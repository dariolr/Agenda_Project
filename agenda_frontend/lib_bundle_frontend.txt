--- FILE: lib/core/l10n/l10_extension.dart ---
import 'package:flutter/widgets.dart';

import 'l10n.dart';

/// üî§ Estensione per accedere facilmente alle stringhe localizzate.
///
/// Permette di scrivere:
/// ```dart
/// Text(context.l10n.welcomeMessage)
/// ```
/// invece di:
/// ```dart
/// Text(L10n.of(context).welcomeMessage)
/// ```
///
/// ‚úÖ Compatibile con aggiornamenti runtime della lingua.
/// ‚úÖ Evita dipendenze da `L10n.current` statico.
/// ‚úÖ Standard consigliato per progetti Flutter internazionalizzati.
extension L10nX on BuildContext {
  /// Restituisce l'istanza corrente di [L10n] per questo [BuildContext].
  L10n get l10n => L10n.of(this);
}

extension DurationLocalization on BuildContext {
  String localizedDurationLabel(int minutes) {
    final hours = minutes ~/ 60;
    final mins = minutes % 60;
    final l10n = this.l10n;

    if (hours > 0 && mins > 0) {
      return l10n.durationHourMinute(hours, mins);
    } else if (hours > 0) {
      return l10n.durationHour(hours);
    } else {
      return l10n.durationMinute(mins);
    }
  }
}
--- FILE: lib/core/l10n/intl/messages_all.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that looks up messages for specific locales by
// delegating to the appropriate library.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:implementation_imports, file_names, unnecessary_new
// ignore_for_file:unnecessary_brace_in_string_interps, directives_ordering
// ignore_for_file:argument_type_not_assignable, invalid_assignment
// ignore_for_file:prefer_single_quotes, prefer_generic_function_type_aliases
// ignore_for_file:comment_references

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';
import 'package:intl/src/intl_helpers.dart';

import 'messages_en.dart' as messages_en;
import 'messages_it.dart' as messages_it;

typedef Future<dynamic> LibraryLoader();
Map<String, LibraryLoader> _deferredLibraries = {
  'en': () => new SynchronousFuture(null),
  'it': () => new SynchronousFuture(null),
};

MessageLookupByLibrary? _findExact(String localeName) {
  switch (localeName) {
    case 'en':
      return messages_en.messages;
    case 'it':
      return messages_it.messages;
    default:
      return null;
  }
}

/// User programs should call this before using [localeName] for messages.
Future<bool> initializeMessages(String localeName) {
  var availableLocale = Intl.verifiedLocale(
    localeName,
    (locale) => _deferredLibraries[locale] != null,
    onFailure: (_) => null,
  );
  if (availableLocale == null) {
    return new SynchronousFuture(false);
  }
  var lib = _deferredLibraries[availableLocale];
  lib == null ? new SynchronousFuture(false) : lib();
  initializeInternalMessageLookup(() => new CompositeMessageLookup());
  messageLookup.addLocale(availableLocale, _findGeneratedMessagesFor);
  return new SynchronousFuture(true);
}

bool _messagesExistFor(String locale) {
  try {
    return _findExact(locale) != null;
  } catch (e) {
    return false;
  }
}

MessageLookupByLibrary? _findGeneratedMessagesFor(String locale) {
  var actualLocale = Intl.verifiedLocale(
    locale,
    _messagesExistFor,
    onFailure: (_) => null,
  );
  if (actualLocale == null) return null;
  return _findExact(actualLocale);
}
--- FILE: lib/core/l10n/intl/messages_it.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that provides messages for a it locale. All the
// messages from the main program should be duplicated here with the same
// function name.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:unnecessary_brace_in_string_interps, unnecessary_new
// ignore_for_file:prefer_single_quotes,comment_references, directives_ordering
// ignore_for_file:annotate_overrides,prefer_generic_function_type_aliases
// ignore_for_file:unused_import, file_names, avoid_escaping_inner_quotes
// ignore_for_file:unnecessary_string_interpolations, unnecessary_string_escapes

import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = new MessageLookup();

typedef String MessageIfAbsent(String messageStr, List<dynamic> args);

class MessageLookup extends MessageLookupByLibrary {
  String get localeName => 'it';

  static String m0(id) => "Codice prenotazione: ${id}";

  static String m1(date) => "Prima disponibilit√†: ${date}";

  static String m2(hours) => "${hours} ora";

  static String m3(hours, minutes) => "${hours} ora ${minutes} min";

  static String m4(minutes) => "${minutes} min";

  static String m5(minutes) => "${minutes} min";

  static String m6(path) => "Pagina non trovata: ${path}";

  static String m7(days) =>
      "${Intl.plural(days, one: 'Modificabile fino a domani', other: 'Modificabile fino a ${days} giorni')}";

  static String m8(hours) =>
      "${Intl.plural(hours, one: 'Modificabile fino a 1 ora', other: 'Modificabile fino a ${hours} ore')}";

  static String m9(minutes) =>
      "${Intl.plural(minutes, one: 'Modificabile fino a 1 minuto', other: 'Modificabile fino a ${minutes} minuti')}";

  static String m10(price) => "‚Ç¨${price}";

  static String m11(duration) => "${duration} min";

  static String m12(price) => "da ${price}";

  static String m13(count) =>
      "${Intl.plural(count, zero: 'Nessun servizio selezionato', one: '1 servizio selezionato', other: '${count} servizi selezionati')}";

  static String m14(total) => "Totale: ${total}";

  final messages = _notInlinedMessages(_notInlinedMessages);
  static Map<String, Function> _notInlinedMessages(_) => <String, Function>{
    "actionBack": MessageLookupByLibrary.simpleMessage("Indietro"),
    "actionCancel": MessageLookupByLibrary.simpleMessage("Annulla"),
    "actionClose": MessageLookupByLibrary.simpleMessage("Chiudi"),
    "actionConfirm": MessageLookupByLibrary.simpleMessage("Conferma"),
    "actionLogin": MessageLookupByLibrary.simpleMessage("Accedi"),
    "actionLogout": MessageLookupByLibrary.simpleMessage("Esci"),
    "actionNext": MessageLookupByLibrary.simpleMessage("Avanti"),
    "actionRegister": MessageLookupByLibrary.simpleMessage("Registrati"),
    "actionRetry": MessageLookupByLibrary.simpleMessage("Riprova"),
    "appTitle": MessageLookupByLibrary.simpleMessage("Prenota Online"),
    "authChangePassword": MessageLookupByLibrary.simpleMessage(
      "Cambia password",
    ),
    "authChangePasswordError": MessageLookupByLibrary.simpleMessage(
      "Password attuale non corretta",
    ),
    "authChangePasswordSuccess": MessageLookupByLibrary.simpleMessage(
      "Password modificata con successo",
    ),
    "authChangePasswordTitle": MessageLookupByLibrary.simpleMessage(
      "Cambia password",
    ),
    "authConfirmPassword": MessageLookupByLibrary.simpleMessage(
      "Conferma password",
    ),
    "authCurrentPassword": MessageLookupByLibrary.simpleMessage(
      "Password attuale",
    ),
    "authEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "authFirstName": MessageLookupByLibrary.simpleMessage("Nome"),
    "authForgotPassword": MessageLookupByLibrary.simpleMessage(
      "Password dimenticata?",
    ),
    "authHaveAccount": MessageLookupByLibrary.simpleMessage(
      "Hai gi√† un account?",
    ),
    "authInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Email non valida",
    ),
    "authInvalidPassword": MessageLookupByLibrary.simpleMessage(
      "Password troppo corta (min. 6 caratteri)",
    ),
    "authInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Numero di telefono non valido",
    ),
    "authLastName": MessageLookupByLibrary.simpleMessage("Cognome"),
    "authLoginFailed": MessageLookupByLibrary.simpleMessage(
      "Credenziali non valide",
    ),
    "authLoginSuccess": MessageLookupByLibrary.simpleMessage(
      "Accesso effettuato",
    ),
    "authLoginTitle": MessageLookupByLibrary.simpleMessage(
      "Accedi al tuo account",
    ),
    "authNewPassword": MessageLookupByLibrary.simpleMessage("Nuova password"),
    "authNoAccount": MessageLookupByLibrary.simpleMessage(
      "Non hai un account?",
    ),
    "authPassword": MessageLookupByLibrary.simpleMessage("Password"),
    "authPasswordMismatch": MessageLookupByLibrary.simpleMessage(
      "Le password non coincidono",
    ),
    "authPasswordRequirements": MessageLookupByLibrary.simpleMessage(
      "La password deve contenere: maiuscola, minuscola, numero",
    ),
    "authPasswordTooShort": MessageLookupByLibrary.simpleMessage(
      "Password troppo corta (min. 8 caratteri)",
    ),
    "authPhone": MessageLookupByLibrary.simpleMessage("Telefono"),
    "authRegisterFailed": MessageLookupByLibrary.simpleMessage(
      "Registrazione fallita",
    ),
    "authRegisterSuccess": MessageLookupByLibrary.simpleMessage(
      "Registrazione completata",
    ),
    "authRegisterTitle": MessageLookupByLibrary.simpleMessage(
      "Crea un nuovo account",
    ),
    "authRequiredField": MessageLookupByLibrary.simpleMessage(
      "Campo obbligatorio",
    ),
    "authResetPasswordConfirmError": MessageLookupByLibrary.simpleMessage(
      "Token non valido o scaduto",
    ),
    "authResetPasswordConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "Inserisci la nuova password",
    ),
    "authResetPasswordConfirmSuccess": MessageLookupByLibrary.simpleMessage(
      "Password reimpostata con successo!",
    ),
    "authResetPasswordConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Reimposta password",
    ),
    "authResetPasswordError": MessageLookupByLibrary.simpleMessage(
      "Errore durante l\'invio. Riprova.",
    ),
    "authResetPasswordMessage": MessageLookupByLibrary.simpleMessage(
      "Inserisci la tua email e ti invieremo le istruzioni per reimpostare la password.",
    ),
    "authResetPasswordSend": MessageLookupByLibrary.simpleMessage("Invia"),
    "authResetPasswordSuccess": MessageLookupByLibrary.simpleMessage(
      "Email inviata! Controlla la tua casella di posta.",
    ),
    "authResetPasswordTitle": MessageLookupByLibrary.simpleMessage(
      "Recupera password",
    ),
    "authWelcome": MessageLookupByLibrary.simpleMessage("Benvenuto"),
    "bookingCancelFailed": MessageLookupByLibrary.simpleMessage(
      "Errore durante l\'annullamento",
    ),
    "bookingCancelled": MessageLookupByLibrary.simpleMessage(
      "Prenotazione annullata con successo",
    ),
    "bookingRescheduled": MessageLookupByLibrary.simpleMessage(
      "Prenotazione riprogrammata con successo",
    ),
    "bookingStepDateTime": MessageLookupByLibrary.simpleMessage("Data e ora"),
    "bookingStepLocation": MessageLookupByLibrary.simpleMessage("Sede"),
    "bookingStepServices": MessageLookupByLibrary.simpleMessage("Servizi"),
    "bookingStepStaff": MessageLookupByLibrary.simpleMessage("Operatore"),
    "bookingStepSummary": MessageLookupByLibrary.simpleMessage("Riepilogo"),
    "bookingTitle": MessageLookupByLibrary.simpleMessage(
      "Prenota appuntamento",
    ),
    "businessNotFound": MessageLookupByLibrary.simpleMessage(
      "Attivit√† non trovata",
    ),
    "businessNotFoundHint": MessageLookupByLibrary.simpleMessage(
      "Verifica l\'indirizzo o contatta direttamente l\'attivit√†.",
    ),
    "cancel": MessageLookupByLibrary.simpleMessage("Annulla"),
    "cancelBookingConfirm": MessageLookupByLibrary.simpleMessage(
      "Sei sicuro di voler annullare questa prenotazione?",
    ),
    "cancelBookingTitle": MessageLookupByLibrary.simpleMessage(
      "Annulla prenotazione",
    ),
    "confirmReschedule": MessageLookupByLibrary.simpleMessage(
      "Conferma modifica",
    ),
    "confirmationBookingId": m0,
    "confirmationGoHome": MessageLookupByLibrary.simpleMessage(
      "Torna alla home",
    ),
    "confirmationNewBooking": MessageLookupByLibrary.simpleMessage(
      "Nuova prenotazione",
    ),
    "confirmationSubtitle": MessageLookupByLibrary.simpleMessage(
      "Ti abbiamo inviato un\'email di conferma",
    ),
    "confirmationTitle": MessageLookupByLibrary.simpleMessage(
      "Prenotazione confermata!",
    ),
    "currentBooking": MessageLookupByLibrary.simpleMessage(
      "Prenotazione attuale",
    ),
    "dateTimeAfternoon": MessageLookupByLibrary.simpleMessage("Pomeriggio"),
    "dateTimeEvening": MessageLookupByLibrary.simpleMessage("Sera"),
    "dateTimeFirstAvailable": m1,
    "dateTimeMorning": MessageLookupByLibrary.simpleMessage("Mattina"),
    "dateTimeNoSlots": MessageLookupByLibrary.simpleMessage(
      "Nessun orario disponibile per questa data",
    ),
    "dateTimeSelectDate": MessageLookupByLibrary.simpleMessage(
      "Seleziona una data",
    ),
    "dateTimeSubtitle": MessageLookupByLibrary.simpleMessage(
      "Seleziona quando desideri prenotare",
    ),
    "dateTimeTitle": MessageLookupByLibrary.simpleMessage("Scegli data e ora"),
    "durationHour": m2,
    "durationHourMinute": m3,
    "durationMinute": m4,
    "durationMinutes": m5,
    "errorBusinessNotActive": MessageLookupByLibrary.simpleMessage(
      "Attivit√† non attiva",
    ),
    "errorBusinessNotActiveSubtitle": MessageLookupByLibrary.simpleMessage(
      "Questa attivit√† non √® ancora configurata per le prenotazioni online. Contatta direttamente l\'attivit√†.",
    ),
    "errorBusinessNotFound": MessageLookupByLibrary.simpleMessage(
      "Attivit√† non trovata",
    ),
    "errorBusinessNotFoundSubtitle": MessageLookupByLibrary.simpleMessage(
      "L\'attivit√† richiesta non esiste. Verifica l\'indirizzo o contatta direttamente l\'attivit√†.",
    ),
    "errorConnectionTimeout": MessageLookupByLibrary.simpleMessage(
      "La connessione sta impiegando troppo tempo. Riprova.",
    ),
    "errorGeneric": MessageLookupByLibrary.simpleMessage(
      "Si √® verificato un errore",
    ),
    "errorLoadingAvailability": MessageLookupByLibrary.simpleMessage(
      "Impossibile caricare le disponibilit√†. Verifica la connessione e riprova.",
    ),
    "errorLoadingBookings": MessageLookupByLibrary.simpleMessage(
      "Errore nel caricamento delle prenotazioni",
    ),
    "errorLoadingServices": MessageLookupByLibrary.simpleMessage(
      "Impossibile caricare i servizi. Verifica la connessione e riprova.",
    ),
    "errorLoadingStaff": MessageLookupByLibrary.simpleMessage(
      "Impossibile caricare gli operatori. Verifica la connessione e riprova.",
    ),
    "errorLocationNotFound": MessageLookupByLibrary.simpleMessage(
      "Sede non disponibile",
    ),
    "errorLocationNotFoundSubtitle": MessageLookupByLibrary.simpleMessage(
      "La sede selezionata non √® attiva. Contatta l\'attivit√† per maggiori informazioni.",
    ),
    "errorNoAvailability": MessageLookupByLibrary.simpleMessage(
      "Nessuna disponibilit√† per la data selezionata",
    ),
    "errorNotFound": m6,
    "errorServiceUnavailable": MessageLookupByLibrary.simpleMessage(
      "Servizio temporaneamente non disponibile",
    ),
    "errorServiceUnavailableSubtitle": MessageLookupByLibrary.simpleMessage(
      "Stiamo lavorando per risolvere il problema. Riprova tra qualche minuto.",
    ),
    "errorTitle": MessageLookupByLibrary.simpleMessage("Errore"),
    "locationEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessuna sede disponibile",
    ),
    "locationSubtitle": MessageLookupByLibrary.simpleMessage(
      "Seleziona dove vuoi effettuare la prenotazione",
    ),
    "locationTitle": MessageLookupByLibrary.simpleMessage("Scegli la sede"),
    "modifiable": MessageLookupByLibrary.simpleMessage("Modificabile"),
    "modifiableUntilDays": m7,
    "modifiableUntilHours": m8,
    "modifiableUntilMinutes": m9,
    "modify": MessageLookupByLibrary.simpleMessage("Modifica"),
    "modifyNotImplemented": MessageLookupByLibrary.simpleMessage(
      "Funzione di modifica in sviluppo",
    ),
    "monthApril": MessageLookupByLibrary.simpleMessage("Aprile"),
    "monthAugust": MessageLookupByLibrary.simpleMessage("Agosto"),
    "monthDecember": MessageLookupByLibrary.simpleMessage("Dicembre"),
    "monthFebruary": MessageLookupByLibrary.simpleMessage("Febbraio"),
    "monthJanuary": MessageLookupByLibrary.simpleMessage("Gennaio"),
    "monthJuly": MessageLookupByLibrary.simpleMessage("Luglio"),
    "monthJune": MessageLookupByLibrary.simpleMessage("Giugno"),
    "monthMarch": MessageLookupByLibrary.simpleMessage("Marzo"),
    "monthMay": MessageLookupByLibrary.simpleMessage("Maggio"),
    "monthNovember": MessageLookupByLibrary.simpleMessage("Novembre"),
    "monthOctober": MessageLookupByLibrary.simpleMessage("Ottobre"),
    "monthSeptember": MessageLookupByLibrary.simpleMessage("Settembre"),
    "myBookings": MessageLookupByLibrary.simpleMessage("Le mie prenotazioni"),
    "no": MessageLookupByLibrary.simpleMessage("No"),
    "noPastBookings": MessageLookupByLibrary.simpleMessage(
      "Non hai prenotazioni passate",
    ),
    "noUpcomingBookings": MessageLookupByLibrary.simpleMessage(
      "Non hai prenotazioni in programma",
    ),
    "notModifiable": MessageLookupByLibrary.simpleMessage("Non modificabile"),
    "pastBookings": MessageLookupByLibrary.simpleMessage("Passate"),
    "priceFormat": m10,
    "profileTitle": MessageLookupByLibrary.simpleMessage("Profilo"),
    "rescheduleBookingTitle": MessageLookupByLibrary.simpleMessage(
      "Riprogramma prenotazione",
    ),
    "selectDate": MessageLookupByLibrary.simpleMessage("Seleziona data"),
    "selectNewDate": MessageLookupByLibrary.simpleMessage(
      "Seleziona nuova data",
    ),
    "selectNewTime": MessageLookupByLibrary.simpleMessage(
      "Seleziona nuovo orario",
    ),
    "servicesDuration": m11,
    "servicesEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessun servizio disponibile al momento",
    ),
    "servicesEmptySubtitle": MessageLookupByLibrary.simpleMessage(
      "Non ci sono servizi prenotabili online per questa attivit√†",
    ),
    "servicesFree": MessageLookupByLibrary.simpleMessage("Gratis"),
    "servicesPriceFrom": m12,
    "servicesSelected": m13,
    "servicesSubtitle": MessageLookupByLibrary.simpleMessage(
      "Puoi selezionare uno o pi√π servizi",
    ),
    "servicesTitle": MessageLookupByLibrary.simpleMessage("Scegli i servizi"),
    "servicesTotal": m14,
    "staffAnyOperator": MessageLookupByLibrary.simpleMessage(
      "Qualsiasi operatore disponibile",
    ),
    "staffAnyOperatorSubtitle": MessageLookupByLibrary.simpleMessage(
      "Ti assegneremo il primo operatore libero",
    ),
    "staffEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessun operatore disponibile al momento",
    ),
    "staffSubtitle": MessageLookupByLibrary.simpleMessage(
      "Seleziona con chi desideri essere servito",
    ),
    "staffTitle": MessageLookupByLibrary.simpleMessage("Scegli l\'operatore"),
    "summaryDateTime": MessageLookupByLibrary.simpleMessage("Data e ora"),
    "summaryDuration": MessageLookupByLibrary.simpleMessage("Durata totale"),
    "summaryNotes": MessageLookupByLibrary.simpleMessage("Note (opzionale)"),
    "summaryNotesHint": MessageLookupByLibrary.simpleMessage(
      "Aggiungi eventuali note per l\'appuntamento...",
    ),
    "summaryOperator": MessageLookupByLibrary.simpleMessage("Operatore"),
    "summaryPrice": MessageLookupByLibrary.simpleMessage("Prezzo totale"),
    "summaryServices": MessageLookupByLibrary.simpleMessage(
      "Servizi selezionati",
    ),
    "summarySubtitle": MessageLookupByLibrary.simpleMessage(
      "Controlla i dettagli prima di confermare",
    ),
    "summaryTitle": MessageLookupByLibrary.simpleMessage(
      "Riepilogo prenotazione",
    ),
    "upcomingBookings": MessageLookupByLibrary.simpleMessage("Prossime"),
    "validationInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Email non valida",
    ),
    "validationInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Telefono non valido",
    ),
    "validationRequired": MessageLookupByLibrary.simpleMessage(
      "Campo obbligatorio",
    ),
    "weekdayFri": MessageLookupByLibrary.simpleMessage("Ven"),
    "weekdayMon": MessageLookupByLibrary.simpleMessage("Lun"),
    "weekdaySat": MessageLookupByLibrary.simpleMessage("Sab"),
    "weekdaySun": MessageLookupByLibrary.simpleMessage("Dom"),
    "weekdayThu": MessageLookupByLibrary.simpleMessage("Gio"),
    "weekdayTue": MessageLookupByLibrary.simpleMessage("Mar"),
    "weekdayWed": MessageLookupByLibrary.simpleMessage("Mer"),
    "yes": MessageLookupByLibrary.simpleMessage("S√¨"),
  };
}
--- FILE: lib/core/l10n/intl/messages_en.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that provides messages for a en locale. All the
// messages from the main program should be duplicated here with the same
// function name.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:unnecessary_brace_in_string_interps, unnecessary_new
// ignore_for_file:prefer_single_quotes,comment_references, directives_ordering
// ignore_for_file:annotate_overrides,prefer_generic_function_type_aliases
// ignore_for_file:unused_import, file_names, avoid_escaping_inner_quotes
// ignore_for_file:unnecessary_string_interpolations, unnecessary_string_escapes

import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = new MessageLookup();

typedef String MessageIfAbsent(String messageStr, List<dynamic> args);

class MessageLookup extends MessageLookupByLibrary {
  String get localeName => 'en';

  static String m0(id) => "Booking code: ${id}";

  static String m1(date) => "First available: ${date}";

  static String m2(hours) => "${hours} hour";

  static String m3(hours, minutes) => "${hours} hour ${minutes} min";

  static String m4(minutes) => "${minutes} min";

  static String m5(minutes) => "${minutes} min";

  static String m6(path) => "Page not found: ${path}";

  static String m7(days) =>
      "${Intl.plural(days, one: 'Modifiable until tomorrow', other: 'Modifiable for ${days} days')}";

  static String m8(hours) =>
      "${Intl.plural(hours, one: 'Modifiable for 1 hour', other: 'Modifiable for ${hours} hours')}";

  static String m9(minutes) =>
      "${Intl.plural(minutes, one: 'Modifiable for 1 minute', other: 'Modifiable for ${minutes} minutes')}";

  static String m10(price) => "‚Ç¨${price}";

  static String m11(duration) => "${duration} min";

  static String m12(price) => "from ${price}";

  static String m13(count) =>
      "${Intl.plural(count, zero: 'No service selected', one: '1 service selected', other: '${count} services selected')}";

  static String m14(total) => "Total: ${total}";

  final messages = _notInlinedMessages(_notInlinedMessages);
  static Map<String, Function> _notInlinedMessages(_) => <String, Function>{
    "actionBack": MessageLookupByLibrary.simpleMessage("Back"),
    "actionCancel": MessageLookupByLibrary.simpleMessage("Cancel"),
    "actionClose": MessageLookupByLibrary.simpleMessage("Close"),
    "actionConfirm": MessageLookupByLibrary.simpleMessage("Confirm"),
    "actionLogin": MessageLookupByLibrary.simpleMessage("Login"),
    "actionLogout": MessageLookupByLibrary.simpleMessage("Logout"),
    "actionNext": MessageLookupByLibrary.simpleMessage("Next"),
    "actionRegister": MessageLookupByLibrary.simpleMessage("Register"),
    "actionRetry": MessageLookupByLibrary.simpleMessage("Retry"),
    "appTitle": MessageLookupByLibrary.simpleMessage("Book Online"),
    "authChangePassword": MessageLookupByLibrary.simpleMessage(
      "Change password",
    ),
    "authChangePasswordError": MessageLookupByLibrary.simpleMessage(
      "Current password is incorrect",
    ),
    "authChangePasswordSuccess": MessageLookupByLibrary.simpleMessage(
      "Password changed successfully",
    ),
    "authChangePasswordTitle": MessageLookupByLibrary.simpleMessage(
      "Change password",
    ),
    "authConfirmPassword": MessageLookupByLibrary.simpleMessage(
      "Confirm password",
    ),
    "authCurrentPassword": MessageLookupByLibrary.simpleMessage(
      "Current password",
    ),
    "authEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "authFirstName": MessageLookupByLibrary.simpleMessage("First name"),
    "authForgotPassword": MessageLookupByLibrary.simpleMessage(
      "Forgot password?",
    ),
    "authHaveAccount": MessageLookupByLibrary.simpleMessage(
      "Already have an account?",
    ),
    "authInvalidEmail": MessageLookupByLibrary.simpleMessage("Invalid email"),
    "authInvalidPassword": MessageLookupByLibrary.simpleMessage(
      "Password too short (min. 6 characters)",
    ),
    "authInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Invalid phone number",
    ),
    "authLastName": MessageLookupByLibrary.simpleMessage("Last name"),
    "authLoginFailed": MessageLookupByLibrary.simpleMessage(
      "Invalid credentials",
    ),
    "authLoginSuccess": MessageLookupByLibrary.simpleMessage(
      "Login successful",
    ),
    "authLoginTitle": MessageLookupByLibrary.simpleMessage(
      "Login to your account",
    ),
    "authNewPassword": MessageLookupByLibrary.simpleMessage("New password"),
    "authNoAccount": MessageLookupByLibrary.simpleMessage(
      "Don\'t have an account?",
    ),
    "authPassword": MessageLookupByLibrary.simpleMessage("Password"),
    "authPasswordMismatch": MessageLookupByLibrary.simpleMessage(
      "Passwords don\'t match",
    ),
    "authPasswordRequirements": MessageLookupByLibrary.simpleMessage(
      "Password must contain: uppercase, lowercase, number",
    ),
    "authPasswordTooShort": MessageLookupByLibrary.simpleMessage(
      "Password too short (min. 8 characters)",
    ),
    "authPhone": MessageLookupByLibrary.simpleMessage("Phone"),
    "authRegisterFailed": MessageLookupByLibrary.simpleMessage(
      "Registration failed",
    ),
    "authRegisterSuccess": MessageLookupByLibrary.simpleMessage(
      "Registration completed",
    ),
    "authRegisterTitle": MessageLookupByLibrary.simpleMessage(
      "Create a new account",
    ),
    "authRequiredField": MessageLookupByLibrary.simpleMessage("Required field"),
    "authResetPasswordConfirmError": MessageLookupByLibrary.simpleMessage(
      "Invalid or expired token",
    ),
    "authResetPasswordConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "Enter your new password",
    ),
    "authResetPasswordConfirmSuccess": MessageLookupByLibrary.simpleMessage(
      "Password reset successful!",
    ),
    "authResetPasswordConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Reset password",
    ),
    "authResetPasswordError": MessageLookupByLibrary.simpleMessage(
      "Error sending email. Please try again.",
    ),
    "authResetPasswordMessage": MessageLookupByLibrary.simpleMessage(
      "Enter your email and we\'ll send you instructions to reset your password.",
    ),
    "authResetPasswordSend": MessageLookupByLibrary.simpleMessage("Send"),
    "authResetPasswordSuccess": MessageLookupByLibrary.simpleMessage(
      "Email sent! Check your inbox.",
    ),
    "authResetPasswordTitle": MessageLookupByLibrary.simpleMessage(
      "Reset password",
    ),
    "authWelcome": MessageLookupByLibrary.simpleMessage("Welcome"),
    "bookingCancelFailed": MessageLookupByLibrary.simpleMessage(
      "Error cancelling booking",
    ),
    "bookingCancelled": MessageLookupByLibrary.simpleMessage(
      "Booking cancelled successfully",
    ),
    "bookingRescheduled": MessageLookupByLibrary.simpleMessage(
      "Booking rescheduled successfully",
    ),
    "bookingStepDateTime": MessageLookupByLibrary.simpleMessage("Date & Time"),
    "bookingStepLocation": MessageLookupByLibrary.simpleMessage("Location"),
    "bookingStepServices": MessageLookupByLibrary.simpleMessage("Services"),
    "bookingStepStaff": MessageLookupByLibrary.simpleMessage("Staff"),
    "bookingStepSummary": MessageLookupByLibrary.simpleMessage("Summary"),
    "bookingTitle": MessageLookupByLibrary.simpleMessage("Book appointment"),
    "businessNotFound": MessageLookupByLibrary.simpleMessage(
      "Business not found",
    ),
    "businessNotFoundHint": MessageLookupByLibrary.simpleMessage(
      "Please check the URL or contact the business directly.",
    ),
    "cancel": MessageLookupByLibrary.simpleMessage("Cancel"),
    "cancelBookingConfirm": MessageLookupByLibrary.simpleMessage(
      "Are you sure you want to cancel this booking?",
    ),
    "cancelBookingTitle": MessageLookupByLibrary.simpleMessage(
      "Cancel booking",
    ),
    "confirmReschedule": MessageLookupByLibrary.simpleMessage(
      "Confirm reschedule",
    ),
    "confirmationBookingId": m0,
    "confirmationGoHome": MessageLookupByLibrary.simpleMessage("Go to home"),
    "confirmationNewBooking": MessageLookupByLibrary.simpleMessage(
      "New booking",
    ),
    "confirmationSubtitle": MessageLookupByLibrary.simpleMessage(
      "We\'ve sent you a confirmation email",
    ),
    "confirmationTitle": MessageLookupByLibrary.simpleMessage(
      "Booking confirmed!",
    ),
    "currentBooking": MessageLookupByLibrary.simpleMessage("Current booking"),
    "dateTimeAfternoon": MessageLookupByLibrary.simpleMessage("Afternoon"),
    "dateTimeEvening": MessageLookupByLibrary.simpleMessage("Evening"),
    "dateTimeFirstAvailable": m1,
    "dateTimeMorning": MessageLookupByLibrary.simpleMessage("Morning"),
    "dateTimeNoSlots": MessageLookupByLibrary.simpleMessage(
      "No time slots available for this date",
    ),
    "dateTimeSelectDate": MessageLookupByLibrary.simpleMessage("Select a date"),
    "dateTimeSubtitle": MessageLookupByLibrary.simpleMessage(
      "Select when you want to book",
    ),
    "dateTimeTitle": MessageLookupByLibrary.simpleMessage(
      "Choose date and time",
    ),
    "durationHour": m2,
    "durationHourMinute": m3,
    "durationMinute": m4,
    "durationMinutes": m5,
    "errorBusinessNotActive": MessageLookupByLibrary.simpleMessage(
      "Business not active",
    ),
    "errorBusinessNotActiveSubtitle": MessageLookupByLibrary.simpleMessage(
      "This business is not yet configured for online bookings. Please contact the business directly.",
    ),
    "errorBusinessNotFound": MessageLookupByLibrary.simpleMessage(
      "Business not found",
    ),
    "errorBusinessNotFoundSubtitle": MessageLookupByLibrary.simpleMessage(
      "The requested business does not exist. Please check the URL or contact the business directly.",
    ),
    "errorConnectionTimeout": MessageLookupByLibrary.simpleMessage(
      "The connection is taking too long. Please try again.",
    ),
    "errorGeneric": MessageLookupByLibrary.simpleMessage("An error occurred"),
    "errorLoadingAvailability": MessageLookupByLibrary.simpleMessage(
      "Unable to load availability. Check your connection and try again.",
    ),
    "errorLoadingBookings": MessageLookupByLibrary.simpleMessage(
      "Error loading bookings",
    ),
    "errorLoadingServices": MessageLookupByLibrary.simpleMessage(
      "Unable to load services. Check your connection and try again.",
    ),
    "errorLoadingStaff": MessageLookupByLibrary.simpleMessage(
      "Unable to load staff. Check your connection and try again.",
    ),
    "errorLocationNotFound": MessageLookupByLibrary.simpleMessage(
      "Location not available",
    ),
    "errorLocationNotFoundSubtitle": MessageLookupByLibrary.simpleMessage(
      "The selected location is not active. Contact the business for more information.",
    ),
    "errorNoAvailability": MessageLookupByLibrary.simpleMessage(
      "No availability for the selected date",
    ),
    "errorNotFound": m6,
    "errorServiceUnavailable": MessageLookupByLibrary.simpleMessage(
      "Service temporarily unavailable",
    ),
    "errorServiceUnavailableSubtitle": MessageLookupByLibrary.simpleMessage(
      "We are working to fix the issue. Please try again in a few minutes.",
    ),
    "errorTitle": MessageLookupByLibrary.simpleMessage("Error"),
    "locationEmpty": MessageLookupByLibrary.simpleMessage(
      "No location available",
    ),
    "locationSubtitle": MessageLookupByLibrary.simpleMessage(
      "Select where you want to book",
    ),
    "locationTitle": MessageLookupByLibrary.simpleMessage("Choose location"),
    "modifiable": MessageLookupByLibrary.simpleMessage("Modifiable"),
    "modifiableUntilDays": m7,
    "modifiableUntilHours": m8,
    "modifiableUntilMinutes": m9,
    "modify": MessageLookupByLibrary.simpleMessage("Modify"),
    "modifyNotImplemented": MessageLookupByLibrary.simpleMessage(
      "Modify feature under development",
    ),
    "monthApril": MessageLookupByLibrary.simpleMessage("April"),
    "monthAugust": MessageLookupByLibrary.simpleMessage("August"),
    "monthDecember": MessageLookupByLibrary.simpleMessage("December"),
    "monthFebruary": MessageLookupByLibrary.simpleMessage("February"),
    "monthJanuary": MessageLookupByLibrary.simpleMessage("January"),
    "monthJuly": MessageLookupByLibrary.simpleMessage("July"),
    "monthJune": MessageLookupByLibrary.simpleMessage("June"),
    "monthMarch": MessageLookupByLibrary.simpleMessage("March"),
    "monthMay": MessageLookupByLibrary.simpleMessage("May"),
    "monthNovember": MessageLookupByLibrary.simpleMessage("November"),
    "monthOctober": MessageLookupByLibrary.simpleMessage("October"),
    "monthSeptember": MessageLookupByLibrary.simpleMessage("September"),
    "myBookings": MessageLookupByLibrary.simpleMessage("My bookings"),
    "no": MessageLookupByLibrary.simpleMessage("No"),
    "noPastBookings": MessageLookupByLibrary.simpleMessage(
      "You have no past bookings",
    ),
    "noUpcomingBookings": MessageLookupByLibrary.simpleMessage(
      "You have no upcoming bookings",
    ),
    "notModifiable": MessageLookupByLibrary.simpleMessage("Not modifiable"),
    "pastBookings": MessageLookupByLibrary.simpleMessage("Past"),
    "priceFormat": m10,
    "profileTitle": MessageLookupByLibrary.simpleMessage("Profile"),
    "rescheduleBookingTitle": MessageLookupByLibrary.simpleMessage(
      "Reschedule booking",
    ),
    "selectDate": MessageLookupByLibrary.simpleMessage("Select date"),
    "selectNewDate": MessageLookupByLibrary.simpleMessage("Select new date"),
    "selectNewTime": MessageLookupByLibrary.simpleMessage("Select new time"),
    "servicesDuration": m11,
    "servicesEmpty": MessageLookupByLibrary.simpleMessage(
      "No services available at the moment",
    ),
    "servicesEmptySubtitle": MessageLookupByLibrary.simpleMessage(
      "There are no services available for online booking at this business",
    ),
    "servicesFree": MessageLookupByLibrary.simpleMessage("Free"),
    "servicesPriceFrom": m12,
    "servicesSelected": m13,
    "servicesSubtitle": MessageLookupByLibrary.simpleMessage(
      "You can select one or more services",
    ),
    "servicesTitle": MessageLookupByLibrary.simpleMessage("Choose services"),
    "servicesTotal": m14,
    "staffAnyOperator": MessageLookupByLibrary.simpleMessage(
      "Any available staff",
    ),
    "staffAnyOperatorSubtitle": MessageLookupByLibrary.simpleMessage(
      "We\'ll assign you the first available staff member",
    ),
    "staffEmpty": MessageLookupByLibrary.simpleMessage(
      "No staff available at the moment",
    ),
    "staffSubtitle": MessageLookupByLibrary.simpleMessage(
      "Select who you want to be served by",
    ),
    "staffTitle": MessageLookupByLibrary.simpleMessage("Choose staff member"),
    "summaryDateTime": MessageLookupByLibrary.simpleMessage("Date and time"),
    "summaryDuration": MessageLookupByLibrary.simpleMessage("Total duration"),
    "summaryNotes": MessageLookupByLibrary.simpleMessage("Notes (optional)"),
    "summaryNotesHint": MessageLookupByLibrary.simpleMessage(
      "Add any notes for the appointment...",
    ),
    "summaryOperator": MessageLookupByLibrary.simpleMessage("Staff member"),
    "summaryPrice": MessageLookupByLibrary.simpleMessage("Total price"),
    "summaryServices": MessageLookupByLibrary.simpleMessage(
      "Selected services",
    ),
    "summarySubtitle": MessageLookupByLibrary.simpleMessage(
      "Review the details before confirming",
    ),
    "summaryTitle": MessageLookupByLibrary.simpleMessage("Booking summary"),
    "upcomingBookings": MessageLookupByLibrary.simpleMessage("Upcoming"),
    "validationInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Invalid email",
    ),
    "validationInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Invalid phone",
    ),
    "validationRequired": MessageLookupByLibrary.simpleMessage(
      "Required field",
    ),
    "weekdayFri": MessageLookupByLibrary.simpleMessage("Fri"),
    "weekdayMon": MessageLookupByLibrary.simpleMessage("Mon"),
    "weekdaySat": MessageLookupByLibrary.simpleMessage("Sat"),
    "weekdaySun": MessageLookupByLibrary.simpleMessage("Sun"),
    "weekdayThu": MessageLookupByLibrary.simpleMessage("Thu"),
    "weekdayTue": MessageLookupByLibrary.simpleMessage("Tue"),
    "weekdayWed": MessageLookupByLibrary.simpleMessage("Wed"),
    "yes": MessageLookupByLibrary.simpleMessage("Yes"),
  };
}
--- FILE: lib/core/l10n/l10n.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'intl/messages_all.dart';

// **************************************************************************
// Generator: Flutter Intl IDE plugin
// Made by Localizely
// **************************************************************************

// ignore_for_file: non_constant_identifier_names, lines_longer_than_80_chars
// ignore_for_file: join_return_with_assignment, prefer_final_in_for_each
// ignore_for_file: avoid_redundant_argument_values, avoid_escaping_inner_quotes

class L10n {
  L10n();

  static L10n? _current;

  static L10n get current {
    assert(
      _current != null,
      'No instance of L10n was loaded. Try to initialize the L10n delegate before accessing L10n.current.',
    );
    return _current!;
  }

  static const AppLocalizationDelegate delegate = AppLocalizationDelegate();

  static Future<L10n> load(Locale locale) {
    final name = (locale.countryCode?.isEmpty ?? false)
        ? locale.languageCode
        : locale.toString();
    final localeName = Intl.canonicalizedLocale(name);
    return initializeMessages(localeName).then((_) {
      Intl.defaultLocale = localeName;
      final instance = L10n();
      L10n._current = instance;

      return instance;
    });
  }

  static L10n of(BuildContext context) {
    final instance = L10n.maybeOf(context);
    assert(
      instance != null,
      'No instance of L10n present in the widget tree. Did you add L10n.delegate in localizationsDelegates?',
    );
    return instance!;
  }

  static L10n? maybeOf(BuildContext context) {
    return Localizations.of<L10n>(context, L10n);
  }

  /// `Prenota Online`
  String get appTitle {
    return Intl.message('Prenota Online', name: 'appTitle', desc: '', args: []);
  }

  /// `Indietro`
  String get actionBack {
    return Intl.message('Indietro', name: 'actionBack', desc: '', args: []);
  }

  /// `Avanti`
  String get actionNext {
    return Intl.message('Avanti', name: 'actionNext', desc: '', args: []);
  }

  /// `Conferma`
  String get actionConfirm {
    return Intl.message('Conferma', name: 'actionConfirm', desc: '', args: []);
  }

  /// `Annulla`
  String get actionCancel {
    return Intl.message('Annulla', name: 'actionCancel', desc: '', args: []);
  }

  /// `Chiudi`
  String get actionClose {
    return Intl.message('Chiudi', name: 'actionClose', desc: '', args: []);
  }

  /// `Riprova`
  String get actionRetry {
    return Intl.message('Riprova', name: 'actionRetry', desc: '', args: []);
  }

  /// `Accedi`
  String get actionLogin {
    return Intl.message('Accedi', name: 'actionLogin', desc: '', args: []);
  }

  /// `Registrati`
  String get actionRegister {
    return Intl.message(
      'Registrati',
      name: 'actionRegister',
      desc: '',
      args: [],
    );
  }

  /// `Esci`
  String get actionLogout {
    return Intl.message('Esci', name: 'actionLogout', desc: '', args: []);
  }

  /// `Errore`
  String get errorTitle {
    return Intl.message('Errore', name: 'errorTitle', desc: '', args: []);
  }

  /// `Si √® verificato un errore`
  String get errorGeneric {
    return Intl.message(
      'Si √® verificato un errore',
      name: 'errorGeneric',
      desc: '',
      args: [],
    );
  }

  /// `Pagina non trovata: {path}`
  String errorNotFound(String path) {
    return Intl.message(
      'Pagina non trovata: $path',
      name: 'errorNotFound',
      desc: '',
      args: [path],
    );
  }

  /// `Nessuna disponibilit√† per la data selezionata`
  String get errorNoAvailability {
    return Intl.message(
      'Nessuna disponibilit√† per la data selezionata',
      name: 'errorNoAvailability',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile caricare i servizi. Verifica la connessione e riprova.`
  String get errorLoadingServices {
    return Intl.message(
      'Impossibile caricare i servizi. Verifica la connessione e riprova.',
      name: 'errorLoadingServices',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile caricare gli operatori. Verifica la connessione e riprova.`
  String get errorLoadingStaff {
    return Intl.message(
      'Impossibile caricare gli operatori. Verifica la connessione e riprova.',
      name: 'errorLoadingStaff',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile caricare le disponibilit√†. Verifica la connessione e riprova.`
  String get errorLoadingAvailability {
    return Intl.message(
      'Impossibile caricare le disponibilit√†. Verifica la connessione e riprova.',
      name: 'errorLoadingAvailability',
      desc: '',
      args: [],
    );
  }

  /// `Nessun servizio disponibile al momento`
  String get servicesEmpty {
    return Intl.message(
      'Nessun servizio disponibile al momento',
      name: 'servicesEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Non ci sono servizi prenotabili online per questa attivit√†`
  String get servicesEmptySubtitle {
    return Intl.message(
      'Non ci sono servizi prenotabili online per questa attivit√†',
      name: 'servicesEmptySubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessun operatore disponibile al momento`
  String get staffEmpty {
    return Intl.message(
      'Nessun operatore disponibile al momento',
      name: 'staffEmpty',
      desc: '',
      args: [],
    );
  }

  /// `La connessione sta impiegando troppo tempo. Riprova.`
  String get errorConnectionTimeout {
    return Intl.message(
      'La connessione sta impiegando troppo tempo. Riprova.',
      name: 'errorConnectionTimeout',
      desc: '',
      args: [],
    );
  }

  /// `Attivit√† non trovata`
  String get errorBusinessNotFound {
    return Intl.message(
      'Attivit√† non trovata',
      name: 'errorBusinessNotFound',
      desc: '',
      args: [],
    );
  }

  /// `L'attivit√† richiesta non esiste. Verifica l'indirizzo o contatta direttamente l'attivit√†.`
  String get errorBusinessNotFoundSubtitle {
    return Intl.message(
      'L\'attivit√† richiesta non esiste. Verifica l\'indirizzo o contatta direttamente l\'attivit√†.',
      name: 'errorBusinessNotFoundSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Attivit√† non attiva`
  String get errorBusinessNotActive {
    return Intl.message(
      'Attivit√† non attiva',
      name: 'errorBusinessNotActive',
      desc: '',
      args: [],
    );
  }

  /// `Questa attivit√† non √® ancora configurata per le prenotazioni online. Contatta direttamente l'attivit√†.`
  String get errorBusinessNotActiveSubtitle {
    return Intl.message(
      'Questa attivit√† non √® ancora configurata per le prenotazioni online. Contatta direttamente l\'attivit√†.',
      name: 'errorBusinessNotActiveSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Sede non disponibile`
  String get errorLocationNotFound {
    return Intl.message(
      'Sede non disponibile',
      name: 'errorLocationNotFound',
      desc: '',
      args: [],
    );
  }

  /// `La sede selezionata non √® attiva. Contatta l'attivit√† per maggiori informazioni.`
  String get errorLocationNotFoundSubtitle {
    return Intl.message(
      'La sede selezionata non √® attiva. Contatta l\'attivit√† per maggiori informazioni.',
      name: 'errorLocationNotFoundSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Servizio temporaneamente non disponibile`
  String get errorServiceUnavailable {
    return Intl.message(
      'Servizio temporaneamente non disponibile',
      name: 'errorServiceUnavailable',
      desc: '',
      args: [],
    );
  }

  /// `Stiamo lavorando per risolvere il problema. Riprova tra qualche minuto.`
  String get errorServiceUnavailableSubtitle {
    return Intl.message(
      'Stiamo lavorando per risolvere il problema. Riprova tra qualche minuto.',
      name: 'errorServiceUnavailableSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Benvenuto`
  String get authWelcome {
    return Intl.message('Benvenuto', name: 'authWelcome', desc: '', args: []);
  }

  /// `Accedi al tuo account`
  String get authLoginTitle {
    return Intl.message(
      'Accedi al tuo account',
      name: 'authLoginTitle',
      desc: '',
      args: [],
    );
  }

  /// `Crea un nuovo account`
  String get authRegisterTitle {
    return Intl.message(
      'Crea un nuovo account',
      name: 'authRegisterTitle',
      desc: '',
      args: [],
    );
  }

  /// `Email`
  String get authEmail {
    return Intl.message('Email', name: 'authEmail', desc: '', args: []);
  }

  /// `Password`
  String get authPassword {
    return Intl.message('Password', name: 'authPassword', desc: '', args: []);
  }

  /// `Conferma password`
  String get authConfirmPassword {
    return Intl.message(
      'Conferma password',
      name: 'authConfirmPassword',
      desc: '',
      args: [],
    );
  }

  /// `Nome`
  String get authFirstName {
    return Intl.message('Nome', name: 'authFirstName', desc: '', args: []);
  }

  /// `Cognome`
  String get authLastName {
    return Intl.message('Cognome', name: 'authLastName', desc: '', args: []);
  }

  /// `Telefono`
  String get authPhone {
    return Intl.message('Telefono', name: 'authPhone', desc: '', args: []);
  }

  /// `Password dimenticata?`
  String get authForgotPassword {
    return Intl.message(
      'Password dimenticata?',
      name: 'authForgotPassword',
      desc: '',
      args: [],
    );
  }

  /// `Non hai un account?`
  String get authNoAccount {
    return Intl.message(
      'Non hai un account?',
      name: 'authNoAccount',
      desc: '',
      args: [],
    );
  }

  /// `Hai gi√† un account?`
  String get authHaveAccount {
    return Intl.message(
      'Hai gi√† un account?',
      name: 'authHaveAccount',
      desc: '',
      args: [],
    );
  }

  /// `Email non valida`
  String get authInvalidEmail {
    return Intl.message(
      'Email non valida',
      name: 'authInvalidEmail',
      desc: '',
      args: [],
    );
  }

  /// `Password troppo corta (min. 6 caratteri)`
  String get authInvalidPassword {
    return Intl.message(
      'Password troppo corta (min. 6 caratteri)',
      name: 'authInvalidPassword',
      desc: '',
      args: [],
    );
  }

  /// `Le password non coincidono`
  String get authPasswordMismatch {
    return Intl.message(
      'Le password non coincidono',
      name: 'authPasswordMismatch',
      desc: '',
      args: [],
    );
  }

  /// `Campo obbligatorio`
  String get authRequiredField {
    return Intl.message(
      'Campo obbligatorio',
      name: 'authRequiredField',
      desc: '',
      args: [],
    );
  }

  /// `Numero di telefono non valido`
  String get authInvalidPhone {
    return Intl.message(
      'Numero di telefono non valido',
      name: 'authInvalidPhone',
      desc: '',
      args: [],
    );
  }

  /// `Accesso effettuato`
  String get authLoginSuccess {
    return Intl.message(
      'Accesso effettuato',
      name: 'authLoginSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Registrazione completata`
  String get authRegisterSuccess {
    return Intl.message(
      'Registrazione completata',
      name: 'authRegisterSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Credenziali non valide`
  String get authLoginFailed {
    return Intl.message(
      'Credenziali non valide',
      name: 'authLoginFailed',
      desc: '',
      args: [],
    );
  }

  /// `Registrazione fallita`
  String get authRegisterFailed {
    return Intl.message(
      'Registrazione fallita',
      name: 'authRegisterFailed',
      desc: '',
      args: [],
    );
  }

  /// `Recupera password`
  String get authResetPasswordTitle {
    return Intl.message(
      'Recupera password',
      name: 'authResetPasswordTitle',
      desc: '',
      args: [],
    );
  }

  /// `Inserisci la tua email e ti invieremo le istruzioni per reimpostare la password.`
  String get authResetPasswordMessage {
    return Intl.message(
      'Inserisci la tua email e ti invieremo le istruzioni per reimpostare la password.',
      name: 'authResetPasswordMessage',
      desc: '',
      args: [],
    );
  }

  /// `Invia`
  String get authResetPasswordSend {
    return Intl.message(
      'Invia',
      name: 'authResetPasswordSend',
      desc: '',
      args: [],
    );
  }

  /// `Email inviata! Controlla la tua casella di posta.`
  String get authResetPasswordSuccess {
    return Intl.message(
      'Email inviata! Controlla la tua casella di posta.',
      name: 'authResetPasswordSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Errore durante l'invio. Riprova.`
  String get authResetPasswordError {
    return Intl.message(
      'Errore durante l\'invio. Riprova.',
      name: 'authResetPasswordError',
      desc: '',
      args: [],
    );
  }

  /// `Reimposta password`
  String get authResetPasswordConfirmTitle {
    return Intl.message(
      'Reimposta password',
      name: 'authResetPasswordConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `Inserisci la nuova password`
  String get authResetPasswordConfirmMessage {
    return Intl.message(
      'Inserisci la nuova password',
      name: 'authResetPasswordConfirmMessage',
      desc: '',
      args: [],
    );
  }

  /// `Nuova password`
  String get authNewPassword {
    return Intl.message(
      'Nuova password',
      name: 'authNewPassword',
      desc: '',
      args: [],
    );
  }

  /// `Password reimpostata con successo!`
  String get authResetPasswordConfirmSuccess {
    return Intl.message(
      'Password reimpostata con successo!',
      name: 'authResetPasswordConfirmSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Token non valido o scaduto`
  String get authResetPasswordConfirmError {
    return Intl.message(
      'Token non valido o scaduto',
      name: 'authResetPasswordConfirmError',
      desc: '',
      args: [],
    );
  }

  /// `Cambia password`
  String get authChangePasswordTitle {
    return Intl.message(
      'Cambia password',
      name: 'authChangePasswordTitle',
      desc: '',
      args: [],
    );
  }

  /// `Password attuale`
  String get authCurrentPassword {
    return Intl.message(
      'Password attuale',
      name: 'authCurrentPassword',
      desc: '',
      args: [],
    );
  }

  /// `Password modificata con successo`
  String get authChangePasswordSuccess {
    return Intl.message(
      'Password modificata con successo',
      name: 'authChangePasswordSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Password attuale non corretta`
  String get authChangePasswordError {
    return Intl.message(
      'Password attuale non corretta',
      name: 'authChangePasswordError',
      desc: '',
      args: [],
    );
  }

  /// `Password troppo corta (min. 8 caratteri)`
  String get authPasswordTooShort {
    return Intl.message(
      'Password troppo corta (min. 8 caratteri)',
      name: 'authPasswordTooShort',
      desc: '',
      args: [],
    );
  }

  /// `La password deve contenere: maiuscola, minuscola, numero`
  String get authPasswordRequirements {
    return Intl.message(
      'La password deve contenere: maiuscola, minuscola, numero',
      name: 'authPasswordRequirements',
      desc: '',
      args: [],
    );
  }

  /// `Cambia password`
  String get authChangePassword {
    return Intl.message(
      'Cambia password',
      name: 'authChangePassword',
      desc: '',
      args: [],
    );
  }

  /// `Profilo`
  String get profileTitle {
    return Intl.message('Profilo', name: 'profileTitle', desc: '', args: []);
  }

  /// `Prenota appuntamento`
  String get bookingTitle {
    return Intl.message(
      'Prenota appuntamento',
      name: 'bookingTitle',
      desc: '',
      args: [],
    );
  }

  /// `Sede`
  String get bookingStepLocation {
    return Intl.message(
      'Sede',
      name: 'bookingStepLocation',
      desc: '',
      args: [],
    );
  }

  /// `Servizi`
  String get bookingStepServices {
    return Intl.message(
      'Servizi',
      name: 'bookingStepServices',
      desc: '',
      args: [],
    );
  }

  /// `Operatore`
  String get bookingStepStaff {
    return Intl.message(
      'Operatore',
      name: 'bookingStepStaff',
      desc: '',
      args: [],
    );
  }

  /// `Data e ora`
  String get bookingStepDateTime {
    return Intl.message(
      'Data e ora',
      name: 'bookingStepDateTime',
      desc: '',
      args: [],
    );
  }

  /// `Riepilogo`
  String get bookingStepSummary {
    return Intl.message(
      'Riepilogo',
      name: 'bookingStepSummary',
      desc: '',
      args: [],
    );
  }

  /// `Scegli la sede`
  String get locationTitle {
    return Intl.message(
      'Scegli la sede',
      name: 'locationTitle',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona dove vuoi effettuare la prenotazione`
  String get locationSubtitle {
    return Intl.message(
      'Seleziona dove vuoi effettuare la prenotazione',
      name: 'locationSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessuna sede disponibile`
  String get locationEmpty {
    return Intl.message(
      'Nessuna sede disponibile',
      name: 'locationEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Scegli i servizi`
  String get servicesTitle {
    return Intl.message(
      'Scegli i servizi',
      name: 'servicesTitle',
      desc: '',
      args: [],
    );
  }

  /// `Puoi selezionare uno o pi√π servizi`
  String get servicesSubtitle {
    return Intl.message(
      'Puoi selezionare uno o pi√π servizi',
      name: 'servicesSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `{count, plural, =0{Nessun servizio selezionato} =1{1 servizio selezionato} other{{count} servizi selezionati}}`
  String servicesSelected(int count) {
    return Intl.plural(
      count,
      zero: 'Nessun servizio selezionato',
      one: '1 servizio selezionato',
      other: '$count servizi selezionati',
      name: 'servicesSelected',
      desc: '',
      args: [count],
    );
  }

  /// `Totale: {total}`
  String servicesTotal(String total) {
    return Intl.message(
      'Totale: $total',
      name: 'servicesTotal',
      desc: '',
      args: [total],
    );
  }

  /// `{duration} min`
  String servicesDuration(int duration) {
    return Intl.message(
      '$duration min',
      name: 'servicesDuration',
      desc: '',
      args: [duration],
    );
  }

  /// `Gratis`
  String get servicesFree {
    return Intl.message('Gratis', name: 'servicesFree', desc: '', args: []);
  }

  /// `da {price}`
  String servicesPriceFrom(String price) {
    return Intl.message(
      'da $price',
      name: 'servicesPriceFrom',
      desc: '',
      args: [price],
    );
  }

  /// `Scegli l'operatore`
  String get staffTitle {
    return Intl.message(
      'Scegli l\'operatore',
      name: 'staffTitle',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona con chi desideri essere servito`
  String get staffSubtitle {
    return Intl.message(
      'Seleziona con chi desideri essere servito',
      name: 'staffSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Qualsiasi operatore disponibile`
  String get staffAnyOperator {
    return Intl.message(
      'Qualsiasi operatore disponibile',
      name: 'staffAnyOperator',
      desc: '',
      args: [],
    );
  }

  /// `Ti assegneremo il primo operatore libero`
  String get staffAnyOperatorSubtitle {
    return Intl.message(
      'Ti assegneremo il primo operatore libero',
      name: 'staffAnyOperatorSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Scegli data e ora`
  String get dateTimeTitle {
    return Intl.message(
      'Scegli data e ora',
      name: 'dateTimeTitle',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona quando desideri prenotare`
  String get dateTimeSubtitle {
    return Intl.message(
      'Seleziona quando desideri prenotare',
      name: 'dateTimeSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Prima disponibilit√†: {date}`
  String dateTimeFirstAvailable(String date) {
    return Intl.message(
      'Prima disponibilit√†: $date',
      name: 'dateTimeFirstAvailable',
      desc: '',
      args: [date],
    );
  }

  /// `Nessun orario disponibile per questa data`
  String get dateTimeNoSlots {
    return Intl.message(
      'Nessun orario disponibile per questa data',
      name: 'dateTimeNoSlots',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona una data`
  String get dateTimeSelectDate {
    return Intl.message(
      'Seleziona una data',
      name: 'dateTimeSelectDate',
      desc: '',
      args: [],
    );
  }

  /// `Mattina`
  String get dateTimeMorning {
    return Intl.message('Mattina', name: 'dateTimeMorning', desc: '', args: []);
  }

  /// `Pomeriggio`
  String get dateTimeAfternoon {
    return Intl.message(
      'Pomeriggio',
      name: 'dateTimeAfternoon',
      desc: '',
      args: [],
    );
  }

  /// `Sera`
  String get dateTimeEvening {
    return Intl.message('Sera', name: 'dateTimeEvening', desc: '', args: []);
  }

  /// `Riepilogo prenotazione`
  String get summaryTitle {
    return Intl.message(
      'Riepilogo prenotazione',
      name: 'summaryTitle',
      desc: '',
      args: [],
    );
  }

  /// `Controlla i dettagli prima di confermare`
  String get summarySubtitle {
    return Intl.message(
      'Controlla i dettagli prima di confermare',
      name: 'summarySubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Servizi selezionati`
  String get summaryServices {
    return Intl.message(
      'Servizi selezionati',
      name: 'summaryServices',
      desc: '',
      args: [],
    );
  }

  /// `Operatore`
  String get summaryOperator {
    return Intl.message(
      'Operatore',
      name: 'summaryOperator',
      desc: '',
      args: [],
    );
  }

  /// `Data e ora`
  String get summaryDateTime {
    return Intl.message(
      'Data e ora',
      name: 'summaryDateTime',
      desc: '',
      args: [],
    );
  }

  /// `Durata totale`
  String get summaryDuration {
    return Intl.message(
      'Durata totale',
      name: 'summaryDuration',
      desc: '',
      args: [],
    );
  }

  /// `Prezzo totale`
  String get summaryPrice {
    return Intl.message(
      'Prezzo totale',
      name: 'summaryPrice',
      desc: '',
      args: [],
    );
  }

  /// `Note (opzionale)`
  String get summaryNotes {
    return Intl.message(
      'Note (opzionale)',
      name: 'summaryNotes',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi eventuali note per l'appuntamento...`
  String get summaryNotesHint {
    return Intl.message(
      'Aggiungi eventuali note per l\'appuntamento...',
      name: 'summaryNotesHint',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione confermata!`
  String get confirmationTitle {
    return Intl.message(
      'Prenotazione confermata!',
      name: 'confirmationTitle',
      desc: '',
      args: [],
    );
  }

  /// `Ti abbiamo inviato un'email di conferma`
  String get confirmationSubtitle {
    return Intl.message(
      'Ti abbiamo inviato un\'email di conferma',
      name: 'confirmationSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Codice prenotazione: {id}`
  String confirmationBookingId(String id) {
    return Intl.message(
      'Codice prenotazione: $id',
      name: 'confirmationBookingId',
      desc: '',
      args: [id],
    );
  }

  /// `Nuova prenotazione`
  String get confirmationNewBooking {
    return Intl.message(
      'Nuova prenotazione',
      name: 'confirmationNewBooking',
      desc: '',
      args: [],
    );
  }

  /// `Torna alla home`
  String get confirmationGoHome {
    return Intl.message(
      'Torna alla home',
      name: 'confirmationGoHome',
      desc: '',
      args: [],
    );
  }

  /// `{minutes} min`
  String durationMinutes(int minutes) {
    return Intl.message(
      '$minutes min',
      name: 'durationMinutes',
      desc: '',
      args: [minutes],
    );
  }

  /// `{minutes} min`
  String durationMinute(int minutes) {
    return Intl.message(
      '$minutes min',
      name: 'durationMinute',
      desc: '',
      args: [minutes],
    );
  }

  /// `{hours} ora`
  String durationHour(int hours) {
    return Intl.message(
      '$hours ora',
      name: 'durationHour',
      desc: '',
      args: [hours],
    );
  }

  /// `{hours} ora {minutes} min`
  String durationHourMinute(int hours, int minutes) {
    return Intl.message(
      '$hours ora $minutes min',
      name: 'durationHourMinute',
      desc: '',
      args: [hours, minutes],
    );
  }

  /// `‚Ç¨{price}`
  String priceFormat(String price) {
    return Intl.message(
      '‚Ç¨$price',
      name: 'priceFormat',
      desc: '',
      args: [price],
    );
  }

  /// `Gennaio`
  String get monthJanuary {
    return Intl.message('Gennaio', name: 'monthJanuary', desc: '', args: []);
  }

  /// `Febbraio`
  String get monthFebruary {
    return Intl.message('Febbraio', name: 'monthFebruary', desc: '', args: []);
  }

  /// `Marzo`
  String get monthMarch {
    return Intl.message('Marzo', name: 'monthMarch', desc: '', args: []);
  }

  /// `Aprile`
  String get monthApril {
    return Intl.message('Aprile', name: 'monthApril', desc: '', args: []);
  }

  /// `Maggio`
  String get monthMay {
    return Intl.message('Maggio', name: 'monthMay', desc: '', args: []);
  }

  /// `Giugno`
  String get monthJune {
    return Intl.message('Giugno', name: 'monthJune', desc: '', args: []);
  }

  /// `Luglio`
  String get monthJuly {
    return Intl.message('Luglio', name: 'monthJuly', desc: '', args: []);
  }

  /// `Agosto`
  String get monthAugust {
    return Intl.message('Agosto', name: 'monthAugust', desc: '', args: []);
  }

  /// `Settembre`
  String get monthSeptember {
    return Intl.message(
      'Settembre',
      name: 'monthSeptember',
      desc: '',
      args: [],
    );
  }

  /// `Ottobre`
  String get monthOctober {
    return Intl.message('Ottobre', name: 'monthOctober', desc: '', args: []);
  }

  /// `Novembre`
  String get monthNovember {
    return Intl.message('Novembre', name: 'monthNovember', desc: '', args: []);
  }

  /// `Dicembre`
  String get monthDecember {
    return Intl.message('Dicembre', name: 'monthDecember', desc: '', args: []);
  }

  /// `Lun`
  String get weekdayMon {
    return Intl.message('Lun', name: 'weekdayMon', desc: '', args: []);
  }

  /// `Mar`
  String get weekdayTue {
    return Intl.message('Mar', name: 'weekdayTue', desc: '', args: []);
  }

  /// `Mer`
  String get weekdayWed {
    return Intl.message('Mer', name: 'weekdayWed', desc: '', args: []);
  }

  /// `Gio`
  String get weekdayThu {
    return Intl.message('Gio', name: 'weekdayThu', desc: '', args: []);
  }

  /// `Ven`
  String get weekdayFri {
    return Intl.message('Ven', name: 'weekdayFri', desc: '', args: []);
  }

  /// `Sab`
  String get weekdaySat {
    return Intl.message('Sab', name: 'weekdaySat', desc: '', args: []);
  }

  /// `Dom`
  String get weekdaySun {
    return Intl.message('Dom', name: 'weekdaySun', desc: '', args: []);
  }

  /// `Le mie prenotazioni`
  String get myBookings {
    return Intl.message(
      'Le mie prenotazioni',
      name: 'myBookings',
      desc: '',
      args: [],
    );
  }

  /// `Prossime`
  String get upcomingBookings {
    return Intl.message(
      'Prossime',
      name: 'upcomingBookings',
      desc: '',
      args: [],
    );
  }

  /// `Passate`
  String get pastBookings {
    return Intl.message('Passate', name: 'pastBookings', desc: '', args: []);
  }

  /// `Non hai prenotazioni in programma`
  String get noUpcomingBookings {
    return Intl.message(
      'Non hai prenotazioni in programma',
      name: 'noUpcomingBookings',
      desc: '',
      args: [],
    );
  }

  /// `Non hai prenotazioni passate`
  String get noPastBookings {
    return Intl.message(
      'Non hai prenotazioni passate',
      name: 'noPastBookings',
      desc: '',
      args: [],
    );
  }

  /// `Errore nel caricamento delle prenotazioni`
  String get errorLoadingBookings {
    return Intl.message(
      'Errore nel caricamento delle prenotazioni',
      name: 'errorLoadingBookings',
      desc: '',
      args: [],
    );
  }

  /// `Modificabile`
  String get modifiable {
    return Intl.message('Modificabile', name: 'modifiable', desc: '', args: []);
  }

  /// `Non modificabile`
  String get notModifiable {
    return Intl.message(
      'Non modificabile',
      name: 'notModifiable',
      desc: '',
      args: [],
    );
  }

  /// `{days, plural, =1{Modificabile fino a domani} other{Modificabile fino a {days} giorni}}`
  String modifiableUntilDays(int days) {
    return Intl.plural(
      days,
      one: 'Modificabile fino a domani',
      other: 'Modificabile fino a $days giorni',
      name: 'modifiableUntilDays',
      desc: '',
      args: [days],
    );
  }

  /// `{hours, plural, =1{Modificabile fino a 1 ora} other{Modificabile fino a {hours} ore}}`
  String modifiableUntilHours(int hours) {
    return Intl.plural(
      hours,
      one: 'Modificabile fino a 1 ora',
      other: 'Modificabile fino a $hours ore',
      name: 'modifiableUntilHours',
      desc: '',
      args: [hours],
    );
  }

  /// `{minutes, plural, =1{Modificabile fino a 1 minuto} other{Modificabile fino a {minutes} minuti}}`
  String modifiableUntilMinutes(int minutes) {
    return Intl.plural(
      minutes,
      one: 'Modificabile fino a 1 minuto',
      other: 'Modificabile fino a $minutes minuti',
      name: 'modifiableUntilMinutes',
      desc: '',
      args: [minutes],
    );
  }

  /// `Modifica`
  String get modify {
    return Intl.message('Modifica', name: 'modify', desc: '', args: []);
  }

  /// `Annulla`
  String get cancel {
    return Intl.message('Annulla', name: 'cancel', desc: '', args: []);
  }

  /// `S√¨`
  String get yes {
    return Intl.message('S√¨', name: 'yes', desc: '', args: []);
  }

  /// `No`
  String get no {
    return Intl.message('No', name: 'no', desc: '', args: []);
  }

  /// `Annulla prenotazione`
  String get cancelBookingTitle {
    return Intl.message(
      'Annulla prenotazione',
      name: 'cancelBookingTitle',
      desc: '',
      args: [],
    );
  }

  /// `Sei sicuro di voler annullare questa prenotazione?`
  String get cancelBookingConfirm {
    return Intl.message(
      'Sei sicuro di voler annullare questa prenotazione?',
      name: 'cancelBookingConfirm',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione annullata con successo`
  String get bookingCancelled {
    return Intl.message(
      'Prenotazione annullata con successo',
      name: 'bookingCancelled',
      desc: '',
      args: [],
    );
  }

  /// `Errore durante l'annullamento`
  String get bookingCancelFailed {
    return Intl.message(
      'Errore durante l\'annullamento',
      name: 'bookingCancelFailed',
      desc: '',
      args: [],
    );
  }

  /// `Funzione di modifica in sviluppo`
  String get modifyNotImplemented {
    return Intl.message(
      'Funzione di modifica in sviluppo',
      name: 'modifyNotImplemented',
      desc: '',
      args: [],
    );
  }

  /// `Riprogramma prenotazione`
  String get rescheduleBookingTitle {
    return Intl.message(
      'Riprogramma prenotazione',
      name: 'rescheduleBookingTitle',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione attuale`
  String get currentBooking {
    return Intl.message(
      'Prenotazione attuale',
      name: 'currentBooking',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona nuova data`
  String get selectNewDate {
    return Intl.message(
      'Seleziona nuova data',
      name: 'selectNewDate',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona data`
  String get selectDate {
    return Intl.message(
      'Seleziona data',
      name: 'selectDate',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona nuovo orario`
  String get selectNewTime {
    return Intl.message(
      'Seleziona nuovo orario',
      name: 'selectNewTime',
      desc: '',
      args: [],
    );
  }

  /// `Conferma modifica`
  String get confirmReschedule {
    return Intl.message(
      'Conferma modifica',
      name: 'confirmReschedule',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione riprogrammata con successo`
  String get bookingRescheduled {
    return Intl.message(
      'Prenotazione riprogrammata con successo',
      name: 'bookingRescheduled',
      desc: '',
      args: [],
    );
  }

  /// `Campo obbligatorio`
  String get validationRequired {
    return Intl.message(
      'Campo obbligatorio',
      name: 'validationRequired',
      desc: '',
      args: [],
    );
  }

  /// `Email non valida`
  String get validationInvalidEmail {
    return Intl.message(
      'Email non valida',
      name: 'validationInvalidEmail',
      desc: '',
      args: [],
    );
  }

  /// `Telefono non valido`
  String get validationInvalidPhone {
    return Intl.message(
      'Telefono non valido',
      name: 'validationInvalidPhone',
      desc: '',
      args: [],
    );
  }

  /// `Attivit√† non trovata`
  String get businessNotFound {
    return Intl.message(
      'Attivit√† non trovata',
      name: 'businessNotFound',
      desc: '',
      args: [],
    );
  }

  /// `Verifica l'indirizzo o contatta direttamente l'attivit√†.`
  String get businessNotFoundHint {
    return Intl.message(
      'Verifica l\'indirizzo o contatta direttamente l\'attivit√†.',
      name: 'businessNotFoundHint',
      desc: '',
      args: [],
    );
  }
}

class AppLocalizationDelegate extends LocalizationsDelegate<L10n> {
  const AppLocalizationDelegate();

  List<Locale> get supportedLocales {
    return const <Locale>[
      Locale.fromSubtags(languageCode: 'it'),
      Locale.fromSubtags(languageCode: 'en'),
    ];
  }

  @override
  bool isSupported(Locale locale) => _isSupported(locale);
  @override
  Future<L10n> load(Locale locale) => L10n.load(locale);
  @override
  bool shouldReload(AppLocalizationDelegate old) => false;

  bool _isSupported(Locale locale) {
    for (var supportedLocale in supportedLocales) {
      if (supportedLocale.languageCode == locale.languageCode) {
        return true;
      }
    }
    return false;
  }
}
--- FILE: lib/core/network/token_storage_mobile.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

import 'token_storage_interface.dart';

/// Implementazione secure storage per mobile/desktop
class SecureTokenStorage implements TokenStorage {
  static const _refreshTokenKey = 'agenda_refresh_token';
  static const _businessIdKey = 'agenda_business_id';

  final FlutterSecureStorage _storage;

  SecureTokenStorage()
    : _storage = const FlutterSecureStorage(
        aOptions: AndroidOptions(encryptedSharedPreferences: true),
        iOptions: IOSOptions(accessibility: KeychainAccessibility.first_unlock),
      );

  @override
  Future<String?> getRefreshToken() async {
    try {
      return await _storage.read(key: _refreshTokenKey);
    } catch (e) {
      debugPrint('TokenStorage: Error reading token: $e');
      return null;
    }
  }

  @override
  Future<void> saveRefreshToken(String token) async {
    try {
      await _storage.write(key: _refreshTokenKey, value: token);
    } catch (e) {
      debugPrint('TokenStorage: Error saving token: $e');
    }
  }

  @override
  Future<void> clearRefreshToken() async {
    try {
      await _storage.delete(key: _refreshTokenKey);
    } catch (e) {
      debugPrint('TokenStorage: Error clearing token: $e');
    }
  }

  @override
  Future<int?> getBusinessId() async {
    try {
      final value = await _storage.read(key: _businessIdKey);
      return value != null ? int.tryParse(value) : null;
    } catch (e) {
      debugPrint('TokenStorage: Error reading businessId: $e');
      return null;
    }
  }

  @override
  Future<void> saveBusinessId(int businessId) async {
    try {
      await _storage.write(key: _businessIdKey, value: businessId.toString());
    } catch (e) {
      debugPrint('TokenStorage: Error saving businessId: $e');
    }
  }

  @override
  Future<void> clearBusinessId() async {
    try {
      await _storage.delete(key: _businessIdKey);
    } catch (e) {
      debugPrint('TokenStorage: Error clearing businessId: $e');
    }
  }
}

/// Factory per creare storage su mobile/desktop
TokenStorage createTokenStorage() => SecureTokenStorage();
--- FILE: lib/core/network/network_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'api_client.dart';
import 'token_storage.dart';

/// Provider per TokenStorage
final tokenStorageProvider = Provider<TokenStorage>((ref) {
  return createTokenStorage();
});

/// Provider per ApiClient
final apiClientProvider = Provider<ApiClient>((ref) {
  final tokenStorage = ref.watch(tokenStorageProvider);
  return ApiClient(tokenStorage: tokenStorage);
});
--- FILE: lib/core/network/api_config.dart ---
/// Configurazione API
class ApiConfig {
  /// Base URL dell'API - configurabile via environment
  /// Default: produzione (https://api.romeolab.it)
  /// Dev locale: --dart-define=API_BASE_URL=http://localhost:8888/agenda_core/public
  static const String baseUrl = String.fromEnvironment(
    'API_BASE_URL',
    defaultValue: 'https://api.romeolab.it',
  );

  /// Location ID di default (per MVP single-location)
  static const int defaultLocationId = 1;

  /// Timeout per le richieste (ridotti per risposta rapida)
  static const Duration connectTimeout = Duration(seconds: 5);
  static const Duration receiveTimeout = Duration(seconds: 5);

  // ========== CUSTOMER AUTH ENDPOINTS ==========
  // Usati dal frontend prenotazioni (agenda_frontend)
  // I clienti usano la tabella 'clients', non 'users'

  /// POST /v1/customer/{business_id}/auth/login
  static String customerLogin(int businessId) =>
      '/v1/customer/$businessId/auth/login';

  /// POST /v1/customer/{business_id}/auth/register
  static String customerRegister(int businessId) =>
      '/v1/customer/$businessId/auth/register';

  /// POST /v1/customer/{business_id}/auth/refresh
  static String customerRefresh(int businessId) =>
      '/v1/customer/$businessId/auth/refresh';

  /// POST /v1/customer/{business_id}/auth/logout
  static String customerLogout(int businessId) =>
      '/v1/customer/$businessId/auth/logout';

  /// POST /v1/customer/{business_id}/auth/forgot-password
  static String customerForgotPassword(int businessId) =>
      '/v1/customer/$businessId/auth/forgot-password';

  /// POST /v1/customer/auth/reset-password
  static const String customerResetPassword =
      '/v1/customer/auth/reset-password';

  /// GET /v1/customer/me
  static const String customerMe = '/v1/customer/me';

  /// PUT /v1/customer/me - Aggiorna profilo cliente
  static const String customerUpdateProfile = '/v1/customer/me';

  /// POST /v1/customer/me/change-password
  static const String customerChangePassword =
      '/v1/customer/me/change-password';

  /// GET /v1/customer/bookings
  static const String customerBookings = '/v1/customer/bookings';

  /// POST /v1/customer/{business_id}/bookings
  static String customerCreateBooking(int businessId) =>
      '/v1/customer/$businessId/bookings';

  // ========== LEGACY AUTH ENDPOINTS (DEPRECATI per frontend) ==========
  // Questi sono per OPERATORI (gestionale), non per clienti
  static const String authLogin = '/v1/auth/login';
  static const String authRegister = '/v1/auth/register';
  static const String authRefresh = '/v1/auth/refresh';
  static const String authLogout = '/v1/auth/logout';
  static const String authForgotPassword = '/v1/auth/forgot-password';
  static const String authResetPassword = '/v1/auth/reset-password';
  static const String authMe = '/v1/me';
  static const String meChangePassword = '/v1/me/change-password';
  static const String meBookings = '/v1/me/bookings';

  // ========== PUBLIC BROWSE ENDPOINTS ==========
  static const String services = '/v1/services';
  static const String staff = '/v1/staff';
  static const String availability = '/v1/availability';

  // ========== STAFF PLANNING ENDPOINTS (read-only) ==========
  /// GET /v1/staff/{id}/plannings - tutti i planning per uno staff
  static String staffPlannings(int staffId) => '/v1/staff/$staffId/plannings';

  /// GET /v1/staff/{id}/planning?date=YYYY-MM-DD - planning valido per data
  static String staffPlanningForDate(int staffId) =>
      '/v1/staff/$staffId/planning';

  /// GET /v1/staff/{id}/planning-availability?date=YYYY-MM-DD - slot disponibili per data
  static String staffPlanningAvailability(int staffId) =>
      '/v1/staff/$staffId/planning-availability';

  // ========== BUSINESS ENDPOINTS ==========
  /// Get business by slug (public, no auth required)
  static String businessBySlug(String slug) => '/v1/businesses/by-slug/$slug';

  /// Get locations for a business (public, no auth required)
  static String businessLocations(int businessId) =>
      '/v1/businesses/$businessId/locations/public';

  // ========== BOOKINGS ENDPOINTS (legacy, per operatori) ==========
  static String bookings(int locationId) =>
      '/v1/locations/$locationId/bookings';
}
--- FILE: lib/core/network/token_storage_web.dart ---
// ignore_for_file: avoid_web_libraries_in_flutter
import 'dart:html' as html;

import 'package:flutter/foundation.dart';

import 'token_storage_interface.dart';

/// Implementazione Web che usa localStorage
/// NOTA: In produzione si dovrebbe preferire cookie httpOnly server-side
class WebTokenStorage implements TokenStorage {
  static const _refreshTokenKey = 'agenda_refresh_token';
  static const _businessIdKey = 'agenda_business_id';

  @override
  Future<String?> getRefreshToken() async {
    try {
      return html.window.localStorage[_refreshTokenKey];
    } catch (e) {
      debugPrint('TokenStorage: Error reading token from localStorage: $e');
      return null;
    }
  }

  @override
  Future<void> saveRefreshToken(String token) async {
    try {
      html.window.localStorage[_refreshTokenKey] = token;
    } catch (e) {
      debugPrint('TokenStorage: Error saving token to localStorage: $e');
    }
  }

  @override
  Future<void> clearRefreshToken() async {
    try {
      html.window.localStorage.remove(_refreshTokenKey);
    } catch (e) {
      debugPrint('TokenStorage: Error clearing token from localStorage: $e');
    }
  }

  @override
  Future<int?> getBusinessId() async {
    try {
      final value = html.window.localStorage[_businessIdKey];
      return value != null ? int.tryParse(value) : null;
    } catch (e) {
      debugPrint(
        'TokenStorage: Error reading businessId from localStorage: $e',
      );
      return null;
    }
  }

  @override
  Future<void> saveBusinessId(int businessId) async {
    try {
      html.window.localStorage[_businessIdKey] = businessId.toString();
    } catch (e) {
      debugPrint('TokenStorage: Error saving businessId to localStorage: $e');
    }
  }

  @override
  Future<void> clearBusinessId() async {
    try {
      html.window.localStorage.remove(_businessIdKey);
    } catch (e) {
      debugPrint(
        'TokenStorage: Error clearing businessId from localStorage: $e',
      );
    }
  }
}

/// Factory per creare storage su Web
TokenStorage createTokenStorage() => WebTokenStorage();
--- FILE: lib/core/network/token_storage_interface.dart ---
/// Gestione storage per refresh token e business ID
/// - Web: localStorage (con considerazioni di sicurezza per production)
/// - Mobile: secure storage
abstract class TokenStorage {
  Future<String?> getRefreshToken();
  Future<void> saveRefreshToken(String token);
  Future<void> clearRefreshToken();

  /// Business ID per customer auth (necessario per refresh token)
  Future<int?> getBusinessId();
  Future<void> saveBusinessId(int businessId);
  Future<void> clearBusinessId();
}
--- FILE: lib/core/network/api_client.dart ---
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';

import 'api_config.dart';
import 'token_storage.dart';

/// Eccezione API custom
class ApiException implements Exception {
  final String code;
  final String message;
  final int statusCode;
  final dynamic details;

  const ApiException({
    required this.code,
    required this.message,
    required this.statusCode,
    this.details,
  });

  bool get isUnauthorized => statusCode == 401;
  bool get isNotFound => statusCode == 404;
  bool get isConflict => statusCode == 409;
  bool get isSlotConflict => code == 'slot_conflict';
  bool get isServiceUnavailable =>
      statusCode == 503 || code == 'database_error';
  bool get isLocationNotFound =>
      isNotFound && message.toLowerCase().contains('location');
  bool get isBusinessNotFound =>
      isNotFound && message.toLowerCase().contains('business');

  @override
  String toString() => 'ApiException($code): $message';
}

/// Client HTTP per comunicare con agenda_core API
/// Usato dal frontend prenotazioni (agenda_frontend) per CLIENTI
class ApiClient {
  final Dio _dio;
  final TokenStorage _tokenStorage;

  String? _accessToken;

  /// Business ID corrente per refresh token
  /// Necessario perch√© l'endpoint di refresh √® business-scoped
  int? _currentBusinessId;

  ApiClient({required TokenStorage tokenStorage, Dio? dio})
    : _tokenStorage = tokenStorage,
      _dio = dio ?? Dio() {
    _dio.options.baseUrl = ApiConfig.baseUrl;
    _dio.options.connectTimeout = ApiConfig.connectTimeout;
    _dio.options.receiveTimeout = ApiConfig.receiveTimeout;
    _dio.options.headers['Content-Type'] = 'application/json';
    _dio.options.headers['Accept'] = 'application/json';

    // Interceptor per logging in debug
    if (kDebugMode) {
      _dio.interceptors.add(
        LogInterceptor(requestBody: true, responseBody: true),
      );
    }

    // Interceptor per auth token
    _dio.interceptors.add(
      InterceptorsWrapper(
        onRequest: (options, handler) {
          if (_accessToken != null) {
            options.headers['Authorization'] = 'Bearer $_accessToken';
          }
          handler.next(options);
        },
        onError: (error, handler) async {
          // Gestione token expired - auto refresh
          if (error.response?.statusCode == 401 &&
              error.response?.data?['error']?['code'] == 'token_expired') {
            try {
              final refreshed = await _refreshToken();
              if (refreshed) {
                // Riprova la richiesta originale
                final opts = error.requestOptions;
                opts.headers['Authorization'] = 'Bearer $_accessToken';
                final response = await _dio.fetch(opts);
                return handler.resolve(response);
              }
            } catch (_) {
              // Refresh fallito, propaga errore originale
            }
          }
          handler.next(error);
        },
      ),
    );
  }

  /// Imposta access token in memoria
  void setAccessToken(String? token) {
    _accessToken = token;
  }

  /// Imposta il business ID corrente (per refresh token)
  void setCurrentBusinessId(int? businessId) {
    _currentBusinessId = businessId;
  }

  /// Verifica se autenticato
  bool get isAuthenticated => _accessToken != null;

  /// Tenta refresh del token (customer)
  Future<bool> _refreshToken() async {
    final refreshToken = await _tokenStorage.getRefreshToken();
    if (refreshToken == null || _currentBusinessId == null) return false;

    try {
      final response = await _dio.post(
        ApiConfig.customerRefresh(_currentBusinessId!),
        data: {'refresh_token': refreshToken},
      );

      if (response.data['success'] == true) {
        final data = response.data['data'];
        _accessToken = data['access_token'];
        await _tokenStorage.saveRefreshToken(data['refresh_token']);
        return true;
      }
    } catch (_) {
      // Token non valido, pulisci storage
      await _tokenStorage.clearRefreshToken();
    }
    return false;
  }

  /// Tenta di ripristinare sessione da refresh token (customer)
  /// Richiede businessId per chiamare l'endpoint corretto
  Future<Map<String, dynamic>?> tryRestoreSession({int? businessId}) async {
    final refreshToken = await _tokenStorage.getRefreshToken();
    if (refreshToken == null) return null;

    // Usa il businessId passato o quello salvato
    final effectiveBusinessId = businessId ?? _currentBusinessId;
    if (effectiveBusinessId == null) return null;

    try {
      final response = await _dio.post(
        ApiConfig.customerRefresh(effectiveBusinessId),
        data: {'refresh_token': refreshToken},
      );

      if (response.data['success'] == true) {
        final data = response.data['data'];
        _accessToken = data['access_token'];
        _currentBusinessId = effectiveBusinessId;
        await _tokenStorage.saveRefreshToken(data['refresh_token']);

        // Fetch customer profile
        return await getCustomerMe();
      }
    } catch (_) {
      await _tokenStorage.clearRefreshToken();
    }
    return null;
  }

  /// Esegue richiesta GET
  Future<Map<String, dynamic>> get(
    String path, {
    Map<String, dynamic>? queryParameters,
  }) async {
    try {
      final response = await _dio.get(path, queryParameters: queryParameters);
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Esegue richiesta POST
  Future<Map<String, dynamic>> post(
    String path, {
    Map<String, dynamic>? data,
    Map<String, String>? headers,
  }) async {
    try {
      final response = await _dio.post(
        path,
        data: data,
        options: headers != null ? Options(headers: headers) : null,
      );
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Esegue richiesta DELETE
  Future<Map<String, dynamic>> delete(
    String path, {
    Map<String, dynamic>? queryParameters,
  }) async {
    try {
      final response = await _dio.delete(
        path,
        queryParameters: queryParameters,
      );
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Esegue richiesta PUT
  Future<Map<String, dynamic>> put(
    String path, {
    Map<String, dynamic>? data,
  }) async {
    try {
      final response = await _dio.put(path, data: data);
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Gestisce risposta API
  Map<String, dynamic> _handleResponse(Response response) {
    final body = response.data as Map<String, dynamic>;
    if (body['success'] == true) {
      return body['data'] as Map<String, dynamic>? ?? {};
    }
    throw ApiException(
      code: body['error']?['code'] ?? 'unknown_error',
      message: body['error']?['message'] ?? 'Unknown error',
      statusCode: response.statusCode ?? 500,
      details: body['error']?['details'],
    );
  }

  /// Gestisce errori Dio
  ApiException _handleError(DioException error) {
    final response = error.response;
    if (response != null) {
      final body = response.data;
      if (body is Map<String, dynamic>) {
        return ApiException(
          code: body['error']?['code'] ?? 'api_error',
          message: body['error']?['message'] ?? error.message ?? 'API Error',
          statusCode: response.statusCode ?? 500,
          details: body['error']?['details'],
        );
      }
    }
    return ApiException(
      code: 'network_error',
      message: error.message ?? 'Network error',
      statusCode: error.response?.statusCode ?? 0,
    );
  }

  // ========== CUSTOMER AUTH ENDPOINTS ==========
  // Usati dal frontend prenotazioni per CLIENTI (tabella clients)

  /// POST /v1/customer/{business_id}/auth/login
  Future<Map<String, dynamic>> customerLogin({
    required int businessId,
    required String email,
    required String password,
  }) async {
    final data = await post(
      ApiConfig.customerLogin(businessId),
      data: {'email': email, 'password': password},
    );

    _accessToken = data['access_token'];
    _currentBusinessId = businessId;
    await _tokenStorage.saveRefreshToken(data['refresh_token']);
    // Salva anche il business ID per restore session
    await _tokenStorage.saveBusinessId(businessId);

    return data;
  }

  /// POST /v1/customer/{business_id}/auth/register
  Future<Map<String, dynamic>> customerRegister({
    required int businessId,
    required String email,
    required String password,
    required String firstName,
    required String lastName,
    String? phone,
  }) async {
    final data = await post(
      ApiConfig.customerRegister(businessId),
      data: {
        'email': email,
        'password': password,
        'first_name': firstName,
        'last_name': lastName,
        if (phone != null) 'phone': phone,
      },
    );

    _accessToken = data['access_token'];
    _currentBusinessId = businessId;
    await _tokenStorage.saveRefreshToken(data['refresh_token']);
    await _tokenStorage.saveBusinessId(businessId);

    return data;
  }

  /// POST /v1/customer/{business_id}/auth/logout
  Future<void> customerLogout({required int businessId}) async {
    final refreshToken = await _tokenStorage.getRefreshToken();
    try {
      await post(
        ApiConfig.customerLogout(businessId),
        data: {'refresh_token': refreshToken},
      );
    } finally {
      _accessToken = null;
      _currentBusinessId = null;
      await _tokenStorage.clearRefreshToken();
      await _tokenStorage.clearBusinessId();
    }
  }

  /// POST /v1/customer/{business_id}/auth/forgot-password
  Future<void> customerForgotPassword({
    required int businessId,
    required String email,
  }) async {
    await post(
      ApiConfig.customerForgotPassword(businessId),
      data: {'email': email},
    );
  }

  /// POST /v1/customer/auth/reset-password
  Future<void> customerResetPassword({
    required String token,
    required String password,
  }) async {
    await post(
      ApiConfig.customerResetPassword,
      data: {'token': token, 'password': password},
    );
  }

  /// GET /v1/customer/me
  Future<Map<String, dynamic>> getCustomerMe() async {
    return get(ApiConfig.customerMe);
  }

  /// PUT /v1/customer/me - Aggiorna profilo cliente
  Future<Map<String, dynamic>> customerUpdateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
  }) async {
    final data = <String, dynamic>{};
    if (firstName != null) data['first_name'] = firstName;
    if (lastName != null) data['last_name'] = lastName;
    if (email != null) data['email'] = email;
    if (phone != null) data['phone'] = phone;

    return put(ApiConfig.customerUpdateProfile, data: data);
  }

  /// POST /v1/customer/me/change-password
  Future<void> customerChangePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    await post(
      ApiConfig.customerChangePassword,
      data: {'current_password': currentPassword, 'new_password': newPassword},
    );
  }

  /// GET /v1/customer/bookings
  Future<Map<String, dynamic>> getCustomerBookings() async {
    return get(ApiConfig.customerBookings);
  }

  /// POST /v1/customer/{business_id}/bookings
  Future<Map<String, dynamic>> createCustomerBooking({
    required int businessId,
    required String idempotencyKey,
    required List<int> serviceIds,
    required String startTime,
    int? staffId,
    String? notes,
  }) async {
    final data = <String, dynamic>{
      'service_ids': serviceIds,
      'start_time': startTime,
    };
    if (staffId != null) {
      data['staff_id'] = staffId;
    }
    if (notes != null && notes.isNotEmpty) {
      data['notes'] = notes;
    }

    return post(
      ApiConfig.customerCreateBooking(businessId),
      data: data,
      headers: {'X-Idempotency-Key': idempotencyKey},
    );
  }

  // ========== LEGACY AUTH ENDPOINTS (per operatori, non usare nel frontend) ==========

  /// POST /v1/auth/login (DEPRECATO - usare customerLogin)
  @Deprecated('Use customerLogin for frontend auth')
  Future<Map<String, dynamic>> login(String email, String password) async {
    final data = await post(
      ApiConfig.authLogin,
      data: {'email': email, 'password': password},
    );

    _accessToken = data['access_token'];
    await _tokenStorage.saveRefreshToken(data['refresh_token']);

    return data;
  }

  /// POST /v1/auth/logout (DEPRECATO - usare customerLogout)
  @Deprecated('Use customerLogout for frontend auth')
  Future<void> logout() async {
    final refreshToken = await _tokenStorage.getRefreshToken();
    try {
      await post(ApiConfig.authLogout, data: {'refresh_token': refreshToken});
    } finally {
      _accessToken = null;
      await _tokenStorage.clearRefreshToken();
    }
  }

  /// GET /v1/me
  Future<Map<String, dynamic>> getMe() async {
    return get(ApiConfig.authMe);
  }

  /// POST /v1/auth/register
  Future<Map<String, dynamic>> register({
    required String email,
    required String password,
    required String name,
    String? phone,
  }) async {
    final data = await post(
      ApiConfig.authRegister,
      data: {
        'email': email,
        'password': password,
        'name': name,
        if (phone != null) 'phone': phone,
      },
    );

    _accessToken = data['access_token'];
    await _tokenStorage.saveRefreshToken(data['refresh_token']);

    return data;
  }

  /// POST /v1/auth/forgot-password
  Future<void> forgotPassword({required String email}) async {
    await post(ApiConfig.authForgotPassword, data: {'email': email});
  }

  /// POST /v1/auth/reset-password
  Future<void> resetPasswordWithToken({
    required String token,
    required String password,
  }) async {
    await post(
      ApiConfig.authResetPassword,
      data: {'token': token, 'password': password},
    );
  }

  /// POST /v1/me/change-password
  Future<void> changePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    await post(
      ApiConfig.meChangePassword,
      data: {'current_password': currentPassword, 'new_password': newPassword},
    );
  }

  /// PUT /v1/me - Aggiorna profilo utente
  Future<Map<String, dynamic>> updateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
  }) async {
    final data = <String, dynamic>{};
    if (firstName != null) data['first_name'] = firstName;
    if (lastName != null) data['last_name'] = lastName;
    if (email != null) data['email'] = email;
    if (phone != null) data['phone'] = phone;

    return put(ApiConfig.authMe, data: data);
  }

  /// GET /v1/me/bookings
  Future<Map<String, dynamic>> getMyBookings() async {
    return get(ApiConfig.meBookings);
  }

  // ========== PUBLIC BROWSE ENDPOINTS ==========

  /// GET /v1/businesses/by-slug/{slug}
  /// Recupera un business dal suo slug (pubblico, no auth)
  Future<Map<String, dynamic>> getBusinessBySlug(String slug) async {
    return get(ApiConfig.businessBySlug(slug));
  }

  /// GET /v1/businesses/{business_id}/locations/public
  /// Recupera le locations di un business (pubblico, per booking flow)
  Future<Map<String, dynamic>> getBusinessLocations(int businessId) async {
    return get(ApiConfig.businessLocations(businessId));
  }

  /// GET /v1/services?location_id=X
  Future<Map<String, dynamic>> getServices(int locationId) async {
    return get(
      ApiConfig.services,
      queryParameters: {'location_id': locationId},
    );
  }

  /// GET /v1/staff?location_id=X
  Future<Map<String, dynamic>> getStaff(int locationId) async {
    return get(ApiConfig.staff, queryParameters: {'location_id': locationId});
  }

  /// GET /v1/availability?location_id=X&date=YYYY-MM-DD&service_ids=1,2&staff_id=N
  Future<Map<String, dynamic>> getAvailability({
    required int locationId,
    required String date,
    required List<int> serviceIds,
    int? staffId,
  }) async {
    final params = <String, dynamic>{
      'location_id': locationId,
      'date': date,
      'service_ids': serviceIds.join(','),
    };
    if (staffId != null) {
      params['staff_id'] = staffId;
    }
    return get(ApiConfig.availability, queryParameters: params);
  }

  // ========== STAFF PLANNING ENDPOINTS (read-only) ==========

  /// GET /v1/staff/{id}/plannings - tutti i planning per uno staff
  Future<Map<String, dynamic>> getStaffPlannings(int staffId) async {
    return get(ApiConfig.staffPlannings(staffId));
  }

  /// GET /v1/staff/{id}/planning?date=YYYY-MM-DD - planning valido per data
  Future<Map<String, dynamic>> getStaffPlanningForDate({
    required int staffId,
    required String date,
  }) async {
    return get(
      ApiConfig.staffPlanningForDate(staffId),
      queryParameters: {'date': date},
    );
  }

  /// GET /v1/staff/{id}/planning-availability?date=YYYY-MM-DD - slot disponibili per data
  /// Ritorna array di slot index (es: [36, 37, 38, 48, 49, 50...])
  Future<Map<String, dynamic>> getStaffPlanningAvailability({
    required int staffId,
    required String date,
  }) async {
    return get(
      ApiConfig.staffPlanningAvailability(staffId),
      queryParameters: {'date': date},
    );
  }

  // ========== BOOKING ENDPOINT ==========

  /// POST /v1/locations/{location_id}/bookings
  Future<Map<String, dynamic>> createBooking({
    required int locationId,
    required String idempotencyKey,
    required List<int> serviceIds,
    required String startTime,
    int? staffId,
    String? notes,
  }) async {
    final data = <String, dynamic>{
      'service_ids': serviceIds,
      'start_time': startTime,
    };
    if (staffId != null) {
      data['staff_id'] = staffId;
    }
    if (notes != null && notes.isNotEmpty) {
      data['notes'] = notes;
    }

    return post(
      ApiConfig.bookings(locationId),
      data: data,
      headers: {'X-Idempotency-Key': idempotencyKey},
    );
  }

  /// DELETE /v1/locations/{location_id}/bookings/{id}
  /// NOTE: Richiede location_id, quindi serve prima recuperare il booking completo
  /// da GET /v1/me/bookings per ottenere il location_id associato
  Future<void> deleteBooking(int locationId, int bookingId) async {
    await delete('/v1/locations/$locationId/bookings/$bookingId');
  }

  /// PUT /v1/locations/{location_id}/bookings/{id}
  /// Reschedule booking (modifica data/ora)
  Future<Map<String, dynamic>> updateBooking({
    required int locationId,
    required int bookingId,
    required String startTime,
    String? notes,
  }) async {
    final data = <String, dynamic>{'start_time': startTime};
    if (notes != null) {
      data['notes'] = notes;
    }

    return await _dio
        .put('/v1/locations/$locationId/bookings/$bookingId', data: data)
        .then((response) => _handleResponse(response))
        .catchError((e) => throw _handleError(e as DioException));
  }
}
--- FILE: lib/core/network/token_storage.dart ---
export 'token_storage_interface.dart';
// Conditional import: web vs mobile/desktop
export 'token_storage_mobile.dart'
    if (dart.library.html) 'token_storage_web.dart';
--- FILE: lib/core/utils/subdomain_resolver.dart ---
/// Utility per risolvere il business slug dall'URL corrente.
///
/// Pattern supportati (in ordine di priorit√†):
/// 1. Sottodominio: {slug}.prenota.tuodominio.it ‚Üí "slug"
/// 2. Path-based: prenota.tuodominio.it/{slug} ‚Üí "slug"
/// 3. Query param: prenota.tuodominio.it?business={slug} ‚Üí "slug"
///
/// Esempio: salonemario.prenota.romeolab.it ‚Üí "salonemario"
/// Esempio: prenota.romeolab.it/salonemario ‚Üí "salonemario"
class SubdomainResolver {
  /// Pattern regex per estrarre lo slug dal sottodominio.
  /// Supporta: {slug}.prenota.{domain} o {slug}.{domain}
  static final RegExp _subdomainPattern = RegExp(
    r'^([a-z0-9][a-z0-9-]*[a-z0-9]|[a-z0-9])\.(?:prenota\.)?',
    caseSensitive: false,
  );

  /// Pattern per validare lo slug (alfanumerico con trattini)
  static final RegExp _slugPattern = RegExp(
    r'^[a-z0-9][a-z0-9-]*[a-z0-9]$|^[a-z0-9]$',
  );

  /// Domini da escludere (non sono slug di business)
  static const _excludedSubdomains = {
    'www',
    'api',
    'admin',
    'gestionale',
    'app',
    'staging',
    'dev',
    'test',
    'localhost',
    'prenota',
  };

  /// Path segments da escludere (non sono slug)
  static const _excludedPaths = {
    '',
    'index.html',
    'booking',
    'login',
    'register',
    'privacy',
    'terms',
  };

  /// Estrae lo slug del business dall'URL corrente.
  ///
  /// Prova in ordine:
  /// 1. Sottodominio: salonemario.prenota.romeolab.it
  /// 2. Path: prenota.romeolab.it/salonemario
  /// 3. Query: prenota.romeolab.it?business=salonemario
  ///
  /// Returns: slug del business o null se non trovato
  static String? getBusinessSlug() {
    try {
      // 1. Prova sottodominio
      final subdomainSlug = _getSlugFromSubdomain();
      if (subdomainSlug != null) {
        return subdomainSlug;
      }

      // 2. Prova path-based (primo segmento del path)
      final pathSlug = _getSlugFromPath();
      if (pathSlug != null) {
        return pathSlug;
      }

      // 3. Prova query parameter
      final querySlug = _getSlugFromQuery();
      if (querySlug != null) {
        return querySlug;
      }

      return null;
    } catch (_) {
      return null;
    }
  }

  /// Estrae slug dal sottodominio
  static String? _getSlugFromSubdomain() {
    final host = Uri.base.host.toLowerCase();

    // Localhost non ha sottodomini
    if (host.startsWith('localhost') || host.startsWith('127.0.0.1')) {
      return null;
    }

    final match = _subdomainPattern.firstMatch(host);
    if (match == null) {
      return null;
    }

    final slug = match.group(1);
    if (slug == null || _excludedSubdomains.contains(slug)) {
      return null;
    }

    return slug;
  }

  /// Estrae slug dal primo segmento del path
  /// Es: prenota.romeolab.it/salonemario ‚Üí "salonemario"
  static String? _getSlugFromPath() {
    final pathSegments = Uri.base.pathSegments;
    if (pathSegments.isEmpty) {
      return null;
    }

    final firstSegment = pathSegments.first.toLowerCase();

    // Verifica che sia un slug valido
    if (_excludedPaths.contains(firstSegment)) {
      return null;
    }

    if (!_slugPattern.hasMatch(firstSegment)) {
      return null;
    }

    return firstSegment;
  }

  /// Estrae slug dal query parameter "business" o "b"
  /// Es: prenota.romeolab.it?business=salonemario ‚Üí "salonemario"
  static String? _getSlugFromQuery() {
    final params = Uri.base.queryParameters;
    final slug = params['business'] ?? params['b'];

    if (slug == null || slug.isEmpty) {
      return null;
    }

    final normalizedSlug = slug.toLowerCase();
    if (!_slugPattern.hasMatch(normalizedSlug)) {
      return null;
    }

    return normalizedSlug;
  }

  /// Verifica se l'URL corrente contiene un business slug.
  static bool isBusinessSubdomain() {
    return getBusinessSlug() != null;
  }

  /// Costruisce l'URL per un business dato il suo slug.
  ///
  /// Usa il formato path-based per compatibilit√† con hosting standard.
  /// Esempio: buildBusinessUrl("salonemario") ‚Üí "https://prenota.romeolab.it/salonemario"
  static String buildBusinessUrl(
    String slug, {
    String baseDomain = 'prenota.romeolab.it',
    bool usePathBased = true,
  }) {
    if (usePathBased) {
      return 'https://$baseDomain/$slug';
    }
    // Formato sottodominio (richiede wildcard SSL)
    return 'https://$slug.$baseDomain';
  }

  /// Ritorna la modalit√† di risoluzione usata per lo slug corrente.
  /// Utile per debug.
  static String? getResolutionMode() {
    if (_getSlugFromSubdomain() != null) return 'subdomain';
    if (_getSlugFromPath() != null) return 'path';
    if (_getSlugFromQuery() != null) return 'query';
    return null;
  }
}
--- FILE: lib/core/models/service_category.dart ---
/// Categoria di servizi
class ServiceCategory {
  final int id;
  final int businessId;
  final String name;
  final String? description;
  final int sortOrder;

  const ServiceCategory({
    required this.id,
    required this.businessId,
    required this.name,
    this.description,
    this.sortOrder = 0,
  });

  ServiceCategory copyWith({
    int? id,
    int? businessId,
    String? name,
    String? description,
    int? sortOrder,
  }) =>
      ServiceCategory(
        id: id ?? this.id,
        businessId: businessId ?? this.businessId,
        name: name ?? this.name,
        description: description ?? this.description,
        sortOrder: sortOrder ?? this.sortOrder,
      );

  factory ServiceCategory.fromJson(Map<String, dynamic> json) =>
      ServiceCategory(
        id: json['id'] as int,
        businessId: json['business_id'] as int,
        name: json['name'] as String,
        description: json['description'] as String?,
        sortOrder: json['sort_order'] as int? ?? 0,
      );

  Map<String, dynamic> toJson() => {
        'id': id,
        'business_id': businessId,
        'name': name,
        if (description != null) 'description': description,
        'sort_order': sortOrder,
      };
}
--- FILE: lib/core/models/user.dart ---
/// Modello utente per l'autenticazione
class User {
  final int id;
  final String email;
  final String firstName;
  final String lastName;
  final String? phone;
  final DateTime createdAt;

  const User({
    required this.id,
    required this.email,
    required this.firstName,
    required this.lastName,
    this.phone,
    required this.createdAt,
  });

  String get fullName => '$firstName $lastName';

  User copyWith({
    int? id,
    String? email,
    String? firstName,
    String? lastName,
    String? phone,
    DateTime? createdAt,
  }) =>
      User(
        id: id ?? this.id,
        email: email ?? this.email,
        firstName: firstName ?? this.firstName,
        lastName: lastName ?? this.lastName,
        phone: phone ?? this.phone,
        createdAt: createdAt ?? this.createdAt,
      );

  factory User.fromJson(Map<String, dynamic> json) => User(
        id: json['id'] as int,
        email: json['email'] as String,
        firstName: json['first_name'] as String,
        lastName: json['last_name'] as String,
        phone: json['phone'] as String?,
        createdAt: DateTime.parse(json['created_at'] as String),
      );

  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'first_name': firstName,
        'last_name': lastName,
        if (phone != null) 'phone': phone,
        'created_at': createdAt.toIso8601String(),
      };
}
--- FILE: lib/core/models/booking_item.dart ---
/// Modello per le prenotazioni utente recuperate da /v1/me/bookings
class BookingItem {
  final int id;
  final int businessId;
  final String businessName;
  final int locationId;
  final String locationName;
  final String? locationAddress;
  final String? locationCity;
  final List<String> serviceNames;
  final List<int> serviceIds;
  final String? staffName;
  final DateTime startTime;
  final DateTime endTime;
  final double totalPrice;
  final String? notes;
  final bool canModify;
  final DateTime? canModifyUntil;
  final String status;

  const BookingItem({
    required this.id,
    required this.businessId,
    required this.businessName,
    required this.locationId,
    required this.locationName,
    this.locationAddress,
    this.locationCity,
    required this.serviceNames,
    this.serviceIds = const [],
    this.staffName,
    required this.startTime,
    required this.endTime,
    this.totalPrice = 0.0,
    this.notes,
    required this.canModify,
    this.canModifyUntil,
    this.status = 'confirmed',
  });

  factory BookingItem.fromJson(Map<String, dynamic> json) {
    // Supporta sia formato nested (location.id) che flat (location_id)
    final location = json['location'] as Map<String, dynamic>?;
    final business = json['business'] as Map<String, dynamic>?;

    return BookingItem(
      id: json['id'] as int? ?? json['booking_id'] as int,
      businessId: business?['id'] as int? ?? json['business_id'] as int,
      businessName:
          business?['name'] as String? ?? json['business_name'] as String,
      locationId: location?['id'] as int? ?? json['location_id'] as int,
      locationName:
          location?['name'] as String? ?? json['location_name'] as String,
      locationAddress:
          location?['address'] as String? ??
          json['location_address'] as String?,
      locationCity:
          location?['city'] as String? ?? json['location_city'] as String?,
      serviceNames: _parseServiceNames(json),
      serviceIds: _parseServiceIds(json),
      staffName: json['staff_name'] as String?,
      startTime: DateTime.parse(json['start_time'] as String),
      endTime: DateTime.parse(json['end_time'] as String),
      totalPrice:
          (json['total_price'] as num?)?.toDouble() ??
          (json['price'] as num?)?.toDouble() ??
          0.0,
      notes: json['notes'] as String?,
      canModify: json['can_modify'] as bool? ?? false,
      canModifyUntil: json['can_modify_until'] != null
          ? DateTime.parse(json['can_modify_until'] as String)
          : null,
      status: json['status'] as String? ?? 'confirmed',
    );
  }

  /// Parsa service_names supportando sia array che singolo valore
  static List<String> _parseServiceNames(Map<String, dynamic> json) {
    // Formato array: service_names: ["Taglio", "Piega"]
    if (json.containsKey('service_names') && json['service_names'] != null) {
      final names = json['service_names'];
      if (names is List) {
        return names.map((e) => e.toString()).toList();
      }
    }
    // Formato singolo: service_name: "Taglio + Piega"
    if (json.containsKey('service_name') && json['service_name'] != null) {
      return [json['service_name'] as String];
    }
    return [];
  }

  /// Parsa service_ids supportando sia array che singolo valore
  static List<int> _parseServiceIds(Map<String, dynamic> json) {
    if (json.containsKey('service_ids') && json['service_ids'] != null) {
      final ids = json['service_ids'];
      if (ids is List) {
        return ids.map((e) => e as int).toList();
      }
    }
    return [];
  }

  /// Stringa formattata dei servizi
  String get servicesDisplay => serviceNames.join(' + ');

  bool get isPast => endTime.isBefore(DateTime.now());
  bool get isUpcoming => !isPast;

  /// Crea copia con nuovi valori (per update locale dopo reschedule)
  BookingItem copyWith({
    DateTime? startTime,
    DateTime? endTime,
    String? notes,
    bool? canModify,
    DateTime? canModifyUntil,
    String? status,
  }) {
    return BookingItem(
      id: id,
      businessId: businessId,
      businessName: businessName,
      locationId: locationId,
      locationName: locationName,
      locationAddress: locationAddress,
      locationCity: locationCity,
      serviceNames: serviceNames,
      serviceIds: serviceIds,
      staffName: staffName,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      totalPrice: totalPrice,
      notes: notes ?? this.notes,
      canModify: canModify ?? this.canModify,
      canModifyUntil: canModifyUntil ?? this.canModifyUntil,
      status: status ?? this.status,
    );
  }
}
--- FILE: lib/core/models/service.dart ---
/// Modello Servizio prenotabile online
class Service {
  final int id;
  final int businessId;
  final int categoryId;
  final String name;
  final String? description;
  final int sortOrder;
  final int durationMinutes;
  final double price;
  final bool isFree;
  final bool isPriceStartingFrom;
  final bool isBookableOnline;

  const Service({
    required this.id,
    required this.businessId,
    required this.categoryId,
    required this.name,
    this.description,
    this.sortOrder = 0,
    required this.durationMinutes,
    required this.price,
    this.isFree = false,
    this.isPriceStartingFrom = false,
    this.isBookableOnline = true,
  });

  Service copyWith({
    int? id,
    int? businessId,
    int? categoryId,
    String? name,
    String? description,
    int? sortOrder,
    int? durationMinutes,
    double? price,
    bool? isFree,
    bool? isPriceStartingFrom,
    bool? isBookableOnline,
  }) => Service(
    id: id ?? this.id,
    businessId: businessId ?? this.businessId,
    categoryId: categoryId ?? this.categoryId,
    name: name ?? this.name,
    description: description ?? this.description,
    sortOrder: sortOrder ?? this.sortOrder,
    durationMinutes: durationMinutes ?? this.durationMinutes,
    price: price ?? this.price,
    isFree: isFree ?? this.isFree,
    isPriceStartingFrom: isPriceStartingFrom ?? this.isPriceStartingFrom,
    isBookableOnline: isBookableOnline ?? this.isBookableOnline,
  );

  factory Service.fromJson(Map<String, dynamic> json) => Service(
    id: json['id'] as int,
    // API pu√≤ usare business_id o derivarlo dalla location
    businessId: json['business_id'] as int? ?? 1,
    categoryId: json['category_id'] as int,
    name: json['name'] as String,
    description: json['description'] as String?,
    sortOrder: json['sort_order'] as int? ?? 0,
    // API ritorna default_duration_minutes o duration_minutes
    durationMinutes:
        json['default_duration_minutes'] as int? ??
        json['duration_minutes'] as int? ??
        30,
    // API ritorna default_price o price
    price:
        (json['default_price'] as num?)?.toDouble() ??
        (json['price'] as num?)?.toDouble() ??
        0.0,
    isFree: json['is_free'] as bool? ?? false,
    isPriceStartingFrom: json['is_price_starting_from'] as bool? ?? false,
    isBookableOnline: json['is_bookable_online'] as bool? ?? true,
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'category_id': categoryId,
    'name': name,
    if (description != null) 'description': description,
    'sort_order': sortOrder,
    'duration_minutes': durationMinutes,
    'price': price,
    'is_free': isFree,
    'is_price_starting_from': isPriceStartingFrom,
    'is_bookable_online': isBookableOnline,
  };

  String get formattedPrice {
    if (isFree) return 'Gratis';
    final priceStr = price.toStringAsFixed(2).replaceAll('.', ',');
    return isPriceStartingFrom ? 'da ‚Ç¨$priceStr' : '‚Ç¨$priceStr';
  }
}
--- FILE: lib/core/models/location.dart ---
import 'package:flutter/foundation.dart';

/// Modello Location (sede)
@immutable
class Location {
  final int id;
  final int businessId;
  final String name;
  final String? address;
  final String? city;
  final String? region;
  final String? country;
  final String? phone;
  final String? email;
  final double? latitude;
  final double? longitude;
  final String? currency;
  final String timezone;
  final bool isDefault;

  const Location({
    required this.id,
    required this.businessId,
    required this.name,
    this.address,
    this.city,
    this.region,
    this.country,
    this.phone,
    this.email,
    this.latitude,
    this.longitude,
    this.currency,
    this.timezone = 'Europe/Rome',
    this.isDefault = false,
  });

  factory Location.fromJson(Map<String, dynamic> json) {
    return Location(
      id: json['id'] as int,
      businessId: json['business_id'] as int,
      name: json['name'] as String,
      address: json['address'] as String?,
      city: json['city'] as String?,
      region: json['region'] as String?,
      country: json['country'] as String?,
      phone: json['phone'] as String?,
      email: json['email'] as String?,
      latitude: json['latitude'] != null
          ? (json['latitude'] as num).toDouble()
          : null,
      longitude: json['longitude'] != null
          ? (json['longitude'] as num).toDouble()
          : null,
      currency: json['currency'] as String?,
      timezone: json['timezone'] as String? ?? 'Europe/Rome',
      isDefault: json['is_default'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'business_id': businessId,
      'name': name,
      'address': address,
      'city': city,
      'region': region,
      'country': country,
      'phone': phone,
      'email': email,
      'latitude': latitude,
      'longitude': longitude,
      'currency': currency,
      'timezone': timezone,
      'is_default': isDefault,
    };
  }

  /// Indirizzo formattato per visualizzazione
  String get formattedAddress {
    final parts = <String>[];
    if (address != null && address!.isNotEmpty) parts.add(address!);
    if (city != null && city!.isNotEmpty) parts.add(city!);
    return parts.join(', ');
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Location && runtimeType == other.runtimeType && id == other.id;

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() => 'Location(id: $id, name: $name, city: $city)';
}
--- FILE: lib/core/models/staff.dart ---
/// Modello Staff/Operatore
class Staff {
  final int id;
  final int businessId;
  final String name;
  final String surname;
  final String? avatarUrl;
  final int sortOrder;
  final bool isBookableOnline;

  const Staff({
    required this.id,
    required this.businessId,
    required this.name,
    required this.surname,
    this.avatarUrl,
    this.sortOrder = 0,
    this.isBookableOnline = true,
  });

  String get displayName {
    if (surname.isEmpty) return name;
    return '$name $surname';
  }

  String get initials {
    final nameInitial = name.isNotEmpty ? name[0].toUpperCase() : '';
    final surnameInitial = surname.isNotEmpty ? surname[0].toUpperCase() : '';
    return '$nameInitial$surnameInitial';
  }

  Staff copyWith({
    int? id,
    int? businessId,
    String? name,
    String? surname,
    String? avatarUrl,
    int? sortOrder,
    bool? isBookableOnline,
  }) =>
      Staff(
        id: id ?? this.id,
        businessId: businessId ?? this.businessId,
        name: name ?? this.name,
        surname: surname ?? this.surname,
        avatarUrl: avatarUrl ?? this.avatarUrl,
        sortOrder: sortOrder ?? this.sortOrder,
        isBookableOnline: isBookableOnline ?? this.isBookableOnline,
      );

  factory Staff.fromJson(Map<String, dynamic> json) => Staff(
        id: json['id'] as int,
        businessId: json['business_id'] as int,
        name: json['name'] as String,
        surname: json['surname'] as String? ?? '',
        avatarUrl: json['avatar_url'] as String?,
        sortOrder: json['sort_order'] as int? ?? 0,
        isBookableOnline: json['is_bookable_online'] as bool? ?? true,
      );

  Map<String, dynamic> toJson() => {
        'id': id,
        'business_id': businessId,
        'name': name,
        'surname': surname,
        if (avatarUrl != null) 'avatar_url': avatarUrl,
        'sort_order': sortOrder,
        'is_bookable_online': isBookableOnline,
      };
}
--- FILE: lib/core/models/time_slot.dart ---
/// Slot temporale disponibile per la prenotazione
class TimeSlot {
  final DateTime startTime;
  final DateTime endTime;
  final int? staffId;

  const TimeSlot({
    required this.startTime,
    required this.endTime,
    this.staffId,
  });

  int get durationMinutes => endTime.difference(startTime).inMinutes;

  String get formattedTime {
    final hour = startTime.hour.toString().padLeft(2, '0');
    final minute = startTime.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }

  TimeSlot copyWith({
    DateTime? startTime,
    DateTime? endTime,
    int? staffId,
  }) =>
      TimeSlot(
        startTime: startTime ?? this.startTime,
        endTime: endTime ?? this.endTime,
        staffId: staffId ?? this.staffId,
      );

  factory TimeSlot.fromJson(Map<String, dynamic> json) => TimeSlot(
        startTime: DateTime.parse(json['start_time'] as String),
        endTime: DateTime.parse(json['end_time'] as String),
        staffId: json['staff_id'] as int?,
      );

  Map<String, dynamic> toJson() => {
        'start_time': startTime.toIso8601String(),
        'end_time': endTime.toIso8601String(),
        if (staffId != null) 'staff_id': staffId,
      };
}
--- FILE: lib/core/models/business.dart ---
import 'package:flutter/foundation.dart';

/// Modello Business
@immutable
class Business {
  final int id;
  final String name;
  final String slug;
  final String? email;
  final String? phone;
  final String timezone;
  final String currency;
  final int? defaultLocationId;

  const Business({
    required this.id,
    required this.name,
    required this.slug,
    this.email,
    this.phone,
    this.timezone = 'Europe/Rome',
    this.currency = 'EUR',
    this.defaultLocationId,
  });

  factory Business.fromJson(Map<String, dynamic> json) {
    return Business(
      id: json['id'] as int,
      name: json['name'] as String,
      slug: json['slug'] as String,
      email: json['email'] as String?,
      phone: json['phone'] as String?,
      timezone: json['timezone'] as String? ?? 'Europe/Rome',
      currency: json['currency'] as String? ?? 'EUR',
      defaultLocationId: json['default_location_id'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'slug': slug,
      'email': email,
      'phone': phone,
      'timezone': timezone,
      'currency': currency,
      'default_location_id': defaultLocationId,
    };
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Business && runtimeType == other.runtimeType && id == other.id;

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() => 'Business(id: $id, name: $name, slug: $slug)';
}
--- FILE: lib/core/models/booking_request.dart ---
import 'service.dart';
import 'staff.dart';
import 'time_slot.dart';

/// Modello per la richiesta di prenotazione
class BookingRequest {
  final List<Service> services;
  final Staff? selectedStaff;
  final TimeSlot? selectedSlot;
  final String? notes;

  const BookingRequest({
    this.services = const [],
    this.selectedStaff,
    this.selectedSlot,
    this.notes,
  });

  /// Durata totale in minuti
  int get totalDurationMinutes =>
      services.fold(0, (sum, s) => sum + s.durationMinutes);

  /// Prezzo totale
  double get totalPrice =>
      services.fold(0.0, (sum, s) => sum + (s.isFree ? 0 : s.price));

  /// Formatta il prezzo totale
  String get formattedTotalPrice {
    if (totalPrice == 0) return 'Gratis';
    return '‚Ç¨${totalPrice.toStringAsFixed(2).replaceAll('.', ',')}';
  }

  /// Verifica se la prenotazione √® completa
  bool get isComplete =>
      services.isNotEmpty && selectedSlot != null;

  BookingRequest copyWith({
    List<Service>? services,
    Staff? selectedStaff,
    TimeSlot? selectedSlot,
    String? notes,
    bool clearStaff = false,
    bool clearSlot = false,
  }) =>
      BookingRequest(
        services: services ?? this.services,
        selectedStaff: clearStaff ? null : (selectedStaff ?? this.selectedStaff),
        selectedSlot: clearSlot ? null : (selectedSlot ?? this.selectedSlot),
        notes: notes ?? this.notes,
      );

  Map<String, dynamic> toJson() => {
        'service_ids': services.map((s) => s.id).toList(),
        if (selectedStaff != null) 'staff_id': selectedStaff!.id,
        if (selectedSlot != null) 'start_time': selectedSlot!.startTime.toIso8601String(),
        if (notes != null && notes!.isNotEmpty) 'notes': notes,
      };
}
--- FILE: lib/app/router.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../core/l10n/l10_extension.dart';
import '../features/auth/presentation/change_password_screen.dart';
import '../features/auth/presentation/login_screen.dart';
import '../features/auth/presentation/profile_screen.dart';
import '../features/auth/presentation/register_screen.dart';
import '../features/auth/presentation/reset_password_screen.dart';
import '../features/auth/providers/auth_provider.dart';
import '../features/booking/presentation/screens/booking_screen.dart';
import '../features/booking/presentation/screens/my_bookings_screen.dart';
import '../features/booking/providers/locations_provider.dart';
import 'providers/route_slug_provider.dart';

/// Router provider con supporto path-based multi-business
///
/// Struttura URL:
/// - /                      ‚Üí Landing page (business non specificato)
/// - /:slug                 ‚Üí Redirect a /:slug/booking
/// - /:slug/booking         ‚Üí Schermata prenotazione
/// - /:slug/login           ‚Üí Login
/// - /:slug/register        ‚Üí Registrazione
/// - /:slug/my-bookings     ‚Üí Le mie prenotazioni
/// - /reset-password/:token ‚Üí Reset password (globale, no slug)
final routerProvider = Provider<GoRouter>((ref) {
  // NOTA: usa ref.read per evitare rebuild del router quando auth cambia
  // Il redirect legge sempre lo stato auth corrente senza causare loop

  return GoRouter(
    initialLocation: '/',
    redirect: (context, state) {
      // Legge auth con ref.read (non ref.watch) per evitare loop
      final isAuthenticated = ref.read(authProvider).isAuthenticated;

      // Filtra segmenti vuoti (trailing slash produce ['slug', ''])
      final pathSegments = state.uri.pathSegments
          .where((s) => s.isNotEmpty)
          .toList();

      // Estrae lo slug dal path (primo segmento se non √® una route riservata)
      String? slug;
      if (pathSegments.isNotEmpty) {
        final firstSegment = pathSegments.first;
        if (!_reservedPaths.contains(firstSegment)) {
          slug = firstSegment;
        }
      }

      debugPrint('üîÄ ROUTER: extracted slug=$slug');

      // Estrae location ID dal query param (?location=4)
      final locationParam = state.uri.queryParameters['location'];
      final urlLocationId = locationParam != null
          ? int.tryParse(locationParam)
          : null;

      // Aggiorna i provider con slug e location correnti
      // Usiamo Future.microtask per evitare modifiche durante il build
      Future.microtask(() {
        ref.read(routeSlugProvider.notifier).state = slug;
        ref.read(urlLocationIdProvider.notifier).state = urlLocationId;
        debugPrint(
          'üîÄ ROUTER: routeSlugProvider updated to $slug, urlLocationId=$urlLocationId',
        );
      });

      // Se siamo su /:slug senza sotto-path, redirect a /:slug/booking (mantieni query params)
      if (slug != null && pathSegments.length == 1) {
        final query = state.uri.query.isNotEmpty ? '?${state.uri.query}' : '';
        debugPrint('üîÄ ROUTER: redirecting to /$slug/booking$query');
        return '/$slug/booking$query';
      }

      // Auth redirect logic per route con slug
      if (slug != null) {
        final subPath = pathSegments.length > 1 ? pathSegments[1] : '';

        // Route protette che richiedono autenticazione
        const protectedRoutes = {'my-bookings', 'profile', 'change-password'};

        // Se non autenticato e cerca di accedere a route protetta, redirect a login
        if (!isAuthenticated && protectedRoutes.contains(subPath)) {
          return '/$slug/login';
        }

        // Se autenticato e cerca di accedere a login/register, redirect a booking
        if (isAuthenticated && (subPath == 'login' || subPath == 'register')) {
          return '/$slug/booking';
        }
      }

      return null;
    },

    routes: [
      // ============================================
      // ROUTE GLOBALI (senza business context)
      // ============================================

      /// Landing page - nessun business specificato
      GoRoute(
        path: '/',
        name: 'landing',
        builder: (context, state) => const _LandingScreen(),
      ),

      /// Reset password (globale, il link viene da email)
      GoRoute(
        path: '/reset-password/:token',
        name: 'reset-password',
        builder: (context, state) {
          final token = state.pathParameters['token'] ?? '';
          return ResetPasswordScreen(token: token);
        },
      ),

      // ============================================
      // ROUTE CON BUSINESS CONTEXT (/:slug/*)
      // ============================================

      /// Prenotazione - route principale del business
      GoRoute(
        path: '/:slug/booking',
        name: 'business-booking',
        builder: (context, state) => const BookingScreen(),
      ),

      /// Login con context business
      GoRoute(
        path: '/:slug/login',
        name: 'business-login',
        builder: (context, state) => const LoginScreen(),
      ),

      /// Registrazione con context business
      GoRoute(
        path: '/:slug/register',
        name: 'business-register',
        builder: (context, state) => const RegisterScreen(),
      ),

      /// Le mie prenotazioni (richiede auth)
      GoRoute(
        path: '/:slug/my-bookings',
        name: 'business-my-bookings',
        builder: (context, state) => const MyBookingsScreen(),
      ),

      /// Cambio password (richiede auth)
      GoRoute(
        path: '/:slug/change-password',
        name: 'business-change-password',
        builder: (context, state) => const ChangePasswordScreen(),
      ),

      /// Profilo utente (richiede auth)
      GoRoute(
        path: '/:slug/profile',
        name: 'business-profile',
        builder: (context, state) => const ProfileScreen(),
      ),

      /// Catch-all per /:slug ‚Üí redirect a /:slug/booking
      /// Gestito nel redirect, ma serve come fallback
      GoRoute(
        path: '/:slug',
        redirect: (context, state) {
          final slug = state.pathParameters['slug'];
          return '/$slug/booking';
        },
      ),
    ],

    errorBuilder: (context, state) => _ErrorScreen(path: state.uri.path),
  );
});

/// Path riservati che NON sono slug di business
const _reservedPaths = {
  'reset-password',
  'login',
  'register',
  'booking',
  'my-bookings',
  'change-password',
  'profile',
  'privacy',
  'terms',
};

/// Schermata landing - nessun business specificato
class _LandingScreen extends ConsumerWidget {
  const _LandingScreen();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;

    return Scaffold(
      body: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.storefront_outlined, size: 64),
            const SizedBox(height: 16),
            Text(
              l10n.businessNotFound,
              style: Theme.of(context).textTheme.titleLarge,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 32),
              child: Text(
                l10n.businessNotFoundHint,
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: Theme.of(
                    context,
                  ).colorScheme.onSurface.withAlpha((0.6 * 255).round()),
                ),
                textAlign: TextAlign.center,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// Schermata errore 404
class _ErrorScreen extends StatelessWidget {
  final String path;

  const _ErrorScreen({required this.path});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.error_outline, size: 64, color: Colors.red),
            const SizedBox(height: 16),
            Text(
              'Pagina non trovata',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: 8),
            Text(
              path,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurface.withAlpha(150),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/app/providers/form_factor_provider.dart ---
import 'dart:ui' as ui;

import 'package:flutter/widgets.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'form_factor_provider.g.dart';

// Definiamo i tre layout che ci interessano
enum AppFormFactor { mobile, tablet, desktop }

AppFormFactor _formFactorForWidth(double width) {
  if (width >= 1024) return AppFormFactor.desktop;
  if (width >= 600) return AppFormFactor.tablet;
  return AppFormFactor.mobile;
}

@riverpod
class FormFactorNotifier extends _$FormFactorNotifier {
  @override
  AppFormFactor build() {
    final binding = WidgetsFlutterBinding.ensureInitialized();
    final dispatcher = binding.platformDispatcher;
    final ui.FlutterView? view = dispatcher.views.isNotEmpty
        ? dispatcher.views.first
        : dispatcher.implicitView;

    if (view != null) {
      final logicalSize = view.physicalSize / view.devicePixelRatio;
      return _formFactorForWidth(logicalSize.width);
    }

    return AppFormFactor.mobile;
  }

  /// Aggiorna il form factor in base alla larghezza dello schermo.
  /// Usa lo stesso breakpoint di 600px che usi nel resto dell'app.
  void update(double screenWidth) {
    final newFactor = _formFactorForWidth(screenWidth);

    // Aggiorna lo stato solo se il form factor cambia
    if (state != newFactor) {
      state = newFactor;
    }
  }
}
--- FILE: lib/app/providers/route_slug_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod/legacy.dart';

/// Provider per lo slug del business estratto dalla route corrente.
///
/// Questo provider viene utilizzato per passare lo slug dal router
/// ai provider che ne hanno bisogno (es. currentBusinessProvider).
///
/// A differenza di SubdomainResolver.getBusinessSlug() che legge Uri.base
/// (statico al caricamento pagina), questo provider viene aggiornato
/// dinamicamente quando la route cambia.
final routeSlugProvider = StateProvider<String?>((ref) => null);

/// Provider per verificare se siamo in una route con business slug
final hasRouteSlugProvider = Provider<bool>((ref) {
  return ref.watch(routeSlugProvider) != null;
});
--- FILE: lib/app/providers/form_factor_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'form_factor_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(FormFactorNotifier)
const formFactorProvider = FormFactorNotifierProvider._();

final class FormFactorNotifierProvider
    extends $NotifierProvider<FormFactorNotifier, AppFormFactor> {
  const FormFactorNotifierProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'formFactorProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$formFactorNotifierHash();

  @$internal
  @override
  FormFactorNotifier create() => FormFactorNotifier();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AppFormFactor value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AppFormFactor>(value),
    );
  }
}

String _$formFactorNotifierHash() =>
    r'c2d345138b8b938ff84a110cd4b6bf3dda7a605e';

abstract class _$FormFactorNotifier extends $Notifier<AppFormFactor> {
  AppFormFactor build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<AppFormFactor, AppFormFactor>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AppFormFactor, AppFormFactor>,
              AppFormFactor,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/app/theme/theme_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'theme.dart';
import 'theme_config.dart';

/// Notifier per gestire il tema dinamico
class ThemeNotifier extends Notifier<AppThemeConfig> {
  @override
  AppThemeConfig build() => const AppThemeConfig(
        seedColor: colorPrimary,
        brightness: Brightness.light,
      );

  void updateSeed(Color color) {
    state = state.copyWith(seedColor: color);
  }

  void toggleBrightness() {
    final newBrightness = state.brightness == Brightness.light
        ? Brightness.dark
        : Brightness.light;
    state = state.copyWith(brightness: newBrightness);
  }
}

/// Provider globale per il tema
final themeNotifierProvider = NotifierProvider<ThemeNotifier, AppThemeConfig>(
  ThemeNotifier.new,
);
--- FILE: lib/app/theme/theme_config.dart ---
import 'package:flutter/material.dart';

class AppThemeConfig {
  final Color seedColor;
  final Brightness brightness;

  const AppThemeConfig({
    required this.seedColor,
    this.brightness = Brightness.light,
  });

  AppThemeConfig copyWith({Color? seedColor, Brightness? brightness}) {
    return AppThemeConfig(
      seedColor: seedColor ?? this.seedColor,
      brightness: brightness ?? this.brightness,
    );
  }
}
--- FILE: lib/app/theme/theme.dart ---
import 'package:flutter/material.dart';

import 'theme_config.dart';

const colorPrimary = Color(0xFF141414);
const colorBackground = Color(0xFFFEFEFE);
const colorAccent = Color(0xFF2196F3);

/// Crea il tema dell'app
ThemeData buildTheme(AppThemeConfig config, Brightness brightness) {
  final isDark = brightness == Brightness.dark;

  final background = isDark ? colorPrimary : colorBackground;
  final onBackground = isDark ? colorBackground : colorPrimary;

  final colorScheme = ColorScheme(
    brightness: brightness,
    primary: colorAccent,
    onPrimary: Colors.white,
    secondary: colorAccent,
    onSecondary: Colors.white,
    error: Colors.red,
    onError: Colors.white,
    surface: background,
    onSurface: onBackground,
  );

  return ThemeData(
    useMaterial3: true,
    colorScheme: colorScheme,
    brightness: brightness,
    scaffoldBackgroundColor: background,
    appBarTheme: AppBarTheme(
      backgroundColor: background,
      foregroundColor: onBackground,
      elevation: 0,
      centerTitle: true,
      surfaceTintColor: Colors.transparent,
    ),
    cardTheme: CardThemeData(
      color: background,
      elevation: 0,
      margin: const EdgeInsets.all(8),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: onBackground.withOpacity(0.1)),
      ),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        backgroundColor: colorAccent,
        foregroundColor: Colors.white,
        minimumSize: const Size(double.infinity, 52),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        elevation: 0,
      ),
    ),
    outlinedButtonTheme: OutlinedButtonThemeData(
      style: OutlinedButton.styleFrom(
        foregroundColor: colorPrimary,
        minimumSize: const Size(double.infinity, 52),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        side: BorderSide(color: colorPrimary.withOpacity(0.2)),
      ),
    ),
    textButtonTheme: TextButtonThemeData(
      style: TextButton.styleFrom(
        foregroundColor: colorAccent,
      ),
    ),
    inputDecorationTheme: InputDecorationTheme(
      filled: true,
      fillColor: onBackground.withOpacity(0.05),
      border: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: BorderSide.none,
      ),
      enabledBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: BorderSide(color: onBackground.withOpacity(0.1)),
      ),
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: colorAccent, width: 2),
      ),
      errorBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: Colors.red),
      ),
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
    ),
    chipTheme: ChipThemeData(
      backgroundColor: colorAccent.withOpacity(0.1),
      selectedColor: colorAccent,
      labelStyle: TextStyle(color: onBackground),
      secondaryLabelStyle: const TextStyle(color: Colors.white),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
    ),
    dividerColor: onBackground.withOpacity(0.1),
    progressIndicatorTheme: const ProgressIndicatorThemeData(
      color: colorAccent,
    ),
  );
}
--- FILE: lib/app/app.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../core/l10n/l10n.dart';
import 'router.dart';
import 'theme/theme.dart';
import 'theme/theme_provider.dart';

class App extends ConsumerWidget {
  const App({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final router = ref.watch(routerProvider);
    final themeConfig = ref.watch(themeNotifierProvider);
    final theme = buildTheme(themeConfig, themeConfig.brightness);

    return MaterialApp.router(
      title: 'Agenda Booking',
      debugShowCheckedModeBanner: false,
      theme: theme,
      routerConfig: router,
      localizationsDelegates: [
        L10n.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: L10n.delegate.supportedLocales,
      locale: const Locale('it'),
    );
  }
}
--- FILE: lib/features/auth/providers/auth_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/network/api_client.dart';
import '../../../core/network/network_providers.dart';
import '../../../core/network/token_storage.dart';
import '../data/auth_repository.dart';
import '../domain/auth_state.dart';

/// Provider per il repository di autenticazione
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return AuthRepository(apiClient);
});

/// Provider per lo stato di autenticazione
final authProvider = NotifierProvider<AuthNotifier, AuthState>(
  AuthNotifier.new,
);

class AuthNotifier extends Notifier<AuthState> {
  @override
  AuthState build() {
    // Tenta ripristino sessione all'avvio
    _tryRestoreSession();
    return AuthState.initial();
  }

  AuthRepository get _repository => ref.read(authRepositoryProvider);

  /// Tenta di ripristinare la sessione da refresh token
  Future<void> _tryRestoreSession() async {
    state = AuthState.loading();
    try {
      // Recupera il businessId salvato
      final tokenStorage = createTokenStorage();
      final savedBusinessId = await tokenStorage.getBusinessId();

      final user = await _repository.tryRestoreSession(
        businessId: savedBusinessId,
      );
      if (user != null) {
        state = AuthState.authenticated(user);
      } else {
        state = AuthState.unauthenticated();
      }
    } catch (e) {
      state = AuthState.unauthenticated();
    }
  }

  /// Login con email e password
  /// Richiede businessId per usare l'endpoint customer corretto
  Future<bool> login({
    required int businessId,
    required String email,
    required String password,
  }) async {
    state = AuthState.loading();
    try {
      final user = await _repository.login(
        businessId: businessId,
        email: email,
        password: password,
      );
      state = AuthState.authenticated(user);
      return true;
    } on ApiException catch (e) {
      state = AuthState.error(e.message);
      return false;
    } catch (e) {
      state = AuthState.error(e.toString());
      return false;
    }
  }

  /// Logout
  Future<void> logout({required int businessId}) async {
    try {
      await _repository.logout(businessId: businessId);
    } finally {
      state = AuthState.unauthenticated();
    }
  }

  /// Registrazione nuovo cliente
  Future<bool> register({
    required int businessId,
    required String email,
    required String password,
    required String firstName,
    required String lastName,
    String? phone,
  }) async {
    state = AuthState.loading();
    try {
      final user = await _repository.register(
        businessId: businessId,
        email: email,
        password: password,
        firstName: firstName,
        lastName: lastName,
        phone: phone,
      );
      state = AuthState.authenticated(user);
      return true;
    } on ApiException catch (e) {
      state = AuthState.error(e.message);
      return false;
    } catch (e) {
      state = AuthState.error(e.toString());
      return false;
    }
  }

  /// Reset password (invia email con link)
  Future<bool> resetPassword({
    required int businessId,
    required String email,
  }) async {
    state = AuthState.loading();
    try {
      await _repository.resetPassword(businessId: businessId, email: email);
      state = AuthState.unauthenticated();
      return true;
    } catch (e) {
      state = AuthState.error(e.toString());
      return false;
    }
  }

  /// Conferma reset password con token
  Future<void> resetPasswordWithToken({
    required String token,
    required String newPassword,
  }) async {
    await _repository.confirmResetPassword(
      token: token,
      newPassword: newPassword,
    );
  }

  /// Cambia password (utente loggato)
  Future<bool> changePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    try {
      await _repository.changePassword(
        currentPassword: currentPassword,
        newPassword: newPassword,
      );
      return true;
    } catch (e) {
      state = AuthState.error(e.toString());
      return false;
    }
  }

  /// Aggiorna il profilo utente
  Future<void> updateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
  }) async {
    final updatedUser = await _repository.updateProfile(
      firstName: firstName,
      lastName: lastName,
      email: email,
      phone: phone,
    );
    state = AuthState.authenticated(updatedUser);
  }

  /// Pulisce errore
  void clearError() {
    state = state.copyWith(clearError: true);
  }

  /// Verifica se √® autenticato
  bool get isAuthenticated => state.isAuthenticated;
}
--- FILE: lib/features/auth/data/auth_repository.dart ---
import '../../../core/models/user.dart';
import '../../../core/network/api_client.dart';

/// Repository per l'autenticazione CUSTOMER - API reale
/// Usa endpoint /v1/customer/{business_id}/auth/* per clienti (tabella clients)
class AuthRepository {
  final ApiClient _apiClient;

  AuthRepository(this._apiClient);

  /// Login cliente
  /// POST /v1/customer/{business_id}/auth/login
  Future<User> login({
    required int businessId,
    required String email,
    required String password,
  }) async {
    final data = await _apiClient.customerLogin(
      businessId: businessId,
      email: email,
      password: password,
    );
    return User.fromJson(data['client'] as Map<String, dynamic>);
  }

  /// Logout cliente
  /// POST /v1/customer/{business_id}/auth/logout
  Future<void> logout({required int businessId}) async {
    await _apiClient.customerLogout(businessId: businessId);
  }

  /// Recupera profilo cliente corrente
  /// GET /v1/customer/me
  Future<User> getCurrentUser() async {
    final data = await _apiClient.getCustomerMe();
    return User.fromJson(data);
  }

  /// Tenta di ripristinare sessione da refresh token
  Future<User?> tryRestoreSession({int? businessId}) async {
    final data = await _apiClient.tryRestoreSession(businessId: businessId);
    if (data != null) {
      return User.fromJson(data);
    }
    return null;
  }

  /// Registrazione nuovo cliente
  /// POST /v1/customer/{business_id}/auth/register
  Future<User> register({
    required int businessId,
    required String email,
    required String password,
    required String firstName,
    required String lastName,
    String? phone,
  }) async {
    final data = await _apiClient.customerRegister(
      businessId: businessId,
      email: email,
      password: password,
      firstName: firstName,
      lastName: lastName,
      phone: phone,
    );
    return User.fromJson(data['client'] as Map<String, dynamic>);
  }

  /// Reset password (invia email con link)
  /// POST /v1/customer/{business_id}/auth/forgot-password
  Future<void> resetPassword({
    required int businessId,
    required String email,
  }) async {
    await _apiClient.customerForgotPassword(
      businessId: businessId,
      email: email,
    );
  }

  /// Conferma reset password con token
  /// POST /v1/customer/auth/reset-password
  Future<void> confirmResetPassword({
    required String token,
    required String newPassword,
  }) async {
    await _apiClient.customerResetPassword(token: token, password: newPassword);
  }

  /// Cambia password (utente loggato)
  /// POST /v1/customer/me/change-password
  Future<void> changePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    await _apiClient.customerChangePassword(
      currentPassword: currentPassword,
      newPassword: newPassword,
    );
  }

  /// Aggiorna profilo cliente
  /// PUT /v1/customer/me
  Future<User> updateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
  }) async {
    final data = await _apiClient.customerUpdateProfile(
      firstName: firstName,
      lastName: lastName,
      email: email,
      phone: phone,
    );
    return User.fromJson(data);
  }
}
--- FILE: lib/features/auth/domain/auth_state.dart ---
import '../../../core/models/user.dart';

/// Stati possibili dell'autenticazione
enum AuthStatus {
  initial,
  loading,
  authenticated,
  unauthenticated,
  error,
}

/// Stato dell'autenticazione
class AuthState {
  final AuthStatus status;
  final User? user;
  final String? errorMessage;

  const AuthState({
    this.status = AuthStatus.initial,
    this.user,
    this.errorMessage,
  });

  bool get isAuthenticated => status == AuthStatus.authenticated && user != null;
  bool get isLoading => status == AuthStatus.loading;

  AuthState copyWith({
    AuthStatus? status,
    User? user,
    String? errorMessage,
    bool clearUser = false,
    bool clearError = false,
  }) =>
      AuthState(
        status: status ?? this.status,
        user: clearUser ? null : (user ?? this.user),
        errorMessage: clearError ? null : (errorMessage ?? this.errorMessage),
      );

  factory AuthState.initial() => const AuthState(status: AuthStatus.initial);
  
  factory AuthState.loading() => const AuthState(status: AuthStatus.loading);
  
  factory AuthState.authenticated(User user) => AuthState(
        status: AuthStatus.authenticated,
        user: user,
      );
  
  factory AuthState.unauthenticated() => const AuthState(
        status: AuthStatus.unauthenticated,
      );
  
  factory AuthState.error(String message) => AuthState(
        status: AuthStatus.error,
        errorMessage: message,
      );
}
--- FILE: lib/features/auth/presentation/profile_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../app/providers/route_slug_provider.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../../core/network/api_client.dart';
import '../providers/auth_provider.dart';

/// Schermata profilo utente per il frontend clienti.
/// Permette di visualizzare e modificare i propri dati.
class ProfileScreen extends ConsumerStatefulWidget {
  const ProfileScreen({super.key});

  @override
  ConsumerState<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends ConsumerState<ProfileScreen> {
  final _formKey = GlobalKey<FormState>();
  late final TextEditingController _firstNameController;
  late final TextEditingController _lastNameController;
  late final TextEditingController _emailController;
  late final TextEditingController _phoneController;

  bool _isLoading = false;
  bool _isEditing = false;
  String? _error;
  String? _success;

  @override
  void initState() {
    super.initState();
    final user = ref.read(authProvider).user;
    _firstNameController = TextEditingController(text: user?.firstName ?? '');
    _lastNameController = TextEditingController(text: user?.lastName ?? '');
    _emailController = TextEditingController(text: user?.email ?? '');
    _phoneController = TextEditingController(text: user?.phone ?? '');
  }

  @override
  void dispose() {
    _firstNameController.dispose();
    _lastNameController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    super.dispose();
  }

  Future<void> _saveChanges() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _error = null;
      _success = null;
    });

    try {
      await ref
          .read(authProvider.notifier)
          .updateProfile(
            firstName: _firstNameController.text.trim(),
            lastName: _lastNameController.text.trim(),
            email: _emailController.text.trim(),
            phone: _phoneController.text.trim().isEmpty
                ? null
                : _phoneController.text.trim(),
          );

      if (mounted) {
        setState(() {
          _isEditing = false;
          _success = 'Profilo aggiornato con successo';
          _isLoading = false;
        });
      }
    } on ApiException catch (e) {
      setState(() {
        _error = e.message;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  void _cancelEditing() {
    final user = ref.read(authProvider).user;
    setState(() {
      _firstNameController.text = user?.firstName ?? '';
      _lastNameController.text = user?.lastName ?? '';
      _emailController.text = user?.email ?? '';
      _phoneController.text = user?.phone ?? '';
      _isEditing = false;
      _error = null;
    });
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final authState = ref.watch(authProvider);
    final user = authState.user;

    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.profileTitle),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.pop(),
        ),
        actions: [
          if (!_isEditing)
            IconButton(
              icon: const Icon(Icons.edit),
              tooltip: 'Modifica',
              onPressed: () => setState(() => _isEditing = true),
            ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(24),
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 500),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // Avatar
                Center(
                  child: CircleAvatar(
                    radius: 50,
                    backgroundColor: colorScheme.primaryContainer,
                    child: Text(
                      _getInitials(user?.firstName, user?.lastName),
                      style: TextStyle(
                        fontSize: 32,
                        fontWeight: FontWeight.bold,
                        color: colorScheme.onPrimaryContainer,
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 24),

                // Messaggi
                if (_success != null) ...[
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: colorScheme.primaryContainer,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Row(
                      children: [
                        Icon(
                          Icons.check_circle,
                          color: colorScheme.onPrimaryContainer,
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            _success!,
                            style: TextStyle(
                              color: colorScheme.onPrimaryContainer,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 16),
                ],

                if (_error != null) ...[
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: colorScheme.errorContainer,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Row(
                      children: [
                        Icon(
                          Icons.error_outline,
                          color: colorScheme.onErrorContainer,
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            _error!,
                            style: TextStyle(
                              color: colorScheme.onErrorContainer,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 16),
                ],

                // Form
                Form(
                  key: _formKey,
                  child: Column(
                    children: [
                      // Nome
                      TextFormField(
                        controller: _firstNameController,
                        enabled: _isEditing,
                        decoration: InputDecoration(
                          labelText: l10n.authFirstName,
                          prefixIcon: const Icon(Icons.person_outline),
                        ),
                        textCapitalization: TextCapitalization.words,
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return l10n.authRequiredField;
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),

                      // Cognome
                      TextFormField(
                        controller: _lastNameController,
                        enabled: _isEditing,
                        decoration: InputDecoration(
                          labelText: l10n.authLastName,
                          prefixIcon: const Icon(Icons.person_outline),
                        ),
                        textCapitalization: TextCapitalization.words,
                      ),
                      const SizedBox(height: 16),

                      // Email
                      TextFormField(
                        controller: _emailController,
                        enabled: _isEditing,
                        decoration: InputDecoration(
                          labelText: l10n.authEmail,
                          prefixIcon: const Icon(Icons.email_outlined),
                          helperText: _isEditing
                              ? 'Attenzione: cambiando email dovrai usarla per il login'
                              : null,
                        ),
                        keyboardType: TextInputType.emailAddress,
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return l10n.authRequiredField;
                          }
                          final emailRegex = RegExp(
                            r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                          );
                          if (!emailRegex.hasMatch(value.trim())) {
                            return l10n.authInvalidEmail;
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),

                      // Telefono
                      TextFormField(
                        controller: _phoneController,
                        enabled: _isEditing,
                        decoration: InputDecoration(
                          labelText: l10n.authPhone,
                          prefixIcon: const Icon(Icons.phone_outlined),
                        ),
                        keyboardType: TextInputType.phone,
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 32),

                // Bottoni
                if (_isEditing) ...[
                  Row(
                    children: [
                      Expanded(
                        child: OutlinedButton(
                          onPressed: _isLoading ? null : _cancelEditing,
                          child: Text(l10n.actionCancel),
                        ),
                      ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: FilledButton(
                          onPressed: _isLoading ? null : _saveChanges,
                          child: _isLoading
                              ? const SizedBox(
                                  width: 20,
                                  height: 20,
                                  child: CircularProgressIndicator(
                                    strokeWidth: 2,
                                  ),
                                )
                              : Text(l10n.actionConfirm),
                        ),
                      ),
                    ],
                  ),
                ] else ...[
                  // Link cambio password
                  OutlinedButton.icon(
                    icon: const Icon(Icons.lock_outline),
                    label: Text(l10n.authChangePassword),
                    onPressed: () {
                      final slug = ref.read(routeSlugProvider);
                      context.push('/$slug/change-password');
                    },
                  ),
                ],
              ],
            ),
          ),
        ),
      ),
    );
  }

  String _getInitials(String? firstName, String? lastName) {
    final first = firstName?.isNotEmpty == true ? firstName![0] : '';
    final last = lastName?.isNotEmpty == true ? lastName![0] : '';
    return '$first$last'.toUpperCase();
  }
}
--- FILE: lib/features/auth/presentation/register_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../app/providers/route_slug_provider.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../booking/providers/business_provider.dart';
import '../providers/auth_provider.dart';

class RegisterScreen extends ConsumerStatefulWidget {
  const RegisterScreen({super.key});

  @override
  ConsumerState<RegisterScreen> createState() => _RegisterScreenState();
}

class _RegisterScreenState extends ConsumerState<RegisterScreen> {
  final _formKey = GlobalKey<FormState>();
  final _firstNameController = TextEditingController();
  final _lastNameController = TextEditingController();
  final _emailController = TextEditingController();
  final _phoneController = TextEditingController();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  bool _obscurePassword = true;
  bool _obscureConfirmPassword = true;

  @override
  void dispose() {
    _firstNameController.dispose();
    _lastNameController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  Future<void> _handleRegister() async {
    if (!_formKey.currentState!.validate()) return;

    // Ottieni il businessId dal provider
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(context.l10n.authLoginFailed),
          backgroundColor: Colors.red,
        ),
      );
      return;
    }

    final success = await ref
        .read(authProvider.notifier)
        .register(
          businessId: businessId,
          email: _emailController.text.trim(),
          password: _passwordController.text,
          firstName: _firstNameController.text.trim(),
          lastName: _lastNameController.text.trim(),
          phone: _phoneController.text.trim().isNotEmpty
              ? _phoneController.text.trim()
              : null,
        );

    if (success && mounted) {
      // Segnala al browser che l'autofill √® completato con successo
      TextInput.finishAutofillContext();
      final slug = ref.read(routeSlugProvider);
      context.go('/$slug/booking');
    }
  }

  @override
  Widget build(BuildContext context) {
    final authState = ref.watch(authProvider);
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.pop(),
        ),
        title: Text(l10n.authRegisterTitle),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: AutofillGroup(
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  const SizedBox(height: 16),

                  // Nome
                  TextFormField(
                    controller: _firstNameController,
                    textInputAction: TextInputAction.next,
                    textCapitalization: TextCapitalization.words,
                    autofillHints: const [AutofillHints.givenName],
                    decoration: InputDecoration(
                      labelText: l10n.authFirstName,
                      prefixIcon: const Icon(Icons.person_outline),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // Cognome
                  TextFormField(
                    controller: _lastNameController,
                    textInputAction: TextInputAction.next,
                    textCapitalization: TextCapitalization.words,
                    autofillHints: const [AutofillHints.familyName],
                    decoration: InputDecoration(
                      labelText: l10n.authLastName,
                      prefixIcon: const Icon(Icons.person_outline),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // Email
                  TextFormField(
                    controller: _emailController,
                    keyboardType: TextInputType.emailAddress,
                    textInputAction: TextInputAction.next,
                    autocorrect: false,
                    enableSuggestions: true,
                    autofillHints: const [AutofillHints.email],
                    decoration: InputDecoration(
                      labelText: l10n.authEmail,
                      prefixIcon: const Icon(Icons.email_outlined),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      if (!value.contains('@')) {
                        return l10n.authInvalidEmail;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // Telefono (opzionale)
                  TextFormField(
                    controller: _phoneController,
                    keyboardType: TextInputType.phone,
                    textInputAction: TextInputAction.next,
                    autofillHints: const [AutofillHints.telephoneNumber],
                    decoration: InputDecoration(
                      labelText: '${l10n.authPhone} (opzionale)',
                      prefixIcon: const Icon(Icons.phone_outlined),
                    ),
                  ),
                  const SizedBox(height: 16),

                  // Password
                  TextFormField(
                    controller: _passwordController,
                    obscureText: _obscurePassword,
                    textInputAction: TextInputAction.next,
                    enableSuggestions: false,
                    autocorrect: false,
                    autofillHints: const [AutofillHints.newPassword],
                    decoration: InputDecoration(
                      labelText: l10n.authPassword,
                      prefixIcon: const Icon(Icons.lock_outlined),
                      suffixIcon: IconButton(
                        icon: Icon(
                          _obscurePassword
                              ? Icons.visibility_outlined
                              : Icons.visibility_off_outlined,
                        ),
                        onPressed: () {
                          setState(() => _obscurePassword = !_obscurePassword);
                        },
                      ),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      if (value.length < 6) {
                        return l10n.authInvalidPassword;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // Conferma Password
                  TextFormField(
                    controller: _confirmPasswordController,
                    obscureText: _obscureConfirmPassword,
                    textInputAction: TextInputAction.done,
                    onFieldSubmitted: (_) => _handleRegister(),
                    decoration: InputDecoration(
                      labelText: l10n.authConfirmPassword,
                      prefixIcon: const Icon(Icons.lock_outlined),
                      suffixIcon: IconButton(
                        icon: Icon(
                          _obscureConfirmPassword
                              ? Icons.visibility_outlined
                              : Icons.visibility_off_outlined,
                        ),
                        onPressed: () {
                          setState(
                            () => _obscureConfirmPassword =
                                !_obscureConfirmPassword,
                          );
                        },
                      ),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      if (value != _passwordController.text) {
                        return l10n.authPasswordMismatch;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 24),

                  // Errore
                  if (authState.errorMessage != null) ...[
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: theme.colorScheme.error.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Row(
                        children: [
                          Icon(
                            Icons.error_outline,
                            color: theme.colorScheme.error,
                          ),
                          const SizedBox(width: 8),
                          Expanded(
                            child: Text(
                              l10n.authRegisterFailed,
                              style: TextStyle(color: theme.colorScheme.error),
                            ),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(height: 16),
                  ],

                  // Bottone Registra
                  ElevatedButton(
                    onPressed: authState.isLoading ? null : _handleRegister,
                    child: authState.isLoading
                        ? const SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              color: Colors.white,
                            ),
                          )
                        : Text(l10n.actionRegister),
                  ),
                  const SizedBox(height: 24),

                  // Link login
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Text(l10n.authHaveAccount),
                      TextButton(
                        onPressed: () {
                          final slug = ref.read(routeSlugProvider);
                          context.go('/$slug/login');
                        },
                        child: Text(l10n.actionLogin),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/auth/presentation/change_password_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/l10_extension.dart';
import '../providers/auth_provider.dart';

class ChangePasswordScreen extends ConsumerStatefulWidget {
  const ChangePasswordScreen({super.key});

  @override
  ConsumerState<ChangePasswordScreen> createState() =>
      _ChangePasswordScreenState();
}

class _ChangePasswordScreenState extends ConsumerState<ChangePasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final _currentPasswordController = TextEditingController();
  final _newPasswordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  bool _obscureCurrentPassword = true;
  bool _obscureNewPassword = true;
  bool _obscureConfirmPassword = true;
  bool _isLoading = false;

  @override
  void dispose() {
    _currentPasswordController.dispose();
    _newPasswordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  Future<void> _handleChangePassword() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    final success = await ref
        .read(authProvider.notifier)
        .changePassword(
          currentPassword: _currentPasswordController.text,
          newPassword: _newPasswordController.text,
        );

    setState(() => _isLoading = false);

    if (mounted) {
      if (success) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(context.l10n.authChangePasswordSuccess),
            backgroundColor: Colors.green,
          ),
        );
        context.pop();
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(context.l10n.authChangePasswordError),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.pop(),
        ),
        title: Text(l10n.authChangePasswordTitle),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                const SizedBox(height: 32),

                // Icon
                Icon(
                  Icons.lock_reset,
                  size: 64,
                  color: theme.colorScheme.primary,
                ),
                const SizedBox(height: 32),

                // Current password
                TextFormField(
                  controller: _currentPasswordController,
                  obscureText: _obscureCurrentPassword,
                  textInputAction: TextInputAction.next,
                  decoration: InputDecoration(
                    labelText: l10n.authCurrentPassword,
                    prefixIcon: const Icon(Icons.lock_outlined),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscureCurrentPassword
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(
                          () => _obscureCurrentPassword =
                              !_obscureCurrentPassword,
                        );
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // New password
                TextFormField(
                  controller: _newPasswordController,
                  obscureText: _obscureNewPassword,
                  textInputAction: TextInputAction.next,
                  decoration: InputDecoration(
                    labelText: l10n.authNewPassword,
                    prefixIcon: const Icon(Icons.lock_outlined),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscureNewPassword
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(
                          () => _obscureNewPassword = !_obscureNewPassword,
                        );
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    if (value.length < 8) {
                      return l10n.authPasswordTooShort;
                    }
                    if (!RegExp(r'[A-Z]').hasMatch(value) ||
                        !RegExp(r'[a-z]').hasMatch(value) ||
                        !RegExp(r'[0-9]').hasMatch(value)) {
                      return l10n.authPasswordRequirements;
                    }
                    if (value == _currentPasswordController.text) {
                      return 'La nuova password deve essere diversa';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // Confirm password
                TextFormField(
                  controller: _confirmPasswordController,
                  obscureText: _obscureConfirmPassword,
                  textInputAction: TextInputAction.done,
                  decoration: InputDecoration(
                    labelText: l10n.authConfirmPassword,
                    prefixIcon: const Icon(Icons.lock_outlined),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscureConfirmPassword
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(
                          () => _obscureConfirmPassword =
                              !_obscureConfirmPassword,
                        );
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    if (value != _newPasswordController.text) {
                      return l10n.authPasswordMismatch;
                    }
                    return null;
                  },
                  onFieldSubmitted: (_) => _handleChangePassword(),
                ),
                const SizedBox(height: 32),

                // Submit button
                FilledButton(
                  onPressed: _isLoading ? null : _handleChangePassword,
                  child: _isLoading
                      ? const SizedBox(
                          height: 20,
                          width: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : Text(l10n.actionConfirm),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/auth/presentation/login_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../app/providers/route_slug_provider.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../booking/providers/business_provider.dart';
import '../providers/auth_provider.dart';

class LoginScreen extends ConsumerStatefulWidget {
  const LoginScreen({super.key});

  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends ConsumerState<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _obscurePassword = true;

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _handleLogin() async {
    if (!_formKey.currentState!.validate()) return;

    // Ottieni il businessId dal provider
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId == null) {
      // Se non c'√® un business, mostra errore
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(context.l10n.authLoginFailed),
          backgroundColor: Colors.red,
        ),
      );
      return;
    }

    final success = await ref
        .read(authProvider.notifier)
        .login(
          businessId: businessId,
          email: _emailController.text.trim(),
          password: _passwordController.text,
        );

    if (success && mounted) {
      // Segnala al browser che l'autofill √® completato con successo
      // Questo triggera la richiesta di salvataggio credenziali
      TextInput.finishAutofillContext();
      final slug = ref.read(routeSlugProvider);
      context.go('/$slug/booking');
    }
  }

  @override
  Widget build(BuildContext context) {
    final authState = ref.watch(authProvider);
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.pop(),
        ),
        title: Text(l10n.authLoginTitle),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: AutofillGroup(
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  const SizedBox(height: 32),

                  // Logo o icona
                  Icon(
                    Icons.lock_outline,
                    size: 64,
                    color: theme.colorScheme.primary,
                  ),
                  const SizedBox(height: 32),

                  // Email
                  TextFormField(
                    controller: _emailController,
                    keyboardType: TextInputType.emailAddress,
                    textInputAction: TextInputAction.next,
                    autofocus:
                        true, // Aiuta Safari mobile a riconoscere il form
                    autocorrect: false,
                    enableSuggestions: true,
                    autofillHints: const [
                      AutofillHints.username,
                      AutofillHints.email,
                    ],
                    decoration: InputDecoration(
                      labelText: l10n.authEmail,
                      prefixIcon: const Icon(Icons.email_outlined),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      if (!value.contains('@')) {
                        return l10n.authInvalidEmail;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // Password
                  TextFormField(
                    controller: _passwordController,
                    obscureText: _obscurePassword,
                    textInputAction: TextInputAction.done,
                    enableSuggestions: false,
                    autocorrect: false,
                    autofillHints: const [AutofillHints.password],
                    onFieldSubmitted: (_) => _handleLogin(),
                    decoration: InputDecoration(
                      labelText: l10n.authPassword,
                      prefixIcon: const Icon(Icons.lock_outlined),
                      suffixIcon: IconButton(
                        icon: Icon(
                          _obscurePassword
                              ? Icons.visibility_outlined
                              : Icons.visibility_off_outlined,
                        ),
                        onPressed: () {
                          setState(() => _obscurePassword = !_obscurePassword);
                        },
                      ),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      if (value.length < 6) {
                        return l10n.authInvalidPassword;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 8),

                  // Password dimenticata
                  Align(
                    alignment: Alignment.centerRight,
                    child: TextButton(
                      onPressed: () => _showResetPasswordDialog(context, ref),
                      child: Text(l10n.authForgotPassword),
                    ),
                  ),
                  const SizedBox(height: 24),

                  // Errore
                  if (authState.errorMessage != null) ...[
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: theme.colorScheme.error.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Row(
                        children: [
                          Icon(
                            Icons.error_outline,
                            color: theme.colorScheme.error,
                          ),
                          const SizedBox(width: 8),
                          Expanded(
                            child: Text(
                              l10n.authLoginFailed,
                              style: TextStyle(color: theme.colorScheme.error),
                            ),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(height: 16),
                  ],

                  // Bottone Login
                  ElevatedButton(
                    onPressed: authState.isLoading ? null : _handleLogin,
                    child: authState.isLoading
                        ? const SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              color: Colors.white,
                            ),
                          )
                        : Text(l10n.actionLogin),
                  ),
                  const SizedBox(height: 24),

                  // Link registrazione
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Text(l10n.authNoAccount),
                      TextButton(
                        onPressed: () {
                          final slug = ref.read(routeSlugProvider);
                          context.go('/$slug/register');
                        },
                        child: Text(l10n.actionRegister),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  void _showResetPasswordDialog(BuildContext context, WidgetRef ref) {
    final emailController = TextEditingController();
    final l10n = context.l10n;
    final businessId = ref.read(currentBusinessIdProvider);

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.authResetPasswordTitle),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(l10n.authResetPasswordMessage),
            const SizedBox(height: 16),
            TextField(
              controller: emailController,
              keyboardType: TextInputType.emailAddress,
              decoration: InputDecoration(
                labelText: l10n.authEmail,
                prefixIcon: const Icon(Icons.email_outlined),
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () async {
              final email = emailController.text.trim();
              if (email.isEmpty) return;

              // Chiudi il dialog prima di fare la chiamata
              Navigator.pop(context);

              // Verifica businessId
              if (businessId == null) {
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text(l10n.authResetPasswordError),
                      backgroundColor: Colors.red,
                    ),
                  );
                }
                return;
              }

              final success = await ref
                  .read(authProvider.notifier)
                  .resetPassword(businessId: businessId, email: email);

              if (context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text(
                      success
                          ? l10n.authResetPasswordSuccess
                          : l10n.authResetPasswordError,
                    ),
                    backgroundColor: success ? Colors.green : Colors.red,
                  ),
                );
              }
            },
            child: Text(l10n.authResetPasswordSend),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/auth/presentation/reset_password_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/l10_extension.dart';
import '../providers/auth_provider.dart';

class ResetPasswordScreen extends ConsumerStatefulWidget {
  final String token;

  const ResetPasswordScreen({required this.token, super.key});

  @override
  ConsumerState<ResetPasswordScreen> createState() =>
      _ResetPasswordScreenState();
}

class _ResetPasswordScreenState extends ConsumerState<ResetPasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  bool _obscurePassword = true;
  bool _obscureConfirmPassword = true;
  bool _isLoading = false;

  @override
  void dispose() {
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  Future<void> _handleResetPassword() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      await ref
          .read(authProvider.notifier)
          .resetPasswordWithToken(
            token: widget.token,
            newPassword: _passwordController.text,
          );

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(context.l10n.authResetPasswordConfirmSuccess),
            backgroundColor: Colors.green,
          ),
        );
        // Redirect a landing - l'utente dovr√† navigare al business per fare login
        context.go('/');
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(context.l10n.authResetPasswordConfirmError),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.go('/'),
        ),
        title: Text(l10n.authResetPasswordConfirmTitle),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                const SizedBox(height: 32),

                // Icon
                Icon(
                  Icons.lock_reset,
                  size: 64,
                  color: theme.colorScheme.primary,
                ),
                const SizedBox(height: 16),

                // Message
                Text(
                  l10n.authResetPasswordConfirmMessage,
                  style: theme.textTheme.bodyLarge,
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 32),

                // New password
                TextFormField(
                  controller: _passwordController,
                  obscureText: _obscurePassword,
                  textInputAction: TextInputAction.next,
                  decoration: InputDecoration(
                    labelText: l10n.authNewPassword,
                    prefixIcon: const Icon(Icons.lock_outlined),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscurePassword
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(() => _obscurePassword = !_obscurePassword);
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    if (value.length < 8) {
                      return l10n.authPasswordTooShort;
                    }
                    if (!RegExp(r'[A-Z]').hasMatch(value) ||
                        !RegExp(r'[a-z]').hasMatch(value) ||
                        !RegExp(r'[0-9]').hasMatch(value)) {
                      return l10n.authPasswordRequirements;
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // Confirm password
                TextFormField(
                  controller: _confirmPasswordController,
                  obscureText: _obscureConfirmPassword,
                  textInputAction: TextInputAction.done,
                  decoration: InputDecoration(
                    labelText: l10n.authConfirmPassword,
                    prefixIcon: const Icon(Icons.lock_outlined),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscureConfirmPassword
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(
                          () => _obscureConfirmPassword =
                              !_obscureConfirmPassword,
                        );
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    if (value != _passwordController.text) {
                      return l10n.authPasswordMismatch;
                    }
                    return null;
                  },
                  onFieldSubmitted: (_) => _handleResetPassword(),
                ),
                const SizedBox(height: 32),

                // Submit button
                FilledButton(
                  onPressed: _isLoading ? null : _handleResetPassword,
                  child: _isLoading
                      ? const SizedBox(
                          height: 20,
                          width: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : Text(l10n.actionConfirm),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/providers/business_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'business_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning
/// Provider per il business corrente (caricato da slug nel path URL)
///
/// L'URL segue il pattern: /{slug}/booking, /{slug}/login, ecc.
/// Il router estrae lo slug e lo aggiorna in routeSlugProvider.
/// Questo provider reagisce ai cambi di slug e carica il business.

@ProviderFor(CurrentBusiness)
const currentBusinessProvider = CurrentBusinessProvider._();

/// Provider per il business corrente (caricato da slug nel path URL)
///
/// L'URL segue il pattern: /{slug}/booking, /{slug}/login, ecc.
/// Il router estrae lo slug e lo aggiorna in routeSlugProvider.
/// Questo provider reagisce ai cambi di slug e carica il business.
final class CurrentBusinessProvider
    extends $AsyncNotifierProvider<CurrentBusiness, Business?> {
  /// Provider per il business corrente (caricato da slug nel path URL)
  ///
  /// L'URL segue il pattern: /{slug}/booking, /{slug}/login, ecc.
  /// Il router estrae lo slug e lo aggiorna in routeSlugProvider.
  /// Questo provider reagisce ai cambi di slug e carica il business.
  const CurrentBusinessProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'currentBusinessProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$currentBusinessHash();

  @$internal
  @override
  CurrentBusiness create() => CurrentBusiness();
}

String _$currentBusinessHash() => r'2f00cc58e347ca0a27ea6647bd55565535f95823';

/// Provider per il business corrente (caricato da slug nel path URL)
///
/// L'URL segue il pattern: /{slug}/booking, /{slug}/login, ecc.
/// Il router estrae lo slug e lo aggiorna in routeSlugProvider.
/// Questo provider reagisce ai cambi di slug e carica il business.

abstract class _$CurrentBusiness extends $AsyncNotifier<Business?> {
  FutureOr<Business?> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<AsyncValue<Business?>, Business?>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<Business?>, Business?>,
              AsyncValue<Business?>,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Provider per l'ID del business corrente (sincrono, utility)

@ProviderFor(CurrentBusinessId)
const currentBusinessIdProvider = CurrentBusinessIdProvider._();

/// Provider per l'ID del business corrente (sincrono, utility)
final class CurrentBusinessIdProvider
    extends $NotifierProvider<CurrentBusinessId, int?> {
  /// Provider per l'ID del business corrente (sincrono, utility)
  const CurrentBusinessIdProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'currentBusinessIdProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$currentBusinessIdHash();

  @$internal
  @override
  CurrentBusinessId create() => CurrentBusinessId();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(int? value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<int?>(value),
    );
  }
}

String _$currentBusinessIdHash() => r'dbb21b4e931947e9e1f0a0e7d3927a478d463ae0';

/// Provider per l'ID del business corrente (sincrono, utility)

abstract class _$CurrentBusinessId extends $Notifier<int?> {
  int? build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<int?, int?>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<int?, int?>,
              int?,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Provider per verificare se il business slug √® valido
/// (slug presente e business trovato nel database)

@ProviderFor(IsBusinessValid)
const isBusinessValidProvider = IsBusinessValidProvider._();

/// Provider per verificare se il business slug √® valido
/// (slug presente e business trovato nel database)
final class IsBusinessValidProvider
    extends $NotifierProvider<IsBusinessValid, bool> {
  /// Provider per verificare se il business slug √® valido
  /// (slug presente e business trovato nel database)
  const IsBusinessValidProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'isBusinessValidProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$isBusinessValidHash();

  @$internal
  @override
  IsBusinessValid create() => IsBusinessValid();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(bool value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<bool>(value),
    );
  }
}

String _$isBusinessValidHash() => r'4d0814c4ad8b342b9ca7225311cb5e49a929041e';

/// Provider per verificare se il business slug √® valido
/// (slug presente e business trovato nel database)

abstract class _$IsBusinessValid extends $Notifier<bool> {
  bool build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<bool, bool>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<bool, bool>,
              bool,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Provider semplice per lo slug corrente (letto dal path URL)

@ProviderFor(businessSlug)
const businessSlugProvider = BusinessSlugProvider._();

/// Provider semplice per lo slug corrente (letto dal path URL)

final class BusinessSlugProvider
    extends $FunctionalProvider<String?, String?, String?>
    with $Provider<String?> {
  /// Provider semplice per lo slug corrente (letto dal path URL)
  const BusinessSlugProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'businessSlugProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$businessSlugHash();

  @$internal
  @override
  $ProviderElement<String?> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  String? create(Ref ref) {
    return businessSlug(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(String? value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<String?>(value),
    );
  }
}

String _$businessSlugHash() => r'2b426e8d5b02f0bf413dc03053031703750be5df';

/// Provider per verificare se siamo su un sottodominio business

@ProviderFor(isBusinessSubdomain)
const isBusinessSubdomainProvider = IsBusinessSubdomainProvider._();

/// Provider per verificare se siamo su un sottodominio business

final class IsBusinessSubdomainProvider
    extends $FunctionalProvider<bool, bool, bool>
    with $Provider<bool> {
  /// Provider per verificare se siamo su un sottodominio business
  const IsBusinessSubdomainProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'isBusinessSubdomainProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$isBusinessSubdomainHash();

  @$internal
  @override
  $ProviderElement<bool> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  bool create(Ref ref) {
    return isBusinessSubdomain(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(bool value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<bool>(value),
    );
  }
}

String _$isBusinessSubdomainHash() =>
    r'7af66aeaae959e3aa4b1de252d5328627d90c0a1';
--- FILE: lib/features/booking/providers/my_bookings_provider.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '/core/models/booking_item.dart';
import '/core/network/network_providers.dart';

part 'my_bookings_provider.g.dart';

/// Stato delle prenotazioni utente (upcoming + past)
class MyBookingsState {
  final List<BookingItem> upcoming;
  final List<BookingItem> past;
  final bool isLoading;
  final String? error;

  const MyBookingsState({
    this.upcoming = const [],
    this.past = const [],
    this.isLoading = false,
    this.error,
  });

  MyBookingsState copyWith({
    List<BookingItem>? upcoming,
    List<BookingItem>? past,
    bool? isLoading,
    String? error,
  }) {
    return MyBookingsState(
      upcoming: upcoming ?? this.upcoming,
      past: past ?? this.past,
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
    );
  }
}

@riverpod
class MyBookings extends _$MyBookings {
  @override
  MyBookingsState build() {
    return const MyBookingsState();
  }

  /// Carica le prenotazioni utente da API
  Future<void> loadBookings() async {
    state = state.copyWith(isLoading: true, error: null);

    try {
      final apiClient = ref.read(apiClientProvider);
      final response = await apiClient.getMyBookings();

      final upcomingJson = response['upcoming'] as List<dynamic>? ?? [];
      final pastJson = response['past'] as List<dynamic>? ?? [];

      final upcoming = upcomingJson
          .map((json) => BookingItem.fromJson(json as Map<String, dynamic>))
          .toList();

      final past = pastJson
          .map((json) => BookingItem.fromJson(json as Map<String, dynamic>))
          .toList();

      state = MyBookingsState(upcoming: upcoming, past: past, isLoading: false);
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }

  /// Cancella una prenotazione (DELETE /v1/locations/{location_id}/bookings/{id})
  Future<bool> cancelBooking(int locationId, int bookingId) async {
    try {
      final apiClient = ref.read(apiClientProvider);
      await apiClient.deleteBooking(locationId, bookingId);

      // Rimuovi localmente
      state = state.copyWith(
        upcoming: state.upcoming.where((b) => b.id != bookingId).toList(),
      );
      return true;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return false;
    }
  }

  /// Modifica una prenotazione (PUT /v1/locations/{location_id}/bookings/{id})
  Future<bool> rescheduleBooking({
    required int locationId,
    required int bookingId,
    required String newStartTime,
    String? notes,
  }) async {
    try {
      final apiClient = ref.read(apiClientProvider);
      final updated = await apiClient.updateBooking(
        locationId: locationId,
        bookingId: bookingId,
        startTime: newStartTime,
        notes: notes,
      );

      // Aggiorna localmente
      final updatedBooking = BookingItem.fromJson(updated);
      state = state.copyWith(
        upcoming: state.upcoming
            .map((b) => b.id == bookingId ? updatedBooking : b)
            .toList(),
      );
      return true;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return false;
    }
  }
}
--- FILE: lib/features/booking/providers/booking_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod/legacy.dart';

import '../../../core/models/booking_request.dart';
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/models/staff.dart';
import '../../../core/models/time_slot.dart';
import '../../../core/network/network_providers.dart';
import '../data/booking_repository.dart';
import '../domain/booking_config.dart';
import 'business_provider.dart';
import 'locations_provider.dart';

/// Provider per il repository
final bookingRepositoryProvider = Provider<BookingRepository>((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return BookingRepository(apiClient);
});

/// Provider per la configurazione del booking (dinamico basato sul business corrente)
final bookingConfigProvider = Provider<BookingConfig>((ref) {
  final businessAsync = ref.watch(currentBusinessProvider);

  // Se il business √® ancora in caricamento o ha errori, ritorna placeholder
  if (businessAsync.isLoading || businessAsync.hasError) {
    return placeholderBookingConfig;
  }

  final business = businessAsync.value;
  if (business == null) {
    // Business non trovato (slug non valido)
    return placeholderBookingConfig;
  }

  // Se il business non ha una location di default, segnala che esiste ma non √® attivo
  final locationId = business.defaultLocationId;
  if (locationId == null) {
    return BookingConfig(
      allowStaffSelection: true,
      businessId: business.id,
      locationId: 0,
      businessExistsButNotActive: true,
    );
  }

  return BookingConfig(
    allowStaffSelection: true,
    businessId: business.id,
    locationId: locationId,
  );
});

/// Provider per la location ID effettiva (da location selezionata o default)
final effectiveLocationIdProvider = Provider<int>((ref) {
  final effectiveLocation = ref.watch(effectiveLocationProvider);
  if (effectiveLocation != null) {
    return effectiveLocation.id;
  }
  // Fallback alla config
  return ref.watch(bookingConfigProvider).locationId;
});

/// Step del flow di prenotazione
enum BookingStep { location, services, staff, dateTime, summary, confirmation }

/// Stato del flow di prenotazione
class BookingFlowState {
  final BookingStep currentStep;
  final BookingRequest request;
  final bool isLoading;
  final String? errorMessage;
  final String? confirmedBookingId;

  const BookingFlowState({
    this.currentStep = BookingStep.location,
    this.request = const BookingRequest(),
    this.isLoading = false,
    this.errorMessage,
    this.confirmedBookingId,
  });

  bool get canGoBack =>
      currentStep.index > 0 && currentStep != BookingStep.confirmation;

  bool get canGoNext {
    switch (currentStep) {
      case BookingStep.location:
        return true; // Gestito dal provider
      case BookingStep.services:
        return request.services.isNotEmpty;
      case BookingStep.staff:
        return true; // Staff opzionale
      case BookingStep.dateTime:
        return request.selectedSlot != null;
      case BookingStep.summary:
        return request.isComplete;
      case BookingStep.confirmation:
        return false;
    }
  }

  BookingFlowState copyWith({
    BookingStep? currentStep,
    BookingRequest? request,
    bool? isLoading,
    String? errorMessage,
    String? confirmedBookingId,
    bool clearError = false,
  }) => BookingFlowState(
    currentStep: currentStep ?? this.currentStep,
    request: request ?? this.request,
    isLoading: isLoading ?? this.isLoading,
    errorMessage: clearError ? null : (errorMessage ?? this.errorMessage),
    confirmedBookingId: confirmedBookingId ?? this.confirmedBookingId,
  );
}

/// Provider principale per il flow di prenotazione
final bookingFlowProvider =
    NotifierProvider<BookingFlowNotifier, BookingFlowState>(
      BookingFlowNotifier.new,
    );

class BookingFlowNotifier extends Notifier<BookingFlowState> {
  @override
  BookingFlowState build() {
    // Determina lo step iniziale in base al numero di locations
    final hasMultipleLocations = ref.watch(hasMultipleLocationsProvider);
    final initialStep = hasMultipleLocations
        ? BookingStep.location
        : BookingStep.services;
    return BookingFlowState(currentStep: initialStep);
  }

  BookingRepository get _repository => ref.read(bookingRepositoryProvider);
  BookingConfig get _config => ref.read(bookingConfigProvider);
  bool get _hasMultipleLocations => ref.read(hasMultipleLocationsProvider);

  /// Reset del flow
  void reset() {
    final initialStep = _hasMultipleLocations
        ? BookingStep.location
        : BookingStep.services;
    state = BookingFlowState(currentStep: initialStep);
    // Reset anche la location selezionata
    ref.read(selectedLocationProvider.notifier).clear();
  }

  /// Vai allo step successivo
  void nextStep() {
    if (!state.canGoNext) return;

    final nextIndex = state.currentStep.index + 1;
    if (nextIndex < BookingStep.values.length) {
      var nextStep = BookingStep.values[nextIndex];

      // Se c'√® una sola location, salta lo step location
      if (nextStep == BookingStep.location && !_hasMultipleLocations) {
        nextStep = BookingStep.services;
      }

      // Se staff selection √® disabilitata, salta lo step staff
      if (nextStep == BookingStep.staff && !_config.allowStaffSelection) {
        nextStep = BookingStep.dateTime;
      }
      state = state.copyWith(currentStep: nextStep);
    }
  }

  /// Vai allo step precedente
  void previousStep() {
    if (!state.canGoBack) return;

    var prevIndex = state.currentStep.index - 1;
    var prevStep = BookingStep.values[prevIndex];

    // Se staff selection √® disabilitata, salta lo step staff
    if (prevStep == BookingStep.staff && !_config.allowStaffSelection) {
      prevIndex--;
      prevStep = BookingStep.values[prevIndex];
    }

    // Se c'√® una sola location, salta lo step location
    if (prevStep == BookingStep.location && !_hasMultipleLocations) {
      // Non andare oltre, siamo gi√† al primo step
      return;
    }

    state = state.copyWith(currentStep: prevStep);
  }

  /// Vai a uno step specifico
  void goToStep(BookingStep step) {
    // Non permettere di tornare allo step location se c'√® una sola location
    if (step == BookingStep.location && !_hasMultipleLocations) {
      return;
    }
    if (step.index < state.currentStep.index) {
      state = state.copyWith(currentStep: step);
    }
  }

  /// Toggle selezione servizio
  void toggleService(Service service) {
    final currentServices = List<Service>.from(state.request.services);

    if (currentServices.any((s) => s.id == service.id)) {
      currentServices.removeWhere((s) => s.id == service.id);
    } else {
      currentServices.add(service);
    }

    // Quando cambiano i servizi, resetta slot selezionato
    state = state.copyWith(
      request: state.request.copyWith(
        services: currentServices,
        clearSlot: true,
      ),
    );
  }

  /// Seleziona staff
  void selectStaff(Staff? staff) {
    state = state.copyWith(
      request: state.request.copyWith(
        selectedStaff: staff,
        clearStaff: staff == null,
        clearSlot: true, // Resetta slot quando cambia staff
      ),
    );
  }

  /// Seleziona slot temporale
  void selectTimeSlot(TimeSlot slot) {
    state = state.copyWith(request: state.request.copyWith(selectedSlot: slot));
  }

  /// Aggiorna note
  void updateNotes(String notes) {
    state = state.copyWith(request: state.request.copyWith(notes: notes));
  }

  /// Conferma prenotazione
  Future<bool> confirmBooking() async {
    if (!state.request.isComplete) return false;

    state = state.copyWith(isLoading: true, clearError: true);

    try {
      // Usa la location effettiva (selezionata o default)
      final locationId = ref.read(effectiveLocationIdProvider);

      final result = await _repository.confirmBooking(
        locationId: locationId,
        serviceIds: state.request.services.map((s) => s.id).toList(),
        startTime: state.request.selectedSlot!.startTime,
        staffId: state.request.selectedStaff?.id,
        notes: state.request.notes,
      );

      // Estrai booking ID dalla risposta
      final bookingId =
          result['id']?.toString() ??
          result['booking_id']?.toString() ??
          'confirmed';

      state = state.copyWith(
        isLoading: false,
        currentStep: BookingStep.confirmation,
        confirmedBookingId: bookingId,
      );
      return true;
    } catch (e) {
      state = state.copyWith(isLoading: false, errorMessage: e.toString());
      return false;
    }
  }
}

/// Dati servizi (categories + services in un'unica chiamata API)
class ServicesData {
  final List<ServiceCategory> categories;
  final List<Service> services;

  const ServicesData({required this.categories, required this.services});

  /// Servizi prenotabili online
  List<Service> get bookableServices =>
      services.where((s) => s.isBookableOnline).toList();

  bool get isEmpty => bookableServices.isEmpty;
}

/// Notifier per gestire il caricamento dei servizi con controllo TOTALE sullo stato
class ServicesDataNotifier extends StateNotifier<AsyncValue<ServicesData>> {
  final Ref _ref;
  bool _hasFetched = false;
  int? _lastLocationId;

  ServicesDataNotifier(this._ref) : super(const AsyncValue.loading()) {
    // Ascolta cambiamenti della location effettiva
    _ref.listen(effectiveLocationIdProvider, (previous, next) {
      if (next > 0 && next != _lastLocationId) {
        _hasFetched = false;
        _lastLocationId = next;
        _loadData();
      }
    }, fireImmediately: true);
  }

  Future<void> _loadData() async {
    if (_hasFetched) return;

    final locationId = _ref.read(effectiveLocationIdProvider);
    if (locationId <= 0) return;

    _hasFetched = true;

    try {
      final repository = _ref.read(bookingRepositoryProvider);

      final result = await repository.getCategoriesWithServices(locationId);

      final sortedCategories = List<ServiceCategory>.from(result.categories)
        ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));
      final sortedServices = List<Service>.from(result.services)
        ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));

      state = AsyncValue.data(
        ServicesData(categories: sortedCategories, services: sortedServices),
      );
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }

  /// Forza il refresh dei dati (per retry manuale)
  Future<void> refresh() async {
    _hasFetched = false;
    state = const AsyncValue.loading();
    await _loadData();
  }
}

/// Provider unico per categorie e servizi (UNA sola chiamata API)
final servicesDataProvider =
    StateNotifierProvider<ServicesDataNotifier, AsyncValue<ServicesData>>(
      (ref) => ServicesDataNotifier(ref),
    );

/// Provider per le categorie (legacy - usa servicesDataProvider)
final categoriesProvider = FutureProvider<List<ServiceCategory>>((ref) async {
  final asyncData = ref.watch(servicesDataProvider);
  return asyncData.whenData((data) => data.categories).value ?? [];
});

/// Provider per i servizi (legacy - usa servicesDataProvider)
final servicesProvider = FutureProvider<List<Service>>((ref) async {
  final asyncData = ref.watch(servicesDataProvider);
  return asyncData.whenData((data) => data.services).value ?? [];
});

/// Notifier per lo staff con protezione da loop
class StaffDataNotifier extends StateNotifier<AsyncValue<List<Staff>>> {
  final Ref _ref;
  bool _hasFetched = false;
  int? _lastLocationId;

  StaffDataNotifier(this._ref) : super(const AsyncValue.loading()) {
    // Ascolta cambiamenti della location effettiva
    _ref.listen(effectiveLocationIdProvider, (previous, next) {
      if (next > 0 && next != _lastLocationId) {
        _hasFetched = false;
        _lastLocationId = next;
        _loadData();
      }
    }, fireImmediately: true);
  }

  Future<void> _loadData() async {
    if (_hasFetched) return;

    final locationId = _ref.read(effectiveLocationIdProvider);
    if (locationId <= 0) return;

    _hasFetched = true;

    try {
      final repository = _ref.read(bookingRepositoryProvider);
      final staff = await repository.getStaff(locationId);
      final sortedStaff = List<Staff>.from(staff)
        ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));
      state = AsyncValue.data(sortedStaff);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }

  Future<void> refresh() async {
    _hasFetched = false;
    state = const AsyncValue.loading();
    await _loadData();
  }
}

/// Provider per lo staff
final staffProvider =
    StateNotifierProvider<StaffDataNotifier, AsyncValue<List<Staff>>>(
      (ref) => StaffDataNotifier(ref),
    );

/// Provider per la data selezionata nel calendario
final selectedDateProvider = StateProvider<DateTime?>((ref) => null);

/// Provider per gli slot disponibili
final availableSlotsProvider = FutureProvider<List<TimeSlot>>((ref) async {
  final repository = ref.read(bookingRepositoryProvider);
  final locationId = ref.watch(effectiveLocationIdProvider);
  final bookingState = ref.watch(bookingFlowProvider);
  final selectedDate = ref.watch(selectedDateProvider);

  if (locationId <= 0 ||
      selectedDate == null ||
      bookingState.request.services.isEmpty) {
    return [];
  }

  return repository.getAvailableSlots(
    locationId: locationId,
    date: selectedDate,
    serviceIds: bookingState.request.services.map((s) => s.id).toList(),
    staffId: bookingState.request.selectedStaff?.id,
  );
});

/// Provider per la prima data disponibile
final firstAvailableDateProvider = FutureProvider<DateTime>((ref) async {
  final repository = ref.read(bookingRepositoryProvider);
  final locationId = ref.watch(effectiveLocationIdProvider);
  final bookingState = ref.watch(bookingFlowProvider);

  if (locationId <= 0) {
    return DateTime.now().add(const Duration(days: 1));
  }

  return repository.getFirstAvailableDate(
    locationId: locationId,
    serviceIds: bookingState.request.services.map((s) => s.id).toList(),
    staffId: bookingState.request.selectedStaff?.id,
  );
});
--- FILE: lib/features/booking/providers/business_provider.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../app/providers/route_slug_provider.dart';
import '../../../core/models/business.dart';
import '../../../core/network/api_client.dart';
import '../../../core/network/network_providers.dart';

part 'business_provider.g.dart';

/// Provider per il business corrente (caricato da slug nel path URL)
///
/// L'URL segue il pattern: /{slug}/booking, /{slug}/login, ecc.
/// Il router estrae lo slug e lo aggiorna in routeSlugProvider.
/// Questo provider reagisce ai cambi di slug e carica il business.
@riverpod
class CurrentBusiness extends _$CurrentBusiness {
  String? _lastSlug;
  Business? _cachedBusiness;
  Object? _cachedError;

  @override
  Future<Business?> build() async {
    // Legge lo slug dal path URL (gestito dal router)
    final slug = ref.watch(routeSlugProvider);

    // Se lo slug non √® cambiato, ritorna la cache
    if (_lastSlug == slug && _cachedBusiness != null) {
      return _cachedBusiness;
    }

    // Se c'era un errore per questo slug, rilancia
    if (_lastSlug == slug && _cachedError != null) {
      throw _cachedError!;
    }

    _lastSlug = slug;
    _cachedBusiness = null;
    _cachedError = null;

    if (slug == null) {
      // Nessun slug nel path ‚Üí landing page
      return null;
    }

    final apiClient = ref.watch(apiClientProvider);

    try {
      final data = await apiClient.getBusinessBySlug(slug);
      _cachedBusiness = Business.fromJson(data);
      return _cachedBusiness;
    } on ApiException catch (e) {
      if (e.statusCode == 404) {
        // Business non trovato - slug non valido
        // Non √® un errore, ritorna null e l'app mostrer√† "business non trovato"
        _cachedBusiness = null;
        return null;
      }
      _cachedError = e;
      rethrow;
    } catch (e) {
      _cachedError = e;
      rethrow;
    }
  }

  /// Ricarica il business corrente (forza refresh)
  Future<void> refresh() async {
    _lastSlug = null;
    _cachedBusiness = null;
    _cachedError = null;
    ref.invalidateSelf();
  }
}

/// Provider per l'ID del business corrente (sincrono, utility)
@riverpod
class CurrentBusinessId extends _$CurrentBusinessId {
  @override
  int? build() {
    final businessAsync = ref.watch(currentBusinessProvider);
    return businessAsync.value?.id;
  }
}

/// Provider per verificare se il business slug √® valido
/// (slug presente e business trovato nel database)
@riverpod
class IsBusinessValid extends _$IsBusinessValid {
  @override
  bool build() {
    final slug = ref.watch(routeSlugProvider);

    if (slug == null) {
      // Nessun slug nel path ‚Üí landing page, non √® un errore
      return true;
    }

    // Se c'√® uno slug, verifica che il business esista
    final businessAsync = ref.watch(currentBusinessProvider);
    return businessAsync.value != null;
  }
}

/// Provider semplice per lo slug corrente (letto dal path URL)
@riverpod
String? businessSlug(Ref ref) {
  return ref.watch(routeSlugProvider);
}

/// Provider per verificare se siamo su un sottodominio business
@riverpod
bool isBusinessSubdomain(Ref ref) {
  return ref.watch(businessSlugProvider) != null;
}
--- FILE: lib/features/booking/providers/my_bookings_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'my_bookings_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(MyBookings)
const myBookingsProvider = MyBookingsProvider._();

final class MyBookingsProvider
    extends $NotifierProvider<MyBookings, MyBookingsState> {
  const MyBookingsProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'myBookingsProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$myBookingsHash();

  @$internal
  @override
  MyBookings create() => MyBookings();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(MyBookingsState value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<MyBookingsState>(value),
    );
  }
}

String _$myBookingsHash() => r'c1c0e43f3b187527bcf855f1e9451fb613e1ddd5';

abstract class _$MyBookings extends $Notifier<MyBookingsState> {
  MyBookingsState build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<MyBookingsState, MyBookingsState>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<MyBookingsState, MyBookingsState>,
              MyBookingsState,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/features/booking/providers/locations_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod/legacy.dart';

import '../../../core/models/location.dart';
import 'booking_provider.dart';
import 'business_provider.dart';

/// Provider per la location ID passata via URL (?location=4)
/// Se valorizzato, lo step location viene saltato
final urlLocationIdProvider = StateProvider<int?>((ref) => null);

/// Provider per le locations del business corrente
final locationsProvider =
    NotifierProvider<LocationsNotifier, AsyncValue<List<Location>>>(
      LocationsNotifier.new,
    );

class LocationsNotifier extends Notifier<AsyncValue<List<Location>>> {
  bool _hasFetched = false;
  int? _lastBusinessId;

  @override
  AsyncValue<List<Location>> build() {
    // Ascolta cambiamenti del business
    ref.listen(currentBusinessProvider, (previous, next) {
      if (next.hasValue && next.value != null) {
        final businessId = next.value!.id;
        if (businessId != _lastBusinessId) {
          _hasFetched = false;
          _lastBusinessId = businessId;
          _loadLocations(businessId);
        }
      }
    }, fireImmediately: true);

    return const AsyncValue.loading();
  }

  Future<void> _loadLocations(int businessId) async {
    if (_hasFetched) return;
    _hasFetched = true;

    state = const AsyncValue.loading();

    try {
      final repo = ref.read(bookingRepositoryProvider);
      final locations = await repo.getLocations(businessId);
      state = AsyncValue.data(locations);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }

  Future<void> refresh() async {
    final business = ref.read(currentBusinessProvider).value;
    if (business == null) return;

    _hasFetched = false;
    await _loadLocations(business.id);
  }
}

/// Provider per la location selezionata dall'utente
class SelectedLocationNotifier extends Notifier<Location?> {
  @override
  Location? build() => null;

  void select(Location location) {
    state = location;
  }

  void clear() {
    state = null;
  }
}

final selectedLocationProvider =
    NotifierProvider<SelectedLocationNotifier, Location?>(
      SelectedLocationNotifier.new,
    );

/// Provider derivato: true se ci sono multiple locations E nessuna location pre-selezionata via URL
/// Se urlLocationIdProvider √® valorizzato, consideriamo come "singola location" (step saltato)
final hasMultipleLocationsProvider = Provider<bool>((ref) {
  // Se c'√® una location passata via URL, non mostrare lo step location
  final urlLocationId = ref.watch(urlLocationIdProvider);
  if (urlLocationId != null) {
    return false;
  }

  final locationsAsync = ref.watch(locationsProvider);
  return locationsAsync.maybeWhen(
    data: (locations) => locations.length > 1,
    orElse: () => false,
  );
});

/// Provider derivato: la location effettiva da usare per il booking
/// Priorit√†: 1) URL param, 2) Selezione utente, 3) Location singola/default
final effectiveLocationProvider = Provider<Location?>((ref) {
  final locationsAsync = ref.watch(locationsProvider);
  final urlLocationId = ref.watch(urlLocationIdProvider);
  final selectedLocation = ref.watch(selectedLocationProvider);

  return locationsAsync.maybeWhen(
    data: (locations) {
      if (locations.isEmpty) return null;

      // 1) Se c'√® location da URL, cerca quella
      if (urlLocationId != null) {
        final urlLocation = locations
            .where((l) => l.id == urlLocationId)
            .firstOrNull;
        if (urlLocation != null) return urlLocation;
        // Se non trovata, fallback a default
      }

      // 2) Se c'√® una sola location, usa quella
      if (locations.length == 1) return locations.first;

      // 3) Usa la selezione dell'utente
      return selectedLocation;
    },
    orElse: () => null,
  );
});
--- FILE: lib/features/booking/data/booking_repository.dart ---
import 'package:uuid/uuid.dart';

import '../../../core/models/location.dart';
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/models/staff.dart';
import '../../../core/models/time_slot.dart';
import '../../../core/network/api_client.dart';

/// Repository per le prenotazioni - API reale
class BookingRepository {
  final ApiClient _apiClient;
  final Uuid _uuid = const Uuid();

  BookingRepository(this._apiClient);

  /// GET /v1/businesses/{business_id}/locations/public
  /// Recupera le locations attive di un business
  Future<List<Location>> getLocations(int businessId) async {
    final data = await _apiClient.getBusinessLocations(businessId);
    final locationsJson = data['data'] as List<dynamic>? ?? [];

    return locationsJson
        .map((json) => Location.fromJson(json as Map<String, dynamic>))
        .toList();
  }

  /// GET /v1/services?location_id=X
  /// Recupera categorie e servizi in un'unica chiamata
  Future<({List<ServiceCategory> categories, List<Service> services})>
  getCategoriesWithServices(int locationId) async {
    final data = await _apiClient.getServices(locationId);
    final categoriesJson = data['categories'] as List<dynamic>? ?? [];

    final categories = <ServiceCategory>[];
    final services = <Service>[];

    for (final json in categoriesJson) {
      final catJson = json as Map<String, dynamic>;
      categories.add(ServiceCategory.fromJson(catJson));

      final catId = catJson['id'] as int;
      final servicesJson = catJson['services'] as List<dynamic>? ?? [];

      for (final svcJson in servicesJson) {
        final svc = svcJson as Map<String, dynamic>;
        if (!svc.containsKey('category_id')) {
          svc['category_id'] = catId;
        }
        services.add(Service.fromJson(svc));
      }
    }

    return (categories: categories, services: services);
  }

  /// GET /v1/services?location_id=X
  /// Recupera categorie con servizi annidati (legacy)
  Future<List<ServiceCategory>> getCategories(int locationId) async {
    final result = await getCategoriesWithServices(locationId);
    return result.categories;
  }

  /// GET /v1/services?location_id=X
  /// Recupera tutti i servizi (flat list) (legacy)
  Future<List<Service>> getServices(int locationId) async {
    final result = await getCategoriesWithServices(locationId);
    return result.services;
  }

  /// GET /v1/staff?location_id=X
  /// Recupera staff prenotabili online
  Future<List<Staff>> getStaff(int locationId) async {
    final data = await _apiClient.getStaff(locationId);

    // Formato atteso: { "staff": [...] }
    final staffJson = data['staff'] as List<dynamic>? ?? [];

    return staffJson.map((json) {
      final staffData = json as Map<String, dynamic>;
      // Mappa display_name se presente
      if (staffData.containsKey('display_name') &&
          !staffData.containsKey('name')) {
        final displayName = staffData['display_name'] as String;
        final parts = displayName.split(' ');
        staffData['name'] = parts.isNotEmpty ? parts.first : displayName;
        staffData['surname'] = parts.length > 1
            ? parts.sublist(1).join(' ')
            : '';
      }
      // Default business_id se non presente
      if (!staffData.containsKey('business_id')) {
        staffData['business_id'] = 1;
      }
      return Staff.fromJson(staffData);
    }).toList();
  }

  /// GET /v1/availability?location_id=X&date=YYYY-MM-DD&service_ids=1,2&staff_id=N
  /// Recupera slot disponibili
  Future<List<TimeSlot>> getAvailableSlots({
    required int locationId,
    required DateTime date,
    required List<int> serviceIds,
    int? staffId,
  }) async {
    if (serviceIds.isEmpty) return [];

    final dateStr =
        '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';

    final data = await _apiClient.getAvailability(
      locationId: locationId,
      date: dateStr,
      serviceIds: serviceIds,
      staffId: staffId,
    );

    final slotsJson = data['slots'] as List<dynamic>? ?? [];

    return slotsJson.map((json) {
      return TimeSlot.fromJson(json as Map<String, dynamic>);
    }).toList();
  }

  /// Trova la prima data con disponibilit√†
  /// Cerca nei prossimi 30 giorni
  Future<DateTime> getFirstAvailableDate({
    required int locationId,
    required List<int> serviceIds,
    int? staffId,
  }) async {
    if (serviceIds.isEmpty) {
      return DateTime.now().add(const Duration(days: 1));
    }

    final now = DateTime.now();
    var checkDate = DateTime(now.year, now.month, now.day);

    // Se oggi √® gi√† tardi, inizia da domani
    if (now.hour >= 18) {
      checkDate = checkDate.add(const Duration(days: 1));
    }

    // Cerca nei prossimi 30 giorni
    for (var i = 0; i < 30; i++) {
      try {
        final slots = await getAvailableSlots(
          locationId: locationId,
          date: checkDate,
          serviceIds: serviceIds,
          staffId: staffId,
        );

        if (slots.isNotEmpty) {
          return checkDate;
        }
      } catch (_) {
        // Ignora errori e prova il giorno successivo
      }
      checkDate = checkDate.add(const Duration(days: 1));
    }

    // Fallback: domani
    return DateTime(now.year, now.month, now.day + 1);
  }

  /// POST /v1/locations/{location_id}/bookings
  /// Conferma prenotazione
  ///
  /// Ritorna i dati del booking creato
  /// Throws ApiException con code='slot_conflict' se slot occupato
  Future<Map<String, dynamic>> confirmBooking({
    required int locationId,
    required List<int> serviceIds,
    required DateTime startTime,
    int? staffId,
    String? notes,
    String? idempotencyKey,
  }) async {
    // Genera idempotency key se non fornita
    final key = idempotencyKey ?? _uuid.v4();

    return _apiClient.createBooking(
      locationId: locationId,
      idempotencyKey: key,
      serviceIds: serviceIds,
      startTime: startTime.toUtc().toIso8601String(),
      staffId: staffId,
      notes: notes,
    );
  }

  /// Genera un nuovo idempotency key (UUID v4)
  String generateIdempotencyKey() => _uuid.v4();
}
--- FILE: lib/features/booking/domain/booking_config.dart ---
/// Configurazione per il flow di prenotazione
class BookingConfig {
  /// Consente all'utente di scegliere l'operatore
  final bool allowStaffSelection;

  /// ID del business
  final int businessId;

  /// ID della location (sede)
  final int locationId;

  /// True se il business esiste ma non ha location configurata
  final bool businessExistsButNotActive;

  const BookingConfig({
    this.allowStaffSelection = true,
    required this.businessId,
    required this.locationId,
    this.businessExistsButNotActive = false,
  });

  /// Crea una config valida solo se businessId e locationId sono noti
  bool get isValid => businessId > 0 && locationId > 0;
}

/// Config placeholder usata quando il business non √® ancora caricato.
/// NON usare direttamente - serve solo come fallback temporaneo.
const placeholderBookingConfig = BookingConfig(
  allowStaffSelection: true,
  businessId: 0,
  locationId: 0,
);
--- FILE: lib/features/booking/presentation/screens/staff_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/staff.dart';
import '../../providers/booking_provider.dart';

class StaffStep extends ConsumerWidget {
  const StaffStep({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final staffAsync = ref.watch(staffProvider);
    final bookingState = ref.watch(bookingFlowProvider);
    final selectedStaff = bookingState.request.selectedStaff;

    return Column(
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                l10n.staffTitle,
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                l10n.staffSubtitle,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurface.withOpacity(0.7),
                ),
              ),
            ],
          ),
        ),

        // Lista staff
        Expanded(
          child: staffAsync.when(
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (e, _) => Center(child: Text(l10n.errorLoadingStaff)),
            data: (staffList) => ListView(
              padding: const EdgeInsets.symmetric(horizontal: 16),
              children: [
                // Opzione "Qualsiasi operatore"
                _StaffTile(
                  staff: null,
                  isSelected: selectedStaff == null,
                  onTap: () {
                    ref.read(bookingFlowProvider.notifier).selectStaff(null);
                  },
                ),
                const SizedBox(height: 8),
                // Lista operatori
                ...staffList
                    .where((s) => s.isBookableOnline)
                    .map(
                      (staff) => Padding(
                        padding: const EdgeInsets.only(bottom: 8),
                        child: _StaffTile(
                          staff: staff,
                          isSelected: selectedStaff?.id == staff.id,
                          onTap: () {
                            ref
                                .read(bookingFlowProvider.notifier)
                                .selectStaff(staff);
                          },
                        ),
                      ),
                    ),
              ],
            ),
          ),
        ),

        // Footer con bottone
        _buildFooter(context, ref),
      ],
    );
  }

  Widget _buildFooter(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, -5),
          ),
        ],
      ),
      child: SafeArea(
        child: ElevatedButton(
          onPressed: () => ref.read(bookingFlowProvider.notifier).nextStep(),
          child: Text(l10n.actionNext),
        ),
      ),
    );
  }
}

class _StaffTile extends StatelessWidget {
  final Staff? staff;
  final bool isSelected;
  final VoidCallback onTap;

  const _StaffTile({
    required this.staff,
    required this.isSelected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    return Card(
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(
          color: isSelected ? theme.colorScheme.primary : theme.dividerColor,
          width: isSelected ? 2 : 1,
        ),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Avatar
              CircleAvatar(
                radius: 24,
                backgroundColor: staff == null
                    ? theme.colorScheme.primary.withOpacity(0.1)
                    : theme.colorScheme.secondary.withOpacity(0.1),
                child: staff == null
                    ? Icon(Icons.groups, color: theme.colorScheme.primary)
                    : Text(
                        staff!.initials,
                        style: TextStyle(
                          color: theme.colorScheme.secondary,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
              ),
              const SizedBox(width: 16),
              // Info
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      staff?.displayName ?? l10n.staffAnyOperator,
                      style: theme.textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    if (staff == null) ...[
                      const SizedBox(height: 4),
                      Text(
                        l10n.staffAnyOperatorSubtitle,
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.6),
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              // Radio
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected
                      ? theme.colorScheme.primary
                      : Colors.transparent,
                  border: Border.all(
                    color: isSelected
                        ? theme.colorScheme.primary
                        : theme.colorScheme.onSurface.withOpacity(0.3),
                    width: 2,
                  ),
                ),
                child: isSelected
                    ? const Icon(Icons.check, size: 16, color: Colors.white)
                    : null,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/summary_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../providers/booking_provider.dart';

class SummaryStep extends ConsumerStatefulWidget {
  const SummaryStep({super.key});

  @override
  ConsumerState<SummaryStep> createState() => _SummaryStepState();
}

class _SummaryStepState extends ConsumerState<SummaryStep> {
  final _notesController = TextEditingController();

  @override
  void dispose() {
    _notesController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final bookingState = ref.watch(bookingFlowProvider);
    final request = bookingState.request;

    return Column(
      children: [
        Expanded(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Header
                Text(
                  l10n.summaryTitle,
                  style: theme.textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  l10n.summarySubtitle,
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.onSurface.withOpacity(0.7),
                  ),
                ),
                const SizedBox(height: 24),

                // Servizi selezionati
                _SummarySection(
                  title: l10n.summaryServices,
                  icon: Icons.list_alt,
                  child: Column(
                    children: request.services.map((service) {
                      return Padding(
                        padding: const EdgeInsets.symmetric(vertical: 4),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    service.name,
                                    style: theme.textTheme.bodyMedium,
                                  ),
                                  Text(
                                    l10n.durationMinutes(
                                      service.durationMinutes,
                                    ),
                                    style: theme.textTheme.bodySmall?.copyWith(
                                      color: theme.colorScheme.onSurface
                                          .withOpacity(0.6),
                                    ),
                                  ),
                                ],
                              ),
                            ),
                            Text(
                              service.formattedPrice,
                              style: theme.textTheme.bodyMedium?.copyWith(
                                fontWeight: FontWeight.w600,
                              ),
                            ),
                          ],
                        ),
                      );
                    }).toList(),
                  ),
                ),
                const SizedBox(height: 16),

                // Operatore
                if (request.selectedStaff != null)
                  _SummarySection(
                    title: l10n.summaryOperator,
                    icon: Icons.person,
                    child: Row(
                      children: [
                        CircleAvatar(
                          radius: 20,
                          backgroundColor: theme.colorScheme.primary
                              .withOpacity(0.1),
                          child: Text(
                            request.selectedStaff!.initials,
                            style: TextStyle(
                              color: theme.colorScheme.primary,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                        const SizedBox(width: 12),
                        Text(
                          request.selectedStaff!.displayName,
                          style: theme.textTheme.bodyMedium,
                        ),
                      ],
                    ),
                  ),
                if (request.selectedStaff != null) const SizedBox(height: 16),

                // Data e ora
                if (request.selectedSlot != null)
                  _SummarySection(
                    title: l10n.summaryDateTime,
                    icon: Icons.calendar_today,
                    child: Text(
                      DateFormat(
                        "EEEE d MMMM yyyy 'alle' HH:mm",
                        'it',
                      ).format(request.selectedSlot!.startTime),
                      style: theme.textTheme.bodyMedium,
                    ),
                  ),
                if (request.selectedSlot != null) const SizedBox(height: 16),

                // Durata totale
                _SummarySection(
                  title: l10n.summaryDuration,
                  icon: Icons.schedule,
                  child: Text(
                    l10n.durationMinutes(request.totalDurationMinutes),
                    style: theme.textTheme.bodyMedium,
                  ),
                ),
                const SizedBox(height: 16),

                // Prezzo totale
                _SummarySection(
                  title: l10n.summaryPrice,
                  icon: Icons.euro,
                  child: Text(
                    request.formattedTotalPrice,
                    style: theme.textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: theme.colorScheme.primary,
                    ),
                  ),
                ),
                const SizedBox(height: 24),

                // Note
                Text(
                  l10n.summaryNotes,
                  style: theme.textTheme.titleSmall?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 8),
                TextField(
                  controller: _notesController,
                  maxLines: 3,
                  decoration: InputDecoration(
                    hintText: l10n.summaryNotesHint,
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                  onChanged: (value) {
                    ref.read(bookingFlowProvider.notifier).updateNotes(value);
                  },
                ),
              ],
            ),
          ),
        ),

        // Footer
        _buildFooter(context, ref, bookingState),
      ],
    );
  }

  Widget _buildFooter(
    BuildContext context,
    WidgetRef ref,
    BookingFlowState state,
  ) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, -5),
          ),
        ],
      ),
      child: SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Errore
            if (state.errorMessage != null) ...[
              Container(
                padding: const EdgeInsets.all(12),
                margin: const EdgeInsets.only(bottom: 12),
                decoration: BoxDecoration(
                  color: theme.colorScheme.error.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    Icon(Icons.error_outline, color: theme.colorScheme.error),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        state.errorMessage!,
                        style: TextStyle(color: theme.colorScheme.error),
                      ),
                    ),
                  ],
                ),
              ),
            ],
            // Bottone conferma
            ElevatedButton(
              onPressed: state.isLoading
                  ? null
                  : () =>
                        ref.read(bookingFlowProvider.notifier).confirmBooking(),
              child: state.isLoading
                  ? const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.white,
                      ),
                    )
                  : Text(l10n.actionConfirm),
            ),
          ],
        ),
      ),
    );
  }
}

class _SummarySection extends StatelessWidget {
  final String title;
  final IconData icon;
  final Widget child;

  const _SummarySection({
    required this.title,
    required this.icon,
    required this.child,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Card(
      margin: EdgeInsets.zero,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(icon, size: 18, color: theme.colorScheme.primary),
                const SizedBox(width: 8),
                Text(
                  title,
                  style: theme.textTheme.titleSmall?.copyWith(
                    fontWeight: FontWeight.w600,
                    color: theme.colorScheme.onSurface.withOpacity(0.7),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            child,
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/services_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';
import '../../../../core/network/api_client.dart';
import '../../providers/booking_provider.dart';

class ServicesStep extends ConsumerWidget {
  const ServicesStep({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final servicesDataAsync = ref.watch(servicesDataProvider);
    final bookingState = ref.watch(bookingFlowProvider);
    final selectedServices = bookingState.request.services;

    return Column(
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                l10n.servicesTitle,
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                l10n.servicesSubtitle,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurface.withOpacity(0.7),
                ),
              ),
            ],
          ),
        ),

        // Lista servizi per categoria (singola chiamata API)
        Expanded(
          child: servicesDataAsync.when(
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (e, _) => _buildErrorWidget(context, ref, e),
            data: (data) {
              if (data.isEmpty) {
                return _EmptyView(
                  title: l10n.servicesEmpty,
                  subtitle: l10n.servicesEmptySubtitle,
                );
              }

              return _buildServicesList(
                context,
                ref,
                data.categories,
                data.bookableServices,
                selectedServices,
              );
            },
          ),
        ),

        // Footer con selezione e bottone
        _buildFooter(context, ref, selectedServices),
      ],
    );
  }

  /// Costruisce il widget di errore appropriato in base al tipo di errore
  Widget _buildErrorWidget(BuildContext context, WidgetRef ref, Object error) {
    final l10n = context.l10n;

    // Determina titolo e sottotitolo in base al tipo di errore
    String title;
    String subtitle;
    IconData icon;
    bool showRetry;

    if (error is ApiException) {
      if (error.isLocationNotFound) {
        title = l10n.errorLocationNotFound;
        subtitle = l10n.errorLocationNotFoundSubtitle;
        icon = Icons.location_off_outlined;
        showRetry = false;
      } else if (error.isBusinessNotFound) {
        title = l10n.errorBusinessNotFound;
        subtitle = l10n.errorBusinessNotFoundSubtitle;
        icon = Icons.store_outlined;
        showRetry = false;
      } else if (error.isServiceUnavailable) {
        title = l10n.errorServiceUnavailable;
        subtitle = l10n.errorServiceUnavailableSubtitle;
        icon = Icons.cloud_off_outlined;
        showRetry = true;
      } else {
        title = l10n.errorLoadingServices;
        subtitle = error.message;
        icon = Icons.error_outline;
        showRetry = true;
      }
    } else {
      title = l10n.errorLoadingServices;
      subtitle = '';
      icon = Icons.cloud_off_outlined;
      showRetry = true;
    }

    return _ErrorView(
      title: title,
      subtitle: subtitle,
      icon: icon,
      onRetry: showRetry
          ? () => ref.read(servicesDataProvider.notifier).refresh()
          : null,
    );
  }

  Widget _buildServicesList(
    BuildContext context,
    WidgetRef ref,
    List<ServiceCategory> categories,
    List<Service> services,
    List<Service> selectedServices,
  ) {
    return ListView.builder(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      itemCount: categories.length,
      itemBuilder: (context, index) {
        final category = categories[index];
        final categoryServices =
            services
                .where((s) => s.categoryId == category.id && s.isBookableOnline)
                .toList()
              ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));

        if (categoryServices.isEmpty) return const SizedBox.shrink();

        return _CategorySection(
          category: category,
          services: categoryServices,
          selectedServices: selectedServices,
          onServiceTap: (service) {
            ref.read(bookingFlowProvider.notifier).toggleService(service);
          },
        );
      },
    );
  }

  Widget _buildFooter(
    BuildContext context,
    WidgetRef ref,
    List<Service> selectedServices,
  ) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final bookingState = ref.watch(bookingFlowProvider);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, -5),
          ),
        ],
      ),
      child: SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Info selezione
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  l10n.servicesSelected(selectedServices.length),
                  style: theme.textTheme.bodyMedium,
                ),
                if (selectedServices.isNotEmpty)
                  Text(
                    bookingState.request.formattedTotalPrice,
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: theme.colorScheme.primary,
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 12),
            // Bottone avanti
            ElevatedButton(
              onPressed: bookingState.canGoNext
                  ? () => ref.read(bookingFlowProvider.notifier).nextStep()
                  : null,
              child: Text(l10n.actionNext),
            ),
          ],
        ),
      ),
    );
  }
}

class _CategorySection extends StatelessWidget {
  final ServiceCategory category;
  final List<Service> services;
  final List<Service> selectedServices;
  final void Function(Service) onServiceTap;

  const _CategorySection({
    required this.category,
    required this.services,
    required this.selectedServices,
    required this.onServiceTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.symmetric(vertical: 12),
          child: Text(
            category.name,
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
        ...services.map((service) {
          final isSelected = selectedServices.any((s) => s.id == service.id);
          return _ServiceTile(
            service: service,
            isSelected: isSelected,
            onTap: () => onServiceTap(service),
          );
        }),
        const SizedBox(height: 8),
      ],
    );
  }
}

class _ServiceTile extends StatelessWidget {
  final Service service;
  final bool isSelected;
  final VoidCallback onTap;

  const _ServiceTile({
    required this.service,
    required this.isSelected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(
          color: isSelected ? theme.colorScheme.primary : theme.dividerColor,
          width: isSelected ? 2 : 1,
        ),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Checkbox
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected
                      ? theme.colorScheme.primary
                      : Colors.transparent,
                  border: Border.all(
                    color: isSelected
                        ? theme.colorScheme.primary
                        : theme.colorScheme.onSurface.withOpacity(0.3),
                    width: 2,
                  ),
                ),
                child: isSelected
                    ? const Icon(Icons.check, size: 16, color: Colors.white)
                    : null,
              ),
              const SizedBox(width: 16),
              // Info servizio
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      service.name,
                      style: theme.textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      l10n.servicesDuration(service.durationMinutes),
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onSurface.withOpacity(0.6),
                      ),
                    ),
                  ],
                ),
              ),
              // Prezzo
              Text(
                service.formattedPrice,
                style: theme.textTheme.titleSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: theme.colorScheme.primary,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// Widget per mostrare errori con bottone retry
class _ErrorView extends StatelessWidget {
  final String title;
  final String subtitle;
  final IconData icon;
  final VoidCallback? onRetry;

  const _ErrorView({
    required this.title,
    this.subtitle = '',
    this.icon = Icons.cloud_off_outlined,
    this.onRetry,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              icon,
              size: 64,
              color: theme.colorScheme.error.withOpacity(0.5),
            ),
            const SizedBox(height: 16),
            Text(
              title,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
              ),
              textAlign: TextAlign.center,
            ),
            if (subtitle.isNotEmpty) ...[
              const SizedBox(height: 8),
              Text(
                subtitle,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurfaceVariant,
                ),
                textAlign: TextAlign.center,
              ),
            ],
            if (onRetry != null) ...[
              const SizedBox(height: 24),
              OutlinedButton.icon(
                onPressed: onRetry,
                icon: const Icon(Icons.refresh),
                label: Text(l10n.actionRetry),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

/// Widget per mostrare stato vuoto
class _EmptyView extends StatelessWidget {
  final String title;
  final String subtitle;

  const _EmptyView({required this.title, required this.subtitle});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.event_busy_outlined,
              size: 64,
              color: theme.colorScheme.onSurface.withOpacity(0.3),
            ),
            const SizedBox(height: 16),
            Text(
              title,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              subtitle,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.6),
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/my_bookings_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '/core/l10n/l10_extension.dart';
import '/core/models/booking_item.dart';
import '/features/booking/providers/my_bookings_provider.dart';
import '../dialogs/reschedule_booking_dialog.dart';

class MyBookingsScreen extends ConsumerStatefulWidget {
  const MyBookingsScreen({super.key});

  @override
  ConsumerState<MyBookingsScreen> createState() => _MyBookingsScreenState();
}

class _MyBookingsScreenState extends ConsumerState<MyBookingsScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    // Carica prenotazioni all'avvio
    Future.microtask(
      () => ref.read(myBookingsProvider.notifier).loadBookings(),
    );
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final bookingsState = ref.watch(myBookingsProvider);

    return Scaffold(
      appBar: AppBar(
        title: Text(context.l10n.myBookings),
        bottom: TabBar(
          controller: _tabController,
          tabs: [
            Tab(
              text: context.l10n.upcomingBookings,
              icon: const Icon(Icons.event_available),
            ),
            Tab(
              text: context.l10n.pastBookings,
              icon: const Icon(Icons.history),
            ),
          ],
        ),
      ),
      body: bookingsState.isLoading
          ? const Center(child: CircularProgressIndicator())
          : bookingsState.error != null
          ? _ErrorView(error: bookingsState.error!)
          : TabBarView(
              controller: _tabController,
              children: [
                _BookingsList(
                  bookings: bookingsState.upcoming,
                  isUpcoming: true,
                ),
                _BookingsList(bookings: bookingsState.past, isUpcoming: false),
              ],
            ),
    );
  }
}

class _ErrorView extends StatelessWidget {
  const _ErrorView({required this.error});

  final String error;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 64, color: Colors.red),
            const SizedBox(height: 16),
            Text(
              context.l10n.errorLoadingBookings,
              style: Theme.of(context).textTheme.titleMedium,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              error,
              style: Theme.of(context).textTheme.bodySmall,
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}

class _BookingsList extends StatelessWidget {
  const _BookingsList({required this.bookings, required this.isUpcoming});

  final List<BookingItem> bookings;
  final bool isUpcoming;

  @override
  Widget build(BuildContext context) {
    if (bookings.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              isUpcoming ? Icons.event_busy : Icons.history,
              size: 64,
              color: Colors.grey,
            ),
            const SizedBox(height: 16),
            Text(
              isUpcoming
                  ? context.l10n.noUpcomingBookings
                  : context.l10n.noPastBookings,
              style: Theme.of(context).textTheme.titleMedium,
            ),
          ],
        ),
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: bookings.length,
      itemBuilder: (context, index) {
        final booking = bookings[index];
        return _BookingCard(booking: booking, isUpcoming: isUpcoming);
      },
    );
  }
}

class _BookingCard extends ConsumerWidget {
  const _BookingCard({required this.booking, required this.isUpcoming});

  final BookingItem booking;
  final bool isUpcoming;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final dateFormat = DateFormat('dd/MM/yyyy', 'it');
    final timeFormat = DateFormat('HH:mm', 'it');

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Intestazione con business e location
            Row(
              children: [
                const Icon(Icons.business, size: 20),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    booking.businessName,
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 4),
            Row(
              children: [
                const Icon(Icons.location_on, size: 18, color: Colors.grey),
                const SizedBox(width: 8),
                Text(
                  booking.locationName,
                  style: Theme.of(context).textTheme.bodyMedium,
                ),
              ],
            ),
            const Divider(height: 24),

            // Servizi
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Icon(Icons.work_outline, size: 18),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    booking.servicesDisplay,
                    style: Theme.of(context).textTheme.bodyMedium,
                  ),
                ),
              ],
            ),

            // Staff (se presente)
            if (booking.staffName != null) ...[
              const SizedBox(height: 8),
              Row(
                children: [
                  const Icon(Icons.person, size: 18, color: Colors.grey),
                  const SizedBox(width: 8),
                  Text(
                    booking.staffName!,
                    style: Theme.of(context).textTheme.bodyMedium,
                  ),
                ],
              ),
            ],
            const SizedBox(height: 12),

            // Data e ora
            Row(
              children: [
                const Icon(Icons.calendar_today, size: 18),
                const SizedBox(width: 8),
                Text(dateFormat.format(booking.startTime)),
                const SizedBox(width: 16),
                const Icon(Icons.access_time, size: 18),
                const SizedBox(width: 8),
                Text(
                  '${timeFormat.format(booking.startTime)} - ${timeFormat.format(booking.endTime)}',
                ),
              ],
            ),

            // Prezzo (se > 0)
            if (booking.totalPrice > 0) ...[
              const SizedBox(height: 8),
              Row(
                children: [
                  const Icon(Icons.euro, size: 18, color: Colors.grey),
                  const SizedBox(width: 8),
                  Text(
                    '${booking.totalPrice.toStringAsFixed(2)} ‚Ç¨',
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ],
              ),
            ],

            // Note (se presenti)
            if (booking.notes != null && booking.notes!.isNotEmpty) ...[
              const SizedBox(height: 12),
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Icon(Icons.note, size: 18),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      booking.notes!,
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                  ),
                ],
              ),
            ],

            // Badge e azioni per prenotazioni future
            if (isUpcoming) ...[
              const SizedBox(height: 16),
              Row(
                children: [
                  // Badge can_modify
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: booking.canModify ? Colors.green : Colors.orange,
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      booking.canModify
                          ? context.l10n.modifiable
                          : context.l10n.notModifiable,
                      style: const TextStyle(color: Colors.white, fontSize: 12),
                    ),
                  ),
                  const SizedBox(width: 8),

                  // Countdown se modificabile
                  if (booking.canModify && booking.canModifyUntil != null)
                    Text(
                      _formatTimeUntil(context, booking.canModifyUntil!),
                      style: Theme.of(context).textTheme.bodySmall,
                    ),

                  const Spacer(),

                  // Pulsanti azione
                  if (booking.canModify) ...[
                    TextButton.icon(
                      onPressed: () => _handleModify(context, ref),
                      icon: const Icon(Icons.edit),
                      label: Text(context.l10n.modify),
                    ),
                    const SizedBox(width: 8),
                    TextButton.icon(
                      onPressed: () => _handleCancel(context, ref),
                      icon: const Icon(Icons.cancel),
                      label: Text(context.l10n.cancel),
                      style: TextButton.styleFrom(foregroundColor: Colors.red),
                    ),
                  ],
                ],
              ),
            ],
          ],
        ),
      ),
    );
  }

  String _formatTimeUntil(BuildContext context, DateTime deadline) {
    final now = DateTime.now();
    final diff = deadline.difference(now);

    if (diff.inHours > 24) {
      final days = diff.inDays;
      return context.l10n.modifiableUntilDays(days);
    } else if (diff.inHours > 0) {
      return context.l10n.modifiableUntilHours(diff.inHours);
    } else {
      return context.l10n.modifiableUntilMinutes(diff.inMinutes);
    }
  }

  Future<void> _handleModify(BuildContext context, WidgetRef ref) async {
    final result = await showDialog<bool>(
      context: context,
      builder: (ctx) => RescheduleBookingDialog(booking: booking),
    );

    if (result == true && context.mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(context.l10n.bookingRescheduled),
          backgroundColor: Colors.green,
        ),
      );
    }
  }

  Future<void> _handleCancel(BuildContext context, WidgetRef ref) async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(context.l10n.cancelBookingTitle),
        content: Text(context.l10n.cancelBookingConfirm),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(false),
            child: Text(context.l10n.no),
          ),
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(true),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: Text(context.l10n.yes),
          ),
        ],
      ),
    );

    if (confirm == true && context.mounted) {
      final success = await ref
          .read(myBookingsProvider.notifier)
          .cancelBooking(booking.locationId, booking.id);

      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              success
                  ? context.l10n.bookingCancelled
                  : context.l10n.bookingCancelFailed,
            ),
            backgroundColor: success ? Colors.green : Colors.red,
          ),
        );
      }
    }
  }
}
--- FILE: lib/features/booking/presentation/screens/booking_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../app/providers/route_slug_provider.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../auth/providers/auth_provider.dart';
import '../../providers/booking_provider.dart';
import '../../providers/business_provider.dart';
import '../../providers/locations_provider.dart';
import '../widgets/booking_step_indicator.dart';
import 'confirmation_step.dart';
import 'date_time_step.dart';
import 'location_step.dart';
import 'services_step.dart';
import 'staff_step.dart';
import 'summary_step.dart';

class BookingScreen extends ConsumerWidget {
  const BookingScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final businessAsync = ref.watch(currentBusinessProvider);
    final config = ref.watch(bookingConfigProvider);
    final l10n = context.l10n;

    // Se il business √® in caricamento, mostra loading
    if (businessAsync.isLoading) {
      return Scaffold(
        appBar: AppBar(title: Text(l10n.bookingTitle)),
        body: const Center(child: CircularProgressIndicator()),
      );
    }

    // Se c'√® un errore nel caricamento del business
    if (businessAsync.hasError) {
      return Scaffold(
        appBar: AppBar(title: Text(l10n.bookingTitle)),
        body: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Icon(Icons.error_outline, size: 64, color: Colors.red),
              const SizedBox(height: 16),
              Text(
                l10n.errorGeneric,
                style: Theme.of(context).textTheme.titleLarge,
              ),
              const SizedBox(height: 16),
              ElevatedButton.icon(
                onPressed: () =>
                    ref.read(currentBusinessProvider.notifier).refresh(),
                icon: const Icon(Icons.refresh),
                label: Text(l10n.actionRetry),
              ),
            ],
          ),
        ),
      );
    }

    // Se la config non √® valida (business o location mancanti)
    if (!config.isValid) {
      // Distingui tra "business non trovato" e "business non attivo"
      final isNotActive = config.businessExistsButNotActive;
      final title = isNotActive
          ? l10n.errorBusinessNotActive
          : l10n.errorBusinessNotFound;
      final subtitle = isNotActive
          ? l10n.errorBusinessNotActiveSubtitle
          : l10n.errorBusinessNotFoundSubtitle;
      final icon = isNotActive ? Icons.schedule : Icons.storefront_outlined;

      return Scaffold(
        appBar: AppBar(title: Text(l10n.bookingTitle)),
        body: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(icon, size: 64),
              const SizedBox(height: 16),
              Text(title, style: Theme.of(context).textTheme.titleLarge),
              const SizedBox(height: 8),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 32),
                child: Text(
                  subtitle,
                  textAlign: TextAlign.center,
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: Theme.of(
                      context,
                    ).colorScheme.onSurface.withAlpha((0.6 * 255).round()),
                  ),
                ),
              ),
            ],
          ),
        ),
      );
    }

    // Normal booking flow
    final bookingState = ref.watch(bookingFlowProvider);
    final hasMultipleLocations = ref.watch(hasMultipleLocationsProvider);
    final isAuthenticated = ref.watch(
      authProvider.select((state) => state.isAuthenticated),
    );
    final slug = ref.watch(routeSlugProvider);

    // Determina se mostrare il back button
    // Se c'√® una sola location e siamo su services, non mostrare back
    final showBackButton =
        bookingState.canGoBack &&
        !(bookingState.currentStep == BookingStep.services &&
            !hasMultipleLocations);

    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.bookingTitle),
        leading: showBackButton
            ? IconButton(
                icon: const Icon(Icons.arrow_back),
                onPressed: () =>
                    ref.read(bookingFlowProvider.notifier).previousStep(),
              )
            : null,
        actions: [
          if (isAuthenticated && slug != null)
            PopupMenuButton<String>(
              icon: const Icon(Icons.account_circle_outlined),
              tooltip: l10n.profileTitle,
              onSelected: (value) {
                switch (value) {
                  case 'bookings':
                    context.go('/$slug/my-bookings');
                  case 'profile':
                    context.push('/$slug/profile');
                }
              },
              itemBuilder: (context) => [
                PopupMenuItem<String>(
                  value: 'bookings',
                  child: ListTile(
                    leading: const Icon(Icons.event_note),
                    title: Text(l10n.myBookings),
                    contentPadding: EdgeInsets.zero,
                    dense: true,
                  ),
                ),
                PopupMenuItem<String>(
                  value: 'profile',
                  child: ListTile(
                    leading: const Icon(Icons.person_outline),
                    title: Text(l10n.profileTitle),
                    contentPadding: EdgeInsets.zero,
                    dense: true,
                  ),
                ),
              ],
            ),
        ],
      ),
      body: Column(
        children: [
          // Step indicator
          if (bookingState.currentStep != BookingStep.confirmation)
            BookingStepIndicator(
              currentStep: bookingState.currentStep,
              allowStaffSelection: config.allowStaffSelection,
              showLocationStep: hasMultipleLocations,
              onStepTap: (step) {
                ref.read(bookingFlowProvider.notifier).goToStep(step);
              },
            ),

          // Content
          Expanded(
            child: AnimatedSwitcher(
              duration: const Duration(milliseconds: 300),
              child: _buildStepContent(bookingState.currentStep),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStepContent(BookingStep step) {
    switch (step) {
      case BookingStep.location:
        return const LocationStep();
      case BookingStep.services:
        return const ServicesStep();
      case BookingStep.staff:
        return const StaffStep();
      case BookingStep.dateTime:
        return const DateTimeStep();
      case BookingStep.summary:
        return const SummaryStep();
      case BookingStep.confirmation:
        return const ConfirmationStep();
    }
  }
}
--- FILE: lib/features/booking/presentation/screens/location_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/location.dart';
import '../../providers/booking_provider.dart';
import '../../providers/locations_provider.dart';

class LocationStep extends ConsumerWidget {
  const LocationStep({super.key});

  /// Aggiorna l'URL con il parametro location per persistenza
  void _updateUrlWithLocation(BuildContext context, int locationId) {
    final uri = GoRouterState.of(context).uri;
    final newUri = uri.replace(
      queryParameters: {
        ...uri.queryParameters,
        'location': locationId.toString(),
      },
    );
    // Usa replaceLocation per non aggiungere alla history del browser
    context.go(newUri.toString());
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final locationsAsync = ref.watch(locationsProvider);
    final selectedLocation = ref.watch(selectedLocationProvider);

    return Column(
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                l10n.locationTitle,
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                l10n.locationSubtitle,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurface.withOpacity(0.7),
                ),
              ),
            ],
          ),
        ),

        // Lista locations
        Expanded(
          child: locationsAsync.when(
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (e, _) => Center(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Icon(Icons.error_outline, size: 48, color: Colors.red),
                  const SizedBox(height: 16),
                  Text(l10n.errorGeneric),
                  const SizedBox(height: 16),
                  ElevatedButton.icon(
                    onPressed: () =>
                        ref.read(locationsProvider.notifier).refresh(),
                    icon: const Icon(Icons.refresh),
                    label: Text(l10n.actionRetry),
                  ),
                ],
              ),
            ),
            data: (locations) {
              if (locations.isEmpty) {
                return Center(
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Icon(
                        Icons.location_off,
                        size: 64,
                        color: theme.colorScheme.onSurface.withOpacity(0.4),
                      ),
                      const SizedBox(height: 16),
                      Text(
                        l10n.locationEmpty,
                        style: theme.textTheme.titleMedium,
                      ),
                    ],
                  ),
                );
              }

              return ListView.builder(
                padding: const EdgeInsets.symmetric(horizontal: 16),
                itemCount: locations.length,
                itemBuilder: (context, index) {
                  final location = locations[index];
                  final isSelected = selectedLocation?.id == location.id;

                  return _LocationCard(
                    location: location,
                    isSelected: isSelected,
                    onTap: () {
                      ref
                          .read(selectedLocationProvider.notifier)
                          .select(location);
                      // Aggiorna URL con location selezionata per persistenza
                      _updateUrlWithLocation(context, location.id);
                    },
                  );
                },
              );
            },
          ),
        ),

        // Footer con bottone
        _buildFooter(context, ref, selectedLocation),
      ],
    );
  }

  Widget _buildFooter(
    BuildContext context,
    WidgetRef ref,
    Location? selectedLocation,
  ) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
      ),
      child: SafeArea(
        child: SizedBox(
          width: double.infinity,
          child: FilledButton(
            onPressed: selectedLocation != null
                ? () => ref.read(bookingFlowProvider.notifier).nextStep()
                : null,
            child: Text(l10n.actionNext),
          ),
        ),
      ),
    );
  }
}

class _LocationCard extends StatelessWidget {
  final Location location;
  final bool isSelected;
  final VoidCallback onTap;

  const _LocationCard({
    required this.location,
    required this.isSelected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: isSelected
            ? BorderSide(color: theme.colorScheme.primary, width: 2)
            : BorderSide.none,
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Icona location
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: isSelected
                      ? theme.colorScheme.primary.withOpacity(0.1)
                      : theme.colorScheme.surfaceContainerHighest,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(
                  Icons.location_on,
                  color: isSelected
                      ? theme.colorScheme.primary
                      : theme.colorScheme.onSurfaceVariant,
                ),
              ),
              const SizedBox(width: 16),

              // Info location
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            location.name,
                            style: theme.textTheme.titleMedium?.copyWith(
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ),
                        if (location.isDefault)
                          Container(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 8,
                              vertical: 2,
                            ),
                            decoration: BoxDecoration(
                              color: theme.colorScheme.primaryContainer,
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: Text(
                              'Principale',
                              style: theme.textTheme.labelSmall?.copyWith(
                                color: theme.colorScheme.onPrimaryContainer,
                              ),
                            ),
                          ),
                      ],
                    ),
                    if (location.formattedAddress.isNotEmpty) ...[
                      const SizedBox(height: 4),
                      Text(
                        location.formattedAddress,
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.7),
                        ),
                      ),
                    ],
                    if (location.phone != null &&
                        location.phone!.isNotEmpty) ...[
                      const SizedBox(height: 4),
                      Row(
                        children: [
                          Icon(
                            Icons.phone_outlined,
                            size: 14,
                            color: theme.colorScheme.onSurface.withOpacity(0.5),
                          ),
                          const SizedBox(width: 4),
                          Text(
                            location.phone!,
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: theme.colorScheme.onSurface.withOpacity(
                                0.7,
                              ),
                            ),
                          ),
                        ],
                      ),
                    ],
                  ],
                ),
              ),

              // Checkmark se selezionato
              if (isSelected)
                Icon(Icons.check_circle, color: theme.colorScheme.primary),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/date_time_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/time_slot.dart';
import '../../providers/booking_provider.dart';

class DateTimeStep extends ConsumerStatefulWidget {
  const DateTimeStep({super.key});

  @override
  ConsumerState<DateTimeStep> createState() => _DateTimeStepState();
}

class _DateTimeStepState extends ConsumerState<DateTimeStep> {
  DateTime _focusedMonth = DateTime.now();

  @override
  void initState() {
    super.initState();
    // Imposta la prima data disponibile
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadFirstAvailableDate();
    });
  }

  Future<void> _loadFirstAvailableDate() async {
    final firstDateAsync = ref.read(firstAvailableDateProvider);
    firstDateAsync.whenData((date) {
      ref.read(selectedDateProvider.notifier).state = date;
      setState(() => _focusedMonth = date);
    });
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final selectedDate = ref.watch(selectedDateProvider);
    final slotsAsync = ref.watch(availableSlotsProvider);
    final bookingState = ref.watch(bookingFlowProvider);
    final firstDateAsync = ref.watch(firstAvailableDateProvider);

    return Column(
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                l10n.dateTimeTitle,
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              firstDateAsync.when(
                loading: () => const SizedBox.shrink(),
                error: (_, __) => const SizedBox.shrink(),
                data: (date) => Text(
                  l10n.dateTimeFirstAvailable(
                    DateFormat('EEEE d MMMM', 'it').format(date),
                  ),
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.primary,
                  ),
                ),
              ),
            ],
          ),
        ),

        // Contenuto scrollabile
        Expanded(
          child: SingleChildScrollView(
            child: Column(
              children: [
                // Calendario
                _buildCalendar(context, selectedDate),

                const Divider(),

                // Slot orari
                slotsAsync.when(
                  loading: () =>
                      const Center(child: CircularProgressIndicator()),
                  error: (e, _) =>
                      Center(child: Text(l10n.errorLoadingAvailability)),
                  data: (slots) => slots.isEmpty
                      ? Padding(
                          padding: const EdgeInsets.all(32),
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                Icons.event_busy,
                                size: 48,
                                color: theme.colorScheme.onSurface.withOpacity(
                                  0.3,
                                ),
                              ),
                              const SizedBox(height: 16),
                              Text(
                                l10n.dateTimeNoSlots,
                                textAlign: TextAlign.center,
                                style: theme.textTheme.bodyLarge?.copyWith(
                                  color: theme.colorScheme.onSurface
                                      .withOpacity(0.6),
                                ),
                              ),
                            ],
                          ),
                        )
                      : _buildTimeSlots(context, ref, slots),
                ),
              ],
            ),
          ),
        ),

        // Footer
        _buildFooter(context, ref, bookingState),
      ],
    );
  }

  Widget _buildCalendar(BuildContext context, DateTime? selectedDate) {
    final theme = Theme.of(context);
    final now = DateTime.now();
    final firstDayOfMonth = DateTime(
      _focusedMonth.year,
      _focusedMonth.month,
      1,
    );
    final lastDayOfMonth = DateTime(
      _focusedMonth.year,
      _focusedMonth.month + 1,
      0,
    );
    final firstWeekday = firstDayOfMonth.weekday;
    final daysInMonth = lastDayOfMonth.day;

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      child: Column(
        children: [
          // Header mese
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              IconButton(
                icon: const Icon(Icons.chevron_left),
                onPressed: () {
                  setState(() {
                    _focusedMonth = DateTime(
                      _focusedMonth.year,
                      _focusedMonth.month - 1,
                    );
                  });
                },
              ),
              Text(
                DateFormat('MMMM yyyy', 'it').format(_focusedMonth),
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              IconButton(
                icon: const Icon(Icons.chevron_right),
                onPressed: () {
                  setState(() {
                    _focusedMonth = DateTime(
                      _focusedMonth.year,
                      _focusedMonth.month + 1,
                    );
                  });
                },
              ),
            ],
          ),
          const SizedBox(height: 8),
          // Giorni della settimana
          Row(
            children: ['L', 'M', 'M', 'G', 'V', 'S', 'D']
                .map(
                  (day) => Expanded(
                    child: Center(
                      child: Text(
                        day,
                        style: theme.textTheme.bodySmall?.copyWith(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.onSurface.withOpacity(0.5),
                        ),
                      ),
                    ),
                  ),
                )
                .toList(),
          ),
          const SizedBox(height: 8),
          // Griglia giorni
          GridView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 7,
              mainAxisSpacing: 4,
              crossAxisSpacing: 4,
            ),
            itemCount: 42,
            itemBuilder: (context, index) {
              final dayOffset = index - (firstWeekday - 1);
              if (dayOffset < 1 || dayOffset > daysInMonth) {
                return const SizedBox.shrink();
              }

              final date = DateTime(
                _focusedMonth.year,
                _focusedMonth.month,
                dayOffset,
              );
              final isToday =
                  date.year == now.year &&
                  date.month == now.month &&
                  date.day == now.day;
              final isPast = date.isBefore(
                DateTime(now.year, now.month, now.day),
              );
              final isSelected =
                  selectedDate != null &&
                  date.year == selectedDate.year &&
                  date.month == selectedDate.month &&
                  date.day == selectedDate.day;

              return GestureDetector(
                onTap: isPast
                    ? null
                    : () {
                        ref.read(selectedDateProvider.notifier).state = date;
                      },
                child: Container(
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    color: isSelected
                        ? theme.colorScheme.primary
                        : isToday
                        ? theme.colorScheme.primary.withOpacity(0.1)
                        : null,
                  ),
                  child: Center(
                    child: Text(
                      '$dayOffset',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: isSelected
                            ? Colors.white
                            : isPast
                            ? theme.colorScheme.onSurface.withOpacity(0.3)
                            : theme.colorScheme.onSurface,
                        fontWeight: isToday || isSelected
                            ? FontWeight.bold
                            : null,
                      ),
                    ),
                  ),
                ),
              );
            },
          ),
        ],
      ),
    );
  }

  Widget _buildTimeSlots(
    BuildContext context,
    WidgetRef ref,
    List<TimeSlot> slots,
  ) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final bookingState = ref.watch(bookingFlowProvider);
    final selectedSlot = bookingState.request.selectedSlot;

    // Raggruppa per fascia oraria
    final morningSlots = slots.where((s) => s.startTime.hour < 12).toList();
    final afternoonSlots = slots
        .where((s) => s.startTime.hour >= 12 && s.startTime.hour < 18)
        .toList();
    final eveningSlots = slots.where((s) => s.startTime.hour >= 18).toList();

    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        if (morningSlots.isNotEmpty) ...[
          Text(l10n.dateTimeMorning, style: theme.textTheme.titleSmall),
          const SizedBox(height: 8),
          _buildSlotGrid(context, ref, morningSlots, selectedSlot),
          const SizedBox(height: 16),
        ],
        if (afternoonSlots.isNotEmpty) ...[
          Text(l10n.dateTimeAfternoon, style: theme.textTheme.titleSmall),
          const SizedBox(height: 8),
          _buildSlotGrid(context, ref, afternoonSlots, selectedSlot),
          const SizedBox(height: 16),
        ],
        if (eveningSlots.isNotEmpty) ...[
          Text(l10n.dateTimeEvening, style: theme.textTheme.titleSmall),
          const SizedBox(height: 8),
          _buildSlotGrid(context, ref, eveningSlots, selectedSlot),
        ],
      ],
    );
  }

  Widget _buildSlotGrid(
    BuildContext context,
    WidgetRef ref,
    List<TimeSlot> slots,
    TimeSlot? selectedSlot,
  ) {
    final theme = Theme.of(context);

    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: slots.map((slot) {
        final isSelected = selectedSlot?.startTime == slot.startTime;
        return GestureDetector(
          onTap: () {
            ref.read(bookingFlowProvider.notifier).selectTimeSlot(slot);
          },
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
            decoration: BoxDecoration(
              color: isSelected
                  ? theme.colorScheme.primary
                  : Colors.transparent,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(
                color: isSelected
                    ? theme.colorScheme.primary
                    : theme.dividerColor,
              ),
            ),
            child: Text(
              slot.formattedTime,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: isSelected ? Colors.white : theme.colorScheme.onSurface,
                fontWeight: isSelected ? FontWeight.bold : null,
              ),
            ),
          ),
        );
      }).toList(),
    );
  }

  Widget _buildFooter(
    BuildContext context,
    WidgetRef ref,
    BookingFlowState state,
  ) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, -5),
          ),
        ],
      ),
      child: SafeArea(
        child: ElevatedButton(
          onPressed: state.canGoNext
              ? () => ref.read(bookingFlowProvider.notifier).nextStep()
              : null,
          child: Text(l10n.actionNext),
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/confirmation_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../app/providers/route_slug_provider.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../providers/booking_provider.dart';

class ConfirmationStep extends ConsumerWidget {
  const ConfirmationStep({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final bookingState = ref.watch(bookingFlowProvider);

    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Spacer(),

            // Icona successo
            Container(
              width: 100,
              height: 100,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                color: Colors.green.withOpacity(0.1),
              ),
              child: const Icon(
                Icons.check_circle,
                size: 64,
                color: Colors.green,
              ),
            ),
            const SizedBox(height: 32),

            // Titolo
            Text(
              l10n.confirmationTitle,
              style: theme.textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.bold,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),

            // Sottotitolo
            Text(
              l10n.confirmationSubtitle,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 24),

            // Codice prenotazione
            if (bookingState.confirmedBookingId != null)
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 24,
                  vertical: 16,
                ),
                decoration: BoxDecoration(
                  color: theme.colorScheme.primary.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  l10n.confirmationBookingId(bookingState.confirmedBookingId!),
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: theme.colorScheme.primary,
                  ),
                ),
              ),

            const Spacer(),

            // Bottoni azioni
            ElevatedButton(
              onPressed: () {
                ref.read(bookingFlowProvider.notifier).reset();
                final slug = ref.read(routeSlugProvider);
                context.go('/$slug/booking');
              },
              child: Text(l10n.confirmationNewBooking),
            ),
            const SizedBox(height: 12),
            OutlinedButton(
              onPressed: () {
                ref.read(bookingFlowProvider.notifier).reset();
                context.go('/');
              },
              child: Text(l10n.confirmationGoHome),
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/dialogs/reschedule_booking_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '/core/l10n/l10_extension.dart';
import '/core/models/booking_item.dart';
import '/core/network/network_providers.dart';
import '../../providers/my_bookings_provider.dart';

/// Dialog per riprogrammare una prenotazione esistente
class RescheduleBookingDialog extends ConsumerStatefulWidget {
  const RescheduleBookingDialog({required this.booking, super.key});

  final BookingItem booking;

  @override
  ConsumerState<RescheduleBookingDialog> createState() =>
      _RescheduleBookingDialogState();
}

class _RescheduleBookingDialogState
    extends ConsumerState<RescheduleBookingDialog> {
  DateTime? _selectedDate;
  String? _selectedTimeSlot;
  List<String> _availableSlots = [];
  bool _isLoadingSlots = false;
  String? _error;
  final _notesController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _notesController.text = widget.booking.notes ?? '';
    // Imposta data corrente della prenotazione
    _selectedDate = widget.booking.startTime;
    _loadAvailability(_selectedDate!);
  }

  @override
  void dispose() {
    _notesController.dispose();
    super.dispose();
  }

  Future<void> _loadAvailability(DateTime date) async {
    setState(() {
      _isLoadingSlots = true;
      _error = null;
      _selectedTimeSlot = null;
    });

    try {
      final apiClient = ref.read(apiClientProvider);
      final dateStr = DateFormat('yyyy-MM-dd').format(date);

      // Recupera service IDs dalla prenotazione corrente
      final serviceIds = widget.booking.serviceIds.isNotEmpty
          ? widget.booking.serviceIds
          : [1]; // Fallback se non disponibili (backward compatibility)

      final response = await apiClient.getAvailability(
        locationId: widget.booking.locationId,
        date: dateStr,
        serviceIds: serviceIds,
      );

      final slots = response['slots'] as List<dynamic>? ?? [];
      setState(() {
        _availableSlots = slots
            .map((slot) {
              final startTime = slot['start_time'] as String;
              final dt = DateTime.parse(startTime);
              return DateFormat('HH:mm').format(dt);
            })
            .toList()
            .cast<String>();
        _isLoadingSlots = false;
      });
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoadingSlots = false;
      });
    }
  }

  Future<void> _selectDate() async {
    final now = DateTime.now();
    final firstDate = now;
    final lastDate = now.add(const Duration(days: 90));

    final picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate ?? now,
      firstDate: firstDate,
      lastDate: lastDate,
      locale: const Locale('it'),
    );

    if (picked != null && mounted) {
      setState(() {
        _selectedDate = picked;
      });
      await _loadAvailability(picked);
    }
  }

  Future<void> _confirmReschedule() async {
    if (_selectedDate == null || _selectedTimeSlot == null) {
      return;
    }

    // Costruisci nuovo start_time ISO8601
    final timeParts = _selectedTimeSlot!.split(':');
    final newDateTime = DateTime(
      _selectedDate!.year,
      _selectedDate!.month,
      _selectedDate!.day,
      int.parse(timeParts[0]),
      int.parse(timeParts[1]),
    );

    final newStartTime = newDateTime.toIso8601String();

    final success = await ref
        .read(myBookingsProvider.notifier)
        .rescheduleBooking(
          locationId: widget.booking.locationId,
          bookingId: widget.booking.id,
          newStartTime: newStartTime,
          notes: _notesController.text.isNotEmpty
              ? _notesController.text
              : null,
        );

    if (mounted) {
      if (success) {
        Navigator.of(context).pop(true);
      } else {
        final bookingsState = ref.read(myBookingsProvider);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(bookingsState.error ?? context.l10n.errorGeneric),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final dateFormat = DateFormat('dd/MM/yyyy', 'it');

    return AlertDialog(
      title: Text(context.l10n.rescheduleBookingTitle),
      content: SingleChildScrollView(
        child: SizedBox(
          width: MediaQuery.of(context).size.width * 0.8,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Info prenotazione corrente
              Text(
                context.l10n.currentBooking,
                style: Theme.of(context).textTheme.titleSmall,
              ),
              const SizedBox(height: 8),
              Text(
                '${widget.booking.serviceNames.join(', ')} - ${dateFormat.format(widget.booking.startTime)} ${DateFormat('HH:mm').format(widget.booking.startTime)}',
                style: Theme.of(context).textTheme.bodyMedium,
              ),
              const Divider(height: 24),

              // Selezione nuova data
              Text(
                context.l10n.selectNewDate,
                style: Theme.of(context).textTheme.titleSmall,
              ),
              const SizedBox(height: 8),
              OutlinedButton.icon(
                onPressed: _selectDate,
                icon: const Icon(Icons.calendar_today),
                label: Text(
                  _selectedDate != null
                      ? dateFormat.format(_selectedDate!)
                      : context.l10n.selectDate,
                ),
              ),
              const SizedBox(height: 16),

              // Slot disponibili
              if (_isLoadingSlots)
                const Center(child: CircularProgressIndicator())
              else if (_error != null)
                Text(_error!, style: const TextStyle(color: Colors.red))
              else if (_availableSlots.isEmpty)
                Text(context.l10n.dateTimeNoSlots)
              else ...[
                Text(
                  context.l10n.selectNewTime,
                  style: Theme.of(context).textTheme.titleSmall,
                ),
                const SizedBox(height: 8),
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: _availableSlots.map((slot) {
                    final isSelected = _selectedTimeSlot == slot;
                    return ChoiceChip(
                      label: Text(slot),
                      selected: isSelected,
                      onSelected: (selected) {
                        setState(() {
                          _selectedTimeSlot = selected ? slot : null;
                        });
                      },
                    );
                  }).toList(),
                ),
              ],
              const SizedBox(height: 16),

              // Note
              TextField(
                controller: _notesController,
                decoration: InputDecoration(
                  labelText: context.l10n.summaryNotes,
                  hintText: context.l10n.summaryNotesHint,
                  border: const OutlineInputBorder(),
                ),
                maxLines: 3,
              ),
            ],
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(false),
          child: Text(context.l10n.actionCancel),
        ),
        FilledButton(
          onPressed: _selectedDate != null && _selectedTimeSlot != null
              ? _confirmReschedule
              : null,
          child: Text(context.l10n.confirmReschedule),
        ),
      ],
    );
  }
}
--- FILE: lib/features/booking/presentation/widgets/booking_step_indicator.dart ---
import 'package:flutter/material.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../providers/booking_provider.dart';

class BookingStepIndicator extends StatelessWidget {
  final BookingStep currentStep;
  final bool allowStaffSelection;
  final bool showLocationStep;
  final void Function(BookingStep) onStepTap;

  const BookingStepIndicator({
    super.key,
    required this.currentStep,
    required this.allowStaffSelection,
    this.showLocationStep = false,
    required this.onStepTap,
  });

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    final steps = [
      if (showLocationStep)
        (BookingStep.location, l10n.bookingStepLocation, Icons.location_on),
      (BookingStep.services, l10n.bookingStepServices, Icons.list_alt),
      if (allowStaffSelection)
        (BookingStep.staff, l10n.bookingStepStaff, Icons.person),
      (BookingStep.dateTime, l10n.bookingStepDateTime, Icons.calendar_today),
      (
        BookingStep.summary,
        l10n.bookingStepSummary,
        Icons.check_circle_outline,
      ),
    ];

    return Container(
      padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 8),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(bottom: BorderSide(color: theme.dividerColor)),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        children: steps.asMap().entries.map((entry) {
          final index = entry.key;
          final (step, label, icon) = entry.value;
          final isActive = step == currentStep;
          final isPast = step.index < currentStep.index;
          final isClickable = isPast;

          return Expanded(
            child: GestureDetector(
              onTap: isClickable ? () => onStepTap(step) : null,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    children: [
                      if (index > 0)
                        Expanded(
                          child: Container(
                            height: 2,
                            color: isPast || isActive
                                ? theme.colorScheme.primary
                                : theme.dividerColor,
                          ),
                        ),
                      Container(
                        width: 32,
                        height: 32,
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          color: isActive
                              ? theme.colorScheme.primary
                              : isPast
                              ? theme.colorScheme.primary.withOpacity(0.2)
                              : theme.dividerColor,
                        ),
                        child: Icon(
                          isPast ? Icons.check : icon,
                          size: 18,
                          color: isActive
                              ? Colors.white
                              : isPast
                              ? theme.colorScheme.primary
                              : theme.colorScheme.onSurface.withOpacity(0.5),
                        ),
                      ),
                      if (index < steps.length - 1)
                        Expanded(
                          child: Container(
                            height: 2,
                            color: isPast
                                ? theme.colorScheme.primary
                                : theme.dividerColor,
                          ),
                        ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Text(
                    label,
                    style: theme.textTheme.bodySmall?.copyWith(
                      fontWeight: isActive
                          ? FontWeight.bold
                          : FontWeight.normal,
                      color: isActive || isPast
                          ? theme.colorScheme.onSurface
                          : theme.colorScheme.onSurface.withOpacity(0.5),
                    ),
                    textAlign: TextAlign.center,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ),
            ),
          );
        }).toList(),
      ),
    );
  }
}
--- FILE: lib/main.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_web_plugins/url_strategy.dart';

import 'app/app.dart';

void main() {
  WidgetsFlutterBinding.ensureInitialized();

  // Usa path URL strategy invece di hash (#) per URL puliti
  // Es: /vamps/booking invece di /#/vamps/booking
  usePathUrlStrategy();

  runApp(const ProviderScope(child: App()));
}
--- FILE: pubspec.yaml ---
name: agenda_frontend
description: "Frontend per prenotazioni online - Agenda Platform"
publish_to: 'none'
version: 1.0.0+1

environment:
  sdk: ^3.10.4

dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter
  flutter_web_plugins:
    sdk: flutter
  
  intl: ^0.20.2    
  flutter_riverpod: ^3.0.3
  riverpod_annotation: ^3.0.3
  go_router: ^16.2.4
  dio: ^5.4.0
  uuid: ^4.3.3
  flutter_secure_storage: ^9.0.0

dev_dependencies:
  build_runner: ^2.7.1
  riverpod_generator: ^3.0.3
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0
  intl_utils: ^2.8.11

flutter:
  uses-material-design: true

flutter_intl:
  enabled: true
  class_name: L10n
  main_locale: it
  arb_dir: lib/core/l10n
  output_dir: lib/core/l10n
