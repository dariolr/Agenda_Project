=======================================
AGENDA CORE - PROJECT SNAPSHOT
Generated on: Sun Jan  4 17:55:15 CET 2026
=======================================

=======================================
----- FILE: AGENTS.md -----

# AGENTS.md ‚Äî agenda_core (Agenda Engine / Core Backend Services)

Questo file √® la fonte di verit√† per qualsiasi agent AI che lavori su agenda_core.
DEVE essere letto prima di scrivere codice.

Compatibilit√† obbligatoria:
- Agenda Frontend (Flutter ‚Äì prenotazione online)
- Agenda Backend (Flutter ‚Äì gestionale)

‚ö†Ô∏è **TERMINOLOGIA OBBLIGATORIA:**
- Il termine **"frontend"** si riferisce SOLO al progetto `agenda_frontend` (prenotazioni clienti)
- Il termine **"backend"** si riferisce SOLO al progetto `agenda_backend` (gestionale operatori)
- Il termine **"core"** o **"API"** si riferisce al progetto `agenda_core` (backend PHP)
- NON usare "frontend" per indicare genericamente interfacce utente

JSON snake_case.
I modelli e i campi gi√† usati dai client NON devono essere rinominati.

Prenotazione pubblica, login obbligatorio solo per conferma.

Autenticazione:
- JWT access token breve (10‚Äì15 min)
- Refresh token lungo (30‚Äì90 gg) con rotazione
- Web: refresh in cookie httpOnly
- Mobile: refresh in secure storage

**Due tipi di autenticazione separati:**
1. **Operatore (users table)**: `POST /v1/auth/login` ‚Üí token con `role: operator`
2. **Customer (clients table)**: `POST /v1/customer/{business_id}/auth/login` ‚Üí token con `role: customer`

I token non sono intercambiabili:
- Customer token non pu√≤ accedere a endpoint gestionale
- Operator token non pu√≤ accedere a endpoint customer

Architettura obbligatoria:
- Http layer (routing, middleware)
- Use cases (CreateBooking, ComputeAvailability‚Ä¶)
- Domain (regole pure)
- Infrastructure (DB, log, provider)

Endpoint minimi:
- POST /v1/auth/login
- POST /v1/auth/refresh
- POST /v1/auth/logout
- GET  /v1/me
- PUT  /v1/me (aggiorna profilo)
- POST /v1/me/change-password (cambio password utente autenticato)
- GET  /v1/auth/verify-reset-token/{token} (verifica token reset)
- POST /v1/auth/reset-password (reset password con token)
- GET  /v1/services
- GET  /v1/staff
- GET  /v1/availability
- POST /v1/bookings (protetto, idempotente)
- POST /v1/admin/businesses/{id}/resend-invite (superadmin)

**Customer Auth Endpoints (self-service booking):**
- POST /v1/customer/{business_id}/auth/login
- POST /v1/customer/{business_id}/auth/register
- POST /v1/customer/{business_id}/auth/refresh
- POST /v1/customer/{business_id}/auth/logout
- POST /v1/customer/{business_id}/auth/forgot-password (richiede email reset)
- POST /v1/customer/auth/reset-password (reset con token)
- GET  /v1/customer/me (customer_auth)
- PUT  /v1/customer/me (customer_auth, aggiorna profilo)
- POST /v1/customer/me/change-password (customer_auth, cambio password)
- POST /v1/customer/{business_id}/bookings (customer_auth, idempotent)
- GET  /v1/customer/bookings (customer_auth)

Booking payload (VINCOLANTE):
- service_ids
- staff_id?
- start_time (ISO8601)
- notes?

Se uno slot √® occupato:
- HTTP 409
- error.code = slot_conflict

Test (PHPUnit):
- 98 test, 195 asserzioni
- Eseguire: `./vendor/bin/phpunit --testdox`
- Classi repository sono `final` ‚Üí NO mock, test logica pura
- JWT_SECRET richiesto in setUp()

Notifiche Email (M10):
- Provider configurabile via `.env`: MAIL_PROVIDER=smtp|brevo|mailgun
- Coda asincrona: notifiche NON bloccano booking flow
- Worker cron: `bin/notification-worker.php` (ogni minuto)
- Reminder cron: `bin/queue-reminders.php` (ogni ora)
- Template: bookingConfirmed, bookingCancelled, bookingReminder, bookingRescheduled
- **Test mode**: `NOTIFICATION_TEST_MODE=true` ‚Üí email inviate a `nome.cognome@romeolab.it`

Cron Jobs (02/01/2026):
| Job | Comando | Intervallo | Scopo |
|-----|---------|------------|-------|
| notification-worker | `php bin/notification-worker.php` | `* * * * *` | Invia email dalla coda |
| queue-reminders | `php bin/queue-reminders.php` | `0 * * * *` | Accoda reminder appuntamenti |
| cleanup-sessions | `php bin/cleanup-sessions.php` | `0 3 1 * *` | Pulisce sessioni e log vecchi |

Formato comando cron SiteGround:
```
cd /home/u1251-kkefwq4fumer/www/api.romeolab.it && php bin/[worker].php >> logs/[worker].log 2>&1
```

File .env:
- `.env` ‚Üí configurazione REALE (non committato, in .gitignore)
- `.env.example` ‚Üí TEMPLATE con placeholder (committato)
- I due file DEVONO avere le STESSE variabili, sempre allineati
- Quando si aggiunge una variabile a `.env.example`, aggiungerla anche a `.env`
- `.env.example` usa valori placeholder, `.env` usa valori reali

Cleanup Worker (02/01/2026):
- File: `bin/cleanup-sessions.php`
- Elimina sessioni scadute/revocate da >30 giorni (`auth_sessions`, `client_sessions`)
- Elimina token reset usati/scaduti (`password_reset_token_users`, `password_reset_token_clients`)
- Tronca log >10MB mantenendo ultime 1000 righe
- Elimina file `.log.*` pi√π vecchi di 30 giorni
- Eseguire: primo del mese alle 03:00 (`0 3 1 * *`)

---

## üîë BACKUP CREDENZIALI PRODUZIONE (02/01/2026)

### Posizione backup
- **iCloud Drive**: `Backup_Credenziali_Agenda/`
- **Password Manager**: voce "Agenda RomeoLab - Produzione"

### File di backup
| File | Contenuto |
|------|-----------|
| `BACKUP_ENV_PRODUZIONE_YYYYMMDD.txt` | Intero `.env` produzione |
| `BACKUP_SSH_KEY_SITEGROUND_YYYYMMDD` | Chiave privata SSH |
| `BACKUP_SSH_KEY_SITEGROUND_YYYYMMDD.pub` | Chiave pubblica SSH |

### ‚ö†Ô∏è QUANDO AGGIORNARE I BACKUP

Aggiornare backup su iCloud + Password Manager quando si modifica:
- `JWT_SECRET` ‚Üí tutti gli utenti devono riloggarsi
- `DB_PASSWORD` ‚Üí credenziali database
- `BREVO_API_KEY` ‚Üí chiave API email
- Chiave SSH SiteGround

### Comando per rigenerare backup

```bash
# Backup .env produzione
ssh siteground "cat www/api.romeolab.it/.env" > ~/Library/Mobile\ Documents/com~apple~CloudDocs/Backup_Credenziali_Agenda/BACKUP_ENV_PRODUZIONE_$(date +%Y%m%d).txt

# Backup chiave SSH (se cambiata)
cp ~/.ssh/siteground_ed25519 ~/Library/Mobile\ Documents/com~apple~CloudDocs/Backup_Credenziali_Agenda/BACKUP_SSH_KEY_SITEGROUND_$(date +%Y%m%d)
cp ~/.ssh/siteground_ed25519.pub ~/Library/Mobile\ Documents/com~apple~CloudDocs/Backup_Credenziali_Agenda/BACKUP_SSH_KEY_SITEGROUND_$(date +%Y%m%d).pub
```

### Credenziali da tenere nel Password Manager
- DB: host, database, username, password
- JWT_SECRET (intero)
- BREVO_API_KEY (intero)
- SSH: user (`u1251-kkefwq4fumer`), porta (`18765`)

---

## üö® REGOLE DEPLOY CRITICHE ‚Äî LEGGERE PRIMA DI OGNI DEPLOY

### Mapping ESATTO Progetto ‚Üí URL ‚Üí Cartella SiteGround

| Progetto | Descrizione | URL Produzione | Cartella SiteGround |
|----------|-------------|----------------|---------------------|
| **agenda_core** | API PHP Backend | api.romeolab.it | `www/api.romeolab.it/` |
| **agenda_frontend** | Prenotazioni CLIENTI | **prenota**.romeolab.it | `www/prenota.romeolab.it/public_html/` |
| **agenda_backend** | Gestionale OPERATORI | **gestionale**.romeolab.it | `www/gestionale.romeolab.it/public_html/` |

### ‚ö†Ô∏è ERRORI COMUNI DA EVITARE

‚ùå **MAI** deployare `agenda_backend` su `prenota.romeolab.it`  
‚ùå **MAI** deployare `agenda_frontend` su `gestionale.romeolab.it`  
‚ùå **MAI** confondere i due progetti Flutter

### Come distinguere i progetti Flutter:

| Caratteristica | agenda_frontend (PRENOTA) | agenda_backend (GESTIONALE) |
|----------------|---------------------------|-----------------------------|
| **Scopo** | Clienti prenotano online | Operatori gestiscono agenda |
| **Route principale** | `/:slug/booking` | `/agenda` |
| **Features** | `booking/` | `agenda/`, `clients/`, `staff/` |
| **Ha drag & drop** | ‚ùå No | ‚úÖ S√¨ |
| **Ha StatefulShellRoute** | ‚ùå No | ‚úÖ S√¨ |
| **Usa routeSlugProvider** | ‚úÖ S√¨ | ‚ùå No |

### Comandi Deploy CORRETTI

```bash
# 1Ô∏è‚É£ FRONTEND PRENOTAZIONI (agenda_frontend ‚Üí prenota.romeolab.it)
cd /path/to/agenda_frontend
flutter build web --release --dart-define=API_BASE_URL=https://api.romeolab.it
rsync -avz --delete build/web/ siteground:www/prenota.romeolab.it/public_html/

# 2Ô∏è‚É£ GESTIONALE (agenda_backend ‚Üí gestionale.romeolab.it)  
cd /path/to/agenda_backend
flutter build web --release --dart-define=API_BASE_URL=https://api.romeolab.it
rsync -avz --delete build/web/ siteground:www/gestionale.romeolab.it/public_html/

# 3Ô∏è‚É£ API (agenda_core ‚Üí api.romeolab.it)
rsync -avz public/ siteground:www/api.romeolab.it/public_html/
rsync -avz --delete src/ siteground:www/api.romeolab.it/src/
rsync -avz --delete vendor/ siteground:www/api.romeolab.it/vendor/
```

### Checklist PRE-DEPLOY

- [ ] Sono nella cartella CORRETTA del progetto?
- [ ] Il nome cartella corrisponde al progetto giusto?
- [ ] L'URL di destinazione √® quello CORRETTO?
- [ ] Ho incrementato `?v=YYYYMMDD-N` in `web/index.html`?

---

Deploy Produzione (28/12/2025):
- API: https://api.romeolab.it
- Frontend: https://prenota.romeolab.it
- Gestionale: https://gestionale.romeolab.it
- Hosting: SiteGround condiviso
- CORS: `CORS_ALLOWED_ORIGINS=https://prenota.romeolab.it,https://gestionale.romeolab.it,http://localhost:8080`
- SSH: porta 18765, chiave ed25519

‚ö†Ô∏è DEPLOY agenda_core ‚Äî SOLO QUESTE CARTELLE:
- `public_html/` ‚Üí entry point (index.php, .htaccess)
- `src/` ‚Üí codice sorgente PHP
- `vendor/` ‚Üí dipendenze Composer
- `bin/` ‚Üí worker notifiche (opzionale, se cron attivo)

MAI deployare: `docs/`, `tests/`, `scripts/`, `migrations/`, `lib/`, `.git/`, `*.md`, `phpunit.xml`, `composer.json`

Comando deploy corretto:
```bash
rsync -avz public/ siteground:www/api.romeolab.it/public_html/
rsync -avz --delete src/ siteground:www/api.romeolab.it/src/
rsync -avz --delete vendor/ siteground:www/api.romeolab.it/vendor/
```

‚ö†Ô∏è VERSIONE CACHE BUSTING (01/01/2026):

**Prima di ogni deploy Flutter (frontend o backend)**, incrementare la versione in `web/index.html`:
```html
<script src="flutter_bootstrap.js?v=YYYYMMDD-N" async></script>
```
- Formato: `?v=YYYYMMDD-N` dove N √® un contatore giornaliero
- Esempio: `?v=20260101-1`, `?v=20260101-2`, ecc.
- Questo forza il browser a ricaricare il JavaScript aggiornato

‚ö†Ô∏è STRUTTURA PROGETTO vs DEPLOY SITEGROUND (31/12/2025):

Nel progetto locale:
- `index.php` e `.htaccess` sono in `public/`
- I path usano `__DIR__ . '/../vendor/autoload.php'` (vendor nella parent)

Su SiteGround (deploy):
- La document root √® SEMPRE `public_html` (obbligatorio)
- `public/` viene mappata come `public_html/` con rsync
- I path sono gi√† corretti, nessuna modifica necessaria

Deploy:
```bash
rsync -avz public/ siteground:www/api.romeolab.it/public_html/
```

Vedi DEPLOY.md sezione 12 per comandi completi.

CORS e Cache Headers (30/12/2025):
- Variabile env: `CORS_ALLOWED_ORIGINS` (NON `CORS_ORIGIN`)
- Response.php aggiunge: `Vary: Origin` per proxy caching corretto
- Response.php aggiunge: `Cache-Control: no-store, no-cache, must-revalidate`
- SiteGround proxy pu√≤ cachare risposte ‚Üí header Vary evita CORS errors
- Se CORS fallisce dopo deploy: purgare cache da SiteGround Site Tools

Multi-Business Path-Based (29/12/2025):
- Struttura URL: `/{slug}/booking`, `/{slug}/login`, ecc.
- SiteGround shared hosting: NO wildcard DNS, NO subdomain routing
- Router Flutter estrae slug dal path e aggiorna `routeSlugProvider`
- Landing page (`/`) mostra "Business non specificato"
- Slug inesistente ‚Üí mostra "Business non trovato" (404 API gestito gracefully)
- Reset password globale: `/reset-password/:token` (senza business context)

Superadmin Business Management (30/12/2025):
- Endpoint CRUD: GET/POST/PUT/DELETE `/v1/admin/businesses`
- PUT `/v1/admin/businesses/{id}` per modifica business
- UseCase `CreateBusiness` con transazione atomica (rollback su errore)
- UseCase `UpdateBusiness` per aggiornamento campi
- Frontend: `BusinessListScreen`, dialogs create/edit
- Flow: superadmin ‚Üí /businesses ‚Üí seleziona/crea/modifica ‚Üí /agenda
- Pulsante "Cambia" in navigation per tornare alla lista business
- **MAI usare StateProvider** ‚Üí sempre Notifier + NotifierProvider

Multi-Location Support (30/12/2025):
- Endpoint pubblico: `GET /v1/businesses/{business_id}/locations/public`
- Ritorna locations attive con campi limitati (id, name, address, city, phone, timezone, is_default)
- Controller: `LocationsController::indexPublic()` usa `$request->getAttribute('business_id')`
- **NON** usare `getRouteParam()` per route pubbliche senza middleware auth
- Frontend: step "Sede" nel booking flow se business ha >1 location

Profilo Utente e Admin Email (31/12/2025):
- `PUT /v1/me` ‚Üí aggiorna profilo utente (first_name, last_name, email, phone)
- UseCase `UpdateProfile` in `src/UseCases/Auth/UpdateProfile.php`
- Validazione email unica (errore se gi√† esistente)
- CreateBusiness: `admin_email` √® OPZIONALE (business pu√≤ essere creato senza owner)
- UpdateBusiness: pu√≤ aggiungere admin a business senza owner, o trasferire ownership
- `POST /v1/admin/businesses/{id}/resend-invite` ‚Üí reinvia email benvenuto admin
- UseCase `ResendAdminInvite` genera nuovo token reset (24h) e invia email
- Template email: `businessAdminWelcome` con link reset password
- BusinessRepository: `findByIdWithAdmin()` e `findAllWithSearch()` includono admin_email
- **GET /v1/admin/businesses** ritorna `admin_email` per ogni business (fix 01/01/2026)

Email Benvenuto Admin (01/01/2026):
- Template `businessAdminWelcome` temporaneamente senza URL prenotazioni
- URL prenotazioni commentato in HTML, rimosso da versione text
- Da riattivare quando frontend booking pronto per il business
- File: `src/Infrastructure/Notifications/EmailTemplateRenderer.php`

Cambio Password e Verifica Token (01/01/2026):
- `GET /v1/auth/verify-reset-token/{token}` ‚Üí verifica validit√† token PRIMA di mostrare form
- UseCase `VerifyResetToken` controlla token non usato e non scaduto
- Errori: `invalid_reset_token` (400) o `reset_token_expired` (400)
- `POST /v1/me/change-password` ‚Üí cambio password utente autenticato
- Payload: `{"current_password": "...", "new_password": "..."}`
- Validazione: password attuale corretta, nuova password rispetta policy (8+ char, maiuscole, minuscole, numeri)
- Errore password errata: `invalid_credentials` (401)

Gestionale UI/UX (01/01/2026):
- **User Menu**: Icona profilo (index 4) nella navigation apre popup menu
- Menu contiene: header nome/email, Cambia password, Cambia Business (superadmin), Esci
- Superadmin: stesso menu sia in `/businesses` che dopo selezione business
- **Login error persistence**: Errore gestito in stato locale widget, non dal provider globale
- **Router rebuild**: Provider derivato `_routerAuthStateProvider` evita rebuild su cambio errorMessage

Logout e Session Expired (01/01/2026):
- `logout(silent: true)` ‚Üí NON fa chiamata API (per sessione gi√† scaduta)
- `SessionExpiredListener` usa `silent: true` per evitare loop infinito
- Flow: sessione scaduta ‚Üí logout silenzioso ‚Üí redirect a login

Categorie Servizi (01/01/2026):
- **NO dati hardcoded** in `ServiceCategoriesNotifier`
- Categorie caricate dall'API insieme ai servizi (`GET /v1/services`)
- `ServicesApi.fetchServicesWithCategories()` estrae categorie dalla risposta
- `ServicesNotifier` popola `serviceCategoriesProvider` con dati API

Services e Categories CRUD (02/01/2026):
- **Endpoint Services:**
  - `POST /v1/locations/{location_id}/services` ‚Üí crea servizio (auth required)
  - `PUT /v1/services/{id}` ‚Üí aggiorna servizio (auth required, `location_id` nel body)
  - `DELETE /v1/services/{id}` ‚Üí soft delete servizio (auth required)
- **Endpoint Categories:**
  - `GET /v1/businesses/{business_id}/categories` ‚Üí lista categorie
  - `POST /v1/businesses/{business_id}/categories` ‚Üí crea categoria
  - `PUT /v1/categories/{id}` ‚Üí aggiorna categoria
  - `DELETE /v1/categories/{id}` ‚Üí elimina categoria (servizi diventano senza categoria)
- **File PHP:**
  - `src/Infrastructure/Repositories/ServiceRepository.php` ‚Üí CRUD methods
  - `src/Http/Controllers/ServicesController.php` ‚Üí endpoint handlers
  - `src/Http/Kernel.php` ‚Üí route registration
- **File Flutter (agenda_backend):**
  - `lib/core/network/api_client.dart` ‚Üí metodi HTTP CRUD
  - `lib/features/services/data/services_api.dart` ‚Üí metodi API
  - `lib/features/services/providers/services_provider.dart` ‚Üí `*Api` methods
  - `lib/features/services/providers/service_categories_provider.dart` ‚Üí `*Api` methods
- **Metodi deprecati:** `add()`, `updateService()`, `delete()`, `duplicate()` locali
- **Usare:** `createServiceApi()`, `updateServiceApi()`, `deleteServiceApi()`, `duplicateServiceApi()`

---

## üóÑÔ∏è API Gestionale - Entit√† Persistite (01/01/2026)

### Staff Services (Servizi abilitati per Staff)
Relazione N:M tra staff e servizi che pu√≤ erogare.

**Gestione tramite endpoint Staff esistenti:**
- `GET /v1/businesses/{business_id}/staff` - ritorna `service_ids` per ogni staff
- `POST /v1/businesses/{business_id}/staff` - accetta `service_ids` nel body
- `PUT /v1/staff/{id}` - accetta `service_ids` nel body

**Tabella:** `staff_services`
- `staff_id`, `service_id` (chiave primaria composta)

**File PHP:**
- `src/Infrastructure/Repositories/StaffRepository.php` ‚Üí `getServiceIds()`, `setServices()`
- `src/Http/Controllers/StaffController.php` ‚Üí gestione `service_ids` in store/update

**File Flutter:**
- `lib/core/models/staff.dart` ‚Üí campo `serviceIds`
- `lib/features/services/providers/services_provider.dart` ‚Üí `eligibleServicesForStaffProvider` legge da Staff
- `lib/features/staff/presentation/dialogs/staff_dialog.dart` ‚Üí salvataggio via API

### Staff Availability Exceptions
Eccezioni ai turni base dello staff (ferie, malattia, straordinari).

**Endpoint:**
- `GET /v1/staff/{id}/availability-exceptions` - lista eccezioni per staff
- `POST /v1/staff/{id}/availability-exceptions` - crea eccezione
- `PUT /v1/staff/availability-exceptions/{id}` - modifica eccezione
- `DELETE /v1/staff/availability-exceptions/{id}` - elimina eccezione

**Tabella:** `staff_availability_exceptions`
- `id`, `staff_id`, `date`, `start_time`, `end_time`, `is_available`, `note`

**File PHP:**
- `src/Infrastructure/Repositories/StaffAvailabilityExceptionRepository.php`
- `src/Http/Controllers/StaffAvailabilityExceptionController.php`

### Resources (Risorse)
Risorse fisiche assegnabili ai servizi (es. cabine, lettini).

**Endpoint:**
- `GET /v1/locations/{id}/resources` - lista risorse per sede
- `POST /v1/locations/{id}/resources` - crea risorsa
- `PUT /v1/resources/{id}` - modifica risorsa
- `DELETE /v1/resources/{id}` - soft delete risorsa

**Tabelle:**
- `resources` - id, location_id, name, description, is_active, deleted_at
- `service_variant_resource_requirements` - variante_servizio ‚Üî risorsa (M:N)

**File PHP:**
- `src/Infrastructure/Repositories/ResourceRepository.php`
- `src/Http/Controllers/ResourcesController.php`

### Time Blocks (Blocchi Non Disponibilit√†)
Periodi di non disponibilit√† per uno o pi√π staff (riunioni, pause, ferie).

**Endpoint:**
- `GET /v1/locations/{id}/time-blocks` - lista blocchi per sede (con filtro date)
- `POST /v1/locations/{id}/time-blocks` - crea blocco
- `PUT /v1/time-blocks/{id}` - modifica blocco
- `DELETE /v1/time-blocks/{id}` - elimina blocco

**Tabelle:**
- `time_blocks` - id, business_id, location_id, start_time, end_time, reason, is_all_day
- `time_block_staff` - blocco ‚Üî staff (M:N)

**File PHP:**
- `src/Infrastructure/Repositories/TimeBlockRepository.php`
- `src/Http/Controllers/TimeBlocksController.php`

---

## üîÑ Refresh e Polling Dati (01/01/2026)

### Refresh all'entrata nelle sezioni
Ogni sezione del gestionale ricarica i dati dal DB quando l'utente vi accede.

| Sezione | Provider ricaricati |
|---------|--------------------|
| Agenda | staff, locations, servizi, clienti |
| Clienti | clienti |
| Team | staff, locations, servizi |
| Servizi | servizi, staff |

### Polling automatico in Agenda
Gli appuntamenti vengono ricaricati automaticamente:
- **Debug**: ogni 10 secondi
- **Produzione**: ogni 5 minuti

Questo permette di vedere nuove prenotazioni fatte online o da altri dispositivi.

### Filtro Location Attive
Il provider `LocationsNotifier` filtra automaticamente le location non attive (`is_active = 0`).
Questo impatta filtri agenda, sezione team e dialog staff.

---

‚ö†Ô∏è REGOLA CRITICA DATABASE:
- **MAI** inserire, modificare o eliminare dati nel database senza richiesta esplicita dell'utente
- Le operazioni di seed/migration vanno eseguite solo se l'utente lo richiede
- In caso di dubbio, chiedere conferma prima di modificare dati in produzione

‚ö†Ô∏è REGOLA CRITICA DEPLOY:
- **MAI** deployare l'intero progetto con un singolo rsync
- Deployare SOLO: `public_html/`, `src/`, `vendor/`, `bin/` (se necessario)
- **MAI** deployare: `docs/`, `tests/`, `scripts/`, `migrations/`, `lib/`, `.git/`, `*.md`, `phpunit.xml`
- Usare sempre i comandi specifici documentati in DEPLOY.md sezione 12

---

## üí∞ Prezzo "A partire da" (01/01/2026)

### Schema Database
`service_variants.is_price_starting_from` (TINYINT, default 0)

### Backend PHP
Tutti gli endpoint che ritornano service_variants includono il campo:
- `ServiceRepository::findById()` ‚Üí include `is_price_starting_from AS is_price_from`
- `ServiceRepository::findByLocationId()` ‚Üí include `is_price_starting_from AS is_price_from`
- `ServiceRepository::findByIds()` ‚Üí include `is_price_starting_from AS is_price_from`
- `ServicesController::index()` ‚Üí ritorna `is_price_starting_from` nella response JSON

### Gestionale Flutter
- `Service.isPriceStartingFrom` (bool) ‚Üí campo flat dal service
- `ServiceVariant.isPriceStartingFrom` (bool) ‚Üí campo dal variant
- `ServiceItem` widget usa `service.isPriceStartingFrom` per visualizzare "a partire da ‚Ç¨X"
- Chiave localizzazione: `priceStartingFromPrefix` = "a partire da"

### Frontend Prenotazioni
Se necessario, seguire stessa logica del gestionale.

---

## üîß Repository Method Names (01/01/2026)

### IMPORTANTE
Il metodo per ottenere PDO connection √®:
```php
$this->db->getPdo()  // ‚úÖ CORRETTO
$this->db->pdo()     // ‚ùå ERRORE - metodo non esistente
```

### Fix Applicati
- `TimeBlockRepository` ‚Üí tutti i `pdo()` sostituiti con `getPdo()`

### Verifica
Prima di usare un repository, verificare che usi `getPdo()` e non `pdo()`.

---

## üîê Sicurezza API - Autorizzazione Business (02/01/2026)

### Pattern Autorizzazione
Tutti i controller che gestiscono dati business-specific implementano il metodo `hasBusinessAccess()`:

```php
private function hasBusinessAccess(Request $request, int $businessId): bool
{
    $userId = $request->getAttribute('user_id');
    if ($userId === null) return false;
    
    // Superadmin ha accesso a tutti i business
    if ($this->userRepo->isSuperadmin($userId)) return true;
    
    // Utente normale: verifica entry in business_users
    return $this->businessUserRepo->hasAccess($userId, $businessId, false);
}
```

### Controller Protetti

| Controller | Endpoint Protetti | Note |
|------------|-------------------|------|
| **ClientsController** | GET/POST/PUT/DELETE `/v1/clients` | Verifica business_id |
| **ServicesController** | POST/PUT/DELETE services e categories | Verifica ownership |
| **BusinessController** | GET `/v1/businesses`, GET `/v1/businesses/{id}` | Solo business accessibili |
| **LocationsController** | GET `/v1/businesses/{id}/locations`, GET `/v1/locations/{id}` | Verifica accesso |
| **AppointmentsController** | GET/PATCH/POST cancel | Owner booking O operatore business |
| **BookingsController** | GET index/show | Verifica business_id |

### Security Best Practice
- `show/update/delete` ritornano **404** (non 403) per non rivelare esistenza risorse
- Operatori con accesso al business possono gestire TUTTI gli appuntamenti
- Utenti normali possono gestire solo i PROPRI booking

### Controller gi√† protetti (pre-esistenti)
- `StaffController` ‚Üí verifica `hasAccess()`
- `TimeBlocksController` ‚Üí verifica `hasAccess()`
- `ResourcesController` ‚Üí verifica `hasAccess()`
- `BusinessUsersController` ‚Üí verifica `checkManageAccess()`
- `AdminBusinessesController` ‚Üí verifica `is_superadmin`

### Dipendenze Controller
Tutti i controller protetti richiedono:
- `BusinessUserRepository` - per verificare accesso
- `UserRepository` - per verificare superadmin

Aggiornare `Kernel.php` quando si aggiungono dipendenze ai controller.

### Nuovi Metodi Repository (02/01/2026)
- `BusinessRepository::findByUserId(int $userId)` - business accessibili all'utente
- `ServiceRepository::findServiceById(int $serviceId)` - trova servizio senza location

---

## üìä Import Dati da Fresha (02/01/2026)

### Istruzioni Migrazione
File in `migrations/fromfresha/`:
- `migra_servizi.md` - import servizi e categorie
- `migra_staff.md` - import staff
- `import_clients.sql` - import clienti (216 record)

### Regola Critica
**NON creare associazioni tra tabelle** (es. `staff_services`) durante import.
Le associazioni devono essere configurate manualmente dall'operatore nel gestionale.

### Match Automatico Clienti
Quando un utente prenota online e nel DB esiste gi√† un client con stessa email/telefono:
- `ClientRepository::findUnlinkedByEmailOrPhone()` cerca client senza `user_id`
- `ClientRepository::linkUserToClient()` associa `user_id` al client esistente
- Priorit√†: email > telefono

---

## üîê Separazione Autenticazione Operator/Customer (02/01/2026)

### Architettura a Due Sistemi Auth

Il sistema usa **due tabelle separate** per l'autenticazione:

| Sistema | Tabella | Endpoint Base | JWT Role | Scopo |
|---------|---------|---------------|----------|-------|
| **Operator** | `users` | `/v1/auth/` | `role: operator` | Gestionale (agenda_backend) |
| **Customer** | `clients` | `/v1/customer/{business_id}/auth/` | `role: customer` | Prenotazioni online (agenda_frontend) |

### ‚ö†Ô∏è REGOLA CRITICA
- I token **NON sono intercambiabili**
- Un token `role: customer` **NON pu√≤** accedere a endpoint gestionale (`/v1/me`, `/v1/businesses`, ecc.)
- Un token `role: operator` **NON pu√≤** accedere a endpoint customer (`/v1/customer/bookings`)

### Schema Database Customer Auth

```sql
-- Nuovi campi su clients
ALTER TABLE clients ADD password_hash VARCHAR(255) NULL;
ALTER TABLE clients ADD email_verified_at TIMESTAMP NULL;

-- Sessioni customer (refresh token)
CREATE TABLE client_sessions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    client_id INT NOT NULL,
    token_hash VARCHAR(64) NOT NULL UNIQUE,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (client_id) REFERENCES clients(id) ON DELETE CASCADE
);

-- Reset password customer
CREATE TABLE password_reset_token_clients (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    client_id INT NOT NULL,
    token_hash VARCHAR(64) NOT NULL UNIQUE,
    expires_at TIMESTAMP NOT NULL,
    used_at TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (client_id) REFERENCES clients(id) ON DELETE CASCADE
);
```

### Endpoint Customer Auth

| Metodo | Endpoint | Descrizione |
|--------|----------|-------------|
| POST | `/v1/customer/{business_id}/auth/register` | Registrazione nuovo cliente |
| POST | `/v1/customer/{business_id}/auth/login` | Login cliente |
| POST | `/v1/customer/{business_id}/auth/refresh` | Rinnovo access token |
| POST | `/v1/customer/{business_id}/auth/logout` | Logout (revoca refresh token) |
| POST | `/v1/customer/{business_id}/auth/forgot-password` | Richiede email reset password |
| POST | `/v1/customer/auth/reset-password` | Reset password con token |
| GET | `/v1/customer/me` | Profilo cliente autenticato |
| POST | `/v1/customer/{business_id}/bookings` | Crea prenotazione (customer) |
| GET | `/v1/customer/bookings` | Lista prenotazioni del cliente |

### JWT Token Structure

**Operator Token:**
```json
{
  "sub": 6,              // user_id
  "role": "operator",
  "exp": 1735830000,
  "iat": 1735829100
}
```

**Customer Token:**
```json
{
  "sub": 42,             // client_id
  "role": "customer",
  "business_id": 1,
  "exp": 1735830000,
  "iat": 1735829100
}
```

### File PHP Creati

| File | Descrizione |
|------|-------------|
| `src/Infrastructure/Repositories/ClientAuthRepository.php` | CRUD client auth, sessioni, password reset |
| `src/Http/Controllers/CustomerAuthController.php` | Endpoint auth customer |
| `src/Http/Middleware/CustomerAuthMiddleware.php` | Valida JWT con `role: customer` |
| `src/UseCases/CustomerAuth/LoginCustomer.php` | UseCase login |
| `src/UseCases/CustomerAuth/RegisterCustomer.php` | UseCase registrazione |
| `src/UseCases/CustomerAuth/RefreshCustomerToken.php` | UseCase refresh token |
| `src/UseCases/CustomerAuth/LogoutCustomer.php` | UseCase logout |
| `src/UseCases/CustomerAuth/GetCustomerMe.php` | UseCase profilo |
| `src/UseCases/CustomerAuth/UpdateCustomerProfile.php` | UseCase aggiorna profilo cliente |
| `src/UseCases/CustomerAuth/ChangeCustomerPassword.php` | UseCase cambio password cliente |

### File PHP Modificati

| File | Modifiche |
|------|-----------|
| `src/Infrastructure/Auth/JwtService.php` | Aggiunto `generateCustomerAccessToken()` con `role: customer` |
| `src/Http/Middleware/AuthMiddleware.php` | Verifica `role: operator` (backwards compatible) |
| `src/Http/Kernel.php` | Route customer auth, middleware `customer_auth` |
| `src/Http/Controllers/BookingsController.php` | `storeCustomer()`, `myCustomerBookings()` |
| `src/UseCases/Booking/CreateBooking.php` | `executeForCustomer()` per booking da customer |
| `src/Domain/Booking/BookingException.php` | Aggiunto `invalidClient()` error |
| `src/Infrastructure/Repositories/BookingRepository.php` | Rimosso metodo duplicato `findByClientId()` |

### Migrazione Database

**File:** `migrations/0020_separate_customer_auth.sql`

**‚ö†Ô∏è PRIMA di eseguire la migrazione:**
1. Fare backup del database
2. Verificare che non ci siano utenti "puri clienti" da migrare (se non ce ne sono, la query INSERT non far√† nulla)

**Eseguire migrazione (se necessario):**
```bash
# Copia file su server
rsync -avz migrations/0020_separate_customer_auth.sql siteground:www/api.romeolab.it/migrations/

# Esegui migrazione
ssh siteground "cd www/api.romeolab.it && mysql -u \$DB_USERNAME -p\$DB_PASSWORD \$DB_DATABASE < migrations/0020_separate_customer_auth.sql"
```

### Middleware Registration (Kernel.php)

```php
// Middleware customer auth
$customerAuthMiddleware = new CustomerAuthMiddleware($jwtService);

// Route customer auth (pubbliche)
$router->post('/v1/customer/{business_id}/auth/register', ...);
$router->post('/v1/customer/{business_id}/auth/login', ...);
$router->post('/v1/customer/{business_id}/auth/refresh', ...);
$router->post('/v1/customer/{business_id}/auth/logout', ...);
$router->post('/v1/customer/{business_id}/auth/forgot-password', ...);
$router->post('/v1/customer/auth/reset-password', ...);

// Route customer protette
$router->group(['middleware' => [$customerAuthMiddleware]], function ($router) {
    $router->get('/v1/customer/me', ...);
    $router->post('/v1/customer/{business_id}/bookings', ...);
    $router->get('/v1/customer/bookings', ...);
});
```

### Migrazione Dati (ATTENZIONE)

La migrazione `0020_separate_customer_auth.sql`:
- Copia dati da `users` a `clients` solo per utenti **NON** in `business_users`
- Gli operatori/admin rimangono **solo** in `users`
- I clienti puri vengono copiati in `clients` con `password_hash`

```sql
-- Solo utenti NON operatori/admin
INSERT INTO clients (business_id, email, password_hash, first_name, last_name, phone, ...)
SELECT bu2.business_id, u.email, u.password_hash, u.first_name, u.last_name, u.phone, ...
FROM users u
JOIN bookings b ON b.user_id = u.id
JOIN appointments a ON a.booking_id = b.id
JOIN staff s ON s.id = a.staff_id
JOIN locations l ON l.id = s.location_id
JOIN business_users bu2 ON bu2.business_id = l.business_id AND bu2.is_owner = 1
WHERE u.password_hash IS NOT NULL
  AND NOT EXISTS (SELECT 1 FROM business_users bu WHERE bu.user_id = u.id)
GROUP BY u.id, bu2.business_id;
```

### Compatibilit√† Backward

L'`AuthMiddleware` per operatori √® **backward compatible**:
- Token senza campo `role` ‚Üí accettato (legacy)
- Token con `role: operator` ‚Üí accettato
- Token con `role: customer` ‚Üí rifiutato (401)

### ‚úÖ Integrazione Flutter Frontend (03/01/2026)

L'integrazione customer auth √® **COMPLETATA** in `agenda_frontend`:

| Componente | Stato | Note |
|------------|-------|------|
| `api_config.dart` | ‚úÖ | Endpoint customer auth |
| `api_client.dart` | ‚úÖ | Metodi `customerLogin()`, `customerRegister()`, `customerLogout()`, `getCustomerMe()` |
| `token_storage_*.dart` | ‚úÖ | Salvataggio `businessId` per refresh token |
| `auth_repository.dart` | ‚úÖ | Usa endpoint customer con `businessId` |
| `auth_provider.dart` | ‚úÖ | `login()`, `logout()`, `register()` richiedono `businessId` |
| `login_screen.dart` | ‚úÖ | Passa `businessId` da `currentBusinessIdProvider` |
| `register_screen.dart` | ‚úÖ | Passa `businessId` da `currentBusinessIdProvider` |

**Flow completo:**
```
1. Cliente accede a: prenota.romeolab.it/romeolab/login
2. Router estrae slug "romeolab" ‚Üí routeSlugProvider
3. currentBusinessProvider carica business da API ‚Üí id: 1
4. Login chiama: POST /v1/customer/1/auth/login
5. Token JWT con role: "customer" salvato in memoria
6. businessId salvato in localStorage/secureStorage per refresh
```

---


SOURCE OF TRUTH: ../../STAFF_PLANNING_MODEL.md

Agisci come senior backend engineer.

Obiettivo:
Integrare nel progetto agenda_core il modello di staff planning temporale gi√† implementato in agenda_backend.

Vincoli:
- Segui ESATTAMENTE STAFF_PLANNING_MODEL.md.
- Non introdurre nuove regole.
- Non modificare il modello dati deciso.
- Non riscrivere logica di business gi√† implementata nel backend.
- Esporre solo API e query necessarie.
- Non toccare agenda_backend n√© agenda_frontend.

Attivit√† obbligatorie:
1) Esporre via API le entit√† staff_planning e staff_planning_week_template.
2) Esporre endpoint per:
   - lettura planning per staff
   - lettura planning valido per una data
   - lettura disponibilit√† staff per una data
3) Gestire valid_to = null come ‚Äúmai‚Äù.
4) Rispettare intervalli temporali chiusi-chiusi.
5) Se pi√π planning risultano validi per una data, restituire errore di consistenza.
6) Non aggiungere fallback automatici.

Output richiesto:
- Codice PHP/API aggiornato.
- Eventuali query SQL di lettura necessarie.
- Nessuna spiegazione testuale.

----- FILE: docs/api_contract_v1.md -----

# API Contract v1 ‚Äî agenda_core

Base URL: `/v1`

---

## Health Check

### GET /health

No authentication required.

Response (200):
```json
{
  "status": "ok",
  "timestamp": "2025-01-15T10:00:00+01:00",
  "version": "1.0.0"
}
```

---

## Response Format

### Success
```json
{
  "success": true,
  "data": { ... }
}
```

### Error
```json
{
  "success": false,
  "error": {
    "code": "error_code",
    "message": "Human readable message",
    "details": { ... }
  }
}
```

---

## Auth Endpoints (globale, no business context)

### POST /v1/auth/login

Request:
```json
{
  "email": "user@example.com",
  "password": "secret"
}
```

Response (200):
```json
{
  "success": true,
  "data": {
    "access_token": "eyJ...",
    "refresh_token": "abc123...",
    "expires_in": 900,
    "user": {
      "id": 1,
      "email": "user@example.com",
      "first_name": "Mario",
      "last_name": "Rossi"
    }
  }
}
```

Note: `refresh_token` viene anche settato come cookie httpOnly.

---

### POST /v1/auth/register

Request:
```json
{
  "email": "newuser@example.com",
  "password": "SecurePass123!",
  "first_name": "Mario",
  "last_name": "Rossi",
  "phone": "+39123456789"
}
```

Oppure con campo `name` unificato:
```json
{
  "email": "newuser@example.com",
  "password": "SecurePass123!",
  "name": "Mario Rossi"
}
```

Response (201):
```json
{
  "success": true,
  "data": {
    "access_token": "eyJ...",
    "refresh_token": "abc123...",
    "expires_in": 900,
    "user": {
      "id": 4,
      "email": "newuser@example.com",
      "first_name": "Mario",
      "last_name": "Rossi"
    }
  }
}
```

Errors:
- `email_already_exists` (409): Email gi√† registrata
- `weak_password` (400): Password non sufficientemente sicura (min 8 caratteri, maiuscola, minuscola, numero)

---

### POST /v1/auth/forgot-password

Request:
```json
{
  "email": "user@example.com"
}
```

Response (200):
```json
{
  "success": true,
  "data": {
    "message": "If the email exists, a password reset link has been sent"
  }
}
```

Note: Ritorna sempre 200 per evitare email enumeration.

---

### POST /v1/auth/reset-password

Request:
```json
{
  "token": "abc123def456...",
  "password": "NewSecurePass456!"
}
```

Response (200):
```json
{
  "success": true,
  "data": {
    "message": "Password has been reset successfully"
  }
}
```

Errors:
- `invalid_reset_token` (400): Token non valido o gi√† usato
- `reset_token_expired` (400): Token scaduto (validit√† 1 ora)
- `weak_password` (400): Password non sufficientemente sicura

---

### POST /v1/auth/refresh

Request (body o cookie):
```json
{
  "refresh_token": "abc123..."
}
```

Response (200):
```json
{
  "success": true,
  "data": {
    "access_token": "eyJ...",
    "refresh_token": "new-token...",
    "expires_in": 900
  }
}
```

Note: Implementa token rotation (vecchio refresh token invalidato).

---

### POST /v1/auth/logout

Headers: `Authorization: Bearer <access_token>`

Request (body o cookie):
```json
{
  "refresh_token": "abc123..."
}
```

Response (200):
```json
{
  "success": true,
  "data": {
    "message": "Logged out successfully"
  }
}
```

---

### GET /v1/me

Headers: `Authorization: Bearer <access_token>`

Response (200):
```json
{
  "success": true,
  "data": {
    "id": 1,
    "email": "user@example.com",
    "first_name": "Mario",
    "last_name": "Rossi",
    "phone": "+39...",
    "is_active": true,
    "staff_memberships": [
      {
        "staff_id": 1,
        "business_id": 1,
        "business_name": "Salone Bella Vita",
        "role": "stylist",
        "display_name": "Mario R."
      }
    ]
  }
}
```

---

### PUT /v1/me

Aggiorna il profilo dell'utente autenticato.

Headers: `Authorization: Bearer <access_token>`

Request (tutti i campi opzionali):
```json
{
  "first_name": "Mario",
  "last_name": "Rossi",
  "email": "nuova@email.com",
  "phone": "+39 333 1234567"
}
```

Response (200):
```json
{
  "success": true,
  "data": {
    "user": {
      "id": 1,
      "email": "nuova@email.com",
      "first_name": "Mario",
      "last_name": "Rossi",
      "phone": "+39 333 1234567",
      "is_active": true
    }
  }
}
```

Errors:
- `unauthorized` (401): Access token non valido o scaduto
- `validation_error` (400): Email gi√† in uso da altro utente

---

### POST /v1/me/change-password

Headers: `Authorization: Bearer <access_token>`

Request:
```json
{
  "current_password": "OldPass123!",
  "new_password": "NewSecurePass456!"
}
```

Response (200):
```json
{
  "success": true,
  "data": {
    "message": "Password changed successfully"
  }
}
```

Errors:
- `unauthorized` (401): Access token non valido o scaduto
- `validation_error` (400): Current password e new password sono obbligatori
- `invalid_credentials` (400): Current password errata
- `weak_password` (400): New password non sufficientemente sicura
- `validation_error` (400): New password uguale a current password

Note: 
- La password deve contenere almeno 8 caratteri
- Deve includere: maiuscola, minuscola, numero
- La nuova password deve essere diversa da quella corrente

---

### GET /v1/me/bookings

Headers: `Authorization: Bearer <access_token>`

Get all bookings for the authenticated user (upcoming and past).

Response (200):
```json
{
  "success": true,
  "data": {
    "upcoming": [
      {
        "booking_id": 123,
        "status": "confirmed",
        "start_time": "2025-12-30T14:00:00+01:00",
        "end_time": "2025-12-30T15:30:00+01:00",
        "service_names": ["Taglio", "Piega"],
        "staff_name": "Mario Rossi",
        "total_price": 45.00,
        "notes": "Note opzionali",
        "location_id": 1,
        "location_name": "Sede Centro",
        "location_address": "Via Roma 123",
        "location_city": "Milano",
        "business_id": 1,
        "business_name": "Salone Bella Vita",
        "can_modify": true,
        "can_modify_until": "2025-12-29T14:00:00+01:00",
        "created_at": "2025-12-20T10:00:00+01:00"
      }
    ],
    "past": [
      {
        "booking_id": 100,
        "status": "completed",
        "start_time": "2025-12-15T10:00:00+01:00",
        "end_time": "2025-12-15T11:00:00+01:00",
        "service_names": ["Taglio Uomo"],
        "staff_name": "Luigi Bianchi",
        "total_price": 25.00,
        "notes": null,
        "location_id": 1,
        "location_name": "...",
        "business_id": 1,
        "business_name": "...",
        "can_modify": false,
        "can_modify_until": null,
        "created_at": "2025-12-10T09:00:00+01:00"
      }
    ]
  }
}
```

Note:
- `booking_id`: ID univoco del booking (alias `id` per compatibilit√† frontend)
- `service_names`: Array di nomi servizi (aggregati da booking_items)
- `staff_name`: Nome completo dello staff (primo assegnato)
- `total_price`: Somma dei prezzi di tutti i booking_items
- `can_modify`: `true` se now < can_modify_until
- `can_modify_until`: deadline calcolata da `start_time - cancellation_hours`
- `cancellation_hours`: policy configurata a livello location o business (default 24h)
- Upcoming bookings ordinati per start_time ASC (prossimo prima)
- Past bookings ordinati per start_time DESC (recente prima)
- Formato flat (no nested objects) per semplicit√† parsing

---

## Superadmin Endpoints (30/12/2025)

Endpoint riservati ai superadmin (`users.is_superadmin = 1`).

### GET /v1/admin/businesses

Lista tutti i business della piattaforma.

**Auth required**: Yes (superadmin only)

Query params:
- `search`: Filtra per nome (opzionale)
- `limit`: Max risultati (default 50, max 100)
- `offset`: Per paginazione

Response (200):
```json
{
  "success": true,
  "data": {
    "businesses": [
      {
        "id": 1,
        "name": "Salone Bella Vita",
        "slug": "salone-bella-vita",
        "email": "info@bellavita.it",
        "phone": "+39 06 12345678",
        "timezone": "Europe/Rome",
        "currency": "EUR",
        "is_active": true,
        "created_at": "2025-01-01T10:00:00+01:00",
        "admin_email": "admin@bellavita.it"
      }
    ],
    "total": 15,
    "limit": 50,
    "offset": 0
  }
}
```

Note:
- `admin_email` √® l'email dell'owner del business (pu√≤ essere null se non assegnato)

Errors:
- `forbidden` (403): Non superadmin

---

### POST /v1/admin/businesses

Crea un nuovo business con owner.

**Auth required**: Yes (superadmin only)

Request:
```json
{
  "name": "Nuovo Salone",
  "slug": "nuovo-salone",
  "admin_email": "admin@nuovosalone.it",
  "email": "info@nuovosalone.it",
  "phone": "+39 333 1234567",
  "timezone": "Europe/Rome",
  "currency": "EUR"
}
```

Note: 
- `name` e `slug` sono obbligatori
- `admin_email` (opzionale): email dell'admin del business
  - Se omesso, il business viene creato senza owner (assegnabile in seguito via PUT)
  - Se l'email non esiste, viene creato un nuovo utente
  - Viene inviata email di benvenuto con link reset password (24h)

Response (201):
```json
{
  "success": true,
  "data": {
    "business": {
      "id": 2,
      "name": "Nuovo Salone",
      "slug": "nuovo-salone",
      "email": "info@nuovosalone.it",
      "phone": "+39 333 1234567",
      "timezone": "Europe/Rome",
      "currency": "EUR",
      "is_active": true,
      "created_at": "2025-12-30T10:00:00+01:00"
    },
    "owner": {
      "id": 1,
      "user_id": 123,
      "business_id": 2,
      "role": "owner"
    }
  }
}
```

Errors:
- `forbidden` (403): Non superadmin
- `validation_error` (400): Slug gi√† esistente o campo mancante

---

### PUT /v1/admin/businesses/{id}

Modifica un business esistente.

**Auth required**: Yes (superadmin only)

Request (tutti i campi opzionali):
```json
{
  "name": "Nome Aggiornato",
  "slug": "slug-aggiornato",
  "admin_email": "nuovo-admin@email.it",
  "email": "nuova@email.it",
  "phone": "+39 333 9999999",
  "timezone": "Europe/Rome",
  "currency": "EUR"
}
```

Note:
- Se `admin_email` viene fornito su business senza owner, viene assegnato come owner
- Se `admin_email` viene cambiato, la ownership viene trasferita
- Il vecchio admin diventa "admin", il nuovo diventa "owner"
- Viene inviata email di benvenuto al nuovo admin

Response (200):
```json
{
  "success": true,
  "data": {
    "business": {
      "id": 2,
      "name": "Nome Aggiornato",
      "slug": "slug-aggiornato",
      "email": "nuova@email.it",
      "phone": "+39 333 9999999",
      "timezone": "Europe/Rome",
      "currency": "EUR",
      "is_active": true,
      "created_at": "2025-12-30T10:00:00+01:00"
    }
  }
}
```

Errors:
- `forbidden` (403): Non superadmin
- `validation_error` (400): Slug gi√† in uso da altro business
- `not_found` (404): Business non trovato

---

### POST /v1/admin/businesses/{id}/resend-invite

Reinvia email di invito all'admin del business.

**Auth required**: Yes (superadmin only)

Genera un nuovo token reset password (validit√† 24h) e invia email di benvenuto.
Utile se l'admin non ha impostato la password in tempo.

Response (200):
```json
{
  "success": true,
  "data": {
    "message": "Invite email sent successfully",
    "admin_email": "admin@example.com"
  }
}
```

Errors:
- `forbidden` (403): Non superadmin
- `not_found` (404): Business non trovato
- `not_found` (404): Business non ha un admin associato

---

### DELETE /v1/admin/businesses/{id}

Soft-delete di un business (imposta `is_active = false`).

**Auth required**: Yes (superadmin only)

Response (200):
```json
{
  "success": true,
  "data": {
    "message": "Business deleted successfully",
    "id": 2
  }
}
```

Errors:
- `forbidden` (403): Non superadmin
- `not_found` (404): Business non trovato

---

## Management Endpoints (admin/staff access)

### GET /v1/businesses

Headers: `Authorization: Bearer <access_token>`

Ritorna la lista di tutti i businesses. (In produzione potrebbe filtrare per user permissions).

Response (200):
```json
{
  "success": true,
  "data": {
    "businesses": [
      {
        "id": 1,
        "name": "Salone Bella Vita",
        "slug": "salone-bella-vita",
        "email": "info@bellavita.it",
        "phone": "+39 06 12345678",
        "timezone": "Europe/Rome",
        "currency": "EUR",
        "is_active": true,
        "created_at": "2025-01-01T00:00:00Z"
      }
    ]
  }
}
```

---

### GET /v1/businesses/{business_id}

Headers: `Authorization: Bearer <access_token>`

Response (200):
```json
{
  "success": true,
  "data": {
    "id": 1,
    "name": "Salone Bella Vita",
    "slug": "salone-bella-vita",
    "email": "info@bellavita.it",
    "phone": "+39 06 12345678",
    "timezone": "Europe/Rome",
    "currency": "EUR",
    "is_active": true,
    "created_at": "2025-01-01T00:00:00Z",
    "updated_at": "2025-01-15T10:00:00Z"
  }
}
```

Error - Not Found (404):
```json
{
  "success": false,
  "error": {
    "code": "not_found",
    "message": "Business not found"
  }
}
```

---

### GET /v1/businesses/{business_id}/locations

Headers: `Authorization: Bearer <access_token>`

Ritorna tutte le locations di un business.

Response (200):
```json
{
  "success": true,
  "data": {
    "data": [
      {
        "id": 1,
        "business_id": 1,
        "name": "Sede Centrale",
        "address": "Via Roma 123, Roma",
        "city": "Roma",
        "region": "Lazio",
        "country": "IT",
        "timezone": "Europe/Rome",
        "latitude": 41.9028,
        "longitude": 12.4964,
        "phone": "+39 06 12345678",
        "email": "roma@bellavita.it",
        "currency": "EUR",
        "is_default": true,
        "is_active": true,
        "created_at": "2025-01-15T10:00:00Z",
        "updated_at": "2025-01-15T10:00:00Z"
      }
    ]
  }
}
```

---

### GET /v1/businesses/{business_id}/locations/public

**No authentication required** (pubblico, per booking flow).

Ritorna le locations attive di un business con campi limitati per il frontend di prenotazione.

Response (200):
```json
{
  "success": true,
  "data": {
    "data": [
      {
        "id": 1,
        "business_id": 1,
        "name": "Sede Centrale",
        "address": "Via Roma 123",
        "city": "Roma",
        "phone": "+39 06 12345678",
        "timezone": "Europe/Rome",
        "is_default": true
      }
    ]
  }
}
```

Nota: Endpoint usato dal frontend di prenotazione per mostrare le sedi disponibili. Se il business ha pi√π di una location, l'utente pu√≤ scegliere dove prenotare.

---

### GET /v1/locations/{location_id}

Headers: `Authorization: Bearer <access_token>`

Response (200):
```json
{
  "success": true,
  "data": {
    "id": 1,
    "business_id": 1,
    "name": "Sede Centrale",
    "address": "Via Roma 123, Roma",
    "city": "Roma",
    "postal_code": "00100",
    "country": "IT",
    "timezone": "Europe/Rome",
    "latitude": 41.9028,
    "longitude": 12.4964,
    "phone": "+39 06 12345678",
    "email": "roma@bellavita.it",
    "currency": "EUR",
    "is_active": true,
    "created_at": "2025-01-01T00:00:00Z",
    "updated_at": "2025-01-15T10:00:00Z"
  }
}
```

---

## Public Endpoints (business-scoped via query param)

### GET /v1/services?location_id=1

Response (200):
```json
{
  "success": true,
  "data": {
    "categories": [
      {
        "id": 1,
        "name": "Taglio",
        "services": [
          {
            "id": 1,
            "name": "Taglio Uomo",
            "description": "...",
            "default_duration_minutes": 30,
            "default_price": 20.00,
            "color": "#FF6B6B",
            "category_id": 1
          }
        ]
      }
    ],
    "services": [ ... ]
  }
}
```

---

### GET /v1/staff?location_id=1

Response (200):
```json
{
  "success": true,
  "data": {
    "staff": [
      {
        "id": 1,
        "display_name": "Anna B.",
        "role": "stylist",
        "color": "#FF6B6B",
        "avatar_url": null
      }
    ]
  }
}
```

---

### GET /v1/availability?location_id=1&date=2024-01-15&service_ids=1,2&staff_id=1

Parameters:
- `location_id` (required): ID della location
- `date` (required): Data in formato YYYY-MM-DD
- `service_ids` (required): IDs servizi separati da virgola
- `staff_id` (optional): Filtra per staff specifico

Response (200):
```json
{
  "success": true,
  "data": {
    "slots": [
      {
        "start_time": "2024-01-15T09:00:00+01:00",
        "end_time": "2024-01-15T10:15:00+01:00",
        "staff_id": 1,
        "staff_name": "Anna B."
      }
    ]
  }
}
```

---

## Protected Endpoints (auth + business-scoped via path)

### POST /v1/locations/{location_id}/bookings

Headers:
- `Authorization: Bearer <access_token>` (required)
- `X-Idempotency-Key: <uuid-v4>` (required, formato UUID v4)

Request Payload (INVARIABILE):
```json
{
  "service_ids": [1, 2],
  "staff_id": 1,
  "start_time": "2024-01-15T10:00:00Z",
  "notes": "Prima visita"
}
```

Response (201):
```json
{
  "success": true,
  "data": {
    "id": 42,
    "business_id": 1,
    "location_id": 1,
    "client_id": 1,
    "status": "confirmed",
    "notes": "Prima visita",
    "total_price": 55.00,
    "total_duration_minutes": 75,
    "created_at": "2024-01-10T14:30:00Z",
    "items": [
      {
        "id": 1,
        "service_id": 1,
        "service_name": "Taglio Uomo",
        "staff_id": 1,
        "staff_name": "Anna B.",
        "location_id": 1,
        "start_time": "2024-01-15T10:00:00Z",
        "end_time": "2024-01-15T10:30:00Z",
        "price": 20.00,
        "duration_minutes": 30
      },
      {
        "id": 2,
        "service_id": 2,
        "service_name": "Taglio Donna",
        "staff_id": 1,
        "staff_name": "Anna B.",
        "location_id": 1,
        "start_time": "2024-01-15T10:30:00Z",
        "end_time": "2024-01-15T11:15:00Z",
        "price": 35.00,
        "duration_minutes": 45
      }
    ]
  }
}
```

Error - Slot Conflict (409):
```json
{
  "success": false,
  "error": {
    "code": "slot_conflict",
    "message": "The requested time slot is no longer available",
    "details": {
      "conflicts": [...]
    }
  }
}
```

---

### PUT /v1/locations/{location_id}/bookings/{booking_id}

Headers: `Authorization: Bearer <access_token>`

**Use Case 1: Update Status or Notes**

Request:
```json
{
  "status": "confirmed",
  "notes": "Cliente confermato via telefono"
}
```

**Use Case 2: Reschedule (Change Date/Time)**

Request:
```json
{
  "start_time": "2025-12-30T14:00:00+01:00",
  "notes": "Riprogrammazione appuntamento"
}
```

Campi opzionali (almeno uno richiesto):
- `status`: "pending" | "confirmed" | "cancelled" | "completed" | "no_show"
- `notes`: stringa
- `start_time`: ISO8601 datetime per reschedule

**Note sul Reschedule**:
- Aggiorna tutti i `booking_items` mantenendo durate e intervalli relativi
- Non permette cambio servizi o staff
- Soggetto a cancellation policy (stesso vincolo di DELETE)
- ‚úÖ Availability check server-side: verifica conflitti staff con `FOR UPDATE`
- Transazione atomica per evitare race conditions

Response (200):
```json
{
  "success": true,
  "data": {
    "id": 42,
    "status": "confirmed",
    "notes": "Cliente confermato via telefono",
    "items": [
      {
        "id": 101,
        "start_time": "2025-12-30T14:00:00+01:00",
        "end_time": "2025-12-30T15:00:00+01:00",
        ...
      }
    ],
    ...
  }
}
```

Error - Not Found (404):
```json
{
  "success": false,
  "error": {
    "code": "not_found",
    "message": "Booking not found"
  }
}
```

Error - Unauthorized (403):
```json
{
  "success": false,
  "error": {
    "code": "unauthorized",
    "message": "You do not have permission to update this booking"
  }
}
```

Error - Cancellation Policy Violation (400):
```json
{
  "success": false,
  "error": {
    "code": "validation_error",
    "message": "Cannot modify booking within 24 hours of appointment start time",
    "details": {
      "cancellation_deadline": "2025-12-29T14:00:00+01:00"
    }
  }
}
```
  }
}
```

---

### DELETE /v1/locations/{location_id}/bookings/{booking_id}

Headers: `Authorization: Bearer <access_token>`

Cancella un booking e tutti i suoi booking_items associati.

Response (200):
```json
{
  "success": true,
  "data": {
    "message": "Booking deleted successfully"
  }
}
```

Error - Not Found (404):
```json
{
  "success": false,
  "error": {
    "code": "not_found",
    "message": "Booking not found"
  }
}
```

Error - Unauthorized (403):
```json
{
  "success": false,
  "error": {
    "code": "unauthorized",
    "message": "You do not have permission to delete this booking"
  }
}
```

---

## Appointments (Gestionale)

### GET /v1/locations/{location_id}/appointments?date=YYYY-MM-DD

Get all appointments (booking_items) for a specific location and date.

**Auth required**: Yes  
**Middleware**: auth, location_path

Query params:
- `date` (required): Date in YYYY-MM-DD format

Response (200):
```json
{
  "success": true,
  "data": {
    "appointments": [
      {
        "id": 1,
        "booking_id": 10,
        "location_id": 1,
        "staff_id": 2,
        "service_variant_id": 5,
        "start_time": "2025-12-27T10:00:00+01:00",
        "end_time": "2025-12-27T10:30:00+01:00",
        "extra_blocked_minutes": 0,
        "extra_processing_minutes": 0,
        "booking_status": "confirmed",
        "client_name": "Mario Rossi",
        "service_name": "Taglio Uomo",
        "staff_name": "Anna Bianchi",
        "created_at": "2025-12-26T15:00:00+01:00",
        "updated_at": "2025-12-26T15:00:00+01:00"
      }
    ]
  }
}
```

---

### PATCH /v1/locations/{location_id}/appointments/{id}

Reschedule or update an appointment.

**Auth required**: Yes  
**Middleware**: auth, location_path  
**Permission**: Only booking owner can update

Request:
```json
{
  "start_time": "2025-12-27T11:00:00+01:00",
  "end_time": "2025-12-27T11:30:00+01:00",
  "staff_id": 3
}
```

Response (200):
```json
{
  "success": true,
  "data": {
    "id": 1,
    "booking_id": 10,
    "start_time": "2025-12-27T11:00:00+01:00",
    "end_time": "2025-12-27T11:30:00+01:00",
    "staff_id": 3,
    "..."
  }
}
```

---

### POST /v1/locations/{location_id}/appointments/{id}/cancel

Cancel an appointment.

**Auth required**: Yes  
**Middleware**: auth, location_path  
**Permission**: Only booking owner can cancel

Response (200):
```json
{
  "success": true,
  "data": {
    "cancelled": true,
    "appointment_id": 1
  }
}
```

---

## Clients (Gestionale)

### GET /v1/clients?business_id=X&search=term

Get clients for a business.

**Auth required**: Yes

Query params:
- `business_id` (required): Business ID
- `search` (optional): Search term (name, email, phone)
- `limit` (optional): Max results (default 100)
- `offset` (optional): Pagination offset

Response (200):
```json
{
  "success": true,
  "data": {
    "clients": [
      {
        "id": 1,
        "business_id": 1,
        "user_id": 5,
        "first_name": "Mario",
        "last_name": "Rossi",
        "email": "mario@example.com",
        "phone": "+39123456789",
        "notes": null,
        "is_archived": false,
        "created_at": "2025-01-01T10:00:00+01:00",
        "updated_at": "2025-01-01T10:00:00+01:00"
      }
    ]
  }
}
```

---

### POST /v1/clients

Create a new client.

**Auth required**: Yes

Request:
```json
{
  "business_id": 1,
  "first_name": "Mario",
  "last_name": "Rossi",
  "email": "mario@example.com",
  "phone": "+39123456789",
  "notes": "Cliente VIP"
}
```

Response (201):
```json
{
  "success": true,
  "data": {
    "id": 1,
    "business_id": 1,
    "first_name": "Mario",
    "..."
  }
}
```

---

### PUT /v1/clients/{id}

Update a client.

**Auth required**: Yes

Request:
```json
{
  "first_name": "Mario",
  "last_name": "Rossi",
  "email": "newemail@example.com",
  "phone": "+39987654321",
  "notes": "Updated notes",
  "is_archived": false
}
```

---

### DELETE /v1/clients/{id}

Archive a client (soft delete).

**Auth required**: Yes

Response (200):
```json
{
  "success": true,
  "data": {
    "deleted": true
  }
}
```

---

## Business Users (Operators) Endpoints

Endpoints per gestire gli operatori di un business (chi pu√≤ accedere al gestionale).

### GET /v1/businesses/{business_id}/users

List operators for a business.

**Auth required**: Yes (owner/admin or superadmin)

Response (200):
```json
{
  "success": true,
  "data": {
    "users": [
      {
        "id": 1,
        "user_id": 2,
        "business_id": 1,
        "role": "owner",
        "email": "anna@example.com",
        "first_name": "Anna",
        "last_name": "Bianchi",
        "status": "active",
        "invited_at": null,
        "joined_at": "2025-01-01T10:00:00+01:00",
        "is_current_user": true
      },
      {
        "id": 2,
        "user_id": 3,
        "business_id": 1,
        "role": "staff",
        "email": "mario@example.com",
        "first_name": "Mario",
        "last_name": "Rossi",
        "status": "active",
        "invited_at": "2025-12-28T10:00:00+01:00",
        "joined_at": "2025-12-28T12:00:00+01:00",
        "is_current_user": false
      }
    ]
  }
}
```

---

### POST /v1/businesses/{business_id}/users

Add an existing user to a business.

**Auth required**: Yes (owner/admin or superadmin)

Request:
```json
{
  "user_id": 5,
  "role": "staff"
}
```

Response (201):
```json
{
  "success": true,
  "data": {
    "id": 3,
    "user_id": 5,
    "business_id": 1,
    "role": "staff"
  }
}
```

Errors:
- `already_member` (409): User gi√† membro del business
- `forbidden` (403): Non puoi assegnare un ruolo >= al tuo

---

### PATCH /v1/businesses/{business_id}/users/{user_id}

Update operator role.

**Auth required**: Yes (owner/admin or superadmin)

Request:
```json
{
  "role": "manager"
}
```

Response (200):
```json
{
  "success": true,
  "data": {
    "id": 2,
    "user_id": 3,
    "role": "manager"
  }
}
```

---

### DELETE /v1/businesses/{business_id}/users/{user_id}

Remove operator from business.

**Auth required**: Yes (owner/admin or superadmin)

Response (200):
```json
{
  "success": true,
  "data": {
    "removed": true
  }
}
```

Errors:
- `forbidden` (403): Non puoi rimuovere owner o te stesso

---

## Business Invitations Endpoints

Endpoints per gestire inviti via email agli operatori.

### GET /v1/businesses/{business_id}/invitations

List pending invitations for a business.

**Auth required**: Yes (owner/admin or superadmin)

Response (200):
```json
{
  "success": true,
  "data": {
    "invitations": [
      {
        "id": 1,
        "email": "nuovo@example.com",
        "role": "staff",
        "expires_at": "2026-01-04T14:00:00+01:00",
        "created_at": "2025-12-28T14:00:00+01:00",
        "invited_by": {
          "first_name": "Anna",
          "last_name": "Bianchi"
        }
      }
    ]
  }
}
```

---

### POST /v1/businesses/{business_id}/invitations

Create a new invitation.

**Auth required**: Yes (owner/admin or superadmin)

Request:
```json
{
  "email": "nuovo@example.com",
  "role": "staff"
}
```

Response (201):
```json
{
  "success": true,
  "data": {
    "id": 1,
    "email": "nuovo@example.com",
    "role": "staff",
    "token": "abc123...",
    "expires_at": "2026-01-04T14:00:00+01:00",
    "invite_url": "https://app.example.com/invite/abc123...",
    "business": {
      "id": 1,
      "name": "Salone Bella Vita"
    }
  }
}
```

Errors:
- `validation_error` (400): Email gi√† membro del business
- `validation_error` (400): Invito gi√† pendente per questa email
- `forbidden` (403): Non puoi invitare con ruolo >= al tuo

---

### DELETE /v1/businesses/{business_id}/invitations/{invitation_id}

Revoke a pending invitation.

**Auth required**: Yes (owner/admin or superadmin)

Response (200):
```json
{
  "success": true,
  "data": {
    "message": "Invitation revoked",
    "id": 1
  }
}
```

---

### GET /v1/invitations/{token}

Get invitation details (public endpoint, no auth required).

Response (200):
```json
{
  "success": true,
  "data": {
    "email": "nuovo@example.com",
    "role": "staff",
    "business": {
      "id": 1,
      "name": "Salone Bella Vita",
      "slug": "salone-bella-vita"
    },
    "expires_at": "2026-01-04T14:00:00+01:00"
  }
}
```

Errors:
- `not_found` (404): Token non valido
- `validation_error` (400): Invito scaduto o gi√† usato

---

### POST /v1/invitations/{token}/accept

Accept an invitation.

**Auth required**: Yes (email must match invitation)

Response (200):
```json
{
  "success": true,
  "data": {
    "message": "Invitation accepted",
    "business_id": 1,
    "business_name": "Salone Bella Vita",
    "role": "staff"
  }
}
```

Errors:
- `not_found` (404): Token non valido
- `validation_error` (400): Invito scaduto
- `forbidden` (403): Email non corrisponde all'invito

---

## Business Context Derivation

| Endpoint Type | location_id Source | business_id |
|---------------|-------------------|-------------|
| Auth | N/A | N/A |
| Public | Query param `?location_id=X` | DB lookup da location_id |
| POST /bookings | PATH param `/locations/{X}/...` | DB lookup da location_id |

**IMPORTANTE**: JWT contiene SOLO `user_id`. MAI `business_id` o `location_id`.

---

## Error Codes

| Code | HTTP | Descrizione |
|------|------|-------------|
| `invalid_credentials` | 401 | Email o password errati |
| `account_disabled` | 401 | Account disabilitato |
| `token_expired` | 401 | Access token scaduto |
| `token_invalid` | 401 | Token malformato o firma invalida |
| `session_revoked` | 401 | Refresh token revocato |
| `unauthorized` | 401 | Authorization header mancante |
| `missing_location` | 400 | location_id non fornito |
| `invalid_location` | 400 | Location non esiste o non attiva |
| `slot_conflict` | 409 | Slot gi√† occupato |
| `invalid_service` | 400 | Servizio non valido |
| `invalid_staff` | 400 | Staff non disponibile |
| `invalid_time` | 400 | Orario non valido |
| `validation_error` | 400 | Errore di validazione generico |
| `not_found` | 404 | Risorsa non trovata |
| `internal_error` | 500 | Errore interno |

---

## Idempotency

Per `POST /bookings`, inviare header `X-Idempotency-Key: <uuid>`.

Se una richiesta con lo stesso `idempotency_key` viene ripetuta (stesso business):
- Se booking gi√† creato ‚Üí ritorna booking esistente (200)
- Se in corso ‚Üí attende completamento

Chiave unica: `(business_id, idempotency_key)`

----- FILE: docs/data_models.md -----

# Data Models ‚Äî agenda_core

## Core Entities

### Service
- id
- business_id
- category_id
- name
- duration_minutes
- price
- is_free
- is_price_starting_from
- is_bookable_online

### Staff
- id
- business_id
- name
- surname
- is_bookable_online

### Booking
- id
- business_id
- location_id
- customer_id
- start_time
- end_time
- notes

---

## User & Auth Entities

### User
- id
- email (unique, global)
- password_hash
- first_name
- last_name
- phone
- is_active
- is_superadmin
- created_at
- updated_at

### AuthSession
- id
- user_id
- refresh_token_hash (SHA-256)
- device_info
- ip_address
- last_used_at
- expires_at
- revoked_at
- created_at

---

## Business Access Control (M11)

### BusinessUser
Associa utenti a businesses con ruoli e permessi.

- id
- business_id
- user_id
- role (enum: owner, admin, manager, staff)
- staff_id (optional, link a staff record)
- can_manage_bookings
- can_manage_clients
- can_manage_services
- can_manage_staff
- can_view_reports
- is_active
- invited_by
- invited_at
- joined_at
- created_at
- updated_at

**Role Hierarchy:**
- `owner`: Full control, can delete business, manage all users
- `admin`: Full control except delete business, can manage users
- `manager`: Can manage appointments, clients, staff schedules
- `staff`: Can view/edit own appointments only

**Unique Constraint:** `(business_id, user_id)`

### BusinessInvitation
Inviti via email per nuovi operatori.

- id
- business_id
- email
- role (enum: admin, manager, staff)
- token (64-char hex, unique)
- expires_at (default: created_at + 7 days)
- status (enum: pending, accepted, expired, revoked)
- accepted_by (user_id, nullable)
- accepted_at (nullable)
- invited_by (user_id)
- created_at
- updated_at

**Unique Constraint:** `(business_id, email, status)` - un solo invito pending per email

**Indexes:**
- `token, status` - lookup per accettazione
- `business_id, status` - lista inviti pendenti
- `email, status` - ricerca inviti per email

---

## Relationships

```
User (1) ----< (N) AuthSession
User (1) ----< (N) BusinessUser >---- (1) Business
User (1) ----< (N) BusinessInvitation >---- (1) Business
Business (1) ----< (N) Location
Business (1) ----< (N) Staff
Business (1) ----< (N) Service
Business (1) ----< (N) Client
Location (1) ----< (N) Booking
```

---

## Notes

- `is_superadmin` in `users` √® flag globale, non legato a nessun business
- Superadmin bypassa completamente `business_users` e pu√≤ operare su qualsiasi business
- `staff_id` in `business_users` permette di collegare un operatore al suo calendario staff

----- FILE: docs/db_schema_mvp.md -----

# DB Schema MVP ‚Äî agenda_core

Schema MySQL/MariaDB per la piattaforma Agenda multi-tenant.

---

## üèóÔ∏è Architettura Multi-Tenant

### Modello di Identit√†

| Entit√† | Scope | Note |
|--------|-------|------|
| `users` | **GLOBALE** | Solo per login/auth. Nessun business_id. |
| `clients` | **PER BUSINESS** | Anagrafica locale. Ha business_id e user_id opzionale. |

Un utente pu√≤ essere client di pi√π business tramite pi√π record `clients`.
Ogni business vede esclusivamente i propri clients.

### JWT

| Campo | Presente | Note |
|-------|----------|------|
| user_id | ‚úÖ | Identit√† utente |
| business_id | ‚ùå | MAI nel JWT |
| location_id | ‚ùå | MAI nel JWT |

### Derivazione contesto business

| Campo | Origine | Quando |
|-------|---------|--------|
| `location_id` | **PATH parameter** | Sempre. Es: `/v1/locations/{location_id}/bookings` |
| `business_id` | **Lookup DB** | `SELECT business_id FROM locations WHERE id = :location_id` |

**‚ö†Ô∏è IMPORTANTE:** 
- Il contesto business deriva SEMPRE dal `location_id` nel PATH
- `business_id` NON √® nel payload, NON √® nel JWT
- Il server lo ricava dal database partendo da `location_id`

---

## üìä Diagramma ER semplificato

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  businesses ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ<‚îÇ  locations  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                   ‚îÇ
       ‚îÇ                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ                   ‚ñº                  ‚ñº
       ‚îÇ            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ            ‚îÇ    staff    ‚îÇ    ‚îÇ   resources   ‚îÇ
       ‚îÇ            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                   ‚îÇ
       ‚ñº                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ
‚îÇ business_users ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ (staff_id opzionale)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ
       ‚îÇ                   ‚îÇ
       ‚ñº                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ
‚îÇ    users    ‚îÇ            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ
       ‚îÇ                   ‚îÇ
       ‚ñº                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
‚îÇ auth_sessions ‚îÇ          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
                           ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ
‚îÇ  services   ‚îÇ            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ
       ‚îÇ                   ‚îÇ
       ‚ñº                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ service_variants ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  bookings   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ<‚îÇ booking_items ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚ñ≤
       ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   clients   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìã Tabelle

### 1. businesses
Tenant principale. Ogni business √® completamente isolato.

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| name | VARCHAR(255) NOT NULL | |
| slug | VARCHAR(100) UNIQUE NOT NULL | Per URL pubblici |
| email | VARCHAR(255) | |
| phone | VARCHAR(50) | |
| timezone | VARCHAR(50) DEFAULT 'Europe/Rome' | |
| currency | VARCHAR(3) DEFAULT 'EUR' | |
| cancellation_hours | INT UNSIGNED DEFAULT 24 | Default policy: ore minime prima appuntamento per cancellare/modificare |
| is_active | TINYINT(1) DEFAULT 1 | |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

### 2. locations
Sedi fisiche di un business.

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| business_id | INT UNSIGNED FK NOT NULL | |
| name | VARCHAR(255) NOT NULL | |
| address | VARCHAR(500) | |
| city | VARCHAR(100) | |
| postal_code | VARCHAR(20) | Aggiunto in migration 0009 |
| region | VARCHAR(100) | |
| country | VARCHAR(100) DEFAULT 'IT' | |
| phone | VARCHAR(50) | |
| email | VARCHAR(255) | |
| latitude | DECIMAL(10,8) | |
| longitude | DECIMAL(11,8) | |
| timezone | VARCHAR(50) DEFAULT 'Europe/Rome' | Aggiunto in migration 0005 |
| currency | VARCHAR(3) | Override business |
| cancellation_hours | INT UNSIGNED NULL | Override business cancellation policy. NULL = usa business default |
| is_default | TINYINT(1) DEFAULT 0 | |
| is_active | TINYINT(1) DEFAULT 1 | |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

### 3. users
Utenti GLOBALI per autenticazione. Non appartengono a nessun business.
Un utente pu√≤ operare con pi√π business diversi tramite la tabella `business_users` (operatori gestionale) o `clients` (clienti prenotazione).

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| email | VARCHAR(255) UNIQUE NOT NULL | Globale, non per business |
| password_hash | VARCHAR(255) NOT NULL | bcrypt/argon2 |
| first_name | VARCHAR(100) NOT NULL | |
| last_name | VARCHAR(100) NOT NULL | |
| phone | VARCHAR(50) | |
| email_verified_at | TIMESTAMP | |
| is_active | TINYINT(1) DEFAULT 1 | |
| is_superadmin | TINYINT(1) DEFAULT 0 | Ruolo globale: pu√≤ gestire tutti i business senza record in business_users |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

**Superadmin**: Non ha record in `business_users`. Quando seleziona un business, opera come admin.

### 3a. business_users
Associazione utenti-business per operatori del gestionale (multi-tenant access control).

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| business_id | INT UNSIGNED FK NOT NULL | |
| user_id | INT UNSIGNED FK NOT NULL | |
| role | ENUM('owner','admin','manager','staff') DEFAULT 'staff' | Gerarchia permessi |
| staff_id | INT UNSIGNED FK NULL | Link opzionale a record staff |
| can_manage_bookings | TINYINT(1) DEFAULT 1 | |
| can_manage_clients | TINYINT(1) DEFAULT 1 | |
| can_manage_services | TINYINT(1) DEFAULT 0 | |
| can_manage_staff | TINYINT(1) DEFAULT 0 | |
| can_view_reports | TINYINT(1) DEFAULT 0 | |
| is_active | TINYINT(1) DEFAULT 1 | |
| invited_by | INT UNSIGNED FK NULL | User che ha invitato |
| invited_at | TIMESTAMP NULL | |
| accepted_at | TIMESTAMP NULL | |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

UNIQUE (business_id, user_id)

**Ruoli e permessi default:**
| Ruolo | bookings | clients | services | staff | reports |
|-------|----------|---------|----------|-------|---------|
| owner | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| admin | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| manager | ‚úÖ | ‚úÖ | ‚ùå | ‚ùå | ‚úÖ |
| staff | ‚úÖ* | ‚úÖ* | ‚ùå | ‚ùå | ‚ùå |

*staff: solo propri appuntamenti/clienti di default

### 3b. business_invitations
Inviti via email per nuovi operatori del business.

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| business_id | INT UNSIGNED FK NOT NULL | |
| email | VARCHAR(255) NOT NULL | Email destinatario |
| role | ENUM('admin','manager','staff') DEFAULT 'staff' | Ruolo assegnato |
| token | VARCHAR(64) NOT NULL UNIQUE | Token hex 64 caratteri |
| expires_at | TIMESTAMP NOT NULL | Default: +7 giorni |
| status | ENUM('pending','accepted','expired','revoked') DEFAULT 'pending' | |
| accepted_by | INT UNSIGNED FK NULL | User che ha accettato |
| accepted_at | TIMESTAMP NULL | |
| invited_by | INT UNSIGNED FK NOT NULL | User che ha invitato |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

UNIQUE (business_id, email, status) - un solo invito pending per email

**Indexes:**
- `(token, status)` - lookup per accettazione
- `(business_id, status)` - lista inviti pendenti
- `(email, status)` - ricerca inviti per email

**Flusso invito:**
1. Owner/Admin crea invito ‚Üí genera token
2. Email inviata con link `/invite/{token}`
3. Destinatario apre link, fa login/register
4. `POST /v1/invitations/{token}/accept` ‚Üí crea record `business_users`

### 4. auth_sessions
Sessioni di autenticazione con refresh token (hash, mai in chiaro).

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| user_id | INT UNSIGNED FK NOT NULL | |
| refresh_token_hash | VARCHAR(255) NOT NULL | SHA-256 del token |
| user_agent | VARCHAR(500) | Per identificare device |
| ip_address | VARCHAR(45) | IPv4 o IPv6 |
| expires_at | TIMESTAMP NOT NULL | Scadenza refresh token |
| last_used_at | TIMESTAMP | Ultimo utilizzo (per rotation) |
| revoked_at | TIMESTAMP | Se revocato manualmente |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |

**Rotation pattern:**
1. Al refresh, si crea una nuova sessione con nuovo `refresh_token_hash`
2. La vecchia sessione viene marcata con `revoked_at = NOW()`
3. Se un token revocato viene riutilizzato ‚Üí si revocano TUTTE le sessioni utente (possibile furto)

### 5. service_categories
Categorie di servizi per organizzazione.

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| business_id | INT UNSIGNED FK NOT NULL | |
| name | VARCHAR(255) NOT NULL | |
| description | TEXT | |
| sort_order | INT DEFAULT 0 | |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

### 6. services
Servizi offerti dal business.

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| business_id | INT UNSIGNED FK NOT NULL | |
| category_id | INT UNSIGNED FK NOT NULL | |
| name | VARCHAR(255) NOT NULL | |
| description | TEXT | |
| sort_order | INT DEFAULT 0 | |
| is_active | TINYINT(1) DEFAULT 1 | |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

### 7. service_variants
Varianti di servizio per location (durata, prezzo, disponibilit√† online).

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| service_id | INT UNSIGNED FK NOT NULL | |
| location_id | INT UNSIGNED FK NOT NULL | |
| duration_minutes | INT UNSIGNED NOT NULL | |
| processing_time | INT UNSIGNED | Minuti post-lavorazione |
| blocked_time | INT UNSIGNED | Minuti bloccati |
| price | DECIMAL(10,2) NOT NULL DEFAULT 0 | |
| currency | VARCHAR(3) | Override location |
| color_hex | VARCHAR(7) | Es. #FF5733 |
| is_bookable_online | TINYINT(1) DEFAULT 1 | |
| is_free | TINYINT(1) DEFAULT 0 | |
| is_price_starting_from | TINYINT(1) DEFAULT 0 | "da ‚Ç¨X" |
| is_active | TINYINT(1) DEFAULT 1 | |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

UNIQUE (service_id, location_id)

### 8. staff
Operatori/dipendenti del business.

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| business_id | INT UNSIGNED FK NOT NULL | |
| name | VARCHAR(100) NOT NULL | |
| surname | VARCHAR(100) DEFAULT '' | |
| color_hex | VARCHAR(7) DEFAULT '#FFD700' | |
| avatar_url | VARCHAR(500) | |
| sort_order | INT DEFAULT 0 | |
| is_default | TINYINT(1) DEFAULT 0 | |
| is_bookable_online | TINYINT(1) DEFAULT 1 | |
| is_active | TINYINT(1) DEFAULT 1 | |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

### 9. staff_locations
Relazione N:M staff ‚Üî locations.

| Colonna | Tipo | Note |
|---------|------|------|
| staff_id | INT UNSIGNED FK NOT NULL | PK part |
| location_id | INT UNSIGNED FK NOT NULL | PK part |

PRIMARY KEY (staff_id, location_id)

### 9a. staff_services
Restrizioni servizi per staff (quali servizi ogni staff pu√≤ erogare).

| Colonna | Tipo | Note |
|---------|------|------|
| staff_id | INT UNSIGNED FK NOT NULL | PK part |
| service_id | INT UNSIGNED FK NOT NULL | PK part |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |

PRIMARY KEY (staff_id, service_id)

**Logica**: Se la tabella √® vuota per uno staff, pu√≤ erogare tutti i servizi (permissivo di default). Se esistono record, validare che lo staff possa erogare TUTTI i servizi richiesti.

### 9b. location_schedules
Orari di apertura per location per giorno della settimana.

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| location_id | INT UNSIGNED FK NOT NULL | |
| day_of_week | TINYINT UNSIGNED NOT NULL | 0=Sunday, 1=Monday, ..., 6=Saturday |
| open_time | TIME NOT NULL | Orario apertura (es. 09:00:00) |
| close_time | TIME NOT NULL | Orario chiusura (es. 18:00:00) |
| is_closed | TINYINT(1) DEFAULT 0 | Giorno chiuso |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

UNIQUE (location_id, day_of_week)

CHECK (day_of_week BETWEEN 0 AND 6)
CHECK (open_time < close_time OR is_closed = 1)

**Fallback**: Se non configurato, default 9:00-18:00 Lun-Ven.

### 10. clients
Clienti gestiti dal business (anagrafica gestionale).

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| business_id | INT UNSIGNED FK NOT NULL | |
| user_id | INT UNSIGNED FK | Link a user se registrato online |
| first_name | VARCHAR(100) | |
| last_name | VARCHAR(100) | |
| email | VARCHAR(255) | |
| phone | VARCHAR(50) | |
| gender | VARCHAR(20) | |
| birth_date | DATE | |
| city | VARCHAR(100) | |
| notes | TEXT | |
| loyalty_points | INT DEFAULT 0 | |
| last_visit | TIMESTAMP | |
| is_archived | TINYINT(1) DEFAULT 0 | |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

INDEX (business_id, email)
INDEX (business_id, phone)

### 11. bookings
Prenotazioni (contenitore di uno o pi√π servizi).

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| business_id | INT UNSIGNED FK NOT NULL | |
| location_id | INT UNSIGNED FK NOT NULL | |
| client_id | INT UNSIGNED FK | |
| user_id | INT UNSIGNED FK | User che ha prenotato online |
| client_name | VARCHAR(255) | Fallback se no client |
| notes | TEXT | |
| status | ENUM('pending','confirmed','completed','cancelled','no_show') DEFAULT 'confirmed' | |
| source | ENUM('online','manual','import') DEFAULT 'manual' | |
| idempotency_key | VARCHAR(64) | Per idempotenza POST |
| idempotency_expires_at | TIMESTAMP | TTL per cleanup |

UNIQUE (business_id, idempotency_key) ‚Äî scoped per tenant, evita collisioni globali
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

INDEX (business_id, location_id, created_at)
INDEX (client_id)
INDEX (user_id)

### 12. booking_items
Singoli appuntamenti/servizi dentro una booking (multi-servizio).

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| booking_id | INT UNSIGNED FK NOT NULL | |
| location_id | INT UNSIGNED FK NOT NULL | Denormalizzato per query availability |
| service_id | INT UNSIGNED FK NOT NULL | |
| service_variant_id | INT UNSIGNED FK NOT NULL | |
| staff_id | INT UNSIGNED FK NOT NULL | |
| start_time | TIMESTAMP NOT NULL | UTC |
| end_time | TIMESTAMP NOT NULL | UTC |
| price | DECIMAL(10,2) | Prezzo applicato |
| extra_blocked_minutes | INT UNSIGNED DEFAULT 0 | |
| extra_processing_minutes | INT UNSIGNED DEFAULT 0 | |
| service_name_snapshot | VARCHAR(255) | Denormalizzato |
| client_name_snapshot | VARCHAR(255) | Denormalizzato |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

INDEX (staff_id, start_time, end_time)
INDEX (location_id, start_time, end_time) ‚Äî per availability senza JOIN

### 13. resources (opzionale MVP+)
Risorse fisiche (es. cabine, attrezzature).

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| location_id | INT UNSIGNED FK NOT NULL | |
| name | VARCHAR(255) NOT NULL | |
| quantity | INT UNSIGNED DEFAULT 1 | |
| type | VARCHAR(100) | |
| note | TEXT | |
| is_active | TINYINT(1) DEFAULT 1 | |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

---

## üîê Idempotenza per POST /bookings

### Strategia
1. Client genera un `Idempotency-Key` (UUID v4) e lo include nell'header
2. Server verifica se esiste gi√† una booking con quella key:
   - **Esiste**: ritorna la booking esistente (HTTP 200, non 201)
   - **Non esiste**: crea la booking e salva la key
3. Le key scadono dopo 24h (cleanup via cron o TTL index)

### Colonne dedicate in `bookings`
```sql
idempotency_key VARCHAR(64) UNIQUE,
idempotency_expires_at TIMESTAMP
```

### Alternativa: tabella separata
Se si preferisce non "sporcare" la tabella bookings:
```sql
CREATE TABLE idempotency_keys (
  key_hash VARCHAR(64) PRIMARY KEY,
  resource_type VARCHAR(50) NOT NULL,
  resource_id INT UNSIGNED NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Scelta MVP:** Colonne dedicate in `bookings` (pi√π semplice, meno join).

---

## üîê Password Reset Tokens

Tabella per gestire il flusso di password reset in modo sicuro.

### password_reset_tokens

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| user_id | INT UNSIGNED NOT NULL | FK ‚Üí users.id |
| token_hash | VARCHAR(64) NOT NULL | SHA-256 del token inviato via email |
| expires_at | TIMESTAMP NOT NULL | Validit√† 1 ora dalla creazione |
| used_at | TIMESTAMP NULL | NULL = non ancora usato |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |

**Indici**:
```sql
INDEX idx_token_hash (token_hash)
INDEX idx_user_id (user_id)
INDEX idx_expires_at (expires_at)  -- Per cleanup automatico
```

**Foreign Keys**:
```sql
FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
```

**Security**:
- Token plain-text inviato via email, mai salvato nel DB
- Solo SHA-256 hash salvato per lookup
- Token monouso: `used_at IS NULL` per validit√†
- Scadenza 1 ora per ridurre finestra attacco
- Cleanup automatico via cron o TTL index

**Flusso**:
1. `POST /auth/forgot-password` ‚Üí genera token random (32 bytes), hash SHA-256, salva, invia email
2. User click link email ‚Üí `POST /auth/reset-password` con token plain-text
3. Server calcola SHA-256(token), cerca in DB con `used_at IS NULL AND expires_at > NOW()`
4. Se valido: update password, marca `used_at = NOW()`, invalida sessioni

**Migration**: Inclusa in `FULL_DATABASE_SCHEMA.sql`

---

## üïê Gestione fusi orari

- **DB**: Tutti i `TIMESTAMP` sono in **UTC**
- **API**: Tutti gli orari in **ISO8601** con timezone (`2025-01-15T10:00:00+01:00`)
- **Conversione**: Il server converte da/verso UTC usando `businesses.timezone`

---

## üìà Indici raccomandati

```sql
-- Query frequenti agenda
CREATE INDEX idx_booking_items_staff_time 
  ON booking_items(staff_id, start_time, end_time);

-- Disponibilit√†
CREATE INDEX idx_booking_items_location_time 
  ON booking_items(location_id, start_time, end_time);

-- Multi-tenant
CREATE INDEX idx_bookings_business_location 
  ON bookings(business_id, location_id);

-- Sessioni attive
CREATE INDEX idx_auth_sessions_user_expires 
  ON auth_sessions(user_id, expires_at, revoked_at);

-- Cleanup idempotency
CREATE INDEX idx_bookings_idempotency_expires 
  ON bookings(idempotency_expires_at);
```

---

## üîÑ Compatibilit√† con i client

### Frontend (BookingRequest ‚Üí bookings + booking_items)
```
service_ids ‚Üí booking_items.service_id (uno per ogni)
staff_id ‚Üí booking_items.staff_id (se null, assegnato dal server)
start_time ‚Üí booking_items.start_time (calcolato in sequenza)
notes ‚Üí bookings.notes
```

### Backend (Appointment ‚Üí booking_items)
La tabella `booking_items` corrisponde al modello `Appointment` del gestionale:
- `booking_id` = relazione con booking
- `service_id`, `service_variant_id`, `staff_id` = riferimenti
- `start_time`, `end_time` = slot temporale
- `extra_*_minutes` = tempi extra
- `*_snapshot` = valori denormalizzati per storico

----- FILE: docs/decisions.md -----

# Decisions ‚Äî agenda_core

- JWT access + refresh token (rotazione)
- Prenotazione pubblica, login solo in conferma
- snake_case
- ISO 8601
- UTC nel DB
- Idempotency-Key su POST /bookings

---

## Decisioni DB Schema MVP (2025-12-26)

### 1. Appointment vs booking_items
**Contesto**: Il backend usa il modello `Appointment` con molti campi, il frontend usa `BookingRequest` pi√π semplice.

**Decisione**: La tabella `booking_items` unifica entrambi i modelli:
- Corrisponde a `Appointment` del gestionale
- Supporta multi-servizio come richiesto da `BookingRequest.service_ids`
- Campi legacy `extra_minutes`/`extra_minutes_type` mappati su `extra_blocked_minutes`/`extra_processing_minutes`

### 2. Service vs ServiceVariant
**Contesto**: Il backend separa `Service` (metadati) da `ServiceVariant` (durata/prezzo per location). Il frontend ha tutto in `Service`.

**Decisione**: Mantenere la separazione del backend:
- `services`: nome, descrizione, categoria
- `service_variants`: durata, prezzo, bookable_online per location
- L'API pubblica pu√≤ "appiattire" i dati per il frontend se necessario

### 3. Client vs User
**Contesto**: `Client` √® l'anagrafica gestionale, `User` √® chi prenota online.

**Decisione (DEFINITIVA)**:
- `users`: account GLOBALI per autenticazione (email unica globale, NESSUN business_id)
- `clients`: anagrafica PER BUSINESS (ha business_id, user_id opzionale)
- Un user pu√≤ essere client di pi√π business tramite pi√π record `clients`
- Ogni business vede esclusivamente i propri clients

**ATTENZIONE Schema DB**: La tabella `clients` usa `is_archived` (non `is_active`):
```sql
-- CORRETTO:
WHERE is_archived = 0

-- SBAGLIATO:
WHERE is_active = 1  -- colonna non esiste!
```

**JWT**:
- Contiene SOLO `user_id`
- NON contiene `business_id`
- NON contiene `location_id`

**Derivazione contesto business**:
- `location_id` viene dal PATH: `/v1/locations/{location_id}/bookings`
- `business_id` viene da lookup DB: `SELECT business_id FROM locations WHERE id = :location_id`

**Flusso creazione booking autenticato**:
1. Leggi `location_id` dal PATH
2. Ricava `business_id` dal DB
3. Cerca record `clients` con `(business_id, user_id)`
4. Se non esiste, crealo automaticamente
5. Associa `client_id` alla booking

### 4. Idempotency implementation
**Contesto**: POST /bookings deve essere idempotente senza cambiare il payload client.

**Decisione**: Colonne dedicate in `bookings`:
- `idempotency_key`: UUID dall'header `Idempotency-Key`
- `idempotency_expires_at`: TTL 24 ore
- Pi√π semplice di tabella separata, cleanup via UPDATE (null) non DELETE

**UNIQUE constraint**: `(business_id, idempotency_key)`

Alternativa valutata: `(business_id, user_id, idempotency_key)`
- Scartata perch√© `user_id` pu√≤ essere NULL (prenotazioni manuali)
- MySQL: `NULL != NULL` ‚Üí UNIQUE non protegge i record con user_id NULL
- UUID v4 ha 122 bit casuali ‚Üí collisione tra utenti diversi praticamente impossibile

Regola: il client genera UUID v4 come Idempotency-Key, il server non lo modifica.

### 5. TimeBlock vs booking_items
**Contesto**: Il backend ha `TimeBlock` per blocchi multi-staff.

**Decisione**: Tabella separata `time_blocks` + `time_block_staff`:
- Non sono booking, sono blocchi di indisponibilit√†
- Relazione N:M con staff (un blocco pu√≤ coinvolgere pi√π operatori)
- Pi√π pulito di usare booking_items con flag speciale

### 6. Refresh token storage
**Contesto**: Sicurezza sessioni.

**Decisione**: 
- Mai salvare token in chiaro, solo SHA-256 hash
- Rotation: nuova sessione ad ogni refresh, vecchia revocata
- Riutilizzo token revocato ‚Üí revoca TUTTE le sessioni utente (possibile furto)
- `last_used_at` per tracking, `revoked_at` per revoca esplicita

### 7. Derivazione business_id/location_id
**Contesto**: Come garantire isolamento tenant.

**Decisione (DEFINITIVA)**:
- `location_id`: dal PATH parameter per booking (`/v1/locations/{location_id}/bookings`), query param per altri endpoint
- `business_id`: lookup DB da location_id (`SELECT business_id FROM locations WHERE id = ?`)
- MAI accettare questi ID dal payload client
- MAI inserire questi ID nel JWT
- Il server li ricava autonomamente per ogni request

**Endpoint booking**:
```
POST /v1/locations/{location_id}/bookings
```

**Endpoint public**:
```
GET /v1/services?location_id={location_id}
GET /v1/staff?location_id={location_id}
GET /v1/availability?location_id={location_id}
```

**Payload booking (INVARIABILE)**:
```json
{
  "service_ids": [int],
  "staff_id": int | null,
  "start_time": "ISO8601",
  "notes": "string | null"
}
```

### 8. Naming conventions
**Decisione**: Tutti i nomi colonna in snake_case per compatibilit√† con i modelli Flutter esistenti. I campi JSON dei client sono VINCOLANTI e non devono essere rinominati.

### 9. Timezone gestione (2025-12-26)
**Contesto**: Il calcolo degli slot disponibili necessita del timezone corretto della location.

**Decisione**: 
- Aggiungere colonna `timezone` (VARCHAR 50) a tabella `locations`
- Default value: 'Europe/Rome'
- ComputeAvailability use case legge timezone dalla location invece di hardcoded
- Format: nomi PHP DateTimeZone (es. 'Europe/Rome', 'America/New_York')

### 10. Restrizioni servizi per staff (2025-12-26)
**Contesto**: Non tutti gli staff possono erogare tutti i servizi.

**Decisione**: Tabella `staff_services` (N:M):
- Schema: `(staff_id, service_id)` PRIMARY KEY
- Logica: se tabella vuota ‚Üí staff pu√≤ fare tutto (permissivo di default)
- Se esistono record per uno staff ‚Üí validare che possa erogare TUTTI i servizi richiesti
- Foreign keys CASCADE su delete

### 11. Orari di apertura per location (2025-12-26)
**Contesto**: Ogni location ha orari di apertura diversi per giorno della settimana.

**Decisione**: Tabella `location_schedules`:
- Schema: `location_id`, `day_of_week` (0=Sunday, 6=Saturday), `open_time`, `close_time`, `is_closed`
- UNIQUE constraint su `(location_id, day_of_week)`
- CHECK constraints: `day_of_week BETWEEN 0 AND 6`, `open_time < close_time OR is_closed = 1`
- Fallback a orari default (9:00-18:00, Lun-Ven) se non configurato

### 12. API gestionali (2025-12-27)
**Contesto**: Il gestionale (agenda_backend) necessita di API dedicate per CRUD clients e appointments.

**Decisione**: Separazione tra API booking (pubbliche) e API gestionali:
- **Appointments endpoints** (`/v1/locations/{id}/appointments`):
  - GET con date filter per vista calendario
  - PATCH per reschedule (solo owner)
  - POST /cancel per cancellazione (solo owner)
  - Ritornano booking_items con dati joined (client, service, staff)
  
- **Clients endpoints** (`/v1/clients`):
  - GET con business_id filter + search
  - POST/PUT/DELETE con validazione business ownership
  - Soft delete via `is_archived = 1`

**Permission model**:
- Clients: visibili solo al business di appartenenza
- Appointments: modificabili solo da user che ha creato la booking

### 13. Webhook infrastructure (2025-12-27)
**Contesto**: Necessit√† di notificare sistemi esterni agli eventi della piattaforma.

**Decisione**: Infrastruttura webhook preparatoria:
- `webhook_endpoints`: registrazione endpoint per business + eventi sottoscritti
- `webhook_deliveries`: log tentativi con retry logic (max 3 tentativi, backoff esponenziale)
- Payload firmato con HMAC-SHA256 usando `secret` dell'endpoint
- Eventi standard: `booking.created`, `booking.updated`, `booking.cancelled`, `appointment.rescheduled`

**NON implementato ora**: dispatcher asincrono e integrazione nei flussi (milestone futura).

### 14. Mock elimination strategy (2025-01-15)
**Contesto**: I progetti frontend (agenda_backend e agenda_frontend) inizialmente usavano dati mock hardcoded per sviluppo rapido. Necessit√† di passare completamente a dati reali tramite API.

**Decisione architetturale**:
- **NO mock data** nei provider di produzione
- **Repository pattern**: Ogni feature ha un repository dedicato che chiama ApiClient
- **Async loading**: Provider usano FutureProvider o Notifier con async initialization per caricare dati all'avvio
- **Fallback graceful**: In caso di errore API, mostrare stato error/empty piuttosto che fallback a mock

**Implementazione business/locations**:
- Creato `BusinessRepository` (PHP) e `BusinessController` per endpoint `/v1/businesses`
- Creato `LocationsController` per endpoint `/v1/businesses/{id}/locations` e `/v1/locations/{id}`
- Esteso `ApiClient` (Dart) con metodi `getBusinesses()` e `getLocations(businessId)`
- Sostituiti provider mock con:
  - `businessRepository` ‚Üí chiama API per lista businesses
  - `locationsRepository` ‚Üí chiama API per locations per business
  - `currentBusinessProvider` ‚Üí FutureProvider che carica business selezionato
  - `currentLocationProvider` ‚Üí Notifier con `_loadLocations()` async

**Rationale**: Eliminare mock garantisce che lo sviluppo frontend scopra subito problemi di integrazione API, validazione dati, e performance. I mock rimangono solo nei test unitari dove appropriato.

### 15. Test strategy and TODO resolution (2025-01-15)
**Contesto**: TODO comments sparsi nei test indicavano test mancanti o stub da implementare.

**Decisione**:
- **Test completi nel backend PHP** (agenda_core): validation, business logic, edge cases
- **Test minimi nel frontend Flutter**: integration tests opzionali, stub per CRUD verificano solo compilazione
- **TODO ‚Üí Documentation**: Tutti i TODO nei test convertiti in commenti documentativi che spiegano la strategia

**Motivazione**: Evitare duplicazione test logica tra backend e frontend. Il frontend testa principalmente UI rendering, state management, e integrazione components. La logica di business √® testata exhaustivamente nel backend.

**Casi specifici risolti**:
- `updateClientForBooking()`: Documentato che API backend PATCH /appointments/{id} non supporta modifica client_id (booking property vs appointment property)
- Stub test CRUD: Documentati come placeholder per future integration tests opzionali
- Integration tests: Aggiunti commenti su come eseguirli manualmente contro backend reale

### 16. Provider loading patterns (2025-01-15)
**Contesto**: Riverpod offre FutureProvider e AsyncNotifier per loading asincrono, ma serve compatibilit√† con codice esistente.

**Decisione**:
- **FutureProvider**: Per liste read-only semplici (es. businesses list)
- **Notifier con async init**: Per state mutabile che richiede loading iniziale (es. locations con add/remove)
- **NO AsyncNotifier**: Evitare per compatibilit√† con logica sincrona esistente

**Pattern standard**:
```dart
// FutureProvider per read-only
@riverpod
Future<List<Business>> businesses(Ref ref) async {
  return ref.watch(businessRepositoryProvider).getAll();
}

// Notifier con async init per state mutabile
@riverpod
class Locations extends _$Locations {
  @override
  List<Location> build() => []; // Inizia vuoto
  
  Future<void> _loadLocations() async {
    final data = await repository.getAll();
    state = data;
  }
}
```

### 17. Multi-Business Path-Based URL (2025-12-29)
**Contesto**: SiteGround shared hosting non supporta wildcard DNS n√© subdomain dinamici. Serve routing multi-business.

**Problema**: `SubdomainResolver.getBusinessSlug()` usava `Uri.base.pathSegments` che √® **statico** al caricamento JavaScript. Quando go_router cambiava il path, `Uri.base` non si aggiornava ‚Üí loop infiniti o loading bloccato.

**Decisione**: Routing path-based con StateProvider dinamico:
- `routeSlugProvider` ‚Äî StateProvider aggiornato dal router nel redirect
- `currentBusinessProvider` ‚Äî Legge slug da `routeSlugProvider`, non pi√π da `SubdomainResolver`
- Router estrae `:slug` dal path e aggiorna provider via `Future.microtask()`

**Struttura URL**:
```
/                      ‚Üí Landing (no business)
/:slug                 ‚Üí Redirect a /:slug/booking  
/:slug/booking         ‚Üí Prenotazione
/:slug/login           ‚Üí Login
/:slug/register        ‚Üí Registrazione
/:slug/my-bookings     ‚Üí Le mie prenotazioni
/reset-password/:token ‚Üí Reset password (globale)
```

**Path riservati** (non sono slug): `reset-password`, `login`, `register`, `booking`, `my-bookings`, `change-password`, `privacy`, `terms`

**File modificati**:
- `lib/app/providers/route_slug_provider.dart` (NUOVO)
- `lib/app/router.dart` (REFACTORED)
- `lib/features/booking/providers/business_provider.dart` (usa routeSlugProvider)

**‚ö†Ô∏è ATTENZIONE**: NON usare `SubdomainResolver.getBusinessSlug()` per ottenere lo slug corrente. Usare sempre `ref.watch(routeSlugProvider)`.

---

## Regole di Dominio (2025-12-26)

### REGOLA DOMINIO 1 ‚Äî Conflict Detection

**Principio**: Il DB NON impedisce overlap temporali. La validazione √® a livello applicativo.

**Definizione conflitto**:
Un booking √® in conflitto se esiste un `booking_item` tale che:
- stesso `staff_id`
- stessa `location_id`
- `start_time < new_end_time`
- `end_time > new_start_time`
- `booking.status IN ('confirmed', 'pending')`

**Implementazione obbligatoria**:
```sql
BEGIN;

-- Lock pessimistico
SELECT id FROM booking_items
WHERE staff_id = @staff_id
  AND location_id = @location_id
  AND start_time < @new_end_time
  AND end_time > @new_start_time
  AND booking_id IN (
    SELECT id FROM bookings 
    WHERE status IN ('confirmed', 'pending')
  )
FOR UPDATE;

-- Se count > 0 ‚Üí ROLLBACK + HTTP 409 slot_conflict
-- Altrimenti:
INSERT INTO bookings (...) VALUES (...);
INSERT INTO booking_items (...) VALUES (...);

COMMIT;
```

---

### REGOLA DOMINIO 2 ‚Äî Service Variants Resolution

**Principio**: Il client invia solo `service_ids`, mai `service_variant_id`.

**Flusso**:
1. Client invia `POST /v1/locations/{location_id}/bookings` con `service_ids: [1, 2]`
2. Server estrae `location_id` dal PATH
3. Per ogni `service_id`, server esegue lookup:
   ```sql
   SELECT id, duration_minutes, price 
   FROM service_variants
   WHERE service_id = @service_id 
     AND location_id = @location_id
     AND is_bookable_online = 1
     AND is_active = 1;
   ```
4. Server calcola `end_time` da `start_time + duration_minutes`
5. Server inserisce `booking_items` con `service_variant_id` risolto

**Constraint**: `UNIQUE (service_id, location_id)` garantisce al massimo una variant per combinazione.

**Errori**:
| Situazione | HTTP | Codice errore |
|------------|------|---------------|
| Variant non esiste per location | 400 | `service_not_available_at_location` |
| `is_bookable_online = 0` | 400 | `service_not_bookable_online` |
| `is_active = 0` | 400 | `service_not_available` |

**Motivazione**: Il frontend espone un modello `Service` semplificato con durata/prezzo diretti. La complessit√† delle variant per location √® nascosta lato server.

---

## 17. Password Management Pattern (2025-12-27)

**Contesto**: Implementazione completa del flusso password reset e cambio password per utenti autenticati.

**Decisione**: Pattern a due fasi per password reset + endpoint dedicato per cambio password:

### Password Reset (utente non autenticato)
1. **Step 1 - Request Reset**: `POST /v1/auth/forgot-password`
   - Input: `email`
   - Output: Sempre 200 (anti email enumeration)
   - Backend: genera token (SHA-256 hash), salva in `password_reset_tokens`, invia email
   - Token validity: 1 ora

2. **Step 2 - Confirm Reset**: `POST /v1/auth/reset-password`
   - Input: `token` (da email), `password`
   - Validazione password: min 8 caratteri, maiuscola + minuscola + numero
   - Backend: verifica token non scaduto/usato, aggiorna password, invalida tutte le sessioni utente
   - Output: 200 success o 400 con error code (`invalid_reset_token`, `reset_token_expired`, `weak_password`)

### Change Password (utente autenticato)
**Endpoint**: `POST /v1/me/change-password` (richiede access token)
- Input: `current_password`, `new_password`
- Validazioni:
  - Current password corretta
  - New password != current password
  - New password rispetta policy (8 char, maiuscola, minuscola, numero)
- Output: 200 success o 400/401 error

**Frontend Implementation**:
- `/reset-password/:token` route per deep link da email
- `/change-password` route per utenti loggati
- Localizzazioni complete IT/EN
- Validazione real-time in UI

**Security**:
- Token SHA-256 hashed nel DB
- Token monouso (campo `used_at`)
- Scadenza 1 ora
- Password reset invalida tutte le sessioni (force re-login)
- Change password richiede autenticazione JWT

**Rationale**: Separare forgot/reset (pubblico, via email) da change (privato, richiede autenticazione) migliora security e UX.

---

## 18. Cancellation Policy & User Booking Management (2025-12-27)

**Contesto**: Gli utenti devono poter consultare e gestire i propri appuntamenti dal frontend pubblico. Appuntamenti passati: solo consultazione. Appuntamenti futuri: annullamento e modifica, con vincoli temporali.

**Decisione**: Implementare cancellation policy configurabile con granularit√† business/location + endpoint dedicato per gestione appuntamenti utente.

### Cancellation Policy Configuration

**Schema DB**:
```sql
-- businesses: policy di default per tutto il business
ALTER TABLE businesses ADD COLUMN cancellation_hours INT UNSIGNED NOT NULL DEFAULT 24;

-- locations: override opzionale per singola sede
ALTER TABLE locations ADD COLUMN cancellation_hours INT UNSIGNED NULL DEFAULT NULL;
```

**Logica**: 
- `cancellation_hours` = ore minime richieste prima dell'appuntamento per cancellare/modificare
- Valore di default: 24 ore
- Gerarchia: `location.cancellation_hours` ‚Üí `business.cancellation_hours` ‚Üí 24
- `cancellation_hours = 0` ‚Üí nessuna cancellazione permessa
- `cancellation_hours = NULL` su location ‚Üí usa policy del business

**Esempi**:
- Business con `cancellation_hours = 48`: utenti possono cancellare fino a 48h prima
- Location A con `cancellation_hours = 12`: override, solo 12h per questa sede
- Location B con `cancellation_hours = NULL`: usa il default del business (48h)

### User Booking Management API

**Endpoint**: `GET /v1/me/bookings` (richiede autenticazione)

**Response**:
```json
{
  "success": true,
  "data": {
    "upcoming": [
      {
        "id": 123,
        "status": "confirmed",
        "start_time": "2025-12-30T14:00:00+01:00",
        "end_time": "2025-12-30T15:30:00+01:00",
        "service_name": "Taglio + Piega",
        "staff_name": "Mario R.",
        "price": 45.00,
        "location": { "id": 1, "name": "Sede Centro", "address": "..." },
        "business": { "id": 1, "name": "Salone Bella Vita" },
        "can_modify": true,
        "can_modify_until": "2025-12-29T14:00:00+01:00",
        "notes": "Porta foto riferimento"
      }
    ],
    "past": [ ... ]
  }
}
```

**Campi chiave**:
- `can_modify`: `true` se ora corrente < `can_modify_until`
- `can_modify_until`: timestamp deadline calcolato da `start_time - cancellation_hours`
- Separazione `upcoming` (modificabili) vs `past` (solo consultazione)

### Validation in UpdateBooking / DeleteBooking

Entrambi i use case validano la policy prima di procedere:

```php
private function validateCancellationPolicy(array $booking): void {
    $startTime = new DateTimeImmutable($earliestStartFromItems);
    $now = new DateTimeImmutable();
    
    // Query policy con fallback
    $cancellationHours = $location->cancellation_hours 
        ?? $business->cancellation_hours 
        ?? 24;
    
    $deadline = $startTime->modify("-{$cancellationHours} hours");
    
    if ($now >= $deadline) {
        throw BookingException::validationError(
            "Cannot modify booking within {$cancellationHours} hours of start time"
        );
    }
}
```

**Errore HTTP 400**:
```json
{
  "success": false,
  "error": {
    "code": "validation_error",
    "message": "Cannot cancel booking within 24 hours of appointment start time",
    "details": {
      "cancellation_deadline": "2025-12-29T14:00:00+01:00"
    }
  }
}
```

### Frontend Implementation (agenda_frontend)

**Nuova feature**: `/my-bookings` route con:
- Lista appuntamenti futuri con badge "modificabile" basato su `can_modify`
- Lista appuntamenti passati (read-only)
- Bottoni "Annulla" e "Modifica" condizionali
- Dialog conferma cancellazione con spiegazione policy
- Form modifica che rispetta vincoli originali (staff, services, availability)

**UX**:
- Se `can_modify = false`: bottoni disabilitati + tooltip con `can_modify_until`
- Countdown visivo ore rimanenti per modifica
- Localizzazioni IT/EN complete

**Constraints su modifica**:
- Stessi vincoli della prenotazione originale (availability, staff_services, etc.)
- Non pu√≤ modificare se oltre deadline
- Reschedule = delete + create (transazionale)

### Rationale

**Business flexibility**: Ogni attivit√† ha esigenze diverse (parrucchiere 24h vs medico 48h vs massaggiatore 2h). Location override permette eccezioni (es: sede remota con policy pi√π rigida).

**User transparency**: Frontend mostra chiaramente deadline e motivazione, evitando frustrazione.

**Backend enforcement**: Policy validata server-side, impossibile bypassare da client.

**Default sensato**: 24h copre la maggioranza dei casi, evitando configurazione obbligatoria.

---

## Decision 19: Reschedule Prenotazione (2025-12-27)

### Contesto

Gli utenti devono poter riprogrammare le proprie prenotazioni future, scegliendo nuova data/ora mantenendo gli stessi servizi e operatore.

### Soluzione Implementata

**Backend**:
- Esteso `PUT /v1/locations/{location_id}/bookings/{id}` per accettare `start_time`
- Nuovo metodo `BookingRepository::rescheduleBooking()` che:
  - Calcola offset temporale tra vecchio e nuovo start_time
  - Aggiorna tutti i `booking_items` con nuovo orario mantenendo durate
  - Preserva intervalli relativi tra servizi multipli

**Frontend**:
- Dialog `RescheduleBookingDialog` con:
  - Date picker per nuova data
  - Availability check in tempo reale
  - Selezione slot disponibili
  - Campo note opzionale
- Integrazione con `myBookingsProvider.rescheduleBooking()`
- Validazione cancellation policy (stessa logica di cancellazione)

**API Endpoint**:
```http
PUT /v1/locations/{location_id}/bookings/{id}
Authorization: Bearer <token>

{
  "start_time": "2025-12-30T14:00:00+01:00",
  "notes": "Modifica appuntamento"
}
```

**Response (200)**:
```json
{
  "success": true,
  "data": {
    "id": 123,
    "items": [
      {
        "id": 456,
        "start_time": "2025-12-30T14:00:00+01:00",
        "end_time": "2025-12-30T15:00:00+01:00",
        ...
      }
    ],
    ...
  }
}
```

### Vincoli

1. **Cancellation Policy**: Stesso vincolo di cancellazione (default 24h)
2. **Availability Check**: ‚úÖ Verificato slot libero per staff nel nuovo orario (transazionale)
3. **Preservazione Servizi**: Non permette cambio servizi, solo data/ora
4. **Multi-Item**: Aggiorna tutti i `booking_items` mantenendo sequenza originale
5. **Transazionalit√†**: Operazione atomica con `FOR UPDATE` per evitare race conditions

### Rationale

**UX semplificata**: Dialog dedicato invece di flow prenotazione completo.

**Mantenimento contesto**: Stessi servizi/staff evitano complessit√† ricalcolo durata/prezzo.

**Consistency**: Stessa policy di cancellazione per prevedibilit√† utente.

**Performance**: Update diretto booking_items invece di delete + recreate.

**Race Condition Safety**: `checkConflicts()` usa `FOR UPDATE` dentro transazione.

### Implementazione Completata (2025-12-27)

‚úÖ **Backend**:
- `UpdateBooking::validateAvailabilityForReschedule()` verifica conflitti per ogni booking_item
- Transazione wrapping check + update per atomicit√†
- `BookingRepository::checkConflicts()` con `FOR UPDATE` e `excludeBookingId`
- Errore HTTP 409 con dettagli conflitti se slot occupato

‚úÖ **Frontend**:
- Dialog con availability check real-time
- Gestione errore 409 con messaggio utente

### TODO

- [ ] Test edge case: reschedule con servizi multipli sovrapposti
- [ ] Email notifica reschedule (richiede M10)

---

## Decision 20: Distinzione Reschedule Client vs Gestionale (2025-12-27)

### Contesto

L'applicazione ha due frontend diversi:
- **agenda_frontend** (cliente): utente finale prenota e gestisce i propri appuntamenti
- **agenda_backend** (gestionale): staff e admin gestiscono tutti gli appuntamenti

### Problema

Come gestire il reschedule (spostamento) di appuntamenti nei due contesti?

### Soluzione: Due Pattern Distinti

| App | Endpoint | Granularit√† | Motivo |
|-----|----------|-------------|--------|
| **agenda_frontend** | `PUT /v1/locations/{id}/bookings/{id}` | Intera prenotazione | Cliente vede la prenotazione come unit√† atomica |
| **agenda_backend** | `PATCH /v1/locations/{id}/appointments/{id}` | Singolo appuntamento | Staff ha flessibilit√† per riorganizzare i singoli slot |

### Esempi Pratici

**Scenario Cliente**:
Mario ha prenotato "Taglio + Piega" alle 14:00. Vuole spostare a domani.
‚Üí Usa `PUT /bookings/{id}` con `start_time` ‚Üí entrambi i servizi si spostano insieme.

**Scenario Staff**:
Anna deve spostare solo la "Piega" di Mario alle 16:00 perch√© lo slot era gi√† occupato.
‚Üí Usa `PATCH /appointments/{id}` ‚Üí sposta solo quel servizio, il "Taglio" resta.

### Implementazione

**Backend (agenda_core)**:
```php
// PUT /bookings/{id} - Reschedule intero booking
if (isset($data['start_time'])) {
    $this->validateAvailabilityForReschedule($booking, $newStartTime);
    $this->bookingRepo->rescheduleBooking($bookingId, $newStartTime);
}

// PATCH /appointments/{id} - Reschedule singolo appointment
$this->appointmentRepo->updateAppointment($appointmentId, $startTime, $endTime, $staffId);
```

**Frontend Cliente (agenda_frontend)**:
- `MyBookingsProvider.rescheduleBooking()` ‚Üí chiama PUT con `start_time`
- Dialog unico per scegliere nuova data/ora
- Tutti i servizi si spostano automaticamente

**Gestionale (agenda_backend)**:
- `AppointmentsProvider.moveAppointment()` ‚Üí chiama PATCH
- Drag & drop singolo appuntamento
- Flessibilit√† totale per staff

### Rationale

1. **UX appropriata per ruolo**:
   - Cliente: semplicit√†, non deve gestire dettagli operativi
   - Staff: controllo granulare per ottimizzare agenda

2. **Backwards compatibility**:
   - Gestionale gi√† usa PATCH /appointments (non cambia nulla)
   - PUT /bookings con start_time √® additive

3. **Conflict detection**:
   - Entrambi i flussi verificano availability
   - FOR UPDATE lock evita race conditions

4. **Coerenza dati**:
   - Client vede sempre booking come unit√†
   - Staff pu√≤ intervenire su singoli item se necessario

### Vincoli

- Il cliente **non** pu√≤ modificare singoli servizi (solo annullare o spostare tutto)
- Lo staff **pu√≤** modificare singoli servizi ma deve gestire manualmente la coerenza
- Reschedule cliente soggetto a cancellation policy
- Reschedule staff **non** soggetto a policy (pu√≤ sempre modificare)

---

## Decision 21: Sistema Permessi Operatori Gestionale (2025-12-28)

### Contesto
Il gestionale (agenda_backend) necessita di un sistema di autenticazione e autorizzazione per gli operatori. Attualmente:
- Gli utenti (`users`) sono globali e non hanno relazione diretta con i business
- I `clients` collegano utenti ai business, ma sono per chi prenota, non per chi gestisce
- Lo `staff` √® anagrafica dipendenti, senza credenziali di login

### Problema
Come assegnare un utente (che pu√≤ fare login) a uno o pi√π business con permessi specifici?

### Decisione
Creare tabella `business_users` che collega `users` a `businesses` con ruoli e permessi.

### Schema
```sql
CREATE TABLE business_users (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    business_id INT UNSIGNED NOT NULL,
    user_id INT UNSIGNED NOT NULL,
    role ENUM('owner', 'admin', 'manager', 'staff') DEFAULT 'staff',
    staff_id INT UNSIGNED NULL,  -- Link opzionale a record staff
    can_manage_bookings TINYINT(1) DEFAULT 1,
    can_manage_clients TINYINT(1) DEFAULT 1,
    can_manage_services TINYINT(1) DEFAULT 0,
    can_manage_staff TINYINT(1) DEFAULT 0,
    can_view_reports TINYINT(1) DEFAULT 0,
    is_active TINYINT(1) DEFAULT 1,
    invited_by INT UNSIGNED NULL,
    invited_at TIMESTAMP NULL,
    accepted_at TIMESTAMP NULL,
    UNIQUE (business_id, user_id)
);

-- Superadmin flag in users table
ALTER TABLE users ADD COLUMN is_superadmin TINYINT(1) DEFAULT 0;
```

### Modello Enterprise (Admin Platform)
Il sistema usa il modello **Enterprise** dove:
- **Superadmin** (globale) gestisce la piattaforma, non √® legato a business specifici
- **Owner** gestisce il proprio business e invita operatori
- Nessuna self-registration di business

### Superadmin: Ruolo Globale

Il superadmin **NON ha record in `business_users`**. √à un flag globale su `users.is_superadmin`.

**Comportamento:**
- Vede lista di TUTTI i business (con ricerca/filtri)
- Pu√≤ creare nuovi business
- Pu√≤ eliminare business
- Quando seleziona un business ‚Üí opera come **admin** (accesso completo)
- Non appare nella lista operatori del business

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              SUPERADMIN (users.is_superadmin = 1)       ‚îÇ
‚îÇ  Scope: GLOBALE (nessun record in business_users)       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚Ä¢ GET /v1/admin/businesses ‚Üí Lista TUTTI i business    ‚îÇ
‚îÇ  ‚Ä¢ POST /v1/admin/businesses ‚Üí Crea business            ‚îÇ
‚îÇ  ‚Ä¢ DELETE /v1/admin/businesses/{id} ‚Üí Elimina           ‚îÇ
‚îÇ  ‚Ä¢ Seleziona business ‚Üí entra come admin                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Gerarchia Ruoli (per business)

| Ruolo | Scope | Descrizione |
|-------|-------|-------------|
| **owner** | Business | Proprietario, controllo totale |
| **admin** | Business | Come owner, ma non pu√≤ eliminare business |
| **manager** | Business | Gestisce appuntamenti, clienti, orari |
| **staff** | Business | Solo propri appuntamenti |

### Chi Pu√≤ Assegnare Ruoli

| Assigner | Pu√≤ Creare |
|----------|------------|
| superadmin | owner (alla creazione business) |
| owner | owner, admin, manager, staff |
| admin | admin, manager, staff |
| manager | ‚ùå |
| staff | ‚ùå |

### API Endpoints

```
# Superadmin only (is_superadmin = true)
GET /v1/admin/businesses              ‚Üí Lista tutti i business (con search)
POST /v1/admin/businesses             ‚Üí Crea nuovo business + owner
DELETE /v1/admin/businesses/{id}      ‚Üí Elimina business
GET /v1/admin/businesses/{id}         ‚Üí Entra come admin

# Authenticated users (business_users)
GET /v1/me/businesses                 ‚Üí Lista business dove user ha accesso
GET /v1/me/businesses/{id}            ‚Üí Dettaglio business con ruolo/permessi

# Owner/Admin only
POST /v1/businesses/{id}/users        ‚Üí Invita nuovo operatore
PUT /v1/businesses/{id}/users/{id}    ‚Üí Modifica ruolo/permessi
DELETE /v1/businesses/{id}/users/{id} ‚Üí Rimuovi accesso
```

### Flusso Superadmin

```
1. POST /v1/auth/login ‚Üí JWT con user_id
2. Server verifica is_superadmin = true
3. GET /v1/admin/businesses?search=salone ‚Üí Lista filtrata
4. Click su business ‚Üí GET /v1/admin/businesses/{id}
5. Da qui opera come admin (bypass business_users check)
```

### Flusso Operatore Normale

```
1. POST /v1/auth/login ‚Üí JWT con user_id
2. GET /v1/me/businesses ‚Üí Lista da business_users
3. Seleziona business ‚Üí salva currentBusinessId
4. Middleware valida accesso tramite business_users
```

### Middleware Access Check

```php
// Pseudocode per validazione accesso
function checkBusinessAccess($userId, $businessId): string {
    // 1. Superadmin bypassa tutto
    if ($this->userRepo->isSuperadmin($userId)) {
        return 'admin'; // Opera come admin
    }
    
    // 2. Verifica business_users
    $businessUser = $this->businessUserRepo->find($userId, $businessId);
    if (!$businessUser || !$businessUser['is_active']) {
        throw AuthException::forbidden('No access to this business');
    }
    
    return $businessUser['role'];
}
```

### Link Staff-User (opzionale)
Campo `staff_id` permette di collegare un operatore al suo record staff:
- Utile per mostrare solo il proprio calendario
- Permette "login as staff" per operatori singoli
- Se NULL, l'operatore vede tutto il team

### Migration
Inclusa in: `migrations/FULL_DATABASE_SCHEMA.sql` (sezione BUSINESS USERS)

### Impatto Frontend (agenda_backend)
1. Creare `features/auth/` con login/logout
2. Modificare `businessesProvider` per usare `/v1/me/businesses`
3. Aggiungere route guard per redirect a login
4. Salvare `currentBusinessId` dopo selezione

### 21. Sistema inviti via email (2025-12-28)
**Contesto**: Gli operatori devono essere invitati tramite email invece di essere aggiunti direttamente.

**Decisione**: Tabella `business_invitations` separata:
- Token univoco 64 caratteri (hex)
- Scadenza 7 giorni default
- Status: `pending`, `accepted`, `expired`, `revoked`
- Constraint: un solo invito pending per (business_id, email)

**Flusso invito**:
1. Owner/Admin crea invito con email + ruolo desiderato
2. Sistema genera token, salva in `business_invitations`
3. Email inviata con link `https://app/invite/{token}`
4. Destinatario apre link, fa login o register
5. `POST /v1/invitations/{token}/accept` verifica email match e crea record `business_users`

**Gerarchia ruoli per inviti**:
- Owner pu√≤ invitare: admin, manager, staff
- Admin pu√≤ invitare: manager, staff
- Manager pu√≤ invitare: staff
- Staff non pu√≤ invitare

**Migration**: Inclusa in `FULL_DATABASE_SCHEMA.sql` (sezione BUSINESS INVITATIONS)

### 22. Frontend integration operators (2025-12-28)
**Contesto**: Il gestionale (agenda_backend) necessita di UI per gestire operatori.

**Decisione**: Struttura modulare nella feature `business/`:
- **Modelli** in `core/models/`: `BusinessUser`, `BusinessInvitation`
- **Repository** in `features/business/data/`: `BusinessUsersRepository`
- **Provider** in `features/business/providers/`: `businessUsersProvider(businessId)` con Riverpod 3.x
- **UI** in `features/business/presentation/`:
  - `OperatorsScreen` - lista operatori + inviti pendenti
  - `dialogs/InviteOperatorDialog` - dialog/sheet per invitare
  - `dialogs/RoleSelectionDialog` - dialog/sheet per cambiare ruolo

**Pattern responsive**:
- Desktop: `showDialog()` con `AppFormDialog`
- Mobile/Tablet: `AppBottomSheet.show()` con sheet dedicati

**Localizzazione**: Chiavi `operators*` in `intl_it.arb` e `intl_en.arb`

### 23. Testing strategy (2025-12-28)
**Contesto**: M8 richiede test minimi per validare logica di business.

**Decisione**: Test PHPUnit focalizzati su logica pura, senza mock di classi `final`.

**Struttura test suite**:
```
tests/
‚îú‚îÄ‚îÄ AuthTest.php           # JWT, password hashing base
‚îú‚îÄ‚îÄ AuthUseCaseTest.php    # Validazione auth, sessioni, email
‚îú‚îÄ‚îÄ BookingTest.php        # Slot overlap, date validation
‚îú‚îÄ‚îÄ BookingUseCaseTest.php # Conflict detection, idempotency, durata
‚îú‚îÄ‚îÄ AvailabilityTest.php   # Slot generation, working hours, timezone
‚îú‚îÄ‚îÄ ExceptionsTest.php     # Auth e Booking exceptions
‚îú‚îÄ‚îÄ IdempotencyTest.php    # UUID v4 validation
‚îú‚îÄ‚îÄ PasswordHasherTest.php # Bcrypt security
‚îú‚îÄ‚îÄ RequestTest.php        # HTTP request parsing
‚îú‚îÄ‚îÄ ResponseTest.php       # HTTP response formatting
‚îî‚îÄ‚îÄ RouterTest.php         # Routing e middleware
```

**Pattern adottati**:
- Classi repository sono `final` ‚Üí NO mock, test della logica pura
- Test di validazione indipendenti dal DB
- Test di calcolo (durata, slot, conflict) con dati in memoria
- Setup JWT_SECRET in `setUp()` / `tearDown()`

**Risultato**: 98 test, 195 asserzioni, 100% pass

**Comandi**:
```bash
# Eseguire tutti i test
./vendor/bin/phpunit --testdox

# Eseguire test specifici
./vendor/bin/phpunit --filter AuthUseCaseTest
```

---

## Vincoli e Divieti

### VIETATO
- Aggiungere `business_id` a `users`
- Inserire `business_id` o `location_id` nel JWT
- Richiedere `business_id` o `location_id` nel payload
- Rinominare colonne esistenti
- Modificare il payload booking
- Implementare booking prima dell'autenticazione
- Spostare logica di dominio nel frontend
- Permettere self-registration di business (modello Enterprise)

### OBBLIGATORIO
- `location_id` nel PATH per ogni request business-scoped
- `business_id` ricavato via lookup DB da `location_id`
- Query gestionali filtrate per `clients.business_id`
- Creazione automatica record `clients` al primo booking autenticato
- Validazione `business_users` per API gestionali (M11+)

---

## Ordine Implementazione

1. **M1 Auth**: login, refresh token con rotazione, me, logout
2. **M2 Public browse**: services, staff, availability
3. **M3 Booking**: POST /v1/locations/{location_id}/bookings (protetto)
4. **M4 Gestionale**: compatibilit√† con backend esistente
5. **M11 Permessi operatori**: business_users, auth gestionale

---

## M10 Notification System - Decisione Architetturale (2025-12-28)

### Contesto
Necessit√† di inviare notifiche email per il ciclo di vita delle prenotazioni (conferma, cancellazione, reminder) su hosting condiviso (SiteGround) con budget limitato.

### Decisione: Architettura Multi-Provider con Strategy Pattern

**Provider selezionabile via `.env`**:
```ini
MAIL_PROVIDER=brevo  # smtp | brevo | mailgun
```

**Motivazioni**:
1. **Vendor lock-in evitato**: Cambio provider con modifica singola variabile
2. **Fallback progression**: Brevo API ‚Üí Brevo SMTP ‚Üí errore
3. **Testing semplificato**: Provider sostituibile in test
4. **Costi ottimizzati**: Brevo free tier 300/giorno sufficiente per MVP

### Gerarchia Email Sender (priorit√†)

| Priorit√† | Fonte | Esempio |
|----------|-------|---------|
| **1¬∞ (alta)** | `locations.email` | `sede.roma@salonemario.it` |
| **2¬∞** | `businesses.email` | `info@salonemario.it` |
| **3¬∞ (fallback)** | `.env MAIL_FROM_*` | `noreply@romeolab.it` |

**Logica implementata**:
```php
$fromEmail = $variables['sender_email'] 
    ?? $variables['location_email'] 
    ?? $variables['business_email'] 
    ?? null;  // null = usa .env fallback
```

Questo permette:
- **Multi-sede**: ogni sede pu√≤ avere email dedicata
- **Multi-business**: ogni business pu√≤ avere email dedicata
- **Fallback sicuro**: se nessuna email configurata, usa quella del `.env`

### Alternativa considerata: Provider unico (SMTP)
**Scartata perch√©**:
- SiteGround SMTP ha limiti di invio (100/ora)
- Nessun tracking deliverability
- Nessun retry automatico

### Alternativa considerata: Invio sincrono
**Scartata perch√©**:
- Booking POST bloccato durante invio email
- Timeout se SMTP lento
- Nessun retry su errore temporaneo

### Implementazione scelta: Coda asincrona
- `notification_queue` con status, retry_count, scheduled_at
- Worker via cron (ogni minuto)
- Notifiche non bloccano flusso principale
- Retry automatico con backoff

### File implementati
```
src/Infrastructure/Notifications/
‚îú‚îÄ‚îÄ EmailProviderInterface.php
‚îú‚îÄ‚îÄ SmtpProvider.php
‚îú‚îÄ‚îÄ BrevoProvider.php
‚îú‚îÄ‚îÄ MailgunProvider.php
‚îú‚îÄ‚îÄ EmailService.php (factory)
‚îî‚îÄ‚îÄ EmailTemplateRenderer.php

src/Infrastructure/Notifications/
‚îî‚îÄ‚îÄ NotificationRepository.php

src/UseCases/Notifications/
‚îú‚îÄ‚îÄ QueueBookingConfirmation.php
‚îú‚îÄ‚îÄ QueueBookingCancellation.php
‚îî‚îÄ‚îÄ QueueBookingReminder.php

bin/
‚îú‚îÄ‚îÄ notification-worker.php
‚îú‚îÄ‚îÄ queue-reminders.php
‚îú‚îÄ‚îÄ run-worker.sh
‚îî‚îÄ‚îÄ run-reminders.sh

migrations/
‚îî‚îÄ‚îÄ FULL_DATABASE_SCHEMA.sql  # Include notification_queue, notification_templates, notification_settings
```

### Cron setup produzione
```bash
# Processa coda ogni minuto (usa wrapper per portabilit√† PHP path)
* * * * * /path/to/agenda_core/bin/run-worker.sh

# Accoda reminder ogni ora
0 * * * * /path/to/agenda_core/bin/run-reminders.sh
```

### Configurazione .env
```ini
MAIL_PROVIDER=brevo
BREVO_API_KEY=xkeysib-xxxxx
BREVO_SMTP_KEY=xsmtpsib-xxxxx
MAIL_FROM_ADDRESS=noreply@tuodominio.it
MAIL_FROM_NAME="Agenda"
```

### Frontend (agenda_backend)
- Campo email aggiunto al dialog modifica location
- Localizzazioni: `teamLocationEmailLabel`, `teamLocationEmailHint`

---

## 23. Superadmin Business Management (30/12/2025)

**Contesto**: Il superadmin deve poter gestire i business dalla piattaforma.

**Decisione**: Implementato flow completo:

### API Endpoints
- `GET /v1/admin/businesses` - Lista tutti i business (con search/pagination)
- `POST /v1/admin/businesses` - Crea business + owner (transazione atomica)
- `PUT /v1/admin/businesses/{id}` - Modifica business
- `DELETE /v1/admin/businesses/{id}` - Soft-delete business

### UseCase Pattern
```
src/UseCases/Business/
‚îú‚îÄ‚îÄ CreateBusiness.php     # Transazione: crea business + owner, rollback su errore
‚îú‚îÄ‚îÄ UpdateBusiness.php     # Aggiorna campi business (name, slug, email, phone, timezone, currency)
‚îú‚îÄ‚îÄ GetAllBusinesses.php   # Lista paginata con ricerca
‚îî‚îÄ‚îÄ GetUserBusinesses.php  # Lista business per utente normale
```

### Frontend (agenda_backend)
- `BusinessListScreen` per superadmin su `/businesses`
- Dialog creazione business con auto-generazione slug
- Dialog modifica business
- Pulsante "Cambia Business" nella navigation per tornare alla lista
- Redirect automatico: superadmin ‚Üí `/businesses`, utente normale ‚Üí `/agenda`

### Router Superadmin Flow
```
Login ‚Üí is_superadmin? 
  ‚îú‚îÄ YES ‚Üí /businesses (lista)
  ‚îÇ        ‚îú‚îÄ Crea nuovo business
  ‚îÇ        ‚îú‚îÄ Modifica business (icona edit)
  ‚îÇ        ‚îî‚îÄ Seleziona business ‚Üí /agenda
  ‚îÇ            ‚îî‚îÄ "Cambia" in navigation ‚Üí /businesses
  ‚îî‚îÄ NO  ‚Üí /agenda (normale)
```

### Provider Riverpod (NO StateProvider!)
```dart
// ‚ùå VIETATO - Deprecato in Riverpod 3.x
final myProvider = StateProvider<int>((ref) => 0);

// ‚úÖ OBBLIGATORIO - Usare Notifier
class SuperadminSelectedBusinessNotifier extends Notifier<int?> {
  @override
  int? build() => null;
  void select(int id) => state = id;
  void clear() => state = null;
}
final superadminSelectedBusinessProvider = NotifierProvider<...>(...)
```

### Modello Business aggiornato
Campi aggiunti: `slug`, `email`, `phone`, `timezone`

### File chiave
| Concetto | File |
|----------|------|
| UseCase Create | `src/UseCases/Business/CreateBusiness.php` |
| UseCase Update | `src/UseCases/Business/UpdateBusiness.php` |
| Controller | `src/Http/Controllers/AdminBusinessesController.php` |
| Lista Screen | `features/business/presentation/business_list_screen.dart` |
| Create Dialog | `features/business/presentation/dialogs/create_business_dialog.dart` |
| Edit Dialog | `features/business/presentation/dialogs/edit_business_dialog.dart` |

---

## 24. Multi-Location Support Frontend (30/12/2025)

**Contesto**: Un business pu√≤ avere pi√π sedi (locations). L'utente deve poter scegliere dove prenotare.

**Decisione**: Implementato step location nel booking flow.

### Comportamento
| Sedi | Flow di prenotazione |
|------|----------------------|
| 0    | "Attivit√† non attiva" (business senza sedi configurate) |
| 1    | Servizi ‚Üí Staff ‚Üí Data/Ora ‚Üí Riepilogo (skip location) |
| 2+   | **Sede** ‚Üí Servizi ‚Üí Staff ‚Üí Data/Ora ‚Üí Riepilogo |

### API Endpoint (pubblico, no auth)
```
GET /v1/businesses/{business_id}/locations/public
```

Response:
```json
{
  "success": true,
  "data": {
    "data": [
      {
        "id": 1,
        "business_id": 4,
        "name": "Sede Centrale",
        "address": "Via Roma 1",
        "city": "Milano",
        "phone": "+39 02 1234567",
        "timezone": "Europe/Rome",
        "is_default": true
      }
    ]
  }
}
```

### Frontend (agenda_frontend)

**Nuovo modello**:
```dart
// lib/core/models/location.dart
class Location {
  final int id;
  final int businessId;
  final String name;
  final String? address;
  final String? city;
  final String? phone;
  final String timezone;
  final bool isDefault;
  // ...
}
```

**Provider**:
```dart
// lib/features/booking/providers/locations_provider.dart
final locationsProvider = NotifierProvider<LocationsNotifier, AsyncValue<List<Location>>>(...);
final selectedLocationProvider = NotifierProvider<SelectedLocationNotifier, Location?>(...);
final hasMultipleLocationsProvider = Provider<bool>(...);
final effectiveLocationProvider = Provider<Location?>(...);
final effectiveLocationIdProvider = Provider<int>(...);
```

**Step**:
- `LocationStep` widget per selezione sede
- `BookingStepIndicator` con parametro `showLocationStep`

### Booking flow aggiornato
```dart
enum BookingStep { location, services, staff, dateTime, summary, confirmation }
```

Il `BookingFlowNotifier`:
- Determina step iniziale basato su `hasMultipleLocationsProvider`
- Salta automaticamente `BookingStep.location` se c'√® una sola sede
- Usa `effectiveLocationIdProvider` per determinare la location da usare

### File chiave
| Concetto | File |
|----------|------|
| Modello Location | `lib/core/models/location.dart` |
| Provider | `lib/features/booking/providers/locations_provider.dart` |
| Step UI | `lib/features/booking/presentation/screens/location_step.dart` |
| Controller PHP | `src/Http/Controllers/LocationsController.php` |
| Endpoint route | `src/Http/Kernel.php` (line ~97) |

### 22. Profilo utente (2025-12-31)
**Contesto**: Gli utenti devono poter modificare il proprio profilo (nome, cognome, email, telefono).

**Decisione**: Endpoint `PUT /v1/me` per aggiornare profilo utente autenticato:
- UseCase `UpdateProfile` in `src/UseCases/Auth/UpdateProfile.php`
- Validazione email unica (errore se gi√† esistente da altro utente)
- Campi aggiornabili: `first_name`, `last_name`, `email`, `phone`
- Frontend (entrambi): pagina `/profilo` o `/:slug/profile`

### 23. Admin email invece di user_id (2025-12-31)
**Contesto**: La creazione business richiedeva `owner_user_id` (utente gi√† esistente). Necessit√† di creare admin anche per email non registrate.

**Decisione**: Sostituire `owner_user_id` con `admin_email`:
- `CreateBusiness`: accetta `admin_email`, crea utente se non esiste
- Se utente nuovo: invia email benvenuto con link reset password (24h)
- Se utente esistente: associato come owner senza email
- Token reset in tabella `password_reset_tokens`

### 24. Trasferimento ownership business (2025-12-31)
**Contesto**: Quando si cambia `admin_email` in UpdateBusiness, la ownership deve essere trasferita.

**Decisione**: 
- `UpdateBusiness` rileva cambio admin_email
- Vecchio admin: ruolo da "owner" a "admin"
- Nuovo admin: creato se non esiste, ruolo "owner"
- Email benvenuto inviata al nuovo admin
- Metodo `BusinessUserRepository::transferOwnership()`

### 25. Reinvio invito admin (2025-12-31)
**Contesto**: Token reset scade dopo 24h. Se admin non ha impostato password in tempo, serve reinvio.

**Decisione**: Endpoint `POST /v1/admin/businesses/{id}/resend-invite`:
- UseCase `ResendAdminInvite`
- Genera nuovo token reset (24h)
- Invia stessa email benvenuto con nuovo link
- Solo superadmin pu√≤ invocare

### 26. Email benvenuto admin senza URL prenotazioni (2026-01-01)
**Contesto**: L'email di benvenuto admin includeva URL prenotazioni, ma il frontend booking non √® ancora pronto per tutti i business.

**Decisione**: Commentato temporaneamente nell'email `businessAdminWelcome`:
- Rimosso `üîó URL prenotazioni: {{booking_url}}`
- Rimosso `üìÖ Condividi questo link con i tuoi clienti...`
- HTML: Commentato con `<!-- TODO: Riattivare URL prenotazioni quando pronto -->`
- Text: Righe rimosse (non supporta commenti)
- Da riattivare quando il frontend booking sar√† configurato per il business

### 27. Login error message persistence (2026-01-01)
**Contesto**: Il messaggio di errore "Credenziali non valide" scompariva dopo pochi istanti.

**Analisi**: Il router usava `ref.watch(authProvider)` che triggherava rebuild ogni volta che lo stato cambiava (incluso `loading ‚Üí error`), ricreando `LoginScreen` e perdendo lo stato locale `_errorMessage`.

**Decisione**: 
- Creato provider derivato `_routerAuthStateProvider` che cambia SOLO quando `isAuthenticated` o `isSuperadmin` cambiano
- Lo stato `error` non causa pi√π rebuild del router
- LoginScreen gestisce errore in stato locale (`setState`) invece che dal provider globale
- File: `lib/app/router_provider.dart`

### 28. Logout loop infinito (2026-01-01)
**Contesto**: Chiamate infinite a `/v1/auth/logout` quando sessione scaduta.

**Analisi**: 
1. Sessione scaduta ‚Üí `sessionExpiredProvider` triggerato
2. `SessionExpiredListener` chiama `logout()`
3. `logout()` fa chiamata API senza token valido ‚Üí 401
4. 401 triggera di nuovo `sessionExpiredProvider` ‚Üí loop

**Decisione**: 
- Aggiunto parametro `silent` a `logout({bool silent = false})`
- `SessionExpiredListener` chiama `logout(silent: true)` ‚Üí nessuna chiamata API
- File: `lib/features/auth/providers/auth_provider.dart`

### 29. Categorie servizi hardcoded (2026-01-01)
**Contesto**: La sezione Servizi mostrava categorie anche con DB vuoto.

**Analisi**: `ServiceCategoriesNotifier` aveva dati seed hardcoded nel metodo `build()` invece di caricare dall'API.

**Decisione**: 
- Rimossi seed data da `ServiceCategoriesNotifier`
- L'API `GET /v1/services` ritorna gi√† `categories` nella risposta
- `ServicesApi.fetchServicesWithCategories()` estrae categorie dalla risposta
- `ServicesNotifier` popola `serviceCategoriesProvider` con categorie dall'API
- File: `lib/features/services/providers/service_categories_provider.dart`

### 30. User menu in navigation (2026-01-01)
**Contesto**: Menu utente (profilo, cambio password, logout) doveva essere accessibile dalla navigation bar.

**Decisione**: 
- Icona "Profilo" (index 4) nella navigation bar apre popup menu
- Menu contiene: header con nome/email, Cambia password, Cambia Business (solo superadmin), Esci
- Rimossa voce "Profilo" dal menu (non necessaria)
- Superadmin vede stesso menu sia in `/businesses` che dopo selezione business
- File: `lib/app/scaffold_with_navigation.dart`, `lib/app/widgets/user_menu_button.dart`

### 31. Aggiungi eccezione spostato nel menu shift (2026-01-01)
**Contesto**: Il bottone "+" per aggiungere eccezioni alla disponibilit√† occupava spazio nella griglia settimanale.

**Decisione**: 
- Rimosso il bottone "+" standalone dalla griglia
- Aggiunta voce "Aggiungi eccezione" nel menu che appare cliccando su un turno
- La funzionalit√† √® disponibile sia nel menu dei turni base che nel menu delle eccezioni esistenti
- Aggiornato `_countSegmentsForDay` per non contare +1 per il chip rimosso
- File: `lib/features/staff/presentation/staff_week_overview_screen.dart`

----- FILE: docs/milestones.md -----

# Milestones ‚Äî agenda_core

## Stato al 31/12/2025

| Milestone | Descrizione | Stato |
|-----------|-------------|-------|
| **M1** | Auth reale (login, refresh, logout, me) | ‚úÖ Completato |
| **M1.1** | Register + Password Reset | ‚úÖ Completato |
| **M1.2** | Booking Management (view, cancel, reschedule) | ‚úÖ Completato |
| **M2** | Public browse (services, staff, availability) | ‚úÖ Completato |
| **M3** | Booking conferma (POST /bookings + idempotency + conflict) | ‚úÖ Completato |
| **M3.1** | Update/Delete booking | ‚úÖ Completato |
| **M3.2** | Timezone, staff_services, location_schedules | ‚úÖ Completato |
| **M3.3** | API Gestionali (appointments, clients CRUD) | ‚úÖ Completato |
| **M4** | Frontend integration | ‚úÖ Completato |
| **M4.1** | Token web hardening (cookie httpOnly) | ‚úÖ Documentato |
| **M5** | Deploy produzione | ‚úÖ **LIVE** |
| **M6** | Webhook infrastructure | ‚úÖ Completato |
| **M7** | Compatibilit√† gestionale (agenda_backend) | ‚úÖ Completato |
| **M7.1** | Mock elimination | ‚úÖ Completato |
| **M8** | Test minimi | ‚úÖ Completato |
| **M9** | Multi-user sync (adaptive polling + SSE) | ‚¨ú Su richiesta |
| **M10** | Notification system (Email + Webhook lifecycle) | ‚úÖ Completato |
| **M11** | Permessi operatori gestionale (business_users) | ‚úÖ Completato |
| **M11.1** | Sistema inviti via email (business_invitations) | ‚úÖ Completato |
| **M12** | Email multilingua (IT/EN) | ‚¨ú Su richiesta |
| **F1** | Frontend responsive (form factor) | ‚¨ú Su richiesta |
| **F2** | Auto-logout su token scaduto | ‚úÖ Completato |
| **D1** | Deploy effettivo produzione SiteGround | ‚úÖ **LIVE** |
| **D2** | Multi-Business Path-Based URL | ‚úÖ **LIVE** |
| **D3** | Multi-Location Support Frontend | ‚úÖ **LIVE** |
| **D4** | Profilo Utente e Admin Email | ‚úÖ **LIVE** |
| **S1** | Audit Log (tracciamento accessi dati sensibili) | ‚¨ú Su richiesta |

---

## Audit Log - Tracciamento Accessi (S1) ‚¨ú Su richiesta

### Descrizione
Sistema di logging per tracciare tutte le operazioni sui dati sensibili (clienti, appuntamenti).
Utile per compliance GDPR, debug e rilevamento accessi anomali.

> ‚ö†Ô∏è **Nota**: Questa funzionalit√† verr√† implementata solo su specifica richiesta.
> La protezione attuale (autorizzazione API) √® gi√† sufficiente per la sicurezza base.

### Cosa traccia
| Campo | Descrizione |
|-------|-------------|
| `user_id` | Chi ha fatto l'operazione |
| `action` | VIEW, LIST, CREATE, UPDATE, DELETE |
| `resource_type` | client, appointment, booking, ecc. |
| `resource_id` | ID della risorsa |
| `business_id` | Business di appartenenza |
| `ip_address` | IP dell'utente |
| `created_at` | Timestamp operazione |

### Schema DB
```sql
CREATE TABLE audit_logs (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id INT,
    action ENUM('VIEW', 'LIST', 'CREATE', 'UPDATE', 'DELETE', 'LOGIN', 'LOGOUT'),
    resource_type VARCHAR(50),
    resource_id INT NULL,
    business_id INT NULL,
    ip_address VARCHAR(45),
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_user (user_id),
    INDEX idx_resource (resource_type, resource_id),
    INDEX idx_business (business_id),
    INDEX idx_created (created_at)
);
```

### Risorse da loggare
- **Clients**: VIEW, LIST, CREATE, UPDATE, DELETE
- **Appointments**: VIEW, LIST, CREATE, UPDATE, CANCEL
- **Users**: LOGIN, LOGOUT, PASSWORD_CHANGE

### Query utili
```sql
-- Chi ha visto il cliente X?
SELECT * FROM audit_logs WHERE resource_type = 'client' AND resource_id = X;

-- Attivit√† di un utente
SELECT * FROM audit_logs WHERE user_id = Y ORDER BY created_at DESC;

-- Rilevamento accessi anomali (troppi LIST)
SELECT user_id, COUNT(*) as views FROM audit_logs 
WHERE action = 'LIST' GROUP BY user_id HAVING views > 100;
```

### Implementazione
1. Creare classe `AuditLogger` in `src/Infrastructure/Logging/`
2. Iniettare nei controller che gestiscono dati sensibili
3. Chiamare `$this->auditLog->log(...)` dopo ogni operazione

---

## Email Multilingua (M12) ‚¨ú Su richiesta

### Descrizione
Supporto multilingua per tutte le email di sistema (IT/EN inizialmente).

> ‚ö†Ô∏è **Nota**: Questa funzionalit√† verr√† implementata solo su specifica richiesta.
> Attualmente tutte le email sono in italiano (target principale Italia).

### Requisiti
- Lingua determinata dalla preferenza utente (`users.locale`) o business (`businesses.locale`)
- Fallback a IT se non specificata
- Template separati per lingua o sistema placeholder con dizionario

### Template da tradurre
- `businessAdminWelcome` ‚Äî Email benvenuto admin business
- `bookingConfirmed` ‚Äî Conferma prenotazione
- `bookingCancelled` ‚Äî Cancellazione prenotazione
- `bookingReminder` ‚Äî Reminder prenotazione
- `bookingRescheduled` ‚Äî Riprogrammazione prenotazione
- `passwordReset` ‚Äî Reset password

### Implementazione proposta
```php
// Opzione 1: Metodi separati per lingua
EmailTemplateRenderer::businessAdminWelcome('it')
EmailTemplateRenderer::businessAdminWelcome('en')

// Opzione 2: Dizionario + placeholder
EmailTemplateRenderer::render('businessAdminWelcome', $data, 'it')
```

### Modifiche DB (se necessario)
```sql
ALTER TABLE users ADD COLUMN locale VARCHAR(5) DEFAULT 'it';
ALTER TABLE businesses ADD COLUMN locale VARCHAR(5) DEFAULT 'it';
```

---

## Frontend Responsive - Form Factor (F1) ‚¨ú Su richiesta

### Descrizione
Implementare il supporto form factor (responsive breakpoints) nel frontend di prenotazione (agenda_frontend), analogamente a quanto gi√† implementato nel gestionale (agenda_backend).

> ‚ö†Ô∏è **Nota**: Questa funzionalit√† verr√† implementata solo su specifica richiesta.
> Attualmente il frontend funziona ma non ha layout ottimizzati per desktop/tablet/mobile.

### Stato attuale
- **agenda_backend (gestionale)**: ‚úÖ Form factor implementato
  - `AppFormFactor.mobile / .tablet / .desktop`
  - `formFactorProvider` per breakpoint responsive
  - Dialog su desktop, bottom sheet su mobile/tablet
- **agenda_frontend (prenotazione)**: ‚ùå Non implementato
  - Layout unico per tutti i dispositivi

### Implementazione richiesta
1. Copiare `form_factor_provider.dart` da agenda_backend
2. Aggiungere breakpoint responsive
3. Adattare UI per:
   - **Mobile**: Layout verticale, bottom sheet per dialogs
   - **Tablet**: Layout misto
   - **Desktop**: Layout orizzontale, dialog/popup

### File di riferimento (agenda_backend)
- `lib/app/providers/form_factor_provider.dart` ‚Äî Provider breakpoint
- `lib/core/widgets/app_bottom_sheet.dart` ‚Äî Bottom sheet wrapper

---

## Auto-logout su Token Scaduto (F2) ‚úÖ Completato 01/01/2026

### Descrizione
Quando il token JWT scade e il refresh fallisce, invece di mostrare "invalid or expired token", il sistema fa logout automatico e reindirizza alla pagina di login.

### Implementazione
1. **ApiClient**: Aggiunto callback `onSessionExpired` e metodo `_triggerSessionExpired()`
2. **SessionExpiredNotifier**: Provider che emette eventi quando la sessione scade
3. **SessionExpiredListener**: Widget che ascolta gli eventi e fa logout + redirect
4. Snackbar "Sessione scaduta. Effettua nuovamente il login."

### File modificati (agenda_backend)
- `lib/core/network/api_client.dart` ‚Äî Callback `onSessionExpired`, metodo `_triggerSessionExpired()`
- `lib/core/network/network_providers.dart` ‚Äî `SessionExpiredNotifier`, passa callback a ApiClient
- `lib/core/widgets/session_expired_listener.dart` ‚Äî **Nuovo**: Widget listener
- `lib/app/app.dart` ‚Äî Wrappa con `SessionExpiredListener`

### Comportamento
- Su qualsiasi 401 (token scaduto, token invalido, unauthorized)
- ApiClient chiama `_triggerSessionExpired()`
- `SessionExpiredNotifier` incrementa contatore
- `SessionExpiredListener` rileva cambio e:
  - Esegue `authProvider.logout()`
  - Mostra snackbar arancione
  - Redirect a `/login`

---

## Profilo Utente e Admin Email (D4) ‚úÖ LIVE 31/12/2025

### Funzionalit√† implementate

**1. Profilo utente (`PUT /v1/me`):**
- Gli utenti possono modificare nome, cognome, email, telefono
- Validazione email unica (errore se gi√† esistente)
- Pagina profilo in entrambi i frontend

**2. Admin email in CreateBusiness:**
- Nuovo campo `admin_email` invece di `owner_user_id`
- Se email non esiste, crea nuovo utente
- Invia email benvenuto con link reset password (24h)

**3. Trasferimento ownership in UpdateBusiness:**
- Rileva cambio `admin_email`
- Vecchio admin: ruolo da "owner" a "admin"
- Nuovo admin: creato se necessario, ruolo "owner"
- Email benvenuto al nuovo admin

**4. Reinvio invito (`POST /v1/admin/businesses/{id}/resend-invite`):**
- Genera nuovo token reset (24h)
- Invia email benvenuto
- Solo superadmin pu√≤ invocare

**5. Fix admin_email in GET businesses (01/01/2026):**
- `GetAllBusinesses` UseCase ora ritorna `admin_email` nella response
- Permette visualizzazione admin nel dialog di modifica business

**6. Email benvenuto senza URL prenotazioni (01/01/2026):**
- Template `businessAdminWelcome` temporaneamente senza URL prenotazioni
- URL e descrizione commentati (da riattivare quando frontend booking pronto)

### File modificati Backend (agenda_core)
- `src/UseCases/Auth/UpdateProfile.php` ‚Äî Nuovo UseCase
- `src/UseCases/Admin/UpdateBusiness.php` ‚Äî Gestione admin_email
- `src/UseCases/Admin/ResendAdminInvite.php` ‚Äî Nuovo UseCase
- `src/Http/Controllers/AuthController.php` ‚Äî `updateMe()` method
- `src/Http/Controllers/AdminBusinessesController.php` ‚Äî `resendInvite()` action
- `src/Infrastructure/Repository/BusinessRepository.php` ‚Äî `findByIdWithAdmin()`, `findAllWithSearch()` con admin_email
- `src/Http/Kernel.php` ‚Äî Route PUT /v1/me e POST resend-invite

### File modificati Frontend (agenda_backend)
- `lib/features/auth/presentation/profile_screen.dart` ‚Äî Nuova pagina profilo
- `lib/features/business/presentation/dialogs/edit_business_dialog.dart` ‚Äî Campo admin_email
- `lib/features/business/presentation/dialogs/create_business_dialog.dart` ‚Äî Campo admin_email
- `lib/features/business/presentation/business_list_screen.dart` ‚Äî Menu reinvia invito
- `lib/features/business/data/business_repository.dart` ‚Äî Metodo `resendAdminInvite()`
- `lib/app/router.dart` ‚Äî Route /profilo

### File modificati Frontend (agenda_frontend)
- `lib/features/auth/presentation/screens/profile_screen.dart` ‚Äî Nuova pagina profilo
- `lib/core/network/api_client.dart` ‚Äî Metodo `put()` e `updateProfile()`
- `lib/app/router.dart` ‚Äî Route /:slug/profile

---

## Multi-Location Support Frontend (D3) ‚úÖ LIVE 30/12/2025

### Funzionalit√†
Se un business ha pi√π sedi attive, l'utente pu√≤ scegliere dove prenotare.
Se il business ha una sola sede, lo step "Sede" viene saltato automaticamente.

### Implementazione Backend (agenda_core)

**Nuovo endpoint pubblico:**
```
GET /v1/businesses/{business_id}/locations/public
```

**Response:**
```json
{
  "data": [
    {
      "id": 1,
      "business_id": 1,
      "name": "Sede Centrale",
      "address": "Via Roma 1",
      "city": "Milano",
      "phone": "+39 02 1234567",
      "timezone": "Europe/Rome",
      "is_default": true
    }
  ]
}
```

**File modificati:**
- `src/Http/Kernel.php` - Aggiunta route pubblica
- `src/Http/Controllers/LocationsController.php` - Aggiunto `indexPublic()` method

### Implementazione Frontend (agenda_frontend)

**Nuovi file:**
- `lib/core/models/location.dart` - Modello Location
- `lib/features/booking/providers/locations_provider.dart` - Provider per locations
- `lib/features/booking/presentation/screens/location_step.dart` - UI step selezione sede

**Provider chiave:**
- `locationsProvider` ‚Äî Carica lista sedi dal backend
- `selectedLocationProvider` ‚Äî NotifierProvider per selezione utente
- `hasMultipleLocationsProvider` ‚Äî Bool, determina se mostrare step Sede
- `effectiveLocationProvider` ‚Äî Location effettiva (scelta o default)
- `effectiveLocationIdProvider` ‚Äî Int ID per chiamate API

**Booking flow modificato:**
```dart
enum BookingStep { location, services, staff, dateTime, summary }
// location step mostrato solo se hasMultipleLocations == true
```

### Note tecniche
- `LocationsController.indexPublic()` usa `$request->getAttribute('business_id')` (NON `getRouteParam()`)
- Le route pubbliche non hanno middleware auth, quindi `getRouteParam()` non funziona
- L'endpoint ritorna solo sedi con `is_active = 1`

---

## Multi-Business Path-Based (D2) ‚úÖ LIVE 29/12/2025

### Problema risolto
L'URL originale usava `SubdomainResolver.getBusinessSlug()` che leggeva `Uri.base.pathSegments` - 
valore **statico** al caricamento della pagina JavaScript. Quando go_router cambiava il path,
`Uri.base` non si aggiornava, causando loop infiniti o loading bloccato.

### Soluzione implementata
1. **Nuovo provider**: `routeSlugProvider` (StateProvider) aggiornato dinamicamente dal router
2. **Router refactored**: Estrae `:slug` dal path e aggiorna `routeSlugProvider` nel redirect
3. **business_provider.dart**: Ora legge slug da `routeSlugProvider` invece di `SubdomainResolver`

### Struttura URL
```
/                      ‚Üí Landing page (business non specificato)
/:slug                 ‚Üí Redirect a /:slug/booking
/:slug/booking         ‚Üí Schermata prenotazione
/:slug/login           ‚Üí Login
/:slug/register        ‚Üí Registrazione
/:slug/my-bookings     ‚Üí Le mie prenotazioni
/reset-password/:token ‚Üí Reset password (globale, no slug)
```

### Path riservati (non slug)
`reset-password`, `login`, `register`, `booking`, `my-bookings`, `change-password`, `privacy`, `terms`

### File modificati
- `lib/app/providers/route_slug_provider.dart` (NUOVO)
- `lib/app/router.dart` (REFACTORED)
- `lib/features/booking/providers/business_provider.dart` (MODIFIED)

### Test comportamento
| URL | Comportamento |
|-----|---------------|
| `https://prenota.romeolab.it/` | Landing: "Business non specificato" |
| `https://prenota.romeolab.it/salone-mario` | Redirect a `/salone-mario/booking` |
| `https://prenota.romeolab.it/salone-mario/booking` | Carica business da API |
| `https://prenota.romeolab.it/slug-inesistente` | API 404 ‚Üí mostra "Business non trovato" |

---

## Deploy Produzione (D1) ‚úÖ LIVE 28/12/2025

### URL Produzione
- **API**: https://api.romeolab.it
- **Frontend Prenotazioni**: https://prenota.romeolab.it
- **Gestionale**: https://gestionale.romeolab.it (da deployare)

### Infrastruttura SiteGround
- **Hosting**: SiteGround condiviso
- **PHP**: 8.2
- **MySQL**: MariaDB (pannello SiteGround)
- **SSH**: Porta 18765, chiave ed25519

### CORS Configurato
```
CORS_ALLOWED_ORIGINS=https://prenota.romeolab.it,https://gestionale.romeolab.it,http://localhost:8080
```

### Fix Implementati
1. **Loop infinito API** - Convertito `FutureProvider` a `StateNotifier` con flag `_hasFetched`
2. **CORS duplicate headers** - Rimosso da `.htaccess`, gestito solo in PHP
3. **Auth state rebuild** - Usato `ref.watch(authProvider.select(...))` per evitare rebuild

### Comandi Deploy
```bash
# API (agenda_core)
rsync -avz --delete --exclude='.env' --exclude='logs/' \
  agenda_core/ siteground:www/api.romeolab.it/

# Frontend (agenda_frontend)
flutter build web --release --dart-define=API_BASE_URL=https://api.romeolab.it
rsync -avz --delete build/web/ siteground:www/prenota.romeolab.it/public_html/
```

---

## Dettaglio

### M1 - Auth reale ‚úÖ
- `POST /v1/auth/login` - Ritorna access_token + refresh_token
- `POST /v1/auth/refresh` - Rotazione token, revoca su riuso
- `POST /v1/auth/logout` - Invalida sessione
- `GET /v1/me` - Profilo utente + client memberships

### M1.1 - Register + Password Management ‚úÖ
- `POST /v1/auth/register` - Registrazione nuovo utente con validazione password
- **Password Reset Flow**:
  - `POST /v1/auth/forgot-password` - Step 1: richiesta reset (email enumeration protected)
  - `POST /v1/auth/reset-password` - Step 2: conferma reset con token da email
  - Token validity: 1 ora, SHA-256 hashed, monouso
  - Reset invalida tutte le sessioni utente (force re-login)
- **Change Password**:
  - `POST /v1/me/change-password` - Cambio password per utente autenticato
  - Validazione: current password corretta, new password diversa, policy enforcement
- **Frontend (agenda_frontend)**:
  - `/reset-password/:token` - Screen per conferma reset con deep link da email
  - `/change-password` - Screen per cambio password (utenti loggati)
  - Localizzazioni complete IT/EN per tutti i flussi

### M2 - Public browse ‚úÖ
- `GET /v1/services?location_id=1` - 9 servizi raggruppati per categoria
- `GET /v1/staff?location_id=1` - 3 staff prenotabili online
- `GET /v1/availability?location_id=1&date=YYYY-MM-DD&service_ids=1,2` - ~105 slot/giorno

### M3 - Booking conferma ‚úÖ
- `POST /v1/locations/{id}/bookings` - Creazione booking
- Header `X-Idempotency-Key` - UUID v4 obbligatorio
- Conflict detection - HTTP 409 + `slot_conflict`
- Auto-create client da user
- Multi-service con durata sequenziale

### M3.1 - Update/Delete booking ‚úÖ
- `PUT /v1/locations/{id}/bookings/{id}` - Aggiorna status/notes
- `DELETE /v1/locations/{id}/bookings/{id}` - Cancella booking
- Validazione permessi: solo user che ha creato la booking pu√≤ modificare/cancellare
- Status validi: 'pending', 'confirmed', 'cancelled', 'completed', 'no_show'

### M3.2 - Infrastructure enhancements ‚úÖ
- **Timezone location**: Campo `timezone` in tabella `locations` (default 'Europe/Rome')
- **Staff services restrictions**: Tabella `staff_services` per definire quali servizi ogni staff pu√≤ erogare
- **L3.3 - API Gestionali ‚úÖ
- **Appointments API**: 
  - `GET /v1/locations/{id}/appointments?date=YYYY-MM-DD` - Lista appuntamenti con join
  - `PATCH /v1/locations/{id}/appointments/{id}` - Reschedule
  - `POST /v1/locations/{id}/appointments/{id}/cancel` - Cancellazione
- **Clients API**:
  - `GET /v1/clients?business_id=X&search=term` - Lista con search
  - `POST /v1/clients` - Creazione
  - `PUT /v1/clients/{id}` - Aggiornamento
  - `DELETE /v1/clients/{id}` - Soft delete (is_archived)
- Permission model: solo owner pu√≤ modificare appointments/bookings

### M4 - Frontend integration ‚úÖ
- Network layer: `ApiClient` con Dio + auto token refresh
- Token storage: `flutter_secure_storage` (mobile) / memory (web MVP)
- Auth flow: login, logout, session restore
- Booking flow: services, staff, availability, confirm booking
- Tutti i mock rimossi da agenda_frontend

### M4.1 - Token web hardening ‚úÖ
- **Documentazione completa**: TOKEN_STORAGE_WEB.md
- Access token in memoria (cancellato a reload)
- Refresh token in httpOnly cookie (immune XSS)
- Cookie secure, sameSite=Strict
- Refresh automatico su reload app
- Auto-refresh interceptor per 401
- CORS configurato con credentials

### M5 - Deploy produzione ‚úÖ
- **Documentazione completa**: DEPLOY.md
- Nginx config con SSL e security headers
- PHP-FPM tuning
- Database setup con utente dedicato
- Environment config (.env.example)
- Backup script
- Monitoring e health check
- Let's Encrypt integration

### M6 - Webhook infrastructure ‚úÖ
- Migration 0008: `webhook_endpoints` + `webhook_deliveries`
- Schema eventi standard (booking.*, client.*, appointment.*)
- Retry logic preparato (attempt_count, next_retry_at)
- Payload firmabile con HMAC-SHA256
- NON attivo nei flussi (milestone futura)

### M7 - Compatibilit√† gestionale (agenda_backend) ‚úÖ
- **Business/Locations API**:
  - `GET /v1/businesses` - Lista businesses
  - `GET /v1/businesses/{id}` - Dettaglio business
  - `GET /v1/businesses/{id}/locations` - Locations per business
  - `GET /v1/locations/{id}` - Dettaglio location
- **Integration agenda_backend**:
  - ApiClient esteso con `getBusinesses()` e `getLocations()`
  - BusinessRepository e LocationsRepository creati
  - Provider refactored per usare API reali
  - Tutti i TODO risolti e documentati

### M7.1 - Mock elimination ‚úÖ
- **Eliminazione completa mock data**:
  - business_providers.dart: da Provider mock a FutureProvider con API
  - location_providers.dart: da Notifier con mock a Notifier con async API loading
  - appointment_providers.dart: TODO rimossi, aggiunti commenti su limitazioni API
  - Test files: 12 TODO convertiti in documentazione strategia test
- **Pattern adottati**:
  - Repository pattern per tutte le feature
  - FutureProvider per dati read-only
  - Notifier con async init per state mutabile
  - Nessun fallback a mock in produzione

### M8 - Test minimi ‚úÖ
- **Test suite completa**: 98 test, 195 asserzioni
- **AuthUseCaseTest**: Password hashing, validazione email, JWT, refresh token, sessioni
- **BookingUseCaseTest**: Validazione booking, calcolo durata, conflict detection, idempotency
- **AvailabilityTest**: Slot generation, working hours, multi-staff, timezone, buffer time
- **BookingTest**: Slot overlap, validazione date, working hours logic
- **ExceptionsTest**: Auth e Booking exceptions
- **IdempotencyTest**: UUID v4 validation
- **RequestTest/ResponseTest**: HTTP layer
- **RouterTest**: Routing e middleware
- **File test creati**:
  - `tests/AuthUseCaseTest.php` - 18 test auth logic
  - `tests/BookingUseCaseTest.php` - 18 test booking logic
  - `tests/AvailabilityTest.php` - 16 test availability computation

### M11 - Permessi operatori gestionale ‚úÖ
- **Modello Enterprise**: Superadmin globale crea businesses, non self-registration
- **Migration 0013**: Tabella `business_users` con ruoli e permessi
- **Gerarchia ruoli**: owner > admin > manager > staff
- **API Backend (agenda_core)**:
  - `GET /v1/admin/businesses` - Lista businesses (superadmin only)
  - `POST /v1/admin/businesses` - Crea business (superadmin only)
  - `GET /v1/businesses/{id}/users` - Lista operatori
  - `POST /v1/businesses/{id}/users` - Aggiungi operatore esistente
  - `PATCH /v1/businesses/{id}/users/{user_id}` - Modifica ruolo
  - `DELETE /v1/businesses/{id}/users/{user_id}` - Rimuovi operatore
- **File implementati**:
  - `BusinessUserRepository.php` - CRUD operatori con soft delete/reinvite
  - `BusinessUsersController.php` - API endpoints
  - `AdminBusinessesController.php` - API superadmin

### M11.1 - Sistema inviti via email ‚úÖ
- **Migration 0014**: Tabella `business_invitations` con token 64 caratteri
- **Flusso invito**:
  1. Owner/Admin crea invito con email + ruolo
  2. Genera token univoco, scadenza 7 giorni
  3. Utente riceve link, fa login/register
  4. `POST /v1/invitations/{token}/accept` associa utente a business
- **API Backend (agenda_core)**:
  - `GET /v1/businesses/{id}/invitations` - Lista inviti pendenti
  - `POST /v1/businesses/{id}/invitations` - Crea invito
  - `DELETE /v1/businesses/{id}/invitations/{id}` - Revoca invito
  - `GET /v1/invitations/{token}` - Dettagli invito (pubblico)
  - `POST /v1/invitations/{token}/accept` - Accetta invito (auth)
- **Frontend (agenda_backend)**:
  - Modelli: `BusinessUser`, `BusinessInvitation`
  - Repository: `BusinessUsersRepository`
  - Provider: `businessUsersProvider(businessId)` Riverpod 3.x
  - UI: `OperatorsScreen`, `InviteOperatorDialog`, `RoleSelectionDialog`
  - Localizzazioni: chiavi `operators*` in IT/EN

### M9 - Multi-user sync (adaptive polling + SSE) ‚¨ú Su richiesta

**Contesto**: Supportare centinaia di operatori simultanei con sessioni brevi (2-5 min) per gestione appuntamenti, mantenendo sincronizzazione dati senza overhead eccessivo su hosting condiviso.

**Pattern d'uso identificato**:
- Alta frequenza: appointments (modifiche continue + booking online random)
- Bassa frequenza: services, staff, locations (modifiche rare, 1-2 volte/mese)
- Mix business: da singolo staff (no conflitti) a team 10+ persone
- Sessioni brevi: 2-5 minuti medi, non collaborazione real-time lunga

**Requisiti**:
- ‚úÖ Supportare 300-500 operatori su hosting condiviso
- ‚úÖ Latency booking online < 2 secondi
- ‚úÖ Carico server < 10 req/sec medio
- ‚úÖ Adaptive: intervalli polling basati su staff count
- ‚úÖ Zero overhead per business singolo operatore

---

#### Sprint 1: Adaptive Polling Foundation

**Backend (agenda_core)**:
Nessuna modifica richiesta, API esistenti sufficienti.

**Frontend (agenda_backend)**:

1. **PollingConfigProvider** [NUOVO]
   ```dart
   // lib/core/providers/polling_config_provider.dart
   @riverpod
   PollingConfig pollingConfig(Ref ref) {
     final business = ref.watch(currentBusinessProvider);
     final staffCount = ref.watch(staffProvider).length;
     
     return PollingConfig(
       appointments: _getAppointmentsInterval(staffCount),
       // Services/Staff/Locations: NO polling (load on demand)
     );
   }
   
   Duration _getAppointmentsInterval(int staffCount) {
     if (staffCount == 1) return Duration(seconds: 120);  // No conflitti
     if (staffCount <= 5) return Duration(seconds: 60);   // Team piccolo
     return Duration(seconds: 30);                         // Team grande
   }
   ```

2. **AppointmentsNotifier con Polling** [MODIFICARE]
   ```dart
   // lib/features/agenda/providers/appointment_providers.dart
   class AppointmentsNotifier extends AsyncNotifier<List<Appointment>> {
     Timer? _pollTimer;
     
     @override
     Future<List<Appointment>> build() async {
       final data = await _fetchAppointments();
       _startAdaptivePolling();
       ref.onDispose(() => _pollTimer?.cancel());
       return data;
     }
     
     void _startAdaptivePolling() {
       final config = ref.read(pollingConfigProvider);
       final interval = config.appointments;
       
       _pollTimer = Timer.periodic(interval, (_) async {
         // Protezione: skip se drag/resize attivo
         if (_isUserInteracting()) return;
         
         await _refreshSilently();
       });
     }
     
     bool _isUserInteracting() {
       final isDragging = ref.read(dragSessionProvider) != null;
       final isResizing = ref.read(isResizingProvider);
       return isDragging || isResizing;
     }
     
     Future<void> _refreshSilently() async {
       try {
         final newData = await _fetchAppointments();
         state = AsyncData(newData);
       } catch (e) {
         // Log error, non mostrare all'utente
       }
     }
   }
   ```

3. **Services/Staff/Locations: Load on Demand** [CONFERMARE]
   - NO polling automatico
   - Refresh solo dopo CREATE/UPDATE/DELETE
   - Pull-to-refresh manuale disponibile

**Testing**:
- Simulare 2-3 browser contemporanei
- Verificare adaptive intervals (1, 3, 10 staff)
- Testare protezione drag & drop (no refresh durante drag)
- Load test: 50 operatori simulati

**Deliverable**:
- Appointments sincronizzati tra operatori
- Carico server: 5-7 req/sec con 250 operatori
- Funziona su SiteGround shared hosting

**Metriche successo**:
- Conflitti appuntamenti: < 1/settimana (target)
- CPU server medio: < 8%
- Latency API P95: < 150ms

---

#### Sprint 2: SSE Real-Time per Booking Online

**Obiettivo**: Notificare operatori in < 2 secondi quando arriva booking online.

**Backend (agenda_core)**:

1. **EventStream Controller** [NUOVO]
   ```php
   // src/Http/Controllers/EventStreamController.php
   class EventStreamController {
     public function stream(Request $request): Response {
       $locationId = $request->query('location_id');
       
       // Validazione auth
       $this->requireAuth($request);
       
       // Setup SSE headers
       header('Content-Type: text/event-stream');
       header('Cache-Control: no-cache');
       header('Connection: keep-alive');
       
       // Keep-alive heartbeat
       while (true) {
         echo "event: heartbeat\n";
         echo "data: {\"timestamp\": \"" . date('c') . "\"}\n\n";
         flush();
         
         // Check for events ogni 5s
         $events = $this->eventStore->getPendingEvents($locationId);
         foreach ($events as $event) {
           echo "event: {$event->type}\n";
           echo "data: " . json_encode($event->data) . "\n\n";
           flush();
           $this->eventStore->markAsSent($event->id);
         }
         
         sleep(5);
       }
     }
   }
   ```

2. **EventStore Redis/MySQL** [NUOVO]
   ```sql
   CREATE TABLE event_stream (
     id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
     location_id INT UNSIGNED NOT NULL,
     event_type VARCHAR(100) NOT NULL,
     payload JSON NOT NULL,
     created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
     sent_at TIMESTAMP NULL,
     INDEX idx_location_pending (location_id, sent_at)
   );
   ```

3. **Dispatch in CreateBooking** [MODIFICARE]
   ```php
   // src/UseCases/CreateBooking.php
   public function execute(CreateBookingRequest $request): Booking {
     $booking = $this->repository->create($request);
     
     // Nuovo: Dispatch SSE event
     $this->eventStore->push([
       'location_id' => $booking->location_id,
       'event_type' => 'booking.created',
       'payload' => [
         'booking_id' => $booking->id,
         'start_time' => $booking->start_time,
         'client_name' => $booking->client->full_name,
       ],
     ]);
     
     return $booking;
   }
   ```

**Frontend (agenda_backend)**:

1. **EventSource Service** [NUOVO]
   ```dart
   // lib/core/services/event_stream_service.dart
   class EventStreamService {
     EventSource? _eventSource;
     final StreamController<ServerEvent> _controller = StreamController.broadcast();
     
     Stream<ServerEvent> listen(int locationId, String accessToken) {
       _eventSource?.close();
       
       _eventSource = EventSource(
         '${ApiConfig.baseUrl}/events?location_id=$locationId',
         headers: {'Authorization': 'Bearer $accessToken'},
       );
       
       _eventSource!.addEventListener('booking.created', (event) {
         _controller.add(BookingCreatedEvent.fromJson(event.data));
       });
       
       return _controller.stream;
     }
     
     void dispose() {
       _eventSource?.close();
       _controller.close();
     }
   }
   ```

2. **AppointmentsNotifier Integration** [MODIFICARE]
   ```dart
   @override
   Future<List<Appointment>> build() async {
     final data = await _fetchAppointments();
     _startAdaptivePolling();
     _listenToSSE(); // NUOVO
     return data;
   }
   
   void _listenToSSE() {
     final locationId = ref.read(currentLocationProvider).id;
     
     ref.listen(eventStreamProvider(locationId), (prev, next) {
       if (next case AsyncData(value: final event)) {
         if (event is BookingCreatedEvent) {
           // Refresh immediato + notifica
           _refreshSilently();
           _showNotification('Nuova prenotazione online ricevuta!');
         }
       }
     });
   }
   ```

**Testing**:
- Simulare booking online da agenda_frontend
- Verificare notifica < 2s in agenda_backend
- Testare reconnection su disconnect
- Load test: 100 connessioni SSE simultanee

**Deliverable**:
- Latency booking online ‚Üí notifica: < 2 secondi
- Overhead SSE: < 1% CPU (heartbeat leggero)
- Funziona con 300+ operatori

**Metriche successo**:
- Latency P95 notifica: < 2s
- Connessioni SSE concorrenti: 300+ senza problemi
- Reconnection automatica su network issues

---

#### Sprint 3: UX Polish & Manual Refresh

**Obiettivo**: Dare controllo all'utente su sincronizzazione + indicatori stato.

1. **Pull-to-Refresh** [AGGIUNGERE]
   ```dart
   // Tutte le schermate lista (agenda, clients, services, staff)
   RefreshIndicator(
     onRefresh: () => ref.refresh(dataProvider.future),
     child: ListView(...),
   )
   ```

2. **Refresh Button in AppBar** [AGGIUNGERE]
   ```dart
   AppBar(
     actions: [
       IconButton(
         icon: Icon(Icons.refresh),
         onPressed: () => ref.invalidate(appointmentsProvider),
       ),
     ],
   )
   ```

3. **Timestamp Ultimo Aggiornamento** [NUOVO]
   ```dart
   class LastUpdateIndicator extends ConsumerWidget {
     @override
     Widget build(BuildContext context, WidgetRef ref) {
       final lastUpdate = ref.watch(lastAppointmentUpdateProvider);
       return Text(
         'Aggiornato ${_formatTimeAgo(lastUpdate)}',
         style: Theme.of(context).textTheme.bodySmall,
       );
     }
   }
   ```

4. **Sync Status Badge** [NUOVO - opzionale]
   ```dart
   // AppBar indicator
   class SyncStatusBadge extends ConsumerWidget {
     @override
     Widget build(BuildContext context, WidgetRef ref) {
       final isSyncing = ref.watch(isSyncingProvider);
       final hasError = ref.watch(syncErrorProvider) != null;
       
       return Icon(
         hasError ? Icons.sync_problem : 
         isSyncing ? Icons.sync : Icons.check_circle,
         color: hasError ? Colors.red : 
                isSyncing ? Colors.orange : Colors.green,
         size: 16,
       );
     }
   }
   ```

5. **Settings: Disable Auto-Sync** [NUOVO - opzionale]
   ```dart
   // lib/features/settings/presentation/sync_settings_screen.dart
   SwitchListTile(
     title: Text('Sincronizzazione automatica'),
     subtitle: Text('Aggiorna appuntamenti in background'),
     value: ref.watch(autoSyncEnabledProvider),
     onChanged: (value) {
       ref.read(autoSyncEnabledProvider.notifier).state = value;
       if (!value) {
         // Stop polling
         ref.read(appointmentsProvider.notifier).stopPolling();
       }
     },
   )
   ```

**Testing**:
- UX flow: pull-to-refresh su tutte le schermate
- Indicatori timestamp corretti
- Settings disabilita/abilita sync

**Deliverable**:
- UI polish completo
- Controllo utente su sync
- Trasparenza stato sincronizzazione

---

#### Architettura Finale

**Data Sync Strategy**:
| Tipo Data | Strategia | Intervallo | Trigger |
|-----------|-----------|------------|---------|
| Appointments | Adaptive Polling | 30-120s | Auto + SSE + Manual |
| Services | Load on Demand | - | Manual refresh |
| Staff | Load on Demand | - | Manual refresh |
| Locations | Load on Demand | - | Manual refresh |
| Booking Online | SSE Push | Real-time | Server event |

**Adaptive Intervals Logic**:
- 1 staff ‚Üí 120s (no conflitti possibili)
- 2-5 staff ‚Üí 60s (team piccolo)
- 6+ staff ‚Üí 30s (team grande)
- Pause polling durante drag/resize attivo

**Performance Target**:
- Request/sec medio: 5-7 (250 operatori)
- Request/sec picco: 20-25 (100 operatori login simultaneo)
- CPU server: < 10% su shared hosting
- Supporto: 300-500 operatori su SiteGround shared (‚Ç¨10/mese)

---

#### Costi & Timeline

**Sviluppo**:
- Sprint 1 (Adaptive Polling): 2 giorni √ó ‚Ç¨400 = ‚Ç¨800
- Sprint 2 (SSE): 3 giorni √ó ‚Ç¨400 = ‚Ç¨1,200
- Sprint 3 (UX Polish): 1 giorno √ó ‚Ç¨400 = ‚Ç¨400
- **Totale one-time**: ‚Ç¨2,400

**Operativi** (annuale, 250 operatori):
- Hosting: ‚Ç¨120/anno (shared sufficiente)
- Bandwidth: trascurabile (< 1 GB/giorno)
---

#### Decision Point: Quando Implementare

**Implementa Sprint 1 se**:
- ‚úÖ Pi√π di 5 business con 3+ staff
- ‚úÖ Frequenti modifiche appuntamenti (20+/giorno per business)
- ‚úÖ Segnalazioni conflitti da operatori (2+/settimana)

**Implementa Sprint 2 se**:
- ‚úÖ Sprint 1 implementato e funzionante
- ‚úÖ Booking online attivo e usato frequentemente (10+/giorno)
- ‚úÖ Latency notifica > 1 minuto non accettabile

**Implementa Sprint 3 se**:
- ‚úÖ Sprint 1 e/o 2 implementati
- ‚úÖ Feedback utenti su trasparenza sync
- ‚úÖ Richiesta controllo manuale polling

**NON implementare se**:
- ‚ùå Tutti business con singolo staff
- ‚ùå Modifiche rare (< 5/giorno)
- ‚ùå Nessuna segnalazione conflitti

---

#### Metriche di Successo

**KPI Post-Implementazione**:
| Metrica | Baseline | Target Sprint 1 | Target Sprint 2 |
|---------|----------|-----------------|-----------------|
| Conflitti/settimana | 3-5 | < 1 | < 1 |
| Latency booking online | N/A | 30-120s | < 2s |
| Ricariche manuali/giorno | 20-30 | < 10 | < 5 |
| Server CPU avg | 1% | 3-5% | 5-8% |
| Operatori supportati | 50 | 300 | 500 |

**Alerting**:
- ‚ö†Ô∏è Polling lag > 60s per 3 cicli ‚Üí Network issues
- üî¥ Error rate polling > 10% ‚Üí Backend problems
- üî¥ SSE disconnections > 5/ora ‚Üí Infrastructure issues
- üî¥ Memory leak > 50MB in 1h ‚Üí Code issue

---

#### Scalabilit√† Futura

| Operatori | Soluzione | Hosting | Note |
|-----------|-----------|---------|------|
| 1-300 | Sprint 1 | Shared hosting | Sufficiente |
| 301-500 | Sprint 1+2 | Shared hosting | Con SSE |
| 501-1000 | Sprint 1+2 + ETags | Cloud hosting | + Conditional requests |
| 1000+ | WebSocket full | Cloud scalabile | Real-time bi-direzionale |

**Upgrade Path**: Quando superi 500 operatori, considera migrazione a Cloud hosting e implementazione full WebSocket invece di polling + SSE.

---

### M10 - Notification System (Email + Webhook lifecycle) ‚úÖ Completato

**Contesto**: Sistema completo di notifiche email per il ciclo di vita degli appuntamenti, con architettura multi-provider e coda asincrona.

#### Architettura Multi-Provider

**Pattern Strategy** per cambio provider via `.env`:
```ini
MAIL_PROVIDER=brevo  # smtp | brevo | mailgun
```

**Provider implementati**:
1. **SmtpProvider**: SMTP generico (SiteGround, Gmail, qualsiasi server SMTP)
2. **BrevoProvider**: Brevo API (300 email/giorno gratis) + fallback SMTP
3. **MailgunProvider**: Mailgun REST API con supporto region EU/US

#### Gerarchia Email Sender (priorit√†)

| Priorit√† | Fonte | Esempio |
|----------|-------|---------|
| **1¬∞ (alta)** | `locations.email` | `sede.roma@salonemario.it` |
| **2¬∞** | `businesses.email` | `info@salonemario.it` |
| **3¬∞ (fallback)** | `.env MAIL_FROM_*` | `noreply@romeolab.it` |

**Logica implementata nel worker**:
```php
$fromEmail = $variables['sender_email'] 
    ?? $variables['location_email'] 
    ?? $variables['business_email'] 
    ?? null;  // null = usa .env fallback
```

#### File Backend (agenda_core)

```
src/Infrastructure/Notifications/
‚îú‚îÄ‚îÄ EmailProviderInterface.php    # Contratto comune
‚îú‚îÄ‚îÄ SmtpProvider.php              # SMTP generico
‚îú‚îÄ‚îÄ BrevoProvider.php             # Brevo API
‚îú‚îÄ‚îÄ MailgunProvider.php           # Mailgun API
‚îú‚îÄ‚îÄ EmailService.php              # Factory con caching
‚îú‚îÄ‚îÄ EmailTemplateRenderer.php     # Template HTML responsive
‚îî‚îÄ‚îÄ NotificationRepository.php    # CRUD coda notifiche

src/UseCases/Notifications/
‚îú‚îÄ‚îÄ QueueBookingConfirmation.php  # Conferma prenotazione
‚îú‚îÄ‚îÄ QueueBookingCancellation.php  # Cancellazione
‚îî‚îÄ‚îÄ QueueBookingReminder.php      # Reminder 24h prima

bin/
‚îú‚îÄ‚îÄ notification-worker.php       # Processa coda (cron ogni minuto)
‚îú‚îÄ‚îÄ queue-reminders.php           # Accoda reminder (cron ogni ora)
‚îú‚îÄ‚îÄ run-worker.sh                 # Wrapper portabile
‚îî‚îÄ‚îÄ run-reminders.sh              # Wrapper portabile

migrations/
‚îî‚îÄ‚îÄ FULL_DATABASE_SCHEMA.sql      # Include notification_queue, notification_templates, notification_settings
```

#### Template Email

4 template HTML responsive con versione plaintext:
1. `bookingConfirmed` - Conferma prenotazione
2. `bookingCancelled` - Cancellazione
3. `bookingReminder` - Reminder 24h
4. `bookingRescheduled` - Modifica data/ora

#### Integrazione Use Case

- **CreateBooking.php**: Accoda conferma + reminder (non bloccante)
- **DeleteBooking.php**: Accoda cancellazione (non bloccante)

#### Frontend (agenda_backend)

- **Campo email location**: Aggiunto al dialog modifica sede
- **Localizzazioni**: `teamLocationEmailLabel`, `teamLocationEmailHint` (IT/EN)

#### Cron Setup Produzione

```bash
# Wrapper script (portabili - non dipendono da path PHP)
* * * * * /path/to/agenda_core/bin/run-worker.sh
0 * * * * /path/to/agenda_core/bin/run-reminders.sh
```

#### Configurazione .env

```ini
MAIL_PROVIDER=brevo
BREVO_API_KEY=xkeysib-xxxxx
BREVO_SMTP_KEY=xsmtpsib-xxxxx
MAIL_FROM_ADDRESS=noreply@tuodominio.it
MAIL_FROM_NAME="Agenda"
```

#### Raccomandazione

Per hosting condiviso (SiteGround): **Brevo** (300 email/giorno gratuiti)
- Verificare dominio su Brevo per sender dinamico
- Ogni location/business pu√≤ avere email personalizzata

---

### M11 - Permessi operatori gestionale ‚¨ú Proposta pronta

**Obiettivo**: Implementare sistema di autenticazione e autorizzazione per operatori del gestionale (agenda_backend), permettendo assegnazione utenti a business con ruoli e permessi.

**Problema attuale**:
- Gli operatori non hanno login nel gestionale
- Il business √® hardcoded (`currentBusinessId = 1`)
- Tutti vedono tutti i business (no multi-tenant security)

**Soluzione**: Tabella `business_users` che collega `users` a `businesses`.

---

#### Sprint 1: Database & API Base

**Backend (agenda_core)**:

1. **Migration** ‚úÖ CREATA
   - Inclusa in: `migrations/FULL_DATABASE_SCHEMA.sql`
   - Tabella `business_users` con ruoli (owner/admin/manager/staff)
   - Permessi granulari (can_manage_bookings, can_manage_clients, etc.)
   - Link opzionale a `staff_id`

2. **Repository** [DA CREARE]
   ```php
   // src/Infrastructure/Repositories/BusinessUserRepository.php
   class BusinessUserRepository {
       public function findByUserId(int $userId): array;
       public function findByBusinessId(int $businessId): array;
       public function hasAccess(int $userId, int $businessId): bool;
       public function getRole(int $userId, int $businessId): ?string;
       public function create(array $data): int;
       public function update(int $id, array $data): void;
       public function delete(int $id): void;
   }
   ```

3. **Use Cases** [DA CREARE]
   ```php
   // GetUserBusinesses - Lista business dove user ha accesso
   // InviteUserToBusiness - Invita nuovo operatore
   // UpdateBusinessUser - Modifica ruolo/permessi
   // RemoveBusinessUser - Rimuovi accesso
   ```

4. **Controller** [DA CREARE]
   ```php
   // src/Http/Controllers/BusinessUsersController.php
   // GET /v1/me/businesses
   // POST /v1/businesses/{id}/users
   // PUT /v1/businesses/{id}/users/{userId}
   // DELETE /v1/businesses/{id}/users/{userId}
   ```

5. **Middleware** [DA CREARE]
   ```php
   // BusinessAccessMiddleware - Valida accesso al business
   // Applicato a tutte le route /v1/businesses/{id}/*
   ```

**Deliverable Sprint 1**:
- API `/v1/me/businesses` funzionante
- Middleware validazione accesso
- Test unitari repository

---

#### Sprint 2: Frontend Auth

**Frontend (agenda_backend)**:

1. **Auth Feature** [DA CREARE]
   ```
   lib/features/auth/
   ‚îú‚îÄ‚îÄ data/
   ‚îÇ   ‚îî‚îÄ‚îÄ auth_repository.dart
   ‚îú‚îÄ‚îÄ domain/
   ‚îÇ   ‚îî‚îÄ‚îÄ auth_state.dart
   ‚îú‚îÄ‚îÄ providers/
   ‚îÇ   ‚îî‚îÄ‚îÄ auth_provider.dart
   ‚îî‚îÄ‚îÄ presentation/
       ‚îî‚îÄ‚îÄ login_screen.dart
   ```

2. **Modifiche Provider** [DA MODIFICARE]
   ```dart
   // business_providers.dart
   // Cambiare da GET /v1/businesses a GET /v1/me/businesses
   final userBusinessesProvider = FutureProvider<List<Business>>((ref) async {
     final repository = ref.watch(authRepositoryProvider);
     return repository.getMyBusinesses();
   });
   ```

3. **Route Guard** [DA CREARE]
   ```dart
   // router.dart - Aggiungere redirect
   redirect: (context, state) {
     final isLoggedIn = ref.read(authProvider).isAuthenticated;
     if (!isLoggedIn && !state.matchedLocation.startsWith('/login')) {
       return '/login';
     }
     return null;
   }
   ```

4. **Business Selection** [DA MODIFICARE]
   - Mostrare dialog selezione business dopo login
   - Salvare `currentBusinessId` in local storage
   - Visualizzare business corrente in app bar

**Deliverable Sprint 2**:
- Login/logout funzionante
- Selezione business post-login
- Persistenza sessione

---

#### Sprint 3: Gestione Team

**Backend (agenda_core)**:

1. **Invite Flow**
   - `POST /v1/businesses/{id}/users` con email destinatario
   - Invio email invito (se M10 completato, altrimenti skip)
   - Token invito con scadenza 7 giorni
   - `POST /v1/invitations/{token}/accept` per accettare

2. **Team Management UI** (agenda_backend)
   - Screen lista operatori business
   - Form modifica ruolo/permessi
   - Azione rimuovi accesso
   - Azione re-invita

**Deliverable Sprint 3**:
- Invito nuovi operatori
- Gestione ruoli esistenti

---

#### Sprint 4: Permessi Granulari

**Backend**:

1. **Permission Check Middleware**
   ```php
   // Esempio: solo manager+ pu√≤ gestire clienti
   if (!$this->hasPermission($userId, $businessId, 'can_manage_clients')) {
       throw AuthException::forbidden('Cannot manage clients');
   }
   ```

2. **Staff-Only View**
   - Se `role = 'staff'` e `staff_id` impostato
   - Filtrare appointments per `staff_id`
   - Nascondere altri calendari

**Frontend**:

1. **UI Conditional Rendering**
   ```dart
   if (userPermissions.canManageStaff) {
     // Mostra sezione gestione team
   }
   ```

2. **Menu Condizionale**
   - Nascondere voci menu non autorizzate
   - Disabilitare azioni non permesse

**Deliverable Sprint 4**:
- Permessi granulari funzionanti
- UI adattiva ai permessi
- Test E2E flusso completo

---

#### Metriche Successo

| Metrica | Target | Misurazione |
|---------|--------|-------------|
| Login success rate | > 99% | auth_sessions created |
| Business selection time | < 2s | UX test |
| Permission check latency | < 10ms | API profiling |
| Unauthorized access attempts | 0 | Security logs |

---

## Note Aggiuntive

### Decisioni architetturali
Vedere [decisions.md](./decisions.md) per dettaglio su:
- Mock elimination strategy
- Test strategy (backend-heavy)
- Provider loading patterns
- Business context derivation
- **Decision 21**: Sistema permessi operatori

### API Documentation
Vedere [api_contract_v1.md](./api_contract_v1.md) per contratto completo API.

----- FILE: docs/model_map.md -----

# Model Map ‚Äî agenda_core

Questo documento elenca i modelli reali usati dai client Flutter e i campi con tipi e nullabilit√†.
I campi **vincolanti** (snake_case) NON possono essere rinominati.

---

## üì¶ Frontend (prenotazione online)

### ServiceCategory
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| businessId | int | ‚úó | `business_id` |
| name | String | ‚úó | `name` |
| description | String | ‚úì | `description` |
| sortOrder | int | ‚úó (default: 0) | `sort_order` |

### Service
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| businessId | int | ‚úó | `business_id` |
| categoryId | int | ‚úó | `category_id` |
| name | String | ‚úó | `name` |
| description | String | ‚úì | `description` |
| sortOrder | int | ‚úó (default: 0) | `sort_order` |
| durationMinutes | int | ‚úó (default: 30) | `duration_minutes` |
| price | double | ‚úó (default: 0.0) | `price` |
| isFree | bool | ‚úó (default: false) | `is_free` |
| isPriceStartingFrom | bool | ‚úó (default: false) | `is_price_starting_from` |
| isBookableOnline | bool | ‚úó (default: true) | `is_bookable_online` |

### Staff
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| businessId | int | ‚úó | `business_id` |
| name | String | ‚úó | `name` |
| surname | String | ‚úó (default: '') | `surname` |
| avatarUrl | String | ‚úì | `avatar_url` |
| sortOrder | int | ‚úó (default: 0) | `sort_order` |
| isBookableOnline | bool | ‚úó (default: true) | `is_bookable_online` |

### TimeSlot
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| startTime | DateTime | ‚úó | `start_time` (ISO8601) |
| endTime | DateTime | ‚úó | `end_time` (ISO8601) |
| staffId | int | ‚úì | `staff_id` |

### User
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| email | String | ‚úó | `email` |
| firstName | String | ‚úó | `first_name` |
| lastName | String | ‚úó | `last_name` |
| phone | String | ‚úì | `phone` |
| createdAt | DateTime | ‚úó | `created_at` (ISO8601) |

### BookingRequest (payload POST /bookings)
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| services | List<Service> | ‚úó | ‚Üí `service_ids` (array int) |
| selectedStaff | Staff | ‚úì | ‚Üí `staff_id` (int) |
| selectedSlot | TimeSlot | ‚úì | ‚Üí `start_time` (ISO8601) |
| notes | String | ‚úì | `notes` |

**‚ö†Ô∏è Payload finale inviato al server:**
```json
{
  "service_ids": [1, 2],
  "staff_id": 5,
  "start_time": "2025-01-15T10:00:00Z",
  "notes": "optional"
}
```

---

## üè¢ Backend (gestionale)

### ServiceCategory (Backend)
Identico al frontend.

### Service (Backend)
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| businessId | int | ‚úó | `business_id` |
| categoryId | int | ‚úó | `category_id` |
| name | String | ‚úó | `name` |
| description | String | ‚úì | `description` |
| sortOrder | int | ‚úó (default: 0) | `sort_order` |

> **Nota**: Il backend usa `ServiceVariant` per durata/prezzo per location.

### ServiceVariant
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| serviceId | int | ‚úó | `service_id` |
| locationId | int | ‚úó | `location_id` |
| durationMinutes | int | ‚úó | `duration_minutes` |
| processingTime | int | ‚úì | `processing_time` |
| blockedTime | int | ‚úì | `blocked_time` |
| price | double | ‚úó | `price` |
| colorHex | String | ‚úì | `color_hex` |
| currency | String | ‚úì | `currency` |
| isBookableOnline | bool | ‚úó (default: true) | `is_bookable_online` |
| isFree | bool | ‚úó (default: false) | `is_free` |
| isPriceStartingFrom | bool | ‚úó (default: false) | `is_price_starting_from` |

### Staff (Backend)
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| businessId | int | ‚úó | `business_id` |
| name | String | ‚úó | `name` |
| surname | String | ‚úó (default: '') | `surname` |
| color | Color | ‚úó | `color_hex` |
| locationIds | List<int> | ‚úó | `location_ids` |
| sortOrder | int | ‚úó (default: 0) | `sort_order` |
| isDefault | bool | ‚úó (default: false) | `is_default` |
| isBookableOnline | bool | ‚úó (default: true) | `is_bookable_online` |

### Location
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| businessId | int | ‚úó | `business_id` |
| name | String | ‚úó | `name` |
| address | String | ‚úì | `address` |
| city | String | ‚úì | `city` |
| region | String | ‚úì | `region` |
| country | String | ‚úì | `country` |
| phone | String | ‚úì | `phone` |
| email | String | ‚úì | `email` |
| latitude | double | ‚úì | `latitude` |
| longitude | double | ‚úì | `longitude` |
| currency | String | ‚úì | `currency` |
| isDefault | bool | ‚úó (default: false) | `is_default` |

### Booking
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| businessId | int | ‚úó | `business_id` |
| locationId | int | ‚úó | `location_id` |
| clientId | int | ‚úì | `client_id` |
| clientName | String | ‚úì | `client_name` |
| notes | String | ‚úì | `notes` |

### Appointment (booking item)
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| bookingId | int | ‚úó | `booking_id` |
| businessId | int | ‚úó | `business_id` |
| locationId | int | ‚úó | `location_id` |
| staffId | int | ‚úó | `staff_id` |
| serviceId | int | ‚úó | `service_id` |
| serviceVariantId | int | ‚úó | `service_variant_id` |
| clientId | int | ‚úì | `client_id` |
| clientName | String | ‚úó (default: '') | `client_name` |
| serviceName | String | ‚úó (default: '') | `service_name` |
| startTime | DateTime | ‚úó | `start_time` (ISO8601) |
| endTime | DateTime | ‚úó | `end_time` (ISO8601) |
| price | double | ‚úì | `price` |
| extraMinutes | int | ‚úì | `extra_minutes` |
| extraMinutesType | ExtraMinutesType | ‚úì | `extra_minutes_type` |
| extraBlockedMinutes | int | ‚úì | `extra_blocked_minutes` |
| extraProcessingMinutes | int | ‚úì | `extra_processing_minutes` |

### Client
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| businessId | int | ‚úó | `business_id` |
| firstName | String | ‚úì | `first_name` |
| lastName | String | ‚úì | `last_name` |
| email | String | ‚úì | `email` |
| phone | String | ‚úì | `phone` |
| gender | String | ‚úì | `gender` |
| birthDate | DateTime | ‚úì | `birth_date` |
| city | String | ‚úì | `city` |
| notes | String | ‚úì | `notes` |
| createdAt | DateTime | ‚úó | `created_at` |
| lastVisit | DateTime | ‚úì | `last_visit` |
| loyaltyPoints | int | ‚úì | `loyalty_points` |
| tags | List<String> | ‚úì | `tags` |
| isArchived | bool | ‚úó (default: false) | `is_archived` |

### Resource
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| locationId | int | ‚úó | `location_id` |
| name | String | ‚úó | `name` |
| quantity | int | ‚úó | `quantity` |
| type | String | ‚úì | `type` |
| note | String | ‚úì | `note` |

### TimeBlock
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| businessId | int | ‚úó | `business_id` |
| locationId | int | ‚úó | `location_id` |
| staffIds | List<int> | ‚úó | `staff_ids` |
| startTime | DateTime | ‚úó | `start_time` (ISO8601) |
| endTime | DateTime | ‚úó | `end_time` (ISO8601) |
| reason | String | ‚úì | `reason` |
| isAllDay | bool | ‚úó (default: false) | `is_all_day` |

---

## üîí Riepilogo campi vincolanti

Questi campi sono usati attivamente nei client Flutter e **NON devono essere rinominati**:

| Modello | Campi critici |
|---------|---------------|
| Service | `id`, `business_id`, `category_id`, `name`, `duration_minutes`, `price`, `is_free`, `is_price_starting_from`, `is_bookable_online` |
| Staff | `id`, `business_id`, `name`, `surname`, `is_bookable_online`, `sort_order` |
| TimeSlot | `start_time`, `end_time`, `staff_id` |
| BookingRequest | `service_ids`, `staff_id`, `start_time`, `notes` |
| Booking | `id`, `business_id`, `location_id`, `client_id`, `client_name`, `notes` |
| Appointment | `id`, `booking_id`, `business_id`, `location_id`, `staff_id`, `service_id`, `start_time`, `end_time` |
| User | `id`, `email`, `first_name`, `last_name`, `phone`, `created_at` |
| Client | `id`, `business_id`, `first_name`, `last_name`, `email`, `phone`, `created_at` |

----- FILE: docs/test_scenarios.md -----

# Test Scenarios ‚Äî Agenda Core API

Questo documento definisce tutti i casi di test per validare il comportamento dell'API Agenda Core.
Aggiornato al: **27 dicembre 2025**

---

## üìã Indice

- [Setup Test Environment](#setup-test-environment)
- [M1: Authentication](#m1-authentication)
- [M2: Public Browse](#m2-public-browse)
- [M3: Booking Creation](#m3-booking-creation)
- [M1.1: Booking Management](#m11-booking-management)
  - [View Bookings](#view-bookings)
  - [Cancel Booking](#cancel-booking)
  - [Reschedule Booking](#reschedule-booking)
- [Edge Cases & Error Handling](#edge-cases--error-handling)
- [Performance & Concurrency](#performance--concurrency)

---

## Setup Test Environment

### Prerequisiti

```bash
# Database di test
mysql -u root -p agenda_test < migrations/FULL_DATABASE_SCHEMA.sql

# Dati di test
mysql -u root -p agenda_test < migrations/seed_data.sql
```

### Test User Credentials

```json
{
  "test_user_1": {
    "email": "mario.rossi@test.com",
    "password": "TestPass123!",
    "user_id": 1
  },
  "test_user_2": {
    "email": "anna.bianchi@test.com",
    "password": "TestPass456!",
    "user_id": 2
  }
}
```

### Test Business/Location IDs

- **Business ID**: 1 (Salone Bella Vita)
- **Location ID**: 1 (Sede Centro, cancellation_hours: 24)
- **Location ID**: 2 (Sede Periferia, cancellation_hours: 48)

### Test Staff/Services

- **Staff ID**: 1 (Anna B., stylist)
- **Staff ID**: 2 (Luigi M., barber)
- **Service ID**: 1 (Taglio Uomo, 30 min, ‚Ç¨20)
- **Service ID**: 2 (Taglio Donna, 45 min, ‚Ç¨35)
- **Service ID**: 3 (Piega, 30 min, ‚Ç¨15)

---

## M1: Authentication

### TEST-AUTH-001: Login con credenziali valide

**Request:**
```http
POST /v1/auth/login
Content-Type: application/json

{
  "email": "mario.rossi@test.com",
  "password": "TestPass123!"
}
```

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "access_token": "eyJ...",
    "refresh_token": "abc123...",
    "expires_in": 900,
    "user": {
      "id": 1,
      "email": "mario.rossi@test.com",
      "first_name": "Mario",
      "last_name": "Rossi"
    }
  }
}
```

**Validazioni:**
- ‚úÖ `access_token` √® un JWT valido
- ‚úÖ `expires_in` = 900 (15 minuti)
- ‚úÖ `refresh_token` salvato in DB con scadenza 30-90 giorni

---

### TEST-AUTH-002: Login con password errata

**Request:**
```http
POST /v1/auth/login
Content-Type: application/json

{
  "email": "mario.rossi@test.com",
  "password": "WrongPassword!"
}
```

**Expected Response (401):**
```json
{
  "success": false,
  "error": {
    "code": "invalid_credentials",
    "message": "Invalid email or password"
  }
}
```

---

### TEST-AUTH-003: Refresh token con token valido

**Request:**
```http
POST /v1/auth/refresh
Content-Type: application/json

{
  "refresh_token": "abc123..."
}
```

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "access_token": "eyJ_new...",
    "refresh_token": "xyz789_new...",
    "expires_in": 900
  }
}
```

**Validazioni:**
- ‚úÖ Vecchio `refresh_token` invalidato (token rotation)
- ‚úÖ Nuovo `refresh_token` salvato in DB
- ‚úÖ Tentativo di riutilizzo vecchio token ‚Üí 401

---

### TEST-AUTH-004: Logout invalida refresh token

**Request:**
```http
POST /v1/auth/logout
Authorization: Bearer <access_token>
Content-Type: application/json

{
  "refresh_token": "abc123..."
}
```

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "message": "Logged out successfully"
  }
}
```

**Validazioni:**
- ‚úÖ `refresh_token` rimosso da DB
- ‚úÖ Tentativo refresh dopo logout ‚Üí 401 `invalid_refresh_token`

---

## M2: Public Browse

### TEST-BROWSE-001: Lista servizi per location

**Request:**
```http
GET /v1/services?location_id=1
```

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "categories": [
      {
        "id": 1,
        "name": "Taglio",
        "services": [
          {
            "id": 1,
            "name": "Taglio Uomo",
            "description": "Taglio classico o moderno",
            "default_duration_minutes": 30,
            "default_price": 20.00,
            "color": "#FF6B6B",
            "category_id": 1
          }
        ]
      }
    ]
  }
}
```

---

### TEST-BROWSE-002: Availability check base

**Request:**
```http
GET /v1/availability?location_id=1&date=2026-01-15&service_ids=1&staff_id=1
```

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "slots": [
      {
        "start_time": "2026-01-15T09:00:00+01:00",
        "end_time": "2026-01-15T09:30:00+01:00",
        "staff_id": 1,
        "staff_name": "Anna B."
      },
      {
        "start_time": "2026-01-15T09:30:00+01:00",
        "end_time": "2026-01-15T10:00:00+01:00",
        "staff_id": 1,
        "staff_name": "Anna B."
      }
    ]
  }
}
```

**Validazioni:**
- ‚úÖ Solo slot liberi (no conflitti con booking esistenti)
- ‚úÖ Rispetta orari lavoro staff
- ‚úÖ Durata slot = somma durate servizi

---

### TEST-BROWSE-003: Availability con servizi multipli

**Request:**
```http
GET /v1/availability?location_id=1&date=2026-01-15&service_ids=1,3&staff_id=1
```

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "slots": [
      {
        "start_time": "2026-01-15T09:00:00+01:00",
        "end_time": "2026-01-15T10:00:00+01:00",
        "staff_id": 1,
        "staff_name": "Anna B."
      }
    ]
  }
}
```

**Validazioni:**
- ‚úÖ Durata slot = 30 min (service 1) + 30 min (service 3) = 60 min
- ‚úÖ Verifica disponibilit√† continuativa per entrambi i servizi

---

## M3: Booking Creation

### TEST-BOOKING-001: Creazione booking con slot disponibile

**Request:**
```http
POST /v1/locations/1/bookings
Authorization: Bearer <access_token>
X-Idempotency-Key: 550e8400-e29b-41d4-a716-446655440001
Content-Type: application/json

{
  "service_ids": [1],
  "staff_id": 1,
  "start_time": "2026-01-15T10:00:00+01:00",
  "notes": "Prima visita"
}
```

**Expected Response (201):**
```json
{
  "success": true,
  "data": {
    "id": 42,
    "business_id": 1,
    "location_id": 1,
    "client_id": 1,
    "status": "confirmed",
    "notes": "Prima visita",
    "total_price": 20.00,
    "total_duration_minutes": 30,
    "created_at": "2025-12-27T14:30:00+01:00",
    "items": [
      {
        "id": 101,
        "service_id": 1,
        "service_name": "Taglio Uomo",
        "staff_id": 1,
        "staff_name": "Anna B.",
        "location_id": 1,
        "start_time": "2026-01-15T10:00:00+01:00",
        "end_time": "2026-01-15T10:30:00+01:00",
        "price": 20.00,
        "duration_minutes": 30
      }
    ]
  }
}
```

**Validazioni:**
- ‚úÖ Record `bookings` creato con `status='confirmed'`
- ‚úÖ Record `booking_items` creato con `service_variant_id` risolto
- ‚úÖ Record `clients` auto-creato se primo booking utente
- ‚úÖ `idempotency_key` salvato con expires_at = +24h

---

### TEST-BOOKING-002: Creazione booking con slot occupato

**Setup:**
1. Crea booking A: staff_id=1, 2026-01-15 10:00-10:30
2. Tenta booking B: staff_id=1, 2026-01-15 10:15-10:45 (overlap)

**Request (Booking B):**
```http
POST /v1/locations/1/bookings
Authorization: Bearer <access_token>
X-Idempotency-Key: 550e8400-e29b-41d4-a716-446655440002
Content-Type: application/json

{
  "service_ids": [1],
  "staff_id": 1,
  "start_time": "2026-01-15T10:15:00+01:00"
}
```

**Expected Response (409):**
```json
{
  "success": false,
  "error": {
    "code": "slot_conflict",
    "message": "The requested time slot is no longer available",
    "details": {
      "conflicts": [
        {
          "booking_id": 42,
          "start_time": "2026-01-15T10:00:00+01:00",
          "end_time": "2026-01-15T10:30:00+01:00"
        }
      ]
    }
  }
}
```

**Validazioni:**
- ‚úÖ Nessun record creato in `bookings` o `booking_items`
- ‚úÖ Transazione rollback completata
- ‚úÖ `FOR UPDATE` ha bloccato row durante check

---

### TEST-BOOKING-003: Idempotency key duplicata

**Setup:**
1. Crea booking con idempotency_key X (successo)
2. Riprova stessa request con idempotency_key X (entro 24h)

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "id": 42,
    ...stesso booking del primo tentativo...
  }
}
```

**Validazioni:**
- ‚úÖ Nessun nuovo booking creato
- ‚úÖ Ritorna booking esistente con idempotency_key X
- ‚úÖ HTTP status 200 (non 201)

---

### TEST-BOOKING-004: Booking servizi multipli sequenziali

**Request:**
```http
POST /v1/locations/1/bookings
Authorization: Bearer <access_token>
X-Idempotency-Key: 550e8400-e29b-41d4-a716-446655440003
Content-Type: application/json

{
  "service_ids": [1, 3],
  "staff_id": 1,
  "start_time": "2026-01-15T14:00:00+01:00"
}
```

**Expected Response (201):**
```json
{
  "success": true,
  "data": {
    "id": 43,
    "total_duration_minutes": 60,
    "total_price": 35.00,
    "items": [
      {
        "id": 102,
        "service_id": 1,
        "start_time": "2026-01-15T14:00:00+01:00",
        "end_time": "2026-01-15T14:30:00+01:00",
        "duration_minutes": 30,
        "price": 20.00
      },
      {
        "id": 103,
        "service_id": 3,
        "start_time": "2026-01-15T14:30:00+01:00",
        "end_time": "2026-01-15T15:00:00+01:00",
        "duration_minutes": 30,
        "price": 15.00
      }
    ]
  }
}
```

**Validazioni:**
- ‚úÖ 2 `booking_items` con orari consecutivi
- ‚úÖ `items[0].end_time` = `items[1].start_time`
- ‚úÖ `total_duration` = somma durate
- ‚úÖ `total_price` = somma prezzi

---

## M1.1: Booking Management

> **Nota:** Aggiornato al 27/12/2025 con formato response flat (no nested objects).

### View Bookings

#### TEST-VIEW-001: Lista bookings utente autenticato

**Request:**
```http
GET /v1/me/bookings
Authorization: Bearer <access_token>
```

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "upcoming": [
      {
        "booking_id": 123,
        "status": "confirmed",
        "start_time": "2026-01-20T14:00:00+01:00",
        "end_time": "2026-01-20T15:00:00+01:00",
        "service_names": ["Taglio", "Piega"],
        "staff_name": "Anna B.",
        "total_price": 35.00,
        "notes": null,
        "location_id": 1,
        "location_name": "Sede Centro",
        "location_address": "Via Roma 123",
        "location_city": "Milano",
        "business_id": 1,
        "business_name": "Salone Bella Vita",
        "can_modify": true,
        "can_modify_until": "2026-01-19T14:00:00+01:00",
        "created_at": "2025-12-20T10:00:00+01:00"
      }
    ],
    "past": [
      {
        "booking_id": 100,
        "status": "completed",
        "start_time": "2025-12-15T10:00:00+01:00",
        "end_time": "2025-12-15T11:00:00+01:00",
        "service_names": ["Taglio Uomo"],
        "staff_name": "Luigi M.",
        "total_price": 25.00,
        "notes": null,
        "location_id": 1,
        "location_name": "Sede Centro",
        "location_address": "Via Roma 123",
        "location_city": "Milano",
        "business_id": 1,
        "business_name": "Salone Bella Vita",
        "can_modify": false,
        "can_modify_until": null,
        "created_at": "2025-12-10T09:00:00+01:00"
      }
    ]
  }
}
```

**Validazioni:**
- ‚úÖ `upcoming` ordinati per `start_time ASC`
- ‚úÖ `past` ordinati per `start_time DESC`
- ‚úÖ `can_modify = true` solo se `now < can_modify_until`
- ‚úÖ `can_modify_until = start_time - cancellation_hours`
- ‚úÖ `service_names` √® array (aggregato da booking_items)
- ‚úÖ `total_price` √® somma prezzi di tutti booking_items
- ‚úÖ Formato flat (no oggetti nested location/business)

---

#### TEST-VIEW-002: Can_modify calculation con location override

**Setup:**
- Location 1: `cancellation_hours = 24`
- Location 2: `cancellation_hours = 48`
- Booking A: location_id=1, start_time = now + 30 ore
- Booking B: location_id=2, start_time = now + 30 ore

**Expected:**
- Booking A: `can_modify = true` (30h > 24h)
- Booking B: `can_modify = false` (30h < 48h)

---

### Cancel Booking

#### TEST-CANCEL-001: Cancellazione entro deadline

**Setup:**
- Location cancellation_hours = 24
- Booking start_time = now + 48 ore
- Now = 2025-12-27T10:00:00

**Request:**
```http
DELETE /v1/locations/1/bookings/123
Authorization: Bearer <access_token>
```

**Expected Response (204):**
```
(empty body)
```

**Validazioni:**
- ‚úÖ `bookings.status` ‚Üí 'cancelled'
- ‚úÖ `booking_items` non eliminati (audit trail)
- ‚úÖ Slot liberato (disponibile in availability check)

---

#### TEST-CANCEL-002: Cancellazione oltre deadline

**Setup:**
- Location cancellation_hours = 24
- Booking start_time = now + 20 ore (entro deadline)

**Request:**
```http
DELETE /v1/locations/1/bookings/123
Authorization: Bearer <access_token>
```

**Expected Response (400):**
```json
{
  "success": false,
  "error": {
    "code": "validation_error",
    "message": "Cannot cancel booking within 24 hours of appointment start time",
    "details": {
      "cancellation_deadline": "2025-12-28T14:00:00+01:00"
    }
  }
}
```

**Validazioni:**
- ‚úÖ Booking non modificato (status rimane 'confirmed')
- ‚úÖ Messaggio include deadline precisa

---

#### TEST-CANCEL-003: Cancellazione booking di altro utente

**Setup:**
- Booking owner: user_id=1
- Request from: user_id=2

**Request:**
```http
DELETE /v1/locations/1/bookings/123
Authorization: Bearer <access_token_user_2>
```

**Expected Response (403):**
```json
{
  "success": false,
  "error": {
    "code": "unauthorized",
    "message": "You do not have permission to cancel this booking"
  }
}
```

---

### Reschedule Booking

#### TEST-RESCHEDULE-001: Reschedule con slot disponibile

**Setup:**
- Booking originale: staff_id=1, 2026-01-20 14:00-15:00 (servizi 1+3)
- Nuovo slot: 2026-01-22 10:00-11:00 (libero)
- Cancellation deadline: non violata

**Request:**
```http
PUT /v1/locations/1/bookings/123
Authorization: Bearer <access_token>
Content-Type: application/json

{
  "start_time": "2026-01-22T10:00:00+01:00",
  "notes": "Riprogrammazione per impegno"
}
```

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "id": 123,
    "status": "confirmed",
    "notes": "Riprogrammazione per impegno",
    "items": [
      {
        "id": 456,
        "service_id": 1,
        "start_time": "2026-01-22T10:00:00+01:00",
        "end_time": "2026-01-22T10:30:00+01:00"
      },
      {
        "id": 457,
        "service_id": 3,
        "start_time": "2026-01-22T10:30:00+01:00",
        "end_time": "2026-01-22T11:00:00+01:00"
      }
    ]
  }
}
```

**Validazioni:**
- ‚úÖ Tutti i `booking_items` aggiornati con nuovo orario
- ‚úÖ Offset temporale preservato (servizio 3 inizia quando finisce servizio 1)
- ‚úÖ Durate invariate
- ‚úÖ Staff e servizi invariati
- ‚úÖ Vecchio slot liberato, nuovo slot occupato

---

#### TEST-RESCHEDULE-002: Reschedule con slot occupato (availability check)

**Setup:**
1. Booking A: staff_id=1, 2026-01-22 10:00-10:30 (esistente)
2. Booking B: staff_id=1, 2026-01-20 14:00-14:30 (da spostare)
3. Tentativo reschedule B ‚Üí 2026-01-22 10:00-10:30 (conflitto con A)

**Request:**
```http
PUT /v1/locations/1/bookings/124
Authorization: Bearer <access_token>
Content-Type: application/json

{
  "start_time": "2026-01-22T10:00:00+01:00"
}
```

**Expected Response (409):**
```json
{
  "success": false,
  "error": {
    "code": "slot_conflict",
    "message": "The requested time slot is no longer available for this staff member",
    "details": {
      "conflicts": [
        {
          "booking_id": 123,
          "start_time": "2026-01-22T10:00:00+01:00",
          "end_time": "2026-01-22T10:30:00+01:00"
        }
      ]
    }
  }
}
```

**Validazioni:**
- ‚úÖ Booking B non modificato (orario originale preservato)
- ‚úÖ Transazione rollback completata
- ‚úÖ `FOR UPDATE` ha bloccato row di Booking A durante check

---

#### TEST-RESCHEDULE-003: Reschedule multi-service con offset complesso

**Setup:**
- Booking originale:
  - Item 1: service_id=1, 2026-01-20 14:00-14:30 (30 min)
  - Item 2: service_id=3, 2026-01-20 14:30-15:00 (30 min)
  - Item 3: service_id=2, 2026-01-20 15:00-15:45 (45 min)
- Nuovo start: 2026-01-22 09:00:00

**Expected:**
- Item 1: 2026-01-22 09:00-09:30 (offset: +43h)
- Item 2: 2026-01-22 09:30-10:00 (offset: +43h)
- Item 3: 2026-01-22 10:00-10:45 (offset: +43h)

**Validazioni:**
- ‚úÖ Offset calcolato correttamente: `new_start - old_start`
- ‚úÖ Tutti gli item spostati con stesso offset
- ‚úÖ Intervalli relativi preservati (no gap, no overlap)

---

#### TEST-RESCHEDULE-004: Reschedule oltre cancellation deadline

**Setup:**
- Location cancellation_hours = 24
- Booking start_time = now + 20 ore
- Tentativo reschedule a now + 48 ore

**Request:**
```http
PUT /v1/locations/1/bookings/123
Authorization: Bearer <access_token>
Content-Type: application/json

{
  "start_time": "2025-12-29T14:00:00+01:00"
}
```

**Expected Response (400):**
```json
{
  "success": false,
  "error": {
    "code": "validation_error",
    "message": "Cannot modify booking within 24 hours of appointment start time",
    "details": {
      "cancellation_deadline": "2025-12-28T14:00:00+01:00"
    }
  }
}
```

**Validazioni:**
- ‚úÖ Policy validata PRIMA dell'availability check
- ‚úÖ Booking non modificato

---

#### TEST-RESCHEDULE-005: Reschedule dello stesso booking a slot parzialmente sovrapposto

**Setup:**
- Booking originale: 2026-01-20 14:00-15:00
- Reschedule a: 2026-01-20 14:30-15:30 (overlap 30 min)
- Nessun altro booking per questo staff

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "id": 123,
    "items": [
      {
        "start_time": "2026-01-20T14:30:00+01:00",
        "end_time": "2026-01-20T15:30:00+01:00"
      }
    ]
  }
}
```

**Validazioni:**
- ‚úÖ `checkConflicts()` riceve `excludeBookingId=123`
- ‚úÖ Overlap con se stesso ignorato
- ‚úÖ Update completato con successo

---

#### TEST-RESCHEDULE-006: Update status/notes (no reschedule)

**Request:**
```http
PUT /v1/locations/1/bookings/123
Authorization: Bearer <access_token>
Content-Type: application/json

{
  "status": "confirmed",
  "notes": "Cliente confermato via telefono"
}
```

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "id": 123,
    "status": "confirmed",
    "notes": "Cliente confermato via telefono",
    "items": [
      {
        "start_time": "2026-01-20T14:00:00+01:00",
        ...orario invariato...
      }
    ]
  }
}
```

**Validazioni:**
- ‚úÖ Solo `status` e `notes` aggiornati
- ‚úÖ `booking_items` invariati
- ‚úÖ No availability check eseguito
- ‚úÖ Cancellation policy NON validata (solo per reschedule/cancel)

---

## Edge Cases & Error Handling

### TEST-EDGE-001: Booking con service_variant non disponibile online

**Setup:**
- Service 1 ha variant per location 1 con `is_bookable_online=0`

**Request:**
```http
POST /v1/locations/1/bookings
Authorization: Bearer <access_token>
X-Idempotency-Key: 550e8400-e29b-41d4-a716-446655440004

{
  "service_ids": [1],
  "staff_id": 1,
  "start_time": "2026-01-15T10:00:00+01:00"
}
```

**Expected Response (400):**
```json
{
  "success": false,
  "error": {
    "code": "validation_error",
    "message": "Service 1 is not available for online booking at this location"
  }
}
```

---

### TEST-EDGE-002: Reschedule con start_time formato invalido

**Request:**
```http
PUT /v1/locations/1/bookings/123
Authorization: Bearer <access_token>

{
  "start_time": "2026-01-22 10:00:00"
}
```

**Expected Response (400):**
```json
{
  "success": false,
  "error": {
    "code": "validation_error",
    "message": "Invalid start_time format. Use ISO8601."
  }
}
```

---

### TEST-EDGE-003: Booking con JWT scaduto

**Request:**
```http
POST /v1/locations/1/bookings
Authorization: Bearer <expired_token>
X-Idempotency-Key: 550e8400-e29b-41d4-a716-446655440005

{
  "service_ids": [1],
  "staff_id": 1,
  "start_time": "2026-01-15T10:00:00+01:00"
}
```

**Expected Response (401):**
```json
{
  "success": false,
  "error": {
    "code": "unauthorized",
    "message": "Access token expired"
  }
}
```

---

### TEST-EDGE-004: Reschedule booking gi√† cancellato

**Setup:**
- Booking status = 'cancelled'

**Request:**
```http
PUT /v1/locations/1/bookings/123
Authorization: Bearer <access_token>

{
  "start_time": "2026-01-22T10:00:00+01:00"
}
```

**Expected Response (400):**
```json
{
  "success": false,
  "error": {
    "code": "validation_error",
    "message": "Cannot reschedule a cancelled booking"
  }
}
```

---

### TEST-EDGE-005: Location ID mismatch tra path e booking

**Setup:**
- Booking originale: location_id=1
- Request path: `/v1/locations/2/bookings/123`

**Request:**
```http
PUT /v1/locations/2/bookings/123
Authorization: Bearer <access_token>

{
  "notes": "Test"
}
```

**Expected Response (404):**
```json
{
  "success": false,
  "error": {
    "code": "not_found",
    "message": "Booking not found"
  }
}
```

**Validazioni:**
- ‚úÖ Query filtrata per `location_id=2 AND booking_id=123` ‚Üí nessun match
- ‚úÖ Previene accesso cross-location

---

## Performance & Concurrency

### TEST-PERF-001: Race condition su reschedule simultanei

**Setup:**
1. Booking A: staff_id=1, 2026-01-20 14:00-14:30
2. Slot target: 2026-01-22 10:00-10:30 (libero)

**Scenario:**
- Thread 1: Reschedule Booking A ‚Üí target slot
- Thread 2: Reschedule Booking A ‚Üí stesso target slot
- Esecuzione simultanea (delay < 100ms)

**Expected Outcome:**
- 1 request ‚Üí **200 OK** (prima a completare transazione)
- 1 request ‚Üí **409 Conflict** (rileva booking gi√† spostato)

**Validazioni:**
- ‚úÖ Una sola transazione committata
- ‚úÖ Nessun double-booking
- ‚úÖ `FOR UPDATE` ha serializzato accesso

---

### TEST-PERF-002: Race condition su booking + reschedule

**Setup:**
- Slot target: 2026-01-22 10:00-10:30 (libero)

**Scenario:**
- Thread 1: `POST /bookings` ‚Üí nuovo booking su target slot
- Thread 2: `PUT /bookings/123` ‚Üí reschedule esistente su target slot
- Esecuzione simultanea

**Expected Outcome:**
- 1 request ‚Üí **201 Created** / **200 OK**
- 1 request ‚Üí **409 Conflict**

**Validazioni:**
- ‚úÖ Una sola transazione occupa lo slot
- ‚úÖ Lock acquisito da `checkConflicts()` FOR UPDATE

---

### TEST-PERF-003: Reschedule multi-item con 10+ servizi

**Setup:**
- Booking con 10 servizi consecutivi (totale 5 ore)
- Nuovo slot: disponibile per tutti i 10 servizi

**Expected:**
- Response time < 1s
- Tutti i 10 `booking_items` aggiornati con offset corretto
- Una sola query UPDATE per tutti gli items (batch)

**Validazioni:**
- ‚úÖ No N+1 query problem
- ‚úÖ Transazione unica

---

### TEST-PERF-004: Availability check con 50+ booking esistenti

**Setup:**
- Staff 1 ha 50 booking su 2026-01-22
- Request availability per 2026-01-22

**Expected:**
- Response time < 500ms
- Solo slot liberi ritornati
- Query con indici su `(staff_id, location_id, start_time, end_time)`

---

## Automation Scripts

### Script: Run All Critical Tests

```bash
#!/bin/bash
# test_critical.sh

BASE_URL="https://api.agenda-test.local/v1"

echo "üß™ Running Critical Test Suite..."

# Login
ACCESS_TOKEN=$(curl -s -X POST "$BASE_URL/auth/login" \
  -H "Content-Type: application/json" \
  -d '{"email":"mario.rossi@test.com","password":"TestPass123!"}' \
  | jq -r '.data.access_token')

echo "‚úÖ Authentication OK"

# TEST-RESCHEDULE-001: Reschedule con slot disponibile
BOOKING_ID=$(curl -s -X POST "$BASE_URL/locations/1/bookings" \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -H "X-Idempotency-Key: $(uuidgen)" \
  -H "Content-Type: application/json" \
  -d '{"service_ids":[1],"staff_id":1,"start_time":"2026-01-20T14:00:00+01:00"}' \
  | jq -r '.data.id')

RESCHEDULE_RESPONSE=$(curl -s -X PUT "$BASE_URL/locations/1/bookings/$BOOKING_ID" \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"start_time":"2026-01-22T10:00:00+01:00"}')

RESCHEDULE_STATUS=$(echo $RESCHEDULE_RESPONSE | jq -r '.success')
if [ "$RESCHEDULE_STATUS" = "true" ]; then
  echo "‚úÖ TEST-RESCHEDULE-001 PASSED"
else
  echo "‚ùå TEST-RESCHEDULE-001 FAILED"
  echo $RESCHEDULE_RESPONSE | jq
fi

# TEST-RESCHEDULE-002: Slot occupato
CONFLICT_RESPONSE=$(curl -s -X PUT "$BASE_URL/locations/1/bookings/$BOOKING_ID" \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"start_time":"2026-01-22T10:00:00+01:00"}')

ERROR_CODE=$(echo $CONFLICT_RESPONSE | jq -r '.error.code')
if [ "$ERROR_CODE" = "slot_conflict" ]; then
  echo "‚úÖ TEST-RESCHEDULE-002 PASSED"
else
  echo "‚ùå TEST-RESCHEDULE-002 FAILED (expected slot_conflict, got $ERROR_CODE)"
fi

echo ""
echo "üìä Test Suite Complete"
```

### Script: Race Condition Simulator

```bash
#!/bin/bash
# test_race_condition.sh

BASE_URL="https://api.agenda-test.local/v1"
ACCESS_TOKEN="<your_token>"
BOOKING_ID=123

# Esegui due reschedule simultanei
(
  curl -s -X PUT "$BASE_URL/locations/1/bookings/$BOOKING_ID" \
    -H "Authorization: Bearer $ACCESS_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"start_time":"2026-01-22T10:00:00+01:00"}' &
  
  curl -s -X PUT "$BASE_URL/locations/1/bookings/$BOOKING_ID" \
    -H "Authorization: Bearer $ACCESS_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"start_time":"2026-01-22T10:00:00+01:00"}' &
  
  wait
) | jq -s 'map(.success) | group_by(.) | map({key: .[0], count: length})'

# Expected output: [{"key":true,"count":1}, {"key":false,"count":1}]
```

---

## Future Test Scenarios

### M10: Notifications

- **TEST-NOTIF-001**: Email conferma dopo booking creation
- **TEST-NOTIF-002**: Email notifica reschedule a cliente e staff
- **TEST-NOTIF-003**: SMS reminder 24h prima appuntamento
- **TEST-NOTIF-004**: Push notification cancellazione booking

### M4: Admin Dashboard

- **TEST-ADMIN-001**: Gestionale vede booking multi-location
- **TEST-ADMIN-002**: Report bookings per staff/periodo
- **TEST-ADMIN-003**: Modifica booking lato admin (no policy)

### M5: Reviews

- **TEST-REVIEW-001**: Cliente pu√≤ recensire solo dopo status='completed'
- **TEST-REVIEW-002**: Review visibile solo dopo approvazione admin

---

## Maintenance

### Aggiornamento Scenari

Quando aggiungi una nuova feature:
1. Crea sezione dedicata (es: `## M2: Feature Name`)
2. Numera test sequenzialmente (`TEST-FEATURE-001`)
3. Includi setup, request, expected response, validazioni
4. Aggiungi script bash per automazione se applicabile

### Test Data Reset

```bash
# Ripristina DB test a stato pulito
mysql -u root -p agenda_test < test_data/reset.sql
mysql -u root -p agenda_test < test_data/seed.sql
```

---

**Ultimo aggiornamento**: 28 dicembre 2025  
**Versione API**: v1  
**Maintainer**: Team Agenda Core

---

## M8: Unit Test Suite (PHPUnit)

### Panoramica

Test suite implementata con PHPUnit 10.5.60. Focus su logica di business pura senza dipendenze dal database.

**Risultati**: 98 test, 195 asserzioni, 100% pass

### TEST-UNIT-AUTH: Auth Use Case Tests

| Test | Descrizione |
|------|-------------|
| `testPasswordHashingAndVerification` | Bcrypt hash + verify |
| `testLoginValidationRequiresEmail` | Email obbligatoria |
| `testLoginValidationRequiresValidEmailFormat` | Formato email valido |
| `testPasswordMinimumLength` | Password ‚â• 8 caratteri |
| `testJwtGenerationAndValidation` | JWT create + validate |
| `testJwtRejectsInvalidToken` | Token malformato |
| `testJwtRejectsTamperedToken` | Token manomesso |
| `testRefreshTokenHashGeneration` | SHA-256 deterministic |
| `testRefreshTokenExpiryCheck` | Scadenza +30 giorni |
| `testRefreshTokenRevokedCheck` | Flag is_revoked |
| `testDisabledAccountCheck` | Account disabilitato |
| `testUserRoleValidation` | Ruoli validi |
| `testAuthExceptionInvalidCredentials` | Exception credentials |
| `testAuthExceptionAccountDisabled` | Exception disabled |
| `testAuthExceptionTokenExpired` | Exception expired |
| `testSessionExpiryCalculation` | TTL access/refresh |
| `testLogoutRequiresUserId` | User ID obbligatorio |

### TEST-UNIT-BOOKING: Booking Use Case Tests

| Test | Descrizione |
|------|-------------|
| `testBookingRequiresServiceIds` | service_ids obbligatorio |
| `testBookingRequiresValidStartTime` | start_time obbligatorio |
| `testBookingRejectsPastStartTime` | No date passate |
| `testBookingAcceptsFutureStartTime` | Date future OK |
| `testTotalDurationCalculation` | Somma durate servizi |
| `testEndTimeCalculation` | start + duration = end |
| `testConflictDetection` | Overlap rilevato |
| `testNoConflictForAdjacentBookings` | Adiacenti OK |
| `testNoConflictForNonOverlappingBookings` | Separati OK |
| `testConflictWhenNewBookingContainsExisting` | Nuovo contiene esistente |
| `testConflictWhenExistingContainsNew` | Esistente contiene nuovo |
| `testIdempotencyKeyFormat` | UUID v4 valido |
| `testIdempotencyKeyRejectsInvalidFormat` | UUID invalido |
| `testTotalPriceCalculation` | Somma prezzi |
| `testValidBookingStatuses` | pending/confirmed/... |
| `testDefaultBookingStatusIsPending` | Default = pending |
| `testSequentialServiceSlotCalculation` | Multi-service sequential |

### TEST-UNIT-AVAILABILITY: Availability Tests

| Test | Descrizione |
|------|-------------|
| `testWorkingHoursParsingAM` | Parse orari apertura |
| `testWorkingHoursSpansDayCorrectly` | Calcolo ore totali |
| `testGenerateSlots30MinInterval` | Slot 30 min |
| `testGenerateSlots15MinInterval` | Slot 15 min |
| `testFilterOutBookedSlots` | Escludi occupati |
| `testFilterSlotsForServiceDuration` | Servizio > slot |
| `testStaffBreakTimeExcludedFromAvailability` | Pausa pranzo |
| `testStaffAvailableOutsideBreak` | Fuori pausa OK |
| `testAnyStaffAvailableReturnsSlot` | Multi-staff OR |
| `testNoStaffAvailableReturnsUnavailable` | Tutti occupati |
| `testAvailabilityForDateRange` | Range date |
| `testExcludeClosedDays` | Domenica chiuso |
| `testBufferTimeBetweenAppointments` | Buffer 15 min |
| `testNoBufferWhenNotConfigured` | Buffer 0 |
| `testSlotConversionBetweenTimezones` | UTC ‚Üî Rome |
| `testSlotsGeneratedInBusinessTimezone` | Timezone business |

### Esecuzione Test

```bash
# Tutti i test con output dettagliato
cd agenda_core
./vendor/bin/phpunit --testdox

# Solo test Auth
./vendor/bin/phpunit --filter AuthUseCaseTest

# Solo test Booking
./vendor/bin/phpunit --filter BookingUseCaseTest

# Solo test Availability
./vendor/bin/phpunit --filter AvailabilityTest

# Coverage report (richiede xdebug)
./vendor/bin/phpunit --coverage-html coverage/
```

### File Test

```
tests/
‚îú‚îÄ‚îÄ AuthTest.php           # 6 test - JWT base, password
‚îú‚îÄ‚îÄ AuthUseCaseTest.php    # 17 test - Logica auth completa
‚îú‚îÄ‚îÄ AvailabilityTest.php   # 16 test - Slot e disponibilit√†
‚îú‚îÄ‚îÄ BookingTest.php        # 7 test - Overlap e date
‚îú‚îÄ‚îÄ BookingUseCaseTest.php # 18 test - Logica booking
‚îú‚îÄ‚îÄ ExceptionsTest.php     # 7 test - Domain exceptions
‚îú‚îÄ‚îÄ IdempotencyTest.php    # 5 test - UUID validation
‚îú‚îÄ‚îÄ PasswordHasherTest.php # 4 test - Bcrypt
‚îú‚îÄ‚îÄ RequestTest.php        # 5 test - HTTP request
‚îú‚îÄ‚îÄ ResponseTest.php       # 7 test - HTTP response
‚îî‚îÄ‚îÄ RouterTest.php         # 7 test - Routing
```

=======================================
----- FILE: .env.example -----

# Environment
APP_ENV=development
APP_DEBUG=true

# Base path prefix for URL routing (es. /agenda_core/public per MAMP)
# Lasciare vuoto se non necessario
APP_BASE_PATH=

# Database
DB_HOST=localhost
DB_PORT=3306
DB_DATABASE=agenda_core
DB_USERNAME=root
DB_PASSWORD=

# JWT
JWT_SECRET=your-secret-key-min-32-chars-here
JWT_ACCESS_TTL=900
JWT_REFRESH_TTL=864000

# CORS
CORS_ORIGIN=http://localhost:3000

# Timezone
APP_TIMEZONE=Europe/Rome

# ========================================
# EMAIL NOTIFICATIONS
# ========================================

# Provider: smtp | brevo | mailgun
MAIL_PROVIDER=smtp

# Default sender (used by all providers)
MAIL_FROM_ADDRESS=noreply@example.com
MAIL_FROM_NAME="Agenda Platform"

# SMTP Configuration (for MAIL_PROVIDER=smtp)
# Works with SiteGround, Gmail, or any SMTP server
SMTP_HOST=smtp.example.com
SMTP_PORT=587
SMTP_USERNAME=your-smtp-username
SMTP_PASSWORD=your-smtp-password
# Encryption: tls | ssl | none
SMTP_ENCRYPTION=tls

# Brevo Configuration (for MAIL_PROVIDER=brevo)
# Free tier: 300 emails/day
# Get API key from: https://app.brevo.com/settings/keys/api
BREVO_API_KEY=your-brevo-api-key
# Optional: Brevo SMTP fallback
BREVO_SMTP_KEY=your-brevo-smtp-key

# Mailgun Configuration (for MAIL_PROVIDER=mailgun)
# Get credentials from: https://app.mailgun.com/mg/dashboard
MAILGUN_API_KEY=your-mailgun-api-key
MAILGUN_DOMAIN=mg.example.com
# Region: eu | us (default: eu)
MAILGUN_REGION=eu

# ========================================
# FRONTEND URLs
# ========================================

# URL frontend prenotazione (per clienti)
FRONTEND_URL=https://prenota.romeolab.it

# URL backend/gestionale (per admin business)
BACKEND_URL=https://gestionale.romeolab.it

# Test mode: redirect all notification emails to nome.cognome@romeolab.it
NOTIFICATION_TEST_MODE=false

=======================================
----- FILE: migrations/0021_business_suspension.sql -----

-- ============================================================================
-- MIGRATION 0021: Business Suspension Support
-- Date: 2026-01-03
-- Description: Add is_suspended and suspension_message fields to businesses
-- ============================================================================

-- Add suspension fields to businesses table
ALTER TABLE businesses 
ADD COLUMN is_suspended TINYINT(1) NOT NULL DEFAULT 0 
    COMMENT 'Whether the business is suspended (visible but not operational)'
    AFTER is_active;

ALTER TABLE businesses 
ADD COLUMN suspension_message TEXT DEFAULT NULL 
    COMMENT 'Message shown to operators and customers when business is suspended'
    AFTER is_suspended;

-- Add index for efficient querying
CREATE INDEX idx_businesses_suspended ON businesses(is_suspended);

----- FILE: migrations/0021_rename_customer_name_to_client_name.sql -----

-- Migration: Rinomina customer_name in client_name per coerenza con client_id
-- Data: 2026-01-04

-- Rinomina colonna nella tabella bookings
ALTER TABLE bookings CHANGE COLUMN customer_name client_name VARCHAR(200) NULL;

----- FILE: migrations/0022_staff_planning.sql -----

-- =============================================================================
-- Migration: 0022_staff_planning.sql
-- Descrizione: Crea tabelle per staff planning settimanale/bisettimanale
-- Data: 2026-01-04
-- =============================================================================

-- -----------------------------------------------------------------------------
-- Tabella: staff_planning
-- Rappresenta una pianificazione settimanale o bisettimanale di uno staff.
-- Intervallo di validit√† [valid_from, valid_to] chiuso-chiuso.
-- valid_to NULL significa "senza scadenza".
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS staff_planning (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    staff_id INT UNSIGNED NOT NULL,
    type ENUM('weekly', 'biweekly') NOT NULL DEFAULT 'weekly',
    valid_from DATE NOT NULL,
    valid_to DATE NULL DEFAULT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
    
    PRIMARY KEY (id),
    
    -- FK verso staff
    CONSTRAINT fk_staff_planning_staff
        FOREIGN KEY (staff_id) REFERENCES staff(id)
        ON DELETE CASCADE
        ON UPDATE CASCADE,
    
    -- Indice per ricerche per staff
    INDEX idx_staff_planning_staff_id (staff_id),
    
    -- Indice per ricerche di validit√† (query: valid_from <= D AND (valid_to IS NULL OR valid_to >= D))
    INDEX idx_staff_planning_validity (staff_id, valid_from, valid_to),
    
    -- Indice per valid_from (ordinamento cronologico)
    INDEX idx_staff_planning_valid_from (valid_from)
    
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;


-- -----------------------------------------------------------------------------
-- Tabella: staff_planning_week_template
-- Template settimanale con slot per ogni giorno.
-- Per planning weekly: solo record con week_label='A'.
-- Per planning biweekly: record con week_label='A' e 'B'.
-- day_of_week: 1=Monday, 7=Sunday (ISO 8601).
-- slots: JSON array di interi (indici slot, es. [36,37,38,39] = 09:00-10:00 con slot 15min).
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS staff_planning_week_template (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    staff_planning_id INT UNSIGNED NOT NULL,
    week_label ENUM('A', 'B') NOT NULL DEFAULT 'A',
    day_of_week TINYINT UNSIGNED NOT NULL,
    slots JSON NOT NULL,
    
    PRIMARY KEY (id),
    
    -- FK verso staff_planning
    CONSTRAINT fk_staff_planning_week_template_planning
        FOREIGN KEY (staff_planning_id) REFERENCES staff_planning(id)
        ON DELETE CASCADE
        ON UPDATE CASCADE,
    
    -- Unicit√†: un solo record per (planning, settimana, giorno)
    UNIQUE KEY uk_planning_week_day (staff_planning_id, week_label, day_of_week),
    
    -- Indice per ricerche per planning
    INDEX idx_week_template_planning_id (staff_planning_id),
    
    -- Vincolo: day_of_week deve essere 1-7
    CONSTRAINT chk_planning_template_day_of_week CHECK (day_of_week >= 1 AND day_of_week <= 7)
    
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

----- FILE: migrations/FULL_DATABASE_SCHEMA.sql -----

-- ============================================================================
-- FULL DATABASE SCHEMA - Agenda Platform
-- Generated: 2025-12-28
-- Description: Schema completo per deploy produzione (unico file)
-- Database: MySQL 8.0+ / MariaDB 10.5+
-- 
-- USAGE:
-- 1. Create empty database in phpMyAdmin
-- 2. Import this file
-- 3. (Optional) Run seed_data.sql for demo data
-- ============================================================================

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ============================================================================
-- SECTION 1: CORE TABLES (from 0001_init.sql)
-- ============================================================================

-- ----------------------------------------------------------------------------
-- businesses: Tenant principale
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS businesses (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(100) NOT NULL,
    email VARCHAR(255) DEFAULT NULL,
    phone VARCHAR(50) DEFAULT NULL,
    timezone VARCHAR(50) NOT NULL DEFAULT 'Europe/Rome',
    currency VARCHAR(3) NOT NULL DEFAULT 'EUR',
    cancellation_hours INT UNSIGNED NOT NULL DEFAULT 24 
        COMMENT 'Default hours before appointment when cancellation/modification is allowed',
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY uk_businesses_slug (slug),
    KEY idx_businesses_active (is_active)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- locations: Sedi fisiche di un business
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS locations (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    name VARCHAR(255) NOT NULL,
    address VARCHAR(500) DEFAULT NULL,
    city VARCHAR(100) DEFAULT NULL,
    postal_code VARCHAR(20) DEFAULT NULL COMMENT 'Postal/ZIP code',
    region VARCHAR(100) DEFAULT NULL,
    country VARCHAR(100) NOT NULL DEFAULT 'IT',
    phone VARCHAR(50) DEFAULT NULL,
    email VARCHAR(255) DEFAULT NULL,
    latitude DECIMAL(10,8) DEFAULT NULL,
    longitude DECIMAL(11,8) DEFAULT NULL,
    timezone VARCHAR(50) DEFAULT 'Europe/Rome' COMMENT 'Location timezone',
    currency VARCHAR(3) DEFAULT NULL COMMENT 'Override business currency',
    cancellation_hours INT UNSIGNED DEFAULT NULL 
        COMMENT 'Override business cancellation policy. NULL = use business default',
    is_default TINYINT(1) NOT NULL DEFAULT 0,
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_locations_business (business_id),
    KEY idx_locations_business_default (business_id, is_default),
    KEY idx_locations_postal_code (postal_code),
    KEY idx_locations_cancellation (business_id, cancellation_hours),
    CONSTRAINT fk_locations_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- location_schedules: Define working hours for each location by day of week
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS location_schedules (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    location_id INT UNSIGNED NOT NULL,
    day_of_week TINYINT UNSIGNED NOT NULL COMMENT '0=Sunday, 1=Monday, ..., 6=Saturday',
    open_time TIME NOT NULL COMMENT 'Opening time (e.g., 09:00:00)',
    close_time TIME NOT NULL COMMENT 'Closing time (e.g., 18:00:00)',
    is_closed TINYINT(1) NOT NULL DEFAULT 0 COMMENT 'Day is closed for business',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY uk_location_schedules (location_id, day_of_week),
    CONSTRAINT fk_location_schedules_location FOREIGN KEY (location_id) 
        REFERENCES locations(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT chk_day_of_week CHECK (day_of_week BETWEEN 0 AND 6),
    CONSTRAINT chk_times CHECK (open_time < close_time OR is_closed = 1)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
COMMENT='Working hours schedule for each location';

-- ----------------------------------------------------------------------------
-- service_categories: Categorie di servizi
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS service_categories (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT DEFAULT NULL,
    sort_order INT NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_service_categories_business (business_id),
    KEY idx_service_categories_sort (business_id, sort_order),
    CONSTRAINT fk_service_categories_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- services: Servizi offerti
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS services (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    category_id INT UNSIGNED NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT DEFAULT NULL,
    sort_order INT NOT NULL DEFAULT 0,
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_services_business (business_id),
    KEY idx_services_category (category_id),
    KEY idx_services_sort (business_id, category_id, sort_order),
    CONSTRAINT fk_services_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_services_category FOREIGN KEY (category_id) 
        REFERENCES service_categories(id) ON DELETE RESTRICT ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- service_variants: Varianti per location (durata, prezzo, disponibilit√†)
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS service_variants (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    service_id INT UNSIGNED NOT NULL,
    location_id INT UNSIGNED NOT NULL,
    duration_minutes INT UNSIGNED NOT NULL,
    processing_time INT UNSIGNED DEFAULT NULL COMMENT 'Minuti post-lavorazione',
    blocked_time INT UNSIGNED DEFAULT NULL COMMENT 'Minuti bloccati',
    price DECIMAL(10,2) NOT NULL DEFAULT 0.00,
    currency VARCHAR(3) DEFAULT NULL COMMENT 'Override location currency',
    color_hex VARCHAR(7) DEFAULT NULL COMMENT 'Es. #FF5733',
    is_bookable_online TINYINT(1) NOT NULL DEFAULT 1,
    is_free TINYINT(1) NOT NULL DEFAULT 0,
    is_price_starting_from TINYINT(1) NOT NULL DEFAULT 0 COMMENT 'Mostra "da ‚Ç¨X"',
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY uk_service_variants_service_location (service_id, location_id),
    KEY idx_service_variants_location (location_id),
    KEY idx_service_variants_bookable (location_id, is_bookable_online, is_active),
    CONSTRAINT fk_service_variants_service FOREIGN KEY (service_id) 
        REFERENCES services(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_service_variants_location FOREIGN KEY (location_id) 
        REFERENCES locations(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- staff: Operatori/dipendenti
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS staff (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    name VARCHAR(100) NOT NULL,
    surname VARCHAR(100) NOT NULL DEFAULT '',
    color_hex VARCHAR(7) NOT NULL DEFAULT '#FFD700',
    avatar_url VARCHAR(500) DEFAULT NULL,
    sort_order INT NOT NULL DEFAULT 0,
    is_default TINYINT(1) NOT NULL DEFAULT 0,
    is_bookable_online TINYINT(1) NOT NULL DEFAULT 1,
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_staff_business (business_id),
    KEY idx_staff_sort (business_id, sort_order),
    KEY idx_staff_bookable (business_id, is_bookable_online, is_active),
    CONSTRAINT fk_staff_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- staff_locations: Relazione N:M staff <-> locations
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS staff_locations (
    staff_id INT UNSIGNED NOT NULL,
    location_id INT UNSIGNED NOT NULL,
    PRIMARY KEY (staff_id, location_id),
    KEY idx_staff_locations_location (location_id),
    CONSTRAINT fk_staff_locations_staff FOREIGN KEY (staff_id) 
        REFERENCES staff(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_staff_locations_location FOREIGN KEY (location_id) 
        REFERENCES locations(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- staff_services: Define which services each staff member can perform
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS staff_services (
    staff_id INT UNSIGNED NOT NULL,
    service_id INT UNSIGNED NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (staff_id, service_id),
    KEY idx_staff_services_service (service_id),
    CONSTRAINT fk_staff_services_staff FOREIGN KEY (staff_id) 
        REFERENCES staff(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_staff_services_service FOREIGN KEY (service_id) 
        REFERENCES services(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
COMMENT='Services that each staff member is qualified to perform';

-- ----------------------------------------------------------------------------
-- staff_schedules: Define working hours for each staff member by day of week
-- Supports multiple time ranges per day (e.g., morning + afternoon shift)
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS staff_schedules (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    staff_id INT UNSIGNED NOT NULL,
    day_of_week TINYINT UNSIGNED NOT NULL COMMENT '1=Monday, 2=Tuesday, ..., 7=Sunday (ISO 8601)',
    start_time TIME NOT NULL COMMENT 'Shift start time (e.g., 09:00:00)',
    end_time TIME NOT NULL COMMENT 'Shift end time (e.g., 13:00:00)',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_staff_schedules_staff (staff_id),
    KEY idx_staff_schedules_day (staff_id, day_of_week),
    CONSTRAINT fk_staff_schedules_staff FOREIGN KEY (staff_id) 
        REFERENCES staff(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT chk_staff_day_of_week CHECK (day_of_week BETWEEN 1 AND 7),
    CONSTRAINT chk_staff_times CHECK (start_time < end_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
COMMENT='Working hours schedule for each staff member. Multiple rows per day allowed for split shifts.';

-- ----------------------------------------------------------------------------
-- clients: Clienti gestiti dal business (anagrafica gestionale)
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS clients (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    user_id INT UNSIGNED DEFAULT NULL COMMENT 'Link a user se registrato online',
    first_name VARCHAR(100) DEFAULT NULL,
    last_name VARCHAR(100) DEFAULT NULL,
    email VARCHAR(255) DEFAULT NULL,
    phone VARCHAR(50) DEFAULT NULL,
    gender VARCHAR(20) DEFAULT NULL,
    birth_date DATE DEFAULT NULL,
    city VARCHAR(100) DEFAULT NULL,
    notes TEXT DEFAULT NULL,
    loyalty_points INT NOT NULL DEFAULT 0,
    last_visit TIMESTAMP NULL DEFAULT NULL,
    is_archived TINYINT(1) NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_clients_business (business_id),
    KEY idx_clients_business_email (business_id, email),
    KEY idx_clients_business_phone (business_id, phone),
    KEY idx_clients_business_archived (business_id, is_archived),
    KEY idx_clients_user (user_id),
    CONSTRAINT fk_clients_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- resources: Risorse fisiche (cabine, attrezzature) - opzionale MVP+
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS resources (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    location_id INT UNSIGNED NOT NULL,
    name VARCHAR(255) NOT NULL,
    quantity INT UNSIGNED NOT NULL DEFAULT 1,
    type VARCHAR(100) DEFAULT NULL,
    note TEXT DEFAULT NULL,
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_resources_location (location_id),
    CONSTRAINT fk_resources_location FOREIGN KEY (location_id) 
        REFERENCES locations(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ============================================================================
-- SECTION 2: AUTHENTICATION TABLES (from 0002_auth.sql)
-- ============================================================================

-- ----------------------------------------------------------------------------
-- users: Identit√† GLOBALE per autenticazione
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS users (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    email VARCHAR(255) NOT NULL,
    password_hash VARCHAR(255) NOT NULL COMMENT 'bcrypt or argon2id hash',
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    phone VARCHAR(50) DEFAULT NULL,
    email_verified_at TIMESTAMP NULL DEFAULT NULL,
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    is_superadmin TINYINT(1) NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY uk_users_email (email),
    KEY idx_users_active (is_active),
    KEY idx_users_created (created_at),
    KEY idx_users_superadmin (is_superadmin)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- auth_sessions: Sessioni con refresh token
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS auth_sessions (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    user_id INT UNSIGNED NOT NULL,
    refresh_token_hash VARCHAR(64) NOT NULL COMMENT 'SHA-256 hex of refresh token',
    user_agent VARCHAR(500) DEFAULT NULL COMMENT 'Browser/app identification',
    ip_address VARCHAR(45) DEFAULT NULL COMMENT 'IPv4 or IPv6',
    expires_at TIMESTAMP NOT NULL COMMENT 'Refresh token expiration',
    last_used_at TIMESTAMP NULL DEFAULT NULL COMMENT 'Last refresh attempt',
    revoked_at TIMESTAMP NULL DEFAULT NULL COMMENT 'Manual revocation timestamp',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY uk_auth_sessions_token (refresh_token_hash),
    KEY idx_auth_sessions_user (user_id),
    KEY idx_auth_sessions_user_active (user_id, revoked_at, expires_at),
    KEY idx_auth_sessions_expires (expires_at),
    CONSTRAINT fk_auth_sessions_user FOREIGN KEY (user_id) 
        REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- password_reset_tokens: Token per reset password
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS password_reset_token_users (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    user_id INT UNSIGNED NOT NULL,
    token_hash VARCHAR(64) NOT NULL COMMENT 'SHA-256 hex of reset token',
    expires_at TIMESTAMP NOT NULL,
    used_at TIMESTAMP NULL DEFAULT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY uk_password_reset_token (token_hash),
    KEY idx_password_reset_user (user_id),
    KEY idx_password_reset_expires (expires_at),
    CONSTRAINT fk_password_reset_user FOREIGN KEY (user_id) 
        REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- Add FK from clients to users
ALTER TABLE clients
    ADD CONSTRAINT fk_clients_user FOREIGN KEY (user_id) 
        REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE;

-- ============================================================================
-- SECTION 3: BUSINESS USERS & INVITATIONS (from 0013, 0014)
-- ============================================================================

-- ----------------------------------------------------------------------------
-- business_users: Links users to businesses with role-based access
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS business_users (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    business_id INT UNSIGNED NOT NULL,
    user_id INT UNSIGNED NOT NULL,
    role ENUM('owner', 'admin', 'manager', 'staff') NOT NULL DEFAULT 'staff',
    staff_id INT UNSIGNED NULL,
    can_manage_bookings TINYINT(1) NOT NULL DEFAULT 1,
    can_manage_clients TINYINT(1) NOT NULL DEFAULT 1,
    can_manage_services TINYINT(1) NOT NULL DEFAULT 0,
    can_manage_staff TINYINT(1) NOT NULL DEFAULT 0,
    can_view_reports TINYINT(1) NOT NULL DEFAULT 0,
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    invited_by INT UNSIGNED NULL,
    invited_at TIMESTAMP NULL,
    accepted_at TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    CONSTRAINT fk_business_users_business 
        FOREIGN KEY (business_id) REFERENCES businesses(id) ON DELETE CASCADE,
    CONSTRAINT fk_business_users_user 
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_business_users_staff 
        FOREIGN KEY (staff_id) REFERENCES staff(id) ON DELETE SET NULL,
    CONSTRAINT fk_business_users_invited_by 
        FOREIGN KEY (invited_by) REFERENCES users(id) ON DELETE SET NULL,
    CONSTRAINT uk_business_user UNIQUE (business_id, user_id),
    KEY idx_business_users_user_active (user_id, is_active),
    KEY idx_business_users_business_role (business_id, role, is_active),
    KEY idx_business_users_staff (staff_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- business_invitations: Email-based invites
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS business_invitations (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    business_id INT UNSIGNED NOT NULL,
    email VARCHAR(255) NOT NULL,
    role ENUM('admin', 'manager', 'staff') NOT NULL DEFAULT 'staff',
    token VARCHAR(64) NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    status ENUM('pending', 'accepted', 'expired', 'revoked') NOT NULL DEFAULT 'pending',
    accepted_by INT UNSIGNED NULL,
    accepted_at TIMESTAMP NULL,
    invited_by INT UNSIGNED NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    CONSTRAINT fk_invitations_business 
        FOREIGN KEY (business_id) REFERENCES businesses(id) ON DELETE CASCADE,
    CONSTRAINT fk_invitations_invited_by 
        FOREIGN KEY (invited_by) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_invitations_accepted_by 
        FOREIGN KEY (accepted_by) REFERENCES users(id) ON DELETE SET NULL,
    CONSTRAINT uk_invitation_token UNIQUE (token),
    CONSTRAINT uk_pending_invitation UNIQUE (business_id, email, status),
    KEY idx_invitations_token (token, status),
    KEY idx_invitations_business_status (business_id, status),
    KEY idx_invitations_email_status (email, status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ============================================================================
-- SECTION 4: BOOKING TABLES (from 0003_booking.sql)
-- ============================================================================

-- ----------------------------------------------------------------------------
-- bookings: Prenotazioni (contenitore di uno o pi√π servizi)
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS bookings (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    location_id INT UNSIGNED NOT NULL,
    client_id INT UNSIGNED DEFAULT NULL COMMENT 'Client from business anagrafica',
    user_id INT UNSIGNED DEFAULT NULL COMMENT 'User who booked online',
    client_name VARCHAR(255) DEFAULT NULL COMMENT 'Fallback if no client',
    notes TEXT DEFAULT NULL,
    status ENUM('pending', 'confirmed', 'completed', 'cancelled', 'no_show') 
        NOT NULL DEFAULT 'confirmed',
    source ENUM('online', 'manual', 'import') NOT NULL DEFAULT 'manual',
    idempotency_key VARCHAR(64) DEFAULT NULL COMMENT 'Client-provided UUID for idempotent POST',
    idempotency_expires_at TIMESTAMP NULL DEFAULT NULL COMMENT 'Key expiration (24h TTL)',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY uk_bookings_idempotency (business_id, idempotency_key),
    KEY idx_bookings_business_location (business_id, location_id),
    KEY idx_bookings_business_location_created (business_id, location_id, created_at),
    KEY idx_bookings_client (client_id),
    KEY idx_bookings_user (user_id),
    KEY idx_bookings_status (business_id, status),
    KEY idx_bookings_idempotency_expires (idempotency_expires_at),
    CONSTRAINT fk_bookings_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_bookings_location FOREIGN KEY (location_id) 
        REFERENCES locations(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_bookings_client FOREIGN KEY (client_id) 
        REFERENCES clients(id) ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT fk_bookings_user FOREIGN KEY (user_id) 
        REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- booking_items: Singoli appuntamenti dentro una booking
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS booking_items (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    booking_id INT UNSIGNED NOT NULL,
    location_id INT UNSIGNED NOT NULL COMMENT 'Denormalized from bookings for availability queries',
    service_id INT UNSIGNED NOT NULL,
    service_variant_id INT UNSIGNED NOT NULL,
    staff_id INT UNSIGNED NOT NULL,
    start_time TIMESTAMP NOT NULL COMMENT 'UTC',
    end_time TIMESTAMP NOT NULL COMMENT 'UTC',
    price DECIMAL(10,2) DEFAULT NULL COMMENT 'Applied price at booking time',
    extra_blocked_minutes INT UNSIGNED NOT NULL DEFAULT 0,
    extra_processing_minutes INT UNSIGNED NOT NULL DEFAULT 0,
    service_name_snapshot VARCHAR(255) DEFAULT NULL,
    client_name_snapshot VARCHAR(255) DEFAULT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_booking_items_booking (booking_id),
    KEY idx_booking_items_staff_time (staff_id, start_time, end_time),
    KEY idx_booking_items_location_time (location_id, start_time, end_time),
    KEY idx_booking_items_service (service_id),
    KEY idx_booking_items_variant (service_variant_id),
    CONSTRAINT fk_booking_items_booking FOREIGN KEY (booking_id) 
        REFERENCES bookings(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_booking_items_location FOREIGN KEY (location_id) 
        REFERENCES locations(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_booking_items_service FOREIGN KEY (service_id) 
        REFERENCES services(id) ON DELETE RESTRICT ON UPDATE CASCADE,
    CONSTRAINT fk_booking_items_variant FOREIGN KEY (service_variant_id) 
        REFERENCES service_variants(id) ON DELETE RESTRICT ON UPDATE CASCADE,
    CONSTRAINT fk_booking_items_staff FOREIGN KEY (staff_id) 
        REFERENCES staff(id) ON DELETE RESTRICT ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- time_blocks: Blocchi di non disponibilit√† (ferie, pause, riunioni)
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS time_blocks (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    location_id INT UNSIGNED NOT NULL,
    start_time TIMESTAMP NOT NULL,
    end_time TIMESTAMP NOT NULL,
    reason VARCHAR(255) DEFAULT NULL,
    is_all_day TINYINT(1) NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_time_blocks_business_location (business_id, location_id),
    KEY idx_time_blocks_time (start_time, end_time),
    CONSTRAINT fk_time_blocks_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_time_blocks_location FOREIGN KEY (location_id) 
        REFERENCES locations(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- time_block_staff: Relazione N:M time_blocks <-> staff
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS time_block_staff (
    time_block_id INT UNSIGNED NOT NULL,
    staff_id INT UNSIGNED NOT NULL,
    PRIMARY KEY (time_block_id, staff_id),
    KEY idx_time_block_staff_staff (staff_id),
    CONSTRAINT fk_time_block_staff_block FOREIGN KEY (time_block_id) 
        REFERENCES time_blocks(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_time_block_staff_staff FOREIGN KEY (staff_id) 
        REFERENCES staff(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ============================================================================
-- SECTION 5: WEBHOOKS (from 0008_webhook_infrastructure.sql)
-- ============================================================================

-- ----------------------------------------------------------------------------
-- webhook_endpoints: Registered webhook endpoints for businesses
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS webhook_endpoints (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    url VARCHAR(500) NOT NULL,
    secret VARCHAR(255) NOT NULL COMMENT 'Used to sign webhook payloads',
    events JSON NOT NULL COMMENT 'Array of event types to subscribe to',
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_webhook_endpoints_business (business_id),
    KEY idx_webhook_endpoints_active (business_id, is_active),
    CONSTRAINT fk_webhook_endpoints_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
COMMENT='Webhook endpoints registered by businesses';

-- ----------------------------------------------------------------------------
-- webhook_deliveries: Log of webhook delivery attempts
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS webhook_deliveries (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    webhook_endpoint_id INT UNSIGNED NOT NULL,
    event_type VARCHAR(100) NOT NULL COMMENT 'booking.created, booking.updated, etc.',
    payload JSON NOT NULL,
    http_status_code INT UNSIGNED NULL COMMENT 'HTTP response code',
    response_body TEXT NULL COMMENT 'Response from webhook endpoint',
    attempt_count INT UNSIGNED NOT NULL DEFAULT 0,
    next_retry_at TIMESTAMP NULL COMMENT 'When to retry if failed',
    delivered_at TIMESTAMP NULL COMMENT 'When successfully delivered',
    failed_at TIMESTAMP NULL COMMENT 'When permanently failed',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_webhook_deliveries_endpoint (webhook_endpoint_id),
    KEY idx_webhook_deliveries_retry (next_retry_at, delivered_at, failed_at),
    KEY idx_webhook_deliveries_event (event_type, created_at),
    CONSTRAINT fk_webhook_deliveries_endpoint FOREIGN KEY (webhook_endpoint_id) 
        REFERENCES webhook_endpoints(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
COMMENT='Log of webhook delivery attempts with retry tracking';

-- ============================================================================
-- SECTION 6: NOTIFICATIONS (from 0015_notification_queue.sql)
-- ============================================================================

-- ----------------------------------------------------------------------------
-- notification_queue: Queue for async notification processing
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS notification_queue (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    type ENUM('email', 'sms', 'push', 'webhook') NOT NULL DEFAULT 'email',
    channel VARCHAR(50) NOT NULL COMMENT 'booking_confirmed, booking_cancelled, reminder_24h, etc.',
    recipient_type ENUM('user', 'client', 'staff') NOT NULL,
    recipient_id INT UNSIGNED NOT NULL,
    recipient_email VARCHAR(255) NULL,
    recipient_phone VARCHAR(20) NULL,
    recipient_name VARCHAR(100) NULL,
    subject VARCHAR(255) NULL COMMENT 'Email subject',
    payload JSON NOT NULL COMMENT 'Template variables and metadata',
    priority TINYINT UNSIGNED NOT NULL DEFAULT 5 COMMENT '1=highest, 10=lowest',
    scheduled_at TIMESTAMP NULL COMMENT 'For scheduled notifications like reminders',
    status ENUM('pending', 'processing', 'sent', 'failed') NOT NULL DEFAULT 'pending',
    attempts INT UNSIGNED NOT NULL DEFAULT 0,
    max_attempts INT UNSIGNED NOT NULL DEFAULT 3,
    last_attempt_at TIMESTAMP NULL,
    sent_at TIMESTAMP NULL,
    failed_at TIMESTAMP NULL,
    error_message TEXT NULL,
    business_id INT UNSIGNED NULL COMMENT 'For business-specific templates',
    booking_id INT UNSIGNED NULL COMMENT 'Reference to related booking',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_notification_pending (status, scheduled_at, priority),
    KEY idx_notification_business (business_id, channel),
    KEY idx_notification_booking (booking_id),
    KEY idx_notification_recipient (recipient_type, recipient_id),
    CONSTRAINT fk_notification_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT fk_notification_booking FOREIGN KEY (booking_id) 
        REFERENCES bookings(id) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
COMMENT='Queue for async notification processing';

-- ----------------------------------------------------------------------------
-- notification_templates: Custom templates per business
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS notification_templates (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    channel VARCHAR(50) NOT NULL COMMENT 'booking_confirmed, booking_cancelled, etc.',
    type ENUM('email', 'sms') NOT NULL DEFAULT 'email',
    subject VARCHAR(255) NULL COMMENT 'Email subject with {{placeholders}}',
    body_html TEXT NULL COMMENT 'HTML body for email',
    body_text TEXT NULL COMMENT 'Plain text body for SMS or email fallback',
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY uk_business_channel_type (business_id, channel, type),
    CONSTRAINT fk_notification_templates_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
COMMENT='Custom notification templates per business';

-- ----------------------------------------------------------------------------
-- notification_settings: Business notification preferences
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS notification_settings (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    email_enabled TINYINT(1) NOT NULL DEFAULT 1,
    email_booking_confirmed TINYINT(1) NOT NULL DEFAULT 1,
    email_booking_cancelled TINYINT(1) NOT NULL DEFAULT 1,
    email_booking_rescheduled TINYINT(1) NOT NULL DEFAULT 1,
    email_reminder_enabled TINYINT(1) NOT NULL DEFAULT 1,
    email_reminder_hours INT UNSIGNED NOT NULL DEFAULT 24 COMMENT 'Hours before appointment',
    sms_enabled TINYINT(1) NOT NULL DEFAULT 0,
    sms_reminder_enabled TINYINT(1) NOT NULL DEFAULT 0,
    sms_reminder_hours INT UNSIGNED NOT NULL DEFAULT 24,
    sender_name VARCHAR(100) NULL COMMENT 'Custom from name',
    reply_to_email VARCHAR(255) NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY uk_business (business_id),
    CONSTRAINT fk_notification_settings_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
COMMENT='Business notification preferences';

-- ============================================================================
-- RE-ENABLE FOREIGN KEY CHECKS
-- ============================================================================
SET FOREIGN_KEY_CHECKS = 1;

-- ============================================================================
-- END OF SCHEMA
-- ============================================================================

=======================================
----- FILE: public/index.php -----

<?php

/**
 * Agenda Core - Entry Point
 * 
 * Struttura: public/ contiene index.php e .htaccess
 * Deploy SiteGround: public/ ‚Üí mappata come public_html/
 */

declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use Agenda\Http\Kernel;
use Agenda\Http\Request;

$dotenv = Dotenv\Dotenv::createImmutable(__DIR__ . '/..');
$dotenv->safeLoad();

date_default_timezone_set($_ENV['APP_TIMEZONE'] ?? 'UTC');

$allowedOrigins = array_map('trim', explode(',', $_ENV['CORS_ALLOWED_ORIGINS'] ?? '*'));
$requestOrigin = $_SERVER['HTTP_ORIGIN'] ?? '';
$corsOrigin = in_array($requestOrigin, $allowedOrigins, true) ? $requestOrigin : ($allowedOrigins[0] ?? '*');

if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    header('Access-Control-Allow-Origin: ' . $corsOrigin);
    header('Access-Control-Allow-Methods: GET, POST, PUT, PATCH, DELETE, OPTIONS');
    header('Access-Control-Allow-Headers: Content-Type, Authorization, Idempotency-Key, X-Idempotency-Key');
    header('Access-Control-Allow-Credentials: true');
    header('Access-Control-Max-Age: 86400');
    http_response_code(204);
    exit;
}

$request = Request::fromGlobals();
$kernel = new Kernel();
$response = $kernel->handle($request);
$response->send();

----- FILE: src/Http/Kernel.php -----

<?php

declare(strict_types=1);

namespace Agenda\Http;

use Agenda\Http\Controllers\AuthController;
use Agenda\Http\Controllers\AvailabilityController;
use Agenda\Http\Controllers\BookingsController;
use Agenda\Http\Controllers\BusinessController;
use Agenda\Http\Controllers\AdminBusinessesController;
use Agenda\Http\Controllers\BusinessUsersController;
use Agenda\Http\Controllers\BusinessInvitationsController;
use Agenda\Http\Controllers\ClientsController;
use Agenda\Http\Controllers\CustomerAuthController;
use Agenda\Http\Controllers\HealthController;
use Agenda\Http\Controllers\LocationsController;
use Agenda\Http\Controllers\ServicesController;
use Agenda\Http\Controllers\StaffController;
use Agenda\Http\Controllers\StaffAvailabilityExceptionController;
use Agenda\Http\Controllers\StaffPlanningController;
use Agenda\Http\Controllers\ResourcesController;
use Agenda\Http\Controllers\TimeBlocksController;
use Agenda\Http\Controllers\AppointmentsController;
use Agenda\Http\Middleware\AuthMiddleware;
use Agenda\Http\Middleware\BusinessAccessMiddleware;
use Agenda\Http\Middleware\CustomerAuthMiddleware;
use Agenda\Http\Middleware\IdempotencyMiddleware;
use Agenda\Http\Middleware\LocationContextMiddleware;
use Agenda\Infrastructure\Database\Connection;
use Agenda\Infrastructure\Logger\Logger;
use Agenda\Infrastructure\Repositories\AuthSessionRepository;
use Agenda\Infrastructure\Repositories\BookingRepository;
use Agenda\Infrastructure\Repositories\BusinessRepository;
use Agenda\Infrastructure\Repositories\BusinessUserRepository;
use Agenda\Infrastructure\Repositories\BusinessInvitationRepository;
use Agenda\Infrastructure\Repositories\ClientAuthRepository;
use Agenda\Infrastructure\Repositories\ClientRepository;
use Agenda\Infrastructure\Repositories\LocationRepository;
use Agenda\Infrastructure\Repositories\ServiceRepository;
use Agenda\Infrastructure\Repositories\StaffRepository;
use Agenda\Infrastructure\Repositories\StaffScheduleRepository;
use Agenda\Infrastructure\Repositories\StaffAvailabilityExceptionRepository;
use Agenda\Infrastructure\Repositories\StaffPlanningRepository;
use Agenda\Infrastructure\Repositories\ResourceRepository;
use Agenda\Infrastructure\Repositories\TimeBlockRepository;
use Agenda\Infrastructure\Repositories\UserRepository;
use Agenda\Infrastructure\Security\JwtService;
use Agenda\Infrastructure\Security\PasswordHasher;
use Agenda\UseCases\Auth\GetMe;
use Agenda\UseCases\Auth\LoginUser;
use Agenda\UseCases\Auth\LogoutUser;
use Agenda\UseCases\Auth\RefreshToken;
use Agenda\UseCases\Auth\RegisterUser;
use Agenda\UseCases\Auth\RequestPasswordReset;
use Agenda\UseCases\Auth\ResetPassword;
use Agenda\UseCases\Auth\VerifyResetToken;
use Agenda\UseCases\Auth\ChangePassword;
use Agenda\UseCases\Auth\UpdateProfile;
use Agenda\UseCases\Booking\ComputeAvailability;
use Agenda\UseCases\Booking\CreateBooking;
use Agenda\UseCases\Booking\UpdateBooking;
use Agenda\UseCases\Booking\DeleteBooking;
use Agenda\UseCases\Booking\GetMyBookings;
use Agenda\UseCases\CustomerAuth\LoginCustomer;
use Agenda\UseCases\CustomerAuth\RegisterCustomer;
use Agenda\UseCases\CustomerAuth\RefreshCustomerToken;
use Agenda\UseCases\CustomerAuth\LogoutCustomer;
use Agenda\UseCases\CustomerAuth\GetCustomerMe;
use Agenda\UseCases\CustomerAuth\RequestCustomerPasswordReset;
use Agenda\UseCases\CustomerAuth\ResetCustomerPassword;
use Agenda\UseCases\CustomerAuth\UpdateCustomerProfile;
use Agenda\UseCases\CustomerAuth\ChangeCustomerPassword;
use Throwable;

final class Kernel
{
    private Router $router;
    private Connection $db;
    private Logger $logger;
    private array $middleware = [];
    private array $controllers = [];

    public function __construct()
    {
        $this->db = new Connection();
        $this->logger = new Logger();
        $this->router = new Router();
        
        $this->registerRoutes();
        $this->registerMiddleware();
        $this->registerControllers();
    }

    private function registerRoutes(): void
    {
        // Health check (no auth, no business context)
        $this->router->get('/health', HealthController::class, 'check');

        // Auth (no business context)
        $this->router->post('/v1/auth/login', AuthController::class, 'login');
        $this->router->post('/v1/auth/register', AuthController::class, 'register');
        $this->router->post('/v1/auth/refresh', AuthController::class, 'refresh');
        $this->router->post('/v1/auth/logout', AuthController::class, 'logout', ['auth']);
        $this->router->post('/v1/auth/forgot-password', AuthController::class, 'forgotPassword');
        $this->router->get('/v1/auth/verify-reset-token/{token}', AuthController::class, 'verifyResetTokenAction');
        $this->router->post('/v1/auth/reset-password', AuthController::class, 'resetPasswordAction');
        $this->router->get('/v1/me', AuthController::class, 'me', ['auth']);
        $this->router->put('/v1/me', AuthController::class, 'updateMe', ['auth']);
        $this->router->post('/v1/me/change-password', AuthController::class, 'changePassword', ['auth']);
        $this->router->get('/v1/me/bookings', BookingsController::class, 'myBookings', ['auth']);
        $this->router->get('/v1/me/businesses', AdminBusinessesController::class, 'myBusinesses', ['auth']);

        // Admin/Superadmin endpoints
        $this->router->get('/v1/admin/businesses', AdminBusinessesController::class, 'index', ['auth']);
        $this->router->post('/v1/admin/businesses', AdminBusinessesController::class, 'store', ['auth']);
        $this->router->put('/v1/admin/businesses/{id}', AdminBusinessesController::class, 'update', ['auth']);
        $this->router->delete('/v1/admin/businesses/{id}', AdminBusinessesController::class, 'destroy', ['auth']);
        $this->router->post('/v1/admin/businesses/{id}/resend-invite', AdminBusinessesController::class, 'resendInvite', ['auth']);

        // Businesses - Public endpoint for subdomain resolution
        $this->router->get('/v1/businesses/by-slug/{slug}', BusinessController::class, 'showBySlug');
        // Public locations for a business (for booking flow)
        $this->router->get('/v1/businesses/{business_id}/locations/public', LocationsController::class, 'indexPublic');

        // Businesses and Locations (auth required)
        $this->router->get('/v1/businesses', BusinessController::class, 'index', ['auth']);
        $this->router->get('/v1/businesses/{id}', BusinessController::class, 'show', ['auth']);
        $this->router->get('/v1/businesses/{business_id}/locations', LocationsController::class, 'index', ['auth']);
        $this->router->post('/v1/businesses/{business_id}/locations', LocationsController::class, 'store', ['auth']);
        $this->router->get('/v1/locations/{id}', LocationsController::class, 'show', ['auth']);
        $this->router->put('/v1/locations/{id}', LocationsController::class, 'update', ['auth']);
        $this->router->delete('/v1/locations/{id}', LocationsController::class, 'destroy', ['auth']);
        $this->router->post('/v1/locations/reorder', LocationsController::class, 'reorder', ['auth']);

        // Staff management (auth required)
        $this->router->get('/v1/businesses/{business_id}/staff', StaffController::class, 'indexByBusiness', ['auth']);
        $this->router->post('/v1/businesses/{business_id}/staff', StaffController::class, 'store', ['auth']);
        $this->router->put('/v1/staff/{id}', StaffController::class, 'update', ['auth']);
        $this->router->delete('/v1/staff/{id}', StaffController::class, 'destroy', ['auth']);
        $this->router->post('/v1/staff/reorder', StaffController::class, 'reorder', ['auth']);

        // Staff schedules (auth required)
        $this->router->get('/v1/businesses/{business_id}/staff/schedules', StaffController::class, 'indexSchedules', ['auth']);
        $this->router->get('/v1/staff/{id}/schedules', StaffController::class, 'showSchedule', ['auth']);
        $this->router->put('/v1/staff/{id}/schedules', StaffController::class, 'updateSchedule', ['auth']);

        // Staff availability exceptions (auth required)
        $this->router->get('/v1/businesses/{business_id}/staff/availability-exceptions', StaffAvailabilityExceptionController::class, 'indexForBusiness', ['auth']);
        $this->router->get('/v1/staff/{id}/availability-exceptions', StaffAvailabilityExceptionController::class, 'indexForStaff', ['auth']);
        $this->router->post('/v1/staff/{id}/availability-exceptions', StaffAvailabilityExceptionController::class, 'store', ['auth']);
        $this->router->put('/v1/staff/availability-exceptions/{id}', StaffAvailabilityExceptionController::class, 'update', ['auth']);
        $this->router->delete('/v1/staff/availability-exceptions/{id}', StaffAvailabilityExceptionController::class, 'destroy', ['auth']);

        // Staff planning (auth required)
        $this->router->get('/v1/staff/{id}/plannings', StaffPlanningController::class, 'indexForStaff', ['auth']);
        $this->router->get('/v1/staff/{id}/planning', StaffPlanningController::class, 'showForDate', ['auth']);
        $this->router->get('/v1/staff/{id}/planning/{planning_id}', StaffPlanningController::class, 'show', ['auth']);
        $this->router->get('/v1/staff/{id}/planning-availability', StaffPlanningController::class, 'availabilityForDate', ['auth']);
        $this->router->post('/v1/staff/{id}/plannings', StaffPlanningController::class, 'store', ['auth']);
        $this->router->put('/v1/staff/{id}/plannings/{planning_id}', StaffPlanningController::class, 'update', ['auth']);
        $this->router->delete('/v1/staff/{id}/plannings/{planning_id}', StaffPlanningController::class, 'destroy', ['auth']);

        // Resources (auth required)
        $this->router->get('/v1/businesses/{business_id}/resources', ResourcesController::class, 'indexByBusiness', ['auth']);
        $this->router->get('/v1/locations/{location_id}/resources', ResourcesController::class, 'indexByLocation', ['auth']);
        $this->router->post('/v1/locations/{location_id}/resources', ResourcesController::class, 'store', ['auth']);
        $this->router->put('/v1/resources/{id}', ResourcesController::class, 'update', ['auth']);
        $this->router->delete('/v1/resources/{id}', ResourcesController::class, 'destroy', ['auth']);

        // Business Users (operators management)
        $this->router->get('/v1/businesses/{business_id}/users', BusinessUsersController::class, 'index', ['auth']);
        $this->router->post('/v1/businesses/{business_id}/users', BusinessUsersController::class, 'store', ['auth']);
        $this->router->patch('/v1/businesses/{business_id}/users/{target_user_id}', BusinessUsersController::class, 'update', ['auth']);
        $this->router->delete('/v1/businesses/{business_id}/users/{target_user_id}', BusinessUsersController::class, 'destroy', ['auth']);

        // Business Invitations
        $this->router->get('/v1/businesses/{business_id}/invitations', BusinessInvitationsController::class, 'index', ['auth']);
        $this->router->post('/v1/businesses/{business_id}/invitations', BusinessInvitationsController::class, 'store', ['auth']);
        $this->router->delete('/v1/businesses/{business_id}/invitations/{invitation_id}', BusinessInvitationsController::class, 'destroy', ['auth']);
        $this->router->get('/v1/invitations/{token}', BusinessInvitationsController::class, 'show');
        $this->router->post('/v1/invitations/{token}/accept', BusinessInvitationsController::class, 'accept', ['auth']);

        // Public (business-scoped via query param)
        $this->router->get('/v1/services', ServicesController::class, 'index', ['location_query']);
        $this->router->get('/v1/staff', StaffController::class, 'index', ['location_query']);
        $this->router->get('/v1/availability', AvailabilityController::class, 'index', ['location_query']);

        // Services CRUD (auth required)
        $this->router->post('/v1/locations/{location_id}/services', ServicesController::class, 'store', ['auth', 'location_path']);
        $this->router->put('/v1/services/{id}', ServicesController::class, 'update', ['auth']);
        $this->router->delete('/v1/services/{id}', ServicesController::class, 'destroy', ['auth']);
        $this->router->post('/v1/services/reorder', ServicesController::class, 'reorderServices', ['auth']);

        // Service Categories CRUD (auth required)
        $this->router->get('/v1/businesses/{business_id}/categories', ServicesController::class, 'indexCategories', ['auth', 'business_access_route']);
        $this->router->post('/v1/businesses/{business_id}/categories', ServicesController::class, 'storeCategory', ['auth', 'business_access_route']);
        $this->router->put('/v1/categories/{id}', ServicesController::class, 'updateCategory', ['auth']);
        $this->router->delete('/v1/categories/{id}', ServicesController::class, 'destroyCategory', ['auth']);
        $this->router->post('/v1/categories/reorder', ServicesController::class, 'reorderCategories', ['auth']);

        // Clients (auth required)
        $this->router->get('/v1/clients', ClientsController::class, 'index', ['auth']);
        $this->router->get('/v1/clients/{id}', ClientsController::class, 'show', ['auth']);
        $this->router->post('/v1/clients', ClientsController::class, 'store', ['auth']);
        $this->router->put('/v1/clients/{id}', ClientsController::class, 'update', ['auth']);
        $this->router->delete('/v1/clients/{id}', ClientsController::class, 'destroy', ['auth']);

        // Bookings (protected, business-scoped via path)
        $this->router->get('/v1/locations/{location_id}/bookings', BookingsController::class, 'index', ['auth', 'location_path']);
        $this->router->get('/v1/locations/{location_id}/bookings/{booking_id}', BookingsController::class, 'show', ['auth', 'location_path']);
        $this->router->post('/v1/locations/{location_id}/bookings', BookingsController::class, 'store', ['auth', 'location_path', 'idempotency']);
        $this->router->put('/v1/locations/{location_id}/bookings/{booking_id}', BookingsController::class, 'update', ['auth', 'location_path']);
        $this->router->delete('/v1/locations/{location_id}/bookings/{booking_id}', BookingsController::class, 'destroy', ['auth', 'location_path']);

        // Time blocks (auth required)
        $this->router->get('/v1/locations/{location_id}/time-blocks', TimeBlocksController::class, 'index', ['auth']);
        $this->router->post('/v1/locations/{location_id}/time-blocks', TimeBlocksController::class, 'store', ['auth']);
        $this->router->put('/v1/time-blocks/{id}', TimeBlocksController::class, 'update', ['auth']);
        $this->router->delete('/v1/time-blocks/{id}', TimeBlocksController::class, 'destroy', ['auth']);

        // Appointments (protected, business-scoped via path)
        $this->router->get('/v1/locations/{location_id}/appointments', AppointmentsController::class, 'index', ['auth', 'location_path']);
        $this->router->get('/v1/locations/{location_id}/appointments/{id}', AppointmentsController::class, 'show', ['auth', 'location_path']);
        $this->router->patch('/v1/locations/{location_id}/appointments/{id}', AppointmentsController::class, 'update', ['auth', 'location_path']);
        $this->router->post('/v1/locations/{location_id}/appointments/{id}/cancel', AppointmentsController::class, 'cancel', ['auth', 'location_path']);
        $this->router->post('/v1/bookings/{booking_id}/items', AppointmentsController::class, 'store', ['auth']);
        $this->router->delete('/v1/bookings/{booking_id}/items/{item_id}', AppointmentsController::class, 'destroyItem', ['auth']);

        // =========================================================================
        // CUSTOMER AUTH (self-service booking)
        // Separate from operator auth - uses clients table, not users table
        // =========================================================================
        $this->router->post('/v1/customer/{business_id}/auth/login', CustomerAuthController::class, 'login');
        $this->router->post('/v1/customer/{business_id}/auth/register', CustomerAuthController::class, 'register');
        $this->router->post('/v1/customer/{business_id}/auth/refresh', CustomerAuthController::class, 'refresh');
        $this->router->post('/v1/customer/{business_id}/auth/logout', CustomerAuthController::class, 'logout');
        $this->router->post('/v1/customer/{business_id}/auth/forgot-password', CustomerAuthController::class, 'forgotPassword');
        $this->router->post('/v1/customer/auth/reset-password', CustomerAuthController::class, 'resetPasswordWithToken');
        $this->router->get('/v1/customer/me', CustomerAuthController::class, 'me', ['customer_auth']);
        $this->router->put('/v1/customer/me', CustomerAuthController::class, 'updateProfile', ['customer_auth']);
        $this->router->post('/v1/customer/me/change-password', CustomerAuthController::class, 'changePassword', ['customer_auth']);
        
        // Customer bookings (protected, uses client_id from customer JWT)
        $this->router->post('/v1/customer/{business_id}/bookings', BookingsController::class, 'storeCustomer', ['customer_auth', 'idempotency']);
        $this->router->get('/v1/customer/bookings', BookingsController::class, 'myCustomerBookings', ['customer_auth']);
    }

    private function registerMiddleware(): void
    {
        $jwtService = new JwtService();
        $locationRepo = new LocationRepository($this->db);
        $businessUserRepo = new BusinessUserRepository($this->db);
        $userRepo = new UserRepository($this->db);

        $this->middleware = [
            'auth' => new AuthMiddleware($jwtService),
            'customer_auth' => new CustomerAuthMiddleware($jwtService),
            'location_path' => new LocationContextMiddleware($locationRepo, 'path'),
            'location_query' => new LocationContextMiddleware($locationRepo, 'query'),
            'idempotency' => new IdempotencyMiddleware(),
            'business_access' => new BusinessAccessMiddleware($businessUserRepo, $userRepo, 'attribute'),
            'business_access_route' => new BusinessAccessMiddleware($businessUserRepo, $userRepo, 'route'),
        ];
    }

    private function registerControllers(): void
    {
        // Repositories
        $userRepo = new UserRepository($this->db);
        $sessionRepo = new AuthSessionRepository($this->db);
        $businessRepo = new BusinessRepository($this->db);
        $businessUserRepo = new BusinessUserRepository($this->db);
        $businessInvitationRepo = new BusinessInvitationRepository($this->db);
        $locationRepo = new LocationRepository($this->db);
        $serviceRepo = new ServiceRepository($this->db);
        $staffRepo = new StaffRepository($this->db);
        $staffScheduleRepo = new StaffScheduleRepository($this->db);
        $staffExceptionRepo = new StaffAvailabilityExceptionRepository($this->db);
        $staffPlanningRepo = new StaffPlanningRepository($this->db);
        $resourceRepo = new ResourceRepository($this->db);
        $timeBlockRepo = new TimeBlockRepository($this->db);
        $bookingRepo = new BookingRepository($this->db);
        $clientRepo = new ClientRepository($this->db);
        $clientAuthRepo = new ClientAuthRepository($this->db);

        // Services
        $jwtService = new JwtService();
        $passwordHasher = new PasswordHasher();

        // Operator Auth Use Cases
        $loginUser = new LoginUser($userRepo, $sessionRepo, $jwtService, $passwordHasher);
        $refreshToken = new RefreshToken($userRepo, $sessionRepo, $jwtService);
        $logoutUser = new LogoutUser($sessionRepo);
        $getMe = new GetMe($userRepo, $clientRepo);
        $registerUser = new RegisterUser($userRepo, $sessionRepo, $jwtService, $passwordHasher);
        $requestPasswordReset = new RequestPasswordReset($this->db, $userRepo);
        $resetPassword = new ResetPassword($this->db, $userRepo, $passwordHasher);
        $verifyResetToken = new VerifyResetToken($this->db);
        $changePassword = new ChangePassword($userRepo, $passwordHasher);
        $updateProfile = new UpdateProfile($this->db, $userRepo);

        // Customer Auth Use Cases
        $loginCustomer = new LoginCustomer($clientAuthRepo, $jwtService, $passwordHasher);
        $registerCustomer = new RegisterCustomer($clientAuthRepo, $clientRepo, $jwtService, $passwordHasher);
        $refreshCustomerToken = new RefreshCustomerToken($clientAuthRepo, $jwtService);
        $logoutCustomer = new LogoutCustomer($clientAuthRepo);
        $getCustomerMe = new GetCustomerMe($clientAuthRepo);
        $requestCustomerPasswordReset = new RequestCustomerPasswordReset($clientAuthRepo, $businessRepo);
        $resetCustomerPassword = new ResetCustomerPassword($clientAuthRepo, $passwordHasher);
        $updateCustomerProfile = new UpdateCustomerProfile($clientAuthRepo);
        $changeCustomerPassword = new ChangeCustomerPassword($clientAuthRepo, $passwordHasher);

        // Booking Use Cases
        $computeAvailability = new ComputeAvailability($bookingRepo, $staffRepo, $locationRepo, $staffPlanningRepo);
        $createBooking = new CreateBooking($this->db, $bookingRepo, $serviceRepo, $staffRepo, $clientRepo, $locationRepo, $userRepo);
        $updateBooking = new UpdateBooking($bookingRepo, $this->db);
        $deleteBooking = new DeleteBooking($bookingRepo, $this->db);
        $getMyBookings = new GetMyBookings($this->db);

        // Controllers
        $this->controllers = [
            HealthController::class => new HealthController(),
            AuthController::class => new AuthController($loginUser, $refreshToken, $logoutUser, $getMe, $registerUser, $requestPasswordReset, $resetPassword, $verifyResetToken, $changePassword, $updateProfile),
            CustomerAuthController::class => new CustomerAuthController($loginCustomer, $refreshCustomerToken, $logoutCustomer, $getCustomerMe, $registerCustomer, $requestCustomerPasswordReset, $resetCustomerPassword, $updateCustomerProfile, $changeCustomerPassword, $businessRepo),
            BusinessController::class => new BusinessController($businessRepo, $locationRepo, $businessUserRepo, $userRepo),
            LocationsController::class => new LocationsController($locationRepo, $businessUserRepo, $userRepo),
            ServicesController::class => new ServicesController($serviceRepo, $locationRepo, $businessUserRepo, $userRepo),
            StaffController::class => new StaffController($staffRepo, $staffScheduleRepo, $businessUserRepo, $locationRepo, $userRepo),
            AvailabilityController::class => new AvailabilityController($computeAvailability, $serviceRepo),
            BookingsController::class => new BookingsController($createBooking, $bookingRepo, $getMyBookings, $updateBooking, $deleteBooking, $locationRepo, $businessUserRepo, $userRepo),
            ClientsController::class => new ClientsController($clientRepo, $businessUserRepo, $userRepo),
            AppointmentsController::class => new AppointmentsController($bookingRepo, $createBooking, $updateBooking, $deleteBooking, $locationRepo, $businessUserRepo, $userRepo),
            AdminBusinessesController::class => new AdminBusinessesController($this->db, $businessRepo, $businessUserRepo, $userRepo),
            BusinessUsersController::class => new BusinessUsersController($businessRepo, $businessUserRepo, $userRepo),
            BusinessInvitationsController::class => new BusinessInvitationsController($businessRepo, $businessUserRepo, $businessInvitationRepo, $userRepo),
            StaffAvailabilityExceptionController::class => new StaffAvailabilityExceptionController($staffExceptionRepo, $staffRepo, $businessUserRepo, $userRepo),
            StaffPlanningController::class => new StaffPlanningController($staffPlanningRepo, $staffRepo, $businessUserRepo, $userRepo),
            ResourcesController::class => new ResourcesController($resourceRepo, $locationRepo, $businessUserRepo, $userRepo),
            TimeBlocksController::class => new TimeBlocksController($timeBlockRepo, $locationRepo, $businessUserRepo, $userRepo),
        ];
    }

    public function handle(Request $request): Response
    {
        try {
            $this->logger->info('Request', [
                'method' => $request->method,
                'path' => $request->path,
                'trace_id' => $request->traceId,
            ]);

            $route = $this->router->match($request->method, $request->path);
            
            if ($route === null) {
                return Response::notFound('Endpoint not found', $request->traceId);
            }

            // Set path params as attributes
            foreach ($route['params'] as $key => $value) {
                $request->setAttribute($key, $value);
            }

            // Apply middleware
            foreach ($route['middleware'] as $middlewareName) {
                if (!isset($this->middleware[$middlewareName])) {
                    continue;
                }
                
                $middleware = $this->middleware[$middlewareName];
                $result = $middleware->handle($request);
                
                if ($result instanceof Response) {
                    return $result;
                }
            }

            // Call controller
            $controller = $this->controllers[$route['controller']] ?? null;
            if ($controller === null) {
                return Response::serverError('Controller not found', $request->traceId);
            }

            $method = $route['method'];
            $response = $controller->$method($request);

            $this->logger->info('Response', [
                'status' => $response->status,
                'trace_id' => $request->traceId,
            ]);

            return $response;

        } catch (\PDOException $e) {
            $this->logger->error('Database error', [
                'message' => $e->getMessage(),
                'trace_id' => $request->traceId,
                'code' => $e->getCode(),
            ]);

            // Return user-friendly message for database errors
            return Response::error(
                'Service temporarily unavailable. Please try again later.',
                'database_error',
                503,
                $request->traceId
            );

        } catch (Throwable $e) {
            $this->logger->error('Exception', [
                'message' => $e->getMessage(),
                'trace_id' => $request->traceId,
                'file' => $e->getFile(),
                'line' => $e->getLine(),
            ]);

            $debug = ($_ENV['APP_DEBUG'] ?? false) === 'true';
            $message = $debug ? $e->getMessage() : 'Internal server error';
            
            return Response::serverError($message, $request->traceId);
        }
    }
}

----- FILE: src/Http/Request.php -----

<?php

declare(strict_types=1);

namespace Agenda\Http;

use Ramsey\Uuid\Uuid;

final class Request
{
    private array $attributes = [];
    private array $cookies = [];

    public function __construct(
        public readonly string $method,
        public readonly string $path,
        public readonly array $query,
        public readonly array $headers,
        public readonly ?array $body,
        public readonly string $traceId,
        array $cookies = [],
    ) {
        $this->cookies = $cookies;
    }

    public static function fromGlobals(): self
    {
        $method = $_SERVER['REQUEST_METHOD'];
        $rawPath = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
        
        // Strip base path prefix (e.g., /agenda_core/public) for MAMP compatibility
        $basePath = $_ENV['APP_BASE_PATH'] ?? '';
        if ($basePath !== '' && str_starts_with($rawPath, $basePath)) {
            $path = substr($rawPath, strlen($basePath)) ?: '/';
        } else {
            $path = $rawPath;
        }
        
        $query = $_GET;
        
        $headers = [];
        
        // Try getallheaders() first (Apache/FPM with mod_php)
        if (function_exists('getallheaders')) {
            foreach (getallheaders() as $name => $value) {
                $headers[strtolower($name)] = $value;
            }
        }
        
        // Fallback to $_SERVER parsing
        foreach ($_SERVER as $key => $value) {
            if (str_starts_with($key, 'HTTP_')) {
                $headerName = strtolower(str_replace('_', '-', substr($key, 5)));
                // Only add if not already set from getallheaders
                if (!isset($headers[$headerName])) {
                    $headers[$headerName] = $value;
                }
            }
        }
        
        // Special case: Authorization header may be set by htaccess
        if (!isset($headers['authorization']) && isset($_SERVER['HTTP_AUTHORIZATION'])) {
            $headers['authorization'] = $_SERVER['HTTP_AUTHORIZATION'];
        }
        // Also check REDIRECT_ prefixed (mod_rewrite sometimes adds this)
        if (!isset($headers['authorization']) && isset($_SERVER['REDIRECT_HTTP_AUTHORIZATION'])) {
            $headers['authorization'] = $_SERVER['REDIRECT_HTTP_AUTHORIZATION'];
        }
        
        $body = null;
        $rawBody = file_get_contents('php://input');
        if ($rawBody !== '' && $rawBody !== false) {
            $body = json_decode($rawBody, true);
        }
        
        $traceId = Uuid::uuid4()->toString();
        
        return new self($method, $path, $query, $headers, $body, $traceId, $_COOKIE);
    }

    public function getHeader(string $name): ?string
    {
        return $this->headers[strtolower($name)] ?? null;
    }

    public function header(string $name): ?string
    {
        return $this->getHeader($name);
    }

    public function bearerToken(): ?string
    {
        $auth = $this->getHeader('authorization');
        if ($auth && str_starts_with($auth, 'Bearer ')) {
            return substr($auth, 7);
        }
        return null;
    }

    public function setAttribute(string $key, mixed $value): void
    {
        $this->attributes[$key] = $value;
    }

    public function getAttribute(string $key, mixed $default = null): mixed
    {
        return $this->attributes[$key] ?? $default;
    }

    public function getBody(): ?array
    {
        return $this->body;
    }

    public function getQuery(): array
    {
        return $this->query;
    }

    public function queryParam(string $name, ?string $default = null): ?string
    {
        return $this->query[$name] ?? $default;
    }

    public function getCookie(string $name): ?string
    {
        return $this->cookies[$name] ?? null;
    }

    public function getClientIp(): ?string
    {
        // Check X-Forwarded-For first (for proxies)
        $forwarded = $this->getHeader('x-forwarded-for');
        if ($forwarded !== null) {
            $ips = explode(',', $forwarded);
            return trim($ips[0]);
        }

        return $_SERVER['REMOTE_ADDR'] ?? null;
    }

    public function userId(): ?int
    {
        return $this->getAttribute('user_id');
    }

    public function businessId(): ?int
    {
        return $this->getAttribute('business_id');
    }

    public function locationId(): ?int
    {
        return $this->getAttribute('location_id');
    }

    /**
     * Get a route parameter (alias for getAttribute).
     * Route params are set as attributes by the Kernel after routing.
     */
    public function getRouteParam(string $name): mixed
    {
        return $this->getAttribute($name);
    }
}

----- FILE: src/Http/Response.php -----

<?php

declare(strict_types=1);

namespace Agenda\Http;

final class Response
{
    private array $cookies = [];

    public function __construct(
        public readonly int $status,
        public readonly array $data,
        public readonly ?string $traceId = null,
    ) {}

    public static function success(array $data, int $status = 200): self
    {
        return new self($status, [
            'success' => true,
            'data' => $data,
        ]);
    }

    public static function json(array $data, int $status = 200): self
    {
        return new self($status, $data);
    }

    public static function created(array $data): self
    {
        return self::success($data, 201);
    }

    public static function error(string $message, string $code, int $status = 400, ?string $traceId = null): self
    {
        return new self($status, [
            'success' => false,
            'error' => [
                'code' => $code,
                'message' => $message,
            ],
        ], $traceId);
    }

    public static function unauthorized(string $message, ?string $traceId = null): self
    {
        return self::error($message, 'unauthorized', 401);
    }

    public static function forbidden(string $message, ?string $traceId = null): self
    {
        return self::error($message, 'forbidden', 403);
    }

    public static function notFound(string $message, ?string $traceId = null): self
    {
        return self::error($message, 'not_found', 404);
    }

    public static function conflict(string $code, string $message, ?string $traceId = null): self
    {
        return self::error($message, $code, 409);
    }

    public static function validationError(string $message, ?string $traceId = null): self
    {
        return self::error($message, 'validation_error', 422);
    }

    public static function serverError(string $message, ?string $traceId = null): self
    {
        return self::error($message, 'internal_error', 500);
    }

    public function setCookie(string $name, string $value, array $options = []): self
    {
        $this->cookies[$name] = [
            'value' => $value,
            'options' => $options,
        ];
        return $this;
    }

    public function send(): void
    {
        http_response_code($this->status);
        header('Content-Type: application/json; charset=utf-8');
        
        // Determina l'origin consentito dinamicamente
        $allowedOrigins = array_map('trim', explode(',', $_ENV['CORS_ALLOWED_ORIGINS'] ?? '*'));
        $requestOrigin = $_SERVER['HTTP_ORIGIN'] ?? '';
        $corsOrigin = in_array($requestOrigin, $allowedOrigins, true) ? $requestOrigin : ($allowedOrigins[0] ?? '*');
        header('Access-Control-Allow-Origin: ' . $corsOrigin);
        header('Access-Control-Allow-Credentials: true');
        header('Vary: Origin');
        header('Cache-Control: no-store, no-cache, must-revalidate');  // Disabilita cache proxy
        
        if ($this->traceId !== null) {
            header('X-Trace-Id: ' . $this->traceId);
        }

        // Set cookies
        foreach ($this->cookies as $name => $cookie) {
            $options = $cookie['options'];
            $cookieOptions = [
                'expires' => time() + ($options['maxAge'] ?? 0),
                'path' => $options['path'] ?? '/',
                'domain' => $options['domain'] ?? '',
                'secure' => $options['secure'] ?? true,
                'httponly' => $options['httpOnly'] ?? true,
                'samesite' => $options['sameSite'] ?? 'Lax',
            ];
            setcookie($name, $cookie['value'], $cookieOptions);
        }
        
        echo json_encode($this->data, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
    }
}

----- FILE: src/Http/Router.php -----

<?php

declare(strict_types=1);

namespace Agenda\Http;

final class Router
{
    private array $routes = [];

    public function get(string $path, string $controller, string $method, array $middleware = []): void
    {
        $this->addRoute('GET', $path, $controller, $method, $middleware);
    }

    public function post(string $path, string $controller, string $method, array $middleware = []): void
    {
        $this->addRoute('POST', $path, $controller, $method, $middleware);
    }

    public function put(string $path, string $controller, string $method, array $middleware = []): void
    {
        $this->addRoute('PUT', $path, $controller, $method, $middleware);
    }

    public function patch(string $path, string $controller, string $method, array $middleware = []): void
    {
        $this->addRoute('PATCH', $path, $controller, $method, $middleware);
    }

    public function delete(string $path, string $controller, string $method, array $middleware = []): void
    {
        $this->addRoute('DELETE', $path, $controller, $method, $middleware);
    }

    private function addRoute(string $httpMethod, string $path, string $controller, string $method, array $middleware): void
    {
        $pattern = preg_replace('/\{([a-zA-Z_]+)\}/', '(?P<$1>[^/]+)', $path);
        $pattern = '#^' . $pattern . '$#';
        
        $this->routes[] = [
            'httpMethod' => $httpMethod,
            'pattern' => $pattern,
            'path' => $path,
            'controller' => $controller,
            'method' => $method,
            'middleware' => $middleware,
        ];
    }

    public function match(string $method, string $path): ?array
    {
        foreach ($this->routes as $route) {
            if ($route['httpMethod'] !== $method) {
                continue;
            }
            
            if (preg_match($route['pattern'], $path, $matches)) {
                $params = array_filter($matches, 'is_string', ARRAY_FILTER_USE_KEY);
                return [
                    'controller' => $route['controller'],
                    'method' => $route['method'],
                    'middleware' => $route['middleware'],
                    'params' => $params,
                ];
            }
        }
        
        return null;
    }
}

=======================================
----- FILE: public/index.php -----

<?php

/**
 * Agenda Core - Entry Point
 * 
 * Struttura: public/ contiene index.php e .htaccess
 * Deploy SiteGround: public/ ‚Üí mappata come public_html/
 */

declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use Agenda\Http\Kernel;
use Agenda\Http\Request;

$dotenv = Dotenv\Dotenv::createImmutable(__DIR__ . '/..');
$dotenv->safeLoad();

date_default_timezone_set($_ENV['APP_TIMEZONE'] ?? 'UTC');

$allowedOrigins = array_map('trim', explode(',', $_ENV['CORS_ALLOWED_ORIGINS'] ?? '*'));
$requestOrigin = $_SERVER['HTTP_ORIGIN'] ?? '';
$corsOrigin = in_array($requestOrigin, $allowedOrigins, true) ? $requestOrigin : ($allowedOrigins[0] ?? '*');

if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    header('Access-Control-Allow-Origin: ' . $corsOrigin);
    header('Access-Control-Allow-Methods: GET, POST, PUT, PATCH, DELETE, OPTIONS');
    header('Access-Control-Allow-Headers: Content-Type, Authorization, Idempotency-Key, X-Idempotency-Key');
    header('Access-Control-Allow-Credentials: true');
    header('Access-Control-Max-Age: 86400');
    http_response_code(204);
    exit;
}

$request = Request::fromGlobals();
$kernel = new Kernel();
$response = $kernel->handle($request);
$response->send();

=======================================

=======================================
END OF SNAPSHOT
=======================================
