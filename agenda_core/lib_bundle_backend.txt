--- FILE: lib/core/l10n/l10_extension.dart ---
import 'package:flutter/widgets.dart';

import 'l10n.dart';

/// üî§ Estensione per accedere facilmente alle stringhe localizzate.
///
/// Permette di scrivere:
/// ```dart
/// Text(context.l10n.welcomeMessage)
/// ```
/// invece di:
/// ```dart
/// Text(L10n.of(context).welcomeMessage)
/// ```
///
/// ‚úÖ Compatibile con aggiornamenti runtime della lingua.
/// ‚úÖ Evita dipendenze da `L10n.current` statico.
/// ‚úÖ Standard consigliato per progetti Flutter internazionalizzati.
extension L10nX on BuildContext {
  /// Restituisce l'istanza corrente di [L10n] per questo [BuildContext].
  L10n get l10n => L10n.of(this);
}

extension DurationLocalization on BuildContext {
  String localizedDurationLabel(int minutes) {
    final hours = minutes ~/ 60;
    final mins = minutes % 60;
    final l10n = this.l10n;

    if (hours > 0 && mins > 0) {
      return l10n.durationHourMinute(hours, mins);
    } else if (hours > 0) {
      return l10n.durationHour(hours);
    } else {
      return l10n.durationMinute(mins);
    }
  }
}
--- FILE: lib/core/l10n/intl/messages_all.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that looks up messages for specific locales by
// delegating to the appropriate library.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:implementation_imports, file_names, unnecessary_new
// ignore_for_file:unnecessary_brace_in_string_interps, directives_ordering
// ignore_for_file:argument_type_not_assignable, invalid_assignment
// ignore_for_file:prefer_single_quotes, prefer_generic_function_type_aliases
// ignore_for_file:comment_references

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';
import 'package:intl/src/intl_helpers.dart';

import 'messages_en.dart' as messages_en;
import 'messages_it.dart' as messages_it;

typedef Future<dynamic> LibraryLoader();
Map<String, LibraryLoader> _deferredLibraries = {
  'en': () => new SynchronousFuture(null),
  'it': () => new SynchronousFuture(null),
};

MessageLookupByLibrary? _findExact(String localeName) {
  switch (localeName) {
    case 'en':
      return messages_en.messages;
    case 'it':
      return messages_it.messages;
    default:
      return null;
  }
}

/// User programs should call this before using [localeName] for messages.
Future<bool> initializeMessages(String localeName) {
  var availableLocale = Intl.verifiedLocale(
    localeName,
    (locale) => _deferredLibraries[locale] != null,
    onFailure: (_) => null,
  );
  if (availableLocale == null) {
    return new SynchronousFuture(false);
  }
  var lib = _deferredLibraries[availableLocale];
  lib == null ? new SynchronousFuture(false) : lib();
  initializeInternalMessageLookup(() => new CompositeMessageLookup());
  messageLookup.addLocale(availableLocale, _findGeneratedMessagesFor);
  return new SynchronousFuture(true);
}

bool _messagesExistFor(String locale) {
  try {
    return _findExact(locale) != null;
  } catch (e) {
    return false;
  }
}

MessageLookupByLibrary? _findGeneratedMessagesFor(String locale) {
  var actualLocale = Intl.verifiedLocale(
    locale,
    _messagesExistFor,
    onFailure: (_) => null,
  );
  if (actualLocale == null) return null;
  return _findExact(actualLocale);
}
--- FILE: lib/core/l10n/intl/messages_it.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that provides messages for a it locale. All the
// messages from the main program should be duplicated here with the same
// function name.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:unnecessary_brace_in_string_interps, unnecessary_new
// ignore_for_file:prefer_single_quotes,comment_references, directives_ordering
// ignore_for_file:annotate_overrides,prefer_generic_function_type_aliases
// ignore_for_file:unused_import, file_names, avoid_escaping_inner_quotes
// ignore_for_file:unnecessary_string_interpolations, unnecessary_string_escapes

import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = new MessageLookup();

typedef String MessageIfAbsent(String messageStr, List<dynamic> args);

class MessageLookup extends MessageLookupByLibrary {
  String get localeName => 'it';

  static String m0(name) => "Disponibilit√† ‚Äì ${name}";

  static String m1(fields) => "Campi modificati: ${fields}";

  static String m2(type) => "Inviata email di tipo: ${type}";

  static String m3(channel) => "Tipo: ${channel}";

  static String m4(email) => "Destinatario: ${email}";

  static String m5(dateTime) => "Data invio: ${dateTime}";

  static String m6(subject) => "Oggetto: ${subject}";

  static String m7(count) => "${count} notifiche";

  static String m8(date, time, staffName) =>
      "La prenotazione verr√† spostata al ${date} alle ${time} per ${staffName}.";

  static String m9(duration) => "Durata totale: ${duration}";

  static String m10(price) => "Totale: ${price}";

  static String m11(count) => "${count} prenotazioni";

  static String m12(confirmed, capacity, waitlist) =>
      "Confermati: ${confirmed}/${capacity} ‚Ä¢ Lista attesa: ${waitlist}";

  static String m13(customerId) => "Cliente ${customerId}";

  static String m14(count) => "Crea ${count} programmazioni";

  static String m15(clientName) => "Appuntamenti di ${clientName}";

  static String m16(count) =>
      "${Intl.plural(count, one: '1 giorno', other: '${count} giorni')}";

  static String m17(count) =>
      "Importa ${Intl.plural(count, one: '1 festivit√†', other: '${count} festivit√†')}";

  static String m18(count) =>
      "${Intl.plural(count, one: '1 festivit√† gi√† presente', other: '${count} festivit√† gi√† presenti')} (contrassegnate con ‚úì)";

  static String m19(count) =>
      "${Intl.plural(count, one: '1 festivit√† importata', other: '${count} festivit√† importate')}";

  static String m20(count) =>
      "per un totale di ${Intl.plural(count, one: '1 giorno', other: '${count} giorni')}";

  static String m21(points) => "Saldo punti: ${points}";

  static String m22(count) => "${count} visite";

  static String m23(hours) => "${hours} ora";

  static String m24(hours, minutes) => "${hours} ora ${minutes} min";

  static String m25(minutes) => "${minutes} min";

  static String m26(id) => "Eccezione non trovata: ${id}";

  static String m27(factor) => "Nessun builder disponibile per ${factor}";

  static String m28(path) => "Pagina non trovata: ${path}";

  static String m29(count) =>
      "${count} ${Intl.plural(count, one: 'giorno', other: 'giorni')}";

  static String m30(dates) => "Alcuni giorni non sono stati salvati: ${dates}.";

  static String m31(details) =>
      "Alcuni giorni non sono stati salvati: ${details}.";

  static String m32(hours) => "${hours}h";

  static String m33(hours, minutes) => "${hours}h ${minutes}m";

  static String m34(businessName, role) =>
      "Sei stato invitato a collaborare con ${businessName} come ${role}.";

  static String m35(date) => "Ultima visita: ${date}";

  static String m36(newTime, staffName) =>
      "L\'appuntamento verr√† spostato alle ${newTime} per ${staffName}.";

  static String m37(date) => "Accettato il ${date}";

  static String m38(email) =>
      "Vuoi eliminare definitivamente l\'invito per ${email}?";

  static String m39(date) => "Scade il ${date}";

  static String m40(email) => "Invito inviato a ${email}";

  static String m41(name) => "Invitato da ${name}";

  static String m42(count) => "${count} inviti archiviati";

  static String m43(count) => "${count} inviti in attesa";

  static String m44(name) => "Vuoi rimuovere ${name} dal team?";

  static String m45(email) => "Vuoi revocare l\'invito per ${email}?";

  static String m46(durationA, durationB, totalDuration) =>
      "Sett. A: ${durationA} | Sett. B: ${durationB} | Tot: ${totalDuration}";

  static String m47(hoursA, hoursB, total) =>
      "Sett. A: ${hoursA}h | Sett. B: ${hoursB}h | Tot: ${total}h";

  static String m48(week) => "Settimana attuale: ${week}";

  static String m49(count) => "Mostra planning scaduti (${count})";

  static String m50(from) => "Valida dal ${from}";

  static String m51(from, to) => "Valida dal ${from} al ${to}";

  static String m52(from) => "Dal ${from}";

  static String m53(from, to) => "Dal ${from} al ${to}";

  static String m54(duration) => "${duration}/settimana";

  static String m55(hours) => "${hours}h/settimana";

  static String m56(count) => "Crea ${count} appuntamenti";

  static String m57(count) => "${count} conflitti";

  static String m58(count) => "${count} appuntamenti";

  static String m59(count) => "${count} selezionati";

  static String m60(index, total) => "${index} di ${total}";

  static String m61(count) => "${count} appuntamenti creati";

  static String m62(count) => "${count} saltati per conflitto";

  static String m63(index, total) =>
      "Questo √® l\'appuntamento ${index} di ${total} nella serie.";

  static String m64(index, total) =>
      "Questo √® l\'appuntamento ${index} di ${total} nella serie.";

  static String m65(count) => "${count} servizi";

  static String m66(count) => "${count} membri abilitati";

  static String m67(count, total) => "${count} di ${total} sedi";

  static String m68(count) =>
      "${Intl.plural(count, one: '1 servizio selezionato', other: '${count} servizi selezionati')}";

  static String m69(dayName) =>
      "Elimina la fascia oraria settimanale di ogni ${dayName}";

  static String m70(date) => "Elimina solo la fascia oraria di ${date}";

  static String m71(dayName) =>
      "Modifica la fascia oraria settimanale di ogni ${dayName}";

  static String m72(date) => "Modifica solo la fascia oraria di ${date}";

  static String m73(count) => "${count} servizi abilitati";

  static String m74(value) => "Usa policy del business (${value})";

  static String m75(count) =>
      "${Intl.plural(count, one: '1 giorno', other: '${count} giorni')}";

  static String m76(count) =>
      "${Intl.plural(count, one: '1 ora', other: '${count} ore')}";

  static String m77(count) =>
      "${Intl.plural(count, one: '1 minuto', other: '${count} minuti')}";

  static String m78(selected, total) => "${selected} su ${total}";

  static String m79(hours) => "${hours} ore totale";

  final messages = _notInlinedMessages(_notInlinedMessages);
  static Map<String, Function> _notInlinedMessages(_) => <String, Function>{
    "actionApply": MessageLookupByLibrary.simpleMessage("Applica"),
    "actionCancel": MessageLookupByLibrary.simpleMessage("Annulla"),
    "actionClose": MessageLookupByLibrary.simpleMessage("Chiudi"),
    "actionConfirm": MessageLookupByLibrary.simpleMessage("Conferma"),
    "actionDelete": MessageLookupByLibrary.simpleMessage("Elimina"),
    "actionDeleteBooking": MessageLookupByLibrary.simpleMessage(
      "Elimina prenotazione",
    ),
    "actionDeselectAll": MessageLookupByLibrary.simpleMessage(
      "Deseleziona tutti",
    ),
    "actionDiscard": MessageLookupByLibrary.simpleMessage("Annulla"),
    "actionEdit": MessageLookupByLibrary.simpleMessage("Modifica"),
    "actionKeepEditing": MessageLookupByLibrary.simpleMessage(
      "Continua a modificare",
    ),
    "actionRefresh": MessageLookupByLibrary.simpleMessage("Aggiorna"),
    "actionReschedule": MessageLookupByLibrary.simpleMessage("Riprogramma"),
    "actionRetry": MessageLookupByLibrary.simpleMessage("Riprova"),
    "actionSave": MessageLookupByLibrary.simpleMessage("Salva"),
    "actionSelectAll": MessageLookupByLibrary.simpleMessage("Seleziona tutti"),
    "addClientToAppointment": MessageLookupByLibrary.simpleMessage(
      "Aggiungi un cliente all\'appuntamento",
    ),
    "addPackage": MessageLookupByLibrary.simpleMessage("Aggiungi pacchetto"),
    "addService": MessageLookupByLibrary.simpleMessage("Aggiungi un servizio"),
    "addServiceTooltip": MessageLookupByLibrary.simpleMessage(
      "Aggiungi servizio",
    ),
    "additionalTimeOptionBlocked": MessageLookupByLibrary.simpleMessage(
      "Tempo bloccato",
    ),
    "additionalTimeOptionProcessing": MessageLookupByLibrary.simpleMessage(
      "Tempo di lavorazione",
    ),
    "additionalTimeSwitch": MessageLookupByLibrary.simpleMessage(
      "Tempo aggiuntivo",
    ),
    "agendaAdd": MessageLookupByLibrary.simpleMessage("Aggiungi"),
    "agendaAddAppointment": MessageLookupByLibrary.simpleMessage(
      "Nuovo appuntamento",
    ),
    "agendaAddBlock": MessageLookupByLibrary.simpleMessage("Nuovo blocco"),
    "agendaAddTitle": MessageLookupByLibrary.simpleMessage("Aggiungi un..."),
    "agendaNextDay": MessageLookupByLibrary.simpleMessage("Giorno successivo"),
    "agendaNextMonth": MessageLookupByLibrary.simpleMessage("Mese successivo"),
    "agendaNextWeek": MessageLookupByLibrary.simpleMessage(
      "Settimana successivo",
    ),
    "agendaNoLocations": MessageLookupByLibrary.simpleMessage(
      "Nessuna sede disponibile",
    ),
    "agendaNoOnDutyTeamTitle": MessageLookupByLibrary.simpleMessage(
      "Nessun membro del team di turno oggi",
    ),
    "agendaNoSelectedTeamTitle": MessageLookupByLibrary.simpleMessage(
      "Nessun membro del team selezionato",
    ),
    "agendaPrevDay": MessageLookupByLibrary.simpleMessage("Giorno precedente"),
    "agendaPrevMonth": MessageLookupByLibrary.simpleMessage("Mese precedente"),
    "agendaPrevWeek": MessageLookupByLibrary.simpleMessage(
      "Settimana precedente",
    ),
    "agendaSelectLocation": MessageLookupByLibrary.simpleMessage(
      "Seleziona sede",
    ),
    "agendaShowAllTeamButton": MessageLookupByLibrary.simpleMessage(
      "Visualizza tutto il team",
    ),
    "agendaToday": MessageLookupByLibrary.simpleMessage("Oggi"),
    "allLocations": MessageLookupByLibrary.simpleMessage("Tutte le sedi"),
    "appTitle": MessageLookupByLibrary.simpleMessage("Agenda Platform"),
    "applyClientToAllAppointmentsMessage": MessageLookupByLibrary.simpleMessage(
      "Il cliente verr√† associato anche agli appuntamenti di questa prenotazione che sono stati assegnati ad altro operatore.",
    ),
    "applyClientToAllAppointmentsTitle": MessageLookupByLibrary.simpleMessage(
      "Applicare il cliente a tutta la prenotazione?",
    ),
    "appointmentDialogTitleEdit": MessageLookupByLibrary.simpleMessage(
      "Modifica appuntamento",
    ),
    "appointmentDialogTitleNew": MessageLookupByLibrary.simpleMessage(
      "Nuovo appuntamento",
    ),
    "appointmentNoteLabel": MessageLookupByLibrary.simpleMessage(
      "Nota sull\'appuntamento",
    ),
    "appointmentNotesTitle": MessageLookupByLibrary.simpleMessage("Note"),
    "appointmentPriceFree": MessageLookupByLibrary.simpleMessage("Gratuito"),
    "appointmentPriceHint": MessageLookupByLibrary.simpleMessage(
      "Prezzo personalizzato",
    ),
    "appointmentPriceLabel": MessageLookupByLibrary.simpleMessage("Prezzo"),
    "appointmentPriceResetTooltip": MessageLookupByLibrary.simpleMessage(
      "Ripristina prezzo del servizio",
    ),
    "atLeastOneServiceRequired": MessageLookupByLibrary.simpleMessage(
      "Aggiungi almeno un servizio",
    ),
    "authEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "authFirstName": MessageLookupByLibrary.simpleMessage("Nome"),
    "authForgotPassword": MessageLookupByLibrary.simpleMessage(
      "Password dimenticata?",
    ),
    "authForgotPasswordInfo": MessageLookupByLibrary.simpleMessage(
      "Contatta l\'amministratore di sistema per reimpostare la password.",
    ),
    "authInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Email non valida",
    ),
    "authLastName": MessageLookupByLibrary.simpleMessage("Cognome"),
    "authLogin": MessageLookupByLibrary.simpleMessage("Accedi"),
    "authLoginFailed": MessageLookupByLibrary.simpleMessage(
      "Credenziali non valide. Riprova.",
    ),
    "authLoginFooter": MessageLookupByLibrary.simpleMessage(
      "Accesso riservato agli operatori autorizzati",
    ),
    "authLoginSubtitle": MessageLookupByLibrary.simpleMessage(
      "Accedi al gestionale",
    ),
    "authLogout": MessageLookupByLibrary.simpleMessage("Esci"),
    "authNetworkError": MessageLookupByLibrary.simpleMessage(
      "Connessione al server non riuscita. Controlla la tua connessione internet.",
    ),
    "authPassword": MessageLookupByLibrary.simpleMessage("Password"),
    "authPasswordTooShort": MessageLookupByLibrary.simpleMessage(
      "Password troppo corta",
    ),
    "authPhone": MessageLookupByLibrary.simpleMessage("Telefono"),
    "authRememberMe": MessageLookupByLibrary.simpleMessage("Ricordami"),
    "authRequiredField": MessageLookupByLibrary.simpleMessage(
      "Campo obbligatorio",
    ),
    "authResetPasswordError": MessageLookupByLibrary.simpleMessage(
      "Si √® verificato un errore. Riprova pi√π tardi.",
    ),
    "authResetPasswordMessage": MessageLookupByLibrary.simpleMessage(
      "Inserisci la tua email. Ti invieremo un link per reimpostare la password.",
    ),
    "authResetPasswordSend": MessageLookupByLibrary.simpleMessage("Invia"),
    "authResetPasswordSuccess": MessageLookupByLibrary.simpleMessage(
      "Se l\'email esiste nel sistema, riceverai un link per reimpostare la password.",
    ),
    "authResetPasswordTitle": MessageLookupByLibrary.simpleMessage(
      "Recupera password",
    ),
    "availabilitySave": MessageLookupByLibrary.simpleMessage("Salva modifiche"),
    "availabilityTitle": MessageLookupByLibrary.simpleMessage(
      "Disponibilit√† settimanale",
    ),
    "availabilityTitleFor": m0,
    "blockAllDay": MessageLookupByLibrary.simpleMessage("Giornata intera"),
    "blockDialogTitleEdit": MessageLookupByLibrary.simpleMessage(
      "Modifica blocco",
    ),
    "blockDialogTitleNew": MessageLookupByLibrary.simpleMessage("Nuovo blocco"),
    "blockEndTime": MessageLookupByLibrary.simpleMessage("Orario fine"),
    "blockReason": MessageLookupByLibrary.simpleMessage("Motivo (opzionale)"),
    "blockReasonHint": MessageLookupByLibrary.simpleMessage(
      "Es. Riunione, Pausa, ecc.",
    ),
    "blockSelectStaff": MessageLookupByLibrary.simpleMessage("Seleziona team"),
    "blockSelectStaffError": MessageLookupByLibrary.simpleMessage(
      "Seleziona almeno un team",
    ),
    "blockStartTime": MessageLookupByLibrary.simpleMessage("Orario inizio"),
    "blockTimeError": MessageLookupByLibrary.simpleMessage(
      "L\'ora di fine deve essere successiva all\'ora di inizio",
    ),
    "bookableOnlineSwitch": MessageLookupByLibrary.simpleMessage(
      "Prenotabile online",
    ),
    "bookingDetails": MessageLookupByLibrary.simpleMessage(
      "Dettagli prenotazione",
    ),
    "bookingHistoryActorCustomer": MessageLookupByLibrary.simpleMessage(
      "Cliente",
    ),
    "bookingHistoryActorStaff": MessageLookupByLibrary.simpleMessage(
      "Operatore",
    ),
    "bookingHistoryActorSystem": MessageLookupByLibrary.simpleMessage(
      "Sistema",
    ),
    "bookingHistoryChangedFields": m1,
    "bookingHistoryEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessun evento registrato",
    ),
    "bookingHistoryError": MessageLookupByLibrary.simpleMessage(
      "Errore nel caricamento dello storico",
    ),
    "bookingHistoryEventAppointmentUpdated":
        MessageLookupByLibrary.simpleMessage("Appuntamento modificato"),
    "bookingHistoryEventCancelled": MessageLookupByLibrary.simpleMessage(
      "Prenotazione cancellata",
    ),
    "bookingHistoryEventCreated": MessageLookupByLibrary.simpleMessage(
      "Prenotazione creata",
    ),
    "bookingHistoryEventDurationChanged": MessageLookupByLibrary.simpleMessage(
      "Durata modificata",
    ),
    "bookingHistoryEventItemAdded": MessageLookupByLibrary.simpleMessage(
      "Servizio aggiunto",
    ),
    "bookingHistoryEventItemDeleted": MessageLookupByLibrary.simpleMessage(
      "Servizio rimosso",
    ),
    "bookingHistoryEventNotificationSent": MessageLookupByLibrary.simpleMessage(
      "Email inviata al cliente",
    ),
    "bookingHistoryEventNotificationSentTitle": m2,
    "bookingHistoryEventPriceChanged": MessageLookupByLibrary.simpleMessage(
      "Prezzo modificato",
    ),
    "bookingHistoryEventReplaced": MessageLookupByLibrary.simpleMessage(
      "Prenotazione riprogrammata",
    ),
    "bookingHistoryEventStaffChanged": MessageLookupByLibrary.simpleMessage(
      "Operatore cambiato",
    ),
    "bookingHistoryEventTimeChanged": MessageLookupByLibrary.simpleMessage(
      "Orario modificato",
    ),
    "bookingHistoryEventUpdated": MessageLookupByLibrary.simpleMessage(
      "Prenotazione modificata",
    ),
    "bookingHistoryLoading": MessageLookupByLibrary.simpleMessage(
      "Caricamento storico...",
    ),
    "bookingHistoryNotificationChannel": m3,
    "bookingHistoryNotificationChannelCancelled":
        MessageLookupByLibrary.simpleMessage("Cancellazione prenotazione"),
    "bookingHistoryNotificationChannelConfirmed":
        MessageLookupByLibrary.simpleMessage("Conferma prenotazione"),
    "bookingHistoryNotificationChannelReminder":
        MessageLookupByLibrary.simpleMessage("Promemoria prenotazione"),
    "bookingHistoryNotificationChannelRescheduled":
        MessageLookupByLibrary.simpleMessage("Riprogrammazione prenotazione"),
    "bookingHistoryNotificationRecipient": m4,
    "bookingHistoryNotificationSentAt": m5,
    "bookingHistoryNotificationSubject": m6,
    "bookingHistoryTitle": MessageLookupByLibrary.simpleMessage(
      "Storico prenotazione",
    ),
    "bookingItems": MessageLookupByLibrary.simpleMessage("Servizi"),
    "bookingNotes": MessageLookupByLibrary.simpleMessage("Note prenotazione"),
    "bookingNotificationsChannelCancelled":
        MessageLookupByLibrary.simpleMessage("Prenotazione annullata"),
    "bookingNotificationsChannelConfirmed":
        MessageLookupByLibrary.simpleMessage("Prenotazione creata"),
    "bookingNotificationsChannelReminder": MessageLookupByLibrary.simpleMessage(
      "Promemoria prenotazione",
    ),
    "bookingNotificationsChannelRescheduled":
        MessageLookupByLibrary.simpleMessage("Prenotazione riprogrammata"),
    "bookingNotificationsEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessuna notifica trovata",
    ),
    "bookingNotificationsEmptyHint": MessageLookupByLibrary.simpleMessage(
      "Prova a modificare i filtri di ricerca",
    ),
    "bookingNotificationsFieldAppointment":
        MessageLookupByLibrary.simpleMessage("Appuntamento"),
    "bookingNotificationsFieldClient": MessageLookupByLibrary.simpleMessage(
      "Cliente",
    ),
    "bookingNotificationsFieldCreatedAt": MessageLookupByLibrary.simpleMessage(
      "Creata il",
    ),
    "bookingNotificationsFieldError": MessageLookupByLibrary.simpleMessage(
      "Errore",
    ),
    "bookingNotificationsFieldLocation": MessageLookupByLibrary.simpleMessage(
      "Sede",
    ),
    "bookingNotificationsFieldRecipient": MessageLookupByLibrary.simpleMessage(
      "Destinatario",
    ),
    "bookingNotificationsFieldSentAt": MessageLookupByLibrary.simpleMessage(
      "Inviata il",
    ),
    "bookingNotificationsFieldType": MessageLookupByLibrary.simpleMessage(
      "Tipo",
    ),
    "bookingNotificationsFilterStatus": MessageLookupByLibrary.simpleMessage(
      "Stato",
    ),
    "bookingNotificationsFilterType": MessageLookupByLibrary.simpleMessage(
      "Tipo",
    ),
    "bookingNotificationsLoadMore": MessageLookupByLibrary.simpleMessage(
      "Carica altre",
    ),
    "bookingNotificationsNoSubject": MessageLookupByLibrary.simpleMessage(
      "Nessun oggetto",
    ),
    "bookingNotificationsNotAvailable": MessageLookupByLibrary.simpleMessage(
      "N/D",
    ),
    "bookingNotificationsSearchHint": MessageLookupByLibrary.simpleMessage(
      "Cliente, destinatario, oggetto",
    ),
    "bookingNotificationsSearchLabel": MessageLookupByLibrary.simpleMessage(
      "Cerca",
    ),
    "bookingNotificationsStatusAll": MessageLookupByLibrary.simpleMessage(
      "Tutti gli stati",
    ),
    "bookingNotificationsStatusFailed": MessageLookupByLibrary.simpleMessage(
      "Fallita",
    ),
    "bookingNotificationsStatusPending": MessageLookupByLibrary.simpleMessage(
      "In coda",
    ),
    "bookingNotificationsStatusProcessing":
        MessageLookupByLibrary.simpleMessage("In elaborazione"),
    "bookingNotificationsStatusSent": MessageLookupByLibrary.simpleMessage(
      "Inviata",
    ),
    "bookingNotificationsTitle": MessageLookupByLibrary.simpleMessage(
      "Notifiche Prenotazioni",
    ),
    "bookingNotificationsTotalCount": m7,
    "bookingNotificationsTypeAll": MessageLookupByLibrary.simpleMessage(
      "Tutti i tipi",
    ),
    "bookingRescheduleCancelAction": MessageLookupByLibrary.simpleMessage(
      "Annulla riprogrammazione",
    ),
    "bookingRescheduleConfirmMessage": m8,
    "bookingRescheduleConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Confermi la riprogrammazione?",
    ),
    "bookingRescheduleMissingBooking": MessageLookupByLibrary.simpleMessage(
      "Prenotazione non trovata.",
    ),
    "bookingRescheduleModeHint": MessageLookupByLibrary.simpleMessage(
      "Modalit√† riprogrammazione attiva: seleziona una data e clicca uno slot.",
    ),
    "bookingRescheduleMoveFailed": MessageLookupByLibrary.simpleMessage(
      "Impossibile riprogrammare la prenotazione.",
    ),
    "bookingStaffNotEligibleWarning": MessageLookupByLibrary.simpleMessage(
      "Attenzione: il membro del team selezionato non √® abilitato per questo servizio.",
    ),
    "bookingTotal": MessageLookupByLibrary.simpleMessage("Totale"),
    "bookingTotalDuration": m9,
    "bookingTotalPrice": m10,
    "bookingUnavailableTimeWarningAppointment":
        MessageLookupByLibrary.simpleMessage(
          "Attenzione: l‚Äôorario selezionato per l‚Äôappuntamento include fasce non disponibili per il team scelto.",
        ),
    "bookingUnavailableTimeWarningService": MessageLookupByLibrary.simpleMessage(
      "Attenzione: l‚Äôorario di questo servizio include fasce non disponibili per il team scelto.",
    ),
    "bookingsListActionCancel": MessageLookupByLibrary.simpleMessage(
      "Cancella",
    ),
    "bookingsListActionEdit": MessageLookupByLibrary.simpleMessage("Modifica"),
    "bookingsListActionView": MessageLookupByLibrary.simpleMessage("Dettagli"),
    "bookingsListAllLocations": MessageLookupByLibrary.simpleMessage(
      "Tutte le sedi",
    ),
    "bookingsListAllServices": MessageLookupByLibrary.simpleMessage(
      "Tutti i servizi",
    ),
    "bookingsListAllStaff": MessageLookupByLibrary.simpleMessage(
      "Tutti gli operatori",
    ),
    "bookingsListAllStatus": MessageLookupByLibrary.simpleMessage(
      "Tutti gli stati",
    ),
    "bookingsListCancelConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "Questa azione non pu√≤ essere annullata.",
    ),
    "bookingsListCancelConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Cancellare prenotazione?",
    ),
    "bookingsListCancelSuccess": MessageLookupByLibrary.simpleMessage(
      "Prenotazione cancellata",
    ),
    "bookingsListColumnActions": MessageLookupByLibrary.simpleMessage("Azioni"),
    "bookingsListColumnClient": MessageLookupByLibrary.simpleMessage("Cliente"),
    "bookingsListColumnCreatedAt": MessageLookupByLibrary.simpleMessage(
      "Creato il",
    ),
    "bookingsListColumnCreatedBy": MessageLookupByLibrary.simpleMessage(
      "Creato da",
    ),
    "bookingsListColumnDateTime": MessageLookupByLibrary.simpleMessage(
      "Data/Ora",
    ),
    "bookingsListColumnPrice": MessageLookupByLibrary.simpleMessage("Prezzo"),
    "bookingsListColumnServices": MessageLookupByLibrary.simpleMessage(
      "Servizi",
    ),
    "bookingsListColumnStaff": MessageLookupByLibrary.simpleMessage(
      "Operatore",
    ),
    "bookingsListColumnStatus": MessageLookupByLibrary.simpleMessage("Stato"),
    "bookingsListEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessuna prenotazione trovata",
    ),
    "bookingsListEmptyHint": MessageLookupByLibrary.simpleMessage(
      "Prova a modificare i filtri di ricerca",
    ),
    "bookingsListFilterClient": MessageLookupByLibrary.simpleMessage(
      "Cerca cliente",
    ),
    "bookingsListFilterClientHint": MessageLookupByLibrary.simpleMessage(
      "Nome, email o telefono",
    ),
    "bookingsListFilterFutureOnly": MessageLookupByLibrary.simpleMessage(
      "Solo futuri",
    ),
    "bookingsListFilterIncludePast": MessageLookupByLibrary.simpleMessage(
      "Includi passati",
    ),
    "bookingsListFilterLocation": MessageLookupByLibrary.simpleMessage("Sede"),
    "bookingsListFilterPeriod": MessageLookupByLibrary.simpleMessage("Periodo"),
    "bookingsListFilterService": MessageLookupByLibrary.simpleMessage(
      "Servizio",
    ),
    "bookingsListFilterStaff": MessageLookupByLibrary.simpleMessage(
      "Operatore",
    ),
    "bookingsListFilterStatus": MessageLookupByLibrary.simpleMessage("Stato"),
    "bookingsListFilterTitle": MessageLookupByLibrary.simpleMessage("Filtri"),
    "bookingsListLoadMore": MessageLookupByLibrary.simpleMessage(
      "Carica altre",
    ),
    "bookingsListLoading": MessageLookupByLibrary.simpleMessage(
      "Caricamento...",
    ),
    "bookingsListNoClient": MessageLookupByLibrary.simpleMessage(
      "Nessun cliente",
    ),
    "bookingsListResetFilters": MessageLookupByLibrary.simpleMessage(
      "Reset filtri",
    ),
    "bookingsListSortAsc": MessageLookupByLibrary.simpleMessage("Crescente"),
    "bookingsListSortByAppointment": MessageLookupByLibrary.simpleMessage(
      "Data appuntamento",
    ),
    "bookingsListSortByCreated": MessageLookupByLibrary.simpleMessage(
      "Data creazione",
    ),
    "bookingsListSortDesc": MessageLookupByLibrary.simpleMessage("Decrescente"),
    "bookingsListSourceInternal": MessageLookupByLibrary.simpleMessage(
      "Gestionale",
    ),
    "bookingsListSourceOnline": MessageLookupByLibrary.simpleMessage("Online"),
    "bookingsListSourcePhone": MessageLookupByLibrary.simpleMessage("Telefono"),
    "bookingsListSourceWalkIn": MessageLookupByLibrary.simpleMessage("Walk-in"),
    "bookingsListStatusCancelled": MessageLookupByLibrary.simpleMessage(
      "Cancellato",
    ),
    "bookingsListStatusCompleted": MessageLookupByLibrary.simpleMessage(
      "Completato",
    ),
    "bookingsListStatusConfirmed": MessageLookupByLibrary.simpleMessage(
      "Confermato",
    ),
    "bookingsListStatusNoShow": MessageLookupByLibrary.simpleMessage("No show"),
    "bookingsListStatusPending": MessageLookupByLibrary.simpleMessage(
      "In attesa",
    ),
    "bookingsListStatusReplaced": MessageLookupByLibrary.simpleMessage(
      "Sostituito",
    ),
    "bookingsListTitle": MessageLookupByLibrary.simpleMessage(
      "Elenco Prenotazioni",
    ),
    "bookingsListTotalCount": m11,
    "businessOnlineBookingsNotificationEmailHelper":
        MessageLookupByLibrary.simpleMessage(
          "Riceve notifiche solo per prenotazioni eseguite dal cliente",
        ),
    "businessOnlineBookingsNotificationEmailHint":
        MessageLookupByLibrary.simpleMessage("es. prenotazioni@salone.it"),
    "businessOnlineBookingsNotificationEmailLabel":
        MessageLookupByLibrary.simpleMessage(
          "Email Notifiche Prenotazioni Online",
        ),
    "businessServiceColorPaletteEnhanced": MessageLookupByLibrary.simpleMessage(
      "Scura (consigliata)",
    ),
    "businessServiceColorPaletteHelper": MessageLookupByLibrary.simpleMessage(
      "Definisce i colori usati nella selezione servizi e nelle card agenda",
    ),
    "businessServiceColorPaletteLabel": MessageLookupByLibrary.simpleMessage(
      "Palette colori servizi",
    ),
    "businessServiceColorPaletteLegacy": MessageLookupByLibrary.simpleMessage(
      "Originale",
    ),
    "cancelledBadge": MessageLookupByLibrary.simpleMessage("CANCELLATO"),
    "cannotDeleteCategoryContent": MessageLookupByLibrary.simpleMessage(
      "La categoria contiene uno o pi√π servizi.",
    ),
    "cannotDeleteTitle": MessageLookupByLibrary.simpleMessage(
      "Impossibile eliminare",
    ),
    "cannotUndoWarning": MessageLookupByLibrary.simpleMessage(
      "Questa azione non pu√≤ essere annullata.",
    ),
    "categoryDuplicateError": MessageLookupByLibrary.simpleMessage(
      "Esiste gi√† una categoria con questo nome",
    ),
    "classEventsActionBook": MessageLookupByLibrary.simpleMessage("Prenota"),
    "classEventsActionCancelBooking": MessageLookupByLibrary.simpleMessage(
      "Annulla prenotazione",
    ),
    "classEventsAddButton": MessageLookupByLibrary.simpleMessage("Aggiungi"),
    "classEventsCapacitySummary": m12,
    "classEventsCreateErrorMessage": MessageLookupByLibrary.simpleMessage(
      "Impossibile creare la classe",
    ),
    "classEventsCreateSuccessMessage": MessageLookupByLibrary.simpleMessage(
      "La classe √® stata creata correttamente",
    ),
    "classEventsCreateSuccessTitle": MessageLookupByLibrary.simpleMessage(
      "Classe creata",
    ),
    "classEventsCreateTitle": MessageLookupByLibrary.simpleMessage(
      "Programmazione",
    ),
    "classEventsEditModeLabel": MessageLookupByLibrary.simpleMessage(
      "Modalit√† modifica",
    ),
    "classEventsEditTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica programmazione",
    ),
    "classEventsEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessuna classe nel giorno selezionato.",
    ),
    "classEventsExpiredBadge": MessageLookupByLibrary.simpleMessage("Scadute"),
    "classEventsFieldCapacity": MessageLookupByLibrary.simpleMessage(
      "Capienza",
    ),
    "classEventsFieldClassType": MessageLookupByLibrary.simpleMessage(
      "Tipo classe",
    ),
    "classEventsFieldDate": MessageLookupByLibrary.simpleMessage("Data"),
    "classEventsFieldEndTime": MessageLookupByLibrary.simpleMessage("Ora fine"),
    "classEventsFieldLocation": MessageLookupByLibrary.simpleMessage("Sede"),
    "classEventsFieldStaff": MessageLookupByLibrary.simpleMessage("Staff"),
    "classEventsFieldStartTime": MessageLookupByLibrary.simpleMessage(
      "Ora inizio",
    ),
    "classEventsFieldTitleOptional": MessageLookupByLibrary.simpleMessage(
      "Titolo (opzionale)",
    ),
    "classEventsFutureBadge": MessageLookupByLibrary.simpleMessage("Future"),
    "classEventsNewScheduleButton": MessageLookupByLibrary.simpleMessage(
      "Nuova programmazione",
    ),
    "classEventsNoClassTypes": MessageLookupByLibrary.simpleMessage(
      "Nessun tipo classe disponibile",
    ),
    "classEventsNoLocationsForClassType": MessageLookupByLibrary.simpleMessage(
      "Nessuna sede abilitata per questo tipo classe",
    ),
    "classEventsNoStaffForLocation": MessageLookupByLibrary.simpleMessage(
      "Nessuno staff disponibile per la sede selezionata",
    ),
    "classEventsParticipantCustomer": m13,
    "classEventsParticipantsTitle": MessageLookupByLibrary.simpleMessage(
      "Partecipanti",
    ),
    "classEventsRecurrenceConflictForceDescription":
        MessageLookupByLibrary.simpleMessage(
          "Crea le programmazioni anche se ci sono sovrapposizioni",
        ),
    "classEventsRecurrenceConflictSkipDescription":
        MessageLookupByLibrary.simpleMessage(
          "Non crea programmazioni se ci sono sovrapposizioni",
        ),
    "classEventsRecurrencePreviewConfirm": m14,
    "classEventsRecurrencePreviewHint": MessageLookupByLibrary.simpleMessage(
      "Deseleziona le programmazioni che non vuoi creare",
    ),
    "classEventsRecurrencePreviewTitle": MessageLookupByLibrary.simpleMessage(
      "Anteprima programmazioni",
    ),
    "classEventsRepeatSchedule": MessageLookupByLibrary.simpleMessage(
      "Ripeti programmazione",
    ),
    "classEventsSchedulesDeleteConfirmMessage":
        MessageLookupByLibrary.simpleMessage(
          "Eliminando la programmazione verranno eliminate anche le eventuali prenotazioni esistenti.",
        ),
    "classEventsSchedulesDeleteConfirmTitle":
        MessageLookupByLibrary.simpleMessage("Eliminare la programmazione?"),
    "classEventsSchedulesDeleteSuccessMessage":
        MessageLookupByLibrary.simpleMessage(
          "La programmazione e le prenotazioni collegate sono state eliminate",
        ),
    "classEventsSchedulesDeleteSuccessTitle":
        MessageLookupByLibrary.simpleMessage("Programmazione eliminata"),
    "classEventsSchedulesListEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessuna programmazione",
    ),
    "classEventsSchedulesListTitle": MessageLookupByLibrary.simpleMessage(
      "Programmazioni esistenti",
    ),
    "classEventsSchedulesUpdateSuccessMessage":
        MessageLookupByLibrary.simpleMessage(
          "La programmazione √® stata aggiornata correttamente",
        ),
    "classEventsSchedulesUpdateSuccessTitle":
        MessageLookupByLibrary.simpleMessage("Programmazione aggiornata"),
    "classEventsShowExpiredSchedules": MessageLookupByLibrary.simpleMessage(
      "Mostra anche scadute",
    ),
    "classEventsTitle": MessageLookupByLibrary.simpleMessage("Classi"),
    "classEventsUntitled": MessageLookupByLibrary.simpleMessage("Classe"),
    "classEventsValidationEndAfterStart": MessageLookupByLibrary.simpleMessage(
      "L\'ora di fine deve essere successiva all\'ora di inizio",
    ),
    "classEventsValidationRequired": MessageLookupByLibrary.simpleMessage(
      "Compila tutti i campi obbligatori",
    ),
    "classTypesActionClone": MessageLookupByLibrary.simpleMessage("Duplica"),
    "classTypesActionDeactivate": MessageLookupByLibrary.simpleMessage(
      "Cancella",
    ),
    "classTypesActionReactivate": MessageLookupByLibrary.simpleMessage(
      "Riattiva",
    ),
    "classTypesActionScheduleClass": MessageLookupByLibrary.simpleMessage(
      "Programmazione",
    ),
    "classTypesAddButton": MessageLookupByLibrary.simpleMessage("Nuovo tipo"),
    "classTypesCloneSuccessMessage": MessageLookupByLibrary.simpleMessage(
      "Il tipo classe √® stato duplicato correttamente",
    ),
    "classTypesCloneSuccessTitle": MessageLookupByLibrary.simpleMessage(
      "Tipo classe duplicato",
    ),
    "classTypesCloneSuffix": MessageLookupByLibrary.simpleMessage("Copia"),
    "classTypesCreateSuccessMessage": MessageLookupByLibrary.simpleMessage(
      "Il tipo classe √® stato creato correttamente",
    ),
    "classTypesCreateSuccessTitle": MessageLookupByLibrary.simpleMessage(
      "Tipo classe creato",
    ),
    "classTypesCreateTitle": MessageLookupByLibrary.simpleMessage(
      "Nuovo tipo classe",
    ),
    "classTypesDeactivateConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "Il tipo classe verr√† disattivato e non sar√† selezionabile per nuove programmazioni.",
    ),
    "classTypesDeactivateConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Cancellare il tipo classe?",
    ),
    "classTypesDeactivateSuccessMessage": MessageLookupByLibrary.simpleMessage(
      "Il tipo classe √® stato disattivato",
    ),
    "classTypesDeactivateSuccessTitle": MessageLookupByLibrary.simpleMessage(
      "Tipo classe cancellato",
    ),
    "classTypesDeleteConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "Questa azione elimina definitivamente il tipo classe.",
    ),
    "classTypesDeleteConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare il tipo classe?",
    ),
    "classTypesDeleteInUseErrorMessage": MessageLookupByLibrary.simpleMessage(
      "Impossibile eliminare il tipo classe perch√© esistono programmazioni associate",
    ),
    "classTypesDeleteSuccessMessage": MessageLookupByLibrary.simpleMessage(
      "Il tipo classe √® stato eliminato",
    ),
    "classTypesDeleteSuccessTitle": MessageLookupByLibrary.simpleMessage(
      "Tipo classe eliminato",
    ),
    "classTypesEditTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica tipo classe",
    ),
    "classTypesEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessun tipo classe configurato",
    ),
    "classTypesFieldDescriptionOptional": MessageLookupByLibrary.simpleMessage(
      "Descrizione (opzionale)",
    ),
    "classTypesFieldIsActive": MessageLookupByLibrary.simpleMessage(
      "Tipo attivo",
    ),
    "classTypesFieldName": MessageLookupByLibrary.simpleMessage("Nome"),
    "classTypesManageButton": MessageLookupByLibrary.simpleMessage(
      "Tipi classe",
    ),
    "classTypesManageTitle": MessageLookupByLibrary.simpleMessage(
      "Gestione tipi classe",
    ),
    "classTypesMutationErrorMessage": MessageLookupByLibrary.simpleMessage(
      "Impossibile salvare il tipo classe",
    ),
    "classTypesReactivateConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "Il tipo classe torner√† disponibile per nuove programmazioni.",
    ),
    "classTypesReactivateConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Riattivare il tipo classe?",
    ),
    "classTypesReactivateSuccessMessage": MessageLookupByLibrary.simpleMessage(
      "Il tipo classe √® stato riattivato",
    ),
    "classTypesReactivateSuccessTitle": MessageLookupByLibrary.simpleMessage(
      "Tipo classe riattivato",
    ),
    "classTypesStatusActive": MessageLookupByLibrary.simpleMessage("Attivo"),
    "classTypesStatusInactive": MessageLookupByLibrary.simpleMessage(
      "Non attivo",
    ),
    "classTypesUpdateSuccessMessage": MessageLookupByLibrary.simpleMessage(
      "Il tipo classe √® stato aggiornato correttamente",
    ),
    "classTypesUpdateSuccessTitle": MessageLookupByLibrary.simpleMessage(
      "Tipo classe aggiornato",
    ),
    "clientAppointmentsCancelledBadge": MessageLookupByLibrary.simpleMessage(
      "ANNULLATA",
    ),
    "clientAppointmentsEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessun appuntamento",
    ),
    "clientAppointmentsPast": MessageLookupByLibrary.simpleMessage("Passati"),
    "clientAppointmentsTitle": m15,
    "clientAppointmentsUpcoming": MessageLookupByLibrary.simpleMessage(
      "Prossimi",
    ),
    "clientLockedHint": MessageLookupByLibrary.simpleMessage(
      "Il cliente non pu√≤ essere modificato per questo appuntamento",
    ),
    "clientNoteLabel": MessageLookupByLibrary.simpleMessage("Nota sul cliente"),
    "clientOptionalHint": MessageLookupByLibrary.simpleMessage(
      "Lascia il campo vuoto se non vuoi associare un cliente all\'appuntamento",
    ),
    "clientsEdit": MessageLookupByLibrary.simpleMessage("Modifica cliente"),
    "clientsEmpty": MessageLookupByLibrary.simpleMessage("Nessun cliente"),
    "clientsNew": MessageLookupByLibrary.simpleMessage("Nuovo cliente"),
    "clientsTitle": MessageLookupByLibrary.simpleMessage("Elenco Clienti"),
    "closuresAddButton": MessageLookupByLibrary.simpleMessage(
      "Aggiungi chiusura",
    ),
    "closuresAddSuccess": MessageLookupByLibrary.simpleMessage(
      "Chiusura aggiunta",
    ),
    "closuresAllLocations": MessageLookupByLibrary.simpleMessage(
      "Tutte le sedi",
    ),
    "closuresDateRange": MessageLookupByLibrary.simpleMessage("Periodo"),
    "closuresDays": m16,
    "closuresDeleteConfirm": MessageLookupByLibrary.simpleMessage(
      "Eliminare questa chiusura?",
    ),
    "closuresDeleteConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "Gli slot di prenotazione in questo periodo torneranno disponibili.",
    ),
    "closuresDeleteSuccess": MessageLookupByLibrary.simpleMessage(
      "Chiusura eliminata",
    ),
    "closuresDeselectAll": MessageLookupByLibrary.simpleMessage(
      "Deseleziona tutte",
    ),
    "closuresEditTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica chiusura",
    ),
    "closuresEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessuna chiusura programmata",
    ),
    "closuresEmptyForPeriod": MessageLookupByLibrary.simpleMessage(
      "Nessuna chiusura programmata per il periodo selezionato",
    ),
    "closuresEmptyHint": MessageLookupByLibrary.simpleMessage(
      "Aggiungi i periodi di chiusura dell\'attivit√† (es. festivit√†, ferie)",
    ),
    "closuresEndDate": MessageLookupByLibrary.simpleMessage("Data fine"),
    "closuresFilterAll": MessageLookupByLibrary.simpleMessage("Tutti"),
    "closuresFilterFromToday": MessageLookupByLibrary.simpleMessage(
      "A partire da oggi",
    ),
    "closuresImportHolidays": MessageLookupByLibrary.simpleMessage(
      "Importa festivit√†",
    ),
    "closuresImportHolidaysAction": m17,
    "closuresImportHolidaysAlreadyAdded": m18,
    "closuresImportHolidaysList": MessageLookupByLibrary.simpleMessage(
      "Seleziona le festivit√† da importare:",
    ),
    "closuresImportHolidaysLocations": MessageLookupByLibrary.simpleMessage(
      "Applica alle sedi:",
    ),
    "closuresImportHolidaysSuccess": m19,
    "closuresImportHolidaysTitle": MessageLookupByLibrary.simpleMessage(
      "Importa festivit√† nazionali",
    ),
    "closuresImportHolidaysUnsupportedCountry":
        MessageLookupByLibrary.simpleMessage(
          "Le festivit√† automatiche non sono disponibili per il paese configurato nella sede.",
        ),
    "closuresImportHolidaysYear": MessageLookupByLibrary.simpleMessage("Anno:"),
    "closuresInvalidDateRange": MessageLookupByLibrary.simpleMessage(
      "La data di fine deve essere uguale o successiva alla data di inizio",
    ),
    "closuresLocations": MessageLookupByLibrary.simpleMessage(
      "Sedi interessate",
    ),
    "closuresNewTitle": MessageLookupByLibrary.simpleMessage("Nuova chiusura"),
    "closuresNoLocations": MessageLookupByLibrary.simpleMessage(
      "Nessuna sede configurata",
    ),
    "closuresOverlapError": MessageLookupByLibrary.simpleMessage(
      "Le date si sovrappongono con un\'altra chiusura esistente",
    ),
    "closuresPast": MessageLookupByLibrary.simpleMessage("Chiusure precedenti"),
    "closuresReason": MessageLookupByLibrary.simpleMessage(
      "Motivo (opzionale)",
    ),
    "closuresReasonHint": MessageLookupByLibrary.simpleMessage(
      "es. Festivit√†, Ferie estive, Manutenzione...",
    ),
    "closuresSelectAll": MessageLookupByLibrary.simpleMessage(
      "Seleziona tutte",
    ),
    "closuresSelectAtLeastOneLocation": MessageLookupByLibrary.simpleMessage(
      "Seleziona almeno una sede",
    ),
    "closuresSingleDay": MessageLookupByLibrary.simpleMessage("Giorno singolo"),
    "closuresStartDate": MessageLookupByLibrary.simpleMessage("Data inizio"),
    "closuresTitle": MessageLookupByLibrary.simpleMessage("Date di chiusura"),
    "closuresTotalDays": m20,
    "closuresUpcoming": MessageLookupByLibrary.simpleMessage(
      "Prossime chiusure",
    ),
    "closuresUpdateSuccess": MessageLookupByLibrary.simpleMessage(
      "Chiusura aggiornata",
    ),
    "createCategoryButtonLabel": MessageLookupByLibrary.simpleMessage(
      "Nuova categoria",
    ),
    "createNewClient": MessageLookupByLibrary.simpleMessage(
      "Crea nuovo cliente",
    ),
    "crmArchiveAction": MessageLookupByLibrary.simpleMessage("Archivia"),
    "crmBookingsReuseHint": MessageLookupByLibrary.simpleMessage(
      "Cronologia prenotazioni disponibile nella vista cliente esistente",
    ),
    "crmBookingsTab": MessageLookupByLibrary.simpleMessage("Prenotazioni"),
    "crmClientDetailTitle": MessageLookupByLibrary.simpleMessage(
      "Dettaglio cliente",
    ),
    "crmClientsDescription": MessageLookupByLibrary.simpleMessage(
      "Vista cliente 360 con KPI e timeline",
    ),
    "crmClientsEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessun cliente trovato",
    ),
    "crmClientsTitle": MessageLookupByLibrary.simpleMessage("Clienti CRM"),
    "crmContactsTab": MessageLookupByLibrary.simpleMessage("Contatti"),
    "crmCreateClientTitle": MessageLookupByLibrary.simpleMessage(
      "Nuovo cliente CRM",
    ),
    "crmCreateSegmentTitle": MessageLookupByLibrary.simpleMessage(
      "Nuovo segmento",
    ),
    "crmCreateTagTitle": MessageLookupByLibrary.simpleMessage("Nuovo tag"),
    "crmExportCopied": MessageLookupByLibrary.simpleMessage(
      "CSV copiato negli appunti",
    ),
    "crmExportCsvButton": MessageLookupByLibrary.simpleMessage(
      "Copia CSV negli appunti",
    ),
    "crmExportCsvTitle": MessageLookupByLibrary.simpleMessage("Export CSV"),
    "crmFilterAll": MessageLookupByLibrary.simpleMessage("Tutti"),
    "crmGdprDeleteConfirm": MessageLookupByLibrary.simpleMessage(
      "Confermi anonimizzazione e archiviazione del cliente?",
    ),
    "crmGdprDeleteTitle": MessageLookupByLibrary.simpleMessage("GDPR Delete"),
    "crmGdprDeleted": MessageLookupByLibrary.simpleMessage(
      "Cliente anonimizzato correttamente",
    ),
    "crmGdprTab": MessageLookupByLibrary.simpleMessage("GDPR"),
    "crmImportCommit": MessageLookupByLibrary.simpleMessage("Commit import"),
    "crmImportCsvHint": MessageLookupByLibrary.simpleMessage(
      "Incolla il CSV con header: first_name,last_name,email,phone,city,notes,source",
    ),
    "crmImportCsvTitle": MessageLookupByLibrary.simpleMessage("Import CSV"),
    "crmImportExportDescription": MessageLookupByLibrary.simpleMessage(
      "Import CSV con preview e export segmenti",
    ),
    "crmImportExportTitle": MessageLookupByLibrary.simpleMessage(
      "Import / Export",
    ),
    "crmImportPreview": MessageLookupByLibrary.simpleMessage("Dry-run preview"),
    "crmKpiAvgTicket": MessageLookupByLibrary.simpleMessage("Scontrino medio"),
    "crmKpiNoShow": MessageLookupByLibrary.simpleMessage("No-show"),
    "crmKpiSpent": MessageLookupByLibrary.simpleMessage("Spesa totale"),
    "crmKpiVisits": MessageLookupByLibrary.simpleMessage("Visite"),
    "crmLoadMore": MessageLookupByLibrary.simpleMessage("Carica altri"),
    "crmLoyaltyPoints": m21,
    "crmLoyaltyTab": MessageLookupByLibrary.simpleMessage("Loyalty"),
    "crmOverviewTab": MessageLookupByLibrary.simpleMessage("Overview"),
    "crmSearchHint": MessageLookupByLibrary.simpleMessage(
      "Cerca per nome, email, telefono, citt√†...",
    ),
    "crmSegmentDeleted": MessageLookupByLibrary.simpleMessage(
      "Segmento eliminato",
    ),
    "crmSegmentNameLabel": MessageLookupByLibrary.simpleMessage(
      "Nome segmento",
    ),
    "crmSegmentQueryLabel": MessageLookupByLibrary.simpleMessage(
      "Query ricerca (q)",
    ),
    "crmSegmentsDescription": MessageLookupByLibrary.simpleMessage(
      "Liste dinamiche clienti con filtri salvati",
    ),
    "crmSegmentsEmpty": MessageLookupByLibrary.simpleMessage("Nessun segmento"),
    "crmSegmentsTitle": MessageLookupByLibrary.simpleMessage("Segmenti"),
    "crmStatusActive": MessageLookupByLibrary.simpleMessage("Attivo"),
    "crmStatusInactive": MessageLookupByLibrary.simpleMessage("Inattivo"),
    "crmStatusLead": MessageLookupByLibrary.simpleMessage("Lead"),
    "crmStatusLost": MessageLookupByLibrary.simpleMessage("Perso"),
    "crmSubtitle": MessageLookupByLibrary.simpleMessage(
      "Gestione clienti avanzata, segmenti, task e privacy",
    ),
    "crmTagColorLabel": MessageLookupByLibrary.simpleMessage("Colore (hex)"),
    "crmTagDeleted": MessageLookupByLibrary.simpleMessage("Tag eliminato"),
    "crmTagNameLabel": MessageLookupByLibrary.simpleMessage("Nome tag"),
    "crmTagsDescription": MessageLookupByLibrary.simpleMessage(
      "Gestione tag centralizzata clienti",
    ),
    "crmTagsEmpty": MessageLookupByLibrary.simpleMessage("Nessun tag"),
    "crmTagsTitle": MessageLookupByLibrary.simpleMessage("Tag"),
    "crmTaskComplete": MessageLookupByLibrary.simpleMessage("Completa"),
    "crmTaskReopen": MessageLookupByLibrary.simpleMessage("Riapri"),
    "crmTasksDescription": MessageLookupByLibrary.simpleMessage(
      "Follow-up staff e attivit√† in ritardo",
    ),
    "crmTasksEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessun task in ritardo",
    ),
    "crmTasksTab": MessageLookupByLibrary.simpleMessage("Task"),
    "crmTasksTitle": MessageLookupByLibrary.simpleMessage("Task"),
    "crmTimelineTab": MessageLookupByLibrary.simpleMessage("Timeline"),
    "crmTitle": MessageLookupByLibrary.simpleMessage("CRM"),
    "crmVisitsLabel": m22,
    "currentWeek": MessageLookupByLibrary.simpleMessage("Settimana corrente"),
    "dayFriday": MessageLookupByLibrary.simpleMessage("Venerd√¨"),
    "dayFridayFull": MessageLookupByLibrary.simpleMessage("venerd√¨"),
    "dayMonday": MessageLookupByLibrary.simpleMessage("Luned√¨"),
    "dayMondayFull": MessageLookupByLibrary.simpleMessage("luned√¨"),
    "daySaturday": MessageLookupByLibrary.simpleMessage("Sabato"),
    "daySaturdayFull": MessageLookupByLibrary.simpleMessage("sabato"),
    "daySunday": MessageLookupByLibrary.simpleMessage("Domenica"),
    "daySundayFull": MessageLookupByLibrary.simpleMessage("domenica"),
    "dayThursday": MessageLookupByLibrary.simpleMessage("Gioved√¨"),
    "dayThursdayFull": MessageLookupByLibrary.simpleMessage("gioved√¨"),
    "dayTuesday": MessageLookupByLibrary.simpleMessage("Marted√¨"),
    "dayTuesdayFull": MessageLookupByLibrary.simpleMessage("marted√¨"),
    "dayWednesday": MessageLookupByLibrary.simpleMessage("Mercoled√¨"),
    "dayWednesdayFull": MessageLookupByLibrary.simpleMessage("mercoled√¨"),
    "deleteAppointmentConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "L\'appuntamento verr√† rimosso. L\'operazione non pu√≤ essere annullata.",
    ),
    "deleteAppointmentConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare l\'appuntamento?",
    ),
    "deleteBookingConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "Verranno rimossi tutti i servizi collegati. L\'operazione non pu√≤ essere annullata.",
    ),
    "deleteBookingConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare l‚Äôintera prenotazione?",
    ),
    "deleteClientConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "Il cliente verr√† eliminato definitivamente. Questa azione non pu√≤ essere annullata.",
    ),
    "deleteClientConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare il cliente?",
    ),
    "deleteConfirmationTitle": MessageLookupByLibrary.simpleMessage(
      "Confermi l‚Äôeliminazione?",
    ),
    "deleteServiceQuestion": MessageLookupByLibrary.simpleMessage(
      "Eliminare il servizio?",
    ),
    "discardChangesMessage": MessageLookupByLibrary.simpleMessage(
      "Hai delle modifiche non salvate. Vuoi scartarle?",
    ),
    "discardChangesTitle": MessageLookupByLibrary.simpleMessage(
      "Modifiche non salvate",
    ),
    "duplicateAction": MessageLookupByLibrary.simpleMessage("Duplica"),
    "durationHour": m23,
    "durationHourMinute": m24,
    "durationMinute": m25,
    "editCategoryTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica categoria",
    ),
    "editServiceTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica servizio",
    ),
    "emptyCategoriesNotReorderableNote": MessageLookupByLibrary.simpleMessage(
      "Le categorie senza servizi non sono riordinabili e restano in coda.",
    ),
    "errorExceptionNotFound": m26,
    "errorFormFactorBuilderMissing": m27,
    "errorFormFactorBuilderRequired": MessageLookupByLibrary.simpleMessage(
      "Specificare almeno un builder per form factor",
    ),
    "errorNotFound": m28,
    "errorServiceNotFound": MessageLookupByLibrary.simpleMessage(
      "Servizio non trovato",
    ),
    "errorTitle": MessageLookupByLibrary.simpleMessage("Errore"),
    "exceptionAllDay": MessageLookupByLibrary.simpleMessage("Giornata intera"),
    "exceptionAvailableNoEffect": MessageLookupByLibrary.simpleMessage(
      "La disponibilit√† extra deve aggiungere ore rispetto alla disponibilit√† base.",
    ),
    "exceptionDateFrom": MessageLookupByLibrary.simpleMessage("Data inizio"),
    "exceptionDateTo": MessageLookupByLibrary.simpleMessage("Data fine"),
    "exceptionDeleteMessage": MessageLookupByLibrary.simpleMessage(
      "L\'eccezione verr√† eliminata definitivamente.",
    ),
    "exceptionDeleteShift": MessageLookupByLibrary.simpleMessage(
      "Elimina eccezione",
    ),
    "exceptionDeleteShiftDesc": MessageLookupByLibrary.simpleMessage(
      "Ripristina la disponibilit√† base",
    ),
    "exceptionDeleteTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare l\'eccezione?",
    ),
    "exceptionDialogTitleEdit": MessageLookupByLibrary.simpleMessage(
      "Modifica eccezione",
    ),
    "exceptionDialogTitleNew": MessageLookupByLibrary.simpleMessage(
      "Nuova eccezione",
    ),
    "exceptionDuration": MessageLookupByLibrary.simpleMessage(
      "Durata (giorni)",
    ),
    "exceptionDurationDays": m29,
    "exceptionEditShift": MessageLookupByLibrary.simpleMessage(
      "Modifica eccezione",
    ),
    "exceptionEditShiftDesc": MessageLookupByLibrary.simpleMessage(
      "Modifica gli orari di questa eccezione",
    ),
    "exceptionEndTime": MessageLookupByLibrary.simpleMessage("Orario fine"),
    "exceptionPartialSaveInfo": m30,
    "exceptionPartialSaveInfoDetailed": m31,
    "exceptionPartialSaveMessage": MessageLookupByLibrary.simpleMessage(
      "I giorni sotto non erano congruenti e non sono stati salvati:",
    ),
    "exceptionPartialSaveTitle": MessageLookupByLibrary.simpleMessage(
      "Eccezioni non salvate",
    ),
    "exceptionPeriodDuration": MessageLookupByLibrary.simpleMessage("Durata"),
    "exceptionPeriodMode": MessageLookupByLibrary.simpleMessage("Periodo"),
    "exceptionPeriodRange": MessageLookupByLibrary.simpleMessage("Da - A"),
    "exceptionPeriodSingle": MessageLookupByLibrary.simpleMessage(
      "Giorno singolo",
    ),
    "exceptionReason": MessageLookupByLibrary.simpleMessage(
      "Motivo (opzionale)",
    ),
    "exceptionReasonExtraShift": MessageLookupByLibrary.simpleMessage(
      "Turno extra",
    ),
    "exceptionReasonHint": MessageLookupByLibrary.simpleMessage(
      "Es. Ferie, Visita medica, Turno extra...",
    ),
    "exceptionReasonMedicalVisit": MessageLookupByLibrary.simpleMessage(
      "Visita medica",
    ),
    "exceptionReasonVacation": MessageLookupByLibrary.simpleMessage("Ferie"),
    "exceptionSelectTime": MessageLookupByLibrary.simpleMessage(
      "Seleziona orario",
    ),
    "exceptionStartTime": MessageLookupByLibrary.simpleMessage("Orario inizio"),
    "exceptionTimeError": MessageLookupByLibrary.simpleMessage(
      "L\'ora di fine deve essere successiva all\'ora di inizio",
    ),
    "exceptionType": MessageLookupByLibrary.simpleMessage("Tipo eccezione"),
    "exceptionTypeAvailable": MessageLookupByLibrary.simpleMessage(
      "Disponibile",
    ),
    "exceptionTypeUnavailable": MessageLookupByLibrary.simpleMessage(
      "Non disponibile",
    ),
    "exceptionUnavailableNoBase": MessageLookupByLibrary.simpleMessage(
      "Non puoi aggiungere una non disponibilit√† in un giorno senza disponibilit√† base.",
    ),
    "exceptionUnavailableNoOverlap": MessageLookupByLibrary.simpleMessage(
      "La non disponibilit√† deve sovrapporsi alla disponibilit√† base.",
    ),
    "exceptionsAdd": MessageLookupByLibrary.simpleMessage("Aggiungi eccezione"),
    "exceptionsEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessuna eccezione configurata",
    ),
    "exceptionsTitle": MessageLookupByLibrary.simpleMessage("Eccezioni"),
    "fieldBlockedTimeLabel": MessageLookupByLibrary.simpleMessage(
      "Tempo bloccato",
    ),
    "fieldCategoryRequiredLabel": MessageLookupByLibrary.simpleMessage(
      "Categoria *",
    ),
    "fieldDescriptionLabel": MessageLookupByLibrary.simpleMessage(
      "Descrizione",
    ),
    "fieldDurationRequiredError": MessageLookupByLibrary.simpleMessage(
      "Seleziona una durata",
    ),
    "fieldDurationRequiredLabel": MessageLookupByLibrary.simpleMessage(
      "Durata *",
    ),
    "fieldNameRequiredError": MessageLookupByLibrary.simpleMessage(
      "Il nome √® obbligatorio",
    ),
    "fieldNameRequiredLabel": MessageLookupByLibrary.simpleMessage("Nome *"),
    "fieldPriceLabel": MessageLookupByLibrary.simpleMessage("Prezzo"),
    "fieldProcessingTimeLabel": MessageLookupByLibrary.simpleMessage(
      "Tempo di lavorazione",
    ),
    "filterAll": MessageLookupByLibrary.simpleMessage("Tutti"),
    "filterInactive": MessageLookupByLibrary.simpleMessage("Inattivi"),
    "filterNew": MessageLookupByLibrary.simpleMessage("Nuovi"),
    "filterVIP": MessageLookupByLibrary.simpleMessage("VIP"),
    "formClient": MessageLookupByLibrary.simpleMessage("Cliente"),
    "formDate": MessageLookupByLibrary.simpleMessage("Data"),
    "formEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "formFirstName": MessageLookupByLibrary.simpleMessage("Nome"),
    "formLastName": MessageLookupByLibrary.simpleMessage("Cognome"),
    "formNotes": MessageLookupByLibrary.simpleMessage(
      "Note (non visibili al cliente)",
    ),
    "formPhone": MessageLookupByLibrary.simpleMessage("Telefono"),
    "formService": MessageLookupByLibrary.simpleMessage("Servizio"),
    "formServices": MessageLookupByLibrary.simpleMessage("Servizi"),
    "formStaff": MessageLookupByLibrary.simpleMessage("Team"),
    "freeLabel": MessageLookupByLibrary.simpleMessage("Gratis"),
    "freeServiceSwitch": MessageLookupByLibrary.simpleMessage(
      "Servizio gratuito",
    ),
    "hoursHoursOnly": m32,
    "hoursMinutesCompact": m33,
    "invitationAcceptAndLoginAction": MessageLookupByLibrary.simpleMessage(
      "Accetta e accedi",
    ),
    "invitationAcceptButton": MessageLookupByLibrary.simpleMessage(
      "Accetta invito",
    ),
    "invitationAcceptErrorEmailMismatch": MessageLookupByLibrary.simpleMessage(
      "Questo invito √® associato a un\'altra email. Esegui il logout dall\'account corrente, poi riapri questo link e accedi con l\'email invitata.",
    ),
    "invitationAcceptErrorExpired": MessageLookupByLibrary.simpleMessage(
      "Questo invito √® scaduto.",
    ),
    "invitationAcceptErrorGeneric": MessageLookupByLibrary.simpleMessage(
      "Impossibile completare l\'operazione. Riprova.",
    ),
    "invitationAcceptErrorInvalid": MessageLookupByLibrary.simpleMessage(
      "Questo invito non √® valido.",
    ),
    "invitationAcceptHintExistingAccount": MessageLookupByLibrary.simpleMessage(
      "Hai gi√† un account? Accedi per accettare l\'invito.",
    ),
    "invitationAcceptHintNoAccount": MessageLookupByLibrary.simpleMessage(
      "Non hai un account? Registrati prima.",
    ),
    "invitationAcceptInProgress": MessageLookupByLibrary.simpleMessage(
      "Accettazione in corso...",
    ),
    "invitationAcceptIntro": m34,
    "invitationAcceptLoading": MessageLookupByLibrary.simpleMessage(
      "Verifica invito in corso...",
    ),
    "invitationAcceptLoginAction": MessageLookupByLibrary.simpleMessage(
      "Accetta per continuare",
    ),
    "invitationAcceptLoginRequired": MessageLookupByLibrary.simpleMessage(
      "Accedi con l\'email invitata per continuare.",
    ),
    "invitationAcceptRequiresRegistration":
        MessageLookupByLibrary.simpleMessage(
          "Per questa email non esiste ancora un account. Usa Registrati.",
        ),
    "invitationAcceptSuccessMessage": MessageLookupByLibrary.simpleMessage(
      "Ora puoi usare il gestionale con i permessi assegnati.",
    ),
    "invitationAcceptSuccessTitle": MessageLookupByLibrary.simpleMessage(
      "Invito accettato",
    ),
    "invitationAcceptTitle": MessageLookupByLibrary.simpleMessage(
      "Accetta invito",
    ),
    "invitationDeclineButton": MessageLookupByLibrary.simpleMessage(
      "Rifiuta invito",
    ),
    "invitationDeclineGoLogin": MessageLookupByLibrary.simpleMessage(
      "Vai al login",
    ),
    "invitationDeclineInProgress": MessageLookupByLibrary.simpleMessage(
      "Rifiuto in corso...",
    ),
    "invitationDeclineSuccessMessage": MessageLookupByLibrary.simpleMessage(
      "Hai rifiutato l\'invito. Non √® stata aggiunta nessuna autorizzazione.",
    ),
    "invitationDeclineSuccessTitle": MessageLookupByLibrary.simpleMessage(
      "Invito rifiutato",
    ),
    "invitationGoToApplication": MessageLookupByLibrary.simpleMessage(
      "Vai all\'applicazione",
    ),
    "invitationRegisterAction": MessageLookupByLibrary.simpleMessage(
      "Registrati per accettare",
    ),
    "invitationRegisterExistingUser": MessageLookupByLibrary.simpleMessage(
      "Email gi√† registrata. Accedi per accettare l\'invito.",
    ),
    "invitationRegisterInProgress": MessageLookupByLibrary.simpleMessage(
      "Registrazione...",
    ),
    "invitationRegisterPasswordConfirm": MessageLookupByLibrary.simpleMessage(
      "Conferma password",
    ),
    "invitationRegisterPasswordMismatch": MessageLookupByLibrary.simpleMessage(
      "Le password non coincidono.",
    ),
    "invitationRegisterPasswordTooShort": MessageLookupByLibrary.simpleMessage(
      "La password deve avere almeno 8 caratteri.",
    ),
    "invitationRegisterPasswordWeak": MessageLookupByLibrary.simpleMessage(
      "La password deve contenere almeno una maiuscola, una minuscola e un numero.",
    ),
    "invitationRegisterTitle": MessageLookupByLibrary.simpleMessage(
      "Registrati per accettare l\'invito",
    ),
    "labelSelect": MessageLookupByLibrary.simpleMessage("Seleziona"),
    "labelStaff": MessageLookupByLibrary.simpleMessage("Team:"),
    "lastVisitLabel": m35,
    "minutesLabel": MessageLookupByLibrary.simpleMessage("min"),
    "moreBookingNotificationsDescription": MessageLookupByLibrary.simpleMessage(
      "Visualizza lo storico delle notifiche prenotazioni",
    ),
    "moreBookingsDescription": MessageLookupByLibrary.simpleMessage(
      "Consulta lo storico delle prenotazioni",
    ),
    "moreProfileDescription": MessageLookupByLibrary.simpleMessage(
      "Gestisci i tuoi dati personali e le credenziali",
    ),
    "moreReportsDescription": MessageLookupByLibrary.simpleMessage(
      "Visualizza statistiche e andamento attivit√†",
    ),
    "moreServicesDescription": MessageLookupByLibrary.simpleMessage(
      "Gestisci i servizi offerti, categorie e listini",
    ),
    "moreSubtitle": MessageLookupByLibrary.simpleMessage(
      "Accedi alle altre funzionalit√† dell\'applicazione",
    ),
    "moreSwitchBusinessDescription": MessageLookupByLibrary.simpleMessage(
      "Passa a un altro business",
    ),
    "moreTeamDescription": MessageLookupByLibrary.simpleMessage(
      "Gestisci operatori, sedi e orari di lavoro",
    ),
    "moveAppointmentConfirmMessage": m36,
    "moveAppointmentConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Confermi lo spostamento?",
    ),
    "navAgenda": MessageLookupByLibrary.simpleMessage("Agenda"),
    "navClients": MessageLookupByLibrary.simpleMessage("Clienti"),
    "navMore": MessageLookupByLibrary.simpleMessage("Altro"),
    "navProfile": MessageLookupByLibrary.simpleMessage("Profilo"),
    "navServices": MessageLookupByLibrary.simpleMessage("Servizi"),
    "navStaff": MessageLookupByLibrary.simpleMessage("Team"),
    "newCategoryTitle": MessageLookupByLibrary.simpleMessage("Nuova categoria"),
    "newServiceTitle": MessageLookupByLibrary.simpleMessage("Nuovo servizio"),
    "noClientForAppointment": MessageLookupByLibrary.simpleMessage(
      "Nessun cliente per l\'appuntamento",
    ),
    "noServicesAdded": MessageLookupByLibrary.simpleMessage(
      "Nessun servizio aggiunto",
    ),
    "noServicesFound": MessageLookupByLibrary.simpleMessage(
      "Nessun servizio trovato",
    ),
    "noServicesInCategory": MessageLookupByLibrary.simpleMessage(
      "Nessun servizio in questa categoria",
    ),
    "noStaffAvailable": MessageLookupByLibrary.simpleMessage(
      "Nessun team disponibile",
    ),
    "notBookableOnline": MessageLookupByLibrary.simpleMessage(
      "Non prenotabile online",
    ),
    "notesPlaceholder": MessageLookupByLibrary.simpleMessage(
      "Note sull\'appuntamento...",
    ),
    "operatorsAcceptedOn": m37,
    "operatorsDeleteInvite": MessageLookupByLibrary.simpleMessage(
      "Elimina invito",
    ),
    "operatorsDeleteInviteConfirm": m38,
    "operatorsEditRole": MessageLookupByLibrary.simpleMessage("Modifica ruolo"),
    "operatorsEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessun operatore configurato",
    ),
    "operatorsExpires": m39,
    "operatorsInviteAlreadyHasAccess": MessageLookupByLibrary.simpleMessage(
      "Questo utente ha gi√† accesso al business.",
    ),
    "operatorsInviteAlreadyPending": MessageLookupByLibrary.simpleMessage(
      "Esiste gi√† un invito in attesa per questa email. Puoi reinviarlo dalla lista degli inviti pendenti.",
    ),
    "operatorsInviteCopied": MessageLookupByLibrary.simpleMessage(
      "Link di invito copiato",
    ),
    "operatorsInviteEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "operatorsInviteEmailFailed": MessageLookupByLibrary.simpleMessage(
      "Impossibile inviare l\'email di invito. Riprova pi√π tardi.",
    ),
    "operatorsInviteEmailUnavailable": MessageLookupByLibrary.simpleMessage(
      "Invio email non disponibile in questo ambiente. Contatta il supporto.",
    ),
    "operatorsInviteError": MessageLookupByLibrary.simpleMessage(
      "Impossibile inviare l\'invito",
    ),
    "operatorsInviteRole": MessageLookupByLibrary.simpleMessage("Ruolo"),
    "operatorsInviteSend": MessageLookupByLibrary.simpleMessage("Invia invito"),
    "operatorsInviteStatusAccepted": MessageLookupByLibrary.simpleMessage(
      "Accettato",
    ),
    "operatorsInviteStatusDeclined": MessageLookupByLibrary.simpleMessage(
      "Rifiutato",
    ),
    "operatorsInviteStatusExpired": MessageLookupByLibrary.simpleMessage(
      "Scaduto",
    ),
    "operatorsInviteStatusPending": MessageLookupByLibrary.simpleMessage(
      "In attesa",
    ),
    "operatorsInviteStatusRevoked": MessageLookupByLibrary.simpleMessage(
      "Revocato",
    ),
    "operatorsInviteSubtitle": MessageLookupByLibrary.simpleMessage(
      "Invia un invito via email",
    ),
    "operatorsInviteSuccess": m40,
    "operatorsInviteTitle": MessageLookupByLibrary.simpleMessage(
      "Invita operatore",
    ),
    "operatorsInvitedBy": m41,
    "operatorsInvitesHistoryCount": m42,
    "operatorsPendingInvites": MessageLookupByLibrary.simpleMessage(
      "Inviti in attesa",
    ),
    "operatorsPendingInvitesCount": m43,
    "operatorsRemove": MessageLookupByLibrary.simpleMessage(
      "Rimuovi operatore",
    ),
    "operatorsRemoveConfirm": m44,
    "operatorsRemoveSuccess": MessageLookupByLibrary.simpleMessage(
      "Operatore rimosso",
    ),
    "operatorsRevokeInvite": MessageLookupByLibrary.simpleMessage(
      "Revoca invito",
    ),
    "operatorsRevokeInviteConfirm": m45,
    "operatorsRoleAdmin": MessageLookupByLibrary.simpleMessage(
      "Amministratore",
    ),
    "operatorsRoleAdminDesc": MessageLookupByLibrary.simpleMessage(
      "Accesso completo a tutte le funzionalit√†. Pu√≤ gestire altri operatori e modificare impostazioni del business.",
    ),
    "operatorsRoleDescription": MessageLookupByLibrary.simpleMessage(
      "Seleziona il livello di accesso",
    ),
    "operatorsRoleManager": MessageLookupByLibrary.simpleMessage("Manager"),
    "operatorsRoleManagerDesc": MessageLookupByLibrary.simpleMessage(
      "Gestisce agenda e clienti. Vede e gestisce tutti gli appuntamenti, ma non pu√≤ gestire operatori n√© impostazioni.",
    ),
    "operatorsRoleOwner": MessageLookupByLibrary.simpleMessage("Proprietario"),
    "operatorsRoleStaff": MessageLookupByLibrary.simpleMessage("Staff"),
    "operatorsRoleStaffDesc": MessageLookupByLibrary.simpleMessage(
      "Vede e gestisce solo i propri appuntamenti. Pu√≤ creare prenotazioni assegnate a s√© stesso.",
    ),
    "operatorsRoleViewer": MessageLookupByLibrary.simpleMessage(
      "Visualizzatore",
    ),
    "operatorsRoleViewerDesc": MessageLookupByLibrary.simpleMessage(
      "Pu√≤ consultare appuntamenti, servizi, staff e disponibilit√†. Nessuna modifica consentita.",
    ),
    "operatorsScopeBusiness": MessageLookupByLibrary.simpleMessage(
      "Tutte le sedi",
    ),
    "operatorsScopeBusinessDesc": MessageLookupByLibrary.simpleMessage(
      "Accesso completo a tutte le sedi del business",
    ),
    "operatorsScopeLocations": MessageLookupByLibrary.simpleMessage(
      "Sedi specifiche",
    ),
    "operatorsScopeLocationsDesc": MessageLookupByLibrary.simpleMessage(
      "Accesso limitato alle sedi selezionate",
    ),
    "operatorsScopeLocationsRequired": MessageLookupByLibrary.simpleMessage(
      "Seleziona almeno una sede",
    ),
    "operatorsScopeSelectLocations": MessageLookupByLibrary.simpleMessage(
      "Seleziona sedi",
    ),
    "operatorsScopeTitle": MessageLookupByLibrary.simpleMessage("Accesso"),
    "operatorsSubtitle": MessageLookupByLibrary.simpleMessage(
      "Gestisci chi pu√≤ accedere al gestionale",
    ),
    "operatorsTitle": MessageLookupByLibrary.simpleMessage("Operatori"),
    "operatorsYou": MessageLookupByLibrary.simpleMessage("Tu"),
    "permissionsDescription": MessageLookupByLibrary.simpleMessage(
      "Gestisci accessi e ruoli degli operatori",
    ),
    "permissionsTitle": MessageLookupByLibrary.simpleMessage("Permessi"),
    "planningActive": MessageLookupByLibrary.simpleMessage("Attivo"),
    "planningBiweeklyDuration": m46,
    "planningBiweeklyHours": m47,
    "planningCreateTitle": MessageLookupByLibrary.simpleMessage(
      "Nuovo planning",
    ),
    "planningCurrentWeek": m48,
    "planningDeleteConfirm": MessageLookupByLibrary.simpleMessage(
      "Sei sicuro di voler eliminare questo planning? Gli orari settimanali verranno rimossi.",
    ),
    "planningDeleteTitle": MessageLookupByLibrary.simpleMessage(
      "Elimina planning",
    ),
    "planningEditTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica planning",
    ),
    "planningFuture": MessageLookupByLibrary.simpleMessage("Futuro"),
    "planningHideExpired": MessageLookupByLibrary.simpleMessage(
      "Nascondi planning scaduti",
    ),
    "planningListAdd": MessageLookupByLibrary.simpleMessage(
      "Aggiungi planning",
    ),
    "planningListEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessun planning definito",
    ),
    "planningListTitle": MessageLookupByLibrary.simpleMessage("Planning"),
    "planningOpenEnded": MessageLookupByLibrary.simpleMessage("Senza scadenza"),
    "planningPast": MessageLookupByLibrary.simpleMessage("Passato"),
    "planningSelectDate": MessageLookupByLibrary.simpleMessage(
      "Seleziona data",
    ),
    "planningSetEndDate": MessageLookupByLibrary.simpleMessage(
      "Imposta data fine",
    ),
    "planningShowExpired": m49,
    "planningType": MessageLookupByLibrary.simpleMessage("Tipo planning"),
    "planningTypeBiweekly": MessageLookupByLibrary.simpleMessage(
      "Bisettimanale",
    ),
    "planningTypeUnavailable": MessageLookupByLibrary.simpleMessage(
      "Non disponibile",
    ),
    "planningTypeWeekly": MessageLookupByLibrary.simpleMessage("Settimanale"),
    "planningValidFrom": MessageLookupByLibrary.simpleMessage(
      "Data inizio validit√†",
    ),
    "planningValidFromOnly": m50,
    "planningValidFromTo": m51,
    "planningValidTo": MessageLookupByLibrary.simpleMessage(
      "Data fine validit√†",
    ),
    "planningValidityFrom": m52,
    "planningValidityRange": m53,
    "planningWeekA": MessageLookupByLibrary.simpleMessage("Settimana A"),
    "planningWeekB": MessageLookupByLibrary.simpleMessage("Settimana B"),
    "planningWeeklyDuration": m54,
    "planningWeeklyHours": m55,
    "popularServicesTitle": MessageLookupByLibrary.simpleMessage(
      "I pi√π richiesti",
    ),
    "priceNotAvailable": MessageLookupByLibrary.simpleMessage("N/D"),
    "priceStartingFromPrefix": MessageLookupByLibrary.simpleMessage(
      "a partire da",
    ),
    "priceStartingFromSwitch": MessageLookupByLibrary.simpleMessage(
      "Prezzo \"a partire da\"",
    ),
    "profileChangePassword": MessageLookupByLibrary.simpleMessage(
      "Cambia password",
    ),
    "profileEmailChangeWarning": MessageLookupByLibrary.simpleMessage(
      "Attenzione: cambiando email dovrai usarla per il login",
    ),
    "profileSwitchBusiness": MessageLookupByLibrary.simpleMessage(
      "Cambia business",
    ),
    "profileTitle": MessageLookupByLibrary.simpleMessage("Profilo"),
    "profileUpdateSuccess": MessageLookupByLibrary.simpleMessage(
      "Profilo aggiornato con successo",
    ),
    "recurrenceAfter": MessageLookupByLibrary.simpleMessage("Dopo"),
    "recurrenceClientRequired": MessageLookupByLibrary.simpleMessage(
      "√à necessario selezionare un cliente per gli appuntamenti ricorrenti",
    ),
    "recurrenceConflictForce": MessageLookupByLibrary.simpleMessage(
      "Crea comunque",
    ),
    "recurrenceConflictForceDescription": MessageLookupByLibrary.simpleMessage(
      "Crea gli appuntamenti anche se ci sono sovrapposizioni",
    ),
    "recurrenceConflictHandling": MessageLookupByLibrary.simpleMessage(
      "Sovrapposizioni",
    ),
    "recurrenceConflictSkip": MessageLookupByLibrary.simpleMessage(
      "Salta date con conflitti",
    ),
    "recurrenceConflictSkipDescription": MessageLookupByLibrary.simpleMessage(
      "Non crea appuntamenti se ci sono sovrapposizioni",
    ),
    "recurrenceDay": MessageLookupByLibrary.simpleMessage("giorno"),
    "recurrenceDays": MessageLookupByLibrary.simpleMessage("giorni"),
    "recurrenceEnds": MessageLookupByLibrary.simpleMessage("Termina"),
    "recurrenceEvery": MessageLookupByLibrary.simpleMessage("Ogni"),
    "recurrenceFrequency": MessageLookupByLibrary.simpleMessage("Frequenza"),
    "recurrenceMonth": MessageLookupByLibrary.simpleMessage("mese"),
    "recurrenceMonths": MessageLookupByLibrary.simpleMessage("mesi"),
    "recurrenceNever": MessageLookupByLibrary.simpleMessage("Per un anno"),
    "recurrenceOccurrences": MessageLookupByLibrary.simpleMessage("occorrenze"),
    "recurrenceOnDate": MessageLookupByLibrary.simpleMessage("Il"),
    "recurrencePreviewConfirm": m56,
    "recurrencePreviewConflictForce": MessageLookupByLibrary.simpleMessage(
      "Crea comunque",
    ),
    "recurrencePreviewConflictSkip": MessageLookupByLibrary.simpleMessage(
      "Esclusa per conflitto",
    ),
    "recurrencePreviewConflicts": m57,
    "recurrencePreviewCount": m58,
    "recurrencePreviewHint": MessageLookupByLibrary.simpleMessage(
      "Deseleziona le date che non vuoi creare",
    ),
    "recurrencePreviewSelected": m59,
    "recurrencePreviewTitle": MessageLookupByLibrary.simpleMessage(
      "Anteprima appuntamenti",
    ),
    "recurrenceRepeatBlock": MessageLookupByLibrary.simpleMessage(
      "Ripeti questo blocco",
    ),
    "recurrenceRepeatBooking": MessageLookupByLibrary.simpleMessage(
      "Ripeti questo appuntamento",
    ),
    "recurrenceSelectDate": MessageLookupByLibrary.simpleMessage(
      "Seleziona data",
    ),
    "recurrenceSeriesIcon": MessageLookupByLibrary.simpleMessage(
      "Appuntamento ricorrente",
    ),
    "recurrenceSeriesOf": m60,
    "recurrenceSummaryAppointments": MessageLookupByLibrary.simpleMessage(
      "Appuntamenti:",
    ),
    "recurrenceSummaryConflict": MessageLookupByLibrary.simpleMessage(
      "Saltato per conflitto",
    ),
    "recurrenceSummaryCreated": m61,
    "recurrenceSummaryDeleted": MessageLookupByLibrary.simpleMessage(
      "Eliminato",
    ),
    "recurrenceSummaryError": MessageLookupByLibrary.simpleMessage(
      "Errore nella creazione della serie",
    ),
    "recurrenceSummarySkipped": m62,
    "recurrenceSummaryTitle": MessageLookupByLibrary.simpleMessage(
      "Serie creata",
    ),
    "recurrenceWeek": MessageLookupByLibrary.simpleMessage("settimana"),
    "recurrenceWeeks": MessageLookupByLibrary.simpleMessage("settimane"),
    "recurringDeleteChooseScope": MessageLookupByLibrary.simpleMessage(
      "Quali appuntamenti vuoi eliminare?",
    ),
    "recurringDeleteMessage": m63,
    "recurringDeleteTitle": MessageLookupByLibrary.simpleMessage(
      "Elimina appuntamento ricorrente",
    ),
    "recurringEditChooseScope": MessageLookupByLibrary.simpleMessage(
      "Quali appuntamenti vuoi modificare?",
    ),
    "recurringEditMessage": m64,
    "recurringEditTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica appuntamento ricorrente",
    ),
    "recurringScopeAll": MessageLookupByLibrary.simpleMessage("Tutti"),
    "recurringScopeOnlyThis": MessageLookupByLibrary.simpleMessage(
      "Solo questo",
    ),
    "recurringScopeThisAndFuture": MessageLookupByLibrary.simpleMessage(
      "Questo e futuri",
    ),
    "removeClient": MessageLookupByLibrary.simpleMessage("Rimuovi cliente"),
    "reorderCategoriesLabel": MessageLookupByLibrary.simpleMessage("Categorie"),
    "reorderHelpDescription": MessageLookupByLibrary.simpleMessage(
      "Riordina categorie e servizi trascinandoli: l‚Äôordine sar√† lo stesso anche nella prenotazione online. Seleziona se ordinare categorie o servizi.",
    ),
    "reorderServicesLabel": MessageLookupByLibrary.simpleMessage("Servizi"),
    "reorderTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica ordinamento",
    ),
    "reportsByDayOfWeek": MessageLookupByLibrary.simpleMessage(
      "Per giorno della settimana",
    ),
    "reportsByHour": MessageLookupByLibrary.simpleMessage("Per fascia oraria"),
    "reportsByLocation": MessageLookupByLibrary.simpleMessage("Per sede"),
    "reportsByPeriod": MessageLookupByLibrary.simpleMessage("Per periodo"),
    "reportsByService": MessageLookupByLibrary.simpleMessage("Per servizio"),
    "reportsByStaff": MessageLookupByLibrary.simpleMessage("Per operatore"),
    "reportsColAppointments": MessageLookupByLibrary.simpleMessage(
      "Appuntamenti",
    ),
    "reportsColAvailableHours": MessageLookupByLibrary.simpleMessage(
      "Effettive",
    ),
    "reportsColAvgDuration": MessageLookupByLibrary.simpleMessage(
      "Durata media",
    ),
    "reportsColAvgRevenue": MessageLookupByLibrary.simpleMessage("Media"),
    "reportsColBlockedHours": MessageLookupByLibrary.simpleMessage("Blocchi"),
    "reportsColCategory": MessageLookupByLibrary.simpleMessage("Categoria"),
    "reportsColDay": MessageLookupByLibrary.simpleMessage("Giorno"),
    "reportsColHour": MessageLookupByLibrary.simpleMessage("Ora"),
    "reportsColHours": MessageLookupByLibrary.simpleMessage("Ore"),
    "reportsColLocation": MessageLookupByLibrary.simpleMessage("Sede"),
    "reportsColOffHours": MessageLookupByLibrary.simpleMessage("Ferie/Assenze"),
    "reportsColPercentage": MessageLookupByLibrary.simpleMessage("%"),
    "reportsColPeriod": MessageLookupByLibrary.simpleMessage("Periodo"),
    "reportsColRevenue": MessageLookupByLibrary.simpleMessage("Incasso"),
    "reportsColScheduledHours": MessageLookupByLibrary.simpleMessage(
      "Programmate",
    ),
    "reportsColService": MessageLookupByLibrary.simpleMessage("Servizio"),
    "reportsColStaff": MessageLookupByLibrary.simpleMessage("Operatore"),
    "reportsColUtilization": MessageLookupByLibrary.simpleMessage(
      "Occupazione",
    ),
    "reportsColWorkedHours": MessageLookupByLibrary.simpleMessage("Prenotate"),
    "reportsFilterLocations": MessageLookupByLibrary.simpleMessage("Sedi"),
    "reportsFilterServices": MessageLookupByLibrary.simpleMessage("Servizi"),
    "reportsFilterStaff": MessageLookupByLibrary.simpleMessage("Staff"),
    "reportsFilterStatus": MessageLookupByLibrary.simpleMessage("Stato"),
    "reportsFullPeriodToggle": MessageLookupByLibrary.simpleMessage(
      "Includi intero periodo (anche futuro)",
    ),
    "reportsNoData": MessageLookupByLibrary.simpleMessage(
      "Nessun dato disponibile",
    ),
    "reportsOccupancyPercentage": MessageLookupByLibrary.simpleMessage(
      "Occupazione",
    ),
    "reportsPresetCustom": MessageLookupByLibrary.simpleMessage(
      "Scegli periodo",
    ),
    "reportsPresetLast3Months": MessageLookupByLibrary.simpleMessage(
      "Ultimi 3 mesi",
    ),
    "reportsPresetLast6Months": MessageLookupByLibrary.simpleMessage(
      "Ultimi 6 mesi",
    ),
    "reportsPresetLastMonth": MessageLookupByLibrary.simpleMessage(
      "Mese scorso",
    ),
    "reportsPresetLastYear": MessageLookupByLibrary.simpleMessage(
      "Anno precedente",
    ),
    "reportsPresetMonth": MessageLookupByLibrary.simpleMessage("Mese corrente"),
    "reportsPresetQuarter": MessageLookupByLibrary.simpleMessage(
      "Trimestre corrente",
    ),
    "reportsPresetSemester": MessageLookupByLibrary.simpleMessage(
      "Semestre corrente",
    ),
    "reportsPresetToday": MessageLookupByLibrary.simpleMessage("Oggi"),
    "reportsPresetWeek": MessageLookupByLibrary.simpleMessage(
      "Questa settimana",
    ),
    "reportsPresetYear": MessageLookupByLibrary.simpleMessage("Anno corrente"),
    "reportsPresets": MessageLookupByLibrary.simpleMessage("Preset periodo"),
    "reportsTabAppointments": MessageLookupByLibrary.simpleMessage(
      "Appuntamenti",
    ),
    "reportsTabStaff": MessageLookupByLibrary.simpleMessage("Team"),
    "reportsTitle": MessageLookupByLibrary.simpleMessage("Report"),
    "reportsTotalAppointments": MessageLookupByLibrary.simpleMessage(
      "Appuntamenti",
    ),
    "reportsTotalHours": MessageLookupByLibrary.simpleMessage("Ore lavorate"),
    "reportsTotalRevenue": MessageLookupByLibrary.simpleMessage("Incasso"),
    "reportsUniqueClients": MessageLookupByLibrary.simpleMessage(
      "Clienti unici",
    ),
    "reportsWorkHoursAvailable": MessageLookupByLibrary.simpleMessage(
      "Effettive",
    ),
    "reportsWorkHoursBlocked": MessageLookupByLibrary.simpleMessage("Blocchi"),
    "reportsWorkHoursOff": MessageLookupByLibrary.simpleMessage(
      "Ferie/Assenze",
    ),
    "reportsWorkHoursScheduled": MessageLookupByLibrary.simpleMessage(
      "Programmate",
    ),
    "reportsWorkHoursSubtitle": MessageLookupByLibrary.simpleMessage(
      "Riepilogo ore programmate, lavorate e assenze",
    ),
    "reportsWorkHoursTitle": MessageLookupByLibrary.simpleMessage("Staff"),
    "reportsWorkHoursUtilization": MessageLookupByLibrary.simpleMessage(
      "Occupazione",
    ),
    "reportsWorkHoursWorked": MessageLookupByLibrary.simpleMessage("Prenotate"),
    "resourceDeleteConfirm": MessageLookupByLibrary.simpleMessage(
      "Eliminare questa risorsa?",
    ),
    "resourceDeleteWarning": MessageLookupByLibrary.simpleMessage(
      "I servizi che usano questa risorsa non saranno pi√π vincolati alla sua disponibilit√†",
    ),
    "resourceEdit": MessageLookupByLibrary.simpleMessage("Modifica risorsa"),
    "resourceNameLabel": MessageLookupByLibrary.simpleMessage("Nome risorsa"),
    "resourceNew": MessageLookupByLibrary.simpleMessage("Nuova risorsa"),
    "resourceNoServicesSelected": MessageLookupByLibrary.simpleMessage(
      "Nessun servizio associato",
    ),
    "resourceNoneLabel": MessageLookupByLibrary.simpleMessage(
      "Nessuna risorsa richiesta",
    ),
    "resourceNoteLabel": MessageLookupByLibrary.simpleMessage(
      "Note (opzionale)",
    ),
    "resourceQuantityLabel": MessageLookupByLibrary.simpleMessage(
      "Quantit√† disponibile",
    ),
    "resourceQuantityRequired": MessageLookupByLibrary.simpleMessage(
      "Qt√† richiesta",
    ),
    "resourceSelectLabel": MessageLookupByLibrary.simpleMessage(
      "Seleziona risorse",
    ),
    "resourceSelectServices": MessageLookupByLibrary.simpleMessage(
      "Seleziona servizi",
    ),
    "resourceServiceCountPlural": m65,
    "resourceServiceCountSingular": MessageLookupByLibrary.simpleMessage(
      "1 servizio",
    ),
    "resourceServicesLabel": MessageLookupByLibrary.simpleMessage(
      "Servizi che usano questa risorsa",
    ),
    "resourceTypeLabel": MessageLookupByLibrary.simpleMessage(
      "Tipo (opzionale)",
    ),
    "resourcesEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessuna risorsa configurata per questa sede",
    ),
    "resourcesEmptyHint": MessageLookupByLibrary.simpleMessage(
      "Le risorse sono attrezzature o spazi (es. cabine, lettini) che possono essere associati ai servizi",
    ),
    "resourcesTitle": MessageLookupByLibrary.simpleMessage("Risorse"),
    "searchClientPlaceholder": MessageLookupByLibrary.simpleMessage(
      "Cerca cliente...",
    ),
    "searchServices": MessageLookupByLibrary.simpleMessage("Cerca servizio..."),
    "selectClientTitle": MessageLookupByLibrary.simpleMessage(
      "Seleziona cliente",
    ),
    "selectService": MessageLookupByLibrary.simpleMessage(
      "Seleziona un servizio",
    ),
    "selectStaffTitle": MessageLookupByLibrary.simpleMessage("Seleziona team"),
    "serviceColorLabel": MessageLookupByLibrary.simpleMessage(
      "Colore servizio",
    ),
    "serviceDuplicateCopyWord": MessageLookupByLibrary.simpleMessage("Copia"),
    "serviceDuplicateError": MessageLookupByLibrary.simpleMessage(
      "Esiste gi√† un servizio con questo nome",
    ),
    "serviceEligibleStaffCount": m66,
    "serviceEligibleStaffNone": MessageLookupByLibrary.simpleMessage(
      "Nessun membro abilitato",
    ),
    "serviceLocationsCount": m67,
    "serviceLocationsLabel": MessageLookupByLibrary.simpleMessage(
      "Sedi disponibili",
    ),
    "servicePackageActiveLabel": MessageLookupByLibrary.simpleMessage(
      "Pacchetto attivo",
    ),
    "servicePackageBrokenLabel": MessageLookupByLibrary.simpleMessage(
      "Non valido",
    ),
    "servicePackageCreatedMessage": MessageLookupByLibrary.simpleMessage(
      "Il pacchetto √® stato creato.",
    ),
    "servicePackageCreatedTitle": MessageLookupByLibrary.simpleMessage(
      "Pacchetto creato",
    ),
    "servicePackageDeleteError": MessageLookupByLibrary.simpleMessage(
      "Errore durante l\'eliminazione del pacchetto.",
    ),
    "servicePackageDeleteMessage": MessageLookupByLibrary.simpleMessage(
      "Questa azione non pu√≤ essere annullata.",
    ),
    "servicePackageDeleteTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare il pacchetto?",
    ),
    "servicePackageDeletedMessage": MessageLookupByLibrary.simpleMessage(
      "Il pacchetto √® stato eliminato.",
    ),
    "servicePackageDeletedTitle": MessageLookupByLibrary.simpleMessage(
      "Pacchetto eliminato",
    ),
    "servicePackageDescriptionLabel": MessageLookupByLibrary.simpleMessage(
      "Descrizione",
    ),
    "servicePackageEditTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica pacchetto",
    ),
    "servicePackageExpandError": MessageLookupByLibrary.simpleMessage(
      "Impossibile espandere il pacchetto selezionato.",
    ),
    "servicePackageInactiveLabel": MessageLookupByLibrary.simpleMessage(
      "Inattivo",
    ),
    "servicePackageNameLabel": MessageLookupByLibrary.simpleMessage(
      "Nome pacchetto",
    ),
    "servicePackageNewMenu": MessageLookupByLibrary.simpleMessage(
      "Nuovo pacchetto",
    ),
    "servicePackageNewTitle": MessageLookupByLibrary.simpleMessage(
      "Nuovo pacchetto",
    ),
    "servicePackageNoServices": MessageLookupByLibrary.simpleMessage(
      "Nessun servizio selezionato",
    ),
    "servicePackageOrderLabel": MessageLookupByLibrary.simpleMessage(
      "Ordine servizi",
    ),
    "servicePackageOverrideDurationLabel": MessageLookupByLibrary.simpleMessage(
      "Durata pacchetto (min)",
    ),
    "servicePackageOverridePriceLabel": MessageLookupByLibrary.simpleMessage(
      "Prezzo pacchetto",
    ),
    "servicePackageSaveError": MessageLookupByLibrary.simpleMessage(
      "Errore nel salvataggio del pacchetto.",
    ),
    "servicePackageServicesLabel": MessageLookupByLibrary.simpleMessage(
      "Servizi inclusi",
    ),
    "servicePackageServicesRequired": MessageLookupByLibrary.simpleMessage(
      "Seleziona almeno un servizio",
    ),
    "servicePackageUpdatedMessage": MessageLookupByLibrary.simpleMessage(
      "Il pacchetto √® stato aggiornato.",
    ),
    "servicePackageUpdatedTitle": MessageLookupByLibrary.simpleMessage(
      "Pacchetto aggiornato",
    ),
    "servicePackagesEmptyState": MessageLookupByLibrary.simpleMessage(
      "Nessun pacchetto disponibile",
    ),
    "servicePackagesTabLabel": MessageLookupByLibrary.simpleMessage(
      "Pacchetti",
    ),
    "servicePackagesTitle": MessageLookupByLibrary.simpleMessage("Pacchetti"),
    "serviceRequiredResourcesLabel": MessageLookupByLibrary.simpleMessage(
      "Risorse richieste",
    ),
    "serviceSeedCategoryBodyDescription": MessageLookupByLibrary.simpleMessage(
      "Servizi dedicati al benessere del corpo",
    ),
    "serviceSeedCategoryBodyName": MessageLookupByLibrary.simpleMessage(
      "Trattamenti Corpo",
    ),
    "serviceSeedCategoryFaceDescription": MessageLookupByLibrary.simpleMessage(
      "Cura estetica e rigenerante per il viso",
    ),
    "serviceSeedCategoryFaceName": MessageLookupByLibrary.simpleMessage(
      "Trattamenti Viso",
    ),
    "serviceSeedCategorySportsDescription":
        MessageLookupByLibrary.simpleMessage(
          "Percorsi pensati per atleti e persone attive",
        ),
    "serviceSeedCategorySportsName": MessageLookupByLibrary.simpleMessage(
      "Trattamenti Sportivi",
    ),
    "serviceSeedServiceFaceDescription": MessageLookupByLibrary.simpleMessage(
      "Pulizia e trattamento illuminante",
    ),
    "serviceSeedServiceFaceName": MessageLookupByLibrary.simpleMessage(
      "Trattamento Viso",
    ),
    "serviceSeedServiceRelaxDescription": MessageLookupByLibrary.simpleMessage(
      "Trattamento rilassante da 30 minuti",
    ),
    "serviceSeedServiceRelaxName": MessageLookupByLibrary.simpleMessage(
      "Massaggio Relax",
    ),
    "serviceSeedServiceSportDescription": MessageLookupByLibrary.simpleMessage(
      "Trattamento decontratturante intensivo",
    ),
    "serviceSeedServiceSportName": MessageLookupByLibrary.simpleMessage(
      "Massaggio Sportivo",
    ),
    "serviceStartsAfterMidnight": MessageLookupByLibrary.simpleMessage(
      "Impossibile aggiungere il servizio: l\'orario supera la mezzanotte. Modifica l\'orario di inizio o l\'operatore.",
    ),
    "servicesLabel": MessageLookupByLibrary.simpleMessage("servizi"),
    "servicesNewServiceMenu": MessageLookupByLibrary.simpleMessage(
      "Nuovo servizio",
    ),
    "servicesSelectedCount": m68,
    "servicesTabLabel": MessageLookupByLibrary.simpleMessage("Servizi"),
    "setPriceToEnable": MessageLookupByLibrary.simpleMessage(
      "Imposta un prezzo per abilitarlo",
    ),
    "shiftDeleteAll": MessageLookupByLibrary.simpleMessage(
      "Elimina tutti questi turni",
    ),
    "shiftDeleteAllDesc": m69,
    "shiftDeleteThisOnly": MessageLookupByLibrary.simpleMessage(
      "Elimina solo questo turno",
    ),
    "shiftDeleteThisOnlyDesc": m70,
    "shiftEditAll": MessageLookupByLibrary.simpleMessage(
      "Modifica tutti questi turni",
    ),
    "shiftEditAllDesc": m71,
    "shiftEditThisOnly": MessageLookupByLibrary.simpleMessage(
      "Modifica solo questo turno",
    ),
    "shiftEditThisOnlyDesc": m72,
    "shiftEditTitle": MessageLookupByLibrary.simpleMessage("Modifica turno"),
    "shiftEndTime": MessageLookupByLibrary.simpleMessage("Ora fine"),
    "shiftStartTime": MessageLookupByLibrary.simpleMessage("Ora inizio"),
    "showAllServices": MessageLookupByLibrary.simpleMessage(
      "Mostra tutti i servizi",
    ),
    "sortByCreatedAtAsc": MessageLookupByLibrary.simpleMessage(
      "Data creazione (vecchi)",
    ),
    "sortByCreatedAtDesc": MessageLookupByLibrary.simpleMessage(
      "Data creazione (nuovi)",
    ),
    "sortByLastNameAsc": MessageLookupByLibrary.simpleMessage("Cognome (A-Z)"),
    "sortByLastNameDesc": MessageLookupByLibrary.simpleMessage("Cognome (Z-A)"),
    "sortByNameAsc": MessageLookupByLibrary.simpleMessage("Nome (A-Z)"),
    "sortByNameDesc": MessageLookupByLibrary.simpleMessage("Nome (Z-A)"),
    "sortByTitle": MessageLookupByLibrary.simpleMessage("Ordina per"),
    "staffEditHours": MessageLookupByLibrary.simpleMessage("Modifica orari"),
    "staffFilterAllTeam": MessageLookupByLibrary.simpleMessage("Tutto il team"),
    "staffFilterOnDuty": MessageLookupByLibrary.simpleMessage("Team di turno"),
    "staffFilterSelectMembers": MessageLookupByLibrary.simpleMessage(
      "Seleziona membri del team",
    ),
    "staffFilterTitle": MessageLookupByLibrary.simpleMessage("Filtra team"),
    "staffFilterTooltip": MessageLookupByLibrary.simpleMessage("Filtra team"),
    "staffHubAvailabilitySubtitle": MessageLookupByLibrary.simpleMessage(
      "Configura gli orari di lavoro settimanali",
    ),
    "staffHubAvailabilityTitle": MessageLookupByLibrary.simpleMessage(
      "Disponibilit√†",
    ),
    "staffHubNotYetAvailable": MessageLookupByLibrary.simpleMessage(
      "Non ancora disponibile",
    ),
    "staffHubStatsSubtitle": MessageLookupByLibrary.simpleMessage(
      "Performance e carichi di lavoro",
    ),
    "staffHubStatsTitle": MessageLookupByLibrary.simpleMessage("Statistiche"),
    "staffHubTeamSubtitle": MessageLookupByLibrary.simpleMessage(
      "Gestione membri e ruoli",
    ),
    "staffHubTeamTitle": MessageLookupByLibrary.simpleMessage("Team"),
    "staffNotBookableOnlineMessage": MessageLookupByLibrary.simpleMessage(
      "Questo membro del team non √® abilitato alle prenotazioni online. Puoi modificare l‚Äôimpostazione dal form di modifica dello staff.",
    ),
    "staffNotBookableOnlineTitle": MessageLookupByLibrary.simpleMessage(
      "Non prenotabile online",
    ),
    "staffNotBookableOnlineTooltip": MessageLookupByLibrary.simpleMessage(
      "Non prenotabile online",
    ),
    "staffScreenPlaceholder": MessageLookupByLibrary.simpleMessage(
      "Schermata Team",
    ),
    "statusCancelled": MessageLookupByLibrary.simpleMessage("Cancellato"),
    "statusCompleted": MessageLookupByLibrary.simpleMessage("Completato"),
    "statusConfirmed": MessageLookupByLibrary.simpleMessage("Confermato"),
    "switchBusiness": MessageLookupByLibrary.simpleMessage("Cambia"),
    "teamAddStaff": MessageLookupByLibrary.simpleMessage("Aggiungi membro"),
    "teamChooseLocationSingleButton": MessageLookupByLibrary.simpleMessage(
      "Seleziona la sede",
    ),
    "teamChooseLocationsButton": MessageLookupByLibrary.simpleMessage(
      "Seleziona sedi",
    ),
    "teamDeleteLocationBlockedMessage": MessageLookupByLibrary.simpleMessage(
      "Rimuovi prima tutti i membri del team associati.",
    ),
    "teamDeleteLocationBlockedTitle": MessageLookupByLibrary.simpleMessage(
      "Impossibile eliminare la sede",
    ),
    "teamDeleteLocationMessage": MessageLookupByLibrary.simpleMessage(
      "La sede verr√† rimossa dal team. L\'operazione non pu√≤ essere annullata.",
    ),
    "teamDeleteLocationTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare la sede?",
    ),
    "teamDeleteStaffMessage": MessageLookupByLibrary.simpleMessage(
      "Il membro verr√† rimosso dal team. L\'operazione non pu√≤ essere annullata.",
    ),
    "teamDeleteStaffTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare il membro del team?",
    ),
    "teamEditLocationTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica sede",
    ),
    "teamEditStaffTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica membro del team",
    ),
    "teamEligibleServicesCount": m73,
    "teamEligibleServicesLabel": MessageLookupByLibrary.simpleMessage(
      "Servizi abilitati",
    ),
    "teamEligibleServicesNone": MessageLookupByLibrary.simpleMessage(
      "Nessun servizio abilitato",
    ),
    "teamEligibleStaffLabel": MessageLookupByLibrary.simpleMessage(
      "Team abilitato",
    ),
    "teamLocationAddressLabel": MessageLookupByLibrary.simpleMessage(
      "Indirizzo",
    ),
    "teamLocationAllowCustomerChooseStaffHint":
        MessageLookupByLibrary.simpleMessage(
          "Se disattivato, il sistema assegna automaticamente l\'operatore",
        ),
    "teamLocationAllowCustomerChooseStaffLabel":
        MessageLookupByLibrary.simpleMessage(
          "Consenti ai clienti di scegliere l\'operatore",
        ),
    "teamLocationBookingLimitsSection": MessageLookupByLibrary.simpleMessage(
      "Limiti prenotazione online",
    ),
    "teamLocationCancellationHoursAlways": MessageLookupByLibrary.simpleMessage(
      "Sempre",
    ),
    "teamLocationCancellationHoursHint": MessageLookupByLibrary.simpleMessage(
      "Tempo minimo prima dell\'appuntamento entro cui il cliente pu√≤ ancora modificare o cancellare",
    ),
    "teamLocationCancellationHoursLabel": MessageLookupByLibrary.simpleMessage(
      "Finestra modifica/cancellazione",
    ),
    "teamLocationCancellationHoursNever": MessageLookupByLibrary.simpleMessage(
      "Mai",
    ),
    "teamLocationCancellationHoursUseBusiness":
        MessageLookupByLibrary.simpleMessage("Usa policy del business"),
    "teamLocationCancellationHoursUseBusinessWithValue": m74,
    "teamLocationDays": m75,
    "teamLocationEmailHint": MessageLookupByLibrary.simpleMessage(
      "Email per notifiche ai clienti",
    ),
    "teamLocationEmailLabel": MessageLookupByLibrary.simpleMessage("Email"),
    "teamLocationHours": m76,
    "teamLocationIsActiveHint": MessageLookupByLibrary.simpleMessage(
      "Se disattivata, la sede non sar√† visibile ai clienti",
    ),
    "teamLocationIsActiveLabel": MessageLookupByLibrary.simpleMessage(
      "Sede attiva",
    ),
    "teamLocationLabel": MessageLookupByLibrary.simpleMessage("Sede"),
    "teamLocationMaxBookingAdvanceHint": MessageLookupByLibrary.simpleMessage(
      "Fino a quanto tempo in anticipo possono prenotare",
    ),
    "teamLocationMaxBookingAdvanceLabel": MessageLookupByLibrary.simpleMessage(
      "Prenotazione massima anticipata",
    ),
    "teamLocationMinBookingNoticeHint": MessageLookupByLibrary.simpleMessage(
      "Quanto tempo prima devono prenotare i clienti",
    ),
    "teamLocationMinBookingNoticeLabel": MessageLookupByLibrary.simpleMessage(
      "Preavviso minimo prenotazione",
    ),
    "teamLocationMinGapHint": MessageLookupByLibrary.simpleMessage(
      "Non mostrare orari che lasciano meno di questo tempo libero",
    ),
    "teamLocationMinGapLabel": MessageLookupByLibrary.simpleMessage(
      "Gap minimo accettabile",
    ),
    "teamLocationMinutes": m77,
    "teamLocationNameLabel": MessageLookupByLibrary.simpleMessage("Nome sede"),
    "teamLocationSlotDisplayModeAll": MessageLookupByLibrary.simpleMessage(
      "Massima disponibilit√†",
    ),
    "teamLocationSlotDisplayModeAllHint": MessageLookupByLibrary.simpleMessage(
      "Mostra tutti gli orari disponibili",
    ),
    "teamLocationSlotDisplayModeLabel": MessageLookupByLibrary.simpleMessage(
      "Modalit√† visualizzazione",
    ),
    "teamLocationSlotDisplayModeMinGap": MessageLookupByLibrary.simpleMessage(
      "Riduci spazi vuoti",
    ),
    "teamLocationSlotDisplayModeMinGapHint":
        MessageLookupByLibrary.simpleMessage(
          "Nasconde orari che creerebbero buchi troppo piccoli",
        ),
    "teamLocationSlotIntervalHint": MessageLookupByLibrary.simpleMessage(
      "Ogni quanti minuti mostrare un orario disponibile nelle prenotazioni online (non influisce sugli slot del planning staff)",
    ),
    "teamLocationSlotIntervalLabel": MessageLookupByLibrary.simpleMessage(
      "Intervallo tra gli orari",
    ),
    "teamLocationSmartSlotDescription": MessageLookupByLibrary.simpleMessage(
      "Configura come vengono mostrati gli orari disponibili ai clienti che prenotano online. Non modifica il planning dello staff.",
    ),
    "teamLocationSmartSlotSection": MessageLookupByLibrary.simpleMessage(
      "Fasce orarie intelligenti",
    ),
    "teamLocationsLabel": MessageLookupByLibrary.simpleMessage("Sedi"),
    "teamNewLocationTitle": MessageLookupByLibrary.simpleMessage("Nuova sede"),
    "teamNewStaffTitle": MessageLookupByLibrary.simpleMessage(
      "Nuovo membro del team",
    ),
    "teamNoStaffInLocation": MessageLookupByLibrary.simpleMessage(
      "Nessun membro in questa sede",
    ),
    "teamReorderHelpDescription": MessageLookupByLibrary.simpleMessage(
      "Riordina sedi e membri del team trascinandoli. Seleziona se ordinare sedi o team. L‚Äôordine sar√† lo stesso anche nella sezione agenda.",
    ),
    "teamSelectAllLocations": MessageLookupByLibrary.simpleMessage(
      "Seleziona tutto",
    ),
    "teamSelectAllServices": MessageLookupByLibrary.simpleMessage(
      "Seleziona tutto",
    ),
    "teamSelectedServicesButton": MessageLookupByLibrary.simpleMessage(
      "Servizi selezionati",
    ),
    "teamSelectedServicesCount": m78,
    "teamServicesLabel": MessageLookupByLibrary.simpleMessage("Servizi"),
    "teamStaffBookableOnlineLabel": MessageLookupByLibrary.simpleMessage(
      "Abilitato alle prenotazioni online",
    ),
    "teamStaffColorLabel": MessageLookupByLibrary.simpleMessage("Colore"),
    "teamStaffLabel": MessageLookupByLibrary.simpleMessage("Team"),
    "teamStaffLocationsLabel": MessageLookupByLibrary.simpleMessage(
      "Sedi associate",
    ),
    "teamStaffMultiLocationWarning": MessageLookupByLibrary.simpleMessage(
      "Se il membro lavora su pi√π sedi, ricorda di allineare disponibilit√† e orari con le sedi selezionate.",
    ),
    "teamStaffNameLabel": MessageLookupByLibrary.simpleMessage("Nome"),
    "teamStaffSurnameLabel": MessageLookupByLibrary.simpleMessage("Cognome"),
    "validationInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Email non valida",
    ),
    "validationInvalidNumber": MessageLookupByLibrary.simpleMessage(
      "Numero non valido",
    ),
    "validationInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Telefono non valido",
    ),
    "validationNameOrLastNameRequired": MessageLookupByLibrary.simpleMessage(
      "Inserire almeno nome o cognome",
    ),
    "validationRequired": MessageLookupByLibrary.simpleMessage("Richiesto"),
    "weeklyScheduleAddShift": MessageLookupByLibrary.simpleMessage(
      "Aggiungi turno",
    ),
    "weeklyScheduleFor": MessageLookupByLibrary.simpleMessage("-"),
    "weeklyScheduleNotWorking": MessageLookupByLibrary.simpleMessage(
      "Non lavora",
    ),
    "weeklyScheduleRemoveShift": MessageLookupByLibrary.simpleMessage(
      "Rimuovi turno",
    ),
    "weeklyScheduleTitle": MessageLookupByLibrary.simpleMessage(
      "Orario settimanale",
    ),
    "weeklyScheduleTotalHours": m79,
  };
}
--- FILE: lib/core/l10n/intl/messages_en.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that provides messages for a en locale. All the
// messages from the main program should be duplicated here with the same
// function name.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:unnecessary_brace_in_string_interps, unnecessary_new
// ignore_for_file:prefer_single_quotes,comment_references, directives_ordering
// ignore_for_file:annotate_overrides,prefer_generic_function_type_aliases
// ignore_for_file:unused_import, file_names, avoid_escaping_inner_quotes
// ignore_for_file:unnecessary_string_interpolations, unnecessary_string_escapes

import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = new MessageLookup();

typedef String MessageIfAbsent(String messageStr, List<dynamic> args);

class MessageLookup extends MessageLookupByLibrary {
  String get localeName => 'en';

  static String m0(name) => "Availability ‚Äì ${name}";

  static String m1(fields) => "Changed fields: ${fields}";

  static String m2(type) => "Email sent of type: ${type}";

  static String m3(channel) => "Type: ${channel}";

  static String m4(email) => "Recipient: ${email}";

  static String m5(dateTime) => "Sent at: ${dateTime}";

  static String m6(subject) => "Subject: ${subject}";

  static String m7(count) => "${count} notifications";

  static String m8(date, time, staffName) =>
      "The booking will be moved to ${date} at ${time} for ${staffName}.";

  static String m9(duration) => "Total duration: ${duration}";

  static String m10(price) => "Total: ${price}";

  static String m11(count) => "${count} bookings";

  static String m12(confirmed, capacity, waitlist) =>
      "Confirmed: ${confirmed}/${capacity} ‚Ä¢ Waitlist: ${waitlist}";

  static String m13(customerId) => "Customer ${customerId}";

  static String m14(count) => "Create ${count} schedules";

  static String m15(clientName) => "${clientName}\'s appointments";

  static String m16(count) =>
      "${Intl.plural(count, one: '1 day', other: '${count} days')}";

  static String m17(count) =>
      "Import ${Intl.plural(count, one: '1 holiday', other: '${count} holidays')}";

  static String m18(count) =>
      "${Intl.plural(count, one: '1 holiday already added', other: '${count} holidays already added')} (marked with ‚úì)";

  static String m19(count) =>
      "${Intl.plural(count, one: '1 holiday imported', other: '${count} holidays imported')}";

  static String m20(count) =>
      "for a total of ${Intl.plural(count, one: '1 day', other: '${count} days')}";

  static String m21(points) => "Points balance: ${points}";

  static String m22(count) => "${count} visits";

  static String m23(hours) => "${hours} hour";

  static String m24(hours, minutes) => "${hours} hour ${minutes} min";

  static String m25(minutes) => "${minutes} min";

  static String m26(id) => "Exception not found: ${id}";

  static String m27(factor) => "No builder available for ${factor}";

  static String m28(path) => "Page not found: ${path}";

  static String m29(count) =>
      "${count} ${Intl.plural(count, one: 'day', other: 'days')}";

  static String m30(dates) => "Some days were not saved: ${dates}.";

  static String m31(details) => "Some days were not saved: ${details}.";

  static String m32(hours) => "${hours}h";

  static String m33(hours, minutes) => "${hours}h ${minutes}m";

  static String m34(businessName, role) =>
      "You were invited to collaborate with ${businessName} as ${role}.";

  static String m35(date) => "Last visit: ${date}";

  static String m36(newTime, staffName) =>
      "The appointment will be moved to ${newTime} for ${staffName}.";

  static String m37(date) => "Accepted on ${date}";

  static String m38(email) =>
      "Do you want to permanently delete the invite for ${email}?";

  static String m39(date) => "Expires on ${date}";

  static String m40(email) => "Invite sent to ${email}";

  static String m41(name) => "Invited by ${name}";

  static String m42(count) => "${count} archived invites";

  static String m43(count) => "${count} pending invites";

  static String m44(name) => "Do you want to remove ${name} from the team?";

  static String m45(email) => "Do you want to revoke the invite for ${email}?";

  static String m46(durationA, durationB, totalDuration) =>
      "Week A: ${durationA} | Week B: ${durationB} | Tot: ${totalDuration}";

  static String m47(hoursA, hoursB, total) =>
      "Week A: ${hoursA}h | Week B: ${hoursB}h | Tot: ${total}h";

  static String m48(week) => "Current week: ${week}";

  static String m49(count) => "Show expired (${count})";

  static String m50(from) => "Valid from ${from}";

  static String m51(from, to) => "Valid from ${from} to ${to}";

  static String m52(from) => "From ${from}";

  static String m53(from, to) => "From ${from} to ${to}";

  static String m54(duration) => "${duration}/week";

  static String m55(hours) => "${hours}h/week";

  static String m56(count) => "Create ${count} appointments";

  static String m57(count) => "${count} conflicts";

  static String m58(count) => "${count} appointments";

  static String m59(count) => "${count} selected";

  static String m60(index, total) => "${index} of ${total}";

  static String m61(count) => "${count} appointments created";

  static String m62(count) => "${count} skipped due to conflicts";

  static String m63(index, total) =>
      "This is appointment ${index} of ${total} in the series.";

  static String m64(index, total) =>
      "This is appointment ${index} of ${total} in the series.";

  static String m65(count) => "${count} services";

  static String m66(count) => "${count} eligible team members";

  static String m67(count, total) => "${count} of ${total} locations";

  static String m68(count) =>
      "${Intl.plural(count, one: '1 service selected', other: '${count} services selected')}";

  static String m69(dayName) =>
      "Delete the weekly time slot for every ${dayName}";

  static String m70(date) => "Delete only the time slot of ${date}";

  static String m71(dayName) =>
      "Edit the weekly time slot for every ${dayName}";

  static String m72(date) => "Edit only the time slot of ${date}";

  static String m73(count) => "${count} eligible services";

  static String m74(value) => "Use business policy (${value})";

  static String m75(count) =>
      "${Intl.plural(count, one: '1 day', other: '${count} days')}";

  static String m76(count) =>
      "${Intl.plural(count, one: '1 hour', other: '${count} hours')}";

  static String m77(count) =>
      "${Intl.plural(count, one: '1 minute', other: '${count} minutes')}";

  static String m78(selected, total) => "${selected} of ${total}";

  static String m79(hours) => "${hours} hours total";

  final messages = _notInlinedMessages(_notInlinedMessages);
  static Map<String, Function> _notInlinedMessages(_) => <String, Function>{
    "actionApply": MessageLookupByLibrary.simpleMessage("Apply"),
    "actionCancel": MessageLookupByLibrary.simpleMessage("Cancel"),
    "actionClose": MessageLookupByLibrary.simpleMessage("Close"),
    "actionConfirm": MessageLookupByLibrary.simpleMessage("Confirm"),
    "actionDelete": MessageLookupByLibrary.simpleMessage("Delete"),
    "actionDeleteBooking": MessageLookupByLibrary.simpleMessage(
      "Delete booking",
    ),
    "actionDeselectAll": MessageLookupByLibrary.simpleMessage("Deselect all"),
    "actionDiscard": MessageLookupByLibrary.simpleMessage("Cancel"),
    "actionEdit": MessageLookupByLibrary.simpleMessage("Edit"),
    "actionKeepEditing": MessageLookupByLibrary.simpleMessage("Keep editing"),
    "actionRefresh": MessageLookupByLibrary.simpleMessage("Refresh"),
    "actionReschedule": MessageLookupByLibrary.simpleMessage("Reschedule"),
    "actionRetry": MessageLookupByLibrary.simpleMessage("Retry"),
    "actionSave": MessageLookupByLibrary.simpleMessage("Save"),
    "actionSelectAll": MessageLookupByLibrary.simpleMessage("Select all"),
    "addClientToAppointment": MessageLookupByLibrary.simpleMessage(
      "Add a client to the appointment",
    ),
    "addPackage": MessageLookupByLibrary.simpleMessage("Add package"),
    "addService": MessageLookupByLibrary.simpleMessage("Add service"),
    "addServiceTooltip": MessageLookupByLibrary.simpleMessage("Add service"),
    "additionalTimeOptionBlocked": MessageLookupByLibrary.simpleMessage(
      "Blocked time",
    ),
    "additionalTimeOptionProcessing": MessageLookupByLibrary.simpleMessage(
      "Processing time",
    ),
    "additionalTimeSwitch": MessageLookupByLibrary.simpleMessage(
      "Additional time",
    ),
    "agendaAdd": MessageLookupByLibrary.simpleMessage("Add"),
    "agendaAddAppointment": MessageLookupByLibrary.simpleMessage(
      "New appointment",
    ),
    "agendaAddBlock": MessageLookupByLibrary.simpleMessage("New block"),
    "agendaAddTitle": MessageLookupByLibrary.simpleMessage("Add a..."),
    "agendaNextDay": MessageLookupByLibrary.simpleMessage("Next day"),
    "agendaNextMonth": MessageLookupByLibrary.simpleMessage("Next month"),
    "agendaNextWeek": MessageLookupByLibrary.simpleMessage("Next Week"),
    "agendaNoLocations": MessageLookupByLibrary.simpleMessage(
      "No locations available",
    ),
    "agendaNoOnDutyTeamTitle": MessageLookupByLibrary.simpleMessage(
      "No team members on duty today",
    ),
    "agendaNoSelectedTeamTitle": MessageLookupByLibrary.simpleMessage(
      "No selected team members",
    ),
    "agendaPrevDay": MessageLookupByLibrary.simpleMessage("Previous day"),
    "agendaPrevMonth": MessageLookupByLibrary.simpleMessage("Previous month"),
    "agendaPrevWeek": MessageLookupByLibrary.simpleMessage("Previous Week"),
    "agendaSelectLocation": MessageLookupByLibrary.simpleMessage(
      "Select location",
    ),
    "agendaShowAllTeamButton": MessageLookupByLibrary.simpleMessage(
      "View all team",
    ),
    "agendaToday": MessageLookupByLibrary.simpleMessage("Today"),
    "allLocations": MessageLookupByLibrary.simpleMessage("All locations"),
    "appTitle": MessageLookupByLibrary.simpleMessage("Agenda Platform"),
    "applyClientToAllAppointmentsMessage": MessageLookupByLibrary.simpleMessage(
      "The client will also be associated with the appointments in this booking that have been assigned to other staff members.",
    ),
    "applyClientToAllAppointmentsTitle": MessageLookupByLibrary.simpleMessage(
      "Apply client to entire booking?",
    ),
    "appointmentDialogTitleEdit": MessageLookupByLibrary.simpleMessage(
      "Edit appointment",
    ),
    "appointmentDialogTitleNew": MessageLookupByLibrary.simpleMessage(
      "New appointment",
    ),
    "appointmentNoteLabel": MessageLookupByLibrary.simpleMessage(
      "Appointment note",
    ),
    "appointmentNotesTitle": MessageLookupByLibrary.simpleMessage("Notes"),
    "appointmentPriceFree": MessageLookupByLibrary.simpleMessage("Free"),
    "appointmentPriceHint": MessageLookupByLibrary.simpleMessage(
      "Custom price",
    ),
    "appointmentPriceLabel": MessageLookupByLibrary.simpleMessage("Price"),
    "appointmentPriceResetTooltip": MessageLookupByLibrary.simpleMessage(
      "Reset to service price",
    ),
    "atLeastOneServiceRequired": MessageLookupByLibrary.simpleMessage(
      "Add at least one service",
    ),
    "authEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "authFirstName": MessageLookupByLibrary.simpleMessage("First Name"),
    "authForgotPassword": MessageLookupByLibrary.simpleMessage(
      "Forgot password?",
    ),
    "authForgotPasswordInfo": MessageLookupByLibrary.simpleMessage(
      "Contact the system administrator to reset your password.",
    ),
    "authInvalidEmail": MessageLookupByLibrary.simpleMessage("Invalid email"),
    "authLastName": MessageLookupByLibrary.simpleMessage("Last Name"),
    "authLogin": MessageLookupByLibrary.simpleMessage("Sign In"),
    "authLoginFailed": MessageLookupByLibrary.simpleMessage(
      "Invalid credentials. Please try again.",
    ),
    "authLoginFooter": MessageLookupByLibrary.simpleMessage(
      "Access reserved for authorized operators",
    ),
    "authLoginSubtitle": MessageLookupByLibrary.simpleMessage(
      "Sign in to the management system",
    ),
    "authLogout": MessageLookupByLibrary.simpleMessage("Sign Out"),
    "authNetworkError": MessageLookupByLibrary.simpleMessage(
      "Could not connect to the server. Check your internet connection.",
    ),
    "authPassword": MessageLookupByLibrary.simpleMessage("Password"),
    "authPasswordTooShort": MessageLookupByLibrary.simpleMessage(
      "Password too short",
    ),
    "authPhone": MessageLookupByLibrary.simpleMessage("Phone"),
    "authRememberMe": MessageLookupByLibrary.simpleMessage("Remember me"),
    "authRequiredField": MessageLookupByLibrary.simpleMessage("Required field"),
    "authResetPasswordError": MessageLookupByLibrary.simpleMessage(
      "An error occurred. Please try again later.",
    ),
    "authResetPasswordMessage": MessageLookupByLibrary.simpleMessage(
      "Enter your email. We will send you a link to reset your password.",
    ),
    "authResetPasswordSend": MessageLookupByLibrary.simpleMessage("Send"),
    "authResetPasswordSuccess": MessageLookupByLibrary.simpleMessage(
      "If the email exists in our system, you will receive a password reset link.",
    ),
    "authResetPasswordTitle": MessageLookupByLibrary.simpleMessage(
      "Reset password",
    ),
    "availabilitySave": MessageLookupByLibrary.simpleMessage("Save changes"),
    "availabilityTitle": MessageLookupByLibrary.simpleMessage(
      "Weekly availability",
    ),
    "availabilityTitleFor": m0,
    "blockAllDay": MessageLookupByLibrary.simpleMessage("All day"),
    "blockDialogTitleEdit": MessageLookupByLibrary.simpleMessage("Edit block"),
    "blockDialogTitleNew": MessageLookupByLibrary.simpleMessage("New block"),
    "blockEndTime": MessageLookupByLibrary.simpleMessage("End time"),
    "blockReason": MessageLookupByLibrary.simpleMessage("Reason (optional)"),
    "blockReasonHint": MessageLookupByLibrary.simpleMessage(
      "E.g. Meeting, Break, etc.",
    ),
    "blockSelectStaff": MessageLookupByLibrary.simpleMessage("Select team"),
    "blockSelectStaffError": MessageLookupByLibrary.simpleMessage(
      "Select at least one team member",
    ),
    "blockStartTime": MessageLookupByLibrary.simpleMessage("Start time"),
    "blockTimeError": MessageLookupByLibrary.simpleMessage(
      "End time must be after start time",
    ),
    "bookableOnlineSwitch": MessageLookupByLibrary.simpleMessage(
      "Bookable online",
    ),
    "bookingDetails": MessageLookupByLibrary.simpleMessage("Booking details"),
    "bookingHistoryActorCustomer": MessageLookupByLibrary.simpleMessage(
      "Customer",
    ),
    "bookingHistoryActorStaff": MessageLookupByLibrary.simpleMessage("Staff"),
    "bookingHistoryActorSystem": MessageLookupByLibrary.simpleMessage("System"),
    "bookingHistoryChangedFields": m1,
    "bookingHistoryEmpty": MessageLookupByLibrary.simpleMessage(
      "No events recorded",
    ),
    "bookingHistoryError": MessageLookupByLibrary.simpleMessage(
      "Error loading history",
    ),
    "bookingHistoryEventAppointmentUpdated":
        MessageLookupByLibrary.simpleMessage("Appointment updated"),
    "bookingHistoryEventCancelled": MessageLookupByLibrary.simpleMessage(
      "Booking cancelled",
    ),
    "bookingHistoryEventCreated": MessageLookupByLibrary.simpleMessage(
      "Booking created",
    ),
    "bookingHistoryEventDurationChanged": MessageLookupByLibrary.simpleMessage(
      "Duration changed",
    ),
    "bookingHistoryEventItemAdded": MessageLookupByLibrary.simpleMessage(
      "Service added",
    ),
    "bookingHistoryEventItemDeleted": MessageLookupByLibrary.simpleMessage(
      "Service removed",
    ),
    "bookingHistoryEventNotificationSent": MessageLookupByLibrary.simpleMessage(
      "Email sent to customer",
    ),
    "bookingHistoryEventNotificationSentTitle": m2,
    "bookingHistoryEventPriceChanged": MessageLookupByLibrary.simpleMessage(
      "Price changed",
    ),
    "bookingHistoryEventReplaced": MessageLookupByLibrary.simpleMessage(
      "Booking rescheduled",
    ),
    "bookingHistoryEventStaffChanged": MessageLookupByLibrary.simpleMessage(
      "Staff changed",
    ),
    "bookingHistoryEventTimeChanged": MessageLookupByLibrary.simpleMessage(
      "Time changed",
    ),
    "bookingHistoryEventUpdated": MessageLookupByLibrary.simpleMessage(
      "Booking updated",
    ),
    "bookingHistoryLoading": MessageLookupByLibrary.simpleMessage(
      "Loading history...",
    ),
    "bookingHistoryNotificationChannel": m3,
    "bookingHistoryNotificationChannelCancelled":
        MessageLookupByLibrary.simpleMessage("Booking cancellation"),
    "bookingHistoryNotificationChannelConfirmed":
        MessageLookupByLibrary.simpleMessage("Booking confirmation"),
    "bookingHistoryNotificationChannelReminder":
        MessageLookupByLibrary.simpleMessage("Booking reminder"),
    "bookingHistoryNotificationChannelRescheduled":
        MessageLookupByLibrary.simpleMessage("Booking rescheduled"),
    "bookingHistoryNotificationRecipient": m4,
    "bookingHistoryNotificationSentAt": m5,
    "bookingHistoryNotificationSubject": m6,
    "bookingHistoryTitle": MessageLookupByLibrary.simpleMessage(
      "Booking history",
    ),
    "bookingItems": MessageLookupByLibrary.simpleMessage("Services"),
    "bookingNotes": MessageLookupByLibrary.simpleMessage("Booking notes"),
    "bookingNotificationsChannelCancelled":
        MessageLookupByLibrary.simpleMessage("Booking cancelled"),
    "bookingNotificationsChannelConfirmed":
        MessageLookupByLibrary.simpleMessage("Booking created"),
    "bookingNotificationsChannelReminder": MessageLookupByLibrary.simpleMessage(
      "Booking reminder",
    ),
    "bookingNotificationsChannelRescheduled":
        MessageLookupByLibrary.simpleMessage("Booking rescheduled"),
    "bookingNotificationsEmpty": MessageLookupByLibrary.simpleMessage(
      "No notifications found",
    ),
    "bookingNotificationsEmptyHint": MessageLookupByLibrary.simpleMessage(
      "Try adjusting your search filters",
    ),
    "bookingNotificationsFieldAppointment":
        MessageLookupByLibrary.simpleMessage("Appointment"),
    "bookingNotificationsFieldClient": MessageLookupByLibrary.simpleMessage(
      "Client",
    ),
    "bookingNotificationsFieldCreatedAt": MessageLookupByLibrary.simpleMessage(
      "Created at",
    ),
    "bookingNotificationsFieldError": MessageLookupByLibrary.simpleMessage(
      "Error",
    ),
    "bookingNotificationsFieldLocation": MessageLookupByLibrary.simpleMessage(
      "Location",
    ),
    "bookingNotificationsFieldRecipient": MessageLookupByLibrary.simpleMessage(
      "Recipient",
    ),
    "bookingNotificationsFieldSentAt": MessageLookupByLibrary.simpleMessage(
      "Sent at",
    ),
    "bookingNotificationsFieldType": MessageLookupByLibrary.simpleMessage(
      "Type",
    ),
    "bookingNotificationsFilterStatus": MessageLookupByLibrary.simpleMessage(
      "Status",
    ),
    "bookingNotificationsFilterType": MessageLookupByLibrary.simpleMessage(
      "Type",
    ),
    "bookingNotificationsLoadMore": MessageLookupByLibrary.simpleMessage(
      "Load more",
    ),
    "bookingNotificationsNoSubject": MessageLookupByLibrary.simpleMessage(
      "No subject",
    ),
    "bookingNotificationsNotAvailable": MessageLookupByLibrary.simpleMessage(
      "N/A",
    ),
    "bookingNotificationsSearchHint": MessageLookupByLibrary.simpleMessage(
      "Client, recipient, subject",
    ),
    "bookingNotificationsSearchLabel": MessageLookupByLibrary.simpleMessage(
      "Search",
    ),
    "bookingNotificationsStatusAll": MessageLookupByLibrary.simpleMessage(
      "All statuses",
    ),
    "bookingNotificationsStatusFailed": MessageLookupByLibrary.simpleMessage(
      "Failed",
    ),
    "bookingNotificationsStatusPending": MessageLookupByLibrary.simpleMessage(
      "Pending",
    ),
    "bookingNotificationsStatusProcessing":
        MessageLookupByLibrary.simpleMessage("Processing"),
    "bookingNotificationsStatusSent": MessageLookupByLibrary.simpleMessage(
      "Sent",
    ),
    "bookingNotificationsTitle": MessageLookupByLibrary.simpleMessage(
      "Booking Notifications",
    ),
    "bookingNotificationsTotalCount": m7,
    "bookingNotificationsTypeAll": MessageLookupByLibrary.simpleMessage(
      "All types",
    ),
    "bookingRescheduleCancelAction": MessageLookupByLibrary.simpleMessage(
      "Cancel reschedule",
    ),
    "bookingRescheduleConfirmMessage": m8,
    "bookingRescheduleConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Confirm reschedule?",
    ),
    "bookingRescheduleMissingBooking": MessageLookupByLibrary.simpleMessage(
      "Booking not found.",
    ),
    "bookingRescheduleModeHint": MessageLookupByLibrary.simpleMessage(
      "Reschedule mode active: select a date and click a slot.",
    ),
    "bookingRescheduleMoveFailed": MessageLookupByLibrary.simpleMessage(
      "Unable to reschedule the booking.",
    ),
    "bookingStaffNotEligibleWarning": MessageLookupByLibrary.simpleMessage(
      "Warning: the selected team member is not eligible for this service.",
    ),
    "bookingTotal": MessageLookupByLibrary.simpleMessage("Total"),
    "bookingTotalDuration": m9,
    "bookingTotalPrice": m10,
    "bookingUnavailableTimeWarningAppointment":
        MessageLookupByLibrary.simpleMessage(
          "Warning: the appointment time includes unavailable slots for the chosen team.",
        ),
    "bookingUnavailableTimeWarningService": MessageLookupByLibrary.simpleMessage(
      "Warning: this service time includes unavailable slots for the chosen team.",
    ),
    "bookingsListActionCancel": MessageLookupByLibrary.simpleMessage("Cancel"),
    "bookingsListActionEdit": MessageLookupByLibrary.simpleMessage("Edit"),
    "bookingsListActionView": MessageLookupByLibrary.simpleMessage("Details"),
    "bookingsListAllLocations": MessageLookupByLibrary.simpleMessage(
      "All locations",
    ),
    "bookingsListAllServices": MessageLookupByLibrary.simpleMessage(
      "All services",
    ),
    "bookingsListAllStaff": MessageLookupByLibrary.simpleMessage("All staff"),
    "bookingsListAllStatus": MessageLookupByLibrary.simpleMessage(
      "All statuses",
    ),
    "bookingsListCancelConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "This action cannot be undone.",
    ),
    "bookingsListCancelConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Cancel booking?",
    ),
    "bookingsListCancelSuccess": MessageLookupByLibrary.simpleMessage(
      "Booking cancelled",
    ),
    "bookingsListColumnActions": MessageLookupByLibrary.simpleMessage(
      "Actions",
    ),
    "bookingsListColumnClient": MessageLookupByLibrary.simpleMessage("Client"),
    "bookingsListColumnCreatedAt": MessageLookupByLibrary.simpleMessage(
      "Created on",
    ),
    "bookingsListColumnCreatedBy": MessageLookupByLibrary.simpleMessage(
      "Created by",
    ),
    "bookingsListColumnDateTime": MessageLookupByLibrary.simpleMessage(
      "Date/Time",
    ),
    "bookingsListColumnPrice": MessageLookupByLibrary.simpleMessage("Price"),
    "bookingsListColumnServices": MessageLookupByLibrary.simpleMessage(
      "Services",
    ),
    "bookingsListColumnStaff": MessageLookupByLibrary.simpleMessage("Staff"),
    "bookingsListColumnStatus": MessageLookupByLibrary.simpleMessage("Status"),
    "bookingsListEmpty": MessageLookupByLibrary.simpleMessage(
      "No bookings found",
    ),
    "bookingsListEmptyHint": MessageLookupByLibrary.simpleMessage(
      "Try adjusting your search filters",
    ),
    "bookingsListFilterClient": MessageLookupByLibrary.simpleMessage(
      "Search client",
    ),
    "bookingsListFilterClientHint": MessageLookupByLibrary.simpleMessage(
      "Name, email or phone",
    ),
    "bookingsListFilterFutureOnly": MessageLookupByLibrary.simpleMessage(
      "Future only",
    ),
    "bookingsListFilterIncludePast": MessageLookupByLibrary.simpleMessage(
      "Include past",
    ),
    "bookingsListFilterLocation": MessageLookupByLibrary.simpleMessage(
      "Location",
    ),
    "bookingsListFilterPeriod": MessageLookupByLibrary.simpleMessage("Period"),
    "bookingsListFilterService": MessageLookupByLibrary.simpleMessage(
      "Service",
    ),
    "bookingsListFilterStaff": MessageLookupByLibrary.simpleMessage("Staff"),
    "bookingsListFilterStatus": MessageLookupByLibrary.simpleMessage("Status"),
    "bookingsListFilterTitle": MessageLookupByLibrary.simpleMessage("Filters"),
    "bookingsListLoadMore": MessageLookupByLibrary.simpleMessage("Load more"),
    "bookingsListLoading": MessageLookupByLibrary.simpleMessage("Loading..."),
    "bookingsListNoClient": MessageLookupByLibrary.simpleMessage("No client"),
    "bookingsListResetFilters": MessageLookupByLibrary.simpleMessage(
      "Reset filters",
    ),
    "bookingsListSortAsc": MessageLookupByLibrary.simpleMessage("Ascending"),
    "bookingsListSortByAppointment": MessageLookupByLibrary.simpleMessage(
      "Appointment date",
    ),
    "bookingsListSortByCreated": MessageLookupByLibrary.simpleMessage(
      "Creation date",
    ),
    "bookingsListSortDesc": MessageLookupByLibrary.simpleMessage("Descending"),
    "bookingsListSourceInternal": MessageLookupByLibrary.simpleMessage(
      "Back office",
    ),
    "bookingsListSourceOnline": MessageLookupByLibrary.simpleMessage("Online"),
    "bookingsListSourcePhone": MessageLookupByLibrary.simpleMessage("Phone"),
    "bookingsListSourceWalkIn": MessageLookupByLibrary.simpleMessage("Walk-in"),
    "bookingsListStatusCancelled": MessageLookupByLibrary.simpleMessage(
      "Cancelled",
    ),
    "bookingsListStatusCompleted": MessageLookupByLibrary.simpleMessage(
      "Completed",
    ),
    "bookingsListStatusConfirmed": MessageLookupByLibrary.simpleMessage(
      "Confirmed",
    ),
    "bookingsListStatusNoShow": MessageLookupByLibrary.simpleMessage("No show"),
    "bookingsListStatusPending": MessageLookupByLibrary.simpleMessage(
      "Pending",
    ),
    "bookingsListStatusReplaced": MessageLookupByLibrary.simpleMessage(
      "Replaced",
    ),
    "bookingsListTitle": MessageLookupByLibrary.simpleMessage("Bookings List"),
    "bookingsListTotalCount": m11,
    "businessOnlineBookingsNotificationEmailHelper":
        MessageLookupByLibrary.simpleMessage(
          "Receives notifications only when customers create/modify/cancel online bookings",
        ),
    "businessOnlineBookingsNotificationEmailHint":
        MessageLookupByLibrary.simpleMessage("e.g. bookings@business.com"),
    "businessOnlineBookingsNotificationEmailLabel":
        MessageLookupByLibrary.simpleMessage(
          "Online bookings notification email",
        ),
    "businessServiceColorPaletteEnhanced": MessageLookupByLibrary.simpleMessage(
      "Darker (recommended)",
    ),
    "businessServiceColorPaletteHelper": MessageLookupByLibrary.simpleMessage(
      "Defines colors used in service selection and agenda cards",
    ),
    "businessServiceColorPaletteLabel": MessageLookupByLibrary.simpleMessage(
      "Service color palette",
    ),
    "businessServiceColorPaletteLegacy": MessageLookupByLibrary.simpleMessage(
      "Original",
    ),
    "cancelledBadge": MessageLookupByLibrary.simpleMessage("CANCELLED"),
    "cannotDeleteCategoryContent": MessageLookupByLibrary.simpleMessage(
      "This category contains one or more services.",
    ),
    "cannotDeleteTitle": MessageLookupByLibrary.simpleMessage("Cannot delete"),
    "cannotUndoWarning": MessageLookupByLibrary.simpleMessage(
      "This action cannot be undone.",
    ),
    "categoryDuplicateError": MessageLookupByLibrary.simpleMessage(
      "A category with this name already exists",
    ),
    "classEventsActionBook": MessageLookupByLibrary.simpleMessage("Book"),
    "classEventsActionCancelBooking": MessageLookupByLibrary.simpleMessage(
      "Cancel booking",
    ),
    "classEventsAddButton": MessageLookupByLibrary.simpleMessage("Add"),
    "classEventsCapacitySummary": m12,
    "classEventsCreateErrorMessage": MessageLookupByLibrary.simpleMessage(
      "Unable to create class",
    ),
    "classEventsCreateSuccessMessage": MessageLookupByLibrary.simpleMessage(
      "The class was created successfully",
    ),
    "classEventsCreateSuccessTitle": MessageLookupByLibrary.simpleMessage(
      "Class created",
    ),
    "classEventsCreateTitle": MessageLookupByLibrary.simpleMessage(
      "Scheduling",
    ),
    "classEventsEditModeLabel": MessageLookupByLibrary.simpleMessage(
      "Edit mode",
    ),
    "classEventsEditTitle": MessageLookupByLibrary.simpleMessage(
      "Edit scheduling",
    ),
    "classEventsEmpty": MessageLookupByLibrary.simpleMessage(
      "No classes in the selected day.",
    ),
    "classEventsExpiredBadge": MessageLookupByLibrary.simpleMessage("Expired"),
    "classEventsFieldCapacity": MessageLookupByLibrary.simpleMessage(
      "Capacity",
    ),
    "classEventsFieldClassType": MessageLookupByLibrary.simpleMessage(
      "Class type",
    ),
    "classEventsFieldDate": MessageLookupByLibrary.simpleMessage("Date"),
    "classEventsFieldEndTime": MessageLookupByLibrary.simpleMessage("End time"),
    "classEventsFieldLocation": MessageLookupByLibrary.simpleMessage(
      "Location",
    ),
    "classEventsFieldStaff": MessageLookupByLibrary.simpleMessage("Staff"),
    "classEventsFieldStartTime": MessageLookupByLibrary.simpleMessage(
      "Start time",
    ),
    "classEventsFieldTitleOptional": MessageLookupByLibrary.simpleMessage(
      "Title (optional)",
    ),
    "classEventsFutureBadge": MessageLookupByLibrary.simpleMessage("Future"),
    "classEventsNewScheduleButton": MessageLookupByLibrary.simpleMessage(
      "New schedule",
    ),
    "classEventsNoClassTypes": MessageLookupByLibrary.simpleMessage(
      "No class types available",
    ),
    "classEventsNoLocationsForClassType": MessageLookupByLibrary.simpleMessage(
      "No enabled location for this class type",
    ),
    "classEventsNoStaffForLocation": MessageLookupByLibrary.simpleMessage(
      "No staff available for selected location",
    ),
    "classEventsParticipantCustomer": m13,
    "classEventsParticipantsTitle": MessageLookupByLibrary.simpleMessage(
      "Participants",
    ),
    "classEventsRecurrenceConflictForceDescription":
        MessageLookupByLibrary.simpleMessage(
          "Create schedules even if there are overlaps",
        ),
    "classEventsRecurrenceConflictSkipDescription":
        MessageLookupByLibrary.simpleMessage(
          "Do not create schedules if there are overlaps",
        ),
    "classEventsRecurrencePreviewConfirm": m14,
    "classEventsRecurrencePreviewHint": MessageLookupByLibrary.simpleMessage(
      "Deselect schedules you do not want to create",
    ),
    "classEventsRecurrencePreviewTitle": MessageLookupByLibrary.simpleMessage(
      "Schedule preview",
    ),
    "classEventsRepeatSchedule": MessageLookupByLibrary.simpleMessage(
      "Repeat schedule",
    ),
    "classEventsSchedulesDeleteConfirmMessage":
        MessageLookupByLibrary.simpleMessage(
          "Deleting the schedule will also delete any existing bookings.",
        ),
    "classEventsSchedulesDeleteConfirmTitle":
        MessageLookupByLibrary.simpleMessage("Delete schedule?"),
    "classEventsSchedulesDeleteSuccessMessage":
        MessageLookupByLibrary.simpleMessage(
          "The schedule and related bookings have been deleted",
        ),
    "classEventsSchedulesDeleteSuccessTitle":
        MessageLookupByLibrary.simpleMessage("Schedule deleted"),
    "classEventsSchedulesListEmpty": MessageLookupByLibrary.simpleMessage(
      "No schedules",
    ),
    "classEventsSchedulesListTitle": MessageLookupByLibrary.simpleMessage(
      "Existing schedules",
    ),
    "classEventsSchedulesUpdateSuccessMessage":
        MessageLookupByLibrary.simpleMessage("Schedule updated successfully"),
    "classEventsSchedulesUpdateSuccessTitle":
        MessageLookupByLibrary.simpleMessage("Schedule updated"),
    "classEventsShowExpiredSchedules": MessageLookupByLibrary.simpleMessage(
      "Show expired too",
    ),
    "classEventsTitle": MessageLookupByLibrary.simpleMessage("Classes"),
    "classEventsUntitled": MessageLookupByLibrary.simpleMessage("Class"),
    "classEventsValidationEndAfterStart": MessageLookupByLibrary.simpleMessage(
      "End time must be after start time",
    ),
    "classEventsValidationRequired": MessageLookupByLibrary.simpleMessage(
      "Fill all required fields",
    ),
    "classTypesActionClone": MessageLookupByLibrary.simpleMessage("Duplicate"),
    "classTypesActionDeactivate": MessageLookupByLibrary.simpleMessage(
      "Delete",
    ),
    "classTypesActionReactivate": MessageLookupByLibrary.simpleMessage(
      "Reactivate",
    ),
    "classTypesActionScheduleClass": MessageLookupByLibrary.simpleMessage(
      "Scheduling",
    ),
    "classTypesAddButton": MessageLookupByLibrary.simpleMessage("New type"),
    "classTypesCloneSuccessMessage": MessageLookupByLibrary.simpleMessage(
      "Class type duplicated successfully",
    ),
    "classTypesCloneSuccessTitle": MessageLookupByLibrary.simpleMessage(
      "Class type duplicated",
    ),
    "classTypesCloneSuffix": MessageLookupByLibrary.simpleMessage("Copy"),
    "classTypesCreateSuccessMessage": MessageLookupByLibrary.simpleMessage(
      "Class type created successfully",
    ),
    "classTypesCreateSuccessTitle": MessageLookupByLibrary.simpleMessage(
      "Class type created",
    ),
    "classTypesCreateTitle": MessageLookupByLibrary.simpleMessage(
      "New class type",
    ),
    "classTypesDeactivateConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "The class type will be deactivated and unavailable for new schedules.",
    ),
    "classTypesDeactivateConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Delete class type?",
    ),
    "classTypesDeactivateSuccessMessage": MessageLookupByLibrary.simpleMessage(
      "Class type has been deactivated",
    ),
    "classTypesDeactivateSuccessTitle": MessageLookupByLibrary.simpleMessage(
      "Class type deleted",
    ),
    "classTypesDeleteConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "This action permanently deletes the class type.",
    ),
    "classTypesDeleteConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Delete class type?",
    ),
    "classTypesDeleteInUseErrorMessage": MessageLookupByLibrary.simpleMessage(
      "Cannot delete class type because there are associated schedules",
    ),
    "classTypesDeleteSuccessMessage": MessageLookupByLibrary.simpleMessage(
      "Class type has been deleted",
    ),
    "classTypesDeleteSuccessTitle": MessageLookupByLibrary.simpleMessage(
      "Class type deleted",
    ),
    "classTypesEditTitle": MessageLookupByLibrary.simpleMessage(
      "Edit class type",
    ),
    "classTypesEmpty": MessageLookupByLibrary.simpleMessage(
      "No class types configured",
    ),
    "classTypesFieldDescriptionOptional": MessageLookupByLibrary.simpleMessage(
      "Description (optional)",
    ),
    "classTypesFieldIsActive": MessageLookupByLibrary.simpleMessage(
      "Type active",
    ),
    "classTypesFieldName": MessageLookupByLibrary.simpleMessage("Name"),
    "classTypesManageButton": MessageLookupByLibrary.simpleMessage(
      "Class types",
    ),
    "classTypesManageTitle": MessageLookupByLibrary.simpleMessage(
      "Class types",
    ),
    "classTypesMutationErrorMessage": MessageLookupByLibrary.simpleMessage(
      "Unable to save class type",
    ),
    "classTypesReactivateConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "The class type will be available again for new schedules.",
    ),
    "classTypesReactivateConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Reactivate class type?",
    ),
    "classTypesReactivateSuccessMessage": MessageLookupByLibrary.simpleMessage(
      "Class type has been reactivated",
    ),
    "classTypesReactivateSuccessTitle": MessageLookupByLibrary.simpleMessage(
      "Class type reactivated",
    ),
    "classTypesStatusActive": MessageLookupByLibrary.simpleMessage("Active"),
    "classTypesStatusInactive": MessageLookupByLibrary.simpleMessage(
      "Inactive",
    ),
    "classTypesUpdateSuccessMessage": MessageLookupByLibrary.simpleMessage(
      "Class type updated successfully",
    ),
    "classTypesUpdateSuccessTitle": MessageLookupByLibrary.simpleMessage(
      "Class type updated",
    ),
    "clientAppointmentsCancelledBadge": MessageLookupByLibrary.simpleMessage(
      "CANCELLED",
    ),
    "clientAppointmentsEmpty": MessageLookupByLibrary.simpleMessage(
      "No appointments",
    ),
    "clientAppointmentsPast": MessageLookupByLibrary.simpleMessage("Past"),
    "clientAppointmentsTitle": m15,
    "clientAppointmentsUpcoming": MessageLookupByLibrary.simpleMessage(
      "Upcoming",
    ),
    "clientLockedHint": MessageLookupByLibrary.simpleMessage(
      "Client cannot be changed for this appointment",
    ),
    "clientNoteLabel": MessageLookupByLibrary.simpleMessage("Client note"),
    "clientOptionalHint": MessageLookupByLibrary.simpleMessage(
      "Leave empty if you don\'t want to associate a client with the appointment",
    ),
    "clientsEdit": MessageLookupByLibrary.simpleMessage("Edit client"),
    "clientsEmpty": MessageLookupByLibrary.simpleMessage("No clients"),
    "clientsNew": MessageLookupByLibrary.simpleMessage("New client"),
    "clientsTitle": MessageLookupByLibrary.simpleMessage("Clients List"),
    "closuresAddButton": MessageLookupByLibrary.simpleMessage("Add closure"),
    "closuresAddSuccess": MessageLookupByLibrary.simpleMessage("Closure added"),
    "closuresAllLocations": MessageLookupByLibrary.simpleMessage(
      "All locations",
    ),
    "closuresDateRange": MessageLookupByLibrary.simpleMessage("Date range"),
    "closuresDays": m16,
    "closuresDeleteConfirm": MessageLookupByLibrary.simpleMessage(
      "Delete this closure?",
    ),
    "closuresDeleteConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "Booking slots during this period will become available again.",
    ),
    "closuresDeleteSuccess": MessageLookupByLibrary.simpleMessage(
      "Closure deleted",
    ),
    "closuresDeselectAll": MessageLookupByLibrary.simpleMessage("Deselect all"),
    "closuresEditTitle": MessageLookupByLibrary.simpleMessage("Edit closure"),
    "closuresEmpty": MessageLookupByLibrary.simpleMessage(
      "No closures scheduled",
    ),
    "closuresEmptyForPeriod": MessageLookupByLibrary.simpleMessage(
      "No closures scheduled for the selected period",
    ),
    "closuresEmptyHint": MessageLookupByLibrary.simpleMessage(
      "Add business closure periods (e.g. holidays, vacations)",
    ),
    "closuresEndDate": MessageLookupByLibrary.simpleMessage("End date"),
    "closuresFilterAll": MessageLookupByLibrary.simpleMessage("All"),
    "closuresFilterFromToday": MessageLookupByLibrary.simpleMessage(
      "From today",
    ),
    "closuresImportHolidays": MessageLookupByLibrary.simpleMessage(
      "Import holidays",
    ),
    "closuresImportHolidaysAction": m17,
    "closuresImportHolidaysAlreadyAdded": m18,
    "closuresImportHolidaysList": MessageLookupByLibrary.simpleMessage(
      "Select holidays to import:",
    ),
    "closuresImportHolidaysLocations": MessageLookupByLibrary.simpleMessage(
      "Apply to locations:",
    ),
    "closuresImportHolidaysSuccess": m19,
    "closuresImportHolidaysTitle": MessageLookupByLibrary.simpleMessage(
      "Import national holidays",
    ),
    "closuresImportHolidaysUnsupportedCountry":
        MessageLookupByLibrary.simpleMessage(
          "Automatic holidays are not available for the country configured in the location.",
        ),
    "closuresImportHolidaysYear": MessageLookupByLibrary.simpleMessage("Year:"),
    "closuresInvalidDateRange": MessageLookupByLibrary.simpleMessage(
      "End date must be equal to or after start date",
    ),
    "closuresLocations": MessageLookupByLibrary.simpleMessage(
      "Affected locations",
    ),
    "closuresNewTitle": MessageLookupByLibrary.simpleMessage("New closure"),
    "closuresNoLocations": MessageLookupByLibrary.simpleMessage(
      "No locations configured",
    ),
    "closuresOverlapError": MessageLookupByLibrary.simpleMessage(
      "Dates overlap with an existing closure",
    ),
    "closuresPast": MessageLookupByLibrary.simpleMessage("Previous closures"),
    "closuresReason": MessageLookupByLibrary.simpleMessage("Reason (optional)"),
    "closuresReasonHint": MessageLookupByLibrary.simpleMessage(
      "e.g. Holiday, Summer vacation, Maintenance...",
    ),
    "closuresSelectAll": MessageLookupByLibrary.simpleMessage("Select all"),
    "closuresSelectAtLeastOneLocation": MessageLookupByLibrary.simpleMessage(
      "Select at least one location",
    ),
    "closuresSingleDay": MessageLookupByLibrary.simpleMessage("Single day"),
    "closuresStartDate": MessageLookupByLibrary.simpleMessage("Start date"),
    "closuresTitle": MessageLookupByLibrary.simpleMessage("Closure dates"),
    "closuresTotalDays": m20,
    "closuresUpcoming": MessageLookupByLibrary.simpleMessage(
      "Upcoming closures",
    ),
    "closuresUpdateSuccess": MessageLookupByLibrary.simpleMessage(
      "Closure updated",
    ),
    "createCategoryButtonLabel": MessageLookupByLibrary.simpleMessage(
      "New category",
    ),
    "createNewClient": MessageLookupByLibrary.simpleMessage(
      "Create new client",
    ),
    "crmArchiveAction": MessageLookupByLibrary.simpleMessage("Archive"),
    "crmBookingsReuseHint": MessageLookupByLibrary.simpleMessage(
      "Booking history is available in existing client view",
    ),
    "crmBookingsTab": MessageLookupByLibrary.simpleMessage("Bookings"),
    "crmClientDetailTitle": MessageLookupByLibrary.simpleMessage(
      "Client detail",
    ),
    "crmClientsDescription": MessageLookupByLibrary.simpleMessage(
      "360 customer view with KPI and timeline",
    ),
    "crmClientsEmpty": MessageLookupByLibrary.simpleMessage("No clients found"),
    "crmClientsTitle": MessageLookupByLibrary.simpleMessage("CRM Clients"),
    "crmContactsTab": MessageLookupByLibrary.simpleMessage("Contacts"),
    "crmCreateClientTitle": MessageLookupByLibrary.simpleMessage(
      "New CRM client",
    ),
    "crmCreateSegmentTitle": MessageLookupByLibrary.simpleMessage(
      "New segment",
    ),
    "crmCreateTagTitle": MessageLookupByLibrary.simpleMessage("New tag"),
    "crmExportCopied": MessageLookupByLibrary.simpleMessage(
      "CSV copied to clipboard",
    ),
    "crmExportCsvButton": MessageLookupByLibrary.simpleMessage(
      "Copy CSV to clipboard",
    ),
    "crmExportCsvTitle": MessageLookupByLibrary.simpleMessage("CSV Export"),
    "crmFilterAll": MessageLookupByLibrary.simpleMessage("All"),
    "crmGdprDeleteConfirm": MessageLookupByLibrary.simpleMessage(
      "Confirm anonymization and archival of this client?",
    ),
    "crmGdprDeleteTitle": MessageLookupByLibrary.simpleMessage("GDPR Delete"),
    "crmGdprDeleted": MessageLookupByLibrary.simpleMessage(
      "Client anonymized successfully",
    ),
    "crmGdprTab": MessageLookupByLibrary.simpleMessage("GDPR"),
    "crmImportCommit": MessageLookupByLibrary.simpleMessage("Commit import"),
    "crmImportCsvHint": MessageLookupByLibrary.simpleMessage(
      "Paste CSV header: first_name,last_name,email,phone,city,notes,source",
    ),
    "crmImportCsvTitle": MessageLookupByLibrary.simpleMessage("CSV Import"),
    "crmImportExportDescription": MessageLookupByLibrary.simpleMessage(
      "CSV import with preview and segment export",
    ),
    "crmImportExportTitle": MessageLookupByLibrary.simpleMessage(
      "Import / Export",
    ),
    "crmImportPreview": MessageLookupByLibrary.simpleMessage("Dry-run preview"),
    "crmKpiAvgTicket": MessageLookupByLibrary.simpleMessage("Avg ticket"),
    "crmKpiNoShow": MessageLookupByLibrary.simpleMessage("No-show"),
    "crmKpiSpent": MessageLookupByLibrary.simpleMessage("Total spent"),
    "crmKpiVisits": MessageLookupByLibrary.simpleMessage("Visits"),
    "crmLoadMore": MessageLookupByLibrary.simpleMessage("Load more"),
    "crmLoyaltyPoints": m21,
    "crmLoyaltyTab": MessageLookupByLibrary.simpleMessage("Loyalty"),
    "crmOverviewTab": MessageLookupByLibrary.simpleMessage("Overview"),
    "crmSearchHint": MessageLookupByLibrary.simpleMessage(
      "Search by name, email, phone, city...",
    ),
    "crmSegmentDeleted": MessageLookupByLibrary.simpleMessage(
      "Segment deleted",
    ),
    "crmSegmentNameLabel": MessageLookupByLibrary.simpleMessage("Segment name"),
    "crmSegmentQueryLabel": MessageLookupByLibrary.simpleMessage(
      "Search query (q)",
    ),
    "crmSegmentsDescription": MessageLookupByLibrary.simpleMessage(
      "Dynamic client lists with saved filters",
    ),
    "crmSegmentsEmpty": MessageLookupByLibrary.simpleMessage("No segments"),
    "crmSegmentsTitle": MessageLookupByLibrary.simpleMessage("Segments"),
    "crmStatusActive": MessageLookupByLibrary.simpleMessage("Active"),
    "crmStatusInactive": MessageLookupByLibrary.simpleMessage("Inactive"),
    "crmStatusLead": MessageLookupByLibrary.simpleMessage("Lead"),
    "crmStatusLost": MessageLookupByLibrary.simpleMessage("Lost"),
    "crmSubtitle": MessageLookupByLibrary.simpleMessage(
      "Advanced client management, segments, tasks and privacy",
    ),
    "crmTagColorLabel": MessageLookupByLibrary.simpleMessage("Color (hex)"),
    "crmTagDeleted": MessageLookupByLibrary.simpleMessage("Tag deleted"),
    "crmTagNameLabel": MessageLookupByLibrary.simpleMessage("Tag name"),
    "crmTagsDescription": MessageLookupByLibrary.simpleMessage(
      "Centralized client tags management",
    ),
    "crmTagsEmpty": MessageLookupByLibrary.simpleMessage("No tags"),
    "crmTagsTitle": MessageLookupByLibrary.simpleMessage("Tags"),
    "crmTaskComplete": MessageLookupByLibrary.simpleMessage("Complete"),
    "crmTaskReopen": MessageLookupByLibrary.simpleMessage("Reopen"),
    "crmTasksDescription": MessageLookupByLibrary.simpleMessage(
      "Staff follow-up and overdue activities",
    ),
    "crmTasksEmpty": MessageLookupByLibrary.simpleMessage("No overdue tasks"),
    "crmTasksTab": MessageLookupByLibrary.simpleMessage("Tasks"),
    "crmTasksTitle": MessageLookupByLibrary.simpleMessage("Tasks"),
    "crmTimelineTab": MessageLookupByLibrary.simpleMessage("Timeline"),
    "crmTitle": MessageLookupByLibrary.simpleMessage("CRM"),
    "crmVisitsLabel": m22,
    "currentWeek": MessageLookupByLibrary.simpleMessage("Current week"),
    "dayFriday": MessageLookupByLibrary.simpleMessage("Friday"),
    "dayFridayFull": MessageLookupByLibrary.simpleMessage("Friday"),
    "dayMonday": MessageLookupByLibrary.simpleMessage("Monday"),
    "dayMondayFull": MessageLookupByLibrary.simpleMessage("Monday"),
    "daySaturday": MessageLookupByLibrary.simpleMessage("Saturday"),
    "daySaturdayFull": MessageLookupByLibrary.simpleMessage("Saturday"),
    "daySunday": MessageLookupByLibrary.simpleMessage("Sunday"),
    "daySundayFull": MessageLookupByLibrary.simpleMessage("Sunday"),
    "dayThursday": MessageLookupByLibrary.simpleMessage("Thursday"),
    "dayThursdayFull": MessageLookupByLibrary.simpleMessage("Thursday"),
    "dayTuesday": MessageLookupByLibrary.simpleMessage("Tuesday"),
    "dayTuesdayFull": MessageLookupByLibrary.simpleMessage("Tuesday"),
    "dayWednesday": MessageLookupByLibrary.simpleMessage("Wednesday"),
    "dayWednesdayFull": MessageLookupByLibrary.simpleMessage("Wednesday"),
    "deleteAppointmentConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "The appointment will be removed. This action cannot be undone.",
    ),
    "deleteAppointmentConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Delete appointment?",
    ),
    "deleteBookingConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "All linked services will be removed. This action cannot be undone.",
    ),
    "deleteBookingConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Delete entire booking?",
    ),
    "deleteClientConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "The client will be permanently deleted. This action cannot be undone.",
    ),
    "deleteClientConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Delete client?",
    ),
    "deleteConfirmationTitle": MessageLookupByLibrary.simpleMessage(
      "Confirm deletion?",
    ),
    "deleteServiceQuestion": MessageLookupByLibrary.simpleMessage(
      "Delete this service?",
    ),
    "discardChangesMessage": MessageLookupByLibrary.simpleMessage(
      "You have unsaved changes. Do you want to discard them?",
    ),
    "discardChangesTitle": MessageLookupByLibrary.simpleMessage(
      "Unsaved changes",
    ),
    "duplicateAction": MessageLookupByLibrary.simpleMessage("Duplicate"),
    "durationHour": m23,
    "durationHourMinute": m24,
    "durationMinute": m25,
    "editCategoryTitle": MessageLookupByLibrary.simpleMessage("Edit category"),
    "editServiceTitle": MessageLookupByLibrary.simpleMessage("Edit service"),
    "emptyCategoriesNotReorderableNote": MessageLookupByLibrary.simpleMessage(
      "Categories without services cannot be reordered and stay at the end.",
    ),
    "errorExceptionNotFound": m26,
    "errorFormFactorBuilderMissing": m27,
    "errorFormFactorBuilderRequired": MessageLookupByLibrary.simpleMessage(
      "Specify at least one builder for form factor",
    ),
    "errorNotFound": m28,
    "errorServiceNotFound": MessageLookupByLibrary.simpleMessage(
      "Service not found",
    ),
    "errorTitle": MessageLookupByLibrary.simpleMessage("Error"),
    "exceptionAllDay": MessageLookupByLibrary.simpleMessage("All day"),
    "exceptionAvailableNoEffect": MessageLookupByLibrary.simpleMessage(
      "Extra availability must add hours beyond the base availability.",
    ),
    "exceptionDateFrom": MessageLookupByLibrary.simpleMessage("Start date"),
    "exceptionDateTo": MessageLookupByLibrary.simpleMessage("End date"),
    "exceptionDeleteMessage": MessageLookupByLibrary.simpleMessage(
      "The exception will be permanently deleted.",
    ),
    "exceptionDeleteShift": MessageLookupByLibrary.simpleMessage(
      "Delete exception",
    ),
    "exceptionDeleteShiftDesc": MessageLookupByLibrary.simpleMessage(
      "Restore base availability",
    ),
    "exceptionDeleteTitle": MessageLookupByLibrary.simpleMessage(
      "Delete exception?",
    ),
    "exceptionDialogTitleEdit": MessageLookupByLibrary.simpleMessage(
      "Edit exception",
    ),
    "exceptionDialogTitleNew": MessageLookupByLibrary.simpleMessage(
      "New exception",
    ),
    "exceptionDuration": MessageLookupByLibrary.simpleMessage(
      "Duration (days)",
    ),
    "exceptionDurationDays": m29,
    "exceptionEditShift": MessageLookupByLibrary.simpleMessage(
      "Edit exception",
    ),
    "exceptionEditShiftDesc": MessageLookupByLibrary.simpleMessage(
      "Edit the times of this exception",
    ),
    "exceptionEndTime": MessageLookupByLibrary.simpleMessage("End time"),
    "exceptionPartialSaveInfo": m30,
    "exceptionPartialSaveInfoDetailed": m31,
    "exceptionPartialSaveMessage": MessageLookupByLibrary.simpleMessage(
      "The days below were not congruent and were not saved:",
    ),
    "exceptionPartialSaveTitle": MessageLookupByLibrary.simpleMessage(
      "Exceptions not saved",
    ),
    "exceptionPeriodDuration": MessageLookupByLibrary.simpleMessage("Duration"),
    "exceptionPeriodMode": MessageLookupByLibrary.simpleMessage("Period"),
    "exceptionPeriodRange": MessageLookupByLibrary.simpleMessage("From - To"),
    "exceptionPeriodSingle": MessageLookupByLibrary.simpleMessage("Single day"),
    "exceptionReason": MessageLookupByLibrary.simpleMessage(
      "Reason (optional)",
    ),
    "exceptionReasonExtraShift": MessageLookupByLibrary.simpleMessage(
      "Extra shift",
    ),
    "exceptionReasonHint": MessageLookupByLibrary.simpleMessage(
      "E.g. Holiday, Medical visit, Extra shift...",
    ),
    "exceptionReasonMedicalVisit": MessageLookupByLibrary.simpleMessage(
      "Medical visit",
    ),
    "exceptionReasonVacation": MessageLookupByLibrary.simpleMessage("Vacation"),
    "exceptionSelectTime": MessageLookupByLibrary.simpleMessage("Select time"),
    "exceptionStartTime": MessageLookupByLibrary.simpleMessage("Start time"),
    "exceptionTimeError": MessageLookupByLibrary.simpleMessage(
      "End time must be after start time",
    ),
    "exceptionType": MessageLookupByLibrary.simpleMessage("Exception type"),
    "exceptionTypeAvailable": MessageLookupByLibrary.simpleMessage("Available"),
    "exceptionTypeUnavailable": MessageLookupByLibrary.simpleMessage(
      "Unavailable",
    ),
    "exceptionUnavailableNoBase": MessageLookupByLibrary.simpleMessage(
      "You can\'t add unavailability on a day with no base availability.",
    ),
    "exceptionUnavailableNoOverlap": MessageLookupByLibrary.simpleMessage(
      "Unavailability must overlap the base availability.",
    ),
    "exceptionsAdd": MessageLookupByLibrary.simpleMessage("Add exception"),
    "exceptionsEmpty": MessageLookupByLibrary.simpleMessage(
      "No exceptions configured",
    ),
    "exceptionsTitle": MessageLookupByLibrary.simpleMessage("Exceptions"),
    "fieldBlockedTimeLabel": MessageLookupByLibrary.simpleMessage(
      "Blocked time",
    ),
    "fieldCategoryRequiredLabel": MessageLookupByLibrary.simpleMessage(
      "Category *",
    ),
    "fieldDescriptionLabel": MessageLookupByLibrary.simpleMessage(
      "Description",
    ),
    "fieldDurationRequiredError": MessageLookupByLibrary.simpleMessage(
      "Please select a duration",
    ),
    "fieldDurationRequiredLabel": MessageLookupByLibrary.simpleMessage(
      "Duration *",
    ),
    "fieldNameRequiredError": MessageLookupByLibrary.simpleMessage(
      "Name is required",
    ),
    "fieldNameRequiredLabel": MessageLookupByLibrary.simpleMessage("Name *"),
    "fieldPriceLabel": MessageLookupByLibrary.simpleMessage("Price"),
    "fieldProcessingTimeLabel": MessageLookupByLibrary.simpleMessage(
      "Processing time",
    ),
    "filterAll": MessageLookupByLibrary.simpleMessage("All"),
    "filterInactive": MessageLookupByLibrary.simpleMessage("Inactive"),
    "filterNew": MessageLookupByLibrary.simpleMessage("New"),
    "filterVIP": MessageLookupByLibrary.simpleMessage("VIP"),
    "formClient": MessageLookupByLibrary.simpleMessage("Client"),
    "formDate": MessageLookupByLibrary.simpleMessage("Date"),
    "formEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "formFirstName": MessageLookupByLibrary.simpleMessage("First name"),
    "formLastName": MessageLookupByLibrary.simpleMessage("Last name"),
    "formNotes": MessageLookupByLibrary.simpleMessage(
      "Notes (not visible to client)",
    ),
    "formPhone": MessageLookupByLibrary.simpleMessage("Phone"),
    "formService": MessageLookupByLibrary.simpleMessage("Service"),
    "formServices": MessageLookupByLibrary.simpleMessage("Services"),
    "formStaff": MessageLookupByLibrary.simpleMessage("Team"),
    "freeLabel": MessageLookupByLibrary.simpleMessage("Free"),
    "freeServiceSwitch": MessageLookupByLibrary.simpleMessage("Free service"),
    "hoursHoursOnly": m32,
    "hoursMinutesCompact": m33,
    "invitationAcceptAndLoginAction": MessageLookupByLibrary.simpleMessage(
      "Accept and sign in",
    ),
    "invitationAcceptButton": MessageLookupByLibrary.simpleMessage(
      "Accept invitation",
    ),
    "invitationAcceptErrorEmailMismatch": MessageLookupByLibrary.simpleMessage(
      "This invitation is linked to a different email. Sign out from the current account, then reopen this invitation link and sign in with the invited email.",
    ),
    "invitationAcceptErrorExpired": MessageLookupByLibrary.simpleMessage(
      "This invitation has expired.",
    ),
    "invitationAcceptErrorGeneric": MessageLookupByLibrary.simpleMessage(
      "Unable to complete the operation. Please try again.",
    ),
    "invitationAcceptErrorInvalid": MessageLookupByLibrary.simpleMessage(
      "This invitation is not valid.",
    ),
    "invitationAcceptHintExistingAccount": MessageLookupByLibrary.simpleMessage(
      "Already have an account? Sign in to accept the invitation.",
    ),
    "invitationAcceptHintNoAccount": MessageLookupByLibrary.simpleMessage(
      "No account yet? Register first.",
    ),
    "invitationAcceptInProgress": MessageLookupByLibrary.simpleMessage(
      "Accepting invitation...",
    ),
    "invitationAcceptIntro": m34,
    "invitationAcceptLoading": MessageLookupByLibrary.simpleMessage(
      "Checking invitation...",
    ),
    "invitationAcceptLoginAction": MessageLookupByLibrary.simpleMessage(
      "Accept to continue",
    ),
    "invitationAcceptLoginRequired": MessageLookupByLibrary.simpleMessage(
      "Sign in with the invited email to continue.",
    ),
    "invitationAcceptRequiresRegistration":
        MessageLookupByLibrary.simpleMessage(
          "No account exists for this email yet. Use Register.",
        ),
    "invitationAcceptSuccessMessage": MessageLookupByLibrary.simpleMessage(
      "You can now use the management app with assigned permissions.",
    ),
    "invitationAcceptSuccessTitle": MessageLookupByLibrary.simpleMessage(
      "Invitation accepted",
    ),
    "invitationAcceptTitle": MessageLookupByLibrary.simpleMessage(
      "Accept invitation",
    ),
    "invitationDeclineButton": MessageLookupByLibrary.simpleMessage(
      "Decline invitation",
    ),
    "invitationDeclineGoLogin": MessageLookupByLibrary.simpleMessage(
      "Go to login",
    ),
    "invitationDeclineInProgress": MessageLookupByLibrary.simpleMessage(
      "Declining invitation...",
    ),
    "invitationDeclineSuccessMessage": MessageLookupByLibrary.simpleMessage(
      "You declined the invitation. No permission has been granted.",
    ),
    "invitationDeclineSuccessTitle": MessageLookupByLibrary.simpleMessage(
      "Invitation declined",
    ),
    "invitationGoToApplication": MessageLookupByLibrary.simpleMessage(
      "Go to application",
    ),
    "invitationRegisterAction": MessageLookupByLibrary.simpleMessage(
      "Register to accept",
    ),
    "invitationRegisterExistingUser": MessageLookupByLibrary.simpleMessage(
      "Email already registered. Sign in to accept the invitation.",
    ),
    "invitationRegisterInProgress": MessageLookupByLibrary.simpleMessage(
      "Registering...",
    ),
    "invitationRegisterPasswordConfirm": MessageLookupByLibrary.simpleMessage(
      "Confirm password",
    ),
    "invitationRegisterPasswordMismatch": MessageLookupByLibrary.simpleMessage(
      "Passwords do not match.",
    ),
    "invitationRegisterPasswordTooShort": MessageLookupByLibrary.simpleMessage(
      "Password must be at least 8 characters long.",
    ),
    "invitationRegisterPasswordWeak": MessageLookupByLibrary.simpleMessage(
      "Password must include at least one uppercase letter, one lowercase letter, and one number.",
    ),
    "invitationRegisterTitle": MessageLookupByLibrary.simpleMessage(
      "Register to accept invitation",
    ),
    "labelSelect": MessageLookupByLibrary.simpleMessage("Select"),
    "labelStaff": MessageLookupByLibrary.simpleMessage("Team:"),
    "lastVisitLabel": m35,
    "minutesLabel": MessageLookupByLibrary.simpleMessage("min"),
    "moreBookingNotificationsDescription": MessageLookupByLibrary.simpleMessage(
      "View booking notifications history",
    ),
    "moreBookingsDescription": MessageLookupByLibrary.simpleMessage(
      "Browse booking history",
    ),
    "moreProfileDescription": MessageLookupByLibrary.simpleMessage(
      "Manage your personal data and credentials",
    ),
    "moreReportsDescription": MessageLookupByLibrary.simpleMessage(
      "View statistics and business performance",
    ),
    "moreServicesDescription": MessageLookupByLibrary.simpleMessage(
      "Manage services, categories and pricing",
    ),
    "moreSubtitle": MessageLookupByLibrary.simpleMessage(
      "Access other application features",
    ),
    "moreSwitchBusinessDescription": MessageLookupByLibrary.simpleMessage(
      "Switch to another business",
    ),
    "moreTeamDescription": MessageLookupByLibrary.simpleMessage(
      "Manage operators, locations and working hours",
    ),
    "moveAppointmentConfirmMessage": m36,
    "moveAppointmentConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Confirm move?",
    ),
    "navAgenda": MessageLookupByLibrary.simpleMessage("Agenda"),
    "navClients": MessageLookupByLibrary.simpleMessage("Clients"),
    "navMore": MessageLookupByLibrary.simpleMessage("More"),
    "navProfile": MessageLookupByLibrary.simpleMessage("Profile"),
    "navServices": MessageLookupByLibrary.simpleMessage("Services"),
    "navStaff": MessageLookupByLibrary.simpleMessage("Team"),
    "newCategoryTitle": MessageLookupByLibrary.simpleMessage("New category"),
    "newServiceTitle": MessageLookupByLibrary.simpleMessage("New service"),
    "noClientForAppointment": MessageLookupByLibrary.simpleMessage(
      "No client for the appointment",
    ),
    "noServicesAdded": MessageLookupByLibrary.simpleMessage(
      "No services added",
    ),
    "noServicesFound": MessageLookupByLibrary.simpleMessage(
      "No services found",
    ),
    "noServicesInCategory": MessageLookupByLibrary.simpleMessage(
      "No services in this category",
    ),
    "noStaffAvailable": MessageLookupByLibrary.simpleMessage(
      "No team available",
    ),
    "notBookableOnline": MessageLookupByLibrary.simpleMessage(
      "Not bookable online",
    ),
    "notesPlaceholder": MessageLookupByLibrary.simpleMessage(
      "Notes about the appointment...",
    ),
    "operatorsAcceptedOn": m37,
    "operatorsDeleteInvite": MessageLookupByLibrary.simpleMessage(
      "Delete invite",
    ),
    "operatorsDeleteInviteConfirm": m38,
    "operatorsEditRole": MessageLookupByLibrary.simpleMessage("Edit role"),
    "operatorsEmpty": MessageLookupByLibrary.simpleMessage(
      "No operators configured",
    ),
    "operatorsExpires": m39,
    "operatorsInviteAlreadyHasAccess": MessageLookupByLibrary.simpleMessage(
      "This user already has access to the business.",
    ),
    "operatorsInviteAlreadyPending": MessageLookupByLibrary.simpleMessage(
      "An invite is already pending for this email. You can resend it from the pending invites list.",
    ),
    "operatorsInviteCopied": MessageLookupByLibrary.simpleMessage(
      "Invite link copied",
    ),
    "operatorsInviteEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "operatorsInviteEmailFailed": MessageLookupByLibrary.simpleMessage(
      "Unable to send the invitation email. Please try again later.",
    ),
    "operatorsInviteEmailUnavailable": MessageLookupByLibrary.simpleMessage(
      "Email sending is unavailable in this environment. Please contact support.",
    ),
    "operatorsInviteError": MessageLookupByLibrary.simpleMessage(
      "Unable to send invite",
    ),
    "operatorsInviteRole": MessageLookupByLibrary.simpleMessage("Role"),
    "operatorsInviteSend": MessageLookupByLibrary.simpleMessage("Send invite"),
    "operatorsInviteStatusAccepted": MessageLookupByLibrary.simpleMessage(
      "Accepted",
    ),
    "operatorsInviteStatusDeclined": MessageLookupByLibrary.simpleMessage(
      "Declined",
    ),
    "operatorsInviteStatusExpired": MessageLookupByLibrary.simpleMessage(
      "Expired",
    ),
    "operatorsInviteStatusPending": MessageLookupByLibrary.simpleMessage(
      "Pending",
    ),
    "operatorsInviteStatusRevoked": MessageLookupByLibrary.simpleMessage(
      "Revoked",
    ),
    "operatorsInviteSubtitle": MessageLookupByLibrary.simpleMessage(
      "Send an invite via email",
    ),
    "operatorsInviteSuccess": m40,
    "operatorsInviteTitle": MessageLookupByLibrary.simpleMessage(
      "Invite operator",
    ),
    "operatorsInvitedBy": m41,
    "operatorsInvitesHistoryCount": m42,
    "operatorsPendingInvites": MessageLookupByLibrary.simpleMessage(
      "Pending invites",
    ),
    "operatorsPendingInvitesCount": m43,
    "operatorsRemove": MessageLookupByLibrary.simpleMessage("Remove operator"),
    "operatorsRemoveConfirm": m44,
    "operatorsRemoveSuccess": MessageLookupByLibrary.simpleMessage(
      "Operator removed",
    ),
    "operatorsRevokeInvite": MessageLookupByLibrary.simpleMessage(
      "Revoke invite",
    ),
    "operatorsRevokeInviteConfirm": m45,
    "operatorsRoleAdmin": MessageLookupByLibrary.simpleMessage("Administrator"),
    "operatorsRoleAdminDesc": MessageLookupByLibrary.simpleMessage(
      "Full access to all features. Can manage other operators and modify business settings.",
    ),
    "operatorsRoleDescription": MessageLookupByLibrary.simpleMessage(
      "Select access level",
    ),
    "operatorsRoleManager": MessageLookupByLibrary.simpleMessage("Manager"),
    "operatorsRoleManagerDesc": MessageLookupByLibrary.simpleMessage(
      "Manages agenda and clients. Can view and manage all appointments, but cannot manage operators or settings.",
    ),
    "operatorsRoleOwner": MessageLookupByLibrary.simpleMessage("Owner"),
    "operatorsRoleStaff": MessageLookupByLibrary.simpleMessage("Staff"),
    "operatorsRoleStaffDesc": MessageLookupByLibrary.simpleMessage(
      "Views and manages only own appointments. Can create bookings assigned to themselves.",
    ),
    "operatorsRoleViewer": MessageLookupByLibrary.simpleMessage("Viewer"),
    "operatorsRoleViewerDesc": MessageLookupByLibrary.simpleMessage(
      "Can view appointments, services, staff, and availability. No edits allowed.",
    ),
    "operatorsScopeBusiness": MessageLookupByLibrary.simpleMessage(
      "All locations",
    ),
    "operatorsScopeBusinessDesc": MessageLookupByLibrary.simpleMessage(
      "Full access to all business locations",
    ),
    "operatorsScopeLocations": MessageLookupByLibrary.simpleMessage(
      "Specific locations",
    ),
    "operatorsScopeLocationsDesc": MessageLookupByLibrary.simpleMessage(
      "Access limited to selected locations",
    ),
    "operatorsScopeLocationsRequired": MessageLookupByLibrary.simpleMessage(
      "Select at least one location",
    ),
    "operatorsScopeSelectLocations": MessageLookupByLibrary.simpleMessage(
      "Select locations",
    ),
    "operatorsScopeTitle": MessageLookupByLibrary.simpleMessage("Access"),
    "operatorsSubtitle": MessageLookupByLibrary.simpleMessage(
      "Manage who can access the platform",
    ),
    "operatorsTitle": MessageLookupByLibrary.simpleMessage("Operators"),
    "operatorsYou": MessageLookupByLibrary.simpleMessage("You"),
    "permissionsDescription": MessageLookupByLibrary.simpleMessage(
      "Manage operator access and roles",
    ),
    "permissionsTitle": MessageLookupByLibrary.simpleMessage("Permissions"),
    "planningActive": MessageLookupByLibrary.simpleMessage("Active"),
    "planningBiweeklyDuration": m46,
    "planningBiweeklyHours": m47,
    "planningCreateTitle": MessageLookupByLibrary.simpleMessage("New planning"),
    "planningCurrentWeek": m48,
    "planningDeleteConfirm": MessageLookupByLibrary.simpleMessage(
      "Are you sure you want to delete this planning? Weekly schedules will be removed.",
    ),
    "planningDeleteTitle": MessageLookupByLibrary.simpleMessage(
      "Delete planning",
    ),
    "planningEditTitle": MessageLookupByLibrary.simpleMessage("Edit planning"),
    "planningFuture": MessageLookupByLibrary.simpleMessage("Future"),
    "planningHideExpired": MessageLookupByLibrary.simpleMessage("Hide expired"),
    "planningListAdd": MessageLookupByLibrary.simpleMessage("Add planning"),
    "planningListEmpty": MessageLookupByLibrary.simpleMessage(
      "No planning defined",
    ),
    "planningListTitle": MessageLookupByLibrary.simpleMessage("Planning"),
    "planningOpenEnded": MessageLookupByLibrary.simpleMessage("No end date"),
    "planningPast": MessageLookupByLibrary.simpleMessage("Past"),
    "planningSelectDate": MessageLookupByLibrary.simpleMessage("Select date"),
    "planningSetEndDate": MessageLookupByLibrary.simpleMessage("Set end date"),
    "planningShowExpired": m49,
    "planningType": MessageLookupByLibrary.simpleMessage("Planning type"),
    "planningTypeBiweekly": MessageLookupByLibrary.simpleMessage("Biweekly"),
    "planningTypeUnavailable": MessageLookupByLibrary.simpleMessage(
      "Unavailable",
    ),
    "planningTypeWeekly": MessageLookupByLibrary.simpleMessage("Weekly"),
    "planningValidFrom": MessageLookupByLibrary.simpleMessage(
      "Validity start date",
    ),
    "planningValidFromOnly": m50,
    "planningValidFromTo": m51,
    "planningValidTo": MessageLookupByLibrary.simpleMessage(
      "Validity end date",
    ),
    "planningValidityFrom": m52,
    "planningValidityRange": m53,
    "planningWeekA": MessageLookupByLibrary.simpleMessage("Week A"),
    "planningWeekB": MessageLookupByLibrary.simpleMessage("Week B"),
    "planningWeeklyDuration": m54,
    "planningWeeklyHours": m55,
    "popularServicesTitle": MessageLookupByLibrary.simpleMessage(
      "Most popular",
    ),
    "priceNotAvailable": MessageLookupByLibrary.simpleMessage("N/A"),
    "priceStartingFromPrefix": MessageLookupByLibrary.simpleMessage(
      "starting from",
    ),
    "priceStartingFromSwitch": MessageLookupByLibrary.simpleMessage(
      "Price ‚Äústarting from‚Äù",
    ),
    "profileChangePassword": MessageLookupByLibrary.simpleMessage(
      "Change password",
    ),
    "profileEmailChangeWarning": MessageLookupByLibrary.simpleMessage(
      "Warning: changing email will update your login credentials",
    ),
    "profileSwitchBusiness": MessageLookupByLibrary.simpleMessage(
      "Switch business",
    ),
    "profileTitle": MessageLookupByLibrary.simpleMessage("Profile"),
    "profileUpdateSuccess": MessageLookupByLibrary.simpleMessage(
      "Profile updated successfully",
    ),
    "recurrenceAfter": MessageLookupByLibrary.simpleMessage("After"),
    "recurrenceClientRequired": MessageLookupByLibrary.simpleMessage(
      "A client must be selected for recurring appointments",
    ),
    "recurrenceConflictForce": MessageLookupByLibrary.simpleMessage(
      "Create anyway",
    ),
    "recurrenceConflictForceDescription": MessageLookupByLibrary.simpleMessage(
      "Create appointments even if there are overlaps",
    ),
    "recurrenceConflictHandling": MessageLookupByLibrary.simpleMessage(
      "Overlaps",
    ),
    "recurrenceConflictSkip": MessageLookupByLibrary.simpleMessage(
      "Skip conflicting dates",
    ),
    "recurrenceConflictSkipDescription": MessageLookupByLibrary.simpleMessage(
      "Don\'t create appointments if there are overlaps",
    ),
    "recurrenceDay": MessageLookupByLibrary.simpleMessage("day"),
    "recurrenceDays": MessageLookupByLibrary.simpleMessage("days"),
    "recurrenceEnds": MessageLookupByLibrary.simpleMessage("Ends"),
    "recurrenceEvery": MessageLookupByLibrary.simpleMessage("Every"),
    "recurrenceFrequency": MessageLookupByLibrary.simpleMessage("Frequency"),
    "recurrenceMonth": MessageLookupByLibrary.simpleMessage("month"),
    "recurrenceMonths": MessageLookupByLibrary.simpleMessage("months"),
    "recurrenceNever": MessageLookupByLibrary.simpleMessage("For one year"),
    "recurrenceOccurrences": MessageLookupByLibrary.simpleMessage(
      "occurrences",
    ),
    "recurrenceOnDate": MessageLookupByLibrary.simpleMessage("On"),
    "recurrencePreviewConfirm": m56,
    "recurrencePreviewConflictForce": MessageLookupByLibrary.simpleMessage(
      "Create anyway",
    ),
    "recurrencePreviewConflictSkip": MessageLookupByLibrary.simpleMessage(
      "Skip due to conflict",
    ),
    "recurrencePreviewConflicts": m57,
    "recurrencePreviewCount": m58,
    "recurrencePreviewHint": MessageLookupByLibrary.simpleMessage(
      "Uncheck the dates you don\'t want to create",
    ),
    "recurrencePreviewSelected": m59,
    "recurrencePreviewTitle": MessageLookupByLibrary.simpleMessage(
      "Appointment preview",
    ),
    "recurrenceRepeatBlock": MessageLookupByLibrary.simpleMessage(
      "Repeat this block",
    ),
    "recurrenceRepeatBooking": MessageLookupByLibrary.simpleMessage(
      "Repeat this appointment",
    ),
    "recurrenceSelectDate": MessageLookupByLibrary.simpleMessage("Select date"),
    "recurrenceSeriesIcon": MessageLookupByLibrary.simpleMessage(
      "Recurring appointment",
    ),
    "recurrenceSeriesOf": m60,
    "recurrenceSummaryAppointments": MessageLookupByLibrary.simpleMessage(
      "Appointments:",
    ),
    "recurrenceSummaryConflict": MessageLookupByLibrary.simpleMessage(
      "Skipped due to conflict",
    ),
    "recurrenceSummaryCreated": m61,
    "recurrenceSummaryDeleted": MessageLookupByLibrary.simpleMessage("Deleted"),
    "recurrenceSummaryError": MessageLookupByLibrary.simpleMessage(
      "Error creating series",
    ),
    "recurrenceSummarySkipped": m62,
    "recurrenceSummaryTitle": MessageLookupByLibrary.simpleMessage(
      "Series created",
    ),
    "recurrenceWeek": MessageLookupByLibrary.simpleMessage("week"),
    "recurrenceWeeks": MessageLookupByLibrary.simpleMessage("weeks"),
    "recurringDeleteChooseScope": MessageLookupByLibrary.simpleMessage(
      "Which appointments do you want to delete?",
    ),
    "recurringDeleteMessage": m63,
    "recurringDeleteTitle": MessageLookupByLibrary.simpleMessage(
      "Delete recurring appointment",
    ),
    "recurringEditChooseScope": MessageLookupByLibrary.simpleMessage(
      "Which appointments do you want to edit?",
    ),
    "recurringEditMessage": m64,
    "recurringEditTitle": MessageLookupByLibrary.simpleMessage(
      "Edit recurring appointment",
    ),
    "recurringScopeAll": MessageLookupByLibrary.simpleMessage("All"),
    "recurringScopeOnlyThis": MessageLookupByLibrary.simpleMessage(
      "Only this one",
    ),
    "recurringScopeThisAndFuture": MessageLookupByLibrary.simpleMessage(
      "This and future",
    ),
    "removeClient": MessageLookupByLibrary.simpleMessage("Remove client"),
    "reorderCategoriesLabel": MessageLookupByLibrary.simpleMessage(
      "Categories",
    ),
    "reorderHelpDescription": MessageLookupByLibrary.simpleMessage(
      "Reorder categories and services by dragging them: the same order will be applied to online booking. Select whether to sort categories or services.",
    ),
    "reorderServicesLabel": MessageLookupByLibrary.simpleMessage("Services"),
    "reorderTitle": MessageLookupByLibrary.simpleMessage("Reorder"),
    "reportsByDayOfWeek": MessageLookupByLibrary.simpleMessage(
      "By day of week",
    ),
    "reportsByHour": MessageLookupByLibrary.simpleMessage("By hour"),
    "reportsByLocation": MessageLookupByLibrary.simpleMessage("By location"),
    "reportsByPeriod": MessageLookupByLibrary.simpleMessage("By period"),
    "reportsByService": MessageLookupByLibrary.simpleMessage("By service"),
    "reportsByStaff": MessageLookupByLibrary.simpleMessage("By staff"),
    "reportsColAppointments": MessageLookupByLibrary.simpleMessage(
      "Appointments",
    ),
    "reportsColAvailableHours": MessageLookupByLibrary.simpleMessage(
      "Effective",
    ),
    "reportsColAvgDuration": MessageLookupByLibrary.simpleMessage(
      "Avg. duration",
    ),
    "reportsColAvgRevenue": MessageLookupByLibrary.simpleMessage("Average"),
    "reportsColBlockedHours": MessageLookupByLibrary.simpleMessage("Blocked"),
    "reportsColCategory": MessageLookupByLibrary.simpleMessage("Category"),
    "reportsColDay": MessageLookupByLibrary.simpleMessage("Day"),
    "reportsColHour": MessageLookupByLibrary.simpleMessage("Hour"),
    "reportsColHours": MessageLookupByLibrary.simpleMessage("Hours"),
    "reportsColLocation": MessageLookupByLibrary.simpleMessage("Location"),
    "reportsColOffHours": MessageLookupByLibrary.simpleMessage("Time Off"),
    "reportsColPercentage": MessageLookupByLibrary.simpleMessage("%"),
    "reportsColPeriod": MessageLookupByLibrary.simpleMessage("Period"),
    "reportsColRevenue": MessageLookupByLibrary.simpleMessage("Revenue"),
    "reportsColScheduledHours": MessageLookupByLibrary.simpleMessage(
      "Scheduled",
    ),
    "reportsColService": MessageLookupByLibrary.simpleMessage("Service"),
    "reportsColStaff": MessageLookupByLibrary.simpleMessage("Staff"),
    "reportsColUtilization": MessageLookupByLibrary.simpleMessage("Occupancy"),
    "reportsColWorkedHours": MessageLookupByLibrary.simpleMessage("Booked"),
    "reportsFilterLocations": MessageLookupByLibrary.simpleMessage("Locations"),
    "reportsFilterServices": MessageLookupByLibrary.simpleMessage("Services"),
    "reportsFilterStaff": MessageLookupByLibrary.simpleMessage("Staff"),
    "reportsFilterStatus": MessageLookupByLibrary.simpleMessage("Status"),
    "reportsFullPeriodToggle": MessageLookupByLibrary.simpleMessage(
      "Include full period (future included)",
    ),
    "reportsNoData": MessageLookupByLibrary.simpleMessage("No data available"),
    "reportsOccupancyPercentage": MessageLookupByLibrary.simpleMessage(
      "Occupancy",
    ),
    "reportsPresetCustom": MessageLookupByLibrary.simpleMessage(
      "Choose period",
    ),
    "reportsPresetLast3Months": MessageLookupByLibrary.simpleMessage(
      "Last 3 months",
    ),
    "reportsPresetLast6Months": MessageLookupByLibrary.simpleMessage(
      "Last 6 months",
    ),
    "reportsPresetLastMonth": MessageLookupByLibrary.simpleMessage(
      "Last month",
    ),
    "reportsPresetLastYear": MessageLookupByLibrary.simpleMessage(
      "Previous year",
    ),
    "reportsPresetMonth": MessageLookupByLibrary.simpleMessage("Current month"),
    "reportsPresetQuarter": MessageLookupByLibrary.simpleMessage(
      "Current quarter",
    ),
    "reportsPresetSemester": MessageLookupByLibrary.simpleMessage(
      "Current semester",
    ),
    "reportsPresetToday": MessageLookupByLibrary.simpleMessage("Today"),
    "reportsPresetWeek": MessageLookupByLibrary.simpleMessage("This week"),
    "reportsPresetYear": MessageLookupByLibrary.simpleMessage("Current year"),
    "reportsPresets": MessageLookupByLibrary.simpleMessage("Period presets"),
    "reportsTabAppointments": MessageLookupByLibrary.simpleMessage(
      "Appointments",
    ),
    "reportsTabStaff": MessageLookupByLibrary.simpleMessage("Team"),
    "reportsTitle": MessageLookupByLibrary.simpleMessage("Reports"),
    "reportsTotalAppointments": MessageLookupByLibrary.simpleMessage(
      "Appointments",
    ),
    "reportsTotalHours": MessageLookupByLibrary.simpleMessage("Hours worked"),
    "reportsTotalRevenue": MessageLookupByLibrary.simpleMessage("Revenue"),
    "reportsUniqueClients": MessageLookupByLibrary.simpleMessage(
      "Unique clients",
    ),
    "reportsWorkHoursAvailable": MessageLookupByLibrary.simpleMessage(
      "Effective",
    ),
    "reportsWorkHoursBlocked": MessageLookupByLibrary.simpleMessage("Blocked"),
    "reportsWorkHoursOff": MessageLookupByLibrary.simpleMessage("Time Off"),
    "reportsWorkHoursScheduled": MessageLookupByLibrary.simpleMessage(
      "Scheduled",
    ),
    "reportsWorkHoursSubtitle": MessageLookupByLibrary.simpleMessage(
      "Summary of scheduled, worked hours and absences",
    ),
    "reportsWorkHoursTitle": MessageLookupByLibrary.simpleMessage("Staff"),
    "reportsWorkHoursUtilization": MessageLookupByLibrary.simpleMessage(
      "Occupancy",
    ),
    "reportsWorkHoursWorked": MessageLookupByLibrary.simpleMessage("Booked"),
    "resourceDeleteConfirm": MessageLookupByLibrary.simpleMessage(
      "Delete this resource?",
    ),
    "resourceDeleteWarning": MessageLookupByLibrary.simpleMessage(
      "Services using this resource will no longer be constrained by its availability",
    ),
    "resourceEdit": MessageLookupByLibrary.simpleMessage("Edit resource"),
    "resourceNameLabel": MessageLookupByLibrary.simpleMessage("Resource name"),
    "resourceNew": MessageLookupByLibrary.simpleMessage("New resource"),
    "resourceNoServicesSelected": MessageLookupByLibrary.simpleMessage(
      "No services associated",
    ),
    "resourceNoneLabel": MessageLookupByLibrary.simpleMessage(
      "No resources required",
    ),
    "resourceNoteLabel": MessageLookupByLibrary.simpleMessage(
      "Notes (optional)",
    ),
    "resourceQuantityLabel": MessageLookupByLibrary.simpleMessage(
      "Available quantity",
    ),
    "resourceQuantityRequired": MessageLookupByLibrary.simpleMessage(
      "Qty required",
    ),
    "resourceSelectLabel": MessageLookupByLibrary.simpleMessage(
      "Select resources",
    ),
    "resourceSelectServices": MessageLookupByLibrary.simpleMessage(
      "Select services",
    ),
    "resourceServiceCountPlural": m65,
    "resourceServiceCountSingular": MessageLookupByLibrary.simpleMessage(
      "1 service",
    ),
    "resourceServicesLabel": MessageLookupByLibrary.simpleMessage(
      "Services using this resource",
    ),
    "resourceTypeLabel": MessageLookupByLibrary.simpleMessage(
      "Type (optional)",
    ),
    "resourcesEmpty": MessageLookupByLibrary.simpleMessage(
      "No resources configured for this location",
    ),
    "resourcesEmptyHint": MessageLookupByLibrary.simpleMessage(
      "Resources are equipment or spaces (e.g., cabins, beds) that can be associated with services",
    ),
    "resourcesTitle": MessageLookupByLibrary.simpleMessage("Resources"),
    "searchClientPlaceholder": MessageLookupByLibrary.simpleMessage(
      "Search client...",
    ),
    "searchServices": MessageLookupByLibrary.simpleMessage("Search service..."),
    "selectClientTitle": MessageLookupByLibrary.simpleMessage("Select client"),
    "selectService": MessageLookupByLibrary.simpleMessage("Select service"),
    "selectStaffTitle": MessageLookupByLibrary.simpleMessage("Select team"),
    "serviceColorLabel": MessageLookupByLibrary.simpleMessage("Service color"),
    "serviceDuplicateCopyWord": MessageLookupByLibrary.simpleMessage("Copy"),
    "serviceDuplicateError": MessageLookupByLibrary.simpleMessage(
      "A service with this name already exists",
    ),
    "serviceEligibleStaffCount": m66,
    "serviceEligibleStaffNone": MessageLookupByLibrary.simpleMessage(
      "No eligible team members",
    ),
    "serviceLocationsCount": m67,
    "serviceLocationsLabel": MessageLookupByLibrary.simpleMessage(
      "Available locations",
    ),
    "servicePackageActiveLabel": MessageLookupByLibrary.simpleMessage(
      "Package active",
    ),
    "servicePackageBrokenLabel": MessageLookupByLibrary.simpleMessage(
      "Invalid",
    ),
    "servicePackageCreatedMessage": MessageLookupByLibrary.simpleMessage(
      "The package has been created.",
    ),
    "servicePackageCreatedTitle": MessageLookupByLibrary.simpleMessage(
      "Package created",
    ),
    "servicePackageDeleteError": MessageLookupByLibrary.simpleMessage(
      "Failed to delete the package.",
    ),
    "servicePackageDeleteMessage": MessageLookupByLibrary.simpleMessage(
      "This action cannot be undone.",
    ),
    "servicePackageDeleteTitle": MessageLookupByLibrary.simpleMessage(
      "Delete package?",
    ),
    "servicePackageDeletedMessage": MessageLookupByLibrary.simpleMessage(
      "The package has been deleted.",
    ),
    "servicePackageDeletedTitle": MessageLookupByLibrary.simpleMessage(
      "Package deleted",
    ),
    "servicePackageDescriptionLabel": MessageLookupByLibrary.simpleMessage(
      "Description",
    ),
    "servicePackageEditTitle": MessageLookupByLibrary.simpleMessage(
      "Edit package",
    ),
    "servicePackageExpandError": MessageLookupByLibrary.simpleMessage(
      "Unable to expand the selected package.",
    ),
    "servicePackageInactiveLabel": MessageLookupByLibrary.simpleMessage(
      "Inactive",
    ),
    "servicePackageNameLabel": MessageLookupByLibrary.simpleMessage(
      "Package name",
    ),
    "servicePackageNewMenu": MessageLookupByLibrary.simpleMessage(
      "New package",
    ),
    "servicePackageNewTitle": MessageLookupByLibrary.simpleMessage(
      "New package",
    ),
    "servicePackageNoServices": MessageLookupByLibrary.simpleMessage(
      "No services selected",
    ),
    "servicePackageOrderLabel": MessageLookupByLibrary.simpleMessage(
      "Service order",
    ),
    "servicePackageOverrideDurationLabel": MessageLookupByLibrary.simpleMessage(
      "Package duration (min)",
    ),
    "servicePackageOverridePriceLabel": MessageLookupByLibrary.simpleMessage(
      "Package price",
    ),
    "servicePackageSaveError": MessageLookupByLibrary.simpleMessage(
      "Failed to save the package.",
    ),
    "servicePackageServicesLabel": MessageLookupByLibrary.simpleMessage(
      "Included services",
    ),
    "servicePackageServicesRequired": MessageLookupByLibrary.simpleMessage(
      "Select at least one service",
    ),
    "servicePackageUpdatedMessage": MessageLookupByLibrary.simpleMessage(
      "The package has been updated.",
    ),
    "servicePackageUpdatedTitle": MessageLookupByLibrary.simpleMessage(
      "Package updated",
    ),
    "servicePackagesEmptyState": MessageLookupByLibrary.simpleMessage(
      "No packages available",
    ),
    "servicePackagesTabLabel": MessageLookupByLibrary.simpleMessage("Packages"),
    "servicePackagesTitle": MessageLookupByLibrary.simpleMessage("Packages"),
    "serviceRequiredResourcesLabel": MessageLookupByLibrary.simpleMessage(
      "Required resources",
    ),
    "serviceSeedCategoryBodyDescription": MessageLookupByLibrary.simpleMessage(
      "Services dedicated to body wellness",
    ),
    "serviceSeedCategoryBodyName": MessageLookupByLibrary.simpleMessage(
      "Body Treatments",
    ),
    "serviceSeedCategoryFaceDescription": MessageLookupByLibrary.simpleMessage(
      "Aesthetic and rejuvenating care for the face",
    ),
    "serviceSeedCategoryFaceName": MessageLookupByLibrary.simpleMessage(
      "Facial Treatments",
    ),
    "serviceSeedCategorySportsDescription":
        MessageLookupByLibrary.simpleMessage(
          "Programs designed for athletes and active people",
        ),
    "serviceSeedCategorySportsName": MessageLookupByLibrary.simpleMessage(
      "Sports Treatments",
    ),
    "serviceSeedServiceFaceDescription": MessageLookupByLibrary.simpleMessage(
      "Cleansing and illuminating treatment",
    ),
    "serviceSeedServiceFaceName": MessageLookupByLibrary.simpleMessage(
      "Facial Treatment",
    ),
    "serviceSeedServiceRelaxDescription": MessageLookupByLibrary.simpleMessage(
      "Relaxing 30-minute treatment",
    ),
    "serviceSeedServiceRelaxName": MessageLookupByLibrary.simpleMessage(
      "Relax Massage",
    ),
    "serviceSeedServiceSportDescription": MessageLookupByLibrary.simpleMessage(
      "Intensive decontracting treatment",
    ),
    "serviceSeedServiceSportName": MessageLookupByLibrary.simpleMessage(
      "Sports Massage",
    ),
    "serviceStartsAfterMidnight": MessageLookupByLibrary.simpleMessage(
      "Cannot add service: the time exceeds midnight. Change the start time or staff member.",
    ),
    "servicesLabel": MessageLookupByLibrary.simpleMessage("services"),
    "servicesNewServiceMenu": MessageLookupByLibrary.simpleMessage(
      "New service",
    ),
    "servicesSelectedCount": m68,
    "servicesTabLabel": MessageLookupByLibrary.simpleMessage("Services"),
    "setPriceToEnable": MessageLookupByLibrary.simpleMessage(
      "Set a price to enable this option",
    ),
    "shiftDeleteAll": MessageLookupByLibrary.simpleMessage(
      "Delete all these shifts",
    ),
    "shiftDeleteAllDesc": m69,
    "shiftDeleteThisOnly": MessageLookupByLibrary.simpleMessage(
      "Delete only this shift",
    ),
    "shiftDeleteThisOnlyDesc": m70,
    "shiftEditAll": MessageLookupByLibrary.simpleMessage(
      "Edit all these shifts",
    ),
    "shiftEditAllDesc": m71,
    "shiftEditThisOnly": MessageLookupByLibrary.simpleMessage(
      "Edit only this shift",
    ),
    "shiftEditThisOnlyDesc": m72,
    "shiftEditTitle": MessageLookupByLibrary.simpleMessage("Edit shift"),
    "shiftEndTime": MessageLookupByLibrary.simpleMessage("End time"),
    "shiftStartTime": MessageLookupByLibrary.simpleMessage("Start time"),
    "showAllServices": MessageLookupByLibrary.simpleMessage(
      "Show all services",
    ),
    "sortByCreatedAtAsc": MessageLookupByLibrary.simpleMessage(
      "Created (oldest)",
    ),
    "sortByCreatedAtDesc": MessageLookupByLibrary.simpleMessage(
      "Created (newest)",
    ),
    "sortByLastNameAsc": MessageLookupByLibrary.simpleMessage(
      "Last name (A-Z)",
    ),
    "sortByLastNameDesc": MessageLookupByLibrary.simpleMessage(
      "Last name (Z-A)",
    ),
    "sortByNameAsc": MessageLookupByLibrary.simpleMessage("Name (A-Z)"),
    "sortByNameDesc": MessageLookupByLibrary.simpleMessage("Name (Z-A)"),
    "sortByTitle": MessageLookupByLibrary.simpleMessage("Sort by"),
    "staffEditHours": MessageLookupByLibrary.simpleMessage("Edit hours"),
    "staffFilterAllTeam": MessageLookupByLibrary.simpleMessage("All team"),
    "staffFilterOnDuty": MessageLookupByLibrary.simpleMessage("On duty team"),
    "staffFilterSelectMembers": MessageLookupByLibrary.simpleMessage(
      "Select team members",
    ),
    "staffFilterTitle": MessageLookupByLibrary.simpleMessage("Filter team"),
    "staffFilterTooltip": MessageLookupByLibrary.simpleMessage("Filter team"),
    "staffHubAvailabilitySubtitle": MessageLookupByLibrary.simpleMessage(
      "Configure weekly working hours",
    ),
    "staffHubAvailabilityTitle": MessageLookupByLibrary.simpleMessage(
      "Availability",
    ),
    "staffHubNotYetAvailable": MessageLookupByLibrary.simpleMessage(
      "Not yet available",
    ),
    "staffHubStatsSubtitle": MessageLookupByLibrary.simpleMessage(
      "Performance and workloads",
    ),
    "staffHubStatsTitle": MessageLookupByLibrary.simpleMessage("Statistics"),
    "staffHubTeamSubtitle": MessageLookupByLibrary.simpleMessage(
      "Manage members and roles",
    ),
    "staffHubTeamTitle": MessageLookupByLibrary.simpleMessage("Team"),
    "staffNotBookableOnlineMessage": MessageLookupByLibrary.simpleMessage(
      "This team member is not enabled for online bookings. You can change this in the staff edit form.",
    ),
    "staffNotBookableOnlineTitle": MessageLookupByLibrary.simpleMessage(
      "Not bookable online",
    ),
    "staffNotBookableOnlineTooltip": MessageLookupByLibrary.simpleMessage(
      "Not bookable online",
    ),
    "staffScreenPlaceholder": MessageLookupByLibrary.simpleMessage(
      "Team Screen",
    ),
    "statusCancelled": MessageLookupByLibrary.simpleMessage("Cancelled"),
    "statusCompleted": MessageLookupByLibrary.simpleMessage("Completed"),
    "statusConfirmed": MessageLookupByLibrary.simpleMessage("Confirmed"),
    "switchBusiness": MessageLookupByLibrary.simpleMessage("Switch"),
    "teamAddStaff": MessageLookupByLibrary.simpleMessage("Add team member"),
    "teamChooseLocationSingleButton": MessageLookupByLibrary.simpleMessage(
      "Select location",
    ),
    "teamChooseLocationsButton": MessageLookupByLibrary.simpleMessage(
      "Select locations",
    ),
    "teamDeleteLocationBlockedMessage": MessageLookupByLibrary.simpleMessage(
      "Remove all team members assigned to this location first.",
    ),
    "teamDeleteLocationBlockedTitle": MessageLookupByLibrary.simpleMessage(
      "Cannot delete location",
    ),
    "teamDeleteLocationMessage": MessageLookupByLibrary.simpleMessage(
      "The location will be removed from the team. This action cannot be undone.",
    ),
    "teamDeleteLocationTitle": MessageLookupByLibrary.simpleMessage(
      "Delete location?",
    ),
    "teamDeleteStaffMessage": MessageLookupByLibrary.simpleMessage(
      "The member will be removed from the team. This action cannot be undone.",
    ),
    "teamDeleteStaffTitle": MessageLookupByLibrary.simpleMessage(
      "Delete team member?",
    ),
    "teamEditLocationTitle": MessageLookupByLibrary.simpleMessage(
      "Edit location",
    ),
    "teamEditStaffTitle": MessageLookupByLibrary.simpleMessage(
      "Edit team member",
    ),
    "teamEligibleServicesCount": m73,
    "teamEligibleServicesLabel": MessageLookupByLibrary.simpleMessage(
      "Eligible services",
    ),
    "teamEligibleServicesNone": MessageLookupByLibrary.simpleMessage(
      "No eligible services",
    ),
    "teamEligibleStaffLabel": MessageLookupByLibrary.simpleMessage(
      "Eligible team members",
    ),
    "teamLocationAddressLabel": MessageLookupByLibrary.simpleMessage("Address"),
    "teamLocationAllowCustomerChooseStaffHint":
        MessageLookupByLibrary.simpleMessage(
          "If disabled, the system assigns the team member automatically",
        ),
    "teamLocationAllowCustomerChooseStaffLabel":
        MessageLookupByLibrary.simpleMessage(
          "Allow customers to choose the team member",
        ),
    "teamLocationBookingLimitsSection": MessageLookupByLibrary.simpleMessage(
      "Online booking limits",
    ),
    "teamLocationCancellationHoursAlways": MessageLookupByLibrary.simpleMessage(
      "Always",
    ),
    "teamLocationCancellationHoursHint": MessageLookupByLibrary.simpleMessage(
      "Minimum time before the appointment during which customers can still modify or cancel",
    ),
    "teamLocationCancellationHoursLabel": MessageLookupByLibrary.simpleMessage(
      "Modify/cancel window",
    ),
    "teamLocationCancellationHoursNever": MessageLookupByLibrary.simpleMessage(
      "Never",
    ),
    "teamLocationCancellationHoursUseBusiness":
        MessageLookupByLibrary.simpleMessage("Use business policy"),
    "teamLocationCancellationHoursUseBusinessWithValue": m74,
    "teamLocationDays": m75,
    "teamLocationEmailHint": MessageLookupByLibrary.simpleMessage(
      "Email for customer notifications",
    ),
    "teamLocationEmailLabel": MessageLookupByLibrary.simpleMessage("Email"),
    "teamLocationHours": m76,
    "teamLocationIsActiveHint": MessageLookupByLibrary.simpleMessage(
      "If disabled, the location will not be visible to customers",
    ),
    "teamLocationIsActiveLabel": MessageLookupByLibrary.simpleMessage(
      "Location active",
    ),
    "teamLocationLabel": MessageLookupByLibrary.simpleMessage("Location"),
    "teamLocationMaxBookingAdvanceHint": MessageLookupByLibrary.simpleMessage(
      "How far ahead customers can book",
    ),
    "teamLocationMaxBookingAdvanceLabel": MessageLookupByLibrary.simpleMessage(
      "Maximum booking advance",
    ),
    "teamLocationMinBookingNoticeHint": MessageLookupByLibrary.simpleMessage(
      "How far in advance customers must book",
    ),
    "teamLocationMinBookingNoticeLabel": MessageLookupByLibrary.simpleMessage(
      "Minimum booking notice",
    ),
    "teamLocationMinGapHint": MessageLookupByLibrary.simpleMessage(
      "Hide time slots that leave less than this time free",
    ),
    "teamLocationMinGapLabel": MessageLookupByLibrary.simpleMessage(
      "Minimum acceptable gap",
    ),
    "teamLocationMinutes": m77,
    "teamLocationNameLabel": MessageLookupByLibrary.simpleMessage(
      "Location name",
    ),
    "teamLocationSlotDisplayModeAll": MessageLookupByLibrary.simpleMessage(
      "Maximum availability",
    ),
    "teamLocationSlotDisplayModeAllHint": MessageLookupByLibrary.simpleMessage(
      "Show all available time slots",
    ),
    "teamLocationSlotDisplayModeLabel": MessageLookupByLibrary.simpleMessage(
      "Display mode",
    ),
    "teamLocationSlotDisplayModeMinGap": MessageLookupByLibrary.simpleMessage(
      "Reduce empty gaps",
    ),
    "teamLocationSlotDisplayModeMinGapHint":
        MessageLookupByLibrary.simpleMessage(
          "Hide slots that would create gaps too small to fill",
        ),
    "teamLocationSlotIntervalHint": MessageLookupByLibrary.simpleMessage(
      "How many minutes between each available slot in online booking (does not affect staff planning slots)",
    ),
    "teamLocationSlotIntervalLabel": MessageLookupByLibrary.simpleMessage(
      "Time slot interval",
    ),
    "teamLocationSmartSlotDescription": MessageLookupByLibrary.simpleMessage(
      "Configure how available times are shown to customers booking online. This does not change staff planning.",
    ),
    "teamLocationSmartSlotSection": MessageLookupByLibrary.simpleMessage(
      "Smart time slots",
    ),
    "teamLocationsLabel": MessageLookupByLibrary.simpleMessage("Locations"),
    "teamNewLocationTitle": MessageLookupByLibrary.simpleMessage(
      "New location",
    ),
    "teamNewStaffTitle": MessageLookupByLibrary.simpleMessage(
      "New team member",
    ),
    "teamNoStaffInLocation": MessageLookupByLibrary.simpleMessage(
      "No team members in this location",
    ),
    "teamReorderHelpDescription": MessageLookupByLibrary.simpleMessage(
      "Reorder locations and team members by dragging them. Select whether to sort locations or team. The order will also apply in the agenda section.",
    ),
    "teamSelectAllLocations": MessageLookupByLibrary.simpleMessage(
      "Select all",
    ),
    "teamSelectAllServices": MessageLookupByLibrary.simpleMessage("Select all"),
    "teamSelectedServicesButton": MessageLookupByLibrary.simpleMessage(
      "Selected services",
    ),
    "teamSelectedServicesCount": m78,
    "teamServicesLabel": MessageLookupByLibrary.simpleMessage("Services"),
    "teamStaffBookableOnlineLabel": MessageLookupByLibrary.simpleMessage(
      "Enabled for online bookings",
    ),
    "teamStaffColorLabel": MessageLookupByLibrary.simpleMessage("Color"),
    "teamStaffLabel": MessageLookupByLibrary.simpleMessage("Team"),
    "teamStaffLocationsLabel": MessageLookupByLibrary.simpleMessage(
      "Assigned locations",
    ),
    "teamStaffMultiLocationWarning": MessageLookupByLibrary.simpleMessage(
      "If the member works across multiple locations, make sure availability aligns with the selected locations.",
    ),
    "teamStaffNameLabel": MessageLookupByLibrary.simpleMessage("First name"),
    "teamStaffSurnameLabel": MessageLookupByLibrary.simpleMessage("Last name"),
    "validationInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Invalid email",
    ),
    "validationInvalidNumber": MessageLookupByLibrary.simpleMessage(
      "Invalid number",
    ),
    "validationInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Invalid phone",
    ),
    "validationNameOrLastNameRequired": MessageLookupByLibrary.simpleMessage(
      "Enter at least first name or last name",
    ),
    "validationRequired": MessageLookupByLibrary.simpleMessage("Required"),
    "weeklyScheduleAddShift": MessageLookupByLibrary.simpleMessage("Add shift"),
    "weeklyScheduleFor": MessageLookupByLibrary.simpleMessage("to"),
    "weeklyScheduleNotWorking": MessageLookupByLibrary.simpleMessage(
      "Not working",
    ),
    "weeklyScheduleRemoveShift": MessageLookupByLibrary.simpleMessage(
      "Remove shift",
    ),
    "weeklyScheduleTitle": MessageLookupByLibrary.simpleMessage("Weekly"),
    "weeklyScheduleTotalHours": m79,
  };
}
--- FILE: lib/core/l10n/date_time_formats.dart ---
import 'package:flutter/widgets.dart';
import 'package:intl/intl.dart';

/// Helper centralizzati per formattare date e orari in base alla locale corrente.
class DtFmt {
  DtFmt._();

  /// HH:mm secondo la locale; su it rimane 24h, su en pu√≤ essere 12/24 in base alle impostazioni.
  static String hm(BuildContext context, int hour, int minute) {
    final locale = Intl.getCurrentLocale();
    final dt = DateTime(0, 1, 1, hour, minute);
    // Prefer format 'HH:mm' but respect locale by using DateFormat.Hm
    return DateFormat.Hm(locale).format(dt);
  }

  /// Etichetta ora piena (senza minuti): es. "09:00" o "9 AM" a seconda locale.
  static String hOnly(BuildContext context, int hour) {
    final locale = Intl.getCurrentLocale();
    final dt = DateTime(0, 1, 1, hour, 0);
    return DateFormat.Hm(locale).format(dt);
  }

  /// Giorno breve localizzato per intestazioni (Lun, Mar, ... / Mon, Tue, ...)
  static String weekdayShort(BuildContext context, int weekdayIso) {
    final locale = Intl.getCurrentLocale();
    final now = DateTime.now();
    final base = now.subtract(Duration(days: now.weekday - weekdayIso));
    return DateFormat.E(locale).format(base);
  }

  /// Data compatta per form: "sab 6 dic 25" / "Sat 6 Dec 25"
  static String shortDate(BuildContext context, DateTime date) {
    final locale = Intl.getCurrentLocale();
    // E = giorno settimana abbreviato, d = giorno, MMM = mese abbreviato, yy = anno a 2 cifre
    return DateFormat('E d MMM yy', locale).format(date);
  }

  /// Data estesa localizzata: es. "sabato 14 febbraio 2026" / "Saturday, February 14, 2026".
  static String longDate(BuildContext context, DateTime date) {
    final locale = Intl.getCurrentLocale();
    return DateFormat.yMMMMEEEEd(locale).format(date);
  }
}
--- FILE: lib/core/l10n/l10n.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'intl/messages_all.dart';

// **************************************************************************
// Generator: Flutter Intl IDE plugin
// Made by Localizely
// **************************************************************************

// ignore_for_file: non_constant_identifier_names, lines_longer_than_80_chars
// ignore_for_file: join_return_with_assignment, prefer_final_in_for_each
// ignore_for_file: avoid_redundant_argument_values, avoid_escaping_inner_quotes

class L10n {
  L10n();

  static L10n? _current;

  static L10n get current {
    assert(
      _current != null,
      'No instance of L10n was loaded. Try to initialize the L10n delegate before accessing L10n.current.',
    );
    return _current!;
  }

  static const AppLocalizationDelegate delegate = AppLocalizationDelegate();

  static Future<L10n> load(Locale locale) {
    final name = (locale.countryCode?.isEmpty ?? false)
        ? locale.languageCode
        : locale.toString();
    final localeName = Intl.canonicalizedLocale(name);
    return initializeMessages(localeName).then((_) {
      Intl.defaultLocale = localeName;
      final instance = L10n();
      L10n._current = instance;

      return instance;
    });
  }

  static L10n of(BuildContext context) {
    final instance = L10n.maybeOf(context);
    assert(
      instance != null,
      'No instance of L10n present in the widget tree. Did you add L10n.delegate in localizationsDelegates?',
    );
    return instance!;
  }

  static L10n? maybeOf(BuildContext context) {
    return Localizations.of<L10n>(context, L10n);
  }

  /// `Agenda Platform`
  String get appTitle {
    return Intl.message(
      'Agenda Platform',
      name: 'appTitle',
      desc: '',
      args: [],
    );
  }

  /// `Agenda`
  String get navAgenda {
    return Intl.message('Agenda', name: 'navAgenda', desc: '', args: []);
  }

  /// `Clienti`
  String get navClients {
    return Intl.message('Clienti', name: 'navClients', desc: '', args: []);
  }

  /// `Servizi`
  String get navServices {
    return Intl.message('Servizi', name: 'navServices', desc: '', args: []);
  }

  /// `Team`
  String get navStaff {
    return Intl.message('Team', name: 'navStaff', desc: '', args: []);
  }

  /// `Profilo`
  String get navProfile {
    return Intl.message('Profilo', name: 'navProfile', desc: '', args: []);
  }

  /// `Altro`
  String get navMore {
    return Intl.message('Altro', name: 'navMore', desc: '', args: []);
  }

  /// `Elenco Clienti`
  String get clientsTitle {
    return Intl.message(
      'Elenco Clienti',
      name: 'clientsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Specificare almeno un builder per form factor`
  String get errorFormFactorBuilderRequired {
    return Intl.message(
      'Specificare almeno un builder per form factor',
      name: 'errorFormFactorBuilderRequired',
      desc: '',
      args: [],
    );
  }

  /// `Nessun builder disponibile per {factor}`
  String errorFormFactorBuilderMissing(String factor) {
    return Intl.message(
      'Nessun builder disponibile per $factor',
      name: 'errorFormFactorBuilderMissing',
      desc: '',
      args: [factor],
    );
  }

  /// `Errore`
  String get errorTitle {
    return Intl.message('Errore', name: 'errorTitle', desc: '', args: []);
  }

  /// `Pagina non trovata: {path}`
  String errorNotFound(String path) {
    return Intl.message(
      'Pagina non trovata: $path',
      name: 'errorNotFound',
      desc: '',
      args: [path],
    );
  }

  /// `Servizio non trovato`
  String get errorServiceNotFound {
    return Intl.message(
      'Servizio non trovato',
      name: 'errorServiceNotFound',
      desc: '',
      args: [],
    );
  }

  /// `Eccezione non trovata: {id}`
  String errorExceptionNotFound(int id) {
    return Intl.message(
      'Eccezione non trovata: $id',
      name: 'errorExceptionNotFound',
      desc: '',
      args: [id],
    );
  }

  /// `Schermata Team`
  String get staffScreenPlaceholder {
    return Intl.message(
      'Schermata Team',
      name: 'staffScreenPlaceholder',
      desc: '',
      args: [],
    );
  }

  /// `Elimina`
  String get actionDelete {
    return Intl.message('Elimina', name: 'actionDelete', desc: '', args: []);
  }

  /// `Annulla`
  String get actionCancel {
    return Intl.message('Annulla', name: 'actionCancel', desc: '', args: []);
  }

  /// `Conferma`
  String get actionConfirm {
    return Intl.message('Conferma', name: 'actionConfirm', desc: '', args: []);
  }

  /// `Chiudi`
  String get actionClose {
    return Intl.message('Chiudi', name: 'actionClose', desc: '', args: []);
  }

  /// `Riprova`
  String get actionRetry {
    return Intl.message('Riprova', name: 'actionRetry', desc: '', args: []);
  }

  /// `Riprogramma`
  String get actionReschedule {
    return Intl.message(
      'Riprogramma',
      name: 'actionReschedule',
      desc: '',
      args: [],
    );
  }

  /// `Confermi l‚Äôeliminazione?`
  String get deleteConfirmationTitle {
    return Intl.message(
      'Confermi l‚Äôeliminazione?',
      name: 'deleteConfirmationTitle',
      desc: '',
      args: [],
    );
  }

  /// `Modalit√† riprogrammazione attiva: seleziona una data e clicca uno slot.`
  String get bookingRescheduleModeHint {
    return Intl.message(
      'Modalit√† riprogrammazione attiva: seleziona una data e clicca uno slot.',
      name: 'bookingRescheduleModeHint',
      desc: '',
      args: [],
    );
  }

  /// `Annulla riprogrammazione`
  String get bookingRescheduleCancelAction {
    return Intl.message(
      'Annulla riprogrammazione',
      name: 'bookingRescheduleCancelAction',
      desc: '',
      args: [],
    );
  }

  /// `Confermi la riprogrammazione?`
  String get bookingRescheduleConfirmTitle {
    return Intl.message(
      'Confermi la riprogrammazione?',
      name: 'bookingRescheduleConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `La prenotazione verr√† spostata al {date} alle {time} per {staffName}.`
  String bookingRescheduleConfirmMessage(
    String date,
    String time,
    String staffName,
  ) {
    return Intl.message(
      'La prenotazione verr√† spostata al $date alle $time per $staffName.',
      name: 'bookingRescheduleConfirmMessage',
      desc: '',
      args: [date, time, staffName],
    );
  }

  /// `Impossibile riprogrammare la prenotazione.`
  String get bookingRescheduleMoveFailed {
    return Intl.message(
      'Impossibile riprogrammare la prenotazione.',
      name: 'bookingRescheduleMoveFailed',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione non trovata.`
  String get bookingRescheduleMissingBooking {
    return Intl.message(
      'Prenotazione non trovata.',
      name: 'bookingRescheduleMissingBooking',
      desc: '',
      args: [],
    );
  }

  /// `Oggi`
  String get agendaToday {
    return Intl.message('Oggi', name: 'agendaToday', desc: '', args: []);
  }

  /// `Giorno precedente`
  String get agendaPrevDay {
    return Intl.message(
      'Giorno precedente',
      name: 'agendaPrevDay',
      desc: '',
      args: [],
    );
  }

  /// `Giorno successivo`
  String get agendaNextDay {
    return Intl.message(
      'Giorno successivo',
      name: 'agendaNextDay',
      desc: '',
      args: [],
    );
  }

  /// `Settimana precedente`
  String get agendaPrevWeek {
    return Intl.message(
      'Settimana precedente',
      name: 'agendaPrevWeek',
      desc: '',
      args: [],
    );
  }

  /// `Settimana successivo`
  String get agendaNextWeek {
    return Intl.message(
      'Settimana successivo',
      name: 'agendaNextWeek',
      desc: '',
      args: [],
    );
  }

  /// `Mese precedente`
  String get agendaPrevMonth {
    return Intl.message(
      'Mese precedente',
      name: 'agendaPrevMonth',
      desc: '',
      args: [],
    );
  }

  /// `Mese successivo`
  String get agendaNextMonth {
    return Intl.message(
      'Mese successivo',
      name: 'agendaNextMonth',
      desc: '',
      args: [],
    );
  }

  /// `Nessuna sede disponibile`
  String get agendaNoLocations {
    return Intl.message(
      'Nessuna sede disponibile',
      name: 'agendaNoLocations',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona sede`
  String get agendaSelectLocation {
    return Intl.message(
      'Seleziona sede',
      name: 'agendaSelectLocation',
      desc: '',
      args: [],
    );
  }

  /// `Tutte le sedi`
  String get allLocations {
    return Intl.message(
      'Tutte le sedi',
      name: 'allLocations',
      desc: '',
      args: [],
    );
  }

  /// `Disponibilit√† settimanale`
  String get availabilityTitle {
    return Intl.message(
      'Disponibilit√† settimanale',
      name: 'availabilityTitle',
      desc: '',
      args: [],
    );
  }

  /// `Disponibilit√† ‚Äì {name}`
  String availabilityTitleFor(String name) {
    return Intl.message(
      'Disponibilit√† ‚Äì $name',
      name: 'availabilityTitleFor',
      desc: '',
      args: [name],
    );
  }

  /// `Salva modifiche`
  String get availabilitySave {
    return Intl.message(
      'Salva modifiche',
      name: 'availabilitySave',
      desc: '',
      args: [],
    );
  }

  /// `Settimana corrente`
  String get currentWeek {
    return Intl.message(
      'Settimana corrente',
      name: 'currentWeek',
      desc: '',
      args: [],
    );
  }

  /// `{hours}h {minutes}m`
  String hoursMinutesCompact(Object hours, Object minutes) {
    return Intl.message(
      '${hours}h ${minutes}m',
      name: 'hoursMinutesCompact',
      desc: '',
      args: [hours, minutes],
    );
  }

  /// `{hours}h`
  String hoursHoursOnly(Object hours) {
    return Intl.message(
      '${hours}h',
      name: 'hoursHoursOnly',
      desc: '',
      args: [hours],
    );
  }

  /// `Team:`
  String get labelStaff {
    return Intl.message('Team:', name: 'labelStaff', desc: '', args: []);
  }

  /// `Seleziona`
  String get labelSelect {
    return Intl.message('Seleziona', name: 'labelSelect', desc: '', args: []);
  }

  /// `Disponibilit√†`
  String get staffHubAvailabilityTitle {
    return Intl.message(
      'Disponibilit√†',
      name: 'staffHubAvailabilityTitle',
      desc: '',
      args: [],
    );
  }

  /// `Configura gli orari di lavoro settimanali`
  String get staffHubAvailabilitySubtitle {
    return Intl.message(
      'Configura gli orari di lavoro settimanali',
      name: 'staffHubAvailabilitySubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Team`
  String get staffHubTeamTitle {
    return Intl.message('Team', name: 'staffHubTeamTitle', desc: '', args: []);
  }

  /// `Gestione membri e ruoli`
  String get staffHubTeamSubtitle {
    return Intl.message(
      'Gestione membri e ruoli',
      name: 'staffHubTeamSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Statistiche`
  String get staffHubStatsTitle {
    return Intl.message(
      'Statistiche',
      name: 'staffHubStatsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Performance e carichi di lavoro`
  String get staffHubStatsSubtitle {
    return Intl.message(
      'Performance e carichi di lavoro',
      name: 'staffHubStatsSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Non ancora disponibile`
  String get staffHubNotYetAvailable {
    return Intl.message(
      'Non ancora disponibile',
      name: 'staffHubNotYetAvailable',
      desc: '',
      args: [],
    );
  }

  /// `Modifica orari`
  String get staffEditHours {
    return Intl.message(
      'Modifica orari',
      name: 'staffEditHours',
      desc: '',
      args: [],
    );
  }

  /// `Modifica`
  String get actionEdit {
    return Intl.message('Modifica', name: 'actionEdit', desc: '', args: []);
  }

  /// `{minutes} min`
  String durationMinute(Object minutes) {
    return Intl.message(
      '$minutes min',
      name: 'durationMinute',
      desc: '',
      args: [minutes],
    );
  }

  /// `{hours} ora`
  String durationHour(Object hours) {
    return Intl.message(
      '$hours ora',
      name: 'durationHour',
      desc: '',
      args: [hours],
    );
  }

  /// `{hours} ora {minutes} min`
  String durationHourMinute(Object hours, Object minutes) {
    return Intl.message(
      '$hours ora $minutes min',
      name: 'durationHourMinute',
      desc: '',
      args: [hours, minutes],
    );
  }

  /// `Gratis`
  String get freeLabel {
    return Intl.message('Gratis', name: 'freeLabel', desc: '', args: []);
  }

  /// `a partire da`
  String get priceStartingFromPrefix {
    return Intl.message(
      'a partire da',
      name: 'priceStartingFromPrefix',
      desc: '',
      args: [],
    );
  }

  /// `N/D`
  String get priceNotAvailable {
    return Intl.message('N/D', name: 'priceNotAvailable', desc: '', args: []);
  }

  /// `Nuovo cliente`
  String get clientsNew {
    return Intl.message(
      'Nuovo cliente',
      name: 'clientsNew',
      desc: '',
      args: [],
    );
  }

  /// `Modifica cliente`
  String get clientsEdit {
    return Intl.message(
      'Modifica cliente',
      name: 'clientsEdit',
      desc: '',
      args: [],
    );
  }

  /// `Nessun cliente`
  String get clientsEmpty {
    return Intl.message(
      'Nessun cliente',
      name: 'clientsEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Salva`
  String get actionSave {
    return Intl.message('Salva', name: 'actionSave', desc: '', args: []);
  }

  /// `Tutti`
  String get filterAll {
    return Intl.message('Tutti', name: 'filterAll', desc: '', args: []);
  }

  /// `VIP`
  String get filterVIP {
    return Intl.message('VIP', name: 'filterVIP', desc: '', args: []);
  }

  /// `Inattivi`
  String get filterInactive {
    return Intl.message('Inattivi', name: 'filterInactive', desc: '', args: []);
  }

  /// `Nuovi`
  String get filterNew {
    return Intl.message('Nuovi', name: 'filterNew', desc: '', args: []);
  }

  /// `Nome`
  String get formFirstName {
    return Intl.message('Nome', name: 'formFirstName', desc: '', args: []);
  }

  /// `Cognome`
  String get formLastName {
    return Intl.message('Cognome', name: 'formLastName', desc: '', args: []);
  }

  /// `Email`
  String get formEmail {
    return Intl.message('Email', name: 'formEmail', desc: '', args: []);
  }

  /// `Telefono`
  String get formPhone {
    return Intl.message('Telefono', name: 'formPhone', desc: '', args: []);
  }

  /// `Note (non visibili al cliente)`
  String get formNotes {
    return Intl.message(
      'Note (non visibili al cliente)',
      name: 'formNotes',
      desc: '',
      args: [],
    );
  }

  /// `Richiesto`
  String get validationRequired {
    return Intl.message(
      'Richiesto',
      name: 'validationRequired',
      desc: '',
      args: [],
    );
  }

  /// `Email non valida`
  String get validationInvalidEmail {
    return Intl.message(
      'Email non valida',
      name: 'validationInvalidEmail',
      desc: '',
      args: [],
    );
  }

  /// `Telefono non valido`
  String get validationInvalidPhone {
    return Intl.message(
      'Telefono non valido',
      name: 'validationInvalidPhone',
      desc: '',
      args: [],
    );
  }

  /// `Ultima visita: {date}`
  String lastVisitLabel(String date) {
    return Intl.message(
      'Ultima visita: $date',
      name: 'lastVisitLabel',
      desc: '',
      args: [date],
    );
  }

  /// `Inserire almeno nome o cognome`
  String get validationNameOrLastNameRequired {
    return Intl.message(
      'Inserire almeno nome o cognome',
      name: 'validationNameOrLastNameRequired',
      desc: '',
      args: [],
    );
  }

  /// `Servizi`
  String get servicesTabLabel {
    return Intl.message(
      'Servizi',
      name: 'servicesTabLabel',
      desc: '',
      args: [],
    );
  }

  /// `Pacchetti`
  String get servicePackagesTabLabel {
    return Intl.message(
      'Pacchetti',
      name: 'servicePackagesTabLabel',
      desc: '',
      args: [],
    );
  }

  /// `Pacchetti`
  String get servicePackagesTitle {
    return Intl.message(
      'Pacchetti',
      name: 'servicePackagesTitle',
      desc: '',
      args: [],
    );
  }

  /// `I pi√π richiesti`
  String get popularServicesTitle {
    return Intl.message(
      'I pi√π richiesti',
      name: 'popularServicesTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessun pacchetto disponibile`
  String get servicePackagesEmptyState {
    return Intl.message(
      'Nessun pacchetto disponibile',
      name: 'servicePackagesEmptyState',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo pacchetto`
  String get servicePackageNewMenu {
    return Intl.message(
      'Nuovo pacchetto',
      name: 'servicePackageNewMenu',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo pacchetto`
  String get servicePackageNewTitle {
    return Intl.message(
      'Nuovo pacchetto',
      name: 'servicePackageNewTitle',
      desc: '',
      args: [],
    );
  }

  /// `Modifica pacchetto`
  String get servicePackageEditTitle {
    return Intl.message(
      'Modifica pacchetto',
      name: 'servicePackageEditTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nome pacchetto`
  String get servicePackageNameLabel {
    return Intl.message(
      'Nome pacchetto',
      name: 'servicePackageNameLabel',
      desc: '',
      args: [],
    );
  }

  /// `Descrizione`
  String get servicePackageDescriptionLabel {
    return Intl.message(
      'Descrizione',
      name: 'servicePackageDescriptionLabel',
      desc: '',
      args: [],
    );
  }

  /// `Prezzo pacchetto`
  String get servicePackageOverridePriceLabel {
    return Intl.message(
      'Prezzo pacchetto',
      name: 'servicePackageOverridePriceLabel',
      desc: '',
      args: [],
    );
  }

  /// `Durata pacchetto (min)`
  String get servicePackageOverrideDurationLabel {
    return Intl.message(
      'Durata pacchetto (min)',
      name: 'servicePackageOverrideDurationLabel',
      desc: '',
      args: [],
    );
  }

  /// `Pacchetto attivo`
  String get servicePackageActiveLabel {
    return Intl.message(
      'Pacchetto attivo',
      name: 'servicePackageActiveLabel',
      desc: '',
      args: [],
    );
  }

  /// `Servizi inclusi`
  String get servicePackageServicesLabel {
    return Intl.message(
      'Servizi inclusi',
      name: 'servicePackageServicesLabel',
      desc: '',
      args: [],
    );
  }

  /// `Ordine servizi`
  String get servicePackageOrderLabel {
    return Intl.message(
      'Ordine servizi',
      name: 'servicePackageOrderLabel',
      desc: '',
      args: [],
    );
  }

  /// `Nessun servizio selezionato`
  String get servicePackageNoServices {
    return Intl.message(
      'Nessun servizio selezionato',
      name: 'servicePackageNoServices',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona almeno un servizio`
  String get servicePackageServicesRequired {
    return Intl.message(
      'Seleziona almeno un servizio',
      name: 'servicePackageServicesRequired',
      desc: '',
      args: [],
    );
  }

  /// `Pacchetto creato`
  String get servicePackageCreatedTitle {
    return Intl.message(
      'Pacchetto creato',
      name: 'servicePackageCreatedTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il pacchetto √® stato creato.`
  String get servicePackageCreatedMessage {
    return Intl.message(
      'Il pacchetto √® stato creato.',
      name: 'servicePackageCreatedMessage',
      desc: '',
      args: [],
    );
  }

  /// `Pacchetto aggiornato`
  String get servicePackageUpdatedTitle {
    return Intl.message(
      'Pacchetto aggiornato',
      name: 'servicePackageUpdatedTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il pacchetto √® stato aggiornato.`
  String get servicePackageUpdatedMessage {
    return Intl.message(
      'Il pacchetto √® stato aggiornato.',
      name: 'servicePackageUpdatedMessage',
      desc: '',
      args: [],
    );
  }

  /// `Errore nel salvataggio del pacchetto.`
  String get servicePackageSaveError {
    return Intl.message(
      'Errore nel salvataggio del pacchetto.',
      name: 'servicePackageSaveError',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare il pacchetto?`
  String get servicePackageDeleteTitle {
    return Intl.message(
      'Eliminare il pacchetto?',
      name: 'servicePackageDeleteTitle',
      desc: '',
      args: [],
    );
  }

  /// `Questa azione non pu√≤ essere annullata.`
  String get servicePackageDeleteMessage {
    return Intl.message(
      'Questa azione non pu√≤ essere annullata.',
      name: 'servicePackageDeleteMessage',
      desc: '',
      args: [],
    );
  }

  /// `Pacchetto eliminato`
  String get servicePackageDeletedTitle {
    return Intl.message(
      'Pacchetto eliminato',
      name: 'servicePackageDeletedTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il pacchetto √® stato eliminato.`
  String get servicePackageDeletedMessage {
    return Intl.message(
      'Il pacchetto √® stato eliminato.',
      name: 'servicePackageDeletedMessage',
      desc: '',
      args: [],
    );
  }

  /// `Errore durante l'eliminazione del pacchetto.`
  String get servicePackageDeleteError {
    return Intl.message(
      'Errore durante l\'eliminazione del pacchetto.',
      name: 'servicePackageDeleteError',
      desc: '',
      args: [],
    );
  }

  /// `Inattivo`
  String get servicePackageInactiveLabel {
    return Intl.message(
      'Inattivo',
      name: 'servicePackageInactiveLabel',
      desc: '',
      args: [],
    );
  }

  /// `Non valido`
  String get servicePackageBrokenLabel {
    return Intl.message(
      'Non valido',
      name: 'servicePackageBrokenLabel',
      desc: '',
      args: [],
    );
  }

  /// `servizi`
  String get servicesLabel {
    return Intl.message('servizi', name: 'servicesLabel', desc: '', args: []);
  }

  /// `min`
  String get minutesLabel {
    return Intl.message('min', name: 'minutesLabel', desc: '', args: []);
  }

  /// `Aggiungi pacchetto`
  String get addPackage {
    return Intl.message(
      'Aggiungi pacchetto',
      name: 'addPackage',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile espandere il pacchetto selezionato.`
  String get servicePackageExpandError {
    return Intl.message(
      'Impossibile espandere il pacchetto selezionato.',
      name: 'servicePackageExpandError',
      desc: '',
      args: [],
    );
  }

  /// `Numero non valido`
  String get validationInvalidNumber {
    return Intl.message(
      'Numero non valido',
      name: 'validationInvalidNumber',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi`
  String get agendaAdd {
    return Intl.message('Aggiungi', name: 'agendaAdd', desc: '', args: []);
  }

  /// `Aggiungi un...`
  String get agendaAddTitle {
    return Intl.message(
      'Aggiungi un...',
      name: 'agendaAddTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo appuntamento`
  String get agendaAddAppointment {
    return Intl.message(
      'Nuovo appuntamento',
      name: 'agendaAddAppointment',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo blocco`
  String get agendaAddBlock {
    return Intl.message(
      'Nuovo blocco',
      name: 'agendaAddBlock',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo appuntamento`
  String get appointmentDialogTitleNew {
    return Intl.message(
      'Nuovo appuntamento',
      name: 'appointmentDialogTitleNew',
      desc: '',
      args: [],
    );
  }

  /// `Modifica appuntamento`
  String get appointmentDialogTitleEdit {
    return Intl.message(
      'Modifica appuntamento',
      name: 'appointmentDialogTitleEdit',
      desc: '',
      args: [],
    );
  }

  /// `Data`
  String get formDate {
    return Intl.message('Data', name: 'formDate', desc: '', args: []);
  }

  /// `Servizio`
  String get formService {
    return Intl.message('Servizio', name: 'formService', desc: '', args: []);
  }

  /// `Cliente`
  String get formClient {
    return Intl.message('Cliente', name: 'formClient', desc: '', args: []);
  }

  /// `Team`
  String get formStaff {
    return Intl.message('Team', name: 'formStaff', desc: '', args: []);
  }

  /// `Dettagli prenotazione`
  String get bookingDetails {
    return Intl.message(
      'Dettagli prenotazione',
      name: 'bookingDetails',
      desc: '',
      args: [],
    );
  }

  /// `Note prenotazione`
  String get bookingNotes {
    return Intl.message(
      'Note prenotazione',
      name: 'bookingNotes',
      desc: '',
      args: [],
    );
  }

  /// `Note`
  String get appointmentNotesTitle {
    return Intl.message(
      'Note',
      name: 'appointmentNotesTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nota sull'appuntamento`
  String get appointmentNoteLabel {
    return Intl.message(
      'Nota sull\'appuntamento',
      name: 'appointmentNoteLabel',
      desc: '',
      args: [],
    );
  }

  /// `Nota sul cliente`
  String get clientNoteLabel {
    return Intl.message(
      'Nota sul cliente',
      name: 'clientNoteLabel',
      desc: '',
      args: [],
    );
  }

  /// `Servizi`
  String get bookingItems {
    return Intl.message('Servizi', name: 'bookingItems', desc: '', args: []);
  }

  /// `Totale`
  String get bookingTotal {
    return Intl.message('Totale', name: 'bookingTotal', desc: '', args: []);
  }

  /// `Attenzione: l‚Äôorario selezionato per l‚Äôappuntamento include fasce non disponibili per il team scelto.`
  String get bookingUnavailableTimeWarningAppointment {
    return Intl.message(
      'Attenzione: l‚Äôorario selezionato per l‚Äôappuntamento include fasce non disponibili per il team scelto.',
      name: 'bookingUnavailableTimeWarningAppointment',
      desc: '',
      args: [],
    );
  }

  /// `Attenzione: l‚Äôorario di questo servizio include fasce non disponibili per il team scelto.`
  String get bookingUnavailableTimeWarningService {
    return Intl.message(
      'Attenzione: l‚Äôorario di questo servizio include fasce non disponibili per il team scelto.',
      name: 'bookingUnavailableTimeWarningService',
      desc: '',
      args: [],
    );
  }

  /// `Attenzione: il membro del team selezionato non √® abilitato per questo servizio.`
  String get bookingStaffNotEligibleWarning {
    return Intl.message(
      'Attenzione: il membro del team selezionato non √® abilitato per questo servizio.',
      name: 'bookingStaffNotEligibleWarning',
      desc: '',
      args: [],
    );
  }

  /// `Elimina prenotazione`
  String get actionDeleteBooking {
    return Intl.message(
      'Elimina prenotazione',
      name: 'actionDeleteBooking',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare l'appuntamento?`
  String get deleteAppointmentConfirmTitle {
    return Intl.message(
      'Eliminare l\'appuntamento?',
      name: 'deleteAppointmentConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `L'appuntamento verr√† rimosso. L'operazione non pu√≤ essere annullata.`
  String get deleteAppointmentConfirmMessage {
    return Intl.message(
      'L\'appuntamento verr√† rimosso. L\'operazione non pu√≤ essere annullata.',
      name: 'deleteAppointmentConfirmMessage',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare l‚Äôintera prenotazione?`
  String get deleteBookingConfirmTitle {
    return Intl.message(
      'Eliminare l‚Äôintera prenotazione?',
      name: 'deleteBookingConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `Verranno rimossi tutti i servizi collegati. L'operazione non pu√≤ essere annullata.`
  String get deleteBookingConfirmMessage {
    return Intl.message(
      'Verranno rimossi tutti i servizi collegati. L\'operazione non pu√≤ essere annullata.',
      name: 'deleteBookingConfirmMessage',
      desc: '',
      args: [],
    );
  }

  /// `Sedi`
  String get teamLocationsLabel {
    return Intl.message('Sedi', name: 'teamLocationsLabel', desc: '', args: []);
  }

  /// `Team`
  String get teamStaffLabel {
    return Intl.message('Team', name: 'teamStaffLabel', desc: '', args: []);
  }

  /// `Aggiungi membro`
  String get teamAddStaff {
    return Intl.message(
      'Aggiungi membro',
      name: 'teamAddStaff',
      desc: '',
      args: [],
    );
  }

  /// `Nessun membro in questa sede`
  String get teamNoStaffInLocation {
    return Intl.message(
      'Nessun membro in questa sede',
      name: 'teamNoStaffInLocation',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile eliminare la sede`
  String get teamDeleteLocationBlockedTitle {
    return Intl.message(
      'Impossibile eliminare la sede',
      name: 'teamDeleteLocationBlockedTitle',
      desc: '',
      args: [],
    );
  }

  /// `Rimuovi prima tutti i membri del team associati.`
  String get teamDeleteLocationBlockedMessage {
    return Intl.message(
      'Rimuovi prima tutti i membri del team associati.',
      name: 'teamDeleteLocationBlockedMessage',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare la sede?`
  String get teamDeleteLocationTitle {
    return Intl.message(
      'Eliminare la sede?',
      name: 'teamDeleteLocationTitle',
      desc: '',
      args: [],
    );
  }

  /// `La sede verr√† rimossa dal team. L'operazione non pu√≤ essere annullata.`
  String get teamDeleteLocationMessage {
    return Intl.message(
      'La sede verr√† rimossa dal team. L\'operazione non pu√≤ essere annullata.',
      name: 'teamDeleteLocationMessage',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare il membro del team?`
  String get teamDeleteStaffTitle {
    return Intl.message(
      'Eliminare il membro del team?',
      name: 'teamDeleteStaffTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il membro verr√† rimosso dal team. L'operazione non pu√≤ essere annullata.`
  String get teamDeleteStaffMessage {
    return Intl.message(
      'Il membro verr√† rimosso dal team. L\'operazione non pu√≤ essere annullata.',
      name: 'teamDeleteStaffMessage',
      desc: '',
      args: [],
    );
  }

  /// `Nuova sede`
  String get teamNewLocationTitle {
    return Intl.message(
      'Nuova sede',
      name: 'teamNewLocationTitle',
      desc: '',
      args: [],
    );
  }

  /// `Modifica sede`
  String get teamEditLocationTitle {
    return Intl.message(
      'Modifica sede',
      name: 'teamEditLocationTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nome sede`
  String get teamLocationNameLabel {
    return Intl.message(
      'Nome sede',
      name: 'teamLocationNameLabel',
      desc: '',
      args: [],
    );
  }

  /// `Indirizzo`
  String get teamLocationAddressLabel {
    return Intl.message(
      'Indirizzo',
      name: 'teamLocationAddressLabel',
      desc: '',
      args: [],
    );
  }

  /// `Email`
  String get teamLocationEmailLabel {
    return Intl.message(
      'Email',
      name: 'teamLocationEmailLabel',
      desc: '',
      args: [],
    );
  }

  /// `Email per notifiche ai clienti`
  String get teamLocationEmailHint {
    return Intl.message(
      'Email per notifiche ai clienti',
      name: 'teamLocationEmailHint',
      desc: '',
      args: [],
    );
  }

  /// `Sede attiva`
  String get teamLocationIsActiveLabel {
    return Intl.message(
      'Sede attiva',
      name: 'teamLocationIsActiveLabel',
      desc: '',
      args: [],
    );
  }

  /// `Se disattivata, la sede non sar√† visibile ai clienti`
  String get teamLocationIsActiveHint {
    return Intl.message(
      'Se disattivata, la sede non sar√† visibile ai clienti',
      name: 'teamLocationIsActiveHint',
      desc: '',
      args: [],
    );
  }

  /// `Limiti prenotazione online`
  String get teamLocationBookingLimitsSection {
    return Intl.message(
      'Limiti prenotazione online',
      name: 'teamLocationBookingLimitsSection',
      desc: '',
      args: [],
    );
  }

  /// `Consenti ai clienti di scegliere l'operatore`
  String get teamLocationAllowCustomerChooseStaffLabel {
    return Intl.message(
      'Consenti ai clienti di scegliere l\'operatore',
      name: 'teamLocationAllowCustomerChooseStaffLabel',
      desc: '',
      args: [],
    );
  }

  /// `Se disattivato, il sistema assegna automaticamente l'operatore`
  String get teamLocationAllowCustomerChooseStaffHint {
    return Intl.message(
      'Se disattivato, il sistema assegna automaticamente l\'operatore',
      name: 'teamLocationAllowCustomerChooseStaffHint',
      desc: '',
      args: [],
    );
  }

  /// `Preavviso minimo prenotazione`
  String get teamLocationMinBookingNoticeLabel {
    return Intl.message(
      'Preavviso minimo prenotazione',
      name: 'teamLocationMinBookingNoticeLabel',
      desc: '',
      args: [],
    );
  }

  /// `Quanto tempo prima devono prenotare i clienti`
  String get teamLocationMinBookingNoticeHint {
    return Intl.message(
      'Quanto tempo prima devono prenotare i clienti',
      name: 'teamLocationMinBookingNoticeHint',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione massima anticipata`
  String get teamLocationMaxBookingAdvanceLabel {
    return Intl.message(
      'Prenotazione massima anticipata',
      name: 'teamLocationMaxBookingAdvanceLabel',
      desc: '',
      args: [],
    );
  }

  /// `Fino a quanto tempo in anticipo possono prenotare`
  String get teamLocationMaxBookingAdvanceHint {
    return Intl.message(
      'Fino a quanto tempo in anticipo possono prenotare',
      name: 'teamLocationMaxBookingAdvanceHint',
      desc: '',
      args: [],
    );
  }

  /// `Finestra modifica/cancellazione`
  String get teamLocationCancellationHoursLabel {
    return Intl.message(
      'Finestra modifica/cancellazione',
      name: 'teamLocationCancellationHoursLabel',
      desc: '',
      args: [],
    );
  }

  /// `Tempo minimo prima dell'appuntamento entro cui il cliente pu√≤ ancora modificare o cancellare`
  String get teamLocationCancellationHoursHint {
    return Intl.message(
      'Tempo minimo prima dell\'appuntamento entro cui il cliente pu√≤ ancora modificare o cancellare',
      name: 'teamLocationCancellationHoursHint',
      desc: '',
      args: [],
    );
  }

  /// `Usa policy del business`
  String get teamLocationCancellationHoursUseBusiness {
    return Intl.message(
      'Usa policy del business',
      name: 'teamLocationCancellationHoursUseBusiness',
      desc: '',
      args: [],
    );
  }

  /// `Usa policy del business ({value})`
  String teamLocationCancellationHoursUseBusinessWithValue(String value) {
    return Intl.message(
      'Usa policy del business ($value)',
      name: 'teamLocationCancellationHoursUseBusinessWithValue',
      desc: '',
      args: [value],
    );
  }

  /// `Sempre`
  String get teamLocationCancellationHoursAlways {
    return Intl.message(
      'Sempre',
      name: 'teamLocationCancellationHoursAlways',
      desc: '',
      args: [],
    );
  }

  /// `Mai`
  String get teamLocationCancellationHoursNever {
    return Intl.message(
      'Mai',
      name: 'teamLocationCancellationHoursNever',
      desc: '',
      args: [],
    );
  }

  /// `{count, plural, =1{1 ora} other{{count} ore}}`
  String teamLocationHours(int count) {
    return Intl.plural(
      count,
      one: '1 ora',
      other: '$count ore',
      name: 'teamLocationHours',
      desc: '',
      args: [count],
    );
  }

  /// `{count, plural, =1{1 giorno} other{{count} giorni}}`
  String teamLocationDays(int count) {
    return Intl.plural(
      count,
      one: '1 giorno',
      other: '$count giorni',
      name: 'teamLocationDays',
      desc: '',
      args: [count],
    );
  }

  /// `{count, plural, =1{1 minuto} other{{count} minuti}}`
  String teamLocationMinutes(int count) {
    return Intl.plural(
      count,
      one: '1 minuto',
      other: '$count minuti',
      name: 'teamLocationMinutes',
      desc: '',
      args: [count],
    );
  }

  /// `Fasce orarie intelligenti`
  String get teamLocationSmartSlotSection {
    return Intl.message(
      'Fasce orarie intelligenti',
      name: 'teamLocationSmartSlotSection',
      desc: '',
      args: [],
    );
  }

  /// `Configura come vengono mostrati gli orari disponibili ai clienti che prenotano online. Non modifica il planning dello staff.`
  String get teamLocationSmartSlotDescription {
    return Intl.message(
      'Configura come vengono mostrati gli orari disponibili ai clienti che prenotano online. Non modifica il planning dello staff.',
      name: 'teamLocationSmartSlotDescription',
      desc: '',
      args: [],
    );
  }

  /// `Intervallo tra gli orari`
  String get teamLocationSlotIntervalLabel {
    return Intl.message(
      'Intervallo tra gli orari',
      name: 'teamLocationSlotIntervalLabel',
      desc: '',
      args: [],
    );
  }

  /// `Ogni quanti minuti mostrare un orario disponibile nelle prenotazioni online (non influisce sugli slot del planning staff)`
  String get teamLocationSlotIntervalHint {
    return Intl.message(
      'Ogni quanti minuti mostrare un orario disponibile nelle prenotazioni online (non influisce sugli slot del planning staff)',
      name: 'teamLocationSlotIntervalHint',
      desc: '',
      args: [],
    );
  }

  /// `Modalit√† visualizzazione`
  String get teamLocationSlotDisplayModeLabel {
    return Intl.message(
      'Modalit√† visualizzazione',
      name: 'teamLocationSlotDisplayModeLabel',
      desc: '',
      args: [],
    );
  }

  /// `Massima disponibilit√†`
  String get teamLocationSlotDisplayModeAll {
    return Intl.message(
      'Massima disponibilit√†',
      name: 'teamLocationSlotDisplayModeAll',
      desc: '',
      args: [],
    );
  }

  /// `Riduci spazi vuoti`
  String get teamLocationSlotDisplayModeMinGap {
    return Intl.message(
      'Riduci spazi vuoti',
      name: 'teamLocationSlotDisplayModeMinGap',
      desc: '',
      args: [],
    );
  }

  /// `Mostra tutti gli orari disponibili`
  String get teamLocationSlotDisplayModeAllHint {
    return Intl.message(
      'Mostra tutti gli orari disponibili',
      name: 'teamLocationSlotDisplayModeAllHint',
      desc: '',
      args: [],
    );
  }

  /// `Nasconde orari che creerebbero buchi troppo piccoli`
  String get teamLocationSlotDisplayModeMinGapHint {
    return Intl.message(
      'Nasconde orari che creerebbero buchi troppo piccoli',
      name: 'teamLocationSlotDisplayModeMinGapHint',
      desc: '',
      args: [],
    );
  }

  /// `Gap minimo accettabile`
  String get teamLocationMinGapLabel {
    return Intl.message(
      'Gap minimo accettabile',
      name: 'teamLocationMinGapLabel',
      desc: '',
      args: [],
    );
  }

  /// `Non mostrare orari che lasciano meno di questo tempo libero`
  String get teamLocationMinGapHint {
    return Intl.message(
      'Non mostrare orari che lasciano meno di questo tempo libero',
      name: 'teamLocationMinGapHint',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo membro del team`
  String get teamNewStaffTitle {
    return Intl.message(
      'Nuovo membro del team',
      name: 'teamNewStaffTitle',
      desc: '',
      args: [],
    );
  }

  /// `Modifica membro del team`
  String get teamEditStaffTitle {
    return Intl.message(
      'Modifica membro del team',
      name: 'teamEditStaffTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nome`
  String get teamStaffNameLabel {
    return Intl.message('Nome', name: 'teamStaffNameLabel', desc: '', args: []);
  }

  /// `Cognome`
  String get teamStaffSurnameLabel {
    return Intl.message(
      'Cognome',
      name: 'teamStaffSurnameLabel',
      desc: '',
      args: [],
    );
  }

  /// `Colore`
  String get teamStaffColorLabel {
    return Intl.message(
      'Colore',
      name: 'teamStaffColorLabel',
      desc: '',
      args: [],
    );
  }

  /// `Sedi associate`
  String get teamStaffLocationsLabel {
    return Intl.message(
      'Sedi associate',
      name: 'teamStaffLocationsLabel',
      desc: '',
      args: [],
    );
  }

  /// `Se il membro lavora su pi√π sedi, ricorda di allineare disponibilit√† e orari con le sedi selezionate.`
  String get teamStaffMultiLocationWarning {
    return Intl.message(
      'Se il membro lavora su pi√π sedi, ricorda di allineare disponibilit√† e orari con le sedi selezionate.',
      name: 'teamStaffMultiLocationWarning',
      desc: '',
      args: [],
    );
  }

  /// `Team abilitato`
  String get teamEligibleStaffLabel {
    return Intl.message(
      'Team abilitato',
      name: 'teamEligibleStaffLabel',
      desc: '',
      args: [],
    );
  }

  /// `Servizi abilitati`
  String get teamEligibleServicesLabel {
    return Intl.message(
      'Servizi abilitati',
      name: 'teamEligibleServicesLabel',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona tutto`
  String get teamSelectAllServices {
    return Intl.message(
      'Seleziona tutto',
      name: 'teamSelectAllServices',
      desc: '',
      args: [],
    );
  }

  /// `{count} servizi abilitati`
  String teamEligibleServicesCount(int count) {
    return Intl.message(
      '$count servizi abilitati',
      name: 'teamEligibleServicesCount',
      desc: '',
      args: [count],
    );
  }

  /// `Nessun servizio abilitato`
  String get teamEligibleServicesNone {
    return Intl.message(
      'Nessun servizio abilitato',
      name: 'teamEligibleServicesNone',
      desc: '',
      args: [],
    );
  }

  /// `Servizi selezionati`
  String get teamSelectedServicesButton {
    return Intl.message(
      'Servizi selezionati',
      name: 'teamSelectedServicesButton',
      desc: '',
      args: [],
    );
  }

  /// `{selected} su {total}`
  String teamSelectedServicesCount(int selected, int total) {
    return Intl.message(
      '$selected su $total',
      name: 'teamSelectedServicesCount',
      desc: '',
      args: [selected, total],
    );
  }

  /// `Servizi`
  String get teamServicesLabel {
    return Intl.message(
      'Servizi',
      name: 'teamServicesLabel',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona sedi`
  String get teamChooseLocationsButton {
    return Intl.message(
      'Seleziona sedi',
      name: 'teamChooseLocationsButton',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona la sede`
  String get teamChooseLocationSingleButton {
    return Intl.message(
      'Seleziona la sede',
      name: 'teamChooseLocationSingleButton',
      desc: '',
      args: [],
    );
  }

  /// `Sede`
  String get teamLocationLabel {
    return Intl.message('Sede', name: 'teamLocationLabel', desc: '', args: []);
  }

  /// `Seleziona tutto`
  String get teamSelectAllLocations {
    return Intl.message(
      'Seleziona tutto',
      name: 'teamSelectAllLocations',
      desc: '',
      args: [],
    );
  }

  /// `Abilitato alle prenotazioni online`
  String get teamStaffBookableOnlineLabel {
    return Intl.message(
      'Abilitato alle prenotazioni online',
      name: 'teamStaffBookableOnlineLabel',
      desc: '',
      args: [],
    );
  }

  /// `Non prenotabile online`
  String get staffNotBookableOnlineTooltip {
    return Intl.message(
      'Non prenotabile online',
      name: 'staffNotBookableOnlineTooltip',
      desc: '',
      args: [],
    );
  }

  /// `Non prenotabile online`
  String get staffNotBookableOnlineTitle {
    return Intl.message(
      'Non prenotabile online',
      name: 'staffNotBookableOnlineTitle',
      desc: '',
      args: [],
    );
  }

  /// `Questo membro del team non √® abilitato alle prenotazioni online. Puoi modificare l‚Äôimpostazione dal form di modifica dello staff.`
  String get staffNotBookableOnlineMessage {
    return Intl.message(
      'Questo membro del team non √® abilitato alle prenotazioni online. Puoi modificare l‚Äôimpostazione dal form di modifica dello staff.',
      name: 'staffNotBookableOnlineMessage',
      desc: '',
      args: [],
    );
  }

  /// `{count} membri abilitati`
  String serviceEligibleStaffCount(int count) {
    return Intl.message(
      '$count membri abilitati',
      name: 'serviceEligibleStaffCount',
      desc: '',
      args: [count],
    );
  }

  /// `Nessun membro abilitato`
  String get serviceEligibleStaffNone {
    return Intl.message(
      'Nessun membro abilitato',
      name: 'serviceEligibleStaffNone',
      desc: '',
      args: [],
    );
  }

  /// `Sedi disponibili`
  String get serviceLocationsLabel {
    return Intl.message(
      'Sedi disponibili',
      name: 'serviceLocationsLabel',
      desc: '',
      args: [],
    );
  }

  /// `{count} di {total} sedi`
  String serviceLocationsCount(int count, int total) {
    return Intl.message(
      '$count di $total sedi',
      name: 'serviceLocationsCount',
      desc: '',
      args: [count, total],
    );
  }

  /// `Riordina sedi e membri del team trascinandoli. Seleziona se ordinare sedi o team. L‚Äôordine sar√† lo stesso anche nella sezione agenda.`
  String get teamReorderHelpDescription {
    return Intl.message(
      'Riordina sedi e membri del team trascinandoli. Seleziona se ordinare sedi o team. L‚Äôordine sar√† lo stesso anche nella sezione agenda.',
      name: 'teamReorderHelpDescription',
      desc: '',
      args: [],
    );
  }

  /// `Nuova categoria`
  String get createCategoryButtonLabel {
    return Intl.message(
      'Nuova categoria',
      name: 'createCategoryButtonLabel',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo servizio`
  String get servicesNewServiceMenu {
    return Intl.message(
      'Nuovo servizio',
      name: 'servicesNewServiceMenu',
      desc: '',
      args: [],
    );
  }

  /// `Modifica ordinamento`
  String get reorderTitle {
    return Intl.message(
      'Modifica ordinamento',
      name: 'reorderTitle',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi servizio`
  String get addServiceTooltip {
    return Intl.message(
      'Aggiungi servizio',
      name: 'addServiceTooltip',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile eliminare`
  String get cannotDeleteTitle {
    return Intl.message(
      'Impossibile eliminare',
      name: 'cannotDeleteTitle',
      desc: '',
      args: [],
    );
  }

  /// `La categoria contiene uno o pi√π servizi.`
  String get cannotDeleteCategoryContent {
    return Intl.message(
      'La categoria contiene uno o pi√π servizi.',
      name: 'cannotDeleteCategoryContent',
      desc: '',
      args: [],
    );
  }

  /// `Nessun servizio in questa categoria`
  String get noServicesInCategory {
    return Intl.message(
      'Nessun servizio in questa categoria',
      name: 'noServicesInCategory',
      desc: '',
      args: [],
    );
  }

  /// `Non prenotabile online`
  String get notBookableOnline {
    return Intl.message(
      'Non prenotabile online',
      name: 'notBookableOnline',
      desc: '',
      args: [],
    );
  }

  /// `Duplica`
  String get duplicateAction {
    return Intl.message('Duplica', name: 'duplicateAction', desc: '', args: []);
  }

  /// `Eliminare il servizio?`
  String get deleteServiceQuestion {
    return Intl.message(
      'Eliminare il servizio?',
      name: 'deleteServiceQuestion',
      desc: '',
      args: [],
    );
  }

  /// `Questa azione non pu√≤ essere annullata.`
  String get cannotUndoWarning {
    return Intl.message(
      'Questa azione non pu√≤ essere annullata.',
      name: 'cannotUndoWarning',
      desc: '',
      args: [],
    );
  }

  /// `Nuova categoria`
  String get newCategoryTitle {
    return Intl.message(
      'Nuova categoria',
      name: 'newCategoryTitle',
      desc: '',
      args: [],
    );
  }

  /// `Modifica categoria`
  String get editCategoryTitle {
    return Intl.message(
      'Modifica categoria',
      name: 'editCategoryTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nome *`
  String get fieldNameRequiredLabel {
    return Intl.message(
      'Nome *',
      name: 'fieldNameRequiredLabel',
      desc: '',
      args: [],
    );
  }

  /// `Il nome √® obbligatorio`
  String get fieldNameRequiredError {
    return Intl.message(
      'Il nome √® obbligatorio',
      name: 'fieldNameRequiredError',
      desc: '',
      args: [],
    );
  }

  /// `Esiste gi√† una categoria con questo nome`
  String get categoryDuplicateError {
    return Intl.message(
      'Esiste gi√† una categoria con questo nome',
      name: 'categoryDuplicateError',
      desc: '',
      args: [],
    );
  }

  /// `Descrizione`
  String get fieldDescriptionLabel {
    return Intl.message(
      'Descrizione',
      name: 'fieldDescriptionLabel',
      desc: '',
      args: [],
    );
  }

  /// `Colore servizio`
  String get serviceColorLabel {
    return Intl.message(
      'Colore servizio',
      name: 'serviceColorLabel',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo servizio`
  String get newServiceTitle {
    return Intl.message(
      'Nuovo servizio',
      name: 'newServiceTitle',
      desc: '',
      args: [],
    );
  }

  /// `Modifica servizio`
  String get editServiceTitle {
    return Intl.message(
      'Modifica servizio',
      name: 'editServiceTitle',
      desc: '',
      args: [],
    );
  }

  /// `Categoria *`
  String get fieldCategoryRequiredLabel {
    return Intl.message(
      'Categoria *',
      name: 'fieldCategoryRequiredLabel',
      desc: '',
      args: [],
    );
  }

  /// `Durata *`
  String get fieldDurationRequiredLabel {
    return Intl.message(
      'Durata *',
      name: 'fieldDurationRequiredLabel',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona una durata`
  String get fieldDurationRequiredError {
    return Intl.message(
      'Seleziona una durata',
      name: 'fieldDurationRequiredError',
      desc: '',
      args: [],
    );
  }

  /// `Prezzo`
  String get fieldPriceLabel {
    return Intl.message('Prezzo', name: 'fieldPriceLabel', desc: '', args: []);
  }

  /// `Tempo di lavorazione`
  String get fieldProcessingTimeLabel {
    return Intl.message(
      'Tempo di lavorazione',
      name: 'fieldProcessingTimeLabel',
      desc: '',
      args: [],
    );
  }

  /// `Tempo bloccato`
  String get fieldBlockedTimeLabel {
    return Intl.message(
      'Tempo bloccato',
      name: 'fieldBlockedTimeLabel',
      desc: '',
      args: [],
    );
  }

  /// `Tempo aggiuntivo`
  String get additionalTimeSwitch {
    return Intl.message(
      'Tempo aggiuntivo',
      name: 'additionalTimeSwitch',
      desc: '',
      args: [],
    );
  }

  /// `Tempo di lavorazione`
  String get additionalTimeOptionProcessing {
    return Intl.message(
      'Tempo di lavorazione',
      name: 'additionalTimeOptionProcessing',
      desc: '',
      args: [],
    );
  }

  /// `Tempo bloccato`
  String get additionalTimeOptionBlocked {
    return Intl.message(
      'Tempo bloccato',
      name: 'additionalTimeOptionBlocked',
      desc: '',
      args: [],
    );
  }

  /// `Prenotabile online`
  String get bookableOnlineSwitch {
    return Intl.message(
      'Prenotabile online',
      name: 'bookableOnlineSwitch',
      desc: '',
      args: [],
    );
  }

  /// `Servizio gratuito`
  String get freeServiceSwitch {
    return Intl.message(
      'Servizio gratuito',
      name: 'freeServiceSwitch',
      desc: '',
      args: [],
    );
  }

  /// `Prezzo "a partire da"`
  String get priceStartingFromSwitch {
    return Intl.message(
      'Prezzo "a partire da"',
      name: 'priceStartingFromSwitch',
      desc: '',
      args: [],
    );
  }

  /// `Imposta un prezzo per abilitarlo`
  String get setPriceToEnable {
    return Intl.message(
      'Imposta un prezzo per abilitarlo',
      name: 'setPriceToEnable',
      desc: '',
      args: [],
    );
  }

  /// `Esiste gi√† un servizio con questo nome`
  String get serviceDuplicateError {
    return Intl.message(
      'Esiste gi√† un servizio con questo nome',
      name: 'serviceDuplicateError',
      desc: '',
      args: [],
    );
  }

  /// `Riordina categorie e servizi trascinandoli: l‚Äôordine sar√† lo stesso anche nella prenotazione online. Seleziona se ordinare categorie o servizi.`
  String get reorderHelpDescription {
    return Intl.message(
      'Riordina categorie e servizi trascinandoli: l‚Äôordine sar√† lo stesso anche nella prenotazione online. Seleziona se ordinare categorie o servizi.',
      name: 'reorderHelpDescription',
      desc: '',
      args: [],
    );
  }

  /// `Categorie`
  String get reorderCategoriesLabel {
    return Intl.message(
      'Categorie',
      name: 'reorderCategoriesLabel',
      desc: '',
      args: [],
    );
  }

  /// `Servizi`
  String get reorderServicesLabel {
    return Intl.message(
      'Servizi',
      name: 'reorderServicesLabel',
      desc: '',
      args: [],
    );
  }

  /// `Le categorie senza servizi non sono riordinabili e restano in coda.`
  String get emptyCategoriesNotReorderableNote {
    return Intl.message(
      'Le categorie senza servizi non sono riordinabili e restano in coda.',
      name: 'emptyCategoriesNotReorderableNote',
      desc: '',
      args: [],
    );
  }

  /// `Trattamenti Corpo`
  String get serviceSeedCategoryBodyName {
    return Intl.message(
      'Trattamenti Corpo',
      name: 'serviceSeedCategoryBodyName',
      desc: '',
      args: [],
    );
  }

  /// `Servizi dedicati al benessere del corpo`
  String get serviceSeedCategoryBodyDescription {
    return Intl.message(
      'Servizi dedicati al benessere del corpo',
      name: 'serviceSeedCategoryBodyDescription',
      desc: '',
      args: [],
    );
  }

  /// `Trattamenti Sportivi`
  String get serviceSeedCategorySportsName {
    return Intl.message(
      'Trattamenti Sportivi',
      name: 'serviceSeedCategorySportsName',
      desc: '',
      args: [],
    );
  }

  /// `Percorsi pensati per atleti e persone attive`
  String get serviceSeedCategorySportsDescription {
    return Intl.message(
      'Percorsi pensati per atleti e persone attive',
      name: 'serviceSeedCategorySportsDescription',
      desc: '',
      args: [],
    );
  }

  /// `Trattamenti Viso`
  String get serviceSeedCategoryFaceName {
    return Intl.message(
      'Trattamenti Viso',
      name: 'serviceSeedCategoryFaceName',
      desc: '',
      args: [],
    );
  }

  /// `Cura estetica e rigenerante per il viso`
  String get serviceSeedCategoryFaceDescription {
    return Intl.message(
      'Cura estetica e rigenerante per il viso',
      name: 'serviceSeedCategoryFaceDescription',
      desc: '',
      args: [],
    );
  }

  /// `Massaggio Relax`
  String get serviceSeedServiceRelaxName {
    return Intl.message(
      'Massaggio Relax',
      name: 'serviceSeedServiceRelaxName',
      desc: '',
      args: [],
    );
  }

  /// `Trattamento rilassante da 30 minuti`
  String get serviceSeedServiceRelaxDescription {
    return Intl.message(
      'Trattamento rilassante da 30 minuti',
      name: 'serviceSeedServiceRelaxDescription',
      desc: '',
      args: [],
    );
  }

  /// `Massaggio Sportivo`
  String get serviceSeedServiceSportName {
    return Intl.message(
      'Massaggio Sportivo',
      name: 'serviceSeedServiceSportName',
      desc: '',
      args: [],
    );
  }

  /// `Trattamento decontratturante intensivo`
  String get serviceSeedServiceSportDescription {
    return Intl.message(
      'Trattamento decontratturante intensivo',
      name: 'serviceSeedServiceSportDescription',
      desc: '',
      args: [],
    );
  }

  /// `Trattamento Viso`
  String get serviceSeedServiceFaceName {
    return Intl.message(
      'Trattamento Viso',
      name: 'serviceSeedServiceFaceName',
      desc: '',
      args: [],
    );
  }

  /// `Pulizia e trattamento illuminante`
  String get serviceSeedServiceFaceDescription {
    return Intl.message(
      'Pulizia e trattamento illuminante',
      name: 'serviceSeedServiceFaceDescription',
      desc: '',
      args: [],
    );
  }

  /// `Copia`
  String get serviceDuplicateCopyWord {
    return Intl.message(
      'Copia',
      name: 'serviceDuplicateCopyWord',
      desc: '',
      args: [],
    );
  }

  /// `Confermi lo spostamento?`
  String get moveAppointmentConfirmTitle {
    return Intl.message(
      'Confermi lo spostamento?',
      name: 'moveAppointmentConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `L'appuntamento verr√† spostato alle {newTime} per {staffName}.`
  String moveAppointmentConfirmMessage(String newTime, String staffName) {
    return Intl.message(
      'L\'appuntamento verr√† spostato alle $newTime per $staffName.',
      name: 'moveAppointmentConfirmMessage',
      desc: '',
      args: [newTime, staffName],
    );
  }

  /// `Modifiche non salvate`
  String get discardChangesTitle {
    return Intl.message(
      'Modifiche non salvate',
      name: 'discardChangesTitle',
      desc: '',
      args: [],
    );
  }

  /// `Hai delle modifiche non salvate. Vuoi scartarle?`
  String get discardChangesMessage {
    return Intl.message(
      'Hai delle modifiche non salvate. Vuoi scartarle?',
      name: 'discardChangesMessage',
      desc: '',
      args: [],
    );
  }

  /// `Annulla`
  String get actionDiscard {
    return Intl.message('Annulla', name: 'actionDiscard', desc: '', args: []);
  }

  /// `Continua a modificare`
  String get actionKeepEditing {
    return Intl.message(
      'Continua a modificare',
      name: 'actionKeepEditing',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare il cliente?`
  String get deleteClientConfirmTitle {
    return Intl.message(
      'Eliminare il cliente?',
      name: 'deleteClientConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il cliente verr√† eliminato definitivamente. Questa azione non pu√≤ essere annullata.`
  String get deleteClientConfirmMessage {
    return Intl.message(
      'Il cliente verr√† eliminato definitivamente. Questa azione non pu√≤ essere annullata.',
      name: 'deleteClientConfirmMessage',
      desc: '',
      args: [],
    );
  }

  /// `Nome (A-Z)`
  String get sortByNameAsc {
    return Intl.message(
      'Nome (A-Z)',
      name: 'sortByNameAsc',
      desc: '',
      args: [],
    );
  }

  /// `Nome (Z-A)`
  String get sortByNameDesc {
    return Intl.message(
      'Nome (Z-A)',
      name: 'sortByNameDesc',
      desc: '',
      args: [],
    );
  }

  /// `Cognome (A-Z)`
  String get sortByLastNameAsc {
    return Intl.message(
      'Cognome (A-Z)',
      name: 'sortByLastNameAsc',
      desc: '',
      args: [],
    );
  }

  /// `Cognome (Z-A)`
  String get sortByLastNameDesc {
    return Intl.message(
      'Cognome (Z-A)',
      name: 'sortByLastNameDesc',
      desc: '',
      args: [],
    );
  }

  /// `Data creazione (nuovi)`
  String get sortByCreatedAtDesc {
    return Intl.message(
      'Data creazione (nuovi)',
      name: 'sortByCreatedAtDesc',
      desc: '',
      args: [],
    );
  }

  /// `Data creazione (vecchi)`
  String get sortByCreatedAtAsc {
    return Intl.message(
      'Data creazione (vecchi)',
      name: 'sortByCreatedAtAsc',
      desc: '',
      args: [],
    );
  }

  /// `Appuntamenti di {clientName}`
  String clientAppointmentsTitle(String clientName) {
    return Intl.message(
      'Appuntamenti di $clientName',
      name: 'clientAppointmentsTitle',
      desc: '',
      args: [clientName],
    );
  }

  /// `Prossimi`
  String get clientAppointmentsUpcoming {
    return Intl.message(
      'Prossimi',
      name: 'clientAppointmentsUpcoming',
      desc: '',
      args: [],
    );
  }

  /// `Passati`
  String get clientAppointmentsPast {
    return Intl.message(
      'Passati',
      name: 'clientAppointmentsPast',
      desc: '',
      args: [],
    );
  }

  /// `Nessun appuntamento`
  String get clientAppointmentsEmpty {
    return Intl.message(
      'Nessun appuntamento',
      name: 'clientAppointmentsEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Filtra team`
  String get staffFilterTooltip {
    return Intl.message(
      'Filtra team',
      name: 'staffFilterTooltip',
      desc: '',
      args: [],
    );
  }

  /// `Filtra team`
  String get staffFilterTitle {
    return Intl.message(
      'Filtra team',
      name: 'staffFilterTitle',
      desc: '',
      args: [],
    );
  }

  /// `Tutto il team`
  String get staffFilterAllTeam {
    return Intl.message(
      'Tutto il team',
      name: 'staffFilterAllTeam',
      desc: '',
      args: [],
    );
  }

  /// `Team di turno`
  String get staffFilterOnDuty {
    return Intl.message(
      'Team di turno',
      name: 'staffFilterOnDuty',
      desc: '',
      args: [],
    );
  }

  /// `Nessun membro del team di turno oggi`
  String get agendaNoOnDutyTeamTitle {
    return Intl.message(
      'Nessun membro del team di turno oggi',
      name: 'agendaNoOnDutyTeamTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessun membro del team selezionato`
  String get agendaNoSelectedTeamTitle {
    return Intl.message(
      'Nessun membro del team selezionato',
      name: 'agendaNoSelectedTeamTitle',
      desc: '',
      args: [],
    );
  }

  /// `Visualizza tutto il team`
  String get agendaShowAllTeamButton {
    return Intl.message(
      'Visualizza tutto il team',
      name: 'agendaShowAllTeamButton',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona membri del team`
  String get staffFilterSelectMembers {
    return Intl.message(
      'Seleziona membri del team',
      name: 'staffFilterSelectMembers',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo blocco`
  String get blockDialogTitleNew {
    return Intl.message(
      'Nuovo blocco',
      name: 'blockDialogTitleNew',
      desc: '',
      args: [],
    );
  }

  /// `Modifica blocco`
  String get blockDialogTitleEdit {
    return Intl.message(
      'Modifica blocco',
      name: 'blockDialogTitleEdit',
      desc: '',
      args: [],
    );
  }

  /// `Giornata intera`
  String get blockAllDay {
    return Intl.message(
      'Giornata intera',
      name: 'blockAllDay',
      desc: '',
      args: [],
    );
  }

  /// `Orario inizio`
  String get blockStartTime {
    return Intl.message(
      'Orario inizio',
      name: 'blockStartTime',
      desc: '',
      args: [],
    );
  }

  /// `Orario fine`
  String get blockEndTime {
    return Intl.message(
      'Orario fine',
      name: 'blockEndTime',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona team`
  String get blockSelectStaff {
    return Intl.message(
      'Seleziona team',
      name: 'blockSelectStaff',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona almeno un team`
  String get blockSelectStaffError {
    return Intl.message(
      'Seleziona almeno un team',
      name: 'blockSelectStaffError',
      desc: '',
      args: [],
    );
  }

  /// `L'ora di fine deve essere successiva all'ora di inizio`
  String get blockTimeError {
    return Intl.message(
      'L\'ora di fine deve essere successiva all\'ora di inizio',
      name: 'blockTimeError',
      desc: '',
      args: [],
    );
  }

  /// `Motivo (opzionale)`
  String get blockReason {
    return Intl.message(
      'Motivo (opzionale)',
      name: 'blockReason',
      desc: '',
      args: [],
    );
  }

  /// `Es. Riunione, Pausa, ecc.`
  String get blockReasonHint {
    return Intl.message(
      'Es. Riunione, Pausa, ecc.',
      name: 'blockReasonHint',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile aggiungere il servizio: l'orario supera la mezzanotte. Modifica l'orario di inizio o l'operatore.`
  String get serviceStartsAfterMidnight {
    return Intl.message(
      'Impossibile aggiungere il servizio: l\'orario supera la mezzanotte. Modifica l\'orario di inizio o l\'operatore.',
      name: 'serviceStartsAfterMidnight',
      desc: '',
      args: [],
    );
  }

  /// `Ordina per`
  String get sortByTitle {
    return Intl.message('Ordina per', name: 'sortByTitle', desc: '', args: []);
  }

  /// `Seleziona team`
  String get selectStaffTitle {
    return Intl.message(
      'Seleziona team',
      name: 'selectStaffTitle',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi un cliente all'appuntamento`
  String get addClientToAppointment {
    return Intl.message(
      'Aggiungi un cliente all\'appuntamento',
      name: 'addClientToAppointment',
      desc: '',
      args: [],
    );
  }

  /// `Lascia il campo vuoto se non vuoi associare un cliente all'appuntamento`
  String get clientOptionalHint {
    return Intl.message(
      'Lascia il campo vuoto se non vuoi associare un cliente all\'appuntamento',
      name: 'clientOptionalHint',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona cliente`
  String get selectClientTitle {
    return Intl.message(
      'Seleziona cliente',
      name: 'selectClientTitle',
      desc: '',
      args: [],
    );
  }

  /// `Rimuovi cliente`
  String get removeClient {
    return Intl.message(
      'Rimuovi cliente',
      name: 'removeClient',
      desc: '',
      args: [],
    );
  }

  /// `Cerca cliente...`
  String get searchClientPlaceholder {
    return Intl.message(
      'Cerca cliente...',
      name: 'searchClientPlaceholder',
      desc: '',
      args: [],
    );
  }

  /// `Crea nuovo cliente`
  String get createNewClient {
    return Intl.message(
      'Crea nuovo cliente',
      name: 'createNewClient',
      desc: '',
      args: [],
    );
  }

  /// `Nessun cliente per l'appuntamento`
  String get noClientForAppointment {
    return Intl.message(
      'Nessun cliente per l\'appuntamento',
      name: 'noClientForAppointment',
      desc: '',
      args: [],
    );
  }

  /// `Servizi`
  String get formServices {
    return Intl.message('Servizi', name: 'formServices', desc: '', args: []);
  }

  /// `Cerca servizio...`
  String get searchServices {
    return Intl.message(
      'Cerca servizio...',
      name: 'searchServices',
      desc: '',
      args: [],
    );
  }

  /// `Mostra tutti i servizi`
  String get showAllServices {
    return Intl.message(
      'Mostra tutti i servizi',
      name: 'showAllServices',
      desc: '',
      args: [],
    );
  }

  /// `Nessun servizio trovato`
  String get noServicesFound {
    return Intl.message(
      'Nessun servizio trovato',
      name: 'noServicesFound',
      desc: '',
      args: [],
    );
  }

  /// `{count, plural, =1{1 servizio selezionato} other{{count} servizi selezionati}}`
  String servicesSelectedCount(int count) {
    return Intl.plural(
      count,
      one: '1 servizio selezionato',
      other: '$count servizi selezionati',
      name: 'servicesSelectedCount',
      desc: '',
      args: [count],
    );
  }

  /// `Aggiungi un servizio`
  String get addService {
    return Intl.message(
      'Aggiungi un servizio',
      name: 'addService',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona un servizio`
  String get selectService {
    return Intl.message(
      'Seleziona un servizio',
      name: 'selectService',
      desc: '',
      args: [],
    );
  }

  /// `Nessun servizio aggiunto`
  String get noServicesAdded {
    return Intl.message(
      'Nessun servizio aggiunto',
      name: 'noServicesAdded',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi almeno un servizio`
  String get atLeastOneServiceRequired {
    return Intl.message(
      'Aggiungi almeno un servizio',
      name: 'atLeastOneServiceRequired',
      desc: '',
      args: [],
    );
  }

  /// `Note sull'appuntamento...`
  String get notesPlaceholder {
    return Intl.message(
      'Note sull\'appuntamento...',
      name: 'notesPlaceholder',
      desc: '',
      args: [],
    );
  }

  /// `Nessun team disponibile`
  String get noStaffAvailable {
    return Intl.message(
      'Nessun team disponibile',
      name: 'noStaffAvailable',
      desc: '',
      args: [],
    );
  }

  /// `Orario settimanale`
  String get weeklyScheduleTitle {
    return Intl.message(
      'Orario settimanale',
      name: 'weeklyScheduleTitle',
      desc: '',
      args: [],
    );
  }

  /// `{hours} ore totale`
  String weeklyScheduleTotalHours(int hours) {
    return Intl.message(
      '$hours ore totale',
      name: 'weeklyScheduleTotalHours',
      desc: '',
      args: [hours],
    );
  }

  /// `Non lavora`
  String get weeklyScheduleNotWorking {
    return Intl.message(
      'Non lavora',
      name: 'weeklyScheduleNotWorking',
      desc: '',
      args: [],
    );
  }

  /// `-`
  String get weeklyScheduleFor {
    return Intl.message('-', name: 'weeklyScheduleFor', desc: '', args: []);
  }

  /// `Aggiungi turno`
  String get weeklyScheduleAddShift {
    return Intl.message(
      'Aggiungi turno',
      name: 'weeklyScheduleAddShift',
      desc: '',
      args: [],
    );
  }

  /// `Rimuovi turno`
  String get weeklyScheduleRemoveShift {
    return Intl.message(
      'Rimuovi turno',
      name: 'weeklyScheduleRemoveShift',
      desc: '',
      args: [],
    );
  }

  /// `luned√¨`
  String get dayMondayFull {
    return Intl.message('luned√¨', name: 'dayMondayFull', desc: '', args: []);
  }

  /// `marted√¨`
  String get dayTuesdayFull {
    return Intl.message('marted√¨', name: 'dayTuesdayFull', desc: '', args: []);
  }

  /// `mercoled√¨`
  String get dayWednesdayFull {
    return Intl.message(
      'mercoled√¨',
      name: 'dayWednesdayFull',
      desc: '',
      args: [],
    );
  }

  /// `gioved√¨`
  String get dayThursdayFull {
    return Intl.message('gioved√¨', name: 'dayThursdayFull', desc: '', args: []);
  }

  /// `venerd√¨`
  String get dayFridayFull {
    return Intl.message('venerd√¨', name: 'dayFridayFull', desc: '', args: []);
  }

  /// `sabato`
  String get daySaturdayFull {
    return Intl.message('sabato', name: 'daySaturdayFull', desc: '', args: []);
  }

  /// `domenica`
  String get daySundayFull {
    return Intl.message('domenica', name: 'daySundayFull', desc: '', args: []);
  }

  /// `Nuova eccezione`
  String get exceptionDialogTitleNew {
    return Intl.message(
      'Nuova eccezione',
      name: 'exceptionDialogTitleNew',
      desc: '',
      args: [],
    );
  }

  /// `Modifica eccezione`
  String get exceptionDialogTitleEdit {
    return Intl.message(
      'Modifica eccezione',
      name: 'exceptionDialogTitleEdit',
      desc: '',
      args: [],
    );
  }

  /// `Tipo eccezione`
  String get exceptionType {
    return Intl.message(
      'Tipo eccezione',
      name: 'exceptionType',
      desc: '',
      args: [],
    );
  }

  /// `Non disponibile`
  String get exceptionTypeUnavailable {
    return Intl.message(
      'Non disponibile',
      name: 'exceptionTypeUnavailable',
      desc: '',
      args: [],
    );
  }

  /// `Disponibile`
  String get exceptionTypeAvailable {
    return Intl.message(
      'Disponibile',
      name: 'exceptionTypeAvailable',
      desc: '',
      args: [],
    );
  }

  /// `Giornata intera`
  String get exceptionAllDay {
    return Intl.message(
      'Giornata intera',
      name: 'exceptionAllDay',
      desc: '',
      args: [],
    );
  }

  /// `Orario inizio`
  String get exceptionStartTime {
    return Intl.message(
      'Orario inizio',
      name: 'exceptionStartTime',
      desc: '',
      args: [],
    );
  }

  /// `Orario fine`
  String get exceptionEndTime {
    return Intl.message(
      'Orario fine',
      name: 'exceptionEndTime',
      desc: '',
      args: [],
    );
  }

  /// `Motivo (opzionale)`
  String get exceptionReason {
    return Intl.message(
      'Motivo (opzionale)',
      name: 'exceptionReason',
      desc: '',
      args: [],
    );
  }

  /// `Ferie`
  String get exceptionReasonVacation {
    return Intl.message(
      'Ferie',
      name: 'exceptionReasonVacation',
      desc: '',
      args: [],
    );
  }

  /// `Turno extra`
  String get exceptionReasonExtraShift {
    return Intl.message(
      'Turno extra',
      name: 'exceptionReasonExtraShift',
      desc: '',
      args: [],
    );
  }

  /// `Visita medica`
  String get exceptionReasonMedicalVisit {
    return Intl.message(
      'Visita medica',
      name: 'exceptionReasonMedicalVisit',
      desc: '',
      args: [],
    );
  }

  /// `Es. Ferie, Visita medica, Turno extra...`
  String get exceptionReasonHint {
    return Intl.message(
      'Es. Ferie, Visita medica, Turno extra...',
      name: 'exceptionReasonHint',
      desc: '',
      args: [],
    );
  }

  /// `L'ora di fine deve essere successiva all'ora di inizio`
  String get exceptionTimeError {
    return Intl.message(
      'L\'ora di fine deve essere successiva all\'ora di inizio',
      name: 'exceptionTimeError',
      desc: '',
      args: [],
    );
  }

  /// `Non puoi aggiungere una non disponibilit√† in un giorno senza disponibilit√† base.`
  String get exceptionUnavailableNoBase {
    return Intl.message(
      'Non puoi aggiungere una non disponibilit√† in un giorno senza disponibilit√† base.',
      name: 'exceptionUnavailableNoBase',
      desc: '',
      args: [],
    );
  }

  /// `La non disponibilit√† deve sovrapporsi alla disponibilit√† base.`
  String get exceptionUnavailableNoOverlap {
    return Intl.message(
      'La non disponibilit√† deve sovrapporsi alla disponibilit√† base.',
      name: 'exceptionUnavailableNoOverlap',
      desc: '',
      args: [],
    );
  }

  /// `La disponibilit√† extra deve aggiungere ore rispetto alla disponibilit√† base.`
  String get exceptionAvailableNoEffect {
    return Intl.message(
      'La disponibilit√† extra deve aggiungere ore rispetto alla disponibilit√† base.',
      name: 'exceptionAvailableNoEffect',
      desc: '',
      args: [],
    );
  }

  /// `Alcuni giorni non sono stati salvati: {dates}.`
  String exceptionPartialSaveInfo(Object dates) {
    return Intl.message(
      'Alcuni giorni non sono stati salvati: $dates.',
      name: 'exceptionPartialSaveInfo',
      desc: '',
      args: [dates],
    );
  }

  /// `Alcuni giorni non sono stati salvati: {details}.`
  String exceptionPartialSaveInfoDetailed(Object details) {
    return Intl.message(
      'Alcuni giorni non sono stati salvati: $details.',
      name: 'exceptionPartialSaveInfoDetailed',
      desc: '',
      args: [details],
    );
  }

  /// `Eccezioni non salvate`
  String get exceptionPartialSaveTitle {
    return Intl.message(
      'Eccezioni non salvate',
      name: 'exceptionPartialSaveTitle',
      desc: '',
      args: [],
    );
  }

  /// `I giorni sotto non erano congruenti e non sono stati salvati:`
  String get exceptionPartialSaveMessage {
    return Intl.message(
      'I giorni sotto non erano congruenti e non sono stati salvati:',
      name: 'exceptionPartialSaveMessage',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare l'eccezione?`
  String get exceptionDeleteTitle {
    return Intl.message(
      'Eliminare l\'eccezione?',
      name: 'exceptionDeleteTitle',
      desc: '',
      args: [],
    );
  }

  /// `L'eccezione verr√† eliminata definitivamente.`
  String get exceptionDeleteMessage {
    return Intl.message(
      'L\'eccezione verr√† eliminata definitivamente.',
      name: 'exceptionDeleteMessage',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona orario`
  String get exceptionSelectTime {
    return Intl.message(
      'Seleziona orario',
      name: 'exceptionSelectTime',
      desc: '',
      args: [],
    );
  }

  /// `Eccezioni`
  String get exceptionsTitle {
    return Intl.message(
      'Eccezioni',
      name: 'exceptionsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessuna eccezione configurata`
  String get exceptionsEmpty {
    return Intl.message(
      'Nessuna eccezione configurata',
      name: 'exceptionsEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi eccezione`
  String get exceptionsAdd {
    return Intl.message(
      'Aggiungi eccezione',
      name: 'exceptionsAdd',
      desc: '',
      args: [],
    );
  }

  /// `Periodo`
  String get exceptionPeriodMode {
    return Intl.message(
      'Periodo',
      name: 'exceptionPeriodMode',
      desc: '',
      args: [],
    );
  }

  /// `Giorno singolo`
  String get exceptionPeriodSingle {
    return Intl.message(
      'Giorno singolo',
      name: 'exceptionPeriodSingle',
      desc: '',
      args: [],
    );
  }

  /// `Da - A`
  String get exceptionPeriodRange {
    return Intl.message(
      'Da - A',
      name: 'exceptionPeriodRange',
      desc: '',
      args: [],
    );
  }

  /// `Durata`
  String get exceptionPeriodDuration {
    return Intl.message(
      'Durata',
      name: 'exceptionPeriodDuration',
      desc: '',
      args: [],
    );
  }

  /// `Data inizio`
  String get exceptionDateFrom {
    return Intl.message(
      'Data inizio',
      name: 'exceptionDateFrom',
      desc: '',
      args: [],
    );
  }

  /// `Data fine`
  String get exceptionDateTo {
    return Intl.message(
      'Data fine',
      name: 'exceptionDateTo',
      desc: '',
      args: [],
    );
  }

  /// `Durata (giorni)`
  String get exceptionDuration {
    return Intl.message(
      'Durata (giorni)',
      name: 'exceptionDuration',
      desc: '',
      args: [],
    );
  }

  /// `{count} {count, plural, =1{giorno} other{giorni}}`
  String exceptionDurationDays(int count) {
    return Intl.message(
      '$count ${Intl.plural(count, one: 'giorno', other: 'giorni')}',
      name: 'exceptionDurationDays',
      desc: '',
      args: [count],
    );
  }

  /// `Elimina solo questo turno`
  String get shiftDeleteThisOnly {
    return Intl.message(
      'Elimina solo questo turno',
      name: 'shiftDeleteThisOnly',
      desc: '',
      args: [],
    );
  }

  /// `Elimina solo la fascia oraria di {date}`
  String shiftDeleteThisOnlyDesc(String date) {
    return Intl.message(
      'Elimina solo la fascia oraria di $date',
      name: 'shiftDeleteThisOnlyDesc',
      desc: '',
      args: [date],
    );
  }

  /// `Elimina tutti questi turni`
  String get shiftDeleteAll {
    return Intl.message(
      'Elimina tutti questi turni',
      name: 'shiftDeleteAll',
      desc: '',
      args: [],
    );
  }

  /// `Elimina la fascia oraria settimanale di ogni {dayName}`
  String shiftDeleteAllDesc(String dayName) {
    return Intl.message(
      'Elimina la fascia oraria settimanale di ogni $dayName',
      name: 'shiftDeleteAllDesc',
      desc: '',
      args: [dayName],
    );
  }

  /// `Modifica solo questo turno`
  String get shiftEditThisOnly {
    return Intl.message(
      'Modifica solo questo turno',
      name: 'shiftEditThisOnly',
      desc: '',
      args: [],
    );
  }

  /// `Modifica solo la fascia oraria di {date}`
  String shiftEditThisOnlyDesc(String date) {
    return Intl.message(
      'Modifica solo la fascia oraria di $date',
      name: 'shiftEditThisOnlyDesc',
      desc: '',
      args: [date],
    );
  }

  /// `Modifica tutti questi turni`
  String get shiftEditAll {
    return Intl.message(
      'Modifica tutti questi turni',
      name: 'shiftEditAll',
      desc: '',
      args: [],
    );
  }

  /// `Modifica la fascia oraria settimanale di ogni {dayName}`
  String shiftEditAllDesc(String dayName) {
    return Intl.message(
      'Modifica la fascia oraria settimanale di ogni $dayName',
      name: 'shiftEditAllDesc',
      desc: '',
      args: [dayName],
    );
  }

  /// `Modifica turno`
  String get shiftEditTitle {
    return Intl.message(
      'Modifica turno',
      name: 'shiftEditTitle',
      desc: '',
      args: [],
    );
  }

  /// `Ora inizio`
  String get shiftStartTime {
    return Intl.message(
      'Ora inizio',
      name: 'shiftStartTime',
      desc: '',
      args: [],
    );
  }

  /// `Ora fine`
  String get shiftEndTime {
    return Intl.message('Ora fine', name: 'shiftEndTime', desc: '', args: []);
  }

  /// `Modifica eccezione`
  String get exceptionEditShift {
    return Intl.message(
      'Modifica eccezione',
      name: 'exceptionEditShift',
      desc: '',
      args: [],
    );
  }

  /// `Modifica gli orari di questa eccezione`
  String get exceptionEditShiftDesc {
    return Intl.message(
      'Modifica gli orari di questa eccezione',
      name: 'exceptionEditShiftDesc',
      desc: '',
      args: [],
    );
  }

  /// `Elimina eccezione`
  String get exceptionDeleteShift {
    return Intl.message(
      'Elimina eccezione',
      name: 'exceptionDeleteShift',
      desc: '',
      args: [],
    );
  }

  /// `Ripristina la disponibilit√† base`
  String get exceptionDeleteShiftDesc {
    return Intl.message(
      'Ripristina la disponibilit√† base',
      name: 'exceptionDeleteShiftDesc',
      desc: '',
      args: [],
    );
  }

  /// `Il cliente non pu√≤ essere modificato per questo appuntamento`
  String get clientLockedHint {
    return Intl.message(
      'Il cliente non pu√≤ essere modificato per questo appuntamento',
      name: 'clientLockedHint',
      desc: '',
      args: [],
    );
  }

  /// `Applicare il cliente a tutta la prenotazione?`
  String get applyClientToAllAppointmentsTitle {
    return Intl.message(
      'Applicare il cliente a tutta la prenotazione?',
      name: 'applyClientToAllAppointmentsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il cliente verr√† associato anche agli appuntamenti di questa prenotazione che sono stati assegnati ad altro operatore.`
  String get applyClientToAllAppointmentsMessage {
    return Intl.message(
      'Il cliente verr√† associato anche agli appuntamenti di questa prenotazione che sono stati assegnati ad altro operatore.',
      name: 'applyClientToAllAppointmentsMessage',
      desc: '',
      args: [],
    );
  }

  /// `Operatori`
  String get operatorsTitle {
    return Intl.message(
      'Operatori',
      name: 'operatorsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Gestisci chi pu√≤ accedere al gestionale`
  String get operatorsSubtitle {
    return Intl.message(
      'Gestisci chi pu√≤ accedere al gestionale',
      name: 'operatorsSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Permessi`
  String get permissionsTitle {
    return Intl.message(
      'Permessi',
      name: 'permissionsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Gestisci accessi e ruoli degli operatori`
  String get permissionsDescription {
    return Intl.message(
      'Gestisci accessi e ruoli degli operatori',
      name: 'permissionsDescription',
      desc: '',
      args: [],
    );
  }

  /// `Nessun operatore configurato`
  String get operatorsEmpty {
    return Intl.message(
      'Nessun operatore configurato',
      name: 'operatorsEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Invita operatore`
  String get operatorsInviteTitle {
    return Intl.message(
      'Invita operatore',
      name: 'operatorsInviteTitle',
      desc: '',
      args: [],
    );
  }

  /// `Invia un invito via email`
  String get operatorsInviteSubtitle {
    return Intl.message(
      'Invia un invito via email',
      name: 'operatorsInviteSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Email`
  String get operatorsInviteEmail {
    return Intl.message(
      'Email',
      name: 'operatorsInviteEmail',
      desc: '',
      args: [],
    );
  }

  /// `Ruolo`
  String get operatorsInviteRole {
    return Intl.message(
      'Ruolo',
      name: 'operatorsInviteRole',
      desc: '',
      args: [],
    );
  }

  /// `Invia invito`
  String get operatorsInviteSend {
    return Intl.message(
      'Invia invito',
      name: 'operatorsInviteSend',
      desc: '',
      args: [],
    );
  }

  /// `Invito inviato a {email}`
  String operatorsInviteSuccess(String email) {
    return Intl.message(
      'Invito inviato a $email',
      name: 'operatorsInviteSuccess',
      desc: '',
      args: [email],
    );
  }

  /// `Esiste gi√† un invito in attesa per questa email. Puoi reinviarlo dalla lista degli inviti pendenti.`
  String get operatorsInviteAlreadyPending {
    return Intl.message(
      'Esiste gi√† un invito in attesa per questa email. Puoi reinviarlo dalla lista degli inviti pendenti.',
      name: 'operatorsInviteAlreadyPending',
      desc: '',
      args: [],
    );
  }

  /// `Questo utente ha gi√† accesso al business.`
  String get operatorsInviteAlreadyHasAccess {
    return Intl.message(
      'Questo utente ha gi√† accesso al business.',
      name: 'operatorsInviteAlreadyHasAccess',
      desc: '',
      args: [],
    );
  }

  /// `Invio email non disponibile in questo ambiente. Contatta il supporto.`
  String get operatorsInviteEmailUnavailable {
    return Intl.message(
      'Invio email non disponibile in questo ambiente. Contatta il supporto.',
      name: 'operatorsInviteEmailUnavailable',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile inviare l'email di invito. Riprova pi√π tardi.`
  String get operatorsInviteEmailFailed {
    return Intl.message(
      'Impossibile inviare l\'email di invito. Riprova pi√π tardi.',
      name: 'operatorsInviteEmailFailed',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile inviare l'invito`
  String get operatorsInviteError {
    return Intl.message(
      'Impossibile inviare l\'invito',
      name: 'operatorsInviteError',
      desc: '',
      args: [],
    );
  }

  /// `Link di invito copiato`
  String get operatorsInviteCopied {
    return Intl.message(
      'Link di invito copiato',
      name: 'operatorsInviteCopied',
      desc: '',
      args: [],
    );
  }

  /// `Accetta invito`
  String get invitationAcceptTitle {
    return Intl.message(
      'Accetta invito',
      name: 'invitationAcceptTitle',
      desc: '',
      args: [],
    );
  }

  /// `Verifica invito in corso...`
  String get invitationAcceptLoading {
    return Intl.message(
      'Verifica invito in corso...',
      name: 'invitationAcceptLoading',
      desc: '',
      args: [],
    );
  }

  /// `Sei stato invitato a collaborare con {businessName} come {role}.`
  String invitationAcceptIntro(String businessName, String role) {
    return Intl.message(
      'Sei stato invitato a collaborare con $businessName come $role.',
      name: 'invitationAcceptIntro',
      desc: '',
      args: [businessName, role],
    );
  }

  /// `Accedi con l'email invitata per continuare.`
  String get invitationAcceptLoginRequired {
    return Intl.message(
      'Accedi con l\'email invitata per continuare.',
      name: 'invitationAcceptLoginRequired',
      desc: '',
      args: [],
    );
  }

  /// `Accetta per continuare`
  String get invitationAcceptLoginAction {
    return Intl.message(
      'Accetta per continuare',
      name: 'invitationAcceptLoginAction',
      desc: '',
      args: [],
    );
  }

  /// `Accetta e accedi`
  String get invitationAcceptAndLoginAction {
    return Intl.message(
      'Accetta e accedi',
      name: 'invitationAcceptAndLoginAction',
      desc: '',
      args: [],
    );
  }

  /// `Hai gi√† un account? Accedi per accettare l'invito.`
  String get invitationAcceptHintExistingAccount {
    return Intl.message(
      'Hai gi√† un account? Accedi per accettare l\'invito.',
      name: 'invitationAcceptHintExistingAccount',
      desc: '',
      args: [],
    );
  }

  /// `Non hai un account? Registrati prima.`
  String get invitationAcceptHintNoAccount {
    return Intl.message(
      'Non hai un account? Registrati prima.',
      name: 'invitationAcceptHintNoAccount',
      desc: '',
      args: [],
    );
  }

  /// `Registrati per accettare`
  String get invitationRegisterAction {
    return Intl.message(
      'Registrati per accettare',
      name: 'invitationRegisterAction',
      desc: '',
      args: [],
    );
  }

  /// `Registrati per accettare l'invito`
  String get invitationRegisterTitle {
    return Intl.message(
      'Registrati per accettare l\'invito',
      name: 'invitationRegisterTitle',
      desc: '',
      args: [],
    );
  }

  /// `Registrazione...`
  String get invitationRegisterInProgress {
    return Intl.message(
      'Registrazione...',
      name: 'invitationRegisterInProgress',
      desc: '',
      args: [],
    );
  }

  /// `Conferma password`
  String get invitationRegisterPasswordConfirm {
    return Intl.message(
      'Conferma password',
      name: 'invitationRegisterPasswordConfirm',
      desc: '',
      args: [],
    );
  }

  /// `La password deve avere almeno 8 caratteri.`
  String get invitationRegisterPasswordTooShort {
    return Intl.message(
      'La password deve avere almeno 8 caratteri.',
      name: 'invitationRegisterPasswordTooShort',
      desc: '',
      args: [],
    );
  }

  /// `La password deve contenere almeno una maiuscola, una minuscola e un numero.`
  String get invitationRegisterPasswordWeak {
    return Intl.message(
      'La password deve contenere almeno una maiuscola, una minuscola e un numero.',
      name: 'invitationRegisterPasswordWeak',
      desc: '',
      args: [],
    );
  }

  /// `Le password non coincidono.`
  String get invitationRegisterPasswordMismatch {
    return Intl.message(
      'Le password non coincidono.',
      name: 'invitationRegisterPasswordMismatch',
      desc: '',
      args: [],
    );
  }

  /// `Email gi√† registrata. Accedi per accettare l'invito.`
  String get invitationRegisterExistingUser {
    return Intl.message(
      'Email gi√† registrata. Accedi per accettare l\'invito.',
      name: 'invitationRegisterExistingUser',
      desc: '',
      args: [],
    );
  }

  /// `Per questa email non esiste ancora un account. Usa Registrati.`
  String get invitationAcceptRequiresRegistration {
    return Intl.message(
      'Per questa email non esiste ancora un account. Usa Registrati.',
      name: 'invitationAcceptRequiresRegistration',
      desc: '',
      args: [],
    );
  }

  /// `Accetta invito`
  String get invitationAcceptButton {
    return Intl.message(
      'Accetta invito',
      name: 'invitationAcceptButton',
      desc: '',
      args: [],
    );
  }

  /// `Accettazione in corso...`
  String get invitationAcceptInProgress {
    return Intl.message(
      'Accettazione in corso...',
      name: 'invitationAcceptInProgress',
      desc: '',
      args: [],
    );
  }

  /// `Rifiuta invito`
  String get invitationDeclineButton {
    return Intl.message(
      'Rifiuta invito',
      name: 'invitationDeclineButton',
      desc: '',
      args: [],
    );
  }

  /// `Rifiuto in corso...`
  String get invitationDeclineInProgress {
    return Intl.message(
      'Rifiuto in corso...',
      name: 'invitationDeclineInProgress',
      desc: '',
      args: [],
    );
  }

  /// `Invito accettato`
  String get invitationAcceptSuccessTitle {
    return Intl.message(
      'Invito accettato',
      name: 'invitationAcceptSuccessTitle',
      desc: '',
      args: [],
    );
  }

  /// `Ora puoi usare il gestionale con i permessi assegnati.`
  String get invitationAcceptSuccessMessage {
    return Intl.message(
      'Ora puoi usare il gestionale con i permessi assegnati.',
      name: 'invitationAcceptSuccessMessage',
      desc: '',
      args: [],
    );
  }

  /// `Invito rifiutato`
  String get invitationDeclineSuccessTitle {
    return Intl.message(
      'Invito rifiutato',
      name: 'invitationDeclineSuccessTitle',
      desc: '',
      args: [],
    );
  }

  /// `Hai rifiutato l'invito. Non √® stata aggiunta nessuna autorizzazione.`
  String get invitationDeclineSuccessMessage {
    return Intl.message(
      'Hai rifiutato l\'invito. Non √® stata aggiunta nessuna autorizzazione.',
      name: 'invitationDeclineSuccessMessage',
      desc: '',
      args: [],
    );
  }

  /// `Vai al login`
  String get invitationDeclineGoLogin {
    return Intl.message(
      'Vai al login',
      name: 'invitationDeclineGoLogin',
      desc: '',
      args: [],
    );
  }

  /// `Questo invito non √® valido.`
  String get invitationAcceptErrorInvalid {
    return Intl.message(
      'Questo invito non √® valido.',
      name: 'invitationAcceptErrorInvalid',
      desc: '',
      args: [],
    );
  }

  /// `Questo invito √® scaduto.`
  String get invitationAcceptErrorExpired {
    return Intl.message(
      'Questo invito √® scaduto.',
      name: 'invitationAcceptErrorExpired',
      desc: '',
      args: [],
    );
  }

  /// `Questo invito √® associato a un'altra email. Esegui il logout dall'account corrente, poi riapri questo link e accedi con l'email invitata.`
  String get invitationAcceptErrorEmailMismatch {
    return Intl.message(
      'Questo invito √® associato a un\'altra email. Esegui il logout dall\'account corrente, poi riapri questo link e accedi con l\'email invitata.',
      name: 'invitationAcceptErrorEmailMismatch',
      desc: '',
      args: [],
    );
  }

  /// `Vai all'applicazione`
  String get invitationGoToApplication {
    return Intl.message(
      'Vai all\'applicazione',
      name: 'invitationGoToApplication',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile completare l'operazione. Riprova.`
  String get invitationAcceptErrorGeneric {
    return Intl.message(
      'Impossibile completare l\'operazione. Riprova.',
      name: 'invitationAcceptErrorGeneric',
      desc: '',
      args: [],
    );
  }

  /// `Accesso`
  String get operatorsScopeTitle {
    return Intl.message(
      'Accesso',
      name: 'operatorsScopeTitle',
      desc: '',
      args: [],
    );
  }

  /// `Tutte le sedi`
  String get operatorsScopeBusiness {
    return Intl.message(
      'Tutte le sedi',
      name: 'operatorsScopeBusiness',
      desc: '',
      args: [],
    );
  }

  /// `Accesso completo a tutte le sedi del business`
  String get operatorsScopeBusinessDesc {
    return Intl.message(
      'Accesso completo a tutte le sedi del business',
      name: 'operatorsScopeBusinessDesc',
      desc: '',
      args: [],
    );
  }

  /// `Sedi specifiche`
  String get operatorsScopeLocations {
    return Intl.message(
      'Sedi specifiche',
      name: 'operatorsScopeLocations',
      desc: '',
      args: [],
    );
  }

  /// `Accesso limitato alle sedi selezionate`
  String get operatorsScopeLocationsDesc {
    return Intl.message(
      'Accesso limitato alle sedi selezionate',
      name: 'operatorsScopeLocationsDesc',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona sedi`
  String get operatorsScopeSelectLocations {
    return Intl.message(
      'Seleziona sedi',
      name: 'operatorsScopeSelectLocations',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona almeno una sede`
  String get operatorsScopeLocationsRequired {
    return Intl.message(
      'Seleziona almeno una sede',
      name: 'operatorsScopeLocationsRequired',
      desc: '',
      args: [],
    );
  }

  /// `Inviti in attesa`
  String get operatorsPendingInvites {
    return Intl.message(
      'Inviti in attesa',
      name: 'operatorsPendingInvites',
      desc: '',
      args: [],
    );
  }

  /// `{count} inviti in attesa`
  String operatorsPendingInvitesCount(int count) {
    return Intl.message(
      '$count inviti in attesa',
      name: 'operatorsPendingInvitesCount',
      desc: '',
      args: [count],
    );
  }

  /// `Revoca invito`
  String get operatorsRevokeInvite {
    return Intl.message(
      'Revoca invito',
      name: 'operatorsRevokeInvite',
      desc: '',
      args: [],
    );
  }

  /// `Vuoi revocare l'invito per {email}?`
  String operatorsRevokeInviteConfirm(String email) {
    return Intl.message(
      'Vuoi revocare l\'invito per $email?',
      name: 'operatorsRevokeInviteConfirm',
      desc: '',
      args: [email],
    );
  }

  /// `Elimina invito`
  String get operatorsDeleteInvite {
    return Intl.message(
      'Elimina invito',
      name: 'operatorsDeleteInvite',
      desc: '',
      args: [],
    );
  }

  /// `Vuoi eliminare definitivamente l'invito per {email}?`
  String operatorsDeleteInviteConfirm(String email) {
    return Intl.message(
      'Vuoi eliminare definitivamente l\'invito per $email?',
      name: 'operatorsDeleteInviteConfirm',
      desc: '',
      args: [email],
    );
  }

  /// `Modifica ruolo`
  String get operatorsEditRole {
    return Intl.message(
      'Modifica ruolo',
      name: 'operatorsEditRole',
      desc: '',
      args: [],
    );
  }

  /// `Rimuovi operatore`
  String get operatorsRemove {
    return Intl.message(
      'Rimuovi operatore',
      name: 'operatorsRemove',
      desc: '',
      args: [],
    );
  }

  /// `Vuoi rimuovere {name} dal team?`
  String operatorsRemoveConfirm(String name) {
    return Intl.message(
      'Vuoi rimuovere $name dal team?',
      name: 'operatorsRemoveConfirm',
      desc: '',
      args: [name],
    );
  }

  /// `Operatore rimosso`
  String get operatorsRemoveSuccess {
    return Intl.message(
      'Operatore rimosso',
      name: 'operatorsRemoveSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Proprietario`
  String get operatorsRoleOwner {
    return Intl.message(
      'Proprietario',
      name: 'operatorsRoleOwner',
      desc: '',
      args: [],
    );
  }

  /// `Amministratore`
  String get operatorsRoleAdmin {
    return Intl.message(
      'Amministratore',
      name: 'operatorsRoleAdmin',
      desc: '',
      args: [],
    );
  }

  /// `Accesso completo a tutte le funzionalit√†. Pu√≤ gestire altri operatori e modificare impostazioni del business.`
  String get operatorsRoleAdminDesc {
    return Intl.message(
      'Accesso completo a tutte le funzionalit√†. Pu√≤ gestire altri operatori e modificare impostazioni del business.',
      name: 'operatorsRoleAdminDesc',
      desc: '',
      args: [],
    );
  }

  /// `Manager`
  String get operatorsRoleManager {
    return Intl.message(
      'Manager',
      name: 'operatorsRoleManager',
      desc: '',
      args: [],
    );
  }

  /// `Gestisce agenda e clienti. Vede e gestisce tutti gli appuntamenti, ma non pu√≤ gestire operatori n√© impostazioni.`
  String get operatorsRoleManagerDesc {
    return Intl.message(
      'Gestisce agenda e clienti. Vede e gestisce tutti gli appuntamenti, ma non pu√≤ gestire operatori n√© impostazioni.',
      name: 'operatorsRoleManagerDesc',
      desc: '',
      args: [],
    );
  }

  /// `Staff`
  String get operatorsRoleStaff {
    return Intl.message(
      'Staff',
      name: 'operatorsRoleStaff',
      desc: '',
      args: [],
    );
  }

  /// `Vede e gestisce solo i propri appuntamenti. Pu√≤ creare prenotazioni assegnate a s√© stesso.`
  String get operatorsRoleStaffDesc {
    return Intl.message(
      'Vede e gestisce solo i propri appuntamenti. Pu√≤ creare prenotazioni assegnate a s√© stesso.',
      name: 'operatorsRoleStaffDesc',
      desc: '',
      args: [],
    );
  }

  /// `Visualizzatore`
  String get operatorsRoleViewer {
    return Intl.message(
      'Visualizzatore',
      name: 'operatorsRoleViewer',
      desc: '',
      args: [],
    );
  }

  /// `Pu√≤ consultare appuntamenti, servizi, staff e disponibilit√†. Nessuna modifica consentita.`
  String get operatorsRoleViewerDesc {
    return Intl.message(
      'Pu√≤ consultare appuntamenti, servizi, staff e disponibilit√†. Nessuna modifica consentita.',
      name: 'operatorsRoleViewerDesc',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona il livello di accesso`
  String get operatorsRoleDescription {
    return Intl.message(
      'Seleziona il livello di accesso',
      name: 'operatorsRoleDescription',
      desc: '',
      args: [],
    );
  }

  /// `Tu`
  String get operatorsYou {
    return Intl.message('Tu', name: 'operatorsYou', desc: '', args: []);
  }

  /// `Invitato da {name}`
  String operatorsInvitedBy(String name) {
    return Intl.message(
      'Invitato da $name',
      name: 'operatorsInvitedBy',
      desc: '',
      args: [name],
    );
  }

  /// `Scade il {date}`
  String operatorsExpires(String date) {
    return Intl.message(
      'Scade il $date',
      name: 'operatorsExpires',
      desc: '',
      args: [date],
    );
  }

  /// `Accettato il {date}`
  String operatorsAcceptedOn(String date) {
    return Intl.message(
      'Accettato il $date',
      name: 'operatorsAcceptedOn',
      desc: '',
      args: [date],
    );
  }

  /// `{count} inviti archiviati`
  String operatorsInvitesHistoryCount(int count) {
    return Intl.message(
      '$count inviti archiviati',
      name: 'operatorsInvitesHistoryCount',
      desc: '',
      args: [count],
    );
  }

  /// `In attesa`
  String get operatorsInviteStatusPending {
    return Intl.message(
      'In attesa',
      name: 'operatorsInviteStatusPending',
      desc: '',
      args: [],
    );
  }

  /// `Accettato`
  String get operatorsInviteStatusAccepted {
    return Intl.message(
      'Accettato',
      name: 'operatorsInviteStatusAccepted',
      desc: '',
      args: [],
    );
  }

  /// `Rifiutato`
  String get operatorsInviteStatusDeclined {
    return Intl.message(
      'Rifiutato',
      name: 'operatorsInviteStatusDeclined',
      desc: '',
      args: [],
    );
  }

  /// `Revocato`
  String get operatorsInviteStatusRevoked {
    return Intl.message(
      'Revocato',
      name: 'operatorsInviteStatusRevoked',
      desc: '',
      args: [],
    );
  }

  /// `Scaduto`
  String get operatorsInviteStatusExpired {
    return Intl.message(
      'Scaduto',
      name: 'operatorsInviteStatusExpired',
      desc: '',
      args: [],
    );
  }

  /// `Accedi al gestionale`
  String get authLoginSubtitle {
    return Intl.message(
      'Accedi al gestionale',
      name: 'authLoginSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Email`
  String get authEmail {
    return Intl.message('Email', name: 'authEmail', desc: '', args: []);
  }

  /// `Password`
  String get authPassword {
    return Intl.message('Password', name: 'authPassword', desc: '', args: []);
  }

  /// `Accedi`
  String get authLogin {
    return Intl.message('Accedi', name: 'authLogin', desc: '', args: []);
  }

  /// `Esci`
  String get authLogout {
    return Intl.message('Esci', name: 'authLogout', desc: '', args: []);
  }

  /// `Ricordami`
  String get authRememberMe {
    return Intl.message(
      'Ricordami',
      name: 'authRememberMe',
      desc: '',
      args: [],
    );
  }

  /// `Password dimenticata?`
  String get authForgotPassword {
    return Intl.message(
      'Password dimenticata?',
      name: 'authForgotPassword',
      desc: '',
      args: [],
    );
  }

  /// `Contatta l'amministratore di sistema per reimpostare la password.`
  String get authForgotPasswordInfo {
    return Intl.message(
      'Contatta l\'amministratore di sistema per reimpostare la password.',
      name: 'authForgotPasswordInfo',
      desc: '',
      args: [],
    );
  }

  /// `Recupera password`
  String get authResetPasswordTitle {
    return Intl.message(
      'Recupera password',
      name: 'authResetPasswordTitle',
      desc: '',
      args: [],
    );
  }

  /// `Inserisci la tua email. Ti invieremo un link per reimpostare la password.`
  String get authResetPasswordMessage {
    return Intl.message(
      'Inserisci la tua email. Ti invieremo un link per reimpostare la password.',
      name: 'authResetPasswordMessage',
      desc: '',
      args: [],
    );
  }

  /// `Invia`
  String get authResetPasswordSend {
    return Intl.message(
      'Invia',
      name: 'authResetPasswordSend',
      desc: '',
      args: [],
    );
  }

  /// `Se l'email esiste nel sistema, riceverai un link per reimpostare la password.`
  String get authResetPasswordSuccess {
    return Intl.message(
      'Se l\'email esiste nel sistema, riceverai un link per reimpostare la password.',
      name: 'authResetPasswordSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Si √® verificato un errore. Riprova pi√π tardi.`
  String get authResetPasswordError {
    return Intl.message(
      'Si √® verificato un errore. Riprova pi√π tardi.',
      name: 'authResetPasswordError',
      desc: '',
      args: [],
    );
  }

  /// `Campo obbligatorio`
  String get authRequiredField {
    return Intl.message(
      'Campo obbligatorio',
      name: 'authRequiredField',
      desc: '',
      args: [],
    );
  }

  /// `Email non valida`
  String get authInvalidEmail {
    return Intl.message(
      'Email non valida',
      name: 'authInvalidEmail',
      desc: '',
      args: [],
    );
  }

  /// `Password troppo corta`
  String get authPasswordTooShort {
    return Intl.message(
      'Password troppo corta',
      name: 'authPasswordTooShort',
      desc: '',
      args: [],
    );
  }

  /// `Credenziali non valide. Riprova.`
  String get authLoginFailed {
    return Intl.message(
      'Credenziali non valide. Riprova.',
      name: 'authLoginFailed',
      desc: '',
      args: [],
    );
  }

  /// `Connessione al server non riuscita. Controlla la tua connessione internet.`
  String get authNetworkError {
    return Intl.message(
      'Connessione al server non riuscita. Controlla la tua connessione internet.',
      name: 'authNetworkError',
      desc: '',
      args: [],
    );
  }

  /// `Accesso riservato agli operatori autorizzati`
  String get authLoginFooter {
    return Intl.message(
      'Accesso riservato agli operatori autorizzati',
      name: 'authLoginFooter',
      desc: '',
      args: [],
    );
  }

  /// `Nome`
  String get authFirstName {
    return Intl.message('Nome', name: 'authFirstName', desc: '', args: []);
  }

  /// `Cognome`
  String get authLastName {
    return Intl.message('Cognome', name: 'authLastName', desc: '', args: []);
  }

  /// `Telefono`
  String get authPhone {
    return Intl.message('Telefono', name: 'authPhone', desc: '', args: []);
  }

  /// `Cambia`
  String get switchBusiness {
    return Intl.message('Cambia', name: 'switchBusiness', desc: '', args: []);
  }

  /// `Profilo`
  String get profileTitle {
    return Intl.message('Profilo', name: 'profileTitle', desc: '', args: []);
  }

  /// `Profilo aggiornato con successo`
  String get profileUpdateSuccess {
    return Intl.message(
      'Profilo aggiornato con successo',
      name: 'profileUpdateSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Attenzione: cambiando email dovrai usarla per il login`
  String get profileEmailChangeWarning {
    return Intl.message(
      'Attenzione: cambiando email dovrai usarla per il login',
      name: 'profileEmailChangeWarning',
      desc: '',
      args: [],
    );
  }

  /// `Cambia password`
  String get profileChangePassword {
    return Intl.message(
      'Cambia password',
      name: 'profileChangePassword',
      desc: '',
      args: [],
    );
  }

  /// `Cambia business`
  String get profileSwitchBusiness {
    return Intl.message(
      'Cambia business',
      name: 'profileSwitchBusiness',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo planning`
  String get planningCreateTitle {
    return Intl.message(
      'Nuovo planning',
      name: 'planningCreateTitle',
      desc: '',
      args: [],
    );
  }

  /// `Modifica planning`
  String get planningEditTitle {
    return Intl.message(
      'Modifica planning',
      name: 'planningEditTitle',
      desc: '',
      args: [],
    );
  }

  /// `Elimina planning`
  String get planningDeleteTitle {
    return Intl.message(
      'Elimina planning',
      name: 'planningDeleteTitle',
      desc: '',
      args: [],
    );
  }

  /// `Sei sicuro di voler eliminare questo planning? Gli orari settimanali verranno rimossi.`
  String get planningDeleteConfirm {
    return Intl.message(
      'Sei sicuro di voler eliminare questo planning? Gli orari settimanali verranno rimossi.',
      name: 'planningDeleteConfirm',
      desc: '',
      args: [],
    );
  }

  /// `Tipo planning`
  String get planningType {
    return Intl.message(
      'Tipo planning',
      name: 'planningType',
      desc: '',
      args: [],
    );
  }

  /// `Settimanale`
  String get planningTypeWeekly {
    return Intl.message(
      'Settimanale',
      name: 'planningTypeWeekly',
      desc: '',
      args: [],
    );
  }

  /// `Bisettimanale`
  String get planningTypeBiweekly {
    return Intl.message(
      'Bisettimanale',
      name: 'planningTypeBiweekly',
      desc: '',
      args: [],
    );
  }

  /// `Non disponibile`
  String get planningTypeUnavailable {
    return Intl.message(
      'Non disponibile',
      name: 'planningTypeUnavailable',
      desc: '',
      args: [],
    );
  }

  /// `Data inizio validit√†`
  String get planningValidFrom {
    return Intl.message(
      'Data inizio validit√†',
      name: 'planningValidFrom',
      desc: '',
      args: [],
    );
  }

  /// `Data fine validit√†`
  String get planningValidTo {
    return Intl.message(
      'Data fine validit√†',
      name: 'planningValidTo',
      desc: '',
      args: [],
    );
  }

  /// `Senza scadenza`
  String get planningOpenEnded {
    return Intl.message(
      'Senza scadenza',
      name: 'planningOpenEnded',
      desc: '',
      args: [],
    );
  }

  /// `Valida dal {from} al {to}`
  String planningValidFromTo(String from, String to) {
    return Intl.message(
      'Valida dal $from al $to',
      name: 'planningValidFromTo',
      desc: '',
      args: [from, to],
    );
  }

  /// `Valida dal {from}`
  String planningValidFromOnly(String from) {
    return Intl.message(
      'Valida dal $from',
      name: 'planningValidFromOnly',
      desc: '',
      args: [from],
    );
  }

  /// `{hours}h/settimana`
  String planningWeeklyHours(int hours) {
    return Intl.message(
      '${hours}h/settimana',
      name: 'planningWeeklyHours',
      desc: '',
      args: [hours],
    );
  }

  /// `Sett. A: {hoursA}h | Sett. B: {hoursB}h | Tot: {total}h`
  String planningBiweeklyHours(int hoursA, int hoursB, int total) {
    return Intl.message(
      'Sett. A: ${hoursA}h | Sett. B: ${hoursB}h | Tot: ${total}h',
      name: 'planningBiweeklyHours',
      desc: '',
      args: [hoursA, hoursB, total],
    );
  }

  /// `{duration}/settimana`
  String planningWeeklyDuration(String duration) {
    return Intl.message(
      '$duration/settimana',
      name: 'planningWeeklyDuration',
      desc: '',
      args: [duration],
    );
  }

  /// `Sett. A: {durationA} | Sett. B: {durationB} | Tot: {totalDuration}`
  String planningBiweeklyDuration(
    String durationA,
    String durationB,
    String totalDuration,
  ) {
    return Intl.message(
      'Sett. A: $durationA | Sett. B: $durationB | Tot: $totalDuration',
      name: 'planningBiweeklyDuration',
      desc: '',
      args: [durationA, durationB, totalDuration],
    );
  }

  /// `Mostra planning scaduti ({count})`
  String planningShowExpired(int count) {
    return Intl.message(
      'Mostra planning scaduti ($count)',
      name: 'planningShowExpired',
      desc: '',
      args: [count],
    );
  }

  /// `Nascondi planning scaduti`
  String get planningHideExpired {
    return Intl.message(
      'Nascondi planning scaduti',
      name: 'planningHideExpired',
      desc: '',
      args: [],
    );
  }

  /// `Imposta data fine`
  String get planningSetEndDate {
    return Intl.message(
      'Imposta data fine',
      name: 'planningSetEndDate',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona data`
  String get planningSelectDate {
    return Intl.message(
      'Seleziona data',
      name: 'planningSelectDate',
      desc: '',
      args: [],
    );
  }

  /// `Planning`
  String get planningListTitle {
    return Intl.message(
      'Planning',
      name: 'planningListTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessun planning definito`
  String get planningListEmpty {
    return Intl.message(
      'Nessun planning definito',
      name: 'planningListEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi planning`
  String get planningListAdd {
    return Intl.message(
      'Aggiungi planning',
      name: 'planningListAdd',
      desc: '',
      args: [],
    );
  }

  /// `Settimana A`
  String get planningWeekA {
    return Intl.message(
      'Settimana A',
      name: 'planningWeekA',
      desc: '',
      args: [],
    );
  }

  /// `Settimana B`
  String get planningWeekB {
    return Intl.message(
      'Settimana B',
      name: 'planningWeekB',
      desc: '',
      args: [],
    );
  }

  /// `Settimana attuale: {week}`
  String planningCurrentWeek(String week) {
    return Intl.message(
      'Settimana attuale: $week',
      name: 'planningCurrentWeek',
      desc: '',
      args: [week],
    );
  }

  /// `Dal {from} al {to}`
  String planningValidityRange(String from, String to) {
    return Intl.message(
      'Dal $from al $to',
      name: 'planningValidityRange',
      desc: '',
      args: [from, to],
    );
  }

  /// `Dal {from}`
  String planningValidityFrom(String from) {
    return Intl.message(
      'Dal $from',
      name: 'planningValidityFrom',
      desc: '',
      args: [from],
    );
  }

  /// `Attivo`
  String get planningActive {
    return Intl.message('Attivo', name: 'planningActive', desc: '', args: []);
  }

  /// `Futuro`
  String get planningFuture {
    return Intl.message('Futuro', name: 'planningFuture', desc: '', args: []);
  }

  /// `Passato`
  String get planningPast {
    return Intl.message('Passato', name: 'planningPast', desc: '', args: []);
  }

  /// `Prezzo`
  String get appointmentPriceLabel {
    return Intl.message(
      'Prezzo',
      name: 'appointmentPriceLabel',
      desc: '',
      args: [],
    );
  }

  /// `Prezzo personalizzato`
  String get appointmentPriceHint {
    return Intl.message(
      'Prezzo personalizzato',
      name: 'appointmentPriceHint',
      desc: '',
      args: [],
    );
  }

  /// `Ripristina prezzo del servizio`
  String get appointmentPriceResetTooltip {
    return Intl.message(
      'Ripristina prezzo del servizio',
      name: 'appointmentPriceResetTooltip',
      desc: '',
      args: [],
    );
  }

  /// `Gratuito`
  String get appointmentPriceFree {
    return Intl.message(
      'Gratuito',
      name: 'appointmentPriceFree',
      desc: '',
      args: [],
    );
  }

  /// `Storico prenotazione`
  String get bookingHistoryTitle {
    return Intl.message(
      'Storico prenotazione',
      name: 'bookingHistoryTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessun evento registrato`
  String get bookingHistoryEmpty {
    return Intl.message(
      'Nessun evento registrato',
      name: 'bookingHistoryEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Caricamento storico...`
  String get bookingHistoryLoading {
    return Intl.message(
      'Caricamento storico...',
      name: 'bookingHistoryLoading',
      desc: '',
      args: [],
    );
  }

  /// `Errore nel caricamento dello storico`
  String get bookingHistoryError {
    return Intl.message(
      'Errore nel caricamento dello storico',
      name: 'bookingHistoryError',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione creata`
  String get bookingHistoryEventCreated {
    return Intl.message(
      'Prenotazione creata',
      name: 'bookingHistoryEventCreated',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione modificata`
  String get bookingHistoryEventUpdated {
    return Intl.message(
      'Prenotazione modificata',
      name: 'bookingHistoryEventUpdated',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione cancellata`
  String get bookingHistoryEventCancelled {
    return Intl.message(
      'Prenotazione cancellata',
      name: 'bookingHistoryEventCancelled',
      desc: '',
      args: [],
    );
  }

  /// `Email inviata al cliente`
  String get bookingHistoryEventNotificationSent {
    return Intl.message(
      'Email inviata al cliente',
      name: 'bookingHistoryEventNotificationSent',
      desc: '',
      args: [],
    );
  }

  /// `Inviata email di tipo: {type}`
  String bookingHistoryEventNotificationSentTitle(Object type) {
    return Intl.message(
      'Inviata email di tipo: $type',
      name: 'bookingHistoryEventNotificationSentTitle',
      desc: '',
      args: [type],
    );
  }

  /// `Servizio aggiunto`
  String get bookingHistoryEventItemAdded {
    return Intl.message(
      'Servizio aggiunto',
      name: 'bookingHistoryEventItemAdded',
      desc: '',
      args: [],
    );
  }

  /// `Servizio rimosso`
  String get bookingHistoryEventItemDeleted {
    return Intl.message(
      'Servizio rimosso',
      name: 'bookingHistoryEventItemDeleted',
      desc: '',
      args: [],
    );
  }

  /// `Appuntamento modificato`
  String get bookingHistoryEventAppointmentUpdated {
    return Intl.message(
      'Appuntamento modificato',
      name: 'bookingHistoryEventAppointmentUpdated',
      desc: '',
      args: [],
    );
  }

  /// `Orario modificato`
  String get bookingHistoryEventTimeChanged {
    return Intl.message(
      'Orario modificato',
      name: 'bookingHistoryEventTimeChanged',
      desc: '',
      args: [],
    );
  }

  /// `Operatore cambiato`
  String get bookingHistoryEventStaffChanged {
    return Intl.message(
      'Operatore cambiato',
      name: 'bookingHistoryEventStaffChanged',
      desc: '',
      args: [],
    );
  }

  /// `Prezzo modificato`
  String get bookingHistoryEventPriceChanged {
    return Intl.message(
      'Prezzo modificato',
      name: 'bookingHistoryEventPriceChanged',
      desc: '',
      args: [],
    );
  }

  /// `Durata modificata`
  String get bookingHistoryEventDurationChanged {
    return Intl.message(
      'Durata modificata',
      name: 'bookingHistoryEventDurationChanged',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione riprogrammata`
  String get bookingHistoryEventReplaced {
    return Intl.message(
      'Prenotazione riprogrammata',
      name: 'bookingHistoryEventReplaced',
      desc: '',
      args: [],
    );
  }

  /// `Operatore`
  String get bookingHistoryActorStaff {
    return Intl.message(
      'Operatore',
      name: 'bookingHistoryActorStaff',
      desc: '',
      args: [],
    );
  }

  /// `Cliente`
  String get bookingHistoryActorCustomer {
    return Intl.message(
      'Cliente',
      name: 'bookingHistoryActorCustomer',
      desc: '',
      args: [],
    );
  }

  /// `Sistema`
  String get bookingHistoryActorSystem {
    return Intl.message(
      'Sistema',
      name: 'bookingHistoryActorSystem',
      desc: '',
      args: [],
    );
  }

  /// `Tipo: {channel}`
  String bookingHistoryNotificationChannel(Object channel) {
    return Intl.message(
      'Tipo: $channel',
      name: 'bookingHistoryNotificationChannel',
      desc: '',
      args: [channel],
    );
  }

  /// `Destinatario: {email}`
  String bookingHistoryNotificationRecipient(Object email) {
    return Intl.message(
      'Destinatario: $email',
      name: 'bookingHistoryNotificationRecipient',
      desc: '',
      args: [email],
    );
  }

  /// `Data invio: {dateTime}`
  String bookingHistoryNotificationSentAt(Object dateTime) {
    return Intl.message(
      'Data invio: $dateTime',
      name: 'bookingHistoryNotificationSentAt',
      desc: '',
      args: [dateTime],
    );
  }

  /// `Oggetto: {subject}`
  String bookingHistoryNotificationSubject(Object subject) {
    return Intl.message(
      'Oggetto: $subject',
      name: 'bookingHistoryNotificationSubject',
      desc: '',
      args: [subject],
    );
  }

  /// `Conferma prenotazione`
  String get bookingHistoryNotificationChannelConfirmed {
    return Intl.message(
      'Conferma prenotazione',
      name: 'bookingHistoryNotificationChannelConfirmed',
      desc: '',
      args: [],
    );
  }

  /// `Promemoria prenotazione`
  String get bookingHistoryNotificationChannelReminder {
    return Intl.message(
      'Promemoria prenotazione',
      name: 'bookingHistoryNotificationChannelReminder',
      desc: '',
      args: [],
    );
  }

  /// `Cancellazione prenotazione`
  String get bookingHistoryNotificationChannelCancelled {
    return Intl.message(
      'Cancellazione prenotazione',
      name: 'bookingHistoryNotificationChannelCancelled',
      desc: '',
      args: [],
    );
  }

  /// `Riprogrammazione prenotazione`
  String get bookingHistoryNotificationChannelRescheduled {
    return Intl.message(
      'Riprogrammazione prenotazione',
      name: 'bookingHistoryNotificationChannelRescheduled',
      desc: '',
      args: [],
    );
  }

  /// `Campi modificati: {fields}`
  String bookingHistoryChangedFields(String fields) {
    return Intl.message(
      'Campi modificati: $fields',
      name: 'bookingHistoryChangedFields',
      desc: '',
      args: [fields],
    );
  }

  /// `CANCELLATO`
  String get cancelledBadge {
    return Intl.message(
      'CANCELLATO',
      name: 'cancelledBadge',
      desc: '',
      args: [],
    );
  }

  /// `ANNULLATA`
  String get clientAppointmentsCancelledBadge {
    return Intl.message(
      'ANNULLATA',
      name: 'clientAppointmentsCancelledBadge',
      desc: '',
      args: [],
    );
  }

  /// `Ripeti questo appuntamento`
  String get recurrenceRepeatBooking {
    return Intl.message(
      'Ripeti questo appuntamento',
      name: 'recurrenceRepeatBooking',
      desc: '',
      args: [],
    );
  }

  /// `Ripeti questo blocco`
  String get recurrenceRepeatBlock {
    return Intl.message(
      'Ripeti questo blocco',
      name: 'recurrenceRepeatBlock',
      desc: '',
      args: [],
    );
  }

  /// `Frequenza`
  String get recurrenceFrequency {
    return Intl.message(
      'Frequenza',
      name: 'recurrenceFrequency',
      desc: '',
      args: [],
    );
  }

  /// `Ogni`
  String get recurrenceEvery {
    return Intl.message('Ogni', name: 'recurrenceEvery', desc: '', args: []);
  }

  /// `giorno`
  String get recurrenceDay {
    return Intl.message('giorno', name: 'recurrenceDay', desc: '', args: []);
  }

  /// `giorni`
  String get recurrenceDays {
    return Intl.message('giorni', name: 'recurrenceDays', desc: '', args: []);
  }

  /// `settimana`
  String get recurrenceWeek {
    return Intl.message(
      'settimana',
      name: 'recurrenceWeek',
      desc: '',
      args: [],
    );
  }

  /// `settimane`
  String get recurrenceWeeks {
    return Intl.message(
      'settimane',
      name: 'recurrenceWeeks',
      desc: '',
      args: [],
    );
  }

  /// `mese`
  String get recurrenceMonth {
    return Intl.message('mese', name: 'recurrenceMonth', desc: '', args: []);
  }

  /// `mesi`
  String get recurrenceMonths {
    return Intl.message('mesi', name: 'recurrenceMonths', desc: '', args: []);
  }

  /// `Termina`
  String get recurrenceEnds {
    return Intl.message('Termina', name: 'recurrenceEnds', desc: '', args: []);
  }

  /// `Per un anno`
  String get recurrenceNever {
    return Intl.message(
      'Per un anno',
      name: 'recurrenceNever',
      desc: '',
      args: [],
    );
  }

  /// `Dopo`
  String get recurrenceAfter {
    return Intl.message('Dopo', name: 'recurrenceAfter', desc: '', args: []);
  }

  /// `occorrenze`
  String get recurrenceOccurrences {
    return Intl.message(
      'occorrenze',
      name: 'recurrenceOccurrences',
      desc: '',
      args: [],
    );
  }

  /// `Il`
  String get recurrenceOnDate {
    return Intl.message('Il', name: 'recurrenceOnDate', desc: '', args: []);
  }

  /// `Seleziona data`
  String get recurrenceSelectDate {
    return Intl.message(
      'Seleziona data',
      name: 'recurrenceSelectDate',
      desc: '',
      args: [],
    );
  }

  /// `Anteprima appuntamenti`
  String get recurrencePreviewTitle {
    return Intl.message(
      'Anteprima appuntamenti',
      name: 'recurrencePreviewTitle',
      desc: '',
      args: [],
    );
  }

  /// `{count} appuntamenti`
  String recurrencePreviewCount(int count) {
    return Intl.message(
      '$count appuntamenti',
      name: 'recurrencePreviewCount',
      desc: '',
      args: [count],
    );
  }

  /// `{count} selezionati`
  String recurrencePreviewSelected(int count) {
    return Intl.message(
      '$count selezionati',
      name: 'recurrencePreviewSelected',
      desc: '',
      args: [count],
    );
  }

  /// `{count} conflitti`
  String recurrencePreviewConflicts(int count) {
    return Intl.message(
      '$count conflitti',
      name: 'recurrencePreviewConflicts',
      desc: '',
      args: [count],
    );
  }

  /// `Deseleziona le date che non vuoi creare`
  String get recurrencePreviewHint {
    return Intl.message(
      'Deseleziona le date che non vuoi creare',
      name: 'recurrencePreviewHint',
      desc: '',
      args: [],
    );
  }

  /// `Esclusa per conflitto`
  String get recurrencePreviewConflictSkip {
    return Intl.message(
      'Esclusa per conflitto',
      name: 'recurrencePreviewConflictSkip',
      desc: '',
      args: [],
    );
  }

  /// `Crea comunque`
  String get recurrencePreviewConflictForce {
    return Intl.message(
      'Crea comunque',
      name: 'recurrencePreviewConflictForce',
      desc: '',
      args: [],
    );
  }

  /// `Crea {count} appuntamenti`
  String recurrencePreviewConfirm(int count) {
    return Intl.message(
      'Crea $count appuntamenti',
      name: 'recurrencePreviewConfirm',
      desc: '',
      args: [count],
    );
  }

  /// `Serie creata`
  String get recurrenceSummaryTitle {
    return Intl.message(
      'Serie creata',
      name: 'recurrenceSummaryTitle',
      desc: '',
      args: [],
    );
  }

  /// `{count} appuntamenti creati`
  String recurrenceSummaryCreated(int count) {
    return Intl.message(
      '$count appuntamenti creati',
      name: 'recurrenceSummaryCreated',
      desc: '',
      args: [count],
    );
  }

  /// `{count} saltati per conflitto`
  String recurrenceSummarySkipped(int count) {
    return Intl.message(
      '$count saltati per conflitto',
      name: 'recurrenceSummarySkipped',
      desc: '',
      args: [count],
    );
  }

  /// `Errore nella creazione della serie`
  String get recurrenceSummaryError {
    return Intl.message(
      'Errore nella creazione della serie',
      name: 'recurrenceSummaryError',
      desc: '',
      args: [],
    );
  }

  /// `Appuntamenti:`
  String get recurrenceSummaryAppointments {
    return Intl.message(
      'Appuntamenti:',
      name: 'recurrenceSummaryAppointments',
      desc: '',
      args: [],
    );
  }

  /// `Saltato per conflitto`
  String get recurrenceSummaryConflict {
    return Intl.message(
      'Saltato per conflitto',
      name: 'recurrenceSummaryConflict',
      desc: '',
      args: [],
    );
  }

  /// `Eliminato`
  String get recurrenceSummaryDeleted {
    return Intl.message(
      'Eliminato',
      name: 'recurrenceSummaryDeleted',
      desc: '',
      args: [],
    );
  }

  /// `Appuntamento ricorrente`
  String get recurrenceSeriesIcon {
    return Intl.message(
      'Appuntamento ricorrente',
      name: 'recurrenceSeriesIcon',
      desc: '',
      args: [],
    );
  }

  /// `{index} di {total}`
  String recurrenceSeriesOf(int index, int total) {
    return Intl.message(
      '$index di $total',
      name: 'recurrenceSeriesOf',
      desc: '',
      args: [index, total],
    );
  }

  /// `Elimina appuntamento ricorrente`
  String get recurringDeleteTitle {
    return Intl.message(
      'Elimina appuntamento ricorrente',
      name: 'recurringDeleteTitle',
      desc: '',
      args: [],
    );
  }

  /// `Questo √® l'appuntamento {index} di {total} nella serie.`
  String recurringDeleteMessage(int index, int total) {
    return Intl.message(
      'Questo √® l\'appuntamento $index di $total nella serie.',
      name: 'recurringDeleteMessage',
      desc: '',
      args: [index, total],
    );
  }

  /// `Quali appuntamenti vuoi eliminare?`
  String get recurringDeleteChooseScope {
    return Intl.message(
      'Quali appuntamenti vuoi eliminare?',
      name: 'recurringDeleteChooseScope',
      desc: '',
      args: [],
    );
  }

  /// `Modifica appuntamento ricorrente`
  String get recurringEditTitle {
    return Intl.message(
      'Modifica appuntamento ricorrente',
      name: 'recurringEditTitle',
      desc: '',
      args: [],
    );
  }

  /// `Questo √® l'appuntamento {index} di {total} nella serie.`
  String recurringEditMessage(int index, int total) {
    return Intl.message(
      'Questo √® l\'appuntamento $index di $total nella serie.',
      name: 'recurringEditMessage',
      desc: '',
      args: [index, total],
    );
  }

  /// `Quali appuntamenti vuoi modificare?`
  String get recurringEditChooseScope {
    return Intl.message(
      'Quali appuntamenti vuoi modificare?',
      name: 'recurringEditChooseScope',
      desc: '',
      args: [],
    );
  }

  /// `Solo questo`
  String get recurringScopeOnlyThis {
    return Intl.message(
      'Solo questo',
      name: 'recurringScopeOnlyThis',
      desc: '',
      args: [],
    );
  }

  /// `Questo e futuri`
  String get recurringScopeThisAndFuture {
    return Intl.message(
      'Questo e futuri',
      name: 'recurringScopeThisAndFuture',
      desc: '',
      args: [],
    );
  }

  /// `Tutti`
  String get recurringScopeAll {
    return Intl.message('Tutti', name: 'recurringScopeAll', desc: '', args: []);
  }

  /// `Durata totale: {duration}`
  String bookingTotalDuration(String duration) {
    return Intl.message(
      'Durata totale: $duration',
      name: 'bookingTotalDuration',
      desc: '',
      args: [duration],
    );
  }

  /// `Totale: {price}`
  String bookingTotalPrice(String price) {
    return Intl.message(
      'Totale: $price',
      name: 'bookingTotalPrice',
      desc: '',
      args: [price],
    );
  }

  /// `√à necessario selezionare un cliente per gli appuntamenti ricorrenti`
  String get recurrenceClientRequired {
    return Intl.message(
      '√à necessario selezionare un cliente per gli appuntamenti ricorrenti',
      name: 'recurrenceClientRequired',
      desc: '',
      args: [],
    );
  }

  /// `Sovrapposizioni`
  String get recurrenceConflictHandling {
    return Intl.message(
      'Sovrapposizioni',
      name: 'recurrenceConflictHandling',
      desc: '',
      args: [],
    );
  }

  /// `Salta date con conflitti`
  String get recurrenceConflictSkip {
    return Intl.message(
      'Salta date con conflitti',
      name: 'recurrenceConflictSkip',
      desc: '',
      args: [],
    );
  }

  /// `Non crea appuntamenti se ci sono sovrapposizioni`
  String get recurrenceConflictSkipDescription {
    return Intl.message(
      'Non crea appuntamenti se ci sono sovrapposizioni',
      name: 'recurrenceConflictSkipDescription',
      desc: '',
      args: [],
    );
  }

  /// `Crea comunque`
  String get recurrenceConflictForce {
    return Intl.message(
      'Crea comunque',
      name: 'recurrenceConflictForce',
      desc: '',
      args: [],
    );
  }

  /// `Crea gli appuntamenti anche se ci sono sovrapposizioni`
  String get recurrenceConflictForceDescription {
    return Intl.message(
      'Crea gli appuntamenti anche se ci sono sovrapposizioni',
      name: 'recurrenceConflictForceDescription',
      desc: '',
      args: [],
    );
  }

  /// `Report`
  String get reportsTitle {
    return Intl.message('Report', name: 'reportsTitle', desc: '', args: []);
  }

  /// `Nessun dato disponibile`
  String get reportsNoData {
    return Intl.message(
      'Nessun dato disponibile',
      name: 'reportsNoData',
      desc: '',
      args: [],
    );
  }

  /// `Aggiorna`
  String get actionRefresh {
    return Intl.message('Aggiorna', name: 'actionRefresh', desc: '', args: []);
  }

  /// `Preset periodo`
  String get reportsPresets {
    return Intl.message(
      'Preset periodo',
      name: 'reportsPresets',
      desc: '',
      args: [],
    );
  }

  /// `Scegli periodo`
  String get reportsPresetCustom {
    return Intl.message(
      'Scegli periodo',
      name: 'reportsPresetCustom',
      desc: '',
      args: [],
    );
  }

  /// `Oggi`
  String get reportsPresetToday {
    return Intl.message('Oggi', name: 'reportsPresetToday', desc: '', args: []);
  }

  /// `Questa settimana`
  String get reportsPresetWeek {
    return Intl.message(
      'Questa settimana',
      name: 'reportsPresetWeek',
      desc: '',
      args: [],
    );
  }

  /// `Mese corrente`
  String get reportsPresetMonth {
    return Intl.message(
      'Mese corrente',
      name: 'reportsPresetMonth',
      desc: '',
      args: [],
    );
  }

  /// `Mese scorso`
  String get reportsPresetLastMonth {
    return Intl.message(
      'Mese scorso',
      name: 'reportsPresetLastMonth',
      desc: '',
      args: [],
    );
  }

  /// `Trimestre corrente`
  String get reportsPresetQuarter {
    return Intl.message(
      'Trimestre corrente',
      name: 'reportsPresetQuarter',
      desc: '',
      args: [],
    );
  }

  /// `Semestre corrente`
  String get reportsPresetSemester {
    return Intl.message(
      'Semestre corrente',
      name: 'reportsPresetSemester',
      desc: '',
      args: [],
    );
  }

  /// `Anno corrente`
  String get reportsPresetYear {
    return Intl.message(
      'Anno corrente',
      name: 'reportsPresetYear',
      desc: '',
      args: [],
    );
  }

  /// `Ultimi 3 mesi`
  String get reportsPresetLast3Months {
    return Intl.message(
      'Ultimi 3 mesi',
      name: 'reportsPresetLast3Months',
      desc: '',
      args: [],
    );
  }

  /// `Ultimi 6 mesi`
  String get reportsPresetLast6Months {
    return Intl.message(
      'Ultimi 6 mesi',
      name: 'reportsPresetLast6Months',
      desc: '',
      args: [],
    );
  }

  /// `Anno precedente`
  String get reportsPresetLastYear {
    return Intl.message(
      'Anno precedente',
      name: 'reportsPresetLastYear',
      desc: '',
      args: [],
    );
  }

  /// `Includi intero periodo (anche futuro)`
  String get reportsFullPeriodToggle {
    return Intl.message(
      'Includi intero periodo (anche futuro)',
      name: 'reportsFullPeriodToggle',
      desc: '',
      args: [],
    );
  }

  /// `Sedi`
  String get reportsFilterLocations {
    return Intl.message(
      'Sedi',
      name: 'reportsFilterLocations',
      desc: '',
      args: [],
    );
  }

  /// `Staff`
  String get reportsFilterStaff {
    return Intl.message(
      'Staff',
      name: 'reportsFilterStaff',
      desc: '',
      args: [],
    );
  }

  /// `Servizi`
  String get reportsFilterServices {
    return Intl.message(
      'Servizi',
      name: 'reportsFilterServices',
      desc: '',
      args: [],
    );
  }

  /// `Stato`
  String get reportsFilterStatus {
    return Intl.message(
      'Stato',
      name: 'reportsFilterStatus',
      desc: '',
      args: [],
    );
  }

  /// `Confermato`
  String get statusConfirmed {
    return Intl.message(
      'Confermato',
      name: 'statusConfirmed',
      desc: '',
      args: [],
    );
  }

  /// `Completato`
  String get statusCompleted {
    return Intl.message(
      'Completato',
      name: 'statusCompleted',
      desc: '',
      args: [],
    );
  }

  /// `Cancellato`
  String get statusCancelled {
    return Intl.message(
      'Cancellato',
      name: 'statusCancelled',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona tutti`
  String get actionSelectAll {
    return Intl.message(
      'Seleziona tutti',
      name: 'actionSelectAll',
      desc: '',
      args: [],
    );
  }

  /// `Deseleziona tutti`
  String get actionDeselectAll {
    return Intl.message(
      'Deseleziona tutti',
      name: 'actionDeselectAll',
      desc: '',
      args: [],
    );
  }

  /// `Applica`
  String get actionApply {
    return Intl.message('Applica', name: 'actionApply', desc: '', args: []);
  }

  /// `Appuntamenti`
  String get reportsTotalAppointments {
    return Intl.message(
      'Appuntamenti',
      name: 'reportsTotalAppointments',
      desc: '',
      args: [],
    );
  }

  /// `Incasso`
  String get reportsTotalRevenue {
    return Intl.message(
      'Incasso',
      name: 'reportsTotalRevenue',
      desc: '',
      args: [],
    );
  }

  /// `Ore lavorate`
  String get reportsTotalHours {
    return Intl.message(
      'Ore lavorate',
      name: 'reportsTotalHours',
      desc: '',
      args: [],
    );
  }

  /// `Occupazione`
  String get reportsOccupancyPercentage {
    return Intl.message(
      'Occupazione',
      name: 'reportsOccupancyPercentage',
      desc: '',
      args: [],
    );
  }

  /// `Clienti unici`
  String get reportsUniqueClients {
    return Intl.message(
      'Clienti unici',
      name: 'reportsUniqueClients',
      desc: '',
      args: [],
    );
  }

  /// `Per operatore`
  String get reportsByStaff {
    return Intl.message(
      'Per operatore',
      name: 'reportsByStaff',
      desc: '',
      args: [],
    );
  }

  /// `Per sede`
  String get reportsByLocation {
    return Intl.message(
      'Per sede',
      name: 'reportsByLocation',
      desc: '',
      args: [],
    );
  }

  /// `Per servizio`
  String get reportsByService {
    return Intl.message(
      'Per servizio',
      name: 'reportsByService',
      desc: '',
      args: [],
    );
  }

  /// `Per giorno della settimana`
  String get reportsByDayOfWeek {
    return Intl.message(
      'Per giorno della settimana',
      name: 'reportsByDayOfWeek',
      desc: '',
      args: [],
    );
  }

  /// `Per periodo`
  String get reportsByPeriod {
    return Intl.message(
      'Per periodo',
      name: 'reportsByPeriod',
      desc: '',
      args: [],
    );
  }

  /// `Per fascia oraria`
  String get reportsByHour {
    return Intl.message(
      'Per fascia oraria',
      name: 'reportsByHour',
      desc: '',
      args: [],
    );
  }

  /// `Staff`
  String get reportsWorkHoursTitle {
    return Intl.message(
      'Staff',
      name: 'reportsWorkHoursTitle',
      desc: '',
      args: [],
    );
  }

  /// `Appuntamenti`
  String get reportsTabAppointments {
    return Intl.message(
      'Appuntamenti',
      name: 'reportsTabAppointments',
      desc: '',
      args: [],
    );
  }

  /// `Team`
  String get reportsTabStaff {
    return Intl.message('Team', name: 'reportsTabStaff', desc: '', args: []);
  }

  /// `Riepilogo ore programmate, lavorate e assenze`
  String get reportsWorkHoursSubtitle {
    return Intl.message(
      'Riepilogo ore programmate, lavorate e assenze',
      name: 'reportsWorkHoursSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Programmate`
  String get reportsWorkHoursScheduled {
    return Intl.message(
      'Programmate',
      name: 'reportsWorkHoursScheduled',
      desc: '',
      args: [],
    );
  }

  /// `Prenotate`
  String get reportsWorkHoursWorked {
    return Intl.message(
      'Prenotate',
      name: 'reportsWorkHoursWorked',
      desc: '',
      args: [],
    );
  }

  /// `Blocchi`
  String get reportsWorkHoursBlocked {
    return Intl.message(
      'Blocchi',
      name: 'reportsWorkHoursBlocked',
      desc: '',
      args: [],
    );
  }

  /// `Ferie/Assenze`
  String get reportsWorkHoursOff {
    return Intl.message(
      'Ferie/Assenze',
      name: 'reportsWorkHoursOff',
      desc: '',
      args: [],
    );
  }

  /// `Effettive`
  String get reportsWorkHoursAvailable {
    return Intl.message(
      'Effettive',
      name: 'reportsWorkHoursAvailable',
      desc: '',
      args: [],
    );
  }

  /// `Occupazione`
  String get reportsWorkHoursUtilization {
    return Intl.message(
      'Occupazione',
      name: 'reportsWorkHoursUtilization',
      desc: '',
      args: [],
    );
  }

  /// `Programmate`
  String get reportsColScheduledHours {
    return Intl.message(
      'Programmate',
      name: 'reportsColScheduledHours',
      desc: '',
      args: [],
    );
  }

  /// `Prenotate`
  String get reportsColWorkedHours {
    return Intl.message(
      'Prenotate',
      name: 'reportsColWorkedHours',
      desc: '',
      args: [],
    );
  }

  /// `Blocchi`
  String get reportsColBlockedHours {
    return Intl.message(
      'Blocchi',
      name: 'reportsColBlockedHours',
      desc: '',
      args: [],
    );
  }

  /// `Ferie/Assenze`
  String get reportsColOffHours {
    return Intl.message(
      'Ferie/Assenze',
      name: 'reportsColOffHours',
      desc: '',
      args: [],
    );
  }

  /// `Effettive`
  String get reportsColAvailableHours {
    return Intl.message(
      'Effettive',
      name: 'reportsColAvailableHours',
      desc: '',
      args: [],
    );
  }

  /// `Occupazione`
  String get reportsColUtilization {
    return Intl.message(
      'Occupazione',
      name: 'reportsColUtilization',
      desc: '',
      args: [],
    );
  }

  /// `Operatore`
  String get reportsColStaff {
    return Intl.message(
      'Operatore',
      name: 'reportsColStaff',
      desc: '',
      args: [],
    );
  }

  /// `Appuntamenti`
  String get reportsColAppointments {
    return Intl.message(
      'Appuntamenti',
      name: 'reportsColAppointments',
      desc: '',
      args: [],
    );
  }

  /// `Incasso`
  String get reportsColRevenue {
    return Intl.message(
      'Incasso',
      name: 'reportsColRevenue',
      desc: '',
      args: [],
    );
  }

  /// `Ore`
  String get reportsColHours {
    return Intl.message('Ore', name: 'reportsColHours', desc: '', args: []);
  }

  /// `Media`
  String get reportsColAvgRevenue {
    return Intl.message(
      'Media',
      name: 'reportsColAvgRevenue',
      desc: '',
      args: [],
    );
  }

  /// `%`
  String get reportsColPercentage {
    return Intl.message('%', name: 'reportsColPercentage', desc: '', args: []);
  }

  /// `Sede`
  String get reportsColLocation {
    return Intl.message('Sede', name: 'reportsColLocation', desc: '', args: []);
  }

  /// `Servizio`
  String get reportsColService {
    return Intl.message(
      'Servizio',
      name: 'reportsColService',
      desc: '',
      args: [],
    );
  }

  /// `Categoria`
  String get reportsColCategory {
    return Intl.message(
      'Categoria',
      name: 'reportsColCategory',
      desc: '',
      args: [],
    );
  }

  /// `Durata media`
  String get reportsColAvgDuration {
    return Intl.message(
      'Durata media',
      name: 'reportsColAvgDuration',
      desc: '',
      args: [],
    );
  }

  /// `Giorno`
  String get reportsColDay {
    return Intl.message('Giorno', name: 'reportsColDay', desc: '', args: []);
  }

  /// `Periodo`
  String get reportsColPeriod {
    return Intl.message(
      'Periodo',
      name: 'reportsColPeriod',
      desc: '',
      args: [],
    );
  }

  /// `Ora`
  String get reportsColHour {
    return Intl.message('Ora', name: 'reportsColHour', desc: '', args: []);
  }

  /// `Luned√¨`
  String get dayMonday {
    return Intl.message('Luned√¨', name: 'dayMonday', desc: '', args: []);
  }

  /// `Marted√¨`
  String get dayTuesday {
    return Intl.message('Marted√¨', name: 'dayTuesday', desc: '', args: []);
  }

  /// `Mercoled√¨`
  String get dayWednesday {
    return Intl.message('Mercoled√¨', name: 'dayWednesday', desc: '', args: []);
  }

  /// `Gioved√¨`
  String get dayThursday {
    return Intl.message('Gioved√¨', name: 'dayThursday', desc: '', args: []);
  }

  /// `Venerd√¨`
  String get dayFriday {
    return Intl.message('Venerd√¨', name: 'dayFriday', desc: '', args: []);
  }

  /// `Sabato`
  String get daySaturday {
    return Intl.message('Sabato', name: 'daySaturday', desc: '', args: []);
  }

  /// `Domenica`
  String get daySunday {
    return Intl.message('Domenica', name: 'daySunday', desc: '', args: []);
  }

  /// `Risorse richieste`
  String get serviceRequiredResourcesLabel {
    return Intl.message(
      'Risorse richieste',
      name: 'serviceRequiredResourcesLabel',
      desc: '',
      args: [],
    );
  }

  /// `Nessuna risorsa richiesta`
  String get resourceNoneLabel {
    return Intl.message(
      'Nessuna risorsa richiesta',
      name: 'resourceNoneLabel',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona risorse`
  String get resourceSelectLabel {
    return Intl.message(
      'Seleziona risorse',
      name: 'resourceSelectLabel',
      desc: '',
      args: [],
    );
  }

  /// `Risorse`
  String get resourcesTitle {
    return Intl.message('Risorse', name: 'resourcesTitle', desc: '', args: []);
  }

  /// `Nessuna risorsa configurata per questa sede`
  String get resourcesEmpty {
    return Intl.message(
      'Nessuna risorsa configurata per questa sede',
      name: 'resourcesEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Le risorse sono attrezzature o spazi (es. cabine, lettini) che possono essere associati ai servizi`
  String get resourcesEmptyHint {
    return Intl.message(
      'Le risorse sono attrezzature o spazi (es. cabine, lettini) che possono essere associati ai servizi',
      name: 'resourcesEmptyHint',
      desc: '',
      args: [],
    );
  }

  /// `Nuova risorsa`
  String get resourceNew {
    return Intl.message(
      'Nuova risorsa',
      name: 'resourceNew',
      desc: '',
      args: [],
    );
  }

  /// `Modifica risorsa`
  String get resourceEdit {
    return Intl.message(
      'Modifica risorsa',
      name: 'resourceEdit',
      desc: '',
      args: [],
    );
  }

  /// `Nome risorsa`
  String get resourceNameLabel {
    return Intl.message(
      'Nome risorsa',
      name: 'resourceNameLabel',
      desc: '',
      args: [],
    );
  }

  /// `Quantit√† disponibile`
  String get resourceQuantityLabel {
    return Intl.message(
      'Quantit√† disponibile',
      name: 'resourceQuantityLabel',
      desc: '',
      args: [],
    );
  }

  /// `Tipo (opzionale)`
  String get resourceTypeLabel {
    return Intl.message(
      'Tipo (opzionale)',
      name: 'resourceTypeLabel',
      desc: '',
      args: [],
    );
  }

  /// `Note (opzionale)`
  String get resourceNoteLabel {
    return Intl.message(
      'Note (opzionale)',
      name: 'resourceNoteLabel',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare questa risorsa?`
  String get resourceDeleteConfirm {
    return Intl.message(
      'Eliminare questa risorsa?',
      name: 'resourceDeleteConfirm',
      desc: '',
      args: [],
    );
  }

  /// `I servizi che usano questa risorsa non saranno pi√π vincolati alla sua disponibilit√†`
  String get resourceDeleteWarning {
    return Intl.message(
      'I servizi che usano questa risorsa non saranno pi√π vincolati alla sua disponibilit√†',
      name: 'resourceDeleteWarning',
      desc: '',
      args: [],
    );
  }

  /// `Servizi che usano questa risorsa`
  String get resourceServicesLabel {
    return Intl.message(
      'Servizi che usano questa risorsa',
      name: 'resourceServicesLabel',
      desc: '',
      args: [],
    );
  }

  /// `Nessun servizio associato`
  String get resourceNoServicesSelected {
    return Intl.message(
      'Nessun servizio associato',
      name: 'resourceNoServicesSelected',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona servizi`
  String get resourceSelectServices {
    return Intl.message(
      'Seleziona servizi',
      name: 'resourceSelectServices',
      desc: '',
      args: [],
    );
  }

  /// `1 servizio`
  String get resourceServiceCountSingular {
    return Intl.message(
      '1 servizio',
      name: 'resourceServiceCountSingular',
      desc: '',
      args: [],
    );
  }

  /// `{count} servizi`
  String resourceServiceCountPlural(int count) {
    return Intl.message(
      '$count servizi',
      name: 'resourceServiceCountPlural',
      desc: '',
      args: [count],
    );
  }

  /// `Qt√† richiesta`
  String get resourceQuantityRequired {
    return Intl.message(
      'Qt√† richiesta',
      name: 'resourceQuantityRequired',
      desc: '',
      args: [],
    );
  }

  /// `Elenco Prenotazioni`
  String get bookingsListTitle {
    return Intl.message(
      'Elenco Prenotazioni',
      name: 'bookingsListTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessuna prenotazione trovata`
  String get bookingsListEmpty {
    return Intl.message(
      'Nessuna prenotazione trovata',
      name: 'bookingsListEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Prova a modificare i filtri di ricerca`
  String get bookingsListEmptyHint {
    return Intl.message(
      'Prova a modificare i filtri di ricerca',
      name: 'bookingsListEmptyHint',
      desc: '',
      args: [],
    );
  }

  /// `Filtri`
  String get bookingsListFilterTitle {
    return Intl.message(
      'Filtri',
      name: 'bookingsListFilterTitle',
      desc: '',
      args: [],
    );
  }

  /// `Sede`
  String get bookingsListFilterLocation {
    return Intl.message(
      'Sede',
      name: 'bookingsListFilterLocation',
      desc: '',
      args: [],
    );
  }

  /// `Operatore`
  String get bookingsListFilterStaff {
    return Intl.message(
      'Operatore',
      name: 'bookingsListFilterStaff',
      desc: '',
      args: [],
    );
  }

  /// `Servizio`
  String get bookingsListFilterService {
    return Intl.message(
      'Servizio',
      name: 'bookingsListFilterService',
      desc: '',
      args: [],
    );
  }

  /// `Cerca cliente`
  String get bookingsListFilterClient {
    return Intl.message(
      'Cerca cliente',
      name: 'bookingsListFilterClient',
      desc: '',
      args: [],
    );
  }

  /// `Nome, email o telefono`
  String get bookingsListFilterClientHint {
    return Intl.message(
      'Nome, email o telefono',
      name: 'bookingsListFilterClientHint',
      desc: '',
      args: [],
    );
  }

  /// `Stato`
  String get bookingsListFilterStatus {
    return Intl.message(
      'Stato',
      name: 'bookingsListFilterStatus',
      desc: '',
      args: [],
    );
  }

  /// `Periodo`
  String get bookingsListFilterPeriod {
    return Intl.message(
      'Periodo',
      name: 'bookingsListFilterPeriod',
      desc: '',
      args: [],
    );
  }

  /// `Includi passati`
  String get bookingsListFilterIncludePast {
    return Intl.message(
      'Includi passati',
      name: 'bookingsListFilterIncludePast',
      desc: '',
      args: [],
    );
  }

  /// `Solo futuri`
  String get bookingsListFilterFutureOnly {
    return Intl.message(
      'Solo futuri',
      name: 'bookingsListFilterFutureOnly',
      desc: '',
      args: [],
    );
  }

  /// `Data appuntamento`
  String get bookingsListSortByAppointment {
    return Intl.message(
      'Data appuntamento',
      name: 'bookingsListSortByAppointment',
      desc: '',
      args: [],
    );
  }

  /// `Data creazione`
  String get bookingsListSortByCreated {
    return Intl.message(
      'Data creazione',
      name: 'bookingsListSortByCreated',
      desc: '',
      args: [],
    );
  }

  /// `Crescente`
  String get bookingsListSortAsc {
    return Intl.message(
      'Crescente',
      name: 'bookingsListSortAsc',
      desc: '',
      args: [],
    );
  }

  /// `Decrescente`
  String get bookingsListSortDesc {
    return Intl.message(
      'Decrescente',
      name: 'bookingsListSortDesc',
      desc: '',
      args: [],
    );
  }

  /// `Data/Ora`
  String get bookingsListColumnDateTime {
    return Intl.message(
      'Data/Ora',
      name: 'bookingsListColumnDateTime',
      desc: '',
      args: [],
    );
  }

  /// `Creato il`
  String get bookingsListColumnCreatedAt {
    return Intl.message(
      'Creato il',
      name: 'bookingsListColumnCreatedAt',
      desc: '',
      args: [],
    );
  }

  /// `Creato da`
  String get bookingsListColumnCreatedBy {
    return Intl.message(
      'Creato da',
      name: 'bookingsListColumnCreatedBy',
      desc: '',
      args: [],
    );
  }

  /// `Cliente`
  String get bookingsListColumnClient {
    return Intl.message(
      'Cliente',
      name: 'bookingsListColumnClient',
      desc: '',
      args: [],
    );
  }

  /// `Servizi`
  String get bookingsListColumnServices {
    return Intl.message(
      'Servizi',
      name: 'bookingsListColumnServices',
      desc: '',
      args: [],
    );
  }

  /// `Operatore`
  String get bookingsListColumnStaff {
    return Intl.message(
      'Operatore',
      name: 'bookingsListColumnStaff',
      desc: '',
      args: [],
    );
  }

  /// `Stato`
  String get bookingsListColumnStatus {
    return Intl.message(
      'Stato',
      name: 'bookingsListColumnStatus',
      desc: '',
      args: [],
    );
  }

  /// `Prezzo`
  String get bookingsListColumnPrice {
    return Intl.message(
      'Prezzo',
      name: 'bookingsListColumnPrice',
      desc: '',
      args: [],
    );
  }

  /// `Azioni`
  String get bookingsListColumnActions {
    return Intl.message(
      'Azioni',
      name: 'bookingsListColumnActions',
      desc: '',
      args: [],
    );
  }

  /// `Modifica`
  String get bookingsListActionEdit {
    return Intl.message(
      'Modifica',
      name: 'bookingsListActionEdit',
      desc: '',
      args: [],
    );
  }

  /// `Cancella`
  String get bookingsListActionCancel {
    return Intl.message(
      'Cancella',
      name: 'bookingsListActionCancel',
      desc: '',
      args: [],
    );
  }

  /// `Dettagli`
  String get bookingsListActionView {
    return Intl.message(
      'Dettagli',
      name: 'bookingsListActionView',
      desc: '',
      args: [],
    );
  }

  /// `Confermato`
  String get bookingsListStatusConfirmed {
    return Intl.message(
      'Confermato',
      name: 'bookingsListStatusConfirmed',
      desc: '',
      args: [],
    );
  }

  /// `Cancellato`
  String get bookingsListStatusCancelled {
    return Intl.message(
      'Cancellato',
      name: 'bookingsListStatusCancelled',
      desc: '',
      args: [],
    );
  }

  /// `Completato`
  String get bookingsListStatusCompleted {
    return Intl.message(
      'Completato',
      name: 'bookingsListStatusCompleted',
      desc: '',
      args: [],
    );
  }

  /// `No show`
  String get bookingsListStatusNoShow {
    return Intl.message(
      'No show',
      name: 'bookingsListStatusNoShow',
      desc: '',
      args: [],
    );
  }

  /// `In attesa`
  String get bookingsListStatusPending {
    return Intl.message(
      'In attesa',
      name: 'bookingsListStatusPending',
      desc: '',
      args: [],
    );
  }

  /// `Sostituito`
  String get bookingsListStatusReplaced {
    return Intl.message(
      'Sostituito',
      name: 'bookingsListStatusReplaced',
      desc: '',
      args: [],
    );
  }

  /// `Online`
  String get bookingsListSourceOnline {
    return Intl.message(
      'Online',
      name: 'bookingsListSourceOnline',
      desc: '',
      args: [],
    );
  }

  /// `Telefono`
  String get bookingsListSourcePhone {
    return Intl.message(
      'Telefono',
      name: 'bookingsListSourcePhone',
      desc: '',
      args: [],
    );
  }

  /// `Walk-in`
  String get bookingsListSourceWalkIn {
    return Intl.message(
      'Walk-in',
      name: 'bookingsListSourceWalkIn',
      desc: '',
      args: [],
    );
  }

  /// `Gestionale`
  String get bookingsListSourceInternal {
    return Intl.message(
      'Gestionale',
      name: 'bookingsListSourceInternal',
      desc: '',
      args: [],
    );
  }

  /// `{count} prenotazioni`
  String bookingsListTotalCount(int count) {
    return Intl.message(
      '$count prenotazioni',
      name: 'bookingsListTotalCount',
      desc: '',
      args: [count],
    );
  }

  /// `Carica altre`
  String get bookingsListLoadMore {
    return Intl.message(
      'Carica altre',
      name: 'bookingsListLoadMore',
      desc: '',
      args: [],
    );
  }

  /// `Reset filtri`
  String get bookingsListResetFilters {
    return Intl.message(
      'Reset filtri',
      name: 'bookingsListResetFilters',
      desc: '',
      args: [],
    );
  }

  /// `Tutte le sedi`
  String get bookingsListAllLocations {
    return Intl.message(
      'Tutte le sedi',
      name: 'bookingsListAllLocations',
      desc: '',
      args: [],
    );
  }

  /// `Tutti gli operatori`
  String get bookingsListAllStaff {
    return Intl.message(
      'Tutti gli operatori',
      name: 'bookingsListAllStaff',
      desc: '',
      args: [],
    );
  }

  /// `Tutti i servizi`
  String get bookingsListAllServices {
    return Intl.message(
      'Tutti i servizi',
      name: 'bookingsListAllServices',
      desc: '',
      args: [],
    );
  }

  /// `Tutti gli stati`
  String get bookingsListAllStatus {
    return Intl.message(
      'Tutti gli stati',
      name: 'bookingsListAllStatus',
      desc: '',
      args: [],
    );
  }

  /// `Cancellare prenotazione?`
  String get bookingsListCancelConfirmTitle {
    return Intl.message(
      'Cancellare prenotazione?',
      name: 'bookingsListCancelConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `Questa azione non pu√≤ essere annullata.`
  String get bookingsListCancelConfirmMessage {
    return Intl.message(
      'Questa azione non pu√≤ essere annullata.',
      name: 'bookingsListCancelConfirmMessage',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione cancellata`
  String get bookingsListCancelSuccess {
    return Intl.message(
      'Prenotazione cancellata',
      name: 'bookingsListCancelSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Caricamento...`
  String get bookingsListLoading {
    return Intl.message(
      'Caricamento...',
      name: 'bookingsListLoading',
      desc: '',
      args: [],
    );
  }

  /// `Nessun cliente`
  String get bookingsListNoClient {
    return Intl.message(
      'Nessun cliente',
      name: 'bookingsListNoClient',
      desc: '',
      args: [],
    );
  }

  /// `Gestisci i servizi offerti, categorie e listini`
  String get moreServicesDescription {
    return Intl.message(
      'Gestisci i servizi offerti, categorie e listini',
      name: 'moreServicesDescription',
      desc: '',
      args: [],
    );
  }

  /// `Gestisci operatori, sedi e orari di lavoro`
  String get moreTeamDescription {
    return Intl.message(
      'Gestisci operatori, sedi e orari di lavoro',
      name: 'moreTeamDescription',
      desc: '',
      args: [],
    );
  }

  /// `Visualizza statistiche e andamento attivit√†`
  String get moreReportsDescription {
    return Intl.message(
      'Visualizza statistiche e andamento attivit√†',
      name: 'moreReportsDescription',
      desc: '',
      args: [],
    );
  }

  /// `Consulta lo storico delle prenotazioni`
  String get moreBookingsDescription {
    return Intl.message(
      'Consulta lo storico delle prenotazioni',
      name: 'moreBookingsDescription',
      desc: '',
      args: [],
    );
  }

  /// `Visualizza lo storico delle notifiche prenotazioni`
  String get moreBookingNotificationsDescription {
    return Intl.message(
      'Visualizza lo storico delle notifiche prenotazioni',
      name: 'moreBookingNotificationsDescription',
      desc: '',
      args: [],
    );
  }

  /// `Gestisci i tuoi dati personali e le credenziali`
  String get moreProfileDescription {
    return Intl.message(
      'Gestisci i tuoi dati personali e le credenziali',
      name: 'moreProfileDescription',
      desc: '',
      args: [],
    );
  }

  /// `Passa a un altro business`
  String get moreSwitchBusinessDescription {
    return Intl.message(
      'Passa a un altro business',
      name: 'moreSwitchBusinessDescription',
      desc: '',
      args: [],
    );
  }

  /// `Notifiche Prenotazioni`
  String get bookingNotificationsTitle {
    return Intl.message(
      'Notifiche Prenotazioni',
      name: 'bookingNotificationsTitle',
      desc: '',
      args: [],
    );
  }

  /// `{count} notifiche`
  String bookingNotificationsTotalCount(int count) {
    return Intl.message(
      '$count notifiche',
      name: 'bookingNotificationsTotalCount',
      desc: '',
      args: [count],
    );
  }

  /// `Nessuna notifica trovata`
  String get bookingNotificationsEmpty {
    return Intl.message(
      'Nessuna notifica trovata',
      name: 'bookingNotificationsEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Prova a modificare i filtri di ricerca`
  String get bookingNotificationsEmptyHint {
    return Intl.message(
      'Prova a modificare i filtri di ricerca',
      name: 'bookingNotificationsEmptyHint',
      desc: '',
      args: [],
    );
  }

  /// `Carica altre`
  String get bookingNotificationsLoadMore {
    return Intl.message(
      'Carica altre',
      name: 'bookingNotificationsLoadMore',
      desc: '',
      args: [],
    );
  }

  /// `Cerca`
  String get bookingNotificationsSearchLabel {
    return Intl.message(
      'Cerca',
      name: 'bookingNotificationsSearchLabel',
      desc: '',
      args: [],
    );
  }

  /// `Cliente, destinatario, oggetto`
  String get bookingNotificationsSearchHint {
    return Intl.message(
      'Cliente, destinatario, oggetto',
      name: 'bookingNotificationsSearchHint',
      desc: '',
      args: [],
    );
  }

  /// `Stato`
  String get bookingNotificationsFilterStatus {
    return Intl.message(
      'Stato',
      name: 'bookingNotificationsFilterStatus',
      desc: '',
      args: [],
    );
  }

  /// `Tipo`
  String get bookingNotificationsFilterType {
    return Intl.message(
      'Tipo',
      name: 'bookingNotificationsFilterType',
      desc: '',
      args: [],
    );
  }

  /// `Tutti gli stati`
  String get bookingNotificationsStatusAll {
    return Intl.message(
      'Tutti gli stati',
      name: 'bookingNotificationsStatusAll',
      desc: '',
      args: [],
    );
  }

  /// `In coda`
  String get bookingNotificationsStatusPending {
    return Intl.message(
      'In coda',
      name: 'bookingNotificationsStatusPending',
      desc: '',
      args: [],
    );
  }

  /// `In elaborazione`
  String get bookingNotificationsStatusProcessing {
    return Intl.message(
      'In elaborazione',
      name: 'bookingNotificationsStatusProcessing',
      desc: '',
      args: [],
    );
  }

  /// `Inviata`
  String get bookingNotificationsStatusSent {
    return Intl.message(
      'Inviata',
      name: 'bookingNotificationsStatusSent',
      desc: '',
      args: [],
    );
  }

  /// `Fallita`
  String get bookingNotificationsStatusFailed {
    return Intl.message(
      'Fallita',
      name: 'bookingNotificationsStatusFailed',
      desc: '',
      args: [],
    );
  }

  /// `Tutti i tipi`
  String get bookingNotificationsTypeAll {
    return Intl.message(
      'Tutti i tipi',
      name: 'bookingNotificationsTypeAll',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione creata`
  String get bookingNotificationsChannelConfirmed {
    return Intl.message(
      'Prenotazione creata',
      name: 'bookingNotificationsChannelConfirmed',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione riprogrammata`
  String get bookingNotificationsChannelRescheduled {
    return Intl.message(
      'Prenotazione riprogrammata',
      name: 'bookingNotificationsChannelRescheduled',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione annullata`
  String get bookingNotificationsChannelCancelled {
    return Intl.message(
      'Prenotazione annullata',
      name: 'bookingNotificationsChannelCancelled',
      desc: '',
      args: [],
    );
  }

  /// `Promemoria prenotazione`
  String get bookingNotificationsChannelReminder {
    return Intl.message(
      'Promemoria prenotazione',
      name: 'bookingNotificationsChannelReminder',
      desc: '',
      args: [],
    );
  }

  /// `Tipo`
  String get bookingNotificationsFieldType {
    return Intl.message(
      'Tipo',
      name: 'bookingNotificationsFieldType',
      desc: '',
      args: [],
    );
  }

  /// `Cliente`
  String get bookingNotificationsFieldClient {
    return Intl.message(
      'Cliente',
      name: 'bookingNotificationsFieldClient',
      desc: '',
      args: [],
    );
  }

  /// `Sede`
  String get bookingNotificationsFieldLocation {
    return Intl.message(
      'Sede',
      name: 'bookingNotificationsFieldLocation',
      desc: '',
      args: [],
    );
  }

  /// `Appuntamento`
  String get bookingNotificationsFieldAppointment {
    return Intl.message(
      'Appuntamento',
      name: 'bookingNotificationsFieldAppointment',
      desc: '',
      args: [],
    );
  }

  /// `Destinatario`
  String get bookingNotificationsFieldRecipient {
    return Intl.message(
      'Destinatario',
      name: 'bookingNotificationsFieldRecipient',
      desc: '',
      args: [],
    );
  }

  /// `Creata il`
  String get bookingNotificationsFieldCreatedAt {
    return Intl.message(
      'Creata il',
      name: 'bookingNotificationsFieldCreatedAt',
      desc: '',
      args: [],
    );
  }

  /// `Inviata il`
  String get bookingNotificationsFieldSentAt {
    return Intl.message(
      'Inviata il',
      name: 'bookingNotificationsFieldSentAt',
      desc: '',
      args: [],
    );
  }

  /// `Errore`
  String get bookingNotificationsFieldError {
    return Intl.message(
      'Errore',
      name: 'bookingNotificationsFieldError',
      desc: '',
      args: [],
    );
  }

  /// `Nessun oggetto`
  String get bookingNotificationsNoSubject {
    return Intl.message(
      'Nessun oggetto',
      name: 'bookingNotificationsNoSubject',
      desc: '',
      args: [],
    );
  }

  /// `N/D`
  String get bookingNotificationsNotAvailable {
    return Intl.message(
      'N/D',
      name: 'bookingNotificationsNotAvailable',
      desc: '',
      args: [],
    );
  }

  /// `Email Notifiche Prenotazioni Online`
  String get businessOnlineBookingsNotificationEmailLabel {
    return Intl.message(
      'Email Notifiche Prenotazioni Online',
      name: 'businessOnlineBookingsNotificationEmailLabel',
      desc: '',
      args: [],
    );
  }

  /// `es. prenotazioni@salone.it`
  String get businessOnlineBookingsNotificationEmailHint {
    return Intl.message(
      'es. prenotazioni@salone.it',
      name: 'businessOnlineBookingsNotificationEmailHint',
      desc: '',
      args: [],
    );
  }

  /// `Riceve notifiche solo per prenotazioni eseguite dal cliente`
  String get businessOnlineBookingsNotificationEmailHelper {
    return Intl.message(
      'Riceve notifiche solo per prenotazioni eseguite dal cliente',
      name: 'businessOnlineBookingsNotificationEmailHelper',
      desc: '',
      args: [],
    );
  }

  /// `Palette colori servizi`
  String get businessServiceColorPaletteLabel {
    return Intl.message(
      'Palette colori servizi',
      name: 'businessServiceColorPaletteLabel',
      desc: '',
      args: [],
    );
  }

  /// `Definisce i colori usati nella selezione servizi e nelle card agenda`
  String get businessServiceColorPaletteHelper {
    return Intl.message(
      'Definisce i colori usati nella selezione servizi e nelle card agenda',
      name: 'businessServiceColorPaletteHelper',
      desc: '',
      args: [],
    );
  }

  /// `Scura (consigliata)`
  String get businessServiceColorPaletteEnhanced {
    return Intl.message(
      'Scura (consigliata)',
      name: 'businessServiceColorPaletteEnhanced',
      desc: '',
      args: [],
    );
  }

  /// `Originale`
  String get businessServiceColorPaletteLegacy {
    return Intl.message(
      'Originale',
      name: 'businessServiceColorPaletteLegacy',
      desc: '',
      args: [],
    );
  }

  /// `Accedi alle altre funzionalit√† dell'applicazione`
  String get moreSubtitle {
    return Intl.message(
      'Accedi alle altre funzionalit√† dell\'applicazione',
      name: 'moreSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Date di chiusura`
  String get closuresTitle {
    return Intl.message(
      'Date di chiusura',
      name: 'closuresTitle',
      desc: '',
      args: [],
    );
  }

  /// `A partire da oggi`
  String get closuresFilterFromToday {
    return Intl.message(
      'A partire da oggi',
      name: 'closuresFilterFromToday',
      desc: '',
      args: [],
    );
  }

  /// `Tutti`
  String get closuresFilterAll {
    return Intl.message('Tutti', name: 'closuresFilterAll', desc: '', args: []);
  }

  /// `Nessuna chiusura programmata`
  String get closuresEmpty {
    return Intl.message(
      'Nessuna chiusura programmata',
      name: 'closuresEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Nessuna chiusura programmata per il periodo selezionato`
  String get closuresEmptyForPeriod {
    return Intl.message(
      'Nessuna chiusura programmata per il periodo selezionato',
      name: 'closuresEmptyForPeriod',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi i periodi di chiusura dell'attivit√† (es. festivit√†, ferie)`
  String get closuresEmptyHint {
    return Intl.message(
      'Aggiungi i periodi di chiusura dell\'attivit√† (es. festivit√†, ferie)',
      name: 'closuresEmptyHint',
      desc: '',
      args: [],
    );
  }

  /// `Prossime chiusure`
  String get closuresUpcoming {
    return Intl.message(
      'Prossime chiusure',
      name: 'closuresUpcoming',
      desc: '',
      args: [],
    );
  }

  /// `Chiusure precedenti`
  String get closuresPast {
    return Intl.message(
      'Chiusure precedenti',
      name: 'closuresPast',
      desc: '',
      args: [],
    );
  }

  /// `per un totale di {count, plural, =1{1 giorno} other{{count} giorni}}`
  String closuresTotalDays(int count) {
    return Intl.message(
      'per un totale di ${Intl.plural(count, one: '1 giorno', other: '$count giorni')}',
      name: 'closuresTotalDays',
      desc: '',
      args: [count],
    );
  }

  /// `Nuova chiusura`
  String get closuresNewTitle {
    return Intl.message(
      'Nuova chiusura',
      name: 'closuresNewTitle',
      desc: '',
      args: [],
    );
  }

  /// `Modifica chiusura`
  String get closuresEditTitle {
    return Intl.message(
      'Modifica chiusura',
      name: 'closuresEditTitle',
      desc: '',
      args: [],
    );
  }

  /// `Data inizio`
  String get closuresStartDate {
    return Intl.message(
      'Data inizio',
      name: 'closuresStartDate',
      desc: '',
      args: [],
    );
  }

  /// `Data fine`
  String get closuresEndDate {
    return Intl.message(
      'Data fine',
      name: 'closuresEndDate',
      desc: '',
      args: [],
    );
  }

  /// `Motivo (opzionale)`
  String get closuresReason {
    return Intl.message(
      'Motivo (opzionale)',
      name: 'closuresReason',
      desc: '',
      args: [],
    );
  }

  /// `es. Festivit√†, Ferie estive, Manutenzione...`
  String get closuresReasonHint {
    return Intl.message(
      'es. Festivit√†, Ferie estive, Manutenzione...',
      name: 'closuresReasonHint',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare questa chiusura?`
  String get closuresDeleteConfirm {
    return Intl.message(
      'Eliminare questa chiusura?',
      name: 'closuresDeleteConfirm',
      desc: '',
      args: [],
    );
  }

  /// `Gli slot di prenotazione in questo periodo torneranno disponibili.`
  String get closuresDeleteConfirmMessage {
    return Intl.message(
      'Gli slot di prenotazione in questo periodo torneranno disponibili.',
      name: 'closuresDeleteConfirmMessage',
      desc: '',
      args: [],
    );
  }

  /// `Le date si sovrappongono con un'altra chiusura esistente`
  String get closuresOverlapError {
    return Intl.message(
      'Le date si sovrappongono con un\'altra chiusura esistente',
      name: 'closuresOverlapError',
      desc: '',
      args: [],
    );
  }

  /// `La data di fine deve essere uguale o successiva alla data di inizio`
  String get closuresInvalidDateRange {
    return Intl.message(
      'La data di fine deve essere uguale o successiva alla data di inizio',
      name: 'closuresInvalidDateRange',
      desc: '',
      args: [],
    );
  }

  /// `{count, plural, =1{1 giorno} other{{count} giorni}}`
  String closuresDays(int count) {
    return Intl.plural(
      count,
      one: '1 giorno',
      other: '$count giorni',
      name: 'closuresDays',
      desc: '',
      args: [count],
    );
  }

  /// `Giorno singolo`
  String get closuresSingleDay {
    return Intl.message(
      'Giorno singolo',
      name: 'closuresSingleDay',
      desc: '',
      args: [],
    );
  }

  /// `Periodo`
  String get closuresDateRange {
    return Intl.message(
      'Periodo',
      name: 'closuresDateRange',
      desc: '',
      args: [],
    );
  }

  /// `Chiusura aggiunta`
  String get closuresAddSuccess {
    return Intl.message(
      'Chiusura aggiunta',
      name: 'closuresAddSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Chiusura aggiornata`
  String get closuresUpdateSuccess {
    return Intl.message(
      'Chiusura aggiornata',
      name: 'closuresUpdateSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Chiusura eliminata`
  String get closuresDeleteSuccess {
    return Intl.message(
      'Chiusura eliminata',
      name: 'closuresDeleteSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Sedi interessate`
  String get closuresLocations {
    return Intl.message(
      'Sedi interessate',
      name: 'closuresLocations',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona tutte`
  String get closuresSelectAll {
    return Intl.message(
      'Seleziona tutte',
      name: 'closuresSelectAll',
      desc: '',
      args: [],
    );
  }

  /// `Deseleziona tutte`
  String get closuresDeselectAll {
    return Intl.message(
      'Deseleziona tutte',
      name: 'closuresDeselectAll',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona almeno una sede`
  String get closuresSelectAtLeastOneLocation {
    return Intl.message(
      'Seleziona almeno una sede',
      name: 'closuresSelectAtLeastOneLocation',
      desc: '',
      args: [],
    );
  }

  /// `Nessuna sede configurata`
  String get closuresNoLocations {
    return Intl.message(
      'Nessuna sede configurata',
      name: 'closuresNoLocations',
      desc: '',
      args: [],
    );
  }

  /// `Tutte le sedi`
  String get closuresAllLocations {
    return Intl.message(
      'Tutte le sedi',
      name: 'closuresAllLocations',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi chiusura`
  String get closuresAddButton {
    return Intl.message(
      'Aggiungi chiusura',
      name: 'closuresAddButton',
      desc: '',
      args: [],
    );
  }

  /// `Importa festivit√†`
  String get closuresImportHolidays {
    return Intl.message(
      'Importa festivit√†',
      name: 'closuresImportHolidays',
      desc: '',
      args: [],
    );
  }

  /// `Importa festivit√† nazionali`
  String get closuresImportHolidaysTitle {
    return Intl.message(
      'Importa festivit√† nazionali',
      name: 'closuresImportHolidaysTitle',
      desc: '',
      args: [],
    );
  }

  /// `Anno:`
  String get closuresImportHolidaysYear {
    return Intl.message(
      'Anno:',
      name: 'closuresImportHolidaysYear',
      desc: '',
      args: [],
    );
  }

  /// `Applica alle sedi:`
  String get closuresImportHolidaysLocations {
    return Intl.message(
      'Applica alle sedi:',
      name: 'closuresImportHolidaysLocations',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona le festivit√† da importare:`
  String get closuresImportHolidaysList {
    return Intl.message(
      'Seleziona le festivit√† da importare:',
      name: 'closuresImportHolidaysList',
      desc: '',
      args: [],
    );
  }

  /// `Importa {count, plural, =1{1 festivit√†} other{{count} festivit√†}}`
  String closuresImportHolidaysAction(int count) {
    return Intl.message(
      'Importa ${Intl.plural(count, one: '1 festivit√†', other: '$count festivit√†')}',
      name: 'closuresImportHolidaysAction',
      desc: '',
      args: [count],
    );
  }

  /// `{count, plural, =1{1 festivit√† importata} other{{count} festivit√† importate}}`
  String closuresImportHolidaysSuccess(int count) {
    return Intl.plural(
      count,
      one: '1 festivit√† importata',
      other: '$count festivit√† importate',
      name: 'closuresImportHolidaysSuccess',
      desc: '',
      args: [count],
    );
  }

  /// `{count, plural, =1{1 festivit√† gi√† presente} other{{count} festivit√† gi√† presenti}} (contrassegnate con ‚úì)`
  String closuresImportHolidaysAlreadyAdded(int count) {
    return Intl.message(
      '${Intl.plural(count, one: '1 festivit√† gi√† presente', other: '$count festivit√† gi√† presenti')} (contrassegnate con ‚úì)',
      name: 'closuresImportHolidaysAlreadyAdded',
      desc: '',
      args: [count],
    );
  }

  /// `Le festivit√† automatiche non sono disponibili per il paese configurato nella sede.`
  String get closuresImportHolidaysUnsupportedCountry {
    return Intl.message(
      'Le festivit√† automatiche non sono disponibili per il paese configurato nella sede.',
      name: 'closuresImportHolidaysUnsupportedCountry',
      desc: '',
      args: [],
    );
  }

  /// `Nessuna classe nel giorno selezionato.`
  String get classEventsEmpty {
    return Intl.message(
      'Nessuna classe nel giorno selezionato.',
      name: 'classEventsEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Classi`
  String get classEventsTitle {
    return Intl.message('Classi', name: 'classEventsTitle', desc: '', args: []);
  }

  /// `Classe`
  String get classEventsUntitled {
    return Intl.message(
      'Classe',
      name: 'classEventsUntitled',
      desc: '',
      args: [],
    );
  }

  /// `Prenota`
  String get classEventsActionBook {
    return Intl.message(
      'Prenota',
      name: 'classEventsActionBook',
      desc: '',
      args: [],
    );
  }

  /// `Annulla prenotazione`
  String get classEventsActionCancelBooking {
    return Intl.message(
      'Annulla prenotazione',
      name: 'classEventsActionCancelBooking',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi`
  String get classEventsAddButton {
    return Intl.message(
      'Aggiungi',
      name: 'classEventsAddButton',
      desc: '',
      args: [],
    );
  }

  /// `Programmazione`
  String get classEventsCreateTitle {
    return Intl.message(
      'Programmazione',
      name: 'classEventsCreateTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nuova programmazione`
  String get classEventsNewScheduleButton {
    return Intl.message(
      'Nuova programmazione',
      name: 'classEventsNewScheduleButton',
      desc: '',
      args: [],
    );
  }

  /// `Modifica programmazione`
  String get classEventsEditTitle {
    return Intl.message(
      'Modifica programmazione',
      name: 'classEventsEditTitle',
      desc: '',
      args: [],
    );
  }

  /// `Modalit√† modifica`
  String get classEventsEditModeLabel {
    return Intl.message(
      'Modalit√† modifica',
      name: 'classEventsEditModeLabel',
      desc: '',
      args: [],
    );
  }

  /// `Titolo (opzionale)`
  String get classEventsFieldTitleOptional {
    return Intl.message(
      'Titolo (opzionale)',
      name: 'classEventsFieldTitleOptional',
      desc: '',
      args: [],
    );
  }

  /// `Tipo classe`
  String get classEventsFieldClassType {
    return Intl.message(
      'Tipo classe',
      name: 'classEventsFieldClassType',
      desc: '',
      args: [],
    );
  }

  /// `Sede`
  String get classEventsFieldLocation {
    return Intl.message(
      'Sede',
      name: 'classEventsFieldLocation',
      desc: '',
      args: [],
    );
  }

  /// `Staff`
  String get classEventsFieldStaff {
    return Intl.message(
      'Staff',
      name: 'classEventsFieldStaff',
      desc: '',
      args: [],
    );
  }

  /// `Data`
  String get classEventsFieldDate {
    return Intl.message(
      'Data',
      name: 'classEventsFieldDate',
      desc: '',
      args: [],
    );
  }

  /// `Ora inizio`
  String get classEventsFieldStartTime {
    return Intl.message(
      'Ora inizio',
      name: 'classEventsFieldStartTime',
      desc: '',
      args: [],
    );
  }

  /// `Ora fine`
  String get classEventsFieldEndTime {
    return Intl.message(
      'Ora fine',
      name: 'classEventsFieldEndTime',
      desc: '',
      args: [],
    );
  }

  /// `Ripeti programmazione`
  String get classEventsRepeatSchedule {
    return Intl.message(
      'Ripeti programmazione',
      name: 'classEventsRepeatSchedule',
      desc: '',
      args: [],
    );
  }

  /// `Non crea programmazioni se ci sono sovrapposizioni`
  String get classEventsRecurrenceConflictSkipDescription {
    return Intl.message(
      'Non crea programmazioni se ci sono sovrapposizioni',
      name: 'classEventsRecurrenceConflictSkipDescription',
      desc: '',
      args: [],
    );
  }

  /// `Crea le programmazioni anche se ci sono sovrapposizioni`
  String get classEventsRecurrenceConflictForceDescription {
    return Intl.message(
      'Crea le programmazioni anche se ci sono sovrapposizioni',
      name: 'classEventsRecurrenceConflictForceDescription',
      desc: '',
      args: [],
    );
  }

  /// `Anteprima programmazioni`
  String get classEventsRecurrencePreviewTitle {
    return Intl.message(
      'Anteprima programmazioni',
      name: 'classEventsRecurrencePreviewTitle',
      desc: '',
      args: [],
    );
  }

  /// `Deseleziona le programmazioni che non vuoi creare`
  String get classEventsRecurrencePreviewHint {
    return Intl.message(
      'Deseleziona le programmazioni che non vuoi creare',
      name: 'classEventsRecurrencePreviewHint',
      desc: '',
      args: [],
    );
  }

  /// `Crea {count} programmazioni`
  String classEventsRecurrencePreviewConfirm(int count) {
    return Intl.message(
      'Crea $count programmazioni',
      name: 'classEventsRecurrencePreviewConfirm',
      desc: '',
      args: [count],
    );
  }

  /// `Capienza`
  String get classEventsFieldCapacity {
    return Intl.message(
      'Capienza',
      name: 'classEventsFieldCapacity',
      desc: '',
      args: [],
    );
  }

  /// `Nessuna sede abilitata per questo tipo classe`
  String get classEventsNoLocationsForClassType {
    return Intl.message(
      'Nessuna sede abilitata per questo tipo classe',
      name: 'classEventsNoLocationsForClassType',
      desc: '',
      args: [],
    );
  }

  /// `Compila tutti i campi obbligatori`
  String get classEventsValidationRequired {
    return Intl.message(
      'Compila tutti i campi obbligatori',
      name: 'classEventsValidationRequired',
      desc: '',
      args: [],
    );
  }

  /// `L'ora di fine deve essere successiva all'ora di inizio`
  String get classEventsValidationEndAfterStart {
    return Intl.message(
      'L\'ora di fine deve essere successiva all\'ora di inizio',
      name: 'classEventsValidationEndAfterStart',
      desc: '',
      args: [],
    );
  }

  /// `Nessun tipo classe disponibile`
  String get classEventsNoClassTypes {
    return Intl.message(
      'Nessun tipo classe disponibile',
      name: 'classEventsNoClassTypes',
      desc: '',
      args: [],
    );
  }

  /// `Nessuno staff disponibile per la sede selezionata`
  String get classEventsNoStaffForLocation {
    return Intl.message(
      'Nessuno staff disponibile per la sede selezionata',
      name: 'classEventsNoStaffForLocation',
      desc: '',
      args: [],
    );
  }

  /// `Programmazioni esistenti`
  String get classEventsSchedulesListTitle {
    return Intl.message(
      'Programmazioni esistenti',
      name: 'classEventsSchedulesListTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessuna programmazione`
  String get classEventsSchedulesListEmpty {
    return Intl.message(
      'Nessuna programmazione',
      name: 'classEventsSchedulesListEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Future`
  String get classEventsFutureBadge {
    return Intl.message(
      'Future',
      name: 'classEventsFutureBadge',
      desc: '',
      args: [],
    );
  }

  /// `Scadute`
  String get classEventsExpiredBadge {
    return Intl.message(
      'Scadute',
      name: 'classEventsExpiredBadge',
      desc: '',
      args: [],
    );
  }

  /// `Mostra anche scadute`
  String get classEventsShowExpiredSchedules {
    return Intl.message(
      'Mostra anche scadute',
      name: 'classEventsShowExpiredSchedules',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare la programmazione?`
  String get classEventsSchedulesDeleteConfirmTitle {
    return Intl.message(
      'Eliminare la programmazione?',
      name: 'classEventsSchedulesDeleteConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `Eliminando la programmazione verranno eliminate anche le eventuali prenotazioni esistenti.`
  String get classEventsSchedulesDeleteConfirmMessage {
    return Intl.message(
      'Eliminando la programmazione verranno eliminate anche le eventuali prenotazioni esistenti.',
      name: 'classEventsSchedulesDeleteConfirmMessage',
      desc: '',
      args: [],
    );
  }

  /// `Programmazione eliminata`
  String get classEventsSchedulesDeleteSuccessTitle {
    return Intl.message(
      'Programmazione eliminata',
      name: 'classEventsSchedulesDeleteSuccessTitle',
      desc: '',
      args: [],
    );
  }

  /// `La programmazione e le prenotazioni collegate sono state eliminate`
  String get classEventsSchedulesDeleteSuccessMessage {
    return Intl.message(
      'La programmazione e le prenotazioni collegate sono state eliminate',
      name: 'classEventsSchedulesDeleteSuccessMessage',
      desc: '',
      args: [],
    );
  }

  /// `Programmazione aggiornata`
  String get classEventsSchedulesUpdateSuccessTitle {
    return Intl.message(
      'Programmazione aggiornata',
      name: 'classEventsSchedulesUpdateSuccessTitle',
      desc: '',
      args: [],
    );
  }

  /// `La programmazione √® stata aggiornata correttamente`
  String get classEventsSchedulesUpdateSuccessMessage {
    return Intl.message(
      'La programmazione √® stata aggiornata correttamente',
      name: 'classEventsSchedulesUpdateSuccessMessage',
      desc: '',
      args: [],
    );
  }

  /// `Classe creata`
  String get classEventsCreateSuccessTitle {
    return Intl.message(
      'Classe creata',
      name: 'classEventsCreateSuccessTitle',
      desc: '',
      args: [],
    );
  }

  /// `La classe √® stata creata correttamente`
  String get classEventsCreateSuccessMessage {
    return Intl.message(
      'La classe √® stata creata correttamente',
      name: 'classEventsCreateSuccessMessage',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile creare la classe`
  String get classEventsCreateErrorMessage {
    return Intl.message(
      'Impossibile creare la classe',
      name: 'classEventsCreateErrorMessage',
      desc: '',
      args: [],
    );
  }

  /// `Tipi classe`
  String get classTypesManageButton {
    return Intl.message(
      'Tipi classe',
      name: 'classTypesManageButton',
      desc: '',
      args: [],
    );
  }

  /// `Gestione tipi classe`
  String get classTypesManageTitle {
    return Intl.message(
      'Gestione tipi classe',
      name: 'classTypesManageTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo tipo`
  String get classTypesAddButton {
    return Intl.message(
      'Nuovo tipo',
      name: 'classTypesAddButton',
      desc: '',
      args: [],
    );
  }

  /// `Nessun tipo classe configurato`
  String get classTypesEmpty {
    return Intl.message(
      'Nessun tipo classe configurato',
      name: 'classTypesEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Attivo`
  String get classTypesStatusActive {
    return Intl.message(
      'Attivo',
      name: 'classTypesStatusActive',
      desc: '',
      args: [],
    );
  }

  /// `Non attivo`
  String get classTypesStatusInactive {
    return Intl.message(
      'Non attivo',
      name: 'classTypesStatusInactive',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo tipo classe`
  String get classTypesCreateTitle {
    return Intl.message(
      'Nuovo tipo classe',
      name: 'classTypesCreateTitle',
      desc: '',
      args: [],
    );
  }

  /// `Modifica tipo classe`
  String get classTypesEditTitle {
    return Intl.message(
      'Modifica tipo classe',
      name: 'classTypesEditTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nome`
  String get classTypesFieldName {
    return Intl.message(
      'Nome',
      name: 'classTypesFieldName',
      desc: '',
      args: [],
    );
  }

  /// `Descrizione (opzionale)`
  String get classTypesFieldDescriptionOptional {
    return Intl.message(
      'Descrizione (opzionale)',
      name: 'classTypesFieldDescriptionOptional',
      desc: '',
      args: [],
    );
  }

  /// `Tipo attivo`
  String get classTypesFieldIsActive {
    return Intl.message(
      'Tipo attivo',
      name: 'classTypesFieldIsActive',
      desc: '',
      args: [],
    );
  }

  /// `Tipo classe creato`
  String get classTypesCreateSuccessTitle {
    return Intl.message(
      'Tipo classe creato',
      name: 'classTypesCreateSuccessTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il tipo classe √® stato creato correttamente`
  String get classTypesCreateSuccessMessage {
    return Intl.message(
      'Il tipo classe √® stato creato correttamente',
      name: 'classTypesCreateSuccessMessage',
      desc: '',
      args: [],
    );
  }

  /// `Tipo classe aggiornato`
  String get classTypesUpdateSuccessTitle {
    return Intl.message(
      'Tipo classe aggiornato',
      name: 'classTypesUpdateSuccessTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il tipo classe √® stato aggiornato correttamente`
  String get classTypesUpdateSuccessMessage {
    return Intl.message(
      'Il tipo classe √® stato aggiornato correttamente',
      name: 'classTypesUpdateSuccessMessage',
      desc: '',
      args: [],
    );
  }

  /// `Programmazione`
  String get classTypesActionScheduleClass {
    return Intl.message(
      'Programmazione',
      name: 'classTypesActionScheduleClass',
      desc: '',
      args: [],
    );
  }

  /// `Duplica`
  String get classTypesActionClone {
    return Intl.message(
      'Duplica',
      name: 'classTypesActionClone',
      desc: '',
      args: [],
    );
  }

  /// `Cancella`
  String get classTypesActionDeactivate {
    return Intl.message(
      'Cancella',
      name: 'classTypesActionDeactivate',
      desc: '',
      args: [],
    );
  }

  /// `Riattiva`
  String get classTypesActionReactivate {
    return Intl.message(
      'Riattiva',
      name: 'classTypesActionReactivate',
      desc: '',
      args: [],
    );
  }

  /// `Copia`
  String get classTypesCloneSuffix {
    return Intl.message(
      'Copia',
      name: 'classTypesCloneSuffix',
      desc: '',
      args: [],
    );
  }

  /// `Tipo classe duplicato`
  String get classTypesCloneSuccessTitle {
    return Intl.message(
      'Tipo classe duplicato',
      name: 'classTypesCloneSuccessTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il tipo classe √® stato duplicato correttamente`
  String get classTypesCloneSuccessMessage {
    return Intl.message(
      'Il tipo classe √® stato duplicato correttamente',
      name: 'classTypesCloneSuccessMessage',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare il tipo classe?`
  String get classTypesDeleteConfirmTitle {
    return Intl.message(
      'Eliminare il tipo classe?',
      name: 'classTypesDeleteConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `Questa azione elimina definitivamente il tipo classe.`
  String get classTypesDeleteConfirmMessage {
    return Intl.message(
      'Questa azione elimina definitivamente il tipo classe.',
      name: 'classTypesDeleteConfirmMessage',
      desc: '',
      args: [],
    );
  }

  /// `Tipo classe eliminato`
  String get classTypesDeleteSuccessTitle {
    return Intl.message(
      'Tipo classe eliminato',
      name: 'classTypesDeleteSuccessTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il tipo classe √® stato eliminato`
  String get classTypesDeleteSuccessMessage {
    return Intl.message(
      'Il tipo classe √® stato eliminato',
      name: 'classTypesDeleteSuccessMessage',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile eliminare il tipo classe perch√© esistono programmazioni associate`
  String get classTypesDeleteInUseErrorMessage {
    return Intl.message(
      'Impossibile eliminare il tipo classe perch√© esistono programmazioni associate',
      name: 'classTypesDeleteInUseErrorMessage',
      desc: '',
      args: [],
    );
  }

  /// `Cancellare il tipo classe?`
  String get classTypesDeactivateConfirmTitle {
    return Intl.message(
      'Cancellare il tipo classe?',
      name: 'classTypesDeactivateConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il tipo classe verr√† disattivato e non sar√† selezionabile per nuove programmazioni.`
  String get classTypesDeactivateConfirmMessage {
    return Intl.message(
      'Il tipo classe verr√† disattivato e non sar√† selezionabile per nuove programmazioni.',
      name: 'classTypesDeactivateConfirmMessage',
      desc: '',
      args: [],
    );
  }

  /// `Riattivare il tipo classe?`
  String get classTypesReactivateConfirmTitle {
    return Intl.message(
      'Riattivare il tipo classe?',
      name: 'classTypesReactivateConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il tipo classe torner√† disponibile per nuove programmazioni.`
  String get classTypesReactivateConfirmMessage {
    return Intl.message(
      'Il tipo classe torner√† disponibile per nuove programmazioni.',
      name: 'classTypesReactivateConfirmMessage',
      desc: '',
      args: [],
    );
  }

  /// `Tipo classe cancellato`
  String get classTypesDeactivateSuccessTitle {
    return Intl.message(
      'Tipo classe cancellato',
      name: 'classTypesDeactivateSuccessTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il tipo classe √® stato disattivato`
  String get classTypesDeactivateSuccessMessage {
    return Intl.message(
      'Il tipo classe √® stato disattivato',
      name: 'classTypesDeactivateSuccessMessage',
      desc: '',
      args: [],
    );
  }

  /// `Tipo classe riattivato`
  String get classTypesReactivateSuccessTitle {
    return Intl.message(
      'Tipo classe riattivato',
      name: 'classTypesReactivateSuccessTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il tipo classe √® stato riattivato`
  String get classTypesReactivateSuccessMessage {
    return Intl.message(
      'Il tipo classe √® stato riattivato',
      name: 'classTypesReactivateSuccessMessage',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile salvare il tipo classe`
  String get classTypesMutationErrorMessage {
    return Intl.message(
      'Impossibile salvare il tipo classe',
      name: 'classTypesMutationErrorMessage',
      desc: '',
      args: [],
    );
  }

  /// `Partecipanti`
  String get classEventsParticipantsTitle {
    return Intl.message(
      'Partecipanti',
      name: 'classEventsParticipantsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Confermati: {confirmed}/{capacity} ‚Ä¢ Lista attesa: {waitlist}`
  String classEventsCapacitySummary(int confirmed, int capacity, int waitlist) {
    return Intl.message(
      'Confermati: $confirmed/$capacity ‚Ä¢ Lista attesa: $waitlist',
      name: 'classEventsCapacitySummary',
      desc: '',
      args: [confirmed, capacity, waitlist],
    );
  }

  /// `Cliente {customerId}`
  String classEventsParticipantCustomer(int customerId) {
    return Intl.message(
      'Cliente $customerId',
      name: 'classEventsParticipantCustomer',
      desc: '',
      args: [customerId],
    );
  }

  /// `CRM`
  String get crmTitle {
    return Intl.message('CRM', name: 'crmTitle', desc: '', args: []);
  }

  /// `Gestione clienti avanzata, segmenti, task e privacy`
  String get crmSubtitle {
    return Intl.message(
      'Gestione clienti avanzata, segmenti, task e privacy',
      name: 'crmSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Clienti CRM`
  String get crmClientsTitle {
    return Intl.message(
      'Clienti CRM',
      name: 'crmClientsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Vista cliente 360 con KPI e timeline`
  String get crmClientsDescription {
    return Intl.message(
      'Vista cliente 360 con KPI e timeline',
      name: 'crmClientsDescription',
      desc: '',
      args: [],
    );
  }

  /// `Segmenti`
  String get crmSegmentsTitle {
    return Intl.message(
      'Segmenti',
      name: 'crmSegmentsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Liste dinamiche clienti con filtri salvati`
  String get crmSegmentsDescription {
    return Intl.message(
      'Liste dinamiche clienti con filtri salvati',
      name: 'crmSegmentsDescription',
      desc: '',
      args: [],
    );
  }

  /// `Task`
  String get crmTasksTitle {
    return Intl.message('Task', name: 'crmTasksTitle', desc: '', args: []);
  }

  /// `Follow-up staff e attivit√† in ritardo`
  String get crmTasksDescription {
    return Intl.message(
      'Follow-up staff e attivit√† in ritardo',
      name: 'crmTasksDescription',
      desc: '',
      args: [],
    );
  }

  /// `Tag`
  String get crmTagsTitle {
    return Intl.message('Tag', name: 'crmTagsTitle', desc: '', args: []);
  }

  /// `Gestione tag centralizzata clienti`
  String get crmTagsDescription {
    return Intl.message(
      'Gestione tag centralizzata clienti',
      name: 'crmTagsDescription',
      desc: '',
      args: [],
    );
  }

  /// `Import / Export`
  String get crmImportExportTitle {
    return Intl.message(
      'Import / Export',
      name: 'crmImportExportTitle',
      desc: '',
      args: [],
    );
  }

  /// `Import CSV con preview e export segmenti`
  String get crmImportExportDescription {
    return Intl.message(
      'Import CSV con preview e export segmenti',
      name: 'crmImportExportDescription',
      desc: '',
      args: [],
    );
  }

  /// `Cerca per nome, email, telefono, citt√†...`
  String get crmSearchHint {
    return Intl.message(
      'Cerca per nome, email, telefono, citt√†...',
      name: 'crmSearchHint',
      desc: '',
      args: [],
    );
  }

  /// `Tutti`
  String get crmFilterAll {
    return Intl.message('Tutti', name: 'crmFilterAll', desc: '', args: []);
  }

  /// `Lead`
  String get crmStatusLead {
    return Intl.message('Lead', name: 'crmStatusLead', desc: '', args: []);
  }

  /// `Attivo`
  String get crmStatusActive {
    return Intl.message('Attivo', name: 'crmStatusActive', desc: '', args: []);
  }

  /// `Inattivo`
  String get crmStatusInactive {
    return Intl.message(
      'Inattivo',
      name: 'crmStatusInactive',
      desc: '',
      args: [],
    );
  }

  /// `Perso`
  String get crmStatusLost {
    return Intl.message('Perso', name: 'crmStatusLost', desc: '', args: []);
  }

  /// `Nessun cliente trovato`
  String get crmClientsEmpty {
    return Intl.message(
      'Nessun cliente trovato',
      name: 'crmClientsEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Carica altri`
  String get crmLoadMore {
    return Intl.message(
      'Carica altri',
      name: 'crmLoadMore',
      desc: '',
      args: [],
    );
  }

  /// `{count} visite`
  String crmVisitsLabel(int count) {
    return Intl.message(
      '$count visite',
      name: 'crmVisitsLabel',
      desc: '',
      args: [count],
    );
  }

  /// `Archivia`
  String get crmArchiveAction {
    return Intl.message(
      'Archivia',
      name: 'crmArchiveAction',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo cliente CRM`
  String get crmCreateClientTitle {
    return Intl.message(
      'Nuovo cliente CRM',
      name: 'crmCreateClientTitle',
      desc: '',
      args: [],
    );
  }

  /// `Dettaglio cliente`
  String get crmClientDetailTitle {
    return Intl.message(
      'Dettaglio cliente',
      name: 'crmClientDetailTitle',
      desc: '',
      args: [],
    );
  }

  /// `Overview`
  String get crmOverviewTab {
    return Intl.message('Overview', name: 'crmOverviewTab', desc: '', args: []);
  }

  /// `Timeline`
  String get crmTimelineTab {
    return Intl.message('Timeline', name: 'crmTimelineTab', desc: '', args: []);
  }

  /// `Prenotazioni`
  String get crmBookingsTab {
    return Intl.message(
      'Prenotazioni',
      name: 'crmBookingsTab',
      desc: '',
      args: [],
    );
  }

  /// `Task`
  String get crmTasksTab {
    return Intl.message('Task', name: 'crmTasksTab', desc: '', args: []);
  }

  /// `Contatti`
  String get crmContactsTab {
    return Intl.message('Contatti', name: 'crmContactsTab', desc: '', args: []);
  }

  /// `Loyalty`
  String get crmLoyaltyTab {
    return Intl.message('Loyalty', name: 'crmLoyaltyTab', desc: '', args: []);
  }

  /// `GDPR`
  String get crmGdprTab {
    return Intl.message('GDPR', name: 'crmGdprTab', desc: '', args: []);
  }

  /// `Cronologia prenotazioni disponibile nella vista cliente esistente`
  String get crmBookingsReuseHint {
    return Intl.message(
      'Cronologia prenotazioni disponibile nella vista cliente esistente',
      name: 'crmBookingsReuseHint',
      desc: '',
      args: [],
    );
  }

  /// `Completa`
  String get crmTaskComplete {
    return Intl.message(
      'Completa',
      name: 'crmTaskComplete',
      desc: '',
      args: [],
    );
  }

  /// `Riapri`
  String get crmTaskReopen {
    return Intl.message('Riapri', name: 'crmTaskReopen', desc: '', args: []);
  }

  /// `Nessun task in ritardo`
  String get crmTasksEmpty {
    return Intl.message(
      'Nessun task in ritardo',
      name: 'crmTasksEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Saldo punti: {points}`
  String crmLoyaltyPoints(String points) {
    return Intl.message(
      'Saldo punti: $points',
      name: 'crmLoyaltyPoints',
      desc: '',
      args: [points],
    );
  }

  /// `Visite`
  String get crmKpiVisits {
    return Intl.message('Visite', name: 'crmKpiVisits', desc: '', args: []);
  }

  /// `Spesa totale`
  String get crmKpiSpent {
    return Intl.message(
      'Spesa totale',
      name: 'crmKpiSpent',
      desc: '',
      args: [],
    );
  }

  /// `Scontrino medio`
  String get crmKpiAvgTicket {
    return Intl.message(
      'Scontrino medio',
      name: 'crmKpiAvgTicket',
      desc: '',
      args: [],
    );
  }

  /// `No-show`
  String get crmKpiNoShow {
    return Intl.message('No-show', name: 'crmKpiNoShow', desc: '', args: []);
  }

  /// `GDPR Delete`
  String get crmGdprDeleteTitle {
    return Intl.message(
      'GDPR Delete',
      name: 'crmGdprDeleteTitle',
      desc: '',
      args: [],
    );
  }

  /// `Confermi anonimizzazione e archiviazione del cliente?`
  String get crmGdprDeleteConfirm {
    return Intl.message(
      'Confermi anonimizzazione e archiviazione del cliente?',
      name: 'crmGdprDeleteConfirm',
      desc: '',
      args: [],
    );
  }

  /// `Cliente anonimizzato correttamente`
  String get crmGdprDeleted {
    return Intl.message(
      'Cliente anonimizzato correttamente',
      name: 'crmGdprDeleted',
      desc: '',
      args: [],
    );
  }

  /// `Nessun tag`
  String get crmTagsEmpty {
    return Intl.message('Nessun tag', name: 'crmTagsEmpty', desc: '', args: []);
  }

  /// `Tag eliminato`
  String get crmTagDeleted {
    return Intl.message(
      'Tag eliminato',
      name: 'crmTagDeleted',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo tag`
  String get crmCreateTagTitle {
    return Intl.message(
      'Nuovo tag',
      name: 'crmCreateTagTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nome tag`
  String get crmTagNameLabel {
    return Intl.message(
      'Nome tag',
      name: 'crmTagNameLabel',
      desc: '',
      args: [],
    );
  }

  /// `Colore (hex)`
  String get crmTagColorLabel {
    return Intl.message(
      'Colore (hex)',
      name: 'crmTagColorLabel',
      desc: '',
      args: [],
    );
  }

  /// `Nessun segmento`
  String get crmSegmentsEmpty {
    return Intl.message(
      'Nessun segmento',
      name: 'crmSegmentsEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Segmento eliminato`
  String get crmSegmentDeleted {
    return Intl.message(
      'Segmento eliminato',
      name: 'crmSegmentDeleted',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo segmento`
  String get crmCreateSegmentTitle {
    return Intl.message(
      'Nuovo segmento',
      name: 'crmCreateSegmentTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nome segmento`
  String get crmSegmentNameLabel {
    return Intl.message(
      'Nome segmento',
      name: 'crmSegmentNameLabel',
      desc: '',
      args: [],
    );
  }

  /// `Query ricerca (q)`
  String get crmSegmentQueryLabel {
    return Intl.message(
      'Query ricerca (q)',
      name: 'crmSegmentQueryLabel',
      desc: '',
      args: [],
    );
  }

  /// `Import CSV`
  String get crmImportCsvTitle {
    return Intl.message(
      'Import CSV',
      name: 'crmImportCsvTitle',
      desc: '',
      args: [],
    );
  }

  /// `Incolla il CSV con header: first_name,last_name,email,phone,city,notes,source`
  String get crmImportCsvHint {
    return Intl.message(
      'Incolla il CSV con header: first_name,last_name,email,phone,city,notes,source',
      name: 'crmImportCsvHint',
      desc: '',
      args: [],
    );
  }

  /// `Dry-run preview`
  String get crmImportPreview {
    return Intl.message(
      'Dry-run preview',
      name: 'crmImportPreview',
      desc: '',
      args: [],
    );
  }

  /// `Commit import`
  String get crmImportCommit {
    return Intl.message(
      'Commit import',
      name: 'crmImportCommit',
      desc: '',
      args: [],
    );
  }

  /// `Export CSV`
  String get crmExportCsvTitle {
    return Intl.message(
      'Export CSV',
      name: 'crmExportCsvTitle',
      desc: '',
      args: [],
    );
  }

  /// `Copia CSV negli appunti`
  String get crmExportCsvButton {
    return Intl.message(
      'Copia CSV negli appunti',
      name: 'crmExportCsvButton',
      desc: '',
      args: [],
    );
  }

  /// `CSV copiato negli appunti`
  String get crmExportCopied {
    return Intl.message(
      'CSV copiato negli appunti',
      name: 'crmExportCopied',
      desc: '',
      args: [],
    );
  }
}

class AppLocalizationDelegate extends LocalizationsDelegate<L10n> {
  const AppLocalizationDelegate();

  List<Locale> get supportedLocales {
    return const <Locale>[
      Locale.fromSubtags(languageCode: 'it'),
      Locale.fromSubtags(languageCode: 'en'),
    ];
  }

  @override
  bool isSupported(Locale locale) => _isSupported(locale);
  @override
  Future<L10n> load(Locale locale) => L10n.load(locale);
  @override
  bool shouldReload(AppLocalizationDelegate old) => false;

  bool _isSupported(Locale locale) {
    for (var supportedLocale in supportedLocales) {
      if (supportedLocale.languageCode == locale.languageCode) {
        return true;
      }
    }
    return false;
  }
}
--- FILE: lib/core/network/token_storage_mobile.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

import 'token_storage_interface.dart';

/// Implementazione secure storage per mobile/desktop
class SecureTokenStorage implements TokenStorage {
  static const _refreshTokenKey = 'agenda_backend_refresh_token';

  final FlutterSecureStorage _storage;

  SecureTokenStorage()
    : _storage = const FlutterSecureStorage(
        aOptions: AndroidOptions(encryptedSharedPreferences: true),
        iOptions: IOSOptions(accessibility: KeychainAccessibility.first_unlock),
      );

  @override
  Future<String?> getRefreshToken() async {
    try {
      return await _storage.read(key: _refreshTokenKey);
    } catch (e) {
      debugPrint('TokenStorage: Error reading token: $e');
      return null;
    }
  }

  @override
  Future<void> saveRefreshToken(String token) async {
    try {
      await _storage.write(key: _refreshTokenKey, value: token);
    } catch (e) {
      debugPrint('TokenStorage: Error saving token: $e');
    }
  }

  @override
  Future<void> clearRefreshToken() async {
    try {
      await _storage.delete(key: _refreshTokenKey);
    } catch (e) {
      debugPrint('TokenStorage: Error clearing token: $e');
    }
  }
}

/// Factory per creare storage su mobile/desktop
TokenStorage createTokenStorage() => SecureTokenStorage();
--- FILE: lib/core/network/network_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import 'api_client.dart';
import 'token_storage.dart';

part 'network_providers.g.dart';

/// Provider per TokenStorage (singleton)
@Riverpod(keepAlive: true)
TokenStorage tokenStorage(Ref ref) {
  return createTokenStorage();
}

/// Provider per notificare quando la sessione √® scaduta.
/// I listener (es. AuthNotifier) possono reagire a questo evento.
final sessionExpiredProvider = NotifierProvider<SessionExpiredNotifier, int>(
  SessionExpiredNotifier.new,
);

/// Notifier che incrementa un contatore ogni volta che la sessione scade.
/// Gli observer possono fare ref.listen() su questo provider.
class SessionExpiredNotifier extends Notifier<int> {
  @override
  int build() => 0;

  void trigger() {
    state++;
  }
}

/// Provider per ApiClient (singleton)
@Riverpod(keepAlive: true)
ApiClient apiClient(Ref ref) {
  final storage = ref.watch(tokenStorageProvider);
  final sessionExpired = ref.read(sessionExpiredProvider.notifier);

  return ApiClient(
    tokenStorage: storage,
    onSessionExpired: () => sessionExpired.trigger(),
  );
}
--- FILE: lib/core/network/api_config.dart ---
/// Configurazione API per agenda_backend (gestionale)
class ApiConfig {
  /// Base URL dell'API - configurabile via environment
  static const String baseUrl = String.fromEnvironment(
    'API_BASE_URL',
    defaultValue: 'https://api.romeolab.it',
  );

  /// Location ID di default (per MVP single-location)
  static const int defaultLocationId = 1;

  /// Business ID di default
  static const int defaultBusinessId = 1;

  /// Timeout per le richieste
  static const Duration connectTimeout = Duration(seconds: 10);
  static const Duration receiveTimeout = Duration(seconds: 30);

  // ========== AUTH ENDPOINTS ==========
  static const String authLogin = '/v1/auth/login';
  static const String authRegister = '/v1/auth/register';
  static const String authRefresh = '/v1/auth/refresh';
  static const String authLogout = '/v1/auth/logout';
  static const String authForgotPassword = '/v1/auth/forgot-password';
  static const String authVerifyResetToken = '/v1/auth/verify-reset-token';
  static const String authResetPassword = '/v1/auth/reset-password';
  static const String authChangePassword = '/v1/me/change-password';
  static const String authMe = '/v1/me';

  // ========== PUBLIC BROWSE ENDPOINTS ==========
  static const String services = '/v1/services';
  static const String staff = '/v1/staff';
  static const String availability = '/v1/availability';

  /// Servizi pi√π prenotati per staff (gestionale)
  static String popularServices(int staffId) =>
      '/v1/staff/$staffId/services/popular';

  // ========== GESTIONALE ENDPOINTS ==========
  static const String clients = '/v1/clients';

  /// Appointments endpoint con location_id nel path
  static String appointments(int locationId) =>
      '/v1/locations/$locationId/appointments';

  /// Singolo appointment endpoint
  static String appointment(int locationId, int appointmentId) =>
      '/v1/locations/$locationId/appointments/$appointmentId';

  /// Cancel appointment endpoint
  static String appointmentCancel(int locationId, int appointmentId) =>
      '/v1/locations/$locationId/appointments/$appointmentId/cancel';

  /// Add item to existing booking endpoint
  static String bookingItems(int bookingId) => '/v1/bookings/$bookingId/items';

  /// Delete item from booking endpoint
  static String bookingItem(int bookingId, int itemId) =>
      '/v1/bookings/$bookingId/items/$itemId';

  /// Bookings endpoint con location_id nel path
  static String bookings(int locationId) =>
      '/v1/locations/$locationId/bookings';

  /// Singolo booking endpoint
  static String booking(int locationId, int bookingId) =>
      '/v1/locations/$locationId/bookings/$bookingId';

  /// Storico booking endpoint
  static String bookingHistory(int bookingId) =>
      '/v1/bookings/$bookingId/history';

  /// Lista bookings filtrata per business (gestionale)
  static String bookingsList(int businessId) =>
      '/v1/businesses/$businessId/bookings/list';

  /// Lista notifiche prenotazioni per business (gestionale)
  static String bookingNotifications(int businessId) =>
      '/v1/businesses/$businessId/booking-notifications';

  // ========== CLASS EVENTS ENDPOINTS ==========

  /// Lista class events per business.
  static String classEvents(int businessId) => '/v1/businesses/$businessId/class-events';

  /// Lista class types per business.
  static String classTypes(int businessId) => '/v1/businesses/$businessId/class-types';

  /// Singolo class type.
  static String classType(int businessId, int classTypeId) =>
      '/v1/businesses/$businessId/class-types/$classTypeId';

  /// Singolo class event.
  static String classEvent(int businessId, int classEventId) =>
      '/v1/businesses/$businessId/class-events/$classEventId';

  /// Prenotazione di un class event (customer/staff scoped endpoint).
  static String classEventBook(int businessId, int classEventId) =>
      '/v1/businesses/$businessId/class-events/$classEventId/book';

  /// Cancellazione prenotazione class event.
  static String classEventCancelBooking(int businessId, int classEventId) =>
      '/v1/businesses/$businessId/class-events/$classEventId/cancel-booking';

  /// Lista partecipanti class event.
  static String classEventParticipants(int businessId, int classEventId) =>
      '/v1/businesses/$businessId/class-events/$classEventId/participants';

  // ========== SERVICE PACKAGES ENDPOINTS ==========

  /// Lista pacchetti servizi per location
  static String servicePackages(int locationId) =>
      '/v1/locations/$locationId/service-packages';

  /// Singolo pacchetto servizi
  static String servicePackage(int locationId, int packageId) =>
      '/v1/locations/$locationId/service-packages/$packageId';

  /// Espansione pacchetto servizi
  static String servicePackageExpand(int locationId, int packageId) =>
      '/v1/locations/$locationId/service-packages/$packageId/expand';

  // ========== BUSINESS USERS (OPERATORS) ENDPOINTS ==========

  /// Lista operatori di un business
  static String businessUsers(int businessId) =>
      '/v1/businesses/$businessId/users';

  /// Singolo operatore
  static String businessUser(int businessId, int userId) =>
      '/v1/businesses/$businessId/users/$userId';

  // ========== BUSINESS INVITATIONS ENDPOINTS ==========

  /// Lista inviti pendenti di un business
  static String businessInvitations(int businessId) =>
      '/v1/businesses/$businessId/invitations';

  /// Singolo invito
  static String businessInvitation(int businessId, int invitationId) =>
      '/v1/businesses/$businessId/invitations/$invitationId';

  /// Dettagli invito pubblico (tramite token)
  static String invitationByToken(String token) => '/v1/invitations/$token';

  /// Accetta invito
  static String acceptInvitation(String token) =>
      '/v1/invitations/$token/accept';

  /// Accetta invito senza login (utente gi√† registrato)
  static String acceptInvitationPublic(String token) =>
      '/v1/invitations/$token/accept-public';

  /// Rifiuta invito
  static String declineInvitation(String token) =>
      '/v1/invitations/$token/decline';

  /// Registrazione account operatore da invito + accettazione
  static String registerInvitation(String token) =>
      '/v1/invitations/$token/register';

  // ========== STAFF PLANNING ENDPOINTS ==========

  /// Lista tutti i planning di uno staff
  static String staffPlannings(int staffId) => '/v1/staff/$staffId/plannings';

  /// Singolo planning (per update/delete)
  static String staffPlanning(int staffId, int planningId) =>
      '/v1/staff/$staffId/plannings/$planningId';

  /// Planning valido per una data
  static String staffPlanningForDate(int staffId) =>
      '/v1/staff/$staffId/planning';

  /// Slot disponibili per una data
  static String staffPlanningAvailability(int staffId) =>
      '/v1/staff/$staffId/planning-availability';
}
--- FILE: lib/core/network/network_providers.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'network_providers.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning
/// Provider per TokenStorage (singleton)

@ProviderFor(tokenStorage)
const tokenStorageProvider = TokenStorageProvider._();

/// Provider per TokenStorage (singleton)

final class TokenStorageProvider
    extends $FunctionalProvider<TokenStorage, TokenStorage, TokenStorage>
    with $Provider<TokenStorage> {
  /// Provider per TokenStorage (singleton)
  const TokenStorageProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'tokenStorageProvider',
        isAutoDispose: false,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$tokenStorageHash();

  @$internal
  @override
  $ProviderElement<TokenStorage> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  TokenStorage create(Ref ref) {
    return tokenStorage(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(TokenStorage value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<TokenStorage>(value),
    );
  }
}

String _$tokenStorageHash() => r'70b99b5c3abf97860696bdff48269108bd63321a';

/// Provider per ApiClient (singleton)

@ProviderFor(apiClient)
const apiClientProvider = ApiClientProvider._();

/// Provider per ApiClient (singleton)

final class ApiClientProvider
    extends $FunctionalProvider<ApiClient, ApiClient, ApiClient>
    with $Provider<ApiClient> {
  /// Provider per ApiClient (singleton)
  const ApiClientProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'apiClientProvider',
        isAutoDispose: false,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$apiClientHash();

  @$internal
  @override
  $ProviderElement<ApiClient> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  ApiClient create(Ref ref) {
    return apiClient(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(ApiClient value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<ApiClient>(value),
    );
  }
}

String _$apiClientHash() => r'7b32d09fb99a2585f8d2f97e67636976b66059ae';
--- FILE: lib/core/network/token_storage_web.dart ---
// ignore_for_file: avoid_web_libraries_in_flutter
import 'dart:html' as html;

import 'package:flutter/foundation.dart';

import 'token_storage_interface.dart';

/// Implementazione Web che usa localStorage
/// NOTA: In produzione si dovrebbe preferire cookie httpOnly server-side
class WebTokenStorage implements TokenStorage {
  static const _refreshTokenKey = 'agenda_backend_refresh_token';

  @override
  Future<String?> getRefreshToken() async {
    try {
      return html.window.localStorage[_refreshTokenKey];
    } catch (e) {
      debugPrint('TokenStorage: Error reading token from localStorage: $e');
      return null;
    }
  }

  @override
  Future<void> saveRefreshToken(String token) async {
    try {
      html.window.localStorage[_refreshTokenKey] = token;
    } catch (e) {
      debugPrint('TokenStorage: Error saving token to localStorage: $e');
    }
  }

  @override
  Future<void> clearRefreshToken() async {
    try {
      html.window.localStorage.remove(_refreshTokenKey);
    } catch (e) {
      debugPrint('TokenStorage: Error clearing token from localStorage: $e');
    }
  }
}

/// Factory per creare storage su Web
TokenStorage createTokenStorage() => WebTokenStorage();
--- FILE: lib/core/network/token_storage_interface.dart ---
/// Gestione storage per refresh token
/// - Web: localStorage (con considerazioni di sicurezza per production)
/// - Mobile: secure storage
abstract class TokenStorage {
  Future<String?> getRefreshToken();
  Future<void> saveRefreshToken(String token);
  Future<void> clearRefreshToken();
}
--- FILE: lib/core/network/api_client.dart ---
import 'dart:async';

import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';

import '/core/models/class_booking.dart';
import '/core/models/class_event.dart';
import '/core/models/class_type.dart';
import '/core/models/location_closure.dart';
import 'api_config.dart';
import 'token_storage.dart';

/// Eccezione API custom
class ApiException implements Exception {
  final String code;
  final String message;
  final int statusCode;
  final dynamic details;

  const ApiException({
    required this.code,
    required this.message,
    required this.statusCode,
    this.details,
  });

  bool get isUnauthorized => statusCode == 401;
  bool get isConflict => statusCode == 409;
  bool get isSlotConflict => code == 'slot_conflict';

  @override
  String toString() => 'ApiException($code): $message';
}

/// Client HTTP per comunicare con agenda_core API
/// Usato dal gestionale (agenda_backend)
class ApiClient {
  final Dio _dio;
  final TokenStorage _tokenStorage;
  final void Function()? onSessionExpired;

  String? _accessToken;
  bool _isRefreshing = false;
  final List<void Function()> _pendingRequests = [];

  ApiClient({
    required TokenStorage tokenStorage,
    Dio? dio,
    this.onSessionExpired,
  }) : _tokenStorage = tokenStorage,
       _dio = dio ?? Dio() {
    _dio.options.baseUrl = ApiConfig.baseUrl;
    _dio.options.connectTimeout = ApiConfig.connectTimeout;
    _dio.options.receiveTimeout = ApiConfig.receiveTimeout;
    _dio.options.headers['Content-Type'] = 'application/json';
    _dio.options.headers['Accept'] = 'application/json';

    // Interceptor per logging SOLO errori in debug
    if (kDebugMode) {
      _dio.interceptors.add(
        InterceptorsWrapper(
          onError: (error, handler) {
            debugPrint('*** DioException ***');
            debugPrint('uri: ${error.requestOptions.uri}');
            debugPrint('statusCode: ${error.response?.statusCode}');
            debugPrint('Response: ${error.response?.data}');
            debugPrint(
              'hasAuthHeader: ${error.requestOptions.headers.containsKey('Authorization')}',
            );
            debugPrint('errorType: ${error.type}');
            debugPrint('errorMessage: ${error.message}');
            handler.next(error);
          },
        ),
      );
    }

    // Interceptor per auth token
    _dio.interceptors.add(
      InterceptorsWrapper(
        onRequest: (options, handler) {
          if (_accessToken != null) {
            options.headers['Authorization'] = 'Bearer $_accessToken';
          }
          handler.next(options);
        },
        onError: (error, handler) async {
          // Gestione token expired - auto refresh con single-flight
          if (error.response?.statusCode == 401 &&
              error.response?.data?['error']?['code'] == 'token_expired') {
            try {
              final refreshed = await _refreshTokenWithLock();
              if (refreshed) {
                // Riprova la richiesta originale
                final opts = error.requestOptions;
                opts.headers['Authorization'] = 'Bearer $_accessToken';
                final response = await _dio.fetch(opts);
                return handler.resolve(response);
              } else {
                // Refresh fallito, sessione scaduta
                _triggerSessionExpired();
              }
            } catch (_) {
              // Refresh fallito, sessione scaduta
              _triggerSessionExpired();
            }
          }
          // Gestione 401 generico (token invalid, unauthorized)
          // MA NON per errori di login (invalid_credentials) o registrazione
          else if (error.response?.statusCode == 401) {
            final errorCode = error.response?.data?['error']?['code'];
            // Non triggerare session expired per errori di credenziali
            if (errorCode != 'invalid_credentials') {
              _triggerSessionExpired();
            }
          }
          handler.next(error);
        },
      ),
    );
  }

  /// Notifica che la sessione √® scaduta
  void _triggerSessionExpired() {
    _accessToken = null;
    _tokenStorage.clearRefreshToken();
    if (onSessionExpired != null) {
      onSessionExpired!();
    }
  }

  /// Imposta access token in memoria
  void setAccessToken(String? token) {
    _accessToken = token;
  }

  /// Verifica se autenticato
  bool get isAuthenticated => _accessToken != null;

  /// Tenta refresh del token con lock per evitare refresh concorrenti
  Future<bool> _refreshTokenWithLock() async {
    if (_isRefreshing) {
      // Aspetta che il refresh in corso finisca
      final completer = Completer<void>();
      _pendingRequests.add(completer.complete);
      await completer.future;
      return _accessToken != null;
    }

    _isRefreshing = true;
    try {
      final success = await _refreshToken();
      // Sblocca le richieste in attesa
      for (final callback in _pendingRequests) {
        callback();
      }
      _pendingRequests.clear();
      return success;
    } finally {
      _isRefreshing = false;
    }
  }

  /// Tenta refresh del token
  Future<bool> _refreshToken() async {
    final refreshToken = await _tokenStorage.getRefreshToken();
    if (refreshToken == null) return false;

    try {
      final response = await _dio.post(
        ApiConfig.authRefresh,
        data: {'refresh_token': refreshToken},
      );

      if (response.data['success'] == true) {
        final data = response.data['data'];
        _accessToken = data['access_token'];
        await _tokenStorage.saveRefreshToken(data['refresh_token']);
        return true;
      }
    } catch (_) {
      // Token non valido, pulisci storage
      await _tokenStorage.clearRefreshToken();
    }
    return false;
  }

  /// Tenta di ripristinare sessione da refresh token
  Future<Map<String, dynamic>?> tryRestoreSession() async {
    final refreshToken = await _tokenStorage.getRefreshToken();
    if (refreshToken == null) return null;

    try {
      final response = await _dio.post(
        ApiConfig.authRefresh,
        data: {'refresh_token': refreshToken},
      );

      if (response.data['success'] == true) {
        final data = response.data['data'];
        _accessToken = data['access_token'];
        await _tokenStorage.saveRefreshToken(data['refresh_token']);

        // Fetch user profile
        return await getMe();
      }
    } catch (e) {
      await _tokenStorage.clearRefreshToken();
    }
    return null;
  }

  /// Esegue richiesta GET
  Future<Map<String, dynamic>> get(
    String path, {
    Map<String, dynamic>? queryParameters,
  }) async {
    try {
      final response = await _dio.get(path, queryParameters: queryParameters);
      // ignore: avoid_print
      //print('DEBUG GET $path response.data: ${response.data}');
      return _handleResponse(response);
    } on DioException catch (e) {
      // ignore: avoid_print
      //print('DEBUG GET $path DioException: ${e.message}');
      // ignore: avoid_print
      //print('DEBUG GET $path response: ${e.response?.data}');
      throw _handleError(e);
    }
  }

  /// Esegue richiesta POST
  Future<Map<String, dynamic>> post(
    String path, {
    Map<String, dynamic>? data,
    Map<String, String>? headers,
  }) async {
    try {
      final response = await _dio.post(
        path,
        data: data,
        options: headers != null ? Options(headers: headers) : null,
      );
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Esegue richiesta POST e ritorna la risposta raw (senza estrarre 'data')
  /// Usato per endpoint che non wrappano la risposta in 'data'
  Future<Map<String, dynamic>> postRawResponse(
    String path, {
    Map<String, dynamic>? data,
    Map<String, String>? headers,
  }) async {
    try {
      final response = await _dio.post(
        path,
        data: data,
        options: headers != null ? Options(headers: headers) : null,
      );
      final body = _bodyAsMapOrThrow(response);
      if (body['success'] == true) {
        return body;
      }
      throw ApiException(
        code: body['error']?['code'] ?? 'unknown_error',
        message: body['error']?['message'] ?? 'Unknown error',
        statusCode: response.statusCode ?? 500,
        details: body['error']?['details'],
      );
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Esegue richiesta PUT
  Future<Map<String, dynamic>> put(
    String path, {
    Map<String, dynamic>? data,
  }) async {
    try {
      final response = await _dio.put(path, data: data);
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Esegue richiesta PATCH
  Future<Map<String, dynamic>> patch(
    String path, {
    Map<String, dynamic>? data,
  }) async {
    try {
      final response = await _dio.patch(path, data: data);
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Esegue richiesta DELETE
  Future<Map<String, dynamic>> delete(String path) async {
    try {
      final response = await _dio.delete(path);
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Gestisce risposta API
  Map<String, dynamic> _handleResponse(Response response) {
    final body = _bodyAsMapOrThrow(response);
    if (body['success'] == true) {
      final data = body['data'];
      if (data is Map<String, dynamic>) {
        return data;
      }
      // Per risposte con data come List, ritorna wrapper
      return {'_list': data, '_raw': body};
    }
    throw ApiException(
      code: body['error']?['code'] ?? 'unknown_error',
      message: body['error']?['message'] ?? 'Unknown error',
      statusCode: response.statusCode ?? 500,
      details: body['error']?['details'],
    );
  }

  Map<String, dynamic> _bodyAsMapOrThrow(Response response) {
    final body = response.data;
    if (body is Map<String, dynamic>) {
      return body;
    }
    if (body is Map) {
      return Map<String, dynamic>.from(body);
    }
    throw ApiException(
      code: 'invalid_response',
      message: 'Invalid server response format',
      statusCode: response.statusCode ?? 500,
      details: {'response_type': body.runtimeType.toString()},
    );
  }

  /// Gestisce errori Dio
  ApiException _handleError(DioException error) {
    final response = error.response;
    if (response != null) {
      final body = response.data;
      if (body is Map<String, dynamic>) {
        return ApiException(
          code: body['error']?['code'] ?? 'api_error',
          message: body['error']?['message'] ?? error.message ?? 'API Error',
          statusCode: response.statusCode ?? 500,
          details: body['error']?['details'],
        );
      }
    }
    return ApiException(
      code: 'network_error',
      message: error.message ?? 'Network error',
      statusCode: error.response?.statusCode ?? 0,
      details: {'type': error.type.name, 'uri': error.requestOptions.uri.toString()},
    );
  }

  // ========== AUTH ENDPOINTS ==========

  /// POST /v1/auth/login
  Future<Map<String, dynamic>> login(String email, String password) async {
    final data = await post(
      ApiConfig.authLogin,
      data: {'email': email, 'password': password},
    );

    _accessToken = data['access_token'];
    await _tokenStorage.saveRefreshToken(data['refresh_token']);

    return data;
  }

  /// POST /v1/auth/register
  Future<Map<String, dynamic>> register({
    required String email,
    required String password,
    String? firstName,
    String? lastName,
    String? name,
    String? phone,
  }) async {
    final payload = <String, dynamic>{'email': email, 'password': password};
    if (firstName != null) payload['first_name'] = firstName;
    if (lastName != null) payload['last_name'] = lastName;
    if (name != null) payload['name'] = name;
    if (phone != null) payload['phone'] = phone;

    final data = await post(ApiConfig.authRegister, data: payload);

    _accessToken = data['access_token'];
    await _tokenStorage.saveRefreshToken(data['refresh_token']);

    return data;
  }

  /// POST /v1/auth/forgot-password
  Future<void> forgotPassword(String email) async {
    await post(ApiConfig.authForgotPassword, data: {'email': email});
  }

  /// GET /v1/auth/verify-reset-token/{token}
  /// Verifica se un token di reset √® valido prima di mostrare il form.
  Future<void> verifyResetToken(String token) async {
    await get('${ApiConfig.authVerifyResetToken}/$token');
  }

  /// POST /v1/auth/reset-password
  Future<void> resetPassword({
    required String token,
    required String password,
  }) async {
    await post(
      ApiConfig.authResetPassword,
      data: {'token': token, 'password': password},
    );
  }

  /// POST /v1/me/change-password - Cambia password utente autenticato
  Future<void> changePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    await post(
      ApiConfig.authChangePassword,
      data: {'current_password': currentPassword, 'new_password': newPassword},
    );
  }

  /// POST /v1/auth/logout
  Future<void> logout() async {
    final refreshToken = await _tokenStorage.getRefreshToken();
    try {
      await post(ApiConfig.authLogout, data: {'refresh_token': refreshToken});
    } finally {
      _accessToken = null;
      await _tokenStorage.clearRefreshToken();
    }
  }

  /// GET /v1/me
  Future<Map<String, dynamic>> getMe() async {
    return get(ApiConfig.authMe);
  }

  /// PUT /v1/me - Aggiorna profilo utente
  Future<Map<String, dynamic>> updateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
  }) async {
    final data = <String, dynamic>{};
    if (firstName != null) data['first_name'] = firstName;
    if (lastName != null) data['last_name'] = lastName;
    if (email != null) data['email'] = email;
    if (phone != null) data['phone'] = phone;

    return put(ApiConfig.authMe, data: data);
  }

  // ========== PUBLIC BROWSE ENDPOINTS ==========

  /// GET /v1/services?location_id=X
  Future<Map<String, dynamic>> getServices(int locationId) async {
    return get(
      ApiConfig.services,
      queryParameters: {'location_id': locationId},
    );
  }

  /// GET /v1/staff/{staff_id}/services/popular
  /// Ritorna i servizi pi√π prenotati per uno staff.
  /// Restituisce lista vuota se la location dello staff ha meno di 25 servizi.
  Future<Map<String, dynamic>> getPopularServices(int staffId) async {
    return get(ApiConfig.popularServices(staffId));
  }

  /// GET /v1/locations/{location_id}/service-packages
  Future<Map<String, dynamic>> getServicePackages(int locationId) async {
    return get(ApiConfig.servicePackages(locationId));
  }

  /// GET /v1/locations/{location_id}/service-packages/{id}/expand
  Future<Map<String, dynamic>> expandServicePackage({
    required int locationId,
    required int packageId,
  }) async {
    return get(ApiConfig.servicePackageExpand(locationId, packageId));
  }

  /// POST /v1/locations/{location_id}/service-packages
  Future<Map<String, dynamic>> createServicePackage({
    required int locationId,
    required String name,
    required int categoryId,
    required List<int> serviceIds,
    String? description,
    double? overridePrice,
    int? overrideDurationMinutes,
    bool isActive = true,
  }) async {
    return post(
      ApiConfig.servicePackages(locationId),
      data: {
        'name': name,
        'category_id': categoryId,
        'service_ids': serviceIds,
        if (description != null) 'description': description,
        if (overridePrice != null) 'override_price': overridePrice,
        if (overrideDurationMinutes != null)
          'override_duration_minutes': overrideDurationMinutes,
        'is_active': isActive,
      },
    );
  }

  /// PUT /v1/locations/{location_id}/service-packages/{id}
  Future<Map<String, dynamic>> updateServicePackage({
    required int locationId,
    required int packageId,
    String? name,
    int? categoryId,
    String? description,
    double? overridePrice,
    int? overrideDurationMinutes,
    bool setOverridePriceNull = false,
    bool setOverrideDurationNull = false,
    bool? isActive,
    List<int>? serviceIds,
  }) async {
    final data = <String, dynamic>{};
    if (name != null) data['name'] = name;
    if (categoryId != null) data['category_id'] = categoryId;
    if (description != null) data['description'] = description;
    if (overridePrice != null || setOverridePriceNull) {
      data['override_price'] = overridePrice;
    }
    if (overrideDurationMinutes != null || setOverrideDurationNull) {
      data['override_duration_minutes'] = overrideDurationMinutes;
    }
    if (isActive != null) data['is_active'] = isActive;
    if (serviceIds != null) data['service_ids'] = serviceIds;

    return put(ApiConfig.servicePackage(locationId, packageId), data: data);
  }

  /// DELETE /v1/locations/{location_id}/service-packages/{id}
  Future<void> deleteServicePackage({
    required int locationId,
    required int packageId,
  }) async {
    await delete(ApiConfig.servicePackage(locationId, packageId));
  }

  /// GET /v1/staff?location_id=X
  Future<Map<String, dynamic>> getStaff(int locationId) async {
    return get(ApiConfig.staff, queryParameters: {'location_id': locationId});
  }

  /// GET /v1/availability
  Future<Map<String, dynamic>> getAvailability({
    required int locationId,
    required String date,
    required List<int> serviceIds,
    int? staffId,
  }) async {
    final params = <String, dynamic>{
      'location_id': locationId,
      'date': date,
      'service_ids': serviceIds.join(','),
    };
    if (staffId != null) {
      params['staff_id'] = staffId;
    }
    return get(ApiConfig.availability, queryParameters: params);
  }

  // ========== GESTIONALE ENDPOINTS ==========

  /// GET /v1/clients?business_id=X[&limit=N][&offset=N][&search=term][&sort=name_asc]
  Future<Map<String, dynamic>> getClients(
    int businessId, {
    int? limit,
    int? offset,
    String? search,
    String? sort,
  }) async {
    final params = <String, dynamic>{'business_id': businessId};
    if (limit != null) params['limit'] = limit;
    if (offset != null) params['offset'] = offset;
    if (search != null && search.isNotEmpty) params['search'] = search;
    if (sort != null && sort.isNotEmpty) params['sort'] = sort;
    return get(ApiConfig.clients, queryParameters: params);
  }

  /// GET /v1/locations/{location_id}/appointments?date=YYYY-MM-DD
  Future<Map<String, dynamic>> getAppointments({
    required int locationId,
    required String date,
  }) async {
    return get(
      ApiConfig.appointments(locationId),
      queryParameters: {'date': date},
    );
  }

  /// PATCH /v1/locations/{location_id}/appointments/{id}
  Future<Map<String, dynamic>> updateAppointment({
    required int locationId,
    required int appointmentId,
    String? startTime,
    String? endTime,
    int? staffId,
    int? serviceId,
    int? serviceVariantId,
    String? serviceNameSnapshot,
    int? clientId,
    String? clientName,
    String? clientNameSnapshot,
    int? extraBlockedMinutes,
    int? extraProcessingMinutes,
    double? price,
    bool priceExplicitlySet = false,
  }) async {
    final data = <String, dynamic>{};
    if (startTime != null) data['start_time'] = startTime;
    if (endTime != null) data['end_time'] = endTime;
    if (staffId != null) data['staff_id'] = staffId;
    if (serviceId != null) data['service_id'] = serviceId;
    if (serviceVariantId != null) data['service_variant_id'] = serviceVariantId;
    if (serviceNameSnapshot != null) {
      data['service_name_snapshot'] = serviceNameSnapshot;
    }
    if (clientId != null) data['client_id'] = clientId;
    if (clientName != null) data['client_name'] = clientName;
    if (clientNameSnapshot != null) {
      data['client_name_snapshot'] = clientNameSnapshot;
    }
    if (extraBlockedMinutes != null) {
      data['extra_blocked_minutes'] = extraBlockedMinutes;
    }
    if (extraProcessingMinutes != null) {
      data['extra_processing_minutes'] = extraProcessingMinutes;
    }
    if (priceExplicitlySet) {
      data['price'] = price;
    }

    try {
      final response = await _dio.patch(
        ApiConfig.appointment(locationId, appointmentId),
        data: data,
      );
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// POST /v1/locations/{location_id}/appointments/{id}/cancel
  Future<void> cancelAppointment({
    required int locationId,
    required int appointmentId,
  }) async {
    await post(ApiConfig.appointmentCancel(locationId, appointmentId));
  }

  /// POST /v1/bookings/{booking_id}/items
  /// Add a new booking item (appointment) to an existing booking
  Future<Map<String, dynamic>> addBookingItem({
    required int bookingId,
    required int locationId,
    required int staffId,
    required int serviceId,
    required int serviceVariantId,
    required String startTime,
    required String endTime,
    String? serviceNameSnapshot,
    String? clientNameSnapshot,
    double? price,
    int? extraBlockedMinutes,
    int? extraProcessingMinutes,
  }) async {
    final data = <String, dynamic>{
      'location_id': locationId,
      'staff_id': staffId,
      'service_id': serviceId,
      'service_variant_id': serviceVariantId,
      'start_time': startTime,
      'end_time': endTime,
    };
    if (serviceNameSnapshot != null) {
      data['service_name_snapshot'] = serviceNameSnapshot;
    }
    if (clientNameSnapshot != null) {
      data['client_name_snapshot'] = clientNameSnapshot;
    }
    if (price != null) data['price'] = price;
    if (extraBlockedMinutes != null) {
      data['extra_blocked_minutes'] = extraBlockedMinutes;
    }
    if (extraProcessingMinutes != null) {
      data['extra_processing_minutes'] = extraProcessingMinutes;
    }

    try {
      final response = await _dio.post(
        ApiConfig.bookingItems(bookingId),
        data: data,
      );
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// DELETE /v1/bookings/{booking_id}/items/{item_id}
  /// Delete a single booking item (appointment) from a booking
  Future<void> deleteBookingItem({
    required int bookingId,
    required int itemId,
  }) async {
    try {
      await _dio.delete(ApiConfig.bookingItem(bookingId, itemId));
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// GET /v1/locations/{location_id}/bookings?date=YYYY-MM-DD
  Future<Map<String, dynamic>> getBookings({
    required int locationId,
    required String date,
    int? staffId,
  }) async {
    final params = <String, dynamic>{'date': date};
    if (staffId != null) {
      params['staff_id'] = staffId;
    }
    return get(ApiConfig.bookings(locationId), queryParameters: params);
  }

  /// GET /v1/locations/{location_id}/bookings/{booking_id}
  Future<Map<String, dynamic>> getBooking({
    required int locationId,
    required int bookingId,
  }) async {
    return get(ApiConfig.booking(locationId, bookingId));
  }

  /// GET /v1/bookings/{booking_id}/history
  Future<Map<String, dynamic>> getBookingHistory({
    required int bookingId,
  }) async {
    return get(ApiConfig.bookingHistory(bookingId));
  }

  /// POST /v1/locations/{location_id}/bookings
  Future<Map<String, dynamic>> createBooking({
    required int locationId,
    required String idempotencyKey,
    required List<int> serviceIds,
    required String startTime,
    int? staffId,
    int? clientId,
    String? notes,
  }) async {
    final data = <String, dynamic>{
      'service_ids': serviceIds,
      'start_time': startTime,
    };
    if (staffId != null) {
      data['staff_id'] = staffId;
    }
    if (clientId != null) {
      data['client_id'] = clientId;
    }
    if (notes != null && notes.isNotEmpty) {
      data['notes'] = notes;
    }

    return post(
      ApiConfig.bookings(locationId),
      data: data,
      headers: {'X-Idempotency-Key': idempotencyKey},
    );
  }

  /// POST /v1/locations/{location_id}/bookings (new items format)
  Future<Map<String, dynamic>> createBookingWithItems({
    required int locationId,
    required String idempotencyKey,
    required List<Map<String, dynamic>> items,
    int? clientId,
    String? notes,
  }) async {
    final data = <String, dynamic>{'items': items};
    if (clientId != null) {
      data['client_id'] = clientId;
    }
    if (notes != null && notes.isNotEmpty) {
      data['notes'] = notes;
    }

    return post(
      ApiConfig.bookings(locationId),
      data: data,
      headers: {'X-Idempotency-Key': idempotencyKey},
    );
  }

  /// PUT /v1/locations/{location_id}/bookings/{booking_id}
  Future<Map<String, dynamic>> updateBooking({
    required int locationId,
    required int bookingId,
    String? status,
    String? notes,
    int? clientId,
    bool clearClient = false,
  }) async {
    final data = <String, dynamic>{};
    if (status != null) {
      data['status'] = status;
    }
    if (notes != null) {
      data['notes'] = notes;
    }
    // clearClient: invia client_id: null per rimuovere il cliente
    // clientId: invia client_id: valore per assegnare un cliente
    if (clearClient) {
      data['client_id'] = null;
    } else if (clientId != null) {
      data['client_id'] = clientId;
    }
    return put(ApiConfig.booking(locationId, bookingId), data: data);
  }

  /// DELETE /v1/locations/{location_id}/bookings/{booking_id}
  Future<void> deleteBooking({
    required int locationId,
    required int bookingId,
  }) async {
    await delete(ApiConfig.booking(locationId, bookingId));
  }

  /// GET /v1/businesses/{business_id}/bookings/list
  /// Lista prenotazioni con filtri avanzati per il gestionale.
  Future<Map<String, dynamic>> getBookingsList({
    required int businessId,
    int? locationId,
    List<int>? locationIds,
    int? staffId,
    List<int>? staffIds,
    List<int>? serviceIds,
    String? clientSearch,
    List<String>? status,
    String? source,
    String? startDate,
    String? endDate,
    bool includePast = false,
    String sortBy = 'appointment', // 'appointment' or 'created'
    String sortOrder = 'desc', // 'asc' or 'desc'
    int limit = 50,
    int offset = 0,
  }) async {
    final queryParameters = <String, dynamic>{
      'include_past': includePast ? 'true' : 'false',
      'sort_by': sortBy,
      'sort_order': sortOrder,
      'limit': limit.toString(),
      'offset': offset.toString(),
    };

    // Support both single and multi-select
    if (locationIds != null && locationIds.isNotEmpty) {
      queryParameters['location_ids'] = locationIds.join(',');
    } else if (locationId != null) {
      queryParameters['location_id'] = locationId.toString();
    }
    if (staffIds != null && staffIds.isNotEmpty) {
      queryParameters['staff_ids'] = staffIds.join(',');
    } else if (staffId != null) {
      queryParameters['staff_id'] = staffId.toString();
    }
    if (serviceIds != null && serviceIds.isNotEmpty) {
      queryParameters['service_ids'] = serviceIds.join(',');
    }
    if (clientSearch != null && clientSearch.isNotEmpty) {
      queryParameters['client_search'] = clientSearch;
    }
    if (status != null && status.isNotEmpty) {
      queryParameters['status'] = status.join(',');
    }
    if (source != null && source.isNotEmpty) {
      queryParameters['source'] = source;
    }
    if (startDate != null) {
      queryParameters['start_date'] = startDate;
    }
    if (endDate != null) {
      queryParameters['end_date'] = endDate;
    }

    return get(
      ApiConfig.bookingsList(businessId),
      queryParameters: queryParameters,
    );
  }



  /// GET /v1/businesses/{business_id}/class-events
  Future<List<ClassEvent>> getClassEvents({
    required int businessId,
    required DateTime fromUtc,
    required DateTime toUtc,
    int? locationId,
    int? classTypeId,
  }) async {
    final response = await get(
      ApiConfig.classEvents(businessId),
      queryParameters: {
        'from': fromUtc.toIso8601String(),
        'to': toUtc.toIso8601String(),
        if (locationId != null) 'location_id': locationId.toString(),
        if (classTypeId != null) 'class_type_id': classTypeId.toString(),
      },
    );
    final data = response['_list'] ?? response['data'] ?? response;
    if (data is List) {
      return data
          .whereType<Map<String, dynamic>>()
          .map(ClassEvent.fromJson)
          .toList();
    }
    if (data is Map && data['items'] is List) {
      return (data['items'] as List)
          .whereType<Map<String, dynamic>>()
          .map(ClassEvent.fromJson)
          .toList();
    }
    return const [];
  }

  /// GET /v1/businesses/{business_id}/class-types
  Future<List<ClassType>> getClassTypes({
    required int businessId,
    bool includeInactive = false,
  }) async {
    final response = await get(
      ApiConfig.classTypes(businessId),
      queryParameters: {
        if (includeInactive) 'include_inactive': '1',
      },
    );
    final data = response['_list'] ?? response['data'] ?? response;
    if (data is List) {
      return data
          .whereType<Map<String, dynamic>>()
          .map(ClassType.fromJson)
          .toList();
    }
    if (data is Map && data['items'] is List) {
      return (data['items'] as List)
          .whereType<Map<String, dynamic>>()
          .map(ClassType.fromJson)
          .toList();
    }
    return const [];
  }

  /// POST /v1/businesses/{business_id}/class-types
  Future<ClassType> createClassType({
    required int businessId,
    required Map<String, dynamic> data,
  }) async {
    final response = await post(ApiConfig.classTypes(businessId), data: data);
    final payload = response['data'];
    return ClassType.fromJson(payload is Map<String, dynamic> ? payload : response);
  }

  /// PUT /v1/businesses/{business_id}/class-types/{id}
  Future<ClassType> updateClassType({
    required int businessId,
    required int classTypeId,
    required Map<String, dynamic> data,
  }) async {
    final response = await put(
      ApiConfig.classType(businessId, classTypeId),
      data: data,
    );
    final payload = response['data'];
    return ClassType.fromJson(payload is Map<String, dynamic> ? payload : response);
  }

  /// DELETE /v1/businesses/{business_id}/class-types/{id}
  Future<void> deleteClassType({
    required int businessId,
    required int classTypeId,
  }) async {
    await delete(ApiConfig.classType(businessId, classTypeId));
  }

  /// GET /v1/businesses/{business_id}/class-events/{id}
  Future<ClassEvent> getClassEvent({
    required int businessId,
    required int classEventId,
  }) async {
    final response = await get(ApiConfig.classEvent(businessId, classEventId));
    final data = response['data'];
    final payload = data is Map<String, dynamic> ? data : response;
    return ClassEvent.fromJson(payload);
  }

  /// GET /v1/businesses/{business_id}/class-events/{id}/participants
  Future<List<ClassBooking>> getClassEventParticipants({
    required int businessId,
    required int classEventId,
    String? status,
  }) async {
    final response = await get(
      ApiConfig.classEventParticipants(businessId, classEventId),
      queryParameters: {if (status != null && status.isNotEmpty) 'status': status},
    );
    final data = response['_list'] ?? response['data'] ?? response;
    if (data is List) {
      return data
          .whereType<Map<String, dynamic>>()
          .map(ClassBooking.fromJson)
          .toList();
    }
    if (data is Map && data['items'] is List) {
      return (data['items'] as List)
          .whereType<Map<String, dynamic>>()
          .map(ClassBooking.fromJson)
          .toList();
    }
    return const [];
  }

  /// POST /v1/businesses/{business_id}/class-events/{id}/book
  Future<ClassBooking> bookClassEvent({
    required int businessId,
    required int classEventId,
    int? customerId,
  }) async {
    final response = await post(
      ApiConfig.classEventBook(businessId, classEventId),
      data: {if (customerId != null) 'customer_id': customerId},
    );
    final data = response['data'];
    final payload = data is Map<String, dynamic> ? data : response;
    return ClassBooking.fromJson(payload);
  }

  /// POST /v1/businesses/{business_id}/class-events/{id}/cancel-booking
  Future<void> cancelClassEventBooking({
    required int businessId,
    required int classEventId,
    int? customerId,
  }) async {
    await post(
      ApiConfig.classEventCancelBooking(businessId, classEventId),
      data: {if (customerId != null) 'customer_id': customerId},
    );
  }

  /// POST /v1/businesses/{business_id}/class-events
  Future<ClassEvent> createClassEvent({
    required int businessId,
    required Map<String, dynamic> data,
  }) async {
    final response = await post(ApiConfig.classEvents(businessId), data: data);
    final payload = response['data'];
    return ClassEvent.fromJson(
      payload is Map<String, dynamic> ? payload : response,
    );
  }

  /// PUT /v1/businesses/{business_id}/class-events/{id}
  Future<ClassEvent> updateClassEvent({
    required int businessId,
    required int classEventId,
    required Map<String, dynamic> data,
  }) async {
    final response = await put(
      ApiConfig.classEvent(businessId, classEventId),
      data: data,
    );
    final payload = response['data'];
    return ClassEvent.fromJson(
      payload is Map<String, dynamic> ? payload : response,
    );
  }

  /// POST /v1/businesses/{business_id}/class-events/{id}/cancel
  Future<void> cancelClassEvent({
    required int businessId,
    required int classEventId,
  }) async {
    await post('${ApiConfig.classEvent(businessId, classEventId)}/cancel');
  }

  /// DELETE /v1/businesses/{business_id}/class-events/{id}
  Future<void> deleteClassEvent({
    required int businessId,
    required int classEventId,
  }) async {
    await delete(ApiConfig.classEvent(businessId, classEventId));
  }

  /// GET /v1/businesses/{business_id}/booking-notifications
  /// Lista notifiche associate alle prenotazioni.
  Future<Map<String, dynamic>> getBookingNotifications({
    required int businessId,
    String? search,
    List<String>? status,
    List<String>? channels,
    String? startDate,
    String? endDate,
    String sortBy = 'created', // 'created' | 'scheduled' | 'sent'
    String sortOrder = 'desc', // 'asc' | 'desc'
    int limit = 50,
    int offset = 0,
  }) async {
    final queryParameters = <String, dynamic>{
      'sort_by': sortBy,
      'sort_order': sortOrder,
      'limit': limit.toString(),
      'offset': offset.toString(),
    };

    if (search != null && search.isNotEmpty) {
      queryParameters['search'] = search;
    }
    if (status != null && status.isNotEmpty) {
      queryParameters['status'] = status.join(',');
    }
    if (channels != null && channels.isNotEmpty) {
      queryParameters['channel'] = channels.join(',');
    }
    if (startDate != null) {
      queryParameters['start_date'] = startDate;
    }
    if (endDate != null) {
      queryParameters['end_date'] = endDate;
    }

    return get(
      ApiConfig.bookingNotifications(businessId),
      queryParameters: queryParameters,
    );
  }

  /// GET /v1/businesses
  Future<List<Map<String, dynamic>>> getBusinesses() async {
    final response = await get('/v1/businesses');
    // API ritorna { data: { data: [...] } } per lista business
    final data = response['data'];
    if (data is List) {
      return data.cast<Map<String, dynamic>>();
    }
    // Se √® un oggetto con chiave 'data' o 'businesses'
    if (data is Map) {
      final list = data['data'] ?? data['businesses'] ?? [];
      return (list as List).cast<Map<String, dynamic>>();
    }
    return [];
  }

  /// GET /v1/admin/businesses
  /// Superadmin only: lista tutti i business.
  Future<List<Map<String, dynamic>>> getAdminBusinesses({
    String? search,
  }) async {
    final queryParameters = <String, dynamic>{};
    if (search != null && search.isNotEmpty) {
      queryParameters['search'] = search;
    }
    final response = await get(
      '/v1/admin/businesses',
      queryParameters: queryParameters.isNotEmpty ? queryParameters : null,
    );
    // _handleResponse ritorna body['data'], quindi response = { businesses: [...], pagination: {...} }
    return (response['businesses'] as List).cast<Map<String, dynamic>>();
  }

  /// POST /v1/admin/businesses
  /// Superadmin only: crea un nuovo business.
  /// Se adminEmail fornito, invia email di benvenuto all'admin con link per impostare password.
  Future<Map<String, dynamic>> createAdminBusiness({
    required String name,
    required String slug,
    String? adminEmail,
    String? email,
    String? phone,
    String? onlineBookingsNotificationEmail,
    String? serviceColorPalette,
    String timezone = 'Europe/Rome',
    String currency = 'EUR',
    String? adminFirstName,
    String? adminLastName,
  }) async {
    final response = await post(
      '/v1/admin/businesses',
      data: {
        'name': name,
        'slug': slug,
        if (adminEmail != null && adminEmail.isNotEmpty)
          'admin_email': adminEmail,
        if (email != null) 'email': email,
        if (phone != null) 'phone': phone,
        if (onlineBookingsNotificationEmail != null)
          'online_bookings_notification_email': onlineBookingsNotificationEmail,
        if (serviceColorPalette != null)
          'service_color_palette': serviceColorPalette,
        'timezone': timezone,
        'currency': currency,
        if (adminFirstName != null) 'admin_first_name': adminFirstName,
        if (adminLastName != null) 'admin_last_name': adminLastName,
      },
    );
    // _handleResponse gi√† ritorna body['data'], quindi response √à il business
    return response;
  }

  /// PUT /v1/admin/businesses/{id}
  /// Superadmin only: aggiorna un business esistente.
  /// Se adminEmail cambia, trasferisce ownership e invia email al nuovo admin.
  Future<Map<String, dynamic>> updateAdminBusiness({
    required int businessId,
    String? name,
    String? slug,
    String? email,
    String? phone,
    String? onlineBookingsNotificationEmail,
    String? serviceColorPalette,
    String? timezone,
    String? currency,
    String? adminEmail,
  }) async {
    final response = await put(
      '/v1/admin/businesses/$businessId',
      data: {
        if (name != null) 'name': name,
        if (slug != null) 'slug': slug,
        if (email != null) 'email': email,
        if (phone != null) 'phone': phone,
        if (onlineBookingsNotificationEmail != null)
          'online_bookings_notification_email': onlineBookingsNotificationEmail,
        if (serviceColorPalette != null)
          'service_color_palette': serviceColorPalette,
        if (timezone != null) 'timezone': timezone,
        if (currency != null) 'currency': currency,
        if (adminEmail != null) 'admin_email': adminEmail,
      },
    );
    return response;
  }

  /// POST /v1/admin/businesses/{id}/resend-invite
  /// Superadmin only: reinvia email di invito all'admin.
  Future<void> resendAdminInvite(int businessId) async {
    await post('/v1/admin/businesses/$businessId/resend-invite');
  }

  /// PUT /v1/admin/businesses/{id}/suspend
  /// Superadmin only: sospende un business con messaggio opzionale.
  Future<Map<String, dynamic>> suspendBusiness({
    required int businessId,
    required bool isSuspended,
    String? suspensionMessage,
  }) async {
    final response = await put(
      '/v1/admin/businesses/$businessId',
      data: {
        'is_suspended': isSuspended,
        if (suspensionMessage != null) 'suspension_message': suspensionMessage,
        if (!isSuspended) 'suspension_message': null,
      },
    );
    return response;
  }

  /// DELETE /v1/admin/businesses/{id}
  /// Superadmin only: soft-delete un business (is_active = 0).
  Future<void> deleteAdminBusiness(int businessId) async {
    await delete('/v1/admin/businesses/$businessId');
  }

  // ========== LOCATIONS CRUD ==========

  /// GET /v1/businesses/{business_id}/locations
  Future<List<Map<String, dynamic>>> getLocations(int businessId) async {
    final response = await get('/v1/businesses/$businessId/locations');
    final locations =
        response['locations'] ?? response['_list'] ?? response['data'];
    if (locations is List) {
      return locations.map((e) => Map<String, dynamic>.from(e as Map)).toList();
    }
    return const <Map<String, dynamic>>[];
  }

  /// POST /v1/businesses/{business_id}/locations
  Future<Map<String, dynamic>> createLocation({
    required int businessId,
    required String name,
    String? address,
    String? phone,
    String? email,
    String? timezone,
    int? minBookingNoticeHours,
    int? maxBookingAdvanceDays,
    int? cancellationHours,
    bool? allowCustomerChooseStaff,
    bool? isActive,
  }) async {
    final response = await post(
      '/v1/businesses/$businessId/locations',
      data: {
        'name': name,
        if (address != null && address.isNotEmpty) 'address': address,
        if (phone != null && phone.isNotEmpty) 'phone': phone,
        if (email != null && email.isNotEmpty) 'email': email,
        if (timezone != null && timezone.isNotEmpty) 'timezone': timezone,
        if (minBookingNoticeHours != null)
          'min_booking_notice_hours': minBookingNoticeHours,
        if (maxBookingAdvanceDays != null)
          'max_booking_advance_days': maxBookingAdvanceDays,
        if (cancellationHours != null) 'cancellation_hours': cancellationHours,
        if (allowCustomerChooseStaff != null)
          'allow_customer_choose_staff': allowCustomerChooseStaff,
        if (isActive != null) 'is_active': isActive,
      },
    );
    final location = response['location'];
    if (location is Map<String, dynamic>) {
      return location;
    }
    if (location is Map) {
      return Map<String, dynamic>.from(location);
    }
    return _asMapPayload(response);
  }

  /// PUT /v1/locations/{id}
  Future<Map<String, dynamic>> updateLocation({
    required int locationId,
    String? name,
    String? address,
    String? phone,
    String? email,
    String? timezone,
    int? minBookingNoticeHours,
    int? maxBookingAdvanceDays,
    int? cancellationHours,
    bool? allowCustomerChooseStaff,
    int? onlineBookingSlotIntervalMinutes,
    String? slotDisplayMode,
    int? minGapMinutes,
    bool? isActive,
  }) async {
    final response = await put(
      '/v1/locations/$locationId',
      data: {
        if (name != null) 'name': name,
        if (address != null) 'address': address,
        if (phone != null) 'phone': phone,
        if (email != null) 'email': email,
        if (timezone != null) 'timezone': timezone,
        if (minBookingNoticeHours != null)
          'min_booking_notice_hours': minBookingNoticeHours,
        if (maxBookingAdvanceDays != null)
          'max_booking_advance_days': maxBookingAdvanceDays,
        if (cancellationHours != null) 'cancellation_hours': cancellationHours,
        if (allowCustomerChooseStaff != null)
          'allow_customer_choose_staff': allowCustomerChooseStaff,
        if (onlineBookingSlotIntervalMinutes != null)
          'online_booking_slot_interval_minutes':
              onlineBookingSlotIntervalMinutes,
        if (slotDisplayMode != null) 'slot_display_mode': slotDisplayMode,
        if (minGapMinutes != null) 'min_gap_minutes': minGapMinutes,
        if (isActive != null) 'is_active': isActive,
      },
    );
    final location = response['location'];
    if (location is Map<String, dynamic>) {
      return location;
    }
    if (location is Map) {
      return Map<String, dynamic>.from(location);
    }
    return _asMapPayload(response);
  }

  /// DELETE /v1/locations/{id}
  Future<void> deleteLocation(int locationId) async {
    await delete('/v1/locations/$locationId');
  }

  /// POST /v1/locations/reorder - Batch update locations sort_order
  Future<Map<String, dynamic>> reorderLocations({
    required List<Map<String, dynamic>> locations,
  }) async {
    return post('/v1/locations/reorder', data: {'locations': locations});
  }

  // ========== SERVICES CRUD ==========

  /// POST /v1/businesses/{business_id}/services
  /// Creates a service with variants for multiple locations
  Future<Map<String, dynamic>> createServiceMultiLocation({
    required int businessId,
    required List<int> locationIds,
    required String name,
    int? categoryId,
    String? description,
    int durationMinutes = 30,
    double price = 0,
    String? colorHex,
    bool isBookableOnline = true,
    bool isPriceStartingFrom = false,
    int? processingTime,
    int? blockedTime,
  }) async {
    final response = await post(
      '/v1/businesses/$businessId/services',
      data: {
        'name': name,
        'location_ids': locationIds,
        if (categoryId != null) 'category_id': categoryId,
        if (description != null && description.isNotEmpty)
          'description': description,
        'duration_minutes': durationMinutes,
        'price': price,
        if (colorHex != null && colorHex.isNotEmpty) 'color': colorHex,
        'is_bookable_online': isBookableOnline,
        'is_price_starting_from': isPriceStartingFrom,
        if (processingTime != null) 'processing_time': processingTime,
        if (blockedTime != null) 'blocked_time': blockedTime,
      },
    );
    return response;
  }

  /// POST /v1/locations/{location_id}/services
  Future<Map<String, dynamic>> createService({
    required int locationId,
    required String name,
    int? categoryId,
    String? description,
    int durationMinutes = 30,
    double price = 0,
    String? colorHex,
    bool isBookableOnline = true,
    bool isPriceStartingFrom = false,
    int? processingTime,
    int? blockedTime,
  }) async {
    final response = await post(
      '/v1/locations/$locationId/services',
      data: {
        'name': name,
        if (categoryId != null) 'category_id': categoryId,
        if (description != null && description.isNotEmpty)
          'description': description,
        'duration_minutes': durationMinutes,
        'price': price,
        if (colorHex != null && colorHex.isNotEmpty) 'color': colorHex,
        'is_bookable_online': isBookableOnline,
        'is_price_starting_from': isPriceStartingFrom,
        if (processingTime != null) 'processing_time': processingTime,
        if (blockedTime != null) 'blocked_time': blockedTime,
      },
    );
    return response;
  }

  /// PUT /v1/services/{id}
  Future<Map<String, dynamic>> updateService({
    required int serviceId,
    required int locationId,
    String? name,
    int? categoryId,
    bool setCategoryIdNull = false,
    String? description,
    bool setDescriptionNull = false,
    int? durationMinutes,
    double? price,
    String? colorHex,
    bool? isBookableOnline,
    bool? isPriceStartingFrom,
    int? sortOrder,
    int? processingTime,
    int? blockedTime,
  }) async {
    final response = await put(
      '/v1/services/$serviceId',
      data: {
        'location_id': locationId,
        if (name != null) 'name': name,
        if (setCategoryIdNull)
          'category_id': null
        else if (categoryId != null)
          'category_id': categoryId,
        if (setDescriptionNull)
          'set_description_null': true
        else if (description != null)
          'description': description,
        if (durationMinutes != null) 'duration_minutes': durationMinutes,
        if (price != null) 'price': price,
        if (colorHex != null) 'color': colorHex,
        if (isBookableOnline != null) 'is_bookable_online': isBookableOnline,
        if (isPriceStartingFrom != null)
          'is_price_starting_from': isPriceStartingFrom,
        if (sortOrder != null) 'sort_order': sortOrder,
        if (processingTime != null) 'processing_time': processingTime,
        if (blockedTime != null) 'blocked_time': blockedTime,
      },
    );
    return response;
  }

  /// DELETE /v1/services/{id}
  Future<void> deleteService(int serviceId) async {
    await delete('/v1/services/$serviceId');
  }

  /// GET /v1/services/{id}/locations
  /// Returns the list of location IDs where this service has an active variant.
  Future<List<int>> getServiceLocations(int serviceId) async {
    final response = await get('/v1/services/$serviceId/locations');
    final locationIds = response['location_ids'] as List<dynamic>? ?? [];
    return locationIds.map((e) => e as int).toList();
  }

  /// PUT /v1/services/{id}/locations
  /// Updates the locations associated with a service.
  Future<List<int>> updateServiceLocations({
    required int serviceId,
    required List<int> locationIds,
  }) async {
    final response = await put(
      '/v1/services/$serviceId/locations',
      data: {'location_ids': locationIds},
    );
    final updatedIds = response['location_ids'] as List<dynamic>? ?? [];
    return updatedIds.map((e) => e as int).toList();
  }

  // ========== SERVICE CATEGORIES CRUD ==========

  /// GET /v1/businesses/{business_id}/categories
  Future<Map<String, dynamic>> getServiceCategories(int businessId) async {
    return get('/v1/businesses/$businessId/categories');
  }

  /// POST /v1/businesses/{business_id}/categories
  Future<Map<String, dynamic>> createServiceCategory({
    required int businessId,
    required String name,
    String? description,
  }) async {
    return post(
      '/v1/businesses/$businessId/categories',
      data: {
        'name': name,
        if (description != null && description.isNotEmpty)
          'description': description,
      },
    );
  }

  /// PUT /v1/categories/{id}
  Future<Map<String, dynamic>> updateServiceCategory({
    required int categoryId,
    String? name,
    String? description,
    int? sortOrder,
  }) async {
    return put(
      '/v1/categories/$categoryId',
      data: {
        if (name != null) 'name': name,
        if (description != null) 'description': description,
        if (sortOrder != null) 'sort_order': sortOrder,
      },
    );
  }

  /// DELETE /v1/categories/{id}
  Future<void> deleteServiceCategory(int categoryId) async {
    await delete('/v1/categories/$categoryId');
  }

  /// POST /v1/services/reorder - Batch update services sort_order and category_id
  Future<Map<String, dynamic>> reorderServices({
    required List<Map<String, dynamic>> services,
  }) async {
    return post('/v1/services/reorder', data: {'services': services});
  }

  /// POST /v1/service-packages/reorder - Batch update packages sort_order and category_id
  Future<Map<String, dynamic>> reorderServicePackages({
    required List<Map<String, dynamic>> packages,
  }) async {
    return post('/v1/service-packages/reorder', data: {'packages': packages});
  }

  /// POST /v1/categories/reorder - Batch update categories sort_order
  Future<Map<String, dynamic>> reorderCategories({
    required List<Map<String, dynamic>> categories,
  }) async {
    return post('/v1/categories/reorder', data: {'categories': categories});
  }

  // ========== SERVICE VARIANT RESOURCES ==========

  /// GET /v1/service-variants/{id}/resources
  Future<Map<String, dynamic>> getServiceVariantResources(
    int serviceVariantId,
  ) async {
    return get('/v1/service-variants/$serviceVariantId/resources');
  }

  /// PUT /v1/service-variants/{id}/resources - Replace all resource requirements
  Future<Map<String, dynamic>> setServiceVariantResources({
    required int serviceVariantId,
    required List<Map<String, dynamic>> resources,
  }) async {
    return put(
      '/v1/service-variants/$serviceVariantId/resources',
      data: {'resources': resources},
    );
  }

  /// POST /v1/service-variants/{id}/resources - Add single resource requirement
  Future<Map<String, dynamic>> addServiceVariantResource({
    required int serviceVariantId,
    required int resourceId,
    int quantity = 1,
  }) async {
    return post(
      '/v1/service-variants/$serviceVariantId/resources',
      data: {'resource_id': resourceId, 'quantity': quantity},
    );
  }

  /// DELETE /v1/service-variants/{id}/resources/{resource_id}
  Future<void> removeServiceVariantResource({
    required int serviceVariantId,
    required int resourceId,
  }) async {
    await delete(
      '/v1/service-variants/$serviceVariantId/resources/$resourceId',
    );
  }

  /// GET /v1/resources/{id}/services - Get services that require this resource
  Future<Map<String, dynamic>> getResourceServices(int resourceId) async {
    return get('/v1/resources/$resourceId/services');
  }

  /// PUT /v1/resources/{id}/services - Set services that require this resource
  Future<Map<String, dynamic>> setResourceServices({
    required int resourceId,
    required List<Map<String, dynamic>> services,
  }) async {
    return put(
      '/v1/resources/$resourceId/services',
      data: {'services': services},
    );
  }

  // ========== STAFF CRUD ==========

  /// GET /v1/businesses/{business_id}/staff
  Future<List<Map<String, dynamic>>> getStaffByBusiness(int businessId) async {
    final response = await get('/v1/businesses/$businessId/staff');
    final staff = response['staff'] ?? response['_list'];
    if (staff is List) {
      return staff.map((e) => Map<String, dynamic>.from(e as Map)).toList();
    }
    return const <Map<String, dynamic>>[];
  }

  /// POST /v1/businesses/{business_id}/staff
  Future<Map<String, dynamic>> createStaff({
    required int businessId,
    required String name,
    String? surname,
    String? colorHex,
    String? avatarUrl,
    bool? isBookableOnline,
    List<int>? locationIds,
    List<int>? serviceIds,
  }) async {
    final response = await post(
      '/v1/businesses/$businessId/staff',
      data: {
        'name': name,
        if (surname != null && surname.isNotEmpty) 'surname': surname,
        if (colorHex != null) 'color_hex': colorHex,
        if (avatarUrl != null) 'avatar_url': avatarUrl,
        if (isBookableOnline != null) 'is_bookable_online': isBookableOnline,
        if (locationIds != null && locationIds.isNotEmpty)
          'location_ids': locationIds,
        if (serviceIds != null) 'service_ids': serviceIds,
      },
    );
    final staff = response['staff'];
    if (staff is Map<String, dynamic>) {
      return staff;
    }
    if (staff is Map) {
      return Map<String, dynamic>.from(staff);
    }
    return _asMapPayload(response);
  }

  /// PUT /v1/staff/{id}
  Future<Map<String, dynamic>> updateStaff({
    required int staffId,
    String? name,
    String? surname,
    String? colorHex,
    String? avatarUrl,
    bool? isBookableOnline,
    int? sortOrder,
    List<int>? locationIds,
    List<int>? serviceIds,
  }) async {
    final response = await put(
      '/v1/staff/$staffId',
      data: {
        if (name != null) 'name': name,
        if (surname != null) 'surname': surname,
        if (colorHex != null) 'color_hex': colorHex,
        if (avatarUrl != null) 'avatar_url': avatarUrl,
        if (isBookableOnline != null) 'is_bookable_online': isBookableOnline,
        if (sortOrder != null) 'sort_order': sortOrder,
        if (locationIds != null) 'location_ids': locationIds,
        if (serviceIds != null) 'service_ids': serviceIds,
      },
    );
    final staff = response['staff'];
    if (staff is Map<String, dynamic>) {
      return staff;
    }
    if (staff is Map) {
      return Map<String, dynamic>.from(staff);
    }
    return _asMapPayload(response);
  }

  /// DELETE /v1/staff/{id}
  Future<void> deleteStaff(int staffId) async {
    await delete('/v1/staff/$staffId');
  }

  /// POST /v1/staff/reorder - Batch update staff sort_order
  Future<Map<String, dynamic>> reorderStaff({
    required List<Map<String, dynamic>> staff,
  }) async {
    return post('/v1/staff/reorder', data: {'staff': staff});
  }

  // ========== BUSINESS USERS (OPERATORS) ==========

  /// GET /v1/businesses/{business_id}/users
  /// Lista operatori di un business.
  Future<List<Map<String, dynamic>>> getBusinessUsers(int businessId) async {
    final response = await get(ApiConfig.businessUsers(businessId));
    final users = response['users'] ?? response['_list'];
    if (users is List) {
      return users.cast<Map<String, dynamic>>();
    }
    return const <Map<String, dynamic>>[];
  }

  /// POST /v1/businesses/{business_id}/users
  /// Aggiunge un utente esistente al business.
  Future<Map<String, dynamic>> addBusinessUser({
    required int businessId,
    required int userId,
    required String role,
  }) async {
    final response = await post(
      ApiConfig.businessUsers(businessId),
      data: {'user_id': userId, 'role': role},
    );
    return _asMapPayload(response);
  }

  /// PATCH /v1/businesses/{business_id}/users/{user_id}
  /// Aggiorna il ruolo e lo scope di un operatore.
  Future<Map<String, dynamic>> updateBusinessUser({
    required int businessId,
    required int userId,
    required String role,
    String? scopeType,
    List<int>? locationIds,
    int? staffId,
  }) async {
    final data = <String, dynamic>{'role': role};
    if (scopeType != null) data['scope_type'] = scopeType;
    if (locationIds != null) data['location_ids'] = locationIds;
    if (staffId != null) {
      data['staff_id'] = staffId;
    } else if (role != 'staff') {
      // Clear staff link when moving away from staff role.
      data['staff_id'] = null;
    }

    final response = await patch(
      ApiConfig.businessUser(businessId, userId),
      data: data,
    );
    return _asMapPayload(response);
  }

  /// DELETE /v1/businesses/{business_id}/users/{user_id}
  /// Rimuove un operatore dal business.
  Future<void> removeBusinessUser({
    required int businessId,
    required int userId,
  }) async {
    await delete(ApiConfig.businessUser(businessId, userId));
  }

  /// GET /v1/me/business/{business_id}
  /// Ottiene il contesto dell'utente corrente per un business (scope_type, location_ids).
  Future<Map<String, dynamic>> getMyBusinessContext(int businessId) async {
    final response = await get('/v1/me/business/$businessId');
    return _asMapPayload(response);
  }

  // ========== BUSINESS INVITATIONS ==========

  /// GET /v1/businesses/{business_id}/invitations
  /// Lista inviti del business.
  Future<List<Map<String, dynamic>>> getBusinessInvitations(
    int businessId, {
    String status = 'pending',
  }) async {
    final response = await get(
      ApiConfig.businessInvitations(businessId),
      queryParameters: {'status': status},
    );
    final invitations = response['invitations'] ?? response['_list'];
    if (invitations is List) {
      return invitations.cast<Map<String, dynamic>>();
    }
    return const <Map<String, dynamic>>[];
  }

  /// POST /v1/businesses/{business_id}/invitations
  /// Crea un nuovo invito via email.
  Future<Map<String, dynamic>> createBusinessInvitation({
    required int businessId,
    required String email,
    required String role,
    String scopeType = 'business',
    List<int>? locationIds,
    int? staffId,
  }) async {
    final data = <String, dynamic>{
      'email': email,
      'role': role,
      'scope_type': scopeType,
    };
    if (locationIds != null && locationIds.isNotEmpty) {
      data['location_ids'] = locationIds;
    }
    if (staffId != null) {
      data['staff_id'] = staffId;
    }

    final response = await post(
      ApiConfig.businessInvitations(businessId),
      data: data,
    );
    return _asMapPayload(response);
  }

  /// DELETE /v1/businesses/{business_id}/invitations/{invitation_id}
  /// Revoca un invito pendente.
  Future<void> revokeBusinessInvitation({
    required int businessId,
    required int invitationId,
  }) async {
    await delete(ApiConfig.businessInvitation(businessId, invitationId));
  }

  /// GET /v1/invitations/{token}
  /// Dettagli di un invito (endpoint pubblico).
  Future<Map<String, dynamic>> getInvitationByToken(String token) async {
    final response = await get(ApiConfig.invitationByToken(token));
    return _asMapPayload(response);
  }

  /// POST /v1/invitations/{token}/accept
  /// Accetta un invito (richiede autenticazione).
  Future<Map<String, dynamic>> acceptInvitation(String token) async {
    final response = await post(ApiConfig.acceptInvitation(token));
    return _asMapPayload(response);
  }

  /// POST /v1/invitations/{token}/accept-public
  /// Accetta invito senza autenticazione (account gi√† esistente).
  Future<Map<String, dynamic>> acceptInvitationPublic(String token) async {
    final response = await post(ApiConfig.acceptInvitationPublic(token));
    return _asMapPayload(response);
  }

  /// POST /v1/invitations/{token}/decline
  /// Rifiuta un invito (richiede autenticazione).
  Future<Map<String, dynamic>> declineInvitation(String token) async {
    final response = await post(ApiConfig.declineInvitation(token));
    return _asMapPayload(response);
  }

  /// POST /v1/invitations/{token}/register
  /// Crea account operatore da invito e accetta invito.
  Future<Map<String, dynamic>> registerInvitation({
    required String token,
    required String firstName,
    required String lastName,
    required String password,
  }) async {
    final response = await post(
      ApiConfig.registerInvitation(token),
      data: {
        'first_name': firstName,
        'last_name': lastName,
        'password': password,
      },
    );
    final data = _asMapPayload(response);
    if (data['access_token'] is String) {
      _accessToken = data['access_token'] as String;
    }
    if (data['refresh_token'] is String) {
      await _tokenStorage.saveRefreshToken(data['refresh_token'] as String);
    }
    return data;
  }

  /// Normalizza payload map per endpoint legacy/nuovi.
  /// `_handleResponse` ritorna gi√† `data`, ma alcuni endpoint possono
  /// ancora essere wrappati in `{ data: {...} }`.
  Map<String, dynamic> _asMapPayload(Map<String, dynamic> response) {
    final nested = response['data'];
    if (nested is Map<String, dynamic>) {
      return nested;
    }
    return response;
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Staff Availability Exceptions
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Get all availability exceptions for all staff in a business
  /// GET /v1/businesses/{businessId}/staff/availability-exceptions
  Future<Map<int, List<Map<String, dynamic>>>>
  getStaffAvailabilityExceptionsAll(
    int businessId, {
    String? fromDate,
    String? toDate,
  }) async {
    final queryParams = <String, String>{};
    if (fromDate != null) queryParams['from_date'] = fromDate;
    if (toDate != null) queryParams['to_date'] = toDate;

    final response = await get(
      '/v1/businesses/$businessId/staff/availability-exceptions',
      queryParameters: queryParams,
    );

    // response = { exceptions: { staffId: [...], ... } }
    final exceptionsMap = response['exceptions'];
    if (exceptionsMap is! Map<String, dynamic>) {
      return const <int, List<Map<String, dynamic>>>{};
    }
    final Map<int, List<Map<String, dynamic>>> result = {};

    for (final entry in exceptionsMap.entries) {
      final staffId = int.parse(entry.key);
      final exceptionsList = (entry.value as List)
          .map((e) => Map<String, dynamic>.from(e as Map))
          .toList();
      result[staffId] = exceptionsList;
    }

    return result;
  }

  /// Get availability exceptions for a single staff member
  /// GET /v1/staff/{staffId}/availability-exceptions
  Future<List<Map<String, dynamic>>> getStaffAvailabilityExceptions(
    int staffId, {
    String? fromDate,
    String? toDate,
  }) async {
    final queryParams = <String, String>{};
    if (fromDate != null) queryParams['from_date'] = fromDate;
    if (toDate != null) queryParams['to_date'] = toDate;

    final response = await get(
      '/v1/staff/$staffId/availability-exceptions',
      queryParameters: queryParams,
    );

    // response = { staff_id: X, exceptions: [...] }
    final exceptions = (response['exceptions'] as List)
        .map((e) => Map<String, dynamic>.from(e as Map))
        .toList();
    return exceptions;
  }

  /// Create a new availability exception for a staff member
  /// POST /v1/staff/{staffId}/availability-exceptions
  Future<Map<String, dynamic>> createStaffAvailabilityException({
    required int staffId,
    required String date,
    String? startTime,
    String? endTime,
    String type = 'unavailable',
    String? reasonCode,
    String? reason,
  }) async {
    final data = <String, dynamic>{'date': date, 'type': type};
    if (startTime != null) data['start_time'] = startTime;
    if (endTime != null) data['end_time'] = endTime;
    if (reasonCode != null) data['reason_code'] = reasonCode;
    if (reason != null) data['reason'] = reason;

    final response = await post(
      '/v1/staff/$staffId/availability-exceptions',
      data: data,
    );

    // response = { exception: {...} }
    return Map<String, dynamic>.from(response['exception'] as Map);
  }

  /// Update an existing availability exception
  /// PUT /v1/staff/availability-exceptions/{exceptionId}
  Future<Map<String, dynamic>> updateStaffAvailabilityException({
    required int exceptionId,
    String? date,
    String? startTime,
    String? endTime,
    String? type,
    String? reasonCode,
    String? reason,
  }) async {
    final data = <String, dynamic>{};
    if (date != null) data['date'] = date;
    if (startTime != null) data['start_time'] = startTime;
    if (endTime != null) data['end_time'] = endTime;
    if (type != null) data['type'] = type;
    if (reasonCode != null) data['reason_code'] = reasonCode;
    if (reason != null) data['reason'] = reason;

    final response = await put(
      '/v1/staff/availability-exceptions/$exceptionId',
      data: data,
    );

    // response = { exception: {...} }
    return Map<String, dynamic>.from(response['exception'] as Map);
  }

  /// Delete an availability exception
  /// DELETE /v1/staff/availability-exceptions/{exceptionId}
  Future<void> deleteStaffAvailabilityException(int exceptionId) async {
    await delete('/v1/staff/availability-exceptions/$exceptionId');
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Resources
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Get all resources for a business
  /// GET /v1/businesses/{businessId}/resources
  Future<List<Map<String, dynamic>>> getResourcesByBusiness(
    int businessId,
  ) async {
    final response = await get('/v1/businesses/$businessId/resources');
    return (response['resources'] as List)
        .map((r) => Map<String, dynamic>.from(r as Map))
        .toList();
  }

  /// Get resources for a location
  /// GET /v1/locations/{locationId}/resources
  Future<List<Map<String, dynamic>>> getResourcesByLocation(
    int locationId,
  ) async {
    final response = await get('/v1/locations/$locationId/resources');
    return (response['resources'] as List)
        .map((r) => Map<String, dynamic>.from(r as Map))
        .toList();
  }

  /// Create a new resource
  /// POST /v1/locations/{locationId}/resources
  Future<Map<String, dynamic>> createResource({
    required int locationId,
    required String name,
    String? type,
    int quantity = 1,
    String? note,
    int sortOrder = 0,
  }) async {
    final response = await post(
      '/v1/locations/$locationId/resources',
      data: {
        'name': name,
        if (type != null) 'type': type,
        'quantity': quantity,
        if (note != null) 'note': note,
        'sort_order': sortOrder,
      },
    );
    return Map<String, dynamic>.from(response['resource'] as Map);
  }

  /// Update a resource
  /// PUT /v1/resources/{resourceId}
  Future<Map<String, dynamic>> updateResource({
    required int resourceId,
    String? name,
    String? type,
    int? quantity,
    String? note,
    int? sortOrder,
  }) async {
    final data = <String, dynamic>{};
    if (name != null) data['name'] = name;
    if (type != null) data['type'] = type;
    if (quantity != null) data['quantity'] = quantity;
    if (note != null) data['note'] = note;
    if (sortOrder != null) data['sort_order'] = sortOrder;

    final response = await put('/v1/resources/$resourceId', data: data);
    return Map<String, dynamic>.from(response['resource'] as Map);
  }

  /// Delete a resource
  /// DELETE /v1/resources/{resourceId}
  Future<void> deleteResource(int resourceId) async {
    await delete('/v1/resources/$resourceId');
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Time Blocks
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Get time blocks for a location in a date range
  /// GET /v1/locations/{locationId}/time-blocks
  Future<List<Map<String, dynamic>>> getTimeBlocks(
    int locationId, {
    String? fromDate,
    String? toDate,
  }) async {
    final queryParams = <String, String>{};
    if (fromDate != null) queryParams['from_date'] = fromDate;
    if (toDate != null) queryParams['to_date'] = toDate;

    final response = await get(
      '/v1/locations/$locationId/time-blocks',
      queryParameters: queryParams,
    );
    return (response['time_blocks'] as List)
        .map((b) => Map<String, dynamic>.from(b as Map))
        .toList();
  }

  /// Create a new time block
  /// POST /v1/locations/{locationId}/time-blocks
  Future<Map<String, dynamic>> createTimeBlock({
    required int locationId,
    required String startTime,
    required String endTime,
    required List<int> staffIds,
    bool isAllDay = false,
    String? reason,
  }) async {
    final response = await post(
      '/v1/locations/$locationId/time-blocks',
      data: {
        'start_time': startTime,
        'end_time': endTime,
        'staff_ids': staffIds,
        'is_all_day': isAllDay,
        if (reason != null) 'reason': reason,
      },
    );
    return Map<String, dynamic>.from(response['time_block'] as Map);
  }

  /// Update a time block
  /// PUT /v1/time-blocks/{blockId}
  Future<Map<String, dynamic>> updateTimeBlock({
    required int blockId,
    String? startTime,
    String? endTime,
    List<int>? staffIds,
    bool? isAllDay,
    String? reason,
  }) async {
    final data = <String, dynamic>{};
    if (startTime != null) data['start_time'] = startTime;
    if (endTime != null) data['end_time'] = endTime;
    if (staffIds != null) data['staff_ids'] = staffIds;
    if (isAllDay != null) data['is_all_day'] = isAllDay;
    if (reason != null) data['reason'] = reason;

    final response = await put('/v1/time-blocks/$blockId', data: data);
    return Map<String, dynamic>.from(response['time_block'] as Map);
  }

  /// Delete a time block
  /// DELETE /v1/time-blocks/{blockId}
  Future<void> deleteTimeBlock(int blockId) async {
    await delete('/v1/time-blocks/$blockId');
  }

  // ========== STAFF PLANNING ENDPOINTS ==========

  /// Get all plannings for a staff member
  /// GET /v1/staff/{staffId}/plannings
  Future<List<Map<String, dynamic>>> getStaffPlannings(int staffId) async {
    final response = await get(ApiConfig.staffPlannings(staffId));
    // _handleResponse wrappa le liste in {'_list': data}
    final plannings = response['_list'] as List<dynamic>? ?? [];
    return plannings.cast<Map<String, dynamic>>();
  }

  /// Get planning valid for a specific date
  /// GET /v1/staff/{staffId}/planning?date=YYYY-MM-DD
  Future<Map<String, dynamic>?> getStaffPlanningForDate({
    required int staffId,
    required String date,
  }) async {
    final response = await get(
      ApiConfig.staffPlanningForDate(staffId),
      queryParameters: {'date': date},
    );
    final planning = response['planning'];
    if (planning is Map<String, dynamic>) {
      return planning;
    }
    if (planning is Map) {
      return Map<String, dynamic>.from(planning);
    }
    return null;
  }

  /// Get available slots for a staff on a date
  /// GET /v1/staff/{staffId}/planning-availability?date=YYYY-MM-DD
  Future<List<int>> getStaffPlanningAvailability({
    required int staffId,
    required String date,
  }) async {
    final response = await get(
      ApiConfig.staffPlanningAvailability(staffId),
      queryParameters: {'date': date},
    );
    final slots = response['slots'] as List<dynamic>? ?? [];
    return slots.cast<int>();
  }

  /// Create a new staff planning
  /// POST /v1/staff/{staffId}/plannings
  Future<Map<String, dynamic>> createStaffPlanning({
    required int staffId,
    required String type,
    required String validFrom,
    String? validTo,
    required List<Map<String, dynamic>> templates,
  }) async {
    // _handleResponse gi√† estrae body['data'], quindi response √à il planning
    final response = await post(
      ApiConfig.staffPlannings(staffId),
      data: {
        'type': type,
        'valid_from': validFrom,
        if (validTo != null) 'valid_to': validTo,
        'templates': templates,
      },
    );
    return Map<String, dynamic>.from(response);
  }

  /// Update an existing staff planning
  /// PUT /v1/staff/{staffId}/plannings/{planningId}
  Future<Map<String, dynamic>> updateStaffPlanning({
    required int staffId,
    required int planningId,
    String? type,
    String? validFrom,
    String? validTo,
    bool setValidToNull = false,
    List<Map<String, dynamic>>? templates,
  }) async {
    final data = <String, dynamic>{};
    if (type != null) data['type'] = type;
    if (validFrom != null) data['valid_from'] = validFrom;
    if (validTo != null) {
      data['valid_to'] = validTo;
    } else if (setValidToNull) {
      data['valid_to'] = null;
    }
    if (templates != null) data['templates'] = templates;

    // _handleResponse gi√† estrae body['data'], quindi response √à il planning
    final response = await put(
      ApiConfig.staffPlanning(staffId, planningId),
      data: data,
    );
    return Map<String, dynamic>.from(response);
  }

  /// Delete a staff planning
  /// DELETE /v1/staff/{staffId}/plannings/{planningId}
  Future<void> deleteStaffPlanning(int staffId, int planningId) async {
    await delete(ApiConfig.staffPlanning(staffId, planningId));
  }

  // ==========================================================================
  // CLOSURES (Chiusure multi-location)
  // ==========================================================================

  /// Recupera tutte le chiusure per un business
  Future<List<LocationClosure>> getClosures(int businessId) async {
    try {
      final response = await _dio.get('/v1/businesses/$businessId/closures');
      final body = _bodyAsMapOrThrow(response);
      final data = body['data'] as Map<String, dynamic>? ?? body;
      final List<dynamic> closures = data['closures'] ?? [];
      return closures
          .map((json) => LocationClosure.fromJson(json as Map<String, dynamic>))
          .toList();
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Recupera le chiusure di un business in un range di date specifico
  Future<List<LocationClosure>> getClosuresInRange({
    required int businessId,
    required DateTime startDate,
    required DateTime endDate,
    int? locationId,
  }) async {
    try {
      final response = await _dio.get(
        '/v1/businesses/$businessId/closures/in-range',
        queryParameters: {
          'start_date': startDate.toIso8601String().split('T').first,
          'end_date': endDate.toIso8601String().split('T').first,
          if (locationId != null) 'location_id': locationId,
        },
      );
      final body = _bodyAsMapOrThrow(response);
      final data = body['data'] as Map<String, dynamic>? ?? body;
      final List<dynamic> closures = data['closures'] ?? [];
      return closures
          .map((json) => LocationClosure.fromJson(json as Map<String, dynamic>))
          .toList();
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Crea una nuova chiusura (applicabile a pi√π location)
  Future<LocationClosure> createClosure({
    required int businessId,
    required List<int> locationIds,
    required DateTime startDate,
    required DateTime endDate,
    String? reason,
  }) async {
    try {
      final response = await _dio.post(
        '/v1/businesses/$businessId/closures',
        data: {
          'location_ids': locationIds,
          'start_date': startDate.toIso8601String().split('T').first,
          'end_date': endDate.toIso8601String().split('T').first,
          if (reason != null && reason.isNotEmpty) 'reason': reason,
        },
      );
      final body = _bodyAsMapOrThrow(response);
      final data = body['data'] is Map<String, dynamic>
          ? body['data'] as Map<String, dynamic>
          : body;
      return LocationClosure.fromJson(data);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Aggiorna una chiusura esistente
  Future<LocationClosure> updateClosure({
    required int closureId,
    required List<int> locationIds,
    required DateTime startDate,
    required DateTime endDate,
    String? reason,
  }) async {
    try {
      final response = await _dio.put(
        '/v1/closures/$closureId',
        data: {
          'location_ids': locationIds,
          'start_date': startDate.toIso8601String().split('T').first,
          'end_date': endDate.toIso8601String().split('T').first,
          if (reason != null) 'reason': reason,
        },
      );
      final body = _bodyAsMapOrThrow(response);
      final data = body['data'] is Map<String, dynamic>
          ? body['data'] as Map<String, dynamic>
          : body;
      return LocationClosure.fromJson(data);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Elimina una chiusura
  Future<void> deleteClosure(int closureId) async {
    try {
      await _dio.delete('/v1/closures/$closureId');
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }
}
--- FILE: lib/core/network/token_storage.dart ---
export 'token_storage_interface.dart';
// Conditional import: web vs mobile/desktop
export 'token_storage_mobile.dart'
    if (dart.library.html) 'token_storage_web.dart';
--- FILE: lib/core/utils/color_utils.dart ---
import 'package:flutter/material.dart';

class ColorUtils {
  /// Restituisce il colore in formato esadecimale '#RRGGBB' (senza alpha)
  static String toHex(Color color) {
    final int argb = color.toARGB32();
    // Prendi solo gli ultimi 6 caratteri (RGB, ignora alpha)
    return '#${argb.toRadixString(16).padLeft(8, '0').substring(2).toUpperCase()}';
  }

  /// Converte una stringa esadecimale '#AARRGGBB' o '#RRGGBB' in un Color
  static Color fromHex(String hexString) {
    final buffer = StringBuffer();
    // Se 6 caratteri (o 7 con #), aggiungi alpha FF
    if (hexString.length == 6 || hexString.length == 7) buffer.write('FF');
    buffer.write(hexString.replaceFirst('#', ''));
    return Color(int.parse(buffer.toString(), radix: 16));
  }
}
--- FILE: lib/core/utils/price_utils.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../features/agenda/providers/business_providers.dart';
import '../../features/agenda/providers/location_providers.dart';
import '../l10n/l10_extension.dart'; // ‚úÖ per usare context.l10n
import '../models/service_variant.dart';

/// Utility per formattazione e parsing dei prezzi, coerente con la valuta
/// effettiva del business o della location.
///
/// üîπ Integra:
/// - Formattazione localizzata tramite [Intl.NumberFormat]
/// - Fallback automatico sul locale corrente
/// - Metodo [parse] per convertire input utente (es. ‚Äú‚Ç¨45,90‚Äù) in `double`
/// - Metodo [formatService] per mostrare prezzo e label standard (‚Äúa partire da‚Ä¶‚Äù)
class PriceFormatter {
  const PriceFormatter._();

  /// Restituisce la valuta effettiva in base a location o business.
  static String effectiveCurrency(WidgetRef ref) {
    final locationCurrency = ref.watch(currentLocationProvider).currency;
    final businessCurrency = ref.watch(currentBusinessProvider).currency;
    return locationCurrency ?? businessCurrency;
  }

  /// Formatta un prezzo numerico [amount] nella valuta indicata.
  ///
  /// Utilizza sempre il simbolo della valuta e rispetta la locale dell'app.
  static String format({
    required BuildContext context,
    required double amount,
    required String currencyCode,
    String? forcedLocale,
  }) {
    // Locale derivata dal contesto o dal parametro forzato
    final localeFromContext = Localizations.localeOf(context).toString();
    final currentLocale = forcedLocale ?? localeFromContext;

    try {
      // Usa simpleCurrency per ottenere il simbolo (‚Ç¨, $, ¬£, ecc.)
      final formatter = NumberFormat.simpleCurrency(
        name: currencyCode,
        locale: currentLocale,
      );
      return formatter.format(amount);
    } catch (_) {
      // Se la locale non √® supportata, prova con la locale dell'app
      try {
        final fallbackFormatter = NumberFormat.simpleCurrency(
          name: currencyCode,
          locale: Intl.getCurrentLocale(),
        );
        return fallbackFormatter.format(amount);
      } catch (_) {
        // Ultimo fallback su 'it_IT' (anzich√© en_US)
        final lastResortFormatter = NumberFormat.simpleCurrency(
          name: currencyCode,
          locale: 'it_IT',
        );
        return lastResortFormatter.format(amount);
      }
    }
  }

  /// Converte una stringa di input (es. ‚Äú‚Ç¨ 45,90‚Äù, ‚Äú45.00‚Äù, ‚ÄúCHF 120‚Äù) in `double`.
  ///
  /// Rimuove simboli e caratteri non numerici, normalizzando la virgola in punto.
  static double? parse(String input) {
    if (input.trim().isEmpty) return null;

    final cleaned = input
        .replaceAll(RegExp(r'[^0-9,.\-]'), '')
        .replaceAll(',', '.');

    return double.tryParse(cleaned);
  }

  /// Formatta un [ServiceVariant] tenendo conto delle impostazioni di valuta e
  /// dei flag `isFree` e `isPriceStartingFrom`.
  static String formatVariant({
    required BuildContext context,
    required WidgetRef ref,
    required ServiceVariant variant,
  }) {
    final currency = variant.currency ?? effectiveCurrency(ref);

    if (variant.isFree) return context.l10n.freeLabel;
    if (variant.price <= 0) return context.l10n.priceNotAvailable;

    final formatted = format(
      context: context,
      amount: variant.price,
      currencyCode: currency,
    );

    return variant.isPriceStartingFrom
        ? '${context.l10n.priceStartingFromPrefix} $formatted'
        : formatted;
  }
}
--- FILE: lib/core/utils/initials_utils.dart ---
import 'package:characters/characters.dart';

/// Utility per generare iniziali in modo Unicode-safe (emoji incluse).
class InitialsUtils {
  const InitialsUtils._();

  static String fromName(String name, {int maxChars = 3}) {
    final trimmed = name.trim();
    if (trimmed.isEmpty || maxChars <= 0) return '';

    final parts = trimmed.split(RegExp(r'\s+')).where((p) => p.isNotEmpty);
    final initials = <String>[];

    final partList = parts.toList();
    if (partList.isNotEmpty) {
      initials.add(_firstGrapheme(partList.first));
    }

    for (int i = 1; i < partList.length && initials.length < maxChars; i++) {
      initials.add(_firstGrapheme(partList[i]));
    }

    if (partList.length == 1 && initials.length < maxChars) {
      final graphemes = trimmed.characters;
      if (graphemes.length > 1) {
        initials.add(graphemes.skip(1).first);
      }
    }

    return initials
        .map((g) => g.toUpperCase())
        .take(maxChars)
        .toList()
        .join();
  }

  static int length(String value) => value.characters.length;

  static String _firstGrapheme(String value) => value.characters.first;
}
--- FILE: lib/core/utils/string_utils.dart ---
/// Utility per la manipolazione delle stringhe
class StringUtils {
  const StringUtils._();

  /// Capitalizza la prima lettera di ogni parola (Title Case)
  /// Es: "mario rossi" ‚Üí "Mario Rossi"
  /// Es: "GIOVANNI BIANCHI" ‚Üí "Giovanni Bianchi"
  static String toTitleCase(String raw) {
    final trimmed = raw.trim();
    if (trimmed.isEmpty) return trimmed;

    final parts = trimmed.split(' ');
    return parts
        .map(
          (w) => w.isEmpty
              ? ''
              : '${w[0].toUpperCase()}${w.substring(1).toLowerCase()}',
        )
        .join(' ');
  }

  /// Capitalizza solo la prima lettera della stringa
  /// Es: "mario rossi" ‚Üí "Mario rossi"
  static String capitalize(String raw) {
    final trimmed = raw.trim();
    if (trimmed.isEmpty) return trimmed;
    return '${trimmed[0].toUpperCase()}${trimmed.substring(1).toLowerCase()}';
  }

  /// Capitalizza la prima lettera, mantenendo il resto invariato
  /// Es: "mario ROSSI" ‚Üí "Mario ROSSI"
  static String capitalizeFirst(String raw) {
    final trimmed = raw.trim();
    if (trimmed.isEmpty) return trimmed;
    return '${trimmed[0].toUpperCase()}${trimmed.substring(1)}';
  }
}
--- FILE: lib/core/utils/app_version.dart ---
import 'dart:js_interop';

@JS('appVersion')
external JSString? get _appVersion;

/// Legge la versione dell'app definita in index.html.
/// Formato: YYYYMMDD-N (es. 20260117-1)
String getAppVersion() {
  try {
    final version = _appVersion;
    if (version != null) {
      return version.toDart;
    }
  } catch (_) {
    // Fallback se JS interop fallisce
  }
  return 'dev';
}
--- FILE: lib/core/utils/date_utils.dart ---
--- FILE: lib/core/models/hour_range.dart ---

--- FILE: lib/core/models/appointment.dart ---
enum ExtraMinutesType { processing, blocked }

ExtraMinutesType? _extraMinutesTypeFromJson(Object? value) {
  if (value is String) {
    for (final type in ExtraMinutesType.values) {
      if (type.name == value) {
        return type;
      }
    }
  }
  return null;
}

String? _extraMinutesTypeToJson(ExtraMinutesType? value) {
  return value?.name;
}

String? _bookingStatusFromJson(Map<String, dynamic> json) {
  final value = (json['booking_status'] ?? json['status']);
  if (value is! String) return null;

  // Avoid accidentally mapping unrelated `status` fields from other payloads.
  const allowed = <String>{
    'pending',
    'confirmed',
    'cancelled',
    'completed',
    'no_show',
    'replaced',
  };
  return allowed.contains(value) ? value : null;
}

class Appointment {
  final int id;
  final int bookingId;
  final int businessId;
  final int locationId;
  final int staffId;
  final int serviceId;
  final int serviceVariantId;
  final int? clientId; // opzionale: collegamento al Client
  final String clientName;
  final String serviceName;
  final DateTime startTime;
  final DateTime endTime;
  final double? price; // prezzo applicato al singolo appuntamento
  final String? bookingSource;
  final String? bookingStatus; // pending, confirmed, replaced, cancelled
  // Legacy single extra fields (kept for backward compatibility)
  final int? extraMinutes;
  final ExtraMinutesType? extraMinutesType;
  // New split extras
  final int? extraBlockedMinutes;
  final int? extraProcessingMinutes;
  // Campi ricorrenza (ereditati dal booking)
  final int? recurrenceRuleId;
  final int? recurrenceIndex;
  final int? recurrenceTotal;

  const Appointment({
    required this.id,
    required this.bookingId,
    required this.businessId,
    required this.locationId,
    required this.staffId,
    required this.serviceId,
    required this.serviceVariantId,
    this.clientId,
    required this.clientName,
    required this.serviceName,
    required this.startTime,
    required this.endTime,
    this.price,
    this.bookingSource,
    this.bookingStatus,
    this.extraMinutes,
    this.extraMinutesType,
    this.extraBlockedMinutes,
    this.extraProcessingMinutes,
    this.recurrenceRuleId,
    this.recurrenceIndex,
    this.recurrenceTotal,
  });

  /// Returns true if this appointment's booking was cancelled
  bool get isCancelled => bookingStatus == 'cancelled';

  /// Returns true if this appointment's booking was replaced
  bool get isReplaced => bookingStatus == 'replaced';

  /// Returns true if this appointment is part of a recurring series
  bool get isRecurring => recurrenceRuleId != null;

  factory Appointment.fromJson(Map<String, dynamic> json) => Appointment(
    id: json['id'] as int,
    bookingId: json['booking_id'] as int,
    businessId: json['business_id'] as int,
    locationId: json['location_id'] as int,
    staffId: json['staff_id'] as int,
    serviceId: json['service_id'] as int,
    serviceVariantId: json['service_variant_id'] as int,
    clientId: json['client_id'] as int?,
    clientName: json['client_name'] as String? ?? '',
    serviceName: json['service_name'] as String? ?? '',
    startTime: DateTime.parse(json['start_time'] as String),
    endTime: DateTime.parse(json['end_time'] as String),
    price: json['price'] != null ? (json['price'] as num).toDouble() : null,
    bookingSource: json['source'] as String?,
    bookingStatus: _bookingStatusFromJson(json),
    extraMinutes: json['extra_minutes'] as int?,
    extraMinutesType: _extraMinutesTypeFromJson(json['extra_minutes_type']),
    extraBlockedMinutes: json['extra_blocked_minutes'] as int?,
    extraProcessingMinutes: json['extra_processing_minutes'] as int?,
    recurrenceRuleId: json['recurrence_rule_id'] as int?,
    recurrenceIndex: json['recurrence_index'] as int?,
    recurrenceTotal: json['recurrence_total'] as int?,
  );

  Appointment copyWith({
    int? id,
    int? bookingId,
    int? businessId,
    int? locationId,
    int? staffId,
    int? serviceId,
    int? serviceVariantId,
    int? clientId,
    String? clientName,
    String? serviceName,
    DateTime? startTime,
    DateTime? endTime,
    double? price,
    String? bookingSource,
    String? bookingStatus,
    int? extraMinutes,
    ExtraMinutesType? extraMinutesType,
    int? extraBlockedMinutes,
    int? extraProcessingMinutes,
    int? recurrenceRuleId,
    int? recurrenceIndex,
    int? recurrenceTotal,
  }) {
    return Appointment(
      id: id ?? this.id,
      bookingId: bookingId ?? this.bookingId,
      businessId: businessId ?? this.businessId,
      locationId: locationId ?? this.locationId,
      staffId: staffId ?? this.staffId,
      serviceId: serviceId ?? this.serviceId,
      serviceVariantId: serviceVariantId ?? this.serviceVariantId,
      clientId: clientId ?? this.clientId,
      clientName: clientName ?? this.clientName,
      serviceName: serviceName ?? this.serviceName,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      price: price ?? this.price,
      bookingSource: bookingSource ?? this.bookingSource,
      bookingStatus: bookingStatus ?? this.bookingStatus,
      extraMinutes: extraMinutes ?? this.extraMinutes,
      extraMinutesType: extraMinutesType ?? this.extraMinutesType,
      extraBlockedMinutes: extraBlockedMinutes ?? this.extraBlockedMinutes,
      extraProcessingMinutes:
          extraProcessingMinutes ?? this.extraProcessingMinutes,
      recurrenceRuleId: recurrenceRuleId ?? this.recurrenceRuleId,
      recurrenceIndex: recurrenceIndex ?? this.recurrenceIndex,
      recurrenceTotal: recurrenceTotal ?? this.recurrenceTotal,
    );
  }

  Map<String, dynamic> toJson() {
    final blocked = blockedExtraMinutes;
    final processing = processingExtraMinutes;
    final legacyType = blocked > 0
        ? ExtraMinutesType.blocked
        : (processing > 0 ? ExtraMinutesType.processing : null);
    final legacyMinutes = legacyType == ExtraMinutesType.blocked
        ? blocked
        : (legacyType == ExtraMinutesType.processing ? processing : null);
    return {
      'id': id,
      'booking_id': bookingId,
      'business_id': businessId,
      'location_id': locationId,
      'staff_id': staffId,
      'service_id': serviceId,
      'service_variant_id': serviceVariantId,
      if (clientId != null) 'client_id': clientId,
      'client_name': clientName,
      'service_name': serviceName,
      'start_time': startTime.toIso8601String(),
      'end_time': endTime.toIso8601String(),
      if (price != null) 'price': price,
      if (bookingSource != null) 'source': bookingSource,
      if (legacyMinutes != null) 'extra_minutes': legacyMinutes,
      if (legacyType != null)
        'extra_minutes_type': _extraMinutesTypeToJson(legacyType),
      if (extraBlockedMinutes != null)
        'extra_blocked_minutes': extraBlockedMinutes,
      if (extraProcessingMinutes != null)
        'extra_processing_minutes': extraProcessingMinutes,
    };
  }

  int get blockedExtraMinutes {
    if (extraBlockedMinutes != null) return extraBlockedMinutes!;
    if (extraMinutesType == ExtraMinutesType.blocked) {
      return extraMinutes ?? 0;
    }
    return 0;
  }

  int get processingExtraMinutes {
    if (extraProcessingMinutes != null) return extraProcessingMinutes!;
    if (extraMinutesType == ExtraMinutesType.processing) {
      return extraMinutes ?? 0;
    }
    return 0;
  }

  int get totalDuration => endTime.difference(startTime).inMinutes;

  String get formattedPrice {
    if (price == null || price == 0) return '';
    return '${price!.toStringAsFixed(2)}‚Ç¨';
  }
}
--- FILE: lib/core/models/recurrence_rule.dart ---
/// Modello per le regole di ricorrenza delle prenotazioni
class RecurrenceRule {
  final int id;
  final int businessId;
  final RecurrenceFrequency frequency;
  final int intervalValue;
  final int? maxOccurrences;
  final DateTime? endDate;
  final ConflictStrategy conflictStrategy;
  final List<int>? daysOfWeek;
  final int? dayOfMonth;
  final DateTime createdAt;
  final DateTime updatedAt;

  const RecurrenceRule({
    required this.id,
    required this.businessId,
    required this.frequency,
    this.intervalValue = 1,
    this.maxOccurrences,
    this.endDate,
    this.conflictStrategy = ConflictStrategy.skip,
    this.daysOfWeek,
    this.dayOfMonth,
    required this.createdAt,
    required this.updatedAt,
  });

  factory RecurrenceRule.fromJson(Map<String, dynamic> json) {
    return RecurrenceRule(
      id: json['id'] as int,
      businessId: json['business_id'] as int,
      frequency: RecurrenceFrequency.fromString(json['frequency'] as String),
      intervalValue: json['interval_value'] as int? ?? 1,
      maxOccurrences: json['max_occurrences'] as int?,
      endDate: json['end_date'] != null
          ? DateTime.parse(json['end_date'] as String)
          : null,
      conflictStrategy: ConflictStrategy.fromString(
        json['conflict_strategy'] as String? ?? 'skip',
      ),
      daysOfWeek: json['days_of_week'] != null
          ? List<int>.from(json['days_of_week'] as List)
          : null,
      dayOfMonth: json['day_of_month'] as int?,
      createdAt: DateTime.parse(json['created_at'] as String),
      updatedAt: DateTime.parse(json['updated_at'] as String),
    );
  }

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'frequency': frequency.value,
    'interval_value': intervalValue,
    if (maxOccurrences != null) 'max_occurrences': maxOccurrences,
    if (endDate != null) 'end_date': endDate!.toIso8601String().split('T')[0],
    'conflict_strategy': conflictStrategy.value,
    if (daysOfWeek != null) 'days_of_week': daysOfWeek,
    if (dayOfMonth != null) 'day_of_month': dayOfMonth,
    'created_at': createdAt.toIso8601String(),
    'updated_at': updatedAt.toIso8601String(),
  };

  RecurrenceRule copyWith({
    int? id,
    int? businessId,
    RecurrenceFrequency? frequency,
    int? intervalValue,
    int? maxOccurrences,
    DateTime? endDate,
    ConflictStrategy? conflictStrategy,
    List<int>? daysOfWeek,
    int? dayOfMonth,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return RecurrenceRule(
      id: id ?? this.id,
      businessId: businessId ?? this.businessId,
      frequency: frequency ?? this.frequency,
      intervalValue: intervalValue ?? this.intervalValue,
      maxOccurrences: maxOccurrences ?? this.maxOccurrences,
      endDate: endDate ?? this.endDate,
      conflictStrategy: conflictStrategy ?? this.conflictStrategy,
      daysOfWeek: daysOfWeek ?? this.daysOfWeek,
      dayOfMonth: dayOfMonth ?? this.dayOfMonth,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  /// Descrizione leggibile della ricorrenza (es. "Ogni 2 settimane")
  String toReadableString({String locale = 'it'}) {
    final interval = intervalValue;
    switch (frequency) {
      case RecurrenceFrequency.daily:
        if (interval == 1) {
          return locale == 'it' ? 'Ogni giorno' : 'Every day';
        }
        return locale == 'it'
            ? 'Ogni $interval giorni'
            : 'Every $interval days';
      case RecurrenceFrequency.weekly:
        if (interval == 1) {
          return locale == 'it' ? 'Ogni settimana' : 'Every week';
        }
        return locale == 'it'
            ? 'Ogni $interval settimane'
            : 'Every $interval weeks';
      case RecurrenceFrequency.monthly:
        if (interval == 1) {
          return locale == 'it' ? 'Ogni mese' : 'Every month';
        }
        return locale == 'it'
            ? 'Ogni $interval mesi'
            : 'Every $interval months';
      case RecurrenceFrequency.custom:
        return locale == 'it'
            ? 'Ogni $interval giorni'
            : 'Every $interval days';
    }
  }
}

/// Frequenza di ricorrenza
enum RecurrenceFrequency {
  daily('daily'),
  weekly('weekly'),
  monthly('monthly'),
  custom('custom');

  final String value;
  const RecurrenceFrequency(this.value);

  static RecurrenceFrequency fromString(String value) {
    return RecurrenceFrequency.values.firstWhere(
      (e) => e.value == value,
      orElse: () => RecurrenceFrequency.weekly,
    );
  }
}

/// Strategia per gestione conflitti
enum ConflictStrategy {
  skip('skip'),
  force('force');

  final String value;
  const ConflictStrategy(this.value);

  static ConflictStrategy fromString(String value) {
    return ConflictStrategy.values.firstWhere(
      (e) => e.value == value,
      orElse: () => ConflictStrategy.skip,
    );
  }
}

/// Configurazione per creare una nuova ricorrenza (lato UI)
class RecurrenceConfig {
  final RecurrenceFrequency frequency;
  final int intervalValue;
  final int? maxOccurrences;
  final DateTime? endDate;
  final ConflictStrategy conflictStrategy;

  const RecurrenceConfig({
    this.frequency = RecurrenceFrequency.weekly,
    this.intervalValue = 1,
    this.maxOccurrences,
    this.endDate,
    this.conflictStrategy = ConflictStrategy.skip,
  });

  /// Indica se la ricorrenza ha un termine definito
  bool get hasEnd => maxOccurrences != null || endDate != null;

  /// Converte in payload per API
  Map<String, dynamic> toApiPayload() => {
    'frequency': frequency.value,
    'interval_value': intervalValue,
    if (maxOccurrences != null) 'max_occurrences': maxOccurrences,
    if (endDate != null) 'end_date': endDate!.toIso8601String().split('T')[0],
    'conflict_strategy': conflictStrategy.value,
  };

  RecurrenceConfig copyWith({
    RecurrenceFrequency? frequency,
    int? intervalValue,
    int? maxOccurrences,
    bool clearMaxOccurrences = false,
    DateTime? endDate,
    bool clearEndDate = false,
    ConflictStrategy? conflictStrategy,
  }) {
    return RecurrenceConfig(
      frequency: frequency ?? this.frequency,
      intervalValue: intervalValue ?? this.intervalValue,
      maxOccurrences: clearMaxOccurrences
          ? null
          : (maxOccurrences ?? this.maxOccurrences),
      endDate: clearEndDate ? null : (endDate ?? this.endDate),
      conflictStrategy: conflictStrategy ?? this.conflictStrategy,
    );
  }

  /// Calcola le date delle occorrenze a partire da una data iniziale
  List<DateTime> calculateOccurrences(
    DateTime startDate, {
    int maxPreview = 365,
  }) {
    final dates = <DateTime>[startDate];
    var current = startDate;

    // Se maxOccurrences √® specificato, usa quello
    // Altrimenti ("Mai"), calcola fino a 1 anno dalla data iniziale
    final limit = maxOccurrences ?? maxPreview;
    final maxEndDate = endDate ?? startDate.add(const Duration(days: 365));

    while (dates.length < limit) {
      switch (frequency) {
        case RecurrenceFrequency.daily:
        case RecurrenceFrequency.custom:
          current = current.add(Duration(days: intervalValue));
        case RecurrenceFrequency.weekly:
          current = current.add(Duration(days: 7 * intervalValue));
        case RecurrenceFrequency.monthly:
          current = DateTime(
            current.year,
            current.month + intervalValue,
            current.day,
            current.hour,
            current.minute,
            current.second,
            current.millisecond,
            current.microsecond,
          );
      }

      // Verifica se superato end_date (o limite 1 anno per "Mai")
      if (current.isAfter(maxEndDate)) {
        break;
      }

      dates.add(current);
    }

    return dates;
  }
}
--- FILE: lib/core/models/business_invitation.dart ---
/// Rappresenta un invito pendente per un utente.
class BusinessInvitation {
  final int id;
  final int businessId;
  final String email;
  final String role;
  final int? staffId;
  final String scopeType; // 'business' o 'locations'
  final List<int>
  locationIds; // IDs delle location accessibili (se scopeType='locations')
  final String? token;
  final String status;
  final DateTime? acceptedAt;
  final DateTime expiresAt;
  final DateTime createdAt;
  final InviterInfo invitedBy;

  const BusinessInvitation({
    required this.id,
    required this.businessId,
    required this.email,
    required this.role,
    this.staffId,
    this.scopeType = 'business',
    this.locationIds = const [],
    this.token,
    this.status = 'pending',
    this.acceptedAt,
    required this.expiresAt,
    required this.createdAt,
    required this.invitedBy,
  });

  /// Verifica se l'invito √® scaduto.
  bool get isExpired => effectiveStatus == 'expired';

  /// Stato calcolato lato client (supporta pending gi√† scaduti).
  String get effectiveStatus {
    if (status == 'pending' && DateTime.now().isAfter(expiresAt)) {
      return 'expired';
    }
    return status;
  }

  bool get isPending => effectiveStatus == 'pending';

  /// Indica se l'invito √® per tutte le location.
  bool get hasBusinessScope => scopeType == 'business';

  /// Indica se l'invito √® per location specifiche.
  bool get hasLocationScope => scopeType == 'locations';

  /// Etichetta tradotta per il ruolo.
  String get roleLabel => switch (role) {
    'admin' => 'Amministratore',
    'manager' => 'Manager',
    'staff' => 'Staff',
    'viewer' => 'Visualizzatore',
    _ => role,
  };

  BusinessInvitation copyWith({
    int? id,
    int? businessId,
    String? email,
    String? role,
    int? staffId,
    String? scopeType,
    List<int>? locationIds,
    String? token,
    String? status,
    DateTime? acceptedAt,
    DateTime? expiresAt,
    DateTime? createdAt,
    InviterInfo? invitedBy,
  }) => BusinessInvitation(
    id: id ?? this.id,
    businessId: businessId ?? this.businessId,
    email: email ?? this.email,
    role: role ?? this.role,
    staffId: staffId ?? this.staffId,
    scopeType: scopeType ?? this.scopeType,
    locationIds: locationIds ?? this.locationIds,
    token: token ?? this.token,
    status: status ?? this.status,
    acceptedAt: acceptedAt ?? this.acceptedAt,
    expiresAt: expiresAt ?? this.expiresAt,
    createdAt: createdAt ?? this.createdAt,
    invitedBy: invitedBy ?? this.invitedBy,
  );

  factory BusinessInvitation.fromJson(Map<String, dynamic> json) {
    final invitedByData = json['invited_by'] as Map<String, dynamic>?;
    final now = DateTime.now();
    return BusinessInvitation(
      id: _asInt(json['id']),
      businessId: _asInt(json['business_id']),
      email: json['email'] as String? ?? '',
      role: json['role'] as String? ?? 'staff',
      staffId: json['staff_id'] != null ? _asInt(json['staff_id']) : null,
      scopeType: json['scope_type'] as String? ?? 'business',
      locationIds:
          (json['location_ids'] as List<dynamic>?)
              ?.map(_asInt)
              .where((e) => e > 0)
              .toList() ??
          [],
      token: json['token'] as String?,
      status:
          json['effective_status'] as String? ??
          json['status'] as String? ??
          'pending',
      acceptedAt: _parseDateTime(json['accepted_at']),
      expiresAt:
          _parseDateTime(json['expires_at']) ??
          now.add(const Duration(days: 7)),
      createdAt: _parseDateTime(json['created_at']) ?? now,
      invitedBy: invitedByData != null
          ? InviterInfo.fromJson(invitedByData)
          : const InviterInfo(firstName: '', lastName: ''),
    );
  }

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'email': email,
    'role': role,
    'staff_id': staffId,
    'scope_type': scopeType,
    'location_ids': locationIds,
    if (token != null) 'token': token,
    'status': status,
    if (acceptedAt != null) 'accepted_at': acceptedAt!.toIso8601String(),
    'expires_at': expiresAt.toIso8601String(),
    'created_at': createdAt.toIso8601String(),
    'invited_by': invitedBy.toJson(),
  };

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BusinessInvitation &&
          runtimeType == other.runtimeType &&
          id == other.id;

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() =>
      'BusinessInvitation(id: $id, email: $email, role: $role, scopeType: $scopeType)';
}

int _asInt(Object? value) {
  if (value is int) return value;
  if (value is num) return value.toInt();
  if (value is String) return int.tryParse(value) ?? 0;
  return 0;
}

DateTime? _parseDateTime(Object? value) {
  if (value is! String || value.isEmpty) return null;
  return DateTime.tryParse(value);
}

/// Informazioni sull'utente che ha inviato l'invito.
class InviterInfo {
  final String firstName;
  final String lastName;

  const InviterInfo({required this.firstName, required this.lastName});

  String get fullName => '$firstName $lastName'.trim();

  factory InviterInfo.fromJson(Map<String, dynamic> json) => InviterInfo(
    firstName: json['first_name'] as String? ?? '',
    lastName: json['last_name'] as String? ?? '',
  );

  Map<String, dynamic> toJson() => {
    'first_name': firstName,
    'last_name': lastName,
  };
}
--- FILE: lib/core/models/business_user.dart ---
/// Rappresenta un utente associato a un business (operatore).
class BusinessUser {
  final int id;
  final int userId;
  final int businessId;
  final String role;
  final int? staffId;
  final String scopeType; // 'business' o 'locations'
  final List<int>
  locationIds; // IDs delle location accessibili (se scopeType='locations')
  final String email;
  final String firstName;
  final String lastName;
  final String status;
  final DateTime? invitedAt;
  final DateTime? joinedAt;
  final bool isCurrentUser;

  const BusinessUser({
    required this.id,
    required this.userId,
    required this.businessId,
    required this.role,
    this.staffId,
    this.scopeType = 'business',
    this.locationIds = const [],
    required this.email,
    required this.firstName,
    required this.lastName,
    required this.status,
    this.invitedAt,
    this.joinedAt,
    this.isCurrentUser = false,
  });

  /// Nome completo dell'utente.
  String get fullName => '$firstName $lastName'.trim();

  /// Indica se l'utente ha un ruolo admin o superiore.
  bool get isAdmin => role == 'owner' || role == 'admin';

  /// Indica se l'utente pu√≤ gestire altri utenti (owner o admin).
  bool get canManageUsers => role == 'owner' || role == 'admin';

  /// Indica se l'utente ha accesso a tutte le location.
  bool get hasBusinessScope => scopeType == 'business';

  /// Indica se l'utente ha accesso limitato a location specifiche.
  bool get hasLocationScope => scopeType == 'locations';

  /// Etichetta tradotta per il ruolo.
  String get roleLabel => switch (role) {
    'owner' => 'Proprietario',
    'admin' => 'Amministratore',
    'manager' => 'Manager',
    'staff' => 'Staff',
    'viewer' => 'Visualizzatore',
    _ => role,
  };

  BusinessUser copyWith({
    int? id,
    int? userId,
    int? businessId,
    String? role,
    int? staffId,
    String? scopeType,
    List<int>? locationIds,
    String? email,
    String? firstName,
    String? lastName,
    String? status,
    DateTime? invitedAt,
    DateTime? joinedAt,
    bool? isCurrentUser,
  }) => BusinessUser(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    businessId: businessId ?? this.businessId,
    role: role ?? this.role,
    staffId: staffId ?? this.staffId,
    scopeType: scopeType ?? this.scopeType,
    locationIds: locationIds ?? this.locationIds,
    email: email ?? this.email,
    firstName: firstName ?? this.firstName,
    lastName: lastName ?? this.lastName,
    status: status ?? this.status,
    invitedAt: invitedAt ?? this.invitedAt,
    joinedAt: joinedAt ?? this.joinedAt,
    isCurrentUser: isCurrentUser ?? this.isCurrentUser,
  );

  factory BusinessUser.fromJson(Map<String, dynamic> json) => BusinessUser(
    id: _asInt(json['id']),
    userId: _asInt(json['user_id']),
    businessId: _asInt(json['business_id']),
    role: json['role'] as String,
    staffId: json['staff_id'] != null ? _asInt(json['staff_id']) : null,
    scopeType: json['scope_type'] as String? ?? 'business',
    locationIds:
        (json['location_ids'] as List<dynamic>?)
            ?.map(_asInt)
            .where((e) => e > 0)
            .toList() ??
        [],
    email: json['email'] as String? ?? json['user']?['email'] as String? ?? '',
    firstName:
        json['first_name'] as String? ??
        json['user']?['first_name'] as String? ??
        '',
    lastName:
        json['last_name'] as String? ??
        json['user']?['last_name'] as String? ??
        '',
    status: json['status'] as String? ?? 'active',
    invitedAt: json['invited_at'] != null
        ? DateTime.parse(json['invited_at'] as String)
        : null,
    joinedAt: json['joined_at'] != null
        ? DateTime.parse(json['joined_at'] as String)
        : (json['accepted_at'] != null
              ? DateTime.parse(json['accepted_at'] as String)
              : null),
    isCurrentUser: json['is_current_user'] as bool? ?? false,
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'user_id': userId,
    'business_id': businessId,
    'role': role,
    'staff_id': staffId,
    'scope_type': scopeType,
    'location_ids': locationIds,
    'email': email,
    'first_name': firstName,
    'last_name': lastName,
    'status': status,
    if (invitedAt != null) 'invited_at': invitedAt!.toIso8601String(),
    if (joinedAt != null) 'joined_at': joinedAt!.toIso8601String(),
    'is_current_user': isCurrentUser,
  };

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BusinessUser &&
          runtimeType == other.runtimeType &&
          id == other.id;

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() =>
      'BusinessUser(id: $id, email: $email, role: $role, scopeType: $scopeType)';
}

int _asInt(Object? value) {
  if (value is int) return value;
  if (value is num) return value.toInt();
  if (value is String) return int.tryParse(value) ?? 0;
  return 0;
}
--- FILE: lib/core/models/booking_list_item.dart ---
import 'package:flutter/material.dart';

import '/core/l10n/l10_extension.dart';
import 'appointment.dart';

/// Model per la visualizzazione nella lista prenotazioni.
/// Include dati aggregati (servizi, staff, date) per evitare join lato client.
class BookingListItem {
  final int id;
  final int businessId;
  final int locationId;
  final String? locationName;
  final int? clientId;
  final String? clientName;
  final String? clientEmail;
  final String? clientPhone;
  final String? notes;
  final String status;
  final String source;

  // Date aggregate
  final DateTime? firstStartTime;
  final DateTime? lastEndTime;
  final double totalPrice;

  // Liste aggregate (nomi separati da virgola)
  final String? serviceNames;
  final String? staffNames;

  // Info creazione
  final DateTime? createdAt;
  final String? creatorName;

  // Ricorrenza
  final int? recurrenceRuleId;
  final int? recurrenceIndex;

  // Items dettagliati (opzionale, per espansione)
  final List<Appointment>? items;

  const BookingListItem({
    required this.id,
    required this.businessId,
    required this.locationId,
    this.locationName,
    this.clientId,
    this.clientName,
    this.clientEmail,
    this.clientPhone,
    this.notes,
    this.status = 'confirmed',
    this.source = 'online',
    this.firstStartTime,
    this.lastEndTime,
    this.totalPrice = 0,
    this.serviceNames,
    this.staffNames,
    this.createdAt,
    this.creatorName,
    this.recurrenceRuleId,
    this.recurrenceIndex,
    this.items,
  });

  /// Se √® ricorrente
  bool get isRecurring => recurrenceRuleId != null;

  /// Status label localizzato
  String statusLabel(BuildContext context) {
    final l10n = context.l10n;
    switch (status) {
      case 'confirmed':
        return l10n.bookingsListStatusConfirmed;
      case 'cancelled':
        return l10n.bookingsListStatusCancelled;
      case 'completed':
        return l10n.bookingsListStatusCompleted;
      case 'no_show':
        return l10n.bookingsListStatusNoShow;
      case 'pending':
        return l10n.bookingsListStatusPending;
      default:
        return status;
    }
  }

  /// Source label localizzato
  String sourceLabel(BuildContext context) {
    final l10n = context.l10n;
    switch (source) {
      case 'online':
      case 'onlinestaff':
        return l10n.bookingsListSourceOnline;
      case 'phone':
        return l10n.bookingsListSourcePhone;
      case 'walk_in':
        return l10n.bookingsListSourceWalkIn;
      case 'internal':
        return l10n.bookingsListSourceInternal;
      default:
        return source;
    }
  }

  /// Colore status
  Color get statusColor {
    switch (status) {
      case 'confirmed':
        return Colors.green;
      case 'cancelled':
        return Colors.red;
      case 'completed':
        return Colors.blue;
      case 'no_show':
        return Colors.orange;
      case 'pending':
        return Colors.amber;
      default:
        return Colors.grey;
    }
  }

  /// Icona source
  IconData get sourceIcon {
    switch (source) {
      case 'online':
      case 'onlinestaff':
        return Icons.cloud_outlined;
      case 'phone':
        return Icons.phone;
      case 'walk_in':
        return Icons.person;
      case 'internal':
        return Icons.desktop_windows;
      default:
        return Icons.help_outline;
    }
  }

  factory BookingListItem.fromJson(Map<String, dynamic> json) {
    final itemsJson = json['items'] as List<dynamic>?;

    return BookingListItem(
      id: json['id'] as int,
      businessId: json['business_id'] as int,
      locationId: json['location_id'] as int,
      locationName: json['location_name'] as String?,
      clientId: json['client_id'] as int?,
      clientName: json['client_name'] as String?,
      clientEmail: json['client_email'] as String?,
      clientPhone: json['client_phone'] as String?,
      notes: json['notes'] as String?,
      status: json['status'] as String? ?? 'confirmed',
      source: json['source'] as String? ?? 'online',
      firstStartTime: json['first_start_time'] != null
          ? DateTime.parse(json['first_start_time'] as String)
          : null,
      lastEndTime: json['last_end_time'] != null
          ? DateTime.parse(json['last_end_time'] as String)
          : null,
      totalPrice: (json['total_price'] as num?)?.toDouble() ?? 0.0,
      serviceNames: json['service_names'] as String?,
      staffNames: json['staff_names'] as String?,
      createdAt: json['created_at'] != null
          ? DateTime.parse(json['created_at'] as String)
          : null,
      creatorName: json['creator_name'] as String?,
      recurrenceRuleId: json['recurrence_rule_id'] as int?,
      recurrenceIndex: json['recurrence_index'] as int?,
      items: itemsJson
          ?.map((e) => Appointment.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'location_id': locationId,
    if (locationName != null) 'location_name': locationName,
    if (clientId != null) 'client_id': clientId,
    if (clientName != null) 'client_name': clientName,
    if (clientEmail != null) 'client_email': clientEmail,
    if (clientPhone != null) 'client_phone': clientPhone,
    if (notes != null) 'notes': notes,
    'status': status,
    'source': source,
    if (firstStartTime != null)
      'first_start_time': firstStartTime!.toIso8601String(),
    if (lastEndTime != null) 'last_end_time': lastEndTime!.toIso8601String(),
    'total_price': totalPrice,
    if (serviceNames != null) 'service_names': serviceNames,
    if (staffNames != null) 'staff_names': staffNames,
    if (createdAt != null) 'created_at': createdAt!.toIso8601String(),
    if (creatorName != null) 'creator_name': creatorName,
    if (recurrenceRuleId != null) 'recurrence_rule_id': recurrenceRuleId,
    if (recurrenceIndex != null) 'recurrence_index': recurrenceIndex,
    if (items != null) 'items': items!.map((e) => e.toJson()).toList(),
  };
}

/// Risultato paginato della lista prenotazioni
class BookingListResult {
  final List<BookingListItem> bookings;
  final int total;
  final int limit;
  final int offset;

  const BookingListResult({
    required this.bookings,
    required this.total,
    required this.limit,
    required this.offset,
  });

  /// Indica se ci sono altre pagine
  bool get hasMore => offset + bookings.length < total;

  /// Numero pagina corrente (0-based)
  int get currentPage => limit > 0 ? offset ~/ limit : 0;

  /// Numero totale di pagine
  int get totalPages => limit > 0 ? (total + limit - 1) ~/ limit : 1;

  factory BookingListResult.fromJson(Map<String, dynamic> json) {
    final bookingsJson = json['bookings'] as List<dynamic>;
    return BookingListResult(
      bookings: bookingsJson
          .map((e) => BookingListItem.fromJson(e as Map<String, dynamic>))
          .toList(),
      total: json['total'] as int? ?? 0,
      limit: json['limit'] as int? ?? 50,
      offset: json['offset'] as int? ?? 0,
    );
  }
}
--- FILE: lib/core/models/service_category.dart ---
class ServiceCategory {
  final int id;
  final int businessId;
  final String name;
  final String? description;
  final int sortOrder; // üîπ ordine di visualizzazione

  const ServiceCategory({
    required this.id,
    required this.businessId,
    required this.name,
    this.description,
    this.sortOrder = 0,
  });

  ServiceCategory copyWith({
    int? id,
    int? businessId,
    String? name,
    String? description,
    int? sortOrder,
  }) => ServiceCategory(
    id: id ?? this.id,
    businessId: businessId ?? this.businessId,
    name: name ?? this.name,
    description: description ?? this.description,
    sortOrder: sortOrder ?? this.sortOrder,
  );

  factory ServiceCategory.fromJson(Map<String, dynamic> json) =>
      ServiceCategory(
        id: json['id'] as int,
        businessId: json['business_id'] as int,
        name: json['name'] as String,
        description: json['description'] as String?,
        sortOrder: json['sort_order'] as int? ?? 0,
      );

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'name': name,
    if (description != null) 'description': description,
    'sort_order': sortOrder,
  };
}
--- FILE: lib/core/models/user.dart ---
import '../utils/initials_utils.dart';

/// Modello utente per l'autenticazione.
/// Rappresenta l'utente loggato nel gestionale.
class User {
  final int id;
  final String email;
  final String firstName;
  final String lastName;
  final String? phone;
  final bool isSuperadmin;
  final DateTime createdAt;

  const User({
    required this.id,
    required this.email,
    required this.firstName,
    required this.lastName,
    this.phone,
    this.isSuperadmin = false,
    required this.createdAt,
  });

  /// Nome completo dell'utente.
  String get fullName => '$firstName $lastName';

  /// Iniziali dell'utente (per avatar).
  String get initials {
    final fullName = '$firstName $lastName'.trim();
    return InitialsUtils.fromName(fullName, maxChars: 2);
  }

  User copyWith({
    int? id,
    String? email,
    String? firstName,
    String? lastName,
    String? phone,
    bool? isSuperadmin,
    DateTime? createdAt,
  }) => User(
    id: id ?? this.id,
    email: email ?? this.email,
    firstName: firstName ?? this.firstName,
    lastName: lastName ?? this.lastName,
    phone: phone ?? this.phone,
    isSuperadmin: isSuperadmin ?? this.isSuperadmin,
    createdAt: createdAt ?? this.createdAt,
  );

  factory User.fromJson(Map<String, dynamic> json) => User(
    id: json['id'] as int,
    email: json['email'] as String,
    firstName: json['first_name'] as String,
    lastName: json['last_name'] as String,
    phone: json['phone'] as String?,
    isSuperadmin: json['is_superadmin'] == true || json['is_superadmin'] == 1,
    createdAt: json['created_at'] != null
        ? DateTime.parse(json['created_at'] as String)
        : DateTime.now(),
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'first_name': firstName,
    'last_name': lastName,
    if (phone != null) 'phone': phone,
    'is_superadmin': isSuperadmin,
    'created_at': createdAt.toIso8601String(),
  };
}
--- FILE: lib/core/models/booking_notification_item.dart ---
import 'package:flutter/material.dart';

import '/core/l10n/l10_extension.dart';

class BookingNotificationItem {
  final int id;
  final int businessId;
  final int? bookingId;
  final int? locationId;
  final String? locationName;
  final String? clientName;
  final String channel;
  final String status;
  final String? recipientEmail;
  final String? recipientName;
  final String? subject;
  final String? errorMessage;
  final int attempts;
  final int maxAttempts;
  final DateTime? createdAt;
  final DateTime? scheduledAt;
  final DateTime? sentAt;
  final DateTime? failedAt;
  final DateTime? firstStartTime;
  final DateTime? lastEndTime;

  const BookingNotificationItem({
    required this.id,
    required this.businessId,
    this.bookingId,
    this.locationId,
    this.locationName,
    this.clientName,
    required this.channel,
    required this.status,
    this.recipientEmail,
    this.recipientName,
    this.subject,
    this.errorMessage,
    this.attempts = 0,
    this.maxAttempts = 0,
    this.createdAt,
    this.scheduledAt,
    this.sentAt,
    this.failedAt,
    this.firstStartTime,
    this.lastEndTime,
  });

  Color get statusColor {
    switch (status) {
      case 'sent':
        return Colors.green;
      case 'failed':
        return Colors.red;
      case 'processing':
        return Colors.blue;
      case 'pending':
        return Colors.amber;
      default:
        return Colors.grey;
    }
  }

  String statusLabel(BuildContext context) {
    final l10n = context.l10n;
    switch (status) {
      case 'pending':
        return l10n.bookingNotificationsStatusPending;
      case 'processing':
        return l10n.bookingNotificationsStatusProcessing;
      case 'sent':
        return l10n.bookingNotificationsStatusSent;
      case 'failed':
        return l10n.bookingNotificationsStatusFailed;
      default:
        return status;
    }
  }

  String channelLabel(BuildContext context) {
    final l10n = context.l10n;
    switch (channel) {
      case 'booking_confirmed':
        return l10n.bookingNotificationsChannelConfirmed;
      case 'booking_rescheduled':
        return l10n.bookingNotificationsChannelRescheduled;
      case 'booking_cancelled':
        return l10n.bookingNotificationsChannelCancelled;
      case 'booking_reminder':
        return l10n.bookingNotificationsChannelReminder;
      default:
        return channel;
    }
  }

  factory BookingNotificationItem.fromJson(Map<String, dynamic> json) {
    DateTime? parseDate(dynamic value) {
      if (value == null) return null;
      final str = value.toString();
      if (str.isEmpty) return null;
      return DateTime.tryParse(str);
    }

    return BookingNotificationItem(
      id: json['id'] as int,
      businessId: json['business_id'] as int,
      bookingId: json['booking_id'] as int?,
      locationId: json['location_id'] as int?,
      locationName: json['location_name'] as String?,
      clientName: json['client_name'] as String?,
      channel: json['channel'] as String? ?? '',
      status: json['status'] as String? ?? '',
      recipientEmail: json['recipient_email'] as String?,
      recipientName: json['recipient_name'] as String?,
      subject: json['subject'] as String?,
      errorMessage: json['error_message'] as String?,
      attempts: json['attempts'] as int? ?? 0,
      maxAttempts: json['max_attempts'] as int? ?? 0,
      createdAt: parseDate(json['created_at']),
      scheduledAt: parseDate(json['scheduled_at']),
      sentAt: parseDate(json['sent_at']),
      failedAt: parseDate(json['failed_at']),
      firstStartTime: parseDate(json['first_start_time']),
      lastEndTime: parseDate(json['last_end_time']),
    );
  }
}

class BookingNotificationsResult {
  final List<BookingNotificationItem> notifications;
  final int total;
  final int limit;
  final int offset;

  const BookingNotificationsResult({
    required this.notifications,
    required this.total,
    required this.limit,
    required this.offset,
  });

  bool get hasMore => offset + notifications.length < total;

  factory BookingNotificationsResult.fromJson(Map<String, dynamic> json) {
    final list = json['notifications'] as List<dynamic>? ?? [];
    return BookingNotificationsResult(
      notifications: list
          .map(
            (e) => BookingNotificationItem.fromJson(e as Map<String, dynamic>),
          )
          .toList(),
      total: json['total'] as int? ?? 0,
      limit: json['limit'] as int? ?? 50,
      offset: json['offset'] as int? ?? 0,
    );
  }
}
--- FILE: lib/core/models/time_block.dart ---
/// Rappresenta un blocco di non disponibilit√† nell'agenda.
///
/// Un blocco pu√≤ essere assegnato a uno o pi√π membri dello staff
/// per una fascia oraria specifica.
class TimeBlock {
  final int id;
  final int businessId;
  final int locationId;

  /// Lista degli ID degli staff a cui √® assegnato il blocco.
  final List<int> staffIds;

  /// Inizio del blocco.
  final DateTime startTime;

  /// Fine del blocco.
  final DateTime endTime;

  /// Motivo opzionale del blocco (es. "Riunione", "Pausa pranzo", ecc.).
  final String? reason;

  /// Se true, il blocco copre l'intera giornata lavorativa.
  final bool isAllDay;

  const TimeBlock({
    required this.id,
    required this.businessId,
    required this.locationId,
    required this.staffIds,
    required this.startTime,
    required this.endTime,
    this.reason,
    this.isAllDay = false,
  });

  factory TimeBlock.fromJson(Map<String, dynamic> json) => TimeBlock(
    id: json['id'] as int,
    businessId: json['business_id'] as int,
    locationId: json['location_id'] as int,
    staffIds: (json['staff_ids'] as List<dynamic>)
        .map((id) => id as int)
        .toList(),
    startTime: DateTime.parse(json['start_time'] as String),
    endTime: DateTime.parse(json['end_time'] as String),
    reason: json['reason'] as String?,
    isAllDay: json['is_all_day'] as bool? ?? false,
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'location_id': locationId,
    'staff_ids': staffIds,
    'start_time': startTime.toIso8601String(),
    'end_time': endTime.toIso8601String(),
    if (reason != null) 'reason': reason,
    'is_all_day': isAllDay,
  };

  TimeBlock copyWith({
    int? id,
    int? businessId,
    int? locationId,
    List<int>? staffIds,
    DateTime? startTime,
    DateTime? endTime,
    String? reason,
    bool? isAllDay,
  }) {
    return TimeBlock(
      id: id ?? this.id,
      businessId: businessId ?? this.businessId,
      locationId: locationId ?? this.locationId,
      staffIds: staffIds ?? this.staffIds,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      reason: reason ?? this.reason,
      isAllDay: isAllDay ?? this.isAllDay,
    );
  }

  /// Durata del blocco in minuti.
  int get durationMinutes => endTime.difference(startTime).inMinutes;

  /// Verifica se il blocco include uno specifico staff.
  bool includesStaff(int staffId) => staffIds.contains(staffId);

  /// Verifica se il blocco si sovrappone a un intervallo di tempo.
  bool overlaps(DateTime start, DateTime end) {
    return startTime.isBefore(end) && endTime.isAfter(start);
  }

  /// Verifica se il blocco √® nella stessa data.
  bool isOnDate(DateTime date) {
    final blockDate = DateTime(startTime.year, startTime.month, startTime.day);
    final targetDate = DateTime(date.year, date.month, date.day);
    return blockDate == targetDate;
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TimeBlock && runtimeType == other.runtimeType && id == other.id;

  @override
  int get hashCode => id.hashCode;
}
--- FILE: lib/core/models/class_booking.dart ---
class ClassBooking {
  final int id;
  final int businessId;
  final int classEventId;
  final int customerId;
  final String status;
  final int? waitlistPosition;
  final DateTime bookedAtUtc;
  final DateTime? cancelledAtUtc;
  final DateTime? checkedInAtUtc;
  final String? paymentStatus;
  final String? notes;

  const ClassBooking({
    required this.id,
    required this.businessId,
    required this.classEventId,
    required this.customerId,
    required this.status,
    required this.bookedAtUtc,
    this.waitlistPosition,
    this.cancelledAtUtc,
    this.checkedInAtUtc,
    this.paymentStatus,
    this.notes,
  });

  bool get isConfirmed => status.toUpperCase() == 'CONFIRMED';
  bool get isWaitlisted => status.toUpperCase() == 'WAITLISTED';

  factory ClassBooking.fromJson(Map<String, dynamic> json) {
    return ClassBooking(
      id: (json['id'] as num).toInt(),
      businessId:
          (json['business_id'] as num?)?.toInt() ??
          (json['tenant_id'] as num?)?.toInt() ??
          0,
      classEventId: (json['class_event_id'] as num).toInt(),
      customerId: (json['customer_id'] as num).toInt(),
      status: (json['status'] as String? ?? 'WAITLISTED').toUpperCase(),
      waitlistPosition: (json['waitlist_position'] as num?)?.toInt(),
      bookedAtUtc: DateTime.parse(
        (json['booked_at'] ?? json['booked_at_utc']) as String,
      ),
      cancelledAtUtc: (json['cancelled_at'] ?? json['cancelled_at_utc']) != null
          ? DateTime.parse(
              (json['cancelled_at'] ?? json['cancelled_at_utc']) as String,
            )
          : null,
      checkedInAtUtc: (json['checked_in_at'] ?? json['checked_in_at_utc']) != null
          ? DateTime.parse(
              (json['checked_in_at'] ?? json['checked_in_at_utc']) as String,
            )
          : null,
      paymentStatus: json['payment_status'] as String?,
      notes: json['notes'] as String?,
    );
  }
}
--- FILE: lib/core/models/booking.dart ---
class Booking {
  final int id;
  final int businessId;
  final int locationId;
  final int? clientId;
  final String? clientName;
  final String? notes;
  final String status;
  final int? replacesBookingId;
  final int? replacedByBookingId;

  // Campi ricorrenza
  final int? recurrenceRuleId;
  final int? recurrenceIndex;
  final bool isRecurrenceParent;
  final bool hasConflict;

  const Booking({
    required this.id,
    required this.businessId,
    required this.locationId,
    this.clientId,
    this.clientName,
    this.notes,
    this.status = 'confirmed',
    this.replacesBookingId,
    this.replacedByBookingId,
    this.recurrenceRuleId,
    this.recurrenceIndex,
    this.isRecurrenceParent = false,
    this.hasConflict = false,
  });

  /// Indica se questa prenotazione √® parte di una serie ricorrente
  bool get isRecurring => recurrenceRuleId != null;

  /// Indica se questa prenotazione √® stata sostituita da un'altra
  bool get isReplaced => status == 'replaced' || replacedByBookingId != null;

  /// Indica se questa prenotazione sostituisce un'altra
  bool get isReplacement => replacesBookingId != null;

  Booking copyWith({
    int? id,
    int? businessId,
    int? locationId,
    int? clientId,
    String? clientName,
    String? notes,
    String? status,
    int? replacesBookingId,
    int? replacedByBookingId,
    int? recurrenceRuleId,
    int? recurrenceIndex,
    bool? isRecurrenceParent,
    bool? hasConflict,
  }) {
    return Booking(
      id: id ?? this.id,
      businessId: businessId ?? this.businessId,
      locationId: locationId ?? this.locationId,
      clientId: clientId ?? this.clientId,
      clientName: clientName ?? this.clientName,
      notes: notes ?? this.notes,
      status: status ?? this.status,
      replacesBookingId: replacesBookingId ?? this.replacesBookingId,
      replacedByBookingId: replacedByBookingId ?? this.replacedByBookingId,
      recurrenceRuleId: recurrenceRuleId ?? this.recurrenceRuleId,
      recurrenceIndex: recurrenceIndex ?? this.recurrenceIndex,
      isRecurrenceParent: isRecurrenceParent ?? this.isRecurrenceParent,
      hasConflict: hasConflict ?? this.hasConflict,
    );
  }

  factory Booking.fromJson(Map<String, dynamic> json) => Booking(
    id: json['id'] as int,
    businessId: json['business_id'] as int,
    locationId: json['location_id'] as int,
    clientId: json['client_id'] as int?,
    clientName: json['client_name'] as String? ?? '',
    notes: json['notes'] as String?,
    status: json['status'] as String? ?? 'confirmed',
    replacesBookingId: json['replaces_booking_id'] as int?,
    replacedByBookingId: json['replaced_by_booking_id'] as int?,
    recurrenceRuleId: json['recurrence_rule_id'] as int?,
    recurrenceIndex: json['recurrence_index'] as int?,
    isRecurrenceParent: (json['is_recurrence_parent'] as int? ?? 0) == 1,
    hasConflict: (json['has_conflict'] as int? ?? 0) == 1,
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'location_id': locationId,
    if (clientId != null) 'client_id': clientId,
    'client_name': clientName,
    if (notes != null) 'notes': notes,
    'status': status,
    if (replacesBookingId != null) 'replaces_booking_id': replacesBookingId,
    if (replacedByBookingId != null)
      'replaced_by_booking_id': replacedByBookingId,
    if (recurrenceRuleId != null) 'recurrence_rule_id': recurrenceRuleId,
    if (recurrenceIndex != null) 'recurrence_index': recurrenceIndex,
    'is_recurrence_parent': isRecurrenceParent ? 1 : 0,
    'has_conflict': hasConflict ? 1 : 0,
  };
}
--- FILE: lib/core/models/resource.dart ---
class Resource {
  final int id;
  final int locationId;
  final String name;
  final int quantity;
  final String? type;
  final String? note;

  const Resource({
    required this.id,
    required this.locationId,
    required this.name,
    required this.quantity,
    this.type,
    this.note,
  });

  Resource copyWith({
    int? id,
    int? locationId,
    String? name,
    int? quantity,
    String? type,
    String? note,
  }) {
    return Resource(
      id: id ?? this.id,
      locationId: locationId ?? this.locationId,
      name: name ?? this.name,
      quantity: quantity ?? this.quantity,
      type: type ?? this.type,
      note: note ?? this.note,
    );
  }

  factory Resource.fromJson(Map<String, dynamic> json) {
    return Resource(
      id: json['id'] as int,
      locationId: json['location_id'] as int,
      name: json['name'] as String,
      quantity: json['quantity'] as int,
      type: json['type'] as String?,
      note: json['note'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'location_id': locationId,
      'name': name,
      'quantity': quantity,
      if (type != null) 'type': type,
      if (note != null) 'note': note,
    };
  }
}

--- FILE: lib/core/models/class_event.dart ---
import 'class_booking.dart';

class ClassEvent {
  final int id;
  final int businessId;
  final int classTypeId;
  final DateTime startsAtUtc;
  final DateTime endsAtUtc;
  final DateTime? startsAtLocal;
  final DateTime? endsAtLocal;
  final int locationId;
  final int? resourceId;
  final int staffId;
  final int capacityTotal;
  final int capacityReserved;
  final int confirmedCount;
  final int waitlistCount;
  final bool waitlistEnabled;
  final DateTime? bookingOpenAtUtc;
  final DateTime? bookingCloseAtUtc;
  final int cancelCutoffMinutes;
  final String status;
  final String visibility;
  final int? priceCents;
  final String? currency;
  final String? myBookingStatus;
  final ClassBooking? myBooking;

  const ClassEvent({
    required this.id,
    required this.businessId,
    required this.classTypeId,
    required this.startsAtUtc,
    required this.endsAtUtc,
    this.startsAtLocal,
    this.endsAtLocal,
    required this.capacityTotal,
    required this.capacityReserved,
    required this.confirmedCount,
    required this.waitlistCount,
    required this.waitlistEnabled,
    required this.cancelCutoffMinutes,
    required this.status,
    required this.visibility,
    required this.locationId,
    required this.staffId,
    this.resourceId,
    this.bookingOpenAtUtc,
    this.bookingCloseAtUtc,
    this.priceCents,
    this.currency,
    this.myBookingStatus,
    this.myBooking,
  });

  int get spotsLeft => capacityTotal - capacityReserved - confirmedCount;
  bool get isFull => spotsLeft <= 0;

  factory ClassEvent.fromJson(Map<String, dynamic> json) {
    return ClassEvent(
      id: (json['id'] as num).toInt(),
      businessId:
          (json['business_id'] as num?)?.toInt() ??
          (json['tenant_id'] as num?)?.toInt() ??
          0,
      classTypeId: (json['class_type_id'] as num?)?.toInt() ?? 0,
      startsAtUtc: _parseUtcDateTime(
        (json['starts_at'] ?? json['starts_at_utc']) as String,
      ),
      endsAtUtc: _parseUtcDateTime(
        (json['ends_at'] ?? json['ends_at_utc']) as String,
      ),
      startsAtLocal:
          (json['starts_at_local'] as String?) != null
          ? _parseLocalDateTime(json['starts_at_local'] as String)
          : null,
      endsAtLocal:
          (json['ends_at_local'] as String?) != null
          ? _parseLocalDateTime(json['ends_at_local'] as String)
          : null,
      locationId: (json['location_id'] as num).toInt(),
      resourceId:
          (json['resource_id'] as num?)?.toInt() ??
          _firstResourceId(json['resource_requirements']),
      staffId:
          (json['staff_id'] as num?)?.toInt() ??
          (json['instructor_staff_id'] as num?)?.toInt() ??
          0,
      capacityTotal: (json['capacity_total'] as num?)?.toInt() ?? 1,
      capacityReserved: (json['capacity_reserved'] as num?)?.toInt() ?? 0,
      confirmedCount: (json['confirmed_count'] as num?)?.toInt() ?? 0,
      waitlistCount: (json['waitlist_count'] as num?)?.toInt() ?? 0,
      waitlistEnabled: (json['waitlist_enabled'] as bool?) ??
          ((json['waitlist_enabled'] as num?)?.toInt() == 1),
      bookingOpenAtUtc: (json['booking_open_at'] ?? json['booking_open_at_utc']) !=
              null
          ? _parseUtcDateTime(
              (json['booking_open_at'] ?? json['booking_open_at_utc']) as String,
            )
          : null,
      bookingCloseAtUtc:
          (json['booking_close_at'] ?? json['booking_close_at_utc']) != null
          ? _parseUtcDateTime(
              (json['booking_close_at'] ?? json['booking_close_at_utc'])
                  as String,
            )
          : null,
      cancelCutoffMinutes:
          (json['cancel_cutoff_minutes'] as num?)?.toInt() ?? 0,
      status: (json['status'] as String? ?? 'SCHEDULED').toUpperCase(),
      visibility: (json['visibility'] as String? ?? 'PUBLIC').toUpperCase(),
      priceCents: (json['price_cents'] as num?)?.toInt(),
      currency: json['currency'] as String?,
      myBookingStatus: json['my_booking_status'] as String?,
      myBooking: json['my_booking'] is Map<String, dynamic>
          ? ClassBooking.fromJson(json['my_booking'] as Map<String, dynamic>)
          : null,
    );
  }

  static int? _firstResourceId(dynamic rawRequirements) {
    if (rawRequirements is! List || rawRequirements.isEmpty) {
      return null;
    }
    final first = rawRequirements.first;
    if (first is! Map<String, dynamic>) {
      return null;
    }
    return (first['resource_id'] as num?)?.toInt();
  }

  static DateTime _parseUtcDateTime(String raw) {
    final trimmed = raw.trim();
    final hasOffset =
        trimmed.endsWith('Z') ||
        trimmed.contains('+') ||
        RegExp(r'-\d{2}:\d{2}$').hasMatch(trimmed);
    if (hasOffset) {
      return DateTime.parse(trimmed).toUtc();
    }
    return DateTime.parse('${trimmed.replaceFirst(' ', 'T')}Z').toUtc();
  }

  static DateTime _parseLocalDateTime(String raw) {
    return DateTime.parse(raw.trim().replaceFirst(' ', 'T'));
  }
}
--- FILE: lib/core/models/service_package.dart ---
class ServicePackageItem {
  final int serviceId;
  final int sortOrder;
  final String? name;
  final int? durationMinutes;
  final double? price;
  final bool serviceIsActive;
  final bool variantIsActive;

  const ServicePackageItem({
    required this.serviceId,
    required this.sortOrder,
    this.name,
    this.durationMinutes,
    this.price,
    this.serviceIsActive = true,
    this.variantIsActive = true,
  });

  factory ServicePackageItem.fromJson(Map<String, dynamic> json) {
    return ServicePackageItem(
      serviceId: json['service_id'] as int,
      sortOrder: json['sort_order'] as int? ?? 0,
      name: json['name'] as String?,
      durationMinutes: json['duration_minutes'] as int?,
      price: (json['price'] as num?)?.toDouble(),
      serviceIsActive: json['service_is_active'] as bool? ?? true,
      variantIsActive: json['variant_is_active'] as bool? ?? true,
    );
  }
}

class ServicePackage {
  final int id;
  final int businessId;
  final int locationId;
  final int categoryId;
  final int sortOrder;
  final String name;
  final String? description;
  final double? overridePrice;
  final int? overrideDurationMinutes;
  final bool isActive;
  final bool isBroken;
  final double effectivePrice;
  final int effectiveDurationMinutes;
  final List<ServicePackageItem> items;

  const ServicePackage({
    required this.id,
    required this.businessId,
    required this.locationId,
    required this.categoryId,
    required this.sortOrder,
    required this.name,
    this.description,
    this.overridePrice,
    this.overrideDurationMinutes,
    this.isActive = true,
    this.isBroken = false,
    required this.effectivePrice,
    required this.effectiveDurationMinutes,
    required this.items,
  });

  int get serviceCount => items.length;

  List<int> get orderedServiceIds {
    final ordered = [...items]..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));
    return ordered.map((item) => item.serviceId).toList();
  }

  ServicePackage copyWith({
    int? id,
    int? businessId,
    int? locationId,
    int? categoryId,
    int? sortOrder,
    String? name,
    String? description,
    double? overridePrice,
    int? overrideDurationMinutes,
    bool? isActive,
    bool? isBroken,
    double? effectivePrice,
    int? effectiveDurationMinutes,
    List<ServicePackageItem>? items,
  }) => ServicePackage(
    id: id ?? this.id,
    businessId: businessId ?? this.businessId,
    locationId: locationId ?? this.locationId,
    categoryId: categoryId ?? this.categoryId,
    sortOrder: sortOrder ?? this.sortOrder,
    name: name ?? this.name,
    description: description ?? this.description,
    overridePrice: overridePrice ?? this.overridePrice,
    overrideDurationMinutes:
        overrideDurationMinutes ?? this.overrideDurationMinutes,
    isActive: isActive ?? this.isActive,
    isBroken: isBroken ?? this.isBroken,
    effectivePrice: effectivePrice ?? this.effectivePrice,
    effectiveDurationMinutes:
        effectiveDurationMinutes ?? this.effectiveDurationMinutes,
    items: items ?? this.items,
  );

  factory ServicePackage.fromJson(Map<String, dynamic> json) {
    final itemsJson = json['items'] as List<dynamic>? ?? const [];
    return ServicePackage(
      id: json['id'] as int,
      businessId: json['business_id'] as int,
      locationId: json['location_id'] as int,
      categoryId: json['category_id'] as int? ?? 0,
      sortOrder: json['sort_order'] as int? ?? 0,
      name: json['name'] as String,
      description: json['description'] as String?,
      overridePrice: (json['override_price'] as num?)?.toDouble(),
      overrideDurationMinutes: json['override_duration_minutes'] as int?,
      isActive: json['is_active'] as bool? ?? true,
      isBroken: json['is_broken'] as bool? ?? false,
      effectivePrice: (json['effective_price'] as num?)?.toDouble() ?? 0,
      effectiveDurationMinutes:
          json['effective_duration_minutes'] as int? ?? 0,
      items: itemsJson
          .map(
            (item) =>
                ServicePackageItem.fromJson(item as Map<String, dynamic>),
          )
          .toList(),
    );
  }
}

class ServicePackageExpansion {
  final int packageId;
  final int locationId;
  final List<int> serviceIds;
  final double effectivePrice;
  final int effectiveDurationMinutes;

  const ServicePackageExpansion({
    required this.packageId,
    required this.locationId,
    required this.serviceIds,
    required this.effectivePrice,
    required this.effectiveDurationMinutes,
  });

  factory ServicePackageExpansion.fromJson(Map<String, dynamic> json) {
    return ServicePackageExpansion(
      packageId: json['package_id'] as int,
      locationId: json['location_id'] as int,
      serviceIds:
          (json['service_ids'] as List<dynamic>? ?? const [])
              .map((id) => id as int)
              .toList(),
      effectivePrice: (json['effective_price'] as num?)?.toDouble() ?? 0,
      effectiveDurationMinutes:
          json['effective_duration_minutes'] as int? ?? 0,
    );
  }
}
--- FILE: lib/core/models/service.dart ---
import 'service_variant_resource_requirement.dart';

class Service {
  final int id;
  final int businessId;
  final int?
  locationId; // Location a cui appartiene il servizio (da service_variants)
  final int categoryId;
  final String name;
  final String? description;
  final int sortOrder; // üîπ posizione nella categoria
  final int? durationMinutes; // da API
  final int? processingTime; // tempo aggiuntivo processing (da API)
  final int? blockedTime; // tempo aggiuntivo bloccato (da API)
  final double? price; // da API
  final String? color; // da API
  final bool isBookableOnline; // prenotabile online
  final bool isPriceStartingFrom; // "a partire da" flag
  final int? serviceVariantId; // ID della variante per location (da API)
  final List<ServiceVariantResourceRequirement>
  resourceRequirements; // risorse richieste

  const Service({
    required this.id,
    required this.businessId,
    this.locationId,
    required this.categoryId,
    required this.name,
    this.description,
    this.sortOrder = 0,
    this.durationMinutes,
    this.processingTime,
    this.blockedTime,
    this.price,
    this.color,
    this.isBookableOnline = true,
    this.isPriceStartingFrom = false,
    this.serviceVariantId,
    this.resourceRequirements = const [],
  });

  Service copyWith({
    int? id,
    int? businessId,
    int? locationId,
    int? categoryId,
    String? name,
    String? description,
    int? sortOrder,
    int? durationMinutes,
    int? processingTime,
    int? blockedTime,
    double? price,
    String? color,
    bool? isBookableOnline,
    bool? isPriceStartingFrom,
    int? serviceVariantId,
    List<ServiceVariantResourceRequirement>? resourceRequirements,
  }) => Service(
    id: id ?? this.id,
    businessId: businessId ?? this.businessId,
    locationId: locationId ?? this.locationId,
    categoryId: categoryId ?? this.categoryId,
    name: name ?? this.name,
    description: description ?? this.description,
    sortOrder: sortOrder ?? this.sortOrder,
    durationMinutes: durationMinutes ?? this.durationMinutes,
    processingTime: processingTime ?? this.processingTime,
    blockedTime: blockedTime ?? this.blockedTime,
    price: price ?? this.price,
    color: color ?? this.color,
    isBookableOnline: isBookableOnline ?? this.isBookableOnline,
    isPriceStartingFrom: isPriceStartingFrom ?? this.isPriceStartingFrom,
    serviceVariantId: serviceVariantId ?? this.serviceVariantId,
    resourceRequirements: resourceRequirements ?? this.resourceRequirements,
  );

  factory Service.fromJson(Map<String, dynamic> json) {
    final resourceRequirementsJson =
        json['resource_requirements'] as List<dynamic>? ?? [];
    final resourceRequirements = resourceRequirementsJson
        .map(
          (r) => ServiceVariantResourceRequirement.fromJson(
            r as Map<String, dynamic>,
          ),
        )
        .toList();

    return Service(
      id: json['id'] as int,
      businessId: json['business_id'] as int? ?? 1,
      locationId: json['location_id'] as int?,
      categoryId: json['category_id'] as int? ?? 0,
      name: json['name'] as String,
      description: json['description'] as String?,
      sortOrder: json['sort_order'] as int? ?? 0,
      durationMinutes: json['duration_minutes'] as int?,
      processingTime: json['processing_time'] as int?,
      blockedTime: json['blocked_time'] as int?,
      price: (json['price'] as num?)?.toDouble(),
      color: json['color'] as String?,
      isBookableOnline: json['is_bookable_online'] as bool? ?? true,
      isPriceStartingFrom: json['is_price_starting_from'] as bool? ?? false,
      serviceVariantId: json['service_variant_id'] as int?,
      resourceRequirements: resourceRequirements,
    );
  }

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    if (locationId != null) 'location_id': locationId,
    'category_id': categoryId,
    'name': name,
    if (description != null) 'description': description,
    'sort_order': sortOrder,
    if (durationMinutes != null) 'duration_minutes': durationMinutes,
    if (price != null) 'price': price,
    if (color != null) 'color': color,
    'is_bookable_online': isBookableOnline,
    'is_price_starting_from': isPriceStartingFrom,
    if (serviceVariantId != null) 'service_variant_id': serviceVariantId,
  };
}
--- FILE: lib/core/models/availability_exception.dart ---
import 'package:flutter/material.dart';

/// Tipo di eccezione alla disponibilit√† settimanale.
enum AvailabilityExceptionType {
  /// Lo staff √® DISPONIBILE in questa fascia (aggiunge disponibilit√†).
  available,

  /// Lo staff NON √® DISPONIBILE in questa fascia (rimuove disponibilit√†).
  unavailable,
}

/// Rappresenta un'eccezione alla disponibilit√† settimanale di uno staff.
///
/// A differenza del template settimanale che definisce gli orari ricorrenti,
/// le eccezioni permettono di:
/// - Aggiungere disponibilit√† extra in giorni/fasce specifiche
/// - Rimuovere disponibilit√† in giorni/fasce specifiche (ferie, malattia, ecc.)
///
/// Esempio:
/// - Template: Lun-Ven 09:00-18:00
/// - Eccezione "available": Sabato 14/12 dalle 10:00 alle 14:00 (lavoro extra)
/// - Eccezione "unavailable": Mercoled√¨ 18/12 tutto il giorno (ferie)
class AvailabilityException {
  final int id;
  final int staffId;

  /// Data specifica dell'eccezione.
  final DateTime date;

  /// Orario di inizio. Se null insieme a [endTime], l'eccezione copre l'intera giornata.
  final TimeOfDay? startTime;

  /// Orario di fine. Se null insieme a [startTime], l'eccezione copre l'intera giornata.
  final TimeOfDay? endTime;

  /// Tipo di eccezione: disponibile o non disponibile.
  final AvailabilityExceptionType type;

  /// Codice motivo opzionale (es. "vacation", "medical_visit", "extra_shift").
  final String? reasonCode;

  /// Motivo opzionale (es. "Ferie", "Visita medica", "Turno extra").
  final String? reason;

  const AvailabilityException({
    required this.id,
    required this.staffId,
    required this.date,
    this.startTime,
    this.endTime,
    required this.type,
    this.reasonCode,
    this.reason,
  });

  /// Se true, l'eccezione copre l'intera giornata.
  bool get isAllDay => startTime == null && endTime == null;

  /// Crea un'eccezione per l'intera giornata.
  factory AvailabilityException.allDay({
    required int id,
    required int staffId,
    required DateTime date,
    required AvailabilityExceptionType type,
    String? reasonCode,
    String? reason,
  }) {
    return AvailabilityException(
      id: id,
      staffId: staffId,
      date: DateUtils.dateOnly(date),
      startTime: null,
      endTime: null,
      type: type,
      reasonCode: reasonCode,
      reason: reason,
    );
  }

  /// Crea un'eccezione per una fascia oraria specifica.
  factory AvailabilityException.timeRange({
    required int id,
    required int staffId,
    required DateTime date,
    required TimeOfDay startTime,
    required TimeOfDay endTime,
    required AvailabilityExceptionType type,
    String? reasonCode,
    String? reason,
  }) {
    return AvailabilityException(
      id: id,
      staffId: staffId,
      date: DateUtils.dateOnly(date),
      startTime: startTime,
      endTime: endTime,
      type: type,
      reasonCode: reasonCode,
      reason: reason,
    );
  }

  AvailabilityException copyWith({
    int? id,
    int? staffId,
    DateTime? date,
    TimeOfDay? startTime,
    TimeOfDay? endTime,
    AvailabilityExceptionType? type,
    String? reasonCode,
    String? reason,
    bool clearStartTime = false,
    bool clearEndTime = false,
    bool clearReasonCode = false,
    bool clearReason = false,
  }) {
    return AvailabilityException(
      id: id ?? this.id,
      staffId: staffId ?? this.staffId,
      date: date ?? this.date,
      startTime: clearStartTime ? null : (startTime ?? this.startTime),
      endTime: clearEndTime ? null : (endTime ?? this.endTime),
      type: type ?? this.type,
      reasonCode: clearReasonCode ? null : (reasonCode ?? this.reasonCode),
      reason: clearReason ? null : (reason ?? this.reason),
    );
  }

  factory AvailabilityException.fromJson(Map<String, dynamic> json) {
    return AvailabilityException(
      id: json['id'] as int,
      staffId: json['staff_id'] as int,
      date: DateTime.parse(json['date'] as String),
      startTime: json['start_time'] != null
          ? _timeOfDayFromString(json['start_time'] as String)
          : null,
      endTime: json['end_time'] != null
          ? _timeOfDayFromString(json['end_time'] as String)
          : null,
      type: AvailabilityExceptionType.values.firstWhere(
        (e) => e.name == json['type'],
        orElse: () => AvailabilityExceptionType.unavailable,
      ),
      reasonCode: json['reason_code'] as String?,
      reason: json['reason'] as String?,
    );
  }

  Map<String, dynamic> toJson() => {
    'id': id,
    'staff_id': staffId,
    'date': date.toIso8601String().split('T').first,
    if (startTime != null) 'start_time': _timeOfDayToString(startTime!),
    if (endTime != null) 'end_time': _timeOfDayToString(endTime!),
    'type': type.name,
    if (reasonCode != null) 'reason_code': reasonCode,
    if (reason != null) 'reason': reason,
  };

  static TimeOfDay _timeOfDayFromString(String time) {
    final parts = time.split(':');
    return TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1]));
  }

  static String _timeOfDayToString(TimeOfDay time) {
    return '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';
  }

  /// Verifica se l'eccezione √® per una data specifica.
  bool isOnDate(DateTime targetDate) {
    final target = DateUtils.dateOnly(targetDate);
    final excDate = DateUtils.dateOnly(date);
    return excDate == target;
  }

  /// Converte l'eccezione in un set di slot index.
  /// [minutesPerSlot] dipende dal contesto:
  /// planning staff = 5, griglia agenda = variabile (es. 15/30/60).
  /// Per eccezioni "all day", copre tutti gli slot della giornata.
  Set<int> toSlotIndices({
    required int minutesPerSlot,
    required int totalSlotsPerDay,
  }) {
    if (isAllDay) {
      // Tutti gli slot della giornata
      return {for (int i = 0; i < totalSlotsPerDay; i++) i};
    }

    final startMinutes = startTime!.hour * 60 + startTime!.minute;
    final endMinutes = endTime!.hour * 60 + endTime!.minute;

    final startSlot = startMinutes ~/ minutesPerSlot;
    final endSlot = endMinutes ~/ minutesPerSlot;

    return {for (int i = startSlot; i < endSlot; i++) i};
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AvailabilityException &&
          runtimeType == other.runtimeType &&
          id == other.id;

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() {
    final timeStr = isAllDay
        ? 'all day'
        : '${_timeOfDayToString(startTime!)}-${_timeOfDayToString(endTime!)}';
    return 'AvailabilityException(id: $id, staffId: $staffId, date: ${date.toIso8601String().split('T').first}, $timeStr, type: ${type.name}, reasonCode: $reasonCode, reason: $reason)';
  }
}
--- FILE: lib/core/models/location_closure.dart ---
import 'package:flutter/foundation.dart';

/// Rappresenta un periodo di chiusura che pu√≤ applicarsi a una o pi√π sedi
/// (es. festivit√†, ferie collettive)
@immutable
class LocationClosure {
  final int id;
  final int businessId;
  final List<int> locationIds;
  final DateTime startDate;
  final DateTime endDate;
  final String? reason;
  final DateTime? createdAt;
  final DateTime? updatedAt;

  const LocationClosure({
    required this.id,
    required this.businessId,
    required this.locationIds,
    required this.startDate,
    required this.endDate,
    this.reason,
    this.createdAt,
    this.updatedAt,
  });

  /// Numero di giorni del periodo di chiusura (inclusivo)
  int get durationDays {
    return endDate.difference(startDate).inDays + 1;
  }

  /// Verifica se una data specifica rientra nel periodo di chiusura
  bool containsDate(DateTime date) {
    final dateOnly = DateTime(date.year, date.month, date.day);
    final startOnly = DateTime(startDate.year, startDate.month, startDate.day);
    final endOnly = DateTime(endDate.year, endDate.month, endDate.day);
    return !dateOnly.isBefore(startOnly) && !dateOnly.isAfter(endOnly);
  }

  /// Verifica se la chiusura si applica a una specifica location
  bool appliesToLocation(int locationId) {
    return locationIds.contains(locationId);
  }

  /// Verifica se due periodi si sovrappongono
  bool overlapsWith(LocationClosure other) {
    return !(endDate.isBefore(other.startDate) ||
        startDate.isAfter(other.endDate));
  }

  factory LocationClosure.fromJson(Map<String, dynamic> json) {
    // Handle location_ids as list of integers
    final rawLocationIds = json['location_ids'];
    final locationIds = <int>[];
    if (rawLocationIds is List) {
      for (final id in rawLocationIds) {
        locationIds.add(id is int ? id : int.parse(id.toString()));
      }
    }

    return LocationClosure(
      id: json['id'] as int,
      businessId: json['business_id'] as int,
      locationIds: locationIds,
      startDate: DateTime.parse(json['start_date'] as String),
      endDate: DateTime.parse(json['end_date'] as String),
      reason: json['reason'] as String?,
      createdAt: json['created_at'] != null
          ? DateTime.parse(json['created_at'] as String)
          : null,
      updatedAt: json['updated_at'] != null
          ? DateTime.parse(json['updated_at'] as String)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'business_id': businessId,
      'location_ids': locationIds,
      'start_date': startDate.toIso8601String().split('T').first,
      'end_date': endDate.toIso8601String().split('T').first,
      if (reason != null) 'reason': reason,
    };
  }

  LocationClosure copyWith({
    int? id,
    int? businessId,
    List<int>? locationIds,
    DateTime? startDate,
    DateTime? endDate,
    String? reason,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return LocationClosure(
      id: id ?? this.id,
      businessId: businessId ?? this.businessId,
      locationIds: locationIds ?? this.locationIds,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      reason: reason ?? this.reason,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is LocationClosure &&
        other.id == id &&
        other.businessId == businessId &&
        listEquals(other.locationIds, locationIds) &&
        other.startDate == startDate &&
        other.endDate == endDate &&
        other.reason == reason;
  }

  @override
  int get hashCode {
    return Object.hash(
      id,
      businessId,
      Object.hashAll(locationIds),
      startDate,
      endDate,
      reason,
    );
  }

  @override
  String toString() {
    return 'LocationClosure(id: $id, businessId: $businessId, locationIds: $locationIds, startDate: $startDate, endDate: $endDate, reason: $reason)';
  }
}
--- FILE: lib/core/models/location.dart ---
class Location {
  final int id;
  final int businessId;
  final String name;
  final String? address;
  final String? city;
  final String? region;
  final String? country;
  final String? phone;
  final String? email;
  final double? latitude;
  final double? longitude;
  final String? currency;
  final String timezone;
  final int minBookingNoticeHours;
  final int maxBookingAdvanceDays;
  final bool allowCustomerChooseStaff;
  final int? cancellationHours;
  final int onlineBookingSlotIntervalMinutes;
  final String slotDisplayMode;
  final int minGapMinutes;
  final bool isDefault;
  final bool isActive;
  final int sortOrder;

  const Location({
    required this.id,
    required this.businessId,
    required this.name,
    this.address,
    this.city,
    this.region,
    this.country,
    this.phone,
    this.email,
    this.latitude,
    this.longitude,
    this.currency,
    this.timezone = 'Europe/Rome',
    this.minBookingNoticeHours = 1,
    this.maxBookingAdvanceDays = 90,
    this.allowCustomerChooseStaff = false,
    this.cancellationHours,
    this.onlineBookingSlotIntervalMinutes = 15,
    this.slotDisplayMode = 'all',
    this.minGapMinutes = 30,
    this.isDefault = false,
    this.isActive = true,
    this.sortOrder = 0,
  });

  Location copyWith({
    int? id,
    int? businessId,
    String? name,
    String? address,
    String? city,
    String? region,
    String? country,
    String? phone,
    String? email,
    double? latitude,
    double? longitude,
    String? currency,
    String? timezone,
    int? minBookingNoticeHours,
    int? maxBookingAdvanceDays,
    bool? allowCustomerChooseStaff,
    int? cancellationHours,
    int? onlineBookingSlotIntervalMinutes,
    String? slotDisplayMode,
    int? minGapMinutes,
    bool? isDefault,
    bool? isActive,
    int? sortOrder,
  }) {
    return Location(
      id: id ?? this.id,
      businessId: businessId ?? this.businessId,
      name: name ?? this.name,
      address: address ?? this.address,
      city: city ?? this.city,
      region: region ?? this.region,
      country: country ?? this.country,
      phone: phone ?? this.phone,
      email: email ?? this.email,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      currency: currency ?? this.currency,
      timezone: timezone ?? this.timezone,
      minBookingNoticeHours:
          minBookingNoticeHours ?? this.minBookingNoticeHours,
      maxBookingAdvanceDays:
          maxBookingAdvanceDays ?? this.maxBookingAdvanceDays,
      allowCustomerChooseStaff:
          allowCustomerChooseStaff ?? this.allowCustomerChooseStaff,
      cancellationHours: cancellationHours ?? this.cancellationHours,
      onlineBookingSlotIntervalMinutes:
          onlineBookingSlotIntervalMinutes ??
          this.onlineBookingSlotIntervalMinutes,
      slotDisplayMode: slotDisplayMode ?? this.slotDisplayMode,
      minGapMinutes: minGapMinutes ?? this.minGapMinutes,
      isDefault: isDefault ?? this.isDefault,
      isActive: isActive ?? this.isActive,
      sortOrder: sortOrder ?? this.sortOrder,
    );
  }

  factory Location.fromJson(Map<String, dynamic> json) {
    return Location(
      id: json['id'] as int,
      businessId: json['business_id'] as int,
      name: json['name'] as String,
      address: json['address'] as String?,
      city: json['city'] as String?,
      region: json['region'] as String?,
      country: json['country'] as String?,
      phone: json['phone'] as String?,
      email: json['email'] as String?,
      latitude: (json['latitude'] as num?)?.toDouble(),
      longitude: (json['longitude'] as num?)?.toDouble(),
      currency: json['currency'] as String?,
      timezone: json['timezone'] as String? ?? 'Europe/Rome',
      minBookingNoticeHours: json['min_booking_notice_hours'] as int? ?? 1,
      maxBookingAdvanceDays: json['max_booking_advance_days'] as int? ?? 90,
      allowCustomerChooseStaff:
          json['allow_customer_choose_staff'] as bool? ?? false,
      cancellationHours: json['cancellation_hours'] as int?,
      onlineBookingSlotIntervalMinutes:
          json['online_booking_slot_interval_minutes'] as int? ?? 15,
      slotDisplayMode: json['slot_display_mode'] as String? ?? 'all',
      minGapMinutes: json['min_gap_minutes'] as int? ?? 30,
      isDefault: json['is_default'] as bool? ?? false,
      isActive: json['is_active'] as bool? ?? true,
      sortOrder: json['sort_order'] as int? ?? 0,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'business_id': businessId,
      'name': name,
      if (address != null) 'address': address,
      if (city != null) 'city': city,
      if (region != null) 'region': region,
      if (country != null) 'country': country,
      if (phone != null) 'phone': phone,
      if (email != null) 'email': email,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (currency != null) 'currency': currency,
      'timezone': timezone,
      'min_booking_notice_hours': minBookingNoticeHours,
      'max_booking_advance_days': maxBookingAdvanceDays,
      'allow_customer_choose_staff': allowCustomerChooseStaff,
      if (cancellationHours != null) 'cancellation_hours': cancellationHours,
      'online_booking_slot_interval_minutes':
          onlineBookingSlotIntervalMinutes,
      'slot_display_mode': slotDisplayMode,
      'min_gap_minutes': minGapMinutes,
      'is_default': isDefault,
      'is_active': isActive,
    };
  }
}
--- FILE: lib/core/models/staff.dart ---
import 'package:flutter/material.dart';

import '../utils/initials_utils.dart';
import '../utils/color_utils.dart';

class Staff {
  final int id;
  final int businessId;
  final String name;
  final String surname;
  final Color color;
  final List<int> locationIds;
  final List<int> serviceIds;
  final int sortOrder; // üîπ ordine in agenda
  final bool isDefault; // üîπ staff predefinito
  final bool isBookableOnline; // üîπ abilitato alle prenotazioni online

  const Staff({
    required this.id,
    required this.businessId,
    required this.name,
    required this.surname,
    required this.color,
    required this.locationIds,
    this.serviceIds = const [],
    this.sortOrder = 0,
    this.isDefault = false,
    this.isBookableOnline = true,
  });

  Staff copyWith({
    int? id,
    int? businessId,
    String? name,
    String? surname,
    Color? color,
    List<int>? locationIds,
    List<int>? serviceIds,
    int? sortOrder,
    bool? isDefault,
    bool? isBookableOnline,
  }) => Staff(
    id: id ?? this.id,
    businessId: businessId ?? this.businessId,
    name: name ?? this.name,
    surname: surname ?? this.surname,
    color: color ?? this.color,
    locationIds: locationIds ?? this.locationIds,
    serviceIds: serviceIds ?? this.serviceIds,
    sortOrder: sortOrder ?? this.sortOrder,
    isDefault: isDefault ?? this.isDefault,
    isBookableOnline: isBookableOnline ?? this.isBookableOnline,
  );

  factory Staff.fromJson(Map<String, dynamic> json) => Staff(
    id: json['id'] as int,
    businessId: json['business_id'] as int,
    name: json['name'] as String,
    surname: json['surname'] as String? ?? '',
    color: json['color_hex'] != null
        ? ColorUtils.fromHex(json['color_hex'] as String)
        : ColorUtils.fromHex('#FFD700'),
    locationIds: (json['location_ids'] as List<dynamic>? ?? [])
        .map((id) => id as int)
        .toList(),
    serviceIds: (json['service_ids'] as List<dynamic>? ?? [])
        .map((id) => id as int)
        .toList(),
    sortOrder: json['sort_order'] as int? ?? 0,
    isDefault: json['is_default'] as bool? ?? false,
    isBookableOnline: json['is_bookable_online'] as bool? ?? true,
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'name': name,
    'surname': surname,
    'color_hex': ColorUtils.toHex(color),
    'location_ids': locationIds,
    'service_ids': serviceIds,
    'sort_order': sortOrder,
    'is_default': isDefault,
    'is_bookable_online': isBookableOnline,
  };

  bool worksAtLocation(int locationId) =>
      locationIds.isEmpty || locationIds.contains(locationId);

  String get displayName {
    if (surname.isEmpty) return name;
    return '$name $surname';
  }

  String get initials {
    final fullName = '$name $surname'.trim();
    return InitialsUtils.fromName(fullName, maxChars: 3);
  }
}
--- FILE: lib/core/models/service_staff_eligibility.dart ---
class ServiceStaffEligibility {
  final int serviceId;
  final int staffId;
  final int? locationId; // null => valido per tutte le location del servizio

  const ServiceStaffEligibility({
    required this.serviceId,
    required this.staffId,
    this.locationId,
  });
}

--- FILE: lib/core/models/staff_planning.dart ---
import 'package:flutter/foundation.dart';

/// Tipo di pianificazione settimanale.
enum StaffPlanningType {
  /// Pianificazione settimanale standard (template A).
  weekly,

  /// Pianificazione bisettimanale (template A/B alternati).
  biweekly,
}

/// Label della settimana per biweekly.
enum WeekLabel {
  /// Prima settimana del ciclo.
  a,

  /// Seconda settimana del ciclo.
  b,
}

/// Rappresenta una pianificazione settimanale o bisettimanale di uno staff.
///
/// Una pianificazione ha un intervallo di validit√† [validFrom, validTo]
/// dove validTo pu√≤ essere null per indicare "senza scadenza".
///
/// Per uno staff, in una data D esiste al massimo un planning valido
/// (nessuna sovrapposizione di intervalli).
@immutable
class StaffPlanning {
  static const int planningStepMinutes = 5;
  static const int defaultPlanningSlotMinutes = planningStepMinutes;

  final int id;
  final int staffId;
  final StaffPlanningType type;

  /// Data di inizio validit√† (inclusa).
  final DateTime validFrom;

  /// Data di fine validit√† (inclusa). Se null, la pianificazione non ha scadenza.
  final DateTime? validTo;

  /// Template settimanali. Per weekly contiene solo weekLabel=A.
  /// Per biweekly contiene sia A che B.
  final List<StaffPlanningWeekTemplate> templates;

  final DateTime createdAt;
  final DateTime? updatedAt;

  int get planningSlotMinutes => planningStepMinutes;

  const StaffPlanning({
    required this.id,
    required this.staffId,
    required this.type,
    required this.validFrom,
    this.validTo,
    required this.templates,
    required this.createdAt,
    this.updatedAt,
  });

  /// Se true, la pianificazione √® valida indefinitamente.
  bool get isOpenEnded => validTo == null;

  /// Verifica se la pianificazione √® valida per una data D.
  /// Usa intervalli chiusi-chiusi: [validFrom, validTo].
  bool isValidForDate(DateTime date) {
    final d = DateUtils.dateOnly(date);
    final from = DateUtils.dateOnly(validFrom);

    if (d.isBefore(from)) return false;
    if (validTo == null) return true;

    final to = DateUtils.dateOnly(validTo!);
    return !d.isAfter(to);
  }

  /// Ottiene il template per la settimana A.
  StaffPlanningWeekTemplate? get templateA =>
      templates.where((t) => t.weekLabel == WeekLabel.a).firstOrNull;

  /// Ottiene il template per la settimana B.
  StaffPlanningWeekTemplate? get templateB =>
      templates.where((t) => t.weekLabel == WeekLabel.b).firstOrNull;

  /// Ottiene il template da usare per una data specifica.
  /// Per weekly restituisce sempre template A.
  /// Per biweekly calcola se siamo in settimana A o B.
  StaffPlanningWeekTemplate? getTemplateForDate(DateTime date) {
    if (type == StaffPlanningType.weekly) {
      return templateA;
    }

    final weekLabel = computeWeekLabel(date);
    return weekLabel == WeekLabel.a ? templateA : templateB;
  }

  /// Totale ore settimanali del template attivo per questo planning.
  double totalWeeklyHoursForTemplate(WeekLabel label) {
    final template = label == WeekLabel.a ? templateA : templateB;
    if (template == null) return 0;
    return template.totalWeeklyHoursFor(
      minutesPerSlot: planningStepMinutes,
    );
  }

  /// Calcola la label della settimana (A/B) per una data.
  /// Per weekly ritorna sempre A.
  WeekLabel computeWeekLabel(DateTime date) {
    if (type == StaffPlanningType.weekly) return WeekLabel.a;

    final d = DateUtils.dateOnly(date);
    final from = DateUtils.dateOnly(validFrom);

    // delta_days = D - valid_from
    final deltaDays = d.difference(from).inDays;

    // week_index = floor(delta_days / 7)
    final weekIndex = deltaDays ~/ 7;

    // pari ‚Üí A, dispari ‚Üí B
    return weekIndex.isEven ? WeekLabel.a : WeekLabel.b;
  }

  StaffPlanning copyWith({
    int? id,
    int? staffId,
    StaffPlanningType? type,
    DateTime? validFrom,
    DateTime? Function()? validTo,
    List<StaffPlanningWeekTemplate>? templates,
    DateTime? createdAt,
    DateTime? Function()? updatedAt,
  }) {
    return StaffPlanning(
      id: id ?? this.id,
      staffId: staffId ?? this.staffId,
      type: type ?? this.type,
      validFrom: validFrom ?? this.validFrom,
      validTo: validTo != null ? validTo() : this.validTo,
      templates: templates ?? this.templates,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt != null ? updatedAt() : this.updatedAt,
    );
  }

  factory StaffPlanning.fromJson(Map<String, dynamic> json) {
    return StaffPlanning(
      id: json['id'] as int,
      staffId: json['staff_id'] as int,
      type: StaffPlanningType.values.firstWhere(
        (t) => t.name == json['type'],
        orElse: () => StaffPlanningType.weekly,
      ),
      validFrom: DateTime.parse(json['valid_from'] as String),
      validTo: json['valid_to'] != null
          ? DateTime.parse(json['valid_to'] as String)
          : null,
      templates: (json['templates'] as List<dynamic>? ?? [])
          .map(
            (t) =>
                StaffPlanningWeekTemplate.fromJson(t as Map<String, dynamic>),
          )
          .toList(),
      createdAt: json['created_at'] != null
          ? DateTime.parse(json['created_at'] as String)
          : DateTime.now(),
      updatedAt: json['updated_at'] != null
          ? DateTime.parse(json['updated_at'] as String)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'staff_id': staffId,
      'type': type.name,
      'valid_from': _dateToIso(validFrom),
      'valid_to': validTo != null ? _dateToIso(validTo!) : null,
      'templates': templates.map((t) => t.toJson()).toList(),
      'created_at': createdAt.toIso8601String(),
      'updated_at': updatedAt?.toIso8601String(),
    };
  }

  static String _dateToIso(DateTime d) =>
      '${d.year.toString().padLeft(4, '0')}-'
      '${d.month.toString().padLeft(2, '0')}-'
      '${d.day.toString().padLeft(2, '0')}';

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StaffPlanning &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          staffId == other.staffId &&
          type == other.type &&
          validFrom == other.validFrom &&
          validTo == other.validTo;

  @override
  int get hashCode => Object.hash(
    id,
    staffId,
    type,
    validFrom,
    validTo,
  );

  @override
  String toString() =>
      'StaffPlanning(id: $id, staffId: $staffId, type: $type, '
      'validFrom: ${_dateToIso(validFrom)}, '
      'validTo: ${validTo != null ? _dateToIso(validTo!) : 'null'})';
}

/// Template di una settimana con gli slot per ogni giorno.
///
/// Per ogni giorno della settimana (1-7, Mon-Sun) contiene gli slot disponibili
/// come `Set<int>` dove ogni int √® l'indice dello slot (es. 108 = 09:00 con step planning da 5 min).
@immutable
class StaffPlanningWeekTemplate {
  final int id;
  final int staffPlanningId;
  final WeekLabel weekLabel;

  /// Mappa: day_of_week (1-7) -> Set di slot index.
  /// 1 = Monday, 7 = Sunday.
  /// Slot vuoto o assente = giorno non disponibile.
  final Map<int, Set<int>> daySlots;

  const StaffPlanningWeekTemplate({
    required this.id,
    required this.staffPlanningId,
    required this.weekLabel,
    required this.daySlots,
  });

  /// Verifica se il giorno ha slot definiti.
  bool hasSlots(int dayOfWeek) {
    final slots = daySlots[dayOfWeek];
    return slots != null && slots.isNotEmpty;
  }

  /// Ottiene gli slot per un giorno specifico.
  Set<int> getSlotsForDay(int dayOfWeek) => daySlots[dayOfWeek] ?? const {};

  /// Calcola le ore totali settimanali assumendo lo step planning di default.
  double get totalWeeklyHours {
    return totalWeeklyHoursFor(
      minutesPerSlot: StaffPlanning.planningStepMinutes,
    );
  }

  /// Calcola le ore totali settimanali usando lo step planning specificato.
  double totalWeeklyHoursFor({required int minutesPerSlot}) {
    int totalSlots = 0;
    for (final slots in daySlots.values) {
      totalSlots += slots.length;
    }
    return totalSlots * minutesPerSlot / 60;
  }

  StaffPlanningWeekTemplate copyWith({
    int? id,
    int? staffPlanningId,
    WeekLabel? weekLabel,
    Map<int, Set<int>>? daySlots,
  }) {
    return StaffPlanningWeekTemplate(
      id: id ?? this.id,
      staffPlanningId: staffPlanningId ?? this.staffPlanningId,
      weekLabel: weekLabel ?? this.weekLabel,
      daySlots: daySlots ?? this.daySlots,
    );
  }

  factory StaffPlanningWeekTemplate.fromJson(Map<String, dynamic> json) {
    // Parse day_slots: pu√≤ essere array di {day_of_week, slots} o mappa diretta
    final Map<int, Set<int>> daySlots = {};

    final rawSlots = json['day_slots'] ?? json['slots'];
    if (rawSlots is List) {
      // Formato: [{day_of_week: 1, slots: [36, 37, ...]}, ...]
      for (final item in rawSlots) {
        if (item is Map<String, dynamic>) {
          final day = item['day_of_week'] as int;
          final slots = (item['slots'] as List<dynamic>? ?? [])
              .map((s) => s as int)
              .toSet();
          daySlots[day] = slots;
        }
      }
    } else if (rawSlots is Map) {
      // Formato: {"1": [36, 37, ...], "2": [...], ...}
      rawSlots.forEach((key, value) {
        final day = int.tryParse(key.toString()) ?? 0;
        if (day >= 1 && day <= 7 && value is List) {
          daySlots[day] = value.map((s) => s as int).toSet();
        }
      });
    }

    return StaffPlanningWeekTemplate(
      id: json['id'] as int? ?? 0,
      staffPlanningId: json['staff_planning_id'] as int? ?? 0,
      weekLabel: WeekLabel.values.firstWhere(
        (l) => l.name == (json['week_label'] as String?)?.toLowerCase(),
        orElse: () => WeekLabel.a,
      ),
      daySlots: daySlots,
    );
  }

  Map<String, dynamic> toJson() {
    // Converti daySlots in formato lista per JSON
    final List<Map<String, dynamic>> slotsJson = [];
    for (int day = 1; day <= 7; day++) {
      final slots = daySlots[day];
      if (slots != null) {
        slotsJson.add({'day_of_week': day, 'slots': slots.toList()..sort()});
      }
    }

    return {
      'id': id,
      'staff_planning_id': staffPlanningId,
      'week_label': weekLabel.name.toUpperCase(),
      'day_slots': slotsJson,
    };
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StaffPlanningWeekTemplate &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          staffPlanningId == other.staffPlanningId &&
          weekLabel == other.weekLabel &&
          mapEquals(daySlots, other.daySlots);

  @override
  int get hashCode => Object.hash(id, staffPlanningId, weekLabel);

  @override
  String toString() =>
      'StaffPlanningWeekTemplate(id: $id, weekLabel: ${weekLabel.name}, '
      'days: ${daySlots.keys.toList()..sort()})';
}

/// Estensione helper per DateUtils.
extension DateUtils on DateTime {
  /// Ritorna la data senza componente oraria (mezzanotte).
  static DateTime dateOnly(DateTime date) =>
      DateTime(date.year, date.month, date.day);
}
--- FILE: lib/core/models/service_variant.dart ---
import 'service_variant_resource_requirement.dart';

class ServiceVariant {
  final int id;
  final int serviceId;
  final int locationId;
  final int durationMinutes;
  final int? processingTime; // minuti opzionali post-lavorazione
  final int? blockedTime; // minuti opzionali bloccati
  final double price;
  final String? colorHex;
  final String? currency; // üîπ Valuta specifica (es. "EUR", "USD")
  final bool isBookableOnline;
  final bool isFree;
  final bool isPriceStartingFrom;
  final List<ServiceVariantResourceRequirement> resourceRequirements;

  const ServiceVariant({
    required this.id,
    required this.serviceId,
    required this.locationId,
    required this.durationMinutes,
    this.processingTime,
    this.blockedTime,
    required this.price,
    this.colorHex,
    this.currency,
    this.isBookableOnline = true,
    this.isFree = false,
    this.isPriceStartingFrom = false,
    this.resourceRequirements = const [],
  });

  ServiceVariant copyWith({
    int? id,
    int? serviceId,
    int? locationId,
    int? durationMinutes,
    int? processingTime,
    int? blockedTime,
    double? price,
    String? colorHex,
    String? currency,
    bool? isBookableOnline,
    bool? isFree,
    bool? isPriceStartingFrom,
    List<ServiceVariantResourceRequirement>? resourceRequirements,
  }) {
    return ServiceVariant(
      id: id ?? this.id,
      serviceId: serviceId ?? this.serviceId,
      locationId: locationId ?? this.locationId,
      durationMinutes: durationMinutes ?? this.durationMinutes,
      processingTime: processingTime ?? this.processingTime,
      blockedTime: blockedTime ?? this.blockedTime,
      price: price ?? this.price,
      colorHex: colorHex ?? this.colorHex,
      currency: currency ?? this.currency,
      isBookableOnline: isBookableOnline ?? this.isBookableOnline,
      isFree: isFree ?? this.isFree,
      isPriceStartingFrom: isPriceStartingFrom ?? this.isPriceStartingFrom,
      resourceRequirements:
          resourceRequirements ?? this.resourceRequirements,
    );
  }

  factory ServiceVariant.fromJson(Map<String, dynamic> json) {
    return ServiceVariant(
      id: json['id'] as int,
      serviceId: json['service_id'] as int,
      locationId: json['location_id'] as int,
      durationMinutes: json['duration_minutes'] as int,
      processingTime: json['processing_time'] as int?,
      blockedTime: json['blocked_time'] as int?,
      price: (json['price'] as num).toDouble(),
      colorHex: json['color_hex'] as String?,
      currency: json['currency'] as String?,
      isBookableOnline: json['is_bookable_online'] as bool? ?? true,
      isFree: json['is_free'] as bool? ?? false,
      isPriceStartingFrom: json['is_price_starting_from'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'service_id': serviceId,
      'location_id': locationId,
      'duration_minutes': durationMinutes,
      if (processingTime != null) 'processing_time': processingTime,
      if (blockedTime != null) 'blocked_time': blockedTime,
      'price': price,
      if (colorHex != null) 'color_hex': colorHex,
      if (currency != null) 'currency': currency,
      'is_bookable_online': isBookableOnline,
      'is_free': isFree,
      'is_price_starting_from': isPriceStartingFrom,
    };
  }
}
--- FILE: lib/core/models/class_type.dart ---
class ClassType {
  final int id;
  final int businessId;
  final String name;
  final String? description;
  final bool isActive;
  final List<int> locationIds;

  const ClassType({
    required this.id,
    required this.businessId,
    required this.name,
    this.description,
    required this.isActive,
    this.locationIds = const [],
  });

  factory ClassType.fromJson(Map<String, dynamic> json) {
    return ClassType(
      id: (json['id'] as num).toInt(),
      businessId: (json['business_id'] as num?)?.toInt() ?? 0,
      name: (json['name'] as String?)?.trim() ?? '',
      description: json['description'] as String?,
      isActive:
          (json['is_active'] as bool?) ??
          ((json['is_active'] as num?)?.toInt() == 1),
      locationIds: (json['location_ids'] as List<dynamic>? ?? const [])
          .map((item) => (item as num).toInt())
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'business_id': businessId,
      'name': name,
      'description': description,
      'is_active': isActive,
      'location_ids': locationIds,
    };
  }
}
--- FILE: lib/core/models/service_variant_resource_requirement.dart ---
class ServiceVariantResourceRequirement {
  final int id;
  final int? serviceVariantId;
  final int resourceId;
  final String? resourceName;
  final int unitsRequired;

  const ServiceVariantResourceRequirement({
    required this.id,
    this.serviceVariantId,
    required this.resourceId,
    this.resourceName,
    required this.unitsRequired,
  });

  ServiceVariantResourceRequirement copyWith({
    int? id,
    int? serviceVariantId,
    int? resourceId,
    String? resourceName,
    int? unitsRequired,
  }) {
    return ServiceVariantResourceRequirement(
      id: id ?? this.id,
      serviceVariantId: serviceVariantId ?? this.serviceVariantId,
      resourceId: resourceId ?? this.resourceId,
      resourceName: resourceName ?? this.resourceName,
      unitsRequired: unitsRequired ?? this.unitsRequired,
    );
  }

  factory ServiceVariantResourceRequirement.fromJson(
    Map<String, dynamic> json,
  ) {
    return ServiceVariantResourceRequirement(
      id: json['id'] as int,
      serviceVariantId: json['service_variant_id'] as int?,
      resourceId: json['resource_id'] as int,
      resourceName: json['resource_name'] as String?,
      // API returns 'quantity', model uses 'unitsRequired'
      unitsRequired:
          json['quantity'] as int? ?? json['units_required'] as int? ?? 1,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      if (serviceVariantId != null) 'service_variant_id': serviceVariantId,
      'resource_id': resourceId,
      if (resourceName != null) 'resource_name': resourceName,
      'quantity': unitsRequired,
    };
  }
}
--- FILE: lib/core/models/popular_service.dart ---
import 'package:flutter/foundation.dart';

/// Modello per un servizio popolare (top 5 pi√π prenotati).
/// Ritornato dall'endpoint /v1/staff/{staff_id}/services/popular
@immutable
class PopularService {
  final int rank;
  final int bookingCount;
  final int serviceId;
  final String serviceName;
  final int? categoryId;
  final String? categoryName;
  final double price;
  final int durationMinutes;
  final String? color;

  const PopularService({
    required this.rank,
    required this.bookingCount,
    required this.serviceId,
    required this.serviceName,
    this.categoryId,
    this.categoryName,
    required this.price,
    required this.durationMinutes,
    this.color,
  });

  factory PopularService.fromJson(Map<String, dynamic> json) {
    return PopularService(
      rank: json['rank'] as int,
      bookingCount: json['booking_count'] as int,
      serviceId: json['service_id'] as int,
      serviceName: json['service_name'] as String,
      categoryId: json['category_id'] as int?,
      categoryName: json['category_name'] as String?,
      price: (json['price'] as num).toDouble(),
      durationMinutes: json['duration_minutes'] as int,
      color: json['color'] as String?,
    );
  }

  Map<String, dynamic> toJson() => {
    'rank': rank,
    'booking_count': bookingCount,
    'service_id': serviceId,
    'service_name': serviceName,
    'category_id': categoryId,
    'category_name': categoryName,
    'price': price,
    'duration_minutes': durationMinutes,
    'color': color,
  };

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PopularService &&
          runtimeType == other.runtimeType &&
          serviceId == other.serviceId;

  @override
  int get hashCode => serviceId.hashCode;
}

/// Risultato dell'endpoint popular services
@immutable
class PopularServicesResult {
  final List<PopularService> popularServices;
  final int enabledServicesCount;
  final bool showPopularSection;

  const PopularServicesResult({
    required this.popularServices,
    required this.enabledServicesCount,
    required this.showPopularSection,
  });

  factory PopularServicesResult.fromJson(Map<String, dynamic> json) {
    final servicesList =
        (json['popular_services'] as List<dynamic>?)
            ?.map((e) => PopularService.fromJson(e as Map<String, dynamic>))
            .toList() ??
        [];

    return PopularServicesResult(
      popularServices: servicesList,
      enabledServicesCount: json['enabled_services_count'] as int? ?? 0,
      showPopularSection: json['show_popular_section'] as bool? ?? false,
    );
  }

  /// Risultato vuoto (nessun servizio popolare)
  static const empty = PopularServicesResult(
    popularServices: [],
    enabledServicesCount: 0,
    showPopularSection: false,
  );
}
--- FILE: lib/core/models/business.dart ---
class Business {
  final int id;
  final String name;
  final String? slug;
  final String? email;
  final String? phone;
  final String? onlineBookingsNotificationEmail;
  final String serviceColorPalette;
  final String? timezone;
  final DateTime createdAt;
  final String currency;
  final String defaultPhonePrefix;
  final int? cancellationHours;
  final String? adminEmail; // Email dell'admin proprietario
  final bool isSuspended; // Business sospeso (visibile ma non operativo)
  final String? suspensionMessage; // Messaggio da mostrare quando sospeso
  final String? userRole; // Ruolo dell'utente corrente nel business
  final String? userScopeType; // Scope dell'utente corrente nel business

  const Business({
    required this.id,
    required this.name,
    this.slug,
    this.email,
    this.phone,
    this.onlineBookingsNotificationEmail,
    this.serviceColorPalette = 'legacy',
    this.timezone,
    required this.createdAt,
    this.currency = 'EUR',
    this.defaultPhonePrefix = '+39',
    this.cancellationHours,
    this.adminEmail,
    this.isSuspended = false,
    this.suspensionMessage,
    this.userRole,
    this.userScopeType,
  });

  Business copyWith({
    int? id,
    String? name,
    String? slug,
    String? email,
    String? phone,
    String? onlineBookingsNotificationEmail,
    String? serviceColorPalette,
    String? timezone,
    DateTime? createdAt,
    String? currency,
    String? defaultPhonePrefix,
    int? cancellationHours,
    String? adminEmail,
    bool? isSuspended,
    String? suspensionMessage,
    String? userRole,
    String? userScopeType,
  }) {
    return Business(
      id: id ?? this.id,
      name: name ?? this.name,
      slug: slug ?? this.slug,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      onlineBookingsNotificationEmail:
          onlineBookingsNotificationEmail ??
          this.onlineBookingsNotificationEmail,
      serviceColorPalette: serviceColorPalette ?? this.serviceColorPalette,
      timezone: timezone ?? this.timezone,
      createdAt: createdAt ?? this.createdAt,
      currency: currency ?? this.currency,
      defaultPhonePrefix: defaultPhonePrefix ?? this.defaultPhonePrefix,
      cancellationHours: cancellationHours ?? this.cancellationHours,
      adminEmail: adminEmail ?? this.adminEmail,
      isSuspended: isSuspended ?? this.isSuspended,
      suspensionMessage: suspensionMessage ?? this.suspensionMessage,
      userRole: userRole ?? this.userRole,
      userScopeType: userScopeType ?? this.userScopeType,
    );
  }

  factory Business.fromJson(Map<String, dynamic> json) {
    return Business(
      id: json['id'] as int,
      name: json['name'] as String,
      slug: json['slug'] as String?,
      email: json['email'] as String?,
      phone: json['phone'] as String?,
      onlineBookingsNotificationEmail:
          json['online_bookings_notification_email'] as String?,
      serviceColorPalette: json['service_color_palette'] as String? ?? 'legacy',
      timezone: json['timezone'] as String?,
      createdAt: json['created_at'] != null
          ? DateTime.parse(json['created_at'] as String)
          : DateTime.now(),
      currency: json['currency'] as String? ?? 'EUR',
      defaultPhonePrefix: json['default_phone_prefix'] as String? ?? '+39',
      cancellationHours: json['cancellation_hours'] as int?,
      adminEmail: json['admin_email'] as String?,
      isSuspended: json['is_suspended'] == true || json['is_suspended'] == 1,
      suspensionMessage: json['suspension_message'] as String?,
      userRole: json['user_role'] as String?,
      userScopeType: json['user_scope_type'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'slug': slug,
      'email': email,
      'phone': phone,
      'online_bookings_notification_email': onlineBookingsNotificationEmail,
      'service_color_palette': serviceColorPalette,
      'timezone': timezone,
      'created_at': createdAt.toIso8601String(),
      'currency': currency,
      'default_phone_prefix': defaultPhonePrefix,
      if (cancellationHours != null) 'cancellation_hours': cancellationHours,
      'admin_email': adminEmail,
      'is_suspended': isSuspended,
      'suspension_message': suspensionMessage,
      'user_role': userRole,
      'user_scope_type': userScopeType,
    };
  }
}
--- FILE: lib/core/services/preferences_service.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Provider per SharedPreferences (inizializzato in main.dart)
final sharedPreferencesProvider = Provider<SharedPreferences>((ref) {
  throw UnimplementedError(
    'sharedPreferencesProvider must be overridden in ProviderScope',
  );
});

/// Chiavi per le preferenze salvate.
/// Le preferenze sono salvate per business_id per supportare superadmin
/// che gestiscono pi√π business.
class PrefsKeys {
  /// Genera la chiave per staff filter mode per un business specifico
  static String staffFilterMode(int businessId) =>
      'staff_filter_mode_$businessId';

  /// Genera la chiave per selected staff IDs per un business specifico
  static String selectedStaffIds(int businessId) =>
      'selected_staff_ids_$businessId';

  /// Genera la chiave per current location ID per un business specifico
  static String currentLocationId(int businessId) =>
      'current_location_id_$businessId';

  /// Chiave per ultimo business visitato dal superadmin
  static const superadminLastBusinessId = 'superadmin_last_business_id';

  /// Chiave legacy (senza business_id) per migrazione
  static const legacyStaffFilterMode = 'staff_filter_mode';
  static const legacySelectedStaffIds = 'selected_staff_ids';
  static const legacyCurrentLocationId = 'current_location_id';
}

/// Service per gestire le preferenze utente.
/// Le preferenze sono salvate per business per supportare operatori
/// che lavorano su pi√π business (superadmin).
class PreferencesService {
  final SharedPreferences _prefs;

  PreferencesService(this._prefs);

  // ============================================
  // Staff Filter Mode
  // ============================================

  /// Ottiene il filtro staff salvato per il business.
  /// Cerca prima la chiave per business, poi fallback su legacy.
  String? getStaffFilterMode(int businessId) {
    // Prima prova chiave per business
    var value = _prefs.getString(PrefsKeys.staffFilterMode(businessId));
    if (value != null) return value;

    // Fallback su chiave legacy (migrazione)
    value = _prefs.getString(PrefsKeys.legacyStaffFilterMode);
    if (value != null) {
      // Migra alla nuova chiave
      setStaffFilterMode(businessId, value);
      _prefs.remove(PrefsKeys.legacyStaffFilterMode);
    }
    return value;
  }

  Future<void> setStaffFilterMode(int businessId, String mode) async {
    await _prefs.setString(PrefsKeys.staffFilterMode(businessId), mode);
  }

  // ============================================
  // Selected Staff IDs
  // ============================================

  /// Ottiene gli ID staff selezionati per il business.
  /// Gli ID vengono validati: ID <= 0 sono filtrati.
  List<int> getSelectedStaffIds(int businessId) {
    // Prima prova chiave per business
    var json = _prefs.getString(PrefsKeys.selectedStaffIds(businessId));

    // Fallback su chiave legacy
    if (json == null) {
      json = _prefs.getString(PrefsKeys.legacySelectedStaffIds);
      if (json != null) {
        // Migra alla nuova chiave
        _prefs.setString(PrefsKeys.selectedStaffIds(businessId), json);
        _prefs.remove(PrefsKeys.legacySelectedStaffIds);
      }
    }

    if (json == null || json.isEmpty) return [];

    // Parse sicuro: ignora valori non validi
    return json
        .split(',')
        .map((s) => int.tryParse(s.trim()) ?? 0)
        .where((id) => id > 0)
        .toList();
  }

  Future<void> setSelectedStaffIds(int businessId, Set<int> ids) async {
    if (ids.isEmpty) {
      // Rimuovi la chiave se vuota per risparmiare spazio
      await _prefs.remove(PrefsKeys.selectedStaffIds(businessId));
    } else {
      await _prefs.setString(
        PrefsKeys.selectedStaffIds(businessId),
        ids.join(','),
      );
    }
  }

  // ============================================
  // Current Location ID
  // ============================================

  /// Ottiene la location corrente salvata per il business.
  int? getCurrentLocationId(int businessId) {
    // Prima prova chiave per business
    var value = _prefs.getInt(PrefsKeys.currentLocationId(businessId));
    if (value != null) return value;

    // Fallback su chiave legacy
    value = _prefs.getInt(PrefsKeys.legacyCurrentLocationId);
    if (value != null) {
      // Migra alla nuova chiave
      setCurrentLocationId(businessId, value);
      _prefs.remove(PrefsKeys.legacyCurrentLocationId);
    }
    return value;
  }

  Future<void> setCurrentLocationId(int businessId, int id) async {
    await _prefs.setInt(PrefsKeys.currentLocationId(businessId), id);
  }

  // ============================================
  // Superadmin Last Business ID
  // ============================================

  /// Ottiene l'ultimo business visitato dal superadmin.
  int? getSuperadminLastBusinessId() {
    return _prefs.getInt(PrefsKeys.superadminLastBusinessId);
  }

  /// Salva l'ultimo business visitato dal superadmin.
  Future<void> setSuperadminLastBusinessId(int businessId) async {
    await _prefs.setInt(PrefsKeys.superadminLastBusinessId, businessId);
  }

  /// Rimuove l'ultimo business salvato (es. se il business viene eliminato).
  Future<void> clearSuperadminLastBusinessId() async {
    await _prefs.remove(PrefsKeys.superadminLastBusinessId);
  }

  // ============================================
  // Clear / Cleanup
  // ============================================

  /// Pulisce le preferenze per un business specifico.
  /// Utile quando il superadmin esce da un business.
  Future<void> clearForBusiness(int businessId) async {
    await _prefs.remove(PrefsKeys.staffFilterMode(businessId));
    await _prefs.remove(PrefsKeys.selectedStaffIds(businessId));
    await _prefs.remove(PrefsKeys.currentLocationId(businessId));
  }

  /// Pulisce tutte le preferenze (logout completo).
  Future<void> clearAll() async {
    // Rimuovi tutte le chiavi che iniziano con i nostri prefix
    final keys = _prefs.getKeys();
    for (final key in keys) {
      if (key.startsWith('staff_filter_mode') ||
          key.startsWith('selected_staff_ids') ||
          key.startsWith('current_location_id')) {
        await _prefs.remove(key);
      }
    }
  }
}

/// Provider per PreferencesService
final preferencesServiceProvider = Provider<PreferencesService>((ref) {
  final prefs = ref.watch(sharedPreferencesProvider);
  return PreferencesService(prefs);
});
--- FILE: lib/core/services/credentials_storage.dart ---
/// Gestione sicura delle credenziali salvate per accesso rapido.
/// - Web: usa localStorage (base64 encoded, non sicuro per dati sensibili in produzione reale)
/// - Mobile: usa flutter_secure_storage
abstract class CredentialsStorage {
  /// Recupera le credenziali salvate (email, password)
  Future<({String? email, String? password})> getSavedCredentials();

  /// Salva le credenziali per accesso rapido futuro
  Future<void> saveCredentials(String email, String password);

  /// Cancella le credenziali salvate
  Future<void> clearCredentials();

  /// Verifica se ci sono credenziali salvate
  Future<bool> hasCredentials();
}
--- FILE: lib/core/services/credentials_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'credentials_storage.dart';
import 'credentials_storage_stub.dart'
    if (dart.library.html) 'credentials_storage_web.dart'
    if (dart.library.io) 'credentials_storage_mobile.dart';

/// Provider per accedere al credentials storage
final credentialsStorageProvider = Provider<CredentialsStorage>((ref) {
  return createCredentialsStorage();
});

/// Provider per le credenziali salvate
final savedCredentialsProvider =
    FutureProvider<({String? email, String? password})>((ref) async {
      final storage = ref.watch(credentialsStorageProvider);
      return storage.getSavedCredentials();
    });
--- FILE: lib/core/services/credentials_storage_stub.dart ---
import 'credentials_storage.dart';

/// Stub per conditional import
CredentialsStorage createCredentialsStorage() => throw UnsupportedError(
  'Cannot create credentials storage without dart:html or flutter_secure_storage',
);
--- FILE: lib/core/services/version_checker.dart ---
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;

import 'version_checker_stub.dart'
    if (dart.library.html) 'version_checker_web.dart';

/// Service che controlla periodicamente se c'√® una nuova versione dell'app.
/// Se rileva un aggiornamento, forza il reload automatico della pagina.
///
/// Usa il file `app_version.txt` che contiene solo la stringa versione
/// (es. "20260129-1.6"). Questo file deve essere generato/aggiornato
/// manualmente durante il deploy.
class VersionChecker {
  static VersionChecker? _instance;
  static VersionChecker get instance => _instance ??= VersionChecker._();

  VersionChecker._();

  Timer? _timer;
  String? _currentVersion;
  bool _isChecking = false;

  /// Intervallo di controllo (default: 60 secondi)
  static const _checkInterval = Duration(seconds: 60);

  /// Avvia il controllo periodico della versione.
  /// Chiamare una sola volta all'avvio dell'app.
  void startPeriodicCheck() {
    // Solo su web
    if (!kIsWeb) return;

    // Evita avvii multipli
    if (_timer != null) return;

    debugPrint('VersionChecker: Starting periodic version check');

    // Primo check immediato per salvare la versione corrente
    _checkVersion();

    // Check periodico
    _timer = Timer.periodic(_checkInterval, (_) => _checkVersion());
  }

  /// Ferma il controllo periodico
  void stopPeriodicCheck() {
    _timer?.cancel();
    _timer = null;
  }

  Future<void> _checkVersion() async {
    if (_isChecking) return;
    _isChecking = true;

    try {
      // Fetch app_version.txt con cache-busting
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final response = await http
          .get(Uri.parse('/app_version.txt?_=$timestamp'))
          .timeout(const Duration(seconds: 10));

      if (response.statusCode == 200) {
        final serverVersion = response.body.trim();

        if (serverVersion.isNotEmpty) {
          if (_currentVersion == null) {
            // Prima esecuzione: salva la versione corrente
            _currentVersion = serverVersion;
            debugPrint('VersionChecker: Initial version: $_currentVersion');
          } else if (_currentVersion != serverVersion) {
            // Versione cambiata: forza reload
            debugPrint(
              'VersionChecker: New version detected! '
              '$_currentVersion -> $serverVersion. Reloading...',
            );
            forceReload();
          }
        }
      }
    } catch (e) {
      // Ignora errori di rete - riprover√† al prossimo ciclo
      debugPrint('VersionChecker: Check failed: $e');
    } finally {
      _isChecking = false;
    }
  }

  /// Forza il reload della pagina (solo web)
  void forceReload() {
    performHardReload();
  }
}
--- FILE: lib/core/services/version_checker_web.dart ---
// ignore: avoid_web_libraries_in_flutter
import 'dart:html' as html;

import 'package:flutter/foundation.dart';

/// Esegue un hard reload della pagina web (bypassa la cache)
void performHardReload() {
  // true = forza reload dal server, ignora cache
  html.window.location.reload();
  debugPrint('Performed hard reload of the page');
}
--- FILE: lib/core/services/credentials_storage_web.dart ---
// ignore_for_file: avoid_web_libraries_in_flutter
import 'dart:convert';
import 'dart:html' as html;

import 'package:flutter/foundation.dart';

import 'credentials_storage.dart';

/// Implementazione Web che usa localStorage con encoding base64.
/// NOTA: Non √® una soluzione sicura al 100% ma offre una protezione
/// minima contro lettura casuale. Il browser comunque protegge
/// localStorage per dominio (same-origin policy).
class WebCredentialsStorage implements CredentialsStorage {
  static const _emailKey = 'agenda_backend_saved_email';
  static const _passwordKey = 'agenda_backend_saved_password';

  @override
  Future<({String? email, String? password})> getSavedCredentials() async {
    try {
      final encodedEmail = html.window.localStorage[_emailKey];
      final encodedPassword = html.window.localStorage[_passwordKey];

      if (encodedEmail == null || encodedPassword == null) {
        return (email: null, password: null);
      }

      final email = utf8.decode(base64Decode(encodedEmail));
      final password = utf8.decode(base64Decode(encodedPassword));

      return (email: email, password: password);
    } catch (e) {
      debugPrint('CredentialsStorage: Error reading credentials: $e');
      return (email: null, password: null);
    }
  }

  @override
  Future<void> saveCredentials(String email, String password) async {
    try {
      final encodedEmail = base64Encode(utf8.encode(email));
      final encodedPassword = base64Encode(utf8.encode(password));

      html.window.localStorage[_emailKey] = encodedEmail;
      html.window.localStorage[_passwordKey] = encodedPassword;
    } catch (e) {
      debugPrint('CredentialsStorage: Error saving credentials: $e');
    }
  }

  @override
  Future<void> clearCredentials() async {
    try {
      html.window.localStorage.remove(_emailKey);
      html.window.localStorage.remove(_passwordKey);
    } catch (e) {
      debugPrint('CredentialsStorage: Error clearing credentials: $e');
    }
  }

  @override
  Future<bool> hasCredentials() async {
    try {
      return html.window.localStorage[_emailKey] != null &&
          html.window.localStorage[_passwordKey] != null;
    } catch (e) {
      return false;
    }
  }
}

/// Factory per creare storage su Web
CredentialsStorage createCredentialsStorage() => WebCredentialsStorage();
--- FILE: lib/core/services/staff_planning_selector.dart ---
import '../models/staff_planning.dart';

/// Risultato della ricerca di un planning valido per una data.
sealed class PlanningLookupResult {
  const PlanningLookupResult();
}

/// Nessun planning trovato per la data.
/// Staff non disponibile in quella data.
class NoPlanningFound extends PlanningLookupResult {
  const NoPlanningFound();

  @override
  String toString() => 'NoPlanningFound()';
}

/// Planning valido trovato.
class PlanningFound extends PlanningLookupResult {
  final StaffPlanning planning;
  final WeekLabel weekLabel;
  final StaffPlanningWeekTemplate template;

  const PlanningFound({
    required this.planning,
    required this.weekLabel,
    required this.template,
  });

  @override
  String toString() =>
      'PlanningFound(planning: ${planning.id}, weekLabel: ${weekLabel.name})';
}

/// Errore: trovati pi√π planning validi (inconsistenza dati).
class MultiplePlanningsFound extends PlanningLookupResult {
  final List<StaffPlanning> plannings;
  final String message;

  const MultiplePlanningsFound({
    required this.plannings,
    required this.message,
  });

  @override
  String toString() => 'MultiplePlanningsFound(count: ${plannings.length})';
}

/// Servizio per la selezione del planning valido per una data.
///
/// Implementa le regole di docs/STAFF_PLANNING_MODEL.md:
/// - Filtra planning con valid_from ‚â§ D ‚â§ valid_to (o valid_to null)
/// - Nessun planning ‚Üí staff non disponibile
/// - Pi√π di uno ‚Üí errore di consistenza
class StaffPlanningSelector {
  /// Trova il planning valido per uno staff in una data specifica.
  ///
  /// [staffId] ID dello staff.
  /// [date] Data per cui cercare il planning.
  /// [allPlannings] Tutti i planning disponibili (gi√† filtrati per staff se desiderato).
  ///
  /// Ritorna:
  /// - [NoPlanningFound] se non esiste planning valido per la data
  /// - [PlanningFound] se esiste esattamente un planning valido
  /// - [MultiplePlanningsFound] se esistono pi√π planning validi (errore dati)
  PlanningLookupResult findPlanningForDate({
    required int staffId,
    required DateTime date,
    required List<StaffPlanning> allPlannings,
  }) {
    // Filtra i planning per questo staff
    final staffPlannings = allPlannings
        .where((p) => p.staffId == staffId)
        .toList();

    // Filtra i planning validi per la data
    final validPlannings = staffPlannings
        .where((p) => p.isValidForDate(date))
        .toList();

    // Caso 1: nessun planning ‚Üí staff non disponibile
    if (validPlannings.isEmpty) {
      return const NoPlanningFound();
    }

    // Caso 2: pi√π di uno ‚Üí errore di consistenza
    if (validPlannings.length > 1) {
      return MultiplePlanningsFound(
        plannings: validPlannings,
        message:
            'Trovati ${validPlannings.length} planning validi per staff $staffId '
            'alla data ${_formatDate(date)}. '
            'Questo indica un errore nei dati (intervalli sovrapposti).',
      );
    }

    // Caso 3: esattamente un planning
    final planning = validPlannings.first;
    final weekLabel = planning.computeWeekLabel(date);
    final template = planning.getTemplateForDate(date);

    // Verifica che il template esista
    if (template == null) {
      // Questo non dovrebbe accadere se la validazione √® corretta,
      // ma gestiamo il caso per robustezza
      return const NoPlanningFound();
    }

    return PlanningFound(
      planning: planning,
      weekLabel: weekLabel,
      template: template,
    );
  }

  /// Ottiene gli slot disponibili per uno staff in una data specifica.
  ///
  /// Ritorna un Set vuoto se:
  /// - Non esiste planning valido per la data
  /// - Il giorno non ha slot configurati nel template
  ///
  /// Ritorna null se c'√® un errore di consistenza (pi√π planning).
  Set<int>? getSlotsForDate({
    required int staffId,
    required DateTime date,
    required List<StaffPlanning> allPlannings,
  }) {
    final result = findPlanningForDate(
      staffId: staffId,
      date: date,
      allPlannings: allPlannings,
    );

    return switch (result) {
      NoPlanningFound() => {},
      PlanningFound(template: final t) => t.getSlotsForDay(date.weekday),
      MultiplePlanningsFound() => null, // Errore, caller deve gestire
    };
  }

  /// Verifica se uno staff √® disponibile in una data.
  ///
  /// Ritorna true se:
  /// - Esiste un planning valido per la data
  /// - Il giorno ha almeno uno slot configurato
  bool isStaffAvailable({
    required int staffId,
    required DateTime date,
    required List<StaffPlanning> allPlannings,
  }) {
    final slots = getSlotsForDate(
      staffId: staffId,
      date: date,
      allPlannings: allPlannings,
    );

    return slots != null && slots.isNotEmpty;
  }

  /// Trova tutti i planning validi in un range di date per uno staff.
  ///
  /// Utile per visualizzare la pianificazione in un calendario.
  /// Ritorna una mappa: data ‚Üí PlanningLookupResult
  Map<DateTime, PlanningLookupResult> findPlanningsForRange({
    required int staffId,
    required DateTime startDate,
    required DateTime endDate,
    required List<StaffPlanning> allPlannings,
  }) {
    final results = <DateTime, PlanningLookupResult>{};

    var current = DateUtils.dateOnly(startDate);
    final end = DateUtils.dateOnly(endDate);

    while (!current.isAfter(end)) {
      results[current] = findPlanningForDate(
        staffId: staffId,
        date: current,
        allPlannings: allPlannings,
      );
      current = current.add(const Duration(days: 1));
    }

    return results;
  }

  /// Trova il prossimo planning valido dopo una data.
  ///
  /// Utile per mostrare quando uno staff diventer√† disponibile.
  /// Ritorna null se non esiste un planning futuro.
  StaffPlanning? findNextPlanning({
    required int staffId,
    required DateTime afterDate,
    required List<StaffPlanning> allPlannings,
  }) {
    final date = DateUtils.dateOnly(afterDate);

    // Filtra i planning per questo staff che iniziano dopo la data
    final futurePlannings = allPlannings
        .where((p) => p.staffId == staffId)
        .where((p) => DateUtils.dateOnly(p.validFrom).isAfter(date))
        .toList();

    if (futurePlannings.isEmpty) return null;

    // Ordina per validFrom e prendi il primo
    futurePlannings.sort((a, b) => a.validFrom.compareTo(b.validFrom));
    return futurePlannings.first;
  }

  String _formatDate(DateTime d) =>
      '${d.year.toString().padLeft(4, '0')}-'
      '${d.month.toString().padLeft(2, '0')}-'
      '${d.day.toString().padLeft(2, '0')}';
}
--- FILE: lib/core/services/credentials_storage_mobile.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

import 'credentials_storage.dart';

/// Implementazione secure storage per mobile/desktop.
/// Usa flutter_secure_storage per salvare in modo sicuro le credenziali.
class SecureCredentialsStorage implements CredentialsStorage {
  static const _emailKey = 'agenda_backend_saved_email';
  static const _passwordKey = 'agenda_backend_saved_password';

  final FlutterSecureStorage _storage;

  SecureCredentialsStorage()
    : _storage = const FlutterSecureStorage(
        aOptions: AndroidOptions(encryptedSharedPreferences: true),
        iOptions: IOSOptions(accessibility: KeychainAccessibility.first_unlock),
      );

  @override
  Future<({String? email, String? password})> getSavedCredentials() async {
    try {
      final email = await _storage.read(key: _emailKey);
      final password = await _storage.read(key: _passwordKey);

      return (email: email, password: password);
    } catch (e) {
      debugPrint('CredentialsStorage: Error reading credentials: $e');
      return (email: null, password: null);
    }
  }

  @override
  Future<void> saveCredentials(String email, String password) async {
    try {
      await _storage.write(key: _emailKey, value: email);
      await _storage.write(key: _passwordKey, value: password);
    } catch (e) {
      debugPrint('CredentialsStorage: Error saving credentials: $e');
    }
  }

  @override
  Future<void> clearCredentials() async {
    try {
      await _storage.delete(key: _emailKey);
      await _storage.delete(key: _passwordKey);
    } catch (e) {
      debugPrint('CredentialsStorage: Error clearing credentials: $e');
    }
  }

  @override
  Future<bool> hasCredentials() async {
    try {
      final email = await _storage.read(key: _emailKey);
      final password = await _storage.read(key: _passwordKey);
      return email != null && password != null;
    } catch (e) {
      return false;
    }
  }
}

/// Factory per creare storage su mobile/desktop
CredentialsStorage createCredentialsStorage() => SecureCredentialsStorage();
--- FILE: lib/core/services/version_checker_stub.dart ---
/// Stub per piattaforme non-web
void performHardReload() {
  // No-op su piattaforme native
}
--- FILE: lib/core/widgets/app_bottom_sheet.dart ---
import 'dart:math' as math;

import 'package:flutter/material.dart';

/// Helper to show a modal bottom sheet with the app's default styling.
class AppBottomSheet {
  AppBottomSheet._();

  /// Altezza predefinita di tutti i bottom sheet (80% dello schermo).
  static const double defaultHeightFactor = 0.95;

  static Future<T?> show<T>({
    required BuildContext context,
    required WidgetBuilder builder,
    bool isScrollControlled = true,
    bool useSafeArea = true,
    bool useRootNavigator = true,
    EdgeInsetsGeometry? padding,

    /// Fraction of screen height (0.0 to 1.0). If provided, the bottom sheet
    /// will have a minimum height of this fraction of the screen.
    double? heightFactor = defaultHeightFactor,
  }) {
    final effectivePadding =
        padding ?? const EdgeInsets.symmetric(horizontal: 20, vertical: 16);
    return showModalBottomSheet<T>(
      context: context,
      isScrollControlled: isScrollControlled,
      backgroundColor: Colors.white,
      useSafeArea: useSafeArea,
      useRootNavigator: useRootNavigator,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (ctx) => AppBottomSheetContainer(
        padding: effectivePadding,
        heightFactor: heightFactor,
        child: builder(ctx),
      ),
    );
  }
}

/// Provides consistent padding, animation and handle for bottom sheet content.
class AppBottomSheetContainer extends StatelessWidget {
  const AppBottomSheetContainer({
    super.key,
    required this.child,
    this.padding = const EdgeInsets.symmetric(horizontal: 20, vertical: 16),
    this.showHandle = true,
    this.heightFactor,
  });

  final Widget child;
  final EdgeInsetsGeometry padding;
  final bool showHandle;

  /// If provided, the container will have a minimum height of this fraction
  /// of the screen height (0.0 to 1.0).
  final double? heightFactor;

  @override
  Widget build(BuildContext context) {
    final keyboardInset = MediaQuery.of(context).viewInsets.bottom;
    Widget content;

    // Apply height constraint if heightFactor is provided
    // Use SizedBox (not ConstrainedBox) to provide a finite height
    // so that Expanded children inside Column can work properly
    if (heightFactor != null) {
      // Ensure bottom padding is at least 50.0 to leave space above
      // system UI / controls and provide consistent spacing across sheets.
      final resolved = padding.resolve(Directionality.of(context));
      final effectivePadding = resolved.copyWith(
        bottom: math.max(resolved.bottom, 50.0),
      );
      final screenHeight = MediaQuery.of(context).size.height;
      final height = screenHeight * heightFactor!;
      content = SizedBox(
        height: height,
        child: Padding(padding: effectivePadding, child: child),
      );
    } else {
      // Quando heightFactor √® null, il contenuto si adatta all'altezza naturale
      // Usa solo il padding fornito senza forzare altezza minima
      content = Padding(padding: padding, child: child);
    }

    final body = showHandle
        ? Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const SizedBox(height: 8),
              Center(
                child: Container(
                  width: 40,
                  height: 4,
                  decoration: BoxDecoration(
                    color: Colors.grey.shade300,
                    borderRadius: BorderRadius.circular(4),
                  ),
                ),
              ),
              const SizedBox(height: 12),
              // Flexible permette al contenuto di adattarsi senza forzare
              // l'altezza massima della bottom sheet.
              Flexible(child: content),
            ],
          )
        : content;

    return AnimatedPadding(
      padding: EdgeInsets.only(bottom: keyboardInset),
      duration: const Duration(milliseconds: 180),
      curve: Curves.easeOut,
      child: body,
    );
  }
}
--- FILE: lib/core/widgets/reorder_toggle_button.dart ---
import 'package:flutter/material.dart';

/// Pulsante testuale con icona che riflette uno stato (attivo/inattivo).
class ReorderToggleButton extends StatelessWidget {
  final bool isActive;
  final VoidCallback onPressed;
  final String activeLabel;
  final String inactiveLabel;
  final IconData activeIcon;
  final IconData inactiveIcon;

  const ReorderToggleButton({
    super.key,
    required this.isActive,
    required this.onPressed,
    required this.activeLabel,
    required this.inactiveLabel,
    required this.activeIcon,
    required this.inactiveIcon,
  });

  @override
  Widget build(BuildContext context) {
    final icon = isActive ? activeIcon : inactiveIcon;
    final label = isActive ? activeLabel : inactiveLabel;

    return TextButton.icon(
      onPressed: onPressed,
      icon: Icon(icon),
      label: Text(label),
    );
  }
}
--- FILE: lib/core/widgets/no_scrollbar_behavior.dart ---
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';

/// Comportamento di scroll personalizzato per l‚Äôapp Agenda.
///
/// - Rimuove glow e scrollbar visibili.
/// - Mantiene la compatibilit√† con mouse, touch e trackpad.
/// - Usa una fisica permissiva che evita conflitti con PageView
///   e altri scroll orizzontali annidati.
///
/// Questo risolve i casi in cui il PageView esterno non riceve
/// mai il gesto perch√© la scroll view interna lo cattura completamente.
class NoScrollbarBehavior extends ScrollBehavior {
  const NoScrollbarBehavior();

  /// üîπ Disabilita completamente la scrollbar visiva.
  @override
  Widget buildScrollbar(
    BuildContext context,
    Widget child,
    ScrollableDetails details,
  ) {
    return child;
  }

  /// üîπ Abilita lo scroll con tutti i tipi di input
  /// (touch, mouse, trackpad, ecc.)
  @override
  Set<PointerDeviceKind> get dragDevices => {
    PointerDeviceKind.touch,
    PointerDeviceKind.mouse,
    PointerDeviceKind.trackpad,
  };

  /// üîπ Fisica dello scroll:
  /// - `BouncingScrollPhysics` ‚Üí effetto ‚Äúelastic‚Äù ai bordi (mobile-like).
  /// - `AlwaysScrollableScrollPhysics` ‚Üí consente lo scroll anche
  ///   quando non c‚Äô√® overflow, cos√¨ i gesti possono passare
  ///   al PageView esterno.
  ///
  /// Risultato: scroll fluido, niente blocchi, compatibile con nested scroll.
  @override
  ScrollPhysics getScrollPhysics(BuildContext context) =>
      const BouncingScrollPhysics(parent: AlwaysScrollableScrollPhysics());
}
--- FILE: lib/core/widgets/staff_picker_sheet.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/staff.dart';
import 'package:agenda_backend/core/widgets/app_bottom_sheet.dart';
import 'package:agenda_backend/core/widgets/app_dividers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Mostra un picker per la selezione dello staff.
/// Su mobile usa un bottom sheet, su desktop un dialog.
Future<int?> showStaffPickerSheet({
  required BuildContext context,
  required WidgetRef ref,
  required List<Staff> staff,
  required int? selectedId,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final l10n = context.l10n;

  if (formFactor != AppFormFactor.desktop) {
    return AppBottomSheet.show<int>(
      context: context,
      padding: EdgeInsets.zero,
      builder: (ctx) => SafeArea(
        child: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Padding(
                padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                child: Text(
                  l10n.selectStaffTitle,
                  style: Theme.of(
                    ctx,
                  ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600),
                ),
              ),
              const AppDivider(),
              StaffPickerContent(
                staff: staff,
                selectedId: selectedId,
                onSelected: (staffId) => Navigator.of(ctx).pop(staffId),
              ),
              const SizedBox(height: 8),
            ],
          ),
        ),
      ),
    );
  } else {
    return showDialog<int>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.selectStaffTitle),
        content: SizedBox(
          width: 300,
          child: ConstrainedBox(
            constraints: BoxConstraints(
              maxHeight: MediaQuery.of(ctx).size.height * 0.5,
            ),
            child: SingleChildScrollView(
              child: StaffPickerContent(
                staff: staff,
                selectedId: selectedId,
                onSelected: (staffId) => Navigator.of(ctx).pop(staffId),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

/// Content widget per la selezione dello staff (riutilizzabile)
class StaffPickerContent extends StatelessWidget {
  const StaffPickerContent({
    super.key,
    required this.staff,
    required this.selectedId,
    required this.onSelected,
  });

  final List<Staff> staff;
  final int? selectedId;
  final ValueChanged<int> onSelected;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    if (staff.isEmpty) {
      return Padding(
        padding: const EdgeInsets.all(24),
        child: Center(
          child: Text(
            l10n.noStaffAvailable,
            style: theme.textTheme.bodyMedium?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
        ),
      );
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        for (final member in staff)
          ListTile(
            leading: StaffCircleAvatar(
              height: 36,
              color: member.color,
              isHighlighted: member.id == selectedId,
              initials: member.initials,
            ),
            title: Text('${member.name} ${member.surname}'.trim()),
            trailing: member.id == selectedId
                ? Icon(Icons.check, color: theme.colorScheme.primary)
                : null,
            selected: member.id == selectedId,
            onTap: () => onSelected(member.id),
          ),
      ],
    );
  }
}
--- FILE: lib/core/widgets/app_buttons.dart ---
import 'package:flutter/material.dart';

/// Centralizes button styling so we can reuse consistent widgets across the app.
class AppButtonStyles {
  static const BorderRadiusGeometry defaultBorderRadius = BorderRadius.all(
    Radius.circular(10),
  );

  static const EdgeInsetsGeometry defaultPadding = EdgeInsets.symmetric(
    vertical: 14,
    horizontal: 16,
  );

  /// Larghezza standard per i pulsanti nei dialog (es. Annulla, Salva).
  static const double dialogButtonWidth = 120.0;

  /// Padding standard per i pulsanti nei dialog.
  static const EdgeInsetsGeometry dialogButtonPadding = EdgeInsets.symmetric(
    vertical: 12,
    horizontal: 16,
  );

  static ButtonStyle filled(
    BuildContext context, {
    Color? backgroundColor,
    Color? foregroundColor,
    EdgeInsetsGeometry? padding,
    BorderRadiusGeometry? borderRadius,
  }) {
    final colorScheme = Theme.of(context).colorScheme;
    return ElevatedButton.styleFrom(
      backgroundColor: backgroundColor ?? colorScheme.primary,
      foregroundColor: foregroundColor ?? colorScheme.onPrimary,
      padding: padding ?? defaultPadding,
      shape: RoundedRectangleBorder(
        borderRadius: borderRadius ?? defaultBorderRadius,
      ),
      textStyle: const TextStyle(fontWeight: FontWeight.w600),
    );
  }

  static ButtonStyle outlined(
    BuildContext context, {
    Color? borderColor,
    Color? foregroundColor,
    EdgeInsetsGeometry? padding,
    BorderRadiusGeometry? borderRadius,
  }) {
    final colorScheme = Theme.of(context).colorScheme;
    final resolvedBorderColor = borderColor ?? colorScheme.primary;
    return OutlinedButton.styleFrom(
      foregroundColor: foregroundColor ?? resolvedBorderColor,
      side: BorderSide(color: resolvedBorderColor, width: 1.4),
      padding: padding ?? defaultPadding,
      shape: RoundedRectangleBorder(
        borderRadius: borderRadius ?? defaultBorderRadius,
      ),
      textStyle: const TextStyle(fontWeight: FontWeight.w600),
    );
  }
}

class AppFilledButton extends StatelessWidget {
  const AppFilledButton({
    super.key,
    required this.onPressed,
    required this.child,
    this.backgroundColor,
    this.foregroundColor,
    this.padding,
    this.borderRadius,
    this.expand = false,
  });

  final VoidCallback? onPressed;
  final Widget child;
  final Color? backgroundColor;
  final Color? foregroundColor;
  final EdgeInsetsGeometry? padding;
  final BorderRadiusGeometry? borderRadius;
  final bool expand;

  @override
  Widget build(BuildContext context) {
    final button = ElevatedButton(
      onPressed: onPressed,
      style: AppButtonStyles.filled(
        context,
        backgroundColor: backgroundColor,
        foregroundColor: foregroundColor,
        padding: padding,
        borderRadius: borderRadius,
      ),
      child: child,
    );

    if (expand) {
      return SizedBox(width: double.infinity, child: button);
    }
    return button;
  }
}

class AppDangerButton extends StatelessWidget {
  const AppDangerButton({
    super.key,
    required this.onPressed,
    required this.child,
    this.expand = false,
    this.padding,
    this.borderRadius,
    this.backgroundColor,
  });

  final VoidCallback? onPressed;
  final Widget child;
  final bool expand;
  final EdgeInsetsGeometry? padding;
  final BorderRadiusGeometry? borderRadius;
  final Color? backgroundColor;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    return AppFilledButton(
      onPressed: onPressed,
      expand: expand,
      padding: padding,
      borderRadius: borderRadius,
      backgroundColor: backgroundColor ?? colorScheme.error,
      foregroundColor: colorScheme.onError,
      child: child,
    );
  }
}

class AppOutlinedActionButton extends StatelessWidget {
  const AppOutlinedActionButton({
    super.key,
    required this.onPressed,
    required this.child,
    this.borderColor,
    this.foregroundColor,
    this.padding,
    this.borderRadius,
    this.expand = false,
  });

  final VoidCallback? onPressed;
  final Widget child;
  final Color? borderColor;
  final Color? foregroundColor;
  final EdgeInsetsGeometry? padding;
  final BorderRadiusGeometry? borderRadius;
  final bool expand;

  @override
  Widget build(BuildContext context) {
    final button = OutlinedButton(
      onPressed: onPressed,
      style: AppButtonStyles.outlined(
        context,
        borderColor: borderColor,
        foregroundColor: foregroundColor,
        padding: padding,
        borderRadius: borderRadius,
      ),
      child: child,
    );

    if (expand) {
      return SizedBox(width: double.infinity, child: button);
    }
    return button;
  }
}

// ============================================================================
// ASYNC BUTTONS - Pulsanti con gestione automatica dello stato di loading
// ============================================================================

/// Pulsante filled con gestione automatica del loading state.
/// Quando [onPressed] √® in esecuzione, mostra uno spinner e disabilita il pulsante.
class AppAsyncFilledButton extends StatefulWidget {
  const AppAsyncFilledButton({
    super.key,
    required this.onPressed,
    required this.child,
    this.backgroundColor,
    this.foregroundColor,
    this.padding,
    this.borderRadius,
    this.expand = false,
    this.isLoading = false,
    this.disabled = false,
    this.showSpinner = true,
  });

  /// Callback async che verr√† eseguito al tap.
  /// Il pulsante si disabilita automaticamente durante l'esecuzione.
  final Future<void> Function()? onPressed;
  final Widget child;
  final Color? backgroundColor;
  final Color? foregroundColor;
  final EdgeInsetsGeometry? padding;
  final BorderRadiusGeometry? borderRadius;
  final bool expand;

  /// Se true, forza lo stato di loading dall'esterno.
  final bool isLoading;

  /// Se true, disabilita il pulsante.
  final bool disabled;

  /// Se false, mantiene il contenuto anche durante il loading.
  final bool showSpinner;

  @override
  State<AppAsyncFilledButton> createState() => _AppAsyncFilledButtonState();
}

class _AppAsyncFilledButtonState extends State<AppAsyncFilledButton> {
  bool _isLoading = false;

  bool get _effectiveLoading => _isLoading || widget.isLoading;

  Future<void> _handlePress() async {
    if (_effectiveLoading || widget.disabled || widget.onPressed == null) {
      return;
    }

    setState(() => _isLoading = true);
    try {
      await widget.onPressed!();
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final isDisabled =
        _effectiveLoading || widget.disabled || widget.onPressed == null;

    return AppFilledButton(
      onPressed: isDisabled ? null : _handlePress,
      backgroundColor: widget.backgroundColor,
      foregroundColor: widget.foregroundColor,
      padding: widget.padding,
      borderRadius: widget.borderRadius,
      expand: widget.expand,
      child: _effectiveLoading && widget.showSpinner
          ? SizedBox(
              width: 20,
              height: 20,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                valueColor: AlwaysStoppedAnimation<Color>(
                  widget.foregroundColor ??
                      Theme.of(context).colorScheme.onPrimary,
                ),
              ),
            )
          : widget.child,
    );
  }
}

/// Pulsante danger con gestione automatica del loading state.
class AppAsyncDangerButton extends StatefulWidget {
  const AppAsyncDangerButton({
    super.key,
    required this.onPressed,
    required this.child,
    this.expand = false,
    this.padding,
    this.borderRadius,
    this.backgroundColor,
    this.isLoading = false,
    this.disabled = false,
    this.showSpinner = true,
  });

  final Future<void> Function()? onPressed;
  final Widget child;
  final bool expand;
  final EdgeInsetsGeometry? padding;
  final BorderRadiusGeometry? borderRadius;
  final Color? backgroundColor;
  final bool isLoading;
  final bool disabled;
  final bool showSpinner;

  @override
  State<AppAsyncDangerButton> createState() => _AppAsyncDangerButtonState();
}

class _AppAsyncDangerButtonState extends State<AppAsyncDangerButton> {
  bool _isLoading = false;

  bool get _effectiveLoading => _isLoading || widget.isLoading;

  Future<void> _handlePress() async {
    if (_effectiveLoading || widget.disabled || widget.onPressed == null) {
      return;
    }

    setState(() => _isLoading = true);
    try {
      await widget.onPressed!();
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final isDisabled =
        _effectiveLoading || widget.disabled || widget.onPressed == null;

    return AppFilledButton(
      onPressed: isDisabled ? null : _handlePress,
      expand: widget.expand,
      padding: widget.padding,
      borderRadius: widget.borderRadius,
      backgroundColor: widget.backgroundColor ?? colorScheme.error,
      foregroundColor: colorScheme.onError,
      child: _effectiveLoading && widget.showSpinner
          ? SizedBox(
              width: 20,
              height: 20,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                valueColor: AlwaysStoppedAnimation<Color>(colorScheme.onError),
              ),
            )
          : widget.child,
    );
  }
}

/// Pulsante outlined con gestione automatica del loading state.
class AppAsyncOutlinedButton extends StatefulWidget {
  const AppAsyncOutlinedButton({
    super.key,
    required this.onPressed,
    required this.child,
    this.borderColor,
    this.foregroundColor,
    this.padding,
    this.borderRadius,
    this.expand = false,
    this.isLoading = false,
    this.disabled = false,
    this.showSpinner = true,
  });

  final Future<void> Function()? onPressed;
  final Widget child;
  final Color? borderColor;
  final Color? foregroundColor;
  final EdgeInsetsGeometry? padding;
  final BorderRadiusGeometry? borderRadius;
  final bool expand;
  final bool isLoading;
  final bool disabled;
  final bool showSpinner;

  @override
  State<AppAsyncOutlinedButton> createState() => _AppAsyncOutlinedButtonState();
}

class _AppAsyncOutlinedButtonState extends State<AppAsyncOutlinedButton> {
  bool _isLoading = false;

  bool get _effectiveLoading => _isLoading || widget.isLoading;

  Future<void> _handlePress() async {
    if (_effectiveLoading || widget.disabled || widget.onPressed == null) {
      return;
    }

    setState(() => _isLoading = true);
    try {
      await widget.onPressed!();
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final isDisabled =
        _effectiveLoading || widget.disabled || widget.onPressed == null;
    final spinnerColor =
        widget.foregroundColor ?? widget.borderColor ?? colorScheme.primary;

    return AppOutlinedActionButton(
      onPressed: isDisabled ? null : _handlePress,
      borderColor: widget.borderColor,
      foregroundColor: widget.foregroundColor,
      padding: widget.padding,
      borderRadius: widget.borderRadius,
      expand: widget.expand,
      child: _effectiveLoading && widget.showSpinner
          ? SizedBox(
              width: 20,
              height: 20,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                valueColor: AlwaysStoppedAnimation<Color>(spinnerColor),
              ),
            )
          : widget.child,
    );
  }
}
--- FILE: lib/core/widgets/app_dialogs.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

/// App-level dialog scaffolds to ensure consistent layout across features.
class AppFormDialog extends StatelessWidget {
  const AppFormDialog({
    super.key,
    required this.title,
    required this.content,
    required this.actions,
    this.contentPadding = const EdgeInsets.only(top: 8),
  });

  final Widget title;
  final Widget content;
  final List<Widget> actions;
  final EdgeInsetsGeometry contentPadding;

  @override
  Widget build(BuildContext context) {
    final base = Theme.of(context);
    final dialogTheme = base.copyWith(
      splashColor: Colors.transparent,
      highlightColor: Colors.transparent,
      splashFactory: NoSplash.splashFactory,
      switchTheme: base.switchTheme.copyWith(
        overlayColor: MaterialStateProperty.all(Colors.transparent),
        thumbColor: MaterialStateProperty.resolveWith((states) {
          if (states.contains(MaterialState.selected)) {
            return base.colorScheme.primary;
          }
          return null;
        }),
        trackColor: MaterialStateProperty.resolveWith((states) {
          if (states.contains(MaterialState.selected)) {
            return base.colorScheme.primary.withOpacity(0.35);
          }
          return null;
        }),
      ),
      radioTheme: base.radioTheme.copyWith(
        overlayColor: MaterialStateProperty.all(Colors.transparent),
        fillColor: MaterialStateProperty.resolveWith((states) {
          if (states.contains(MaterialState.selected)) {
            return base.colorScheme.primary;
          }
          return null;
        }),
      ),
    );
    return Theme(
      data: dialogTheme,
      child: CallbackShortcuts(
        bindings: <ShortcutActivator, VoidCallback>{
          SingleActivator(LogicalKeyboardKey.escape): () =>
              Navigator.of(context, rootNavigator: true).pop(),
        },
        child: Focus(
          autofocus: true,
          child: Dialog(
            insetPadding: const EdgeInsets.symmetric(
              horizontal: 40,
              vertical: 24,
            ),
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 640),
              child: Padding(
                padding: const EdgeInsets.fromLTRB(24, 20, 24, 12),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    DefaultTextStyle(
                      style: dialogTheme.textTheme.titleLarge ??
                          base.textTheme.titleLarge ??
                          const TextStyle(fontSize: 18),
                      child: title,
                    ),
                    const SizedBox(height: 8),
                    Flexible(
                      fit: FlexFit.loose,
                      child: SingleChildScrollView(
                        padding: contentPadding,
                        child: content,
                      ),
                    ),
                    const SizedBox(height: 16),
                    OverflowBar(
                      alignment: MainAxisAlignment.end,
                      spacing: 8,
                      overflowSpacing: 4,
                      children: actions,
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

Future<void> showAppConfirmDialog(
  BuildContext context, {
  required Widget title,
  Widget? content,
  required String confirmLabel,
  required VoidCallback onConfirm,
  String? cancelLabel,
  bool danger = false,
}) async {
  final colorScheme = Theme.of(context).colorScheme;
  return showDialog(
    context: context,
    builder: (_) {
      final base = Theme.of(context);
      final dialogTheme = base.copyWith(
        splashColor: Colors.transparent,
        highlightColor: Colors.transparent,
        splashFactory: NoSplash.splashFactory,
        switchTheme: base.switchTheme.copyWith(
          overlayColor: MaterialStateProperty.all(Colors.transparent),
          thumbColor: MaterialStateProperty.resolveWith((states) {
            if (states.contains(MaterialState.selected)) {
              return base.colorScheme.primary;
            }
            return null;
          }),
          trackColor: MaterialStateProperty.resolveWith((states) {
            if (states.contains(MaterialState.selected)) {
              return base.colorScheme.primary.withOpacity(0.35);
            }
            return null;
          }),
        ),
        radioTheme: base.radioTheme.copyWith(
          overlayColor: MaterialStateProperty.all(Colors.transparent),
        ),
      );
      return Theme(
        data: dialogTheme,
        child: CallbackShortcuts(
          bindings: <ShortcutActivator, VoidCallback>{
            SingleActivator(LogicalKeyboardKey.escape): () =>
                Navigator.of(context, rootNavigator: true).pop(),
            SingleActivator(LogicalKeyboardKey.enter): () {
              onConfirm();
              Navigator.of(context, rootNavigator: true).pop();
            },
          },
          child: Focus(
            autofocus: true,
            child: AlertDialog(
              title: title,
              content: content,
              actions: [
                TextButton(
                  onPressed: () =>
                      Navigator.of(context, rootNavigator: true).pop(),
                  child: Text(cancelLabel ?? 'Annulla'),
                ),
                ElevatedButton(
                  onPressed: () {
                    onConfirm();
                    Navigator.of(context, rootNavigator: true).pop();
                  },
                  style: danger
                      ? ElevatedButton.styleFrom(
                          backgroundColor: colorScheme.error,
                        )
                      : null,
                  child: Text(confirmLabel),
                ),
              ],
            ),
          ),
        ),
      );
    },
  );
}

Future<void> showAppInfoDialog(
  BuildContext context, {
  required Widget title,
  Widget? content,
  String? closeLabel,
}) {
  return showDialog(
    context: context,
    builder: (_) {
      final base = Theme.of(context);
      final dialogTheme = base.copyWith(
        splashColor: Colors.transparent,
        highlightColor: Colors.transparent,
        splashFactory: NoSplash.splashFactory,
        switchTheme: base.switchTheme.copyWith(
          overlayColor: MaterialStateProperty.all(Colors.transparent),
          thumbColor: MaterialStateProperty.resolveWith((states) {
            if (states.contains(MaterialState.selected)) {
              return base.colorScheme.primary;
            }
            return null;
          }),
          trackColor: MaterialStateProperty.resolveWith((states) {
            if (states.contains(MaterialState.selected)) {
              return base.colorScheme.primary.withOpacity(0.35);
            }
            return null;
          }),
        ),
        radioTheme: base.radioTheme.copyWith(
          overlayColor: MaterialStateProperty.all(Colors.transparent),
        ),
      );
      return Theme(
        data: dialogTheme,
        child: CallbackShortcuts(
          bindings: <ShortcutActivator, VoidCallback>{
            SingleActivator(LogicalKeyboardKey.escape): () =>
                Navigator.of(context, rootNavigator: true).pop(),
            SingleActivator(LogicalKeyboardKey.enter): () =>
                Navigator.of(context, rootNavigator: true).pop(),
          },
          child: Focus(
            autofocus: true,
            child: AlertDialog(
              title: title,
              content: content,
              actions: [
                TextButton(
                  onPressed: () =>
                      Navigator.of(context, rootNavigator: true).pop(),
                  child: Text(closeLabel ?? 'Chiudi'),
                ),
              ],
            ),
          ),
        ),
      );
    },
  );
}

/// Mostra un dialog di conferma e ritorna true se confermato, false altrimenti.
/// Utile per operazioni che richiedono conferma esplicita prima di procedere.
Future<bool> showConfirmDialog(
  BuildContext context, {
  required Widget title,
  Widget? content,
  required String confirmLabel,
  String? cancelLabel,
  bool danger = false,
}) async {
  final colorScheme = Theme.of(context).colorScheme;
  final result = await showDialog<bool>(
    context: context,
    barrierDismissible: false,
    builder: (_) {
      final base = Theme.of(context);
      final dialogTheme = base.copyWith(
        splashColor: Colors.transparent,
        highlightColor: Colors.transparent,
        splashFactory: NoSplash.splashFactory,
      );
      return Theme(
        data: dialogTheme,
        child: CallbackShortcuts(
          bindings: <ShortcutActivator, VoidCallback>{
            SingleActivator(LogicalKeyboardKey.escape): () =>
                Navigator.of(context, rootNavigator: true).pop(false),
          },
          child: Focus(
            autofocus: true,
            child: AlertDialog(
              title: title,
              content: content,
              actions: [
                TextButton(
                  onPressed: () =>
                      Navigator.of(context, rootNavigator: true).pop(false),
                  child: Text(cancelLabel ?? 'Annulla'),
                ),
                ElevatedButton(
                  onPressed: () =>
                      Navigator.of(context, rootNavigator: true).pop(true),
                  style: danger
                      ? ElevatedButton.styleFrom(
                          backgroundColor: colorScheme.error,
                        )
                      : null,
                  child: Text(confirmLabel),
                ),
              ],
            ),
          ),
        ),
      );
    },
  );
  return result ?? false;
}

/// Wrapper per dialog che gestisce automaticamente la chiusura con ESC.
/// Wrappa qualsiasi widget dialog per aggiungere supporto ESC.
class DismissibleDialog extends StatelessWidget {
  const DismissibleDialog({super.key, required this.child});

  final Widget child;

  @override
  Widget build(BuildContext context) {
    return CallbackShortcuts(
      bindings: <ShortcutActivator, VoidCallback>{
        SingleActivator(LogicalKeyboardKey.escape): () =>
            Navigator.of(context, rootNavigator: true).pop(),
      },
      child: Focus(autofocus: true, child: child),
    );
  }
}
--- FILE: lib/core/widgets/layout_config_auto_listener.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// 1. Importa il nuovo provider globale
import '../../app/providers/form_factor_provider.dart';
import '../../features/agenda/providers/layout_config_provider.dart';

class LayoutConfigAutoListener extends ConsumerStatefulWidget {
  final Widget child;

  const LayoutConfigAutoListener({super.key, required this.child});

  @override
  ConsumerState<LayoutConfigAutoListener> createState() =>
      _LayoutConfigAutoListenerState();
}

class _LayoutConfigAutoListenerState
    extends ConsumerState<LayoutConfigAutoListener>
    with WidgetsBindingObserver {
  Size? _lastSize;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);

    // üîπ FIX SAFARI DESKTOP: attendi un frame + piccolo delay
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      await Future.delayed(const Duration(milliseconds: 150));
      _updateLayoutConfig();
    });
  }

  @override
  void didChangeMetrics() {
    super.didChangeMetrics();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final newSize = MediaQuery.of(context).size;
      if (_lastSize == null || newSize != _lastSize) {
        _lastSize = newSize;
        _updateLayoutConfig();
      }
    });
  }

  void _updateLayoutConfig() {
    final size = MediaQuery.of(context).size;
    final screenWidth = size.width;
    final screenHeight = size.height;

    // üß© FIX: evita aggiornamenti con MediaQuery ancora non pronta
    if (screenWidth < 100 || screenHeight < 100) {
      return;
    }

    // üîπ Aggiorna layout per l‚Äôagenda
    ref.read(layoutConfigProvider.notifier).updateFromContext(context);

    // üîπ Aggiorna form factor globale (usato dalla shell)
    ref.read(formFactorProvider.notifier).update(screenWidth);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return widget.child;
  }
}
--- FILE: lib/core/widgets/feedback_dialog.dart ---
import 'package:flutter/material.dart';

/// Dialog per mostrare messaggi di feedback all'utente (successo/errore).
/// Sostituisce le SnackBar per un'esperienza pi√π consistente.
class FeedbackDialog extends StatelessWidget {
  const FeedbackDialog({
    super.key,
    required this.title,
    required this.message,
    required this.isSuccess,
    this.actionLabel,
    this.onAction,
  });

  final String title;
  final String message;
  final bool isSuccess;
  final String? actionLabel;
  final VoidCallback? onAction;

  /// Mostra un dialog di successo
  static Future<void> showSuccess(
    BuildContext context, {
    required String title,
    required String message,
    String? actionLabel,
    VoidCallback? onAction,
  }) {
    return showDialog(
      context: context,
      builder: (ctx) => FeedbackDialog(
        title: title,
        message: message,
        isSuccess: true,
        actionLabel: actionLabel,
        onAction: onAction,
      ),
    );
  }

  /// Mostra un dialog di errore
  static Future<void> showError(
    BuildContext context, {
    required String title,
    required String message,
    String? actionLabel,
    VoidCallback? onAction,
  }) {
    return showDialog(
      context: context,
      builder: (ctx) => FeedbackDialog(
        title: title,
        message: message,
        isSuccess: false,
        actionLabel: actionLabel,
        onAction: onAction,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final color = isSuccess
        ? theme.colorScheme.primary
        : theme.colorScheme.error;

    return AlertDialog(
      icon: Icon(
        isSuccess ? Icons.check_circle : Icons.error,
        color: color,
        size: 48,
      ),
      title: Text(title, textAlign: TextAlign.center),
      content: Text(message, textAlign: TextAlign.center),
      actionsAlignment: MainAxisAlignment.center,
      actions: [
        if (actionLabel != null && onAction != null)
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              onAction!();
            },
            child: Text(actionLabel!),
          ),
        FilledButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('OK'),
        ),
      ],
    );
  }
}
--- FILE: lib/core/widgets/adaptive_dropdown.dart ---
import 'dart:math' as math;

import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/core/widgets/app_bottom_sheet.dart';
import 'package:agenda_backend/core/widgets/desktop_popup_container.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'app_dividers.dart';

/// A dropdown item with a value and display widget.
class AdaptiveDropdownItem<T> {
  const AdaptiveDropdownItem({
    required this.value,
    required this.child,
    this.enabled = true,
  });

  final T value;
  final Widget child;
  final bool enabled;
}

/// Alignment for the desktop popup relative to the trigger.
enum AdaptiveDropdownAlignment { left, right }

/// Vertical position for the popup relative to the trigger.
enum AdaptiveDropdownVerticalPosition { below, above }

/// Adaptive dropdown that shows:
/// - A modal bottom sheet on mobile/tablet
/// - An anchored popup on desktop
class AdaptiveDropdown<T> extends ConsumerStatefulWidget {
  const AdaptiveDropdown({
    super.key,
    required this.items,
    required this.onSelected,
    required this.child,
    this.selectedValue,
    this.alignment = AdaptiveDropdownAlignment.left,
    this.verticalPosition = AdaptiveDropdownVerticalPosition.below,
    this.modalTitle,
    this.popupWidth,
    this.popupMaxHeight = 300,
    this.popupBorderRadius = 12.0,
    this.onOpened,
    this.onClosed,
    this.useRootNavigator = true,
    this.forcePopup = false,
    this.hideTriggerWhenOpen = false,
  });

  /// The list of items to display in the dropdown.
  final List<AdaptiveDropdownItem<T>> items;

  /// Called when an item is selected.
  final ValueChanged<T> onSelected;

  /// The trigger widget (typically a button or styled container).
  final Widget child;

  /// The currently selected value (for highlighting in the list).
  final T? selectedValue;

  /// Alignment of the popup on desktop (left or right).
  final AdaptiveDropdownAlignment alignment;

  /// Vertical position of the popup (above or below the trigger).
  final AdaptiveDropdownVerticalPosition verticalPosition;

  /// Optional title for the modal sheet on mobile/tablet.
  final String? modalTitle;

  /// Width of the popup on desktop. If null, matches the trigger width.
  final double? popupWidth;

  /// Maximum height of the popup on desktop.
  final double popupMaxHeight;

  /// Border radius of the popup on desktop.
  final double popupBorderRadius;

  /// Called when the dropdown is opened.
  final VoidCallback? onOpened;

  /// Called when the dropdown is closed.
  final VoidCallback? onClosed;

  /// Whether to push the mobile bottom sheet on the root navigator.
  final bool useRootNavigator;

  /// If true, always show popup instead of bottom sheet on mobile/tablet.
  final bool forcePopup;

  /// If true, hides the trigger widget when the popup is open.
  final bool hideTriggerWhenOpen;

  @override
  ConsumerState<AdaptiveDropdown<T>> createState() =>
      _AdaptiveDropdownState<T>();
}

class _AdaptiveDropdownState<T> extends ConsumerState<AdaptiveDropdown<T>> {
  final LayerLink _layerLink = LayerLink();
  OverlayEntry? _overlayEntry;
  bool _isOpen = false;

  @override
  void dispose() {
    _removeOverlay();
    super.dispose();
  }

  void _removeOverlay() {
    _overlayEntry?.remove();
    _overlayEntry = null;
    if (_isOpen) {
      _isOpen = false;
      widget.onClosed?.call();
      if (widget.hideTriggerWhenOpen) {
        setState(() {});
      }
    }
  }

  void _handleTap() {
    final formFactor = ref.read(formFactorProvider);

    if (widget.forcePopup || formFactor == AppFormFactor.desktop) {
      _showDesktopPopup();
    } else {
      _showMobileSheet();
    }
  }

  Future<void> _showMobileSheet() async {
    widget.onOpened?.call();
    _isOpen = true;

    final result = await AppBottomSheet.show<T>(
      context: context,
      heightFactor: null,
      builder: (ctx) => _MobileSheetContent<T>(
        items: widget.items,
        selectedValue: widget.selectedValue,
        title: widget.modalTitle,
        onSelected: (value) {
          Navigator.of(ctx).pop(value);
        },
      ),
      useRootNavigator: widget.useRootNavigator,
      padding: EdgeInsets.zero,
    );

    _isOpen = false;
    widget.onClosed?.call();

    if (result != null) {
      widget.onSelected(result);
    }
  }

  void _showDesktopPopup() {
    if (_overlayEntry != null) {
      _removeOverlay();
      return;
    }

    widget.onOpened?.call();
    _isOpen = true;
    if (widget.hideTriggerWhenOpen) {
      setState(() {});
    }

    final renderBox = context.findRenderObject() as RenderBox;
    final triggerSize = renderBox.size;

    _overlayEntry = OverlayEntry(
      builder: (overlayContext) => DesktopPopupContainer(
        link: _layerLink,
        triggerWidth: triggerSize.width,
        triggerHeight: triggerSize.height,
        popupWidth: widget.popupWidth,
        maxHeight: widget.popupMaxHeight,
        borderRadius: widget.popupBorderRadius,
        alignment: widget.alignment == AdaptiveDropdownAlignment.right
            ? PopupAlignment.right
            : PopupAlignment.left,
        verticalPosition:
            widget.verticalPosition == AdaptiveDropdownVerticalPosition.above
            ? PopupVerticalPosition.above
            : PopupVerticalPosition.below,
        onDismiss: _removeOverlay,
        child: _DesktopDropdownContent<T>(
          items: widget.items,
          selectedValue: widget.selectedValue,
          title: widget.modalTitle,
          onSelected: (value) {
            _removeOverlay();
            widget.onSelected(value);
          },
        ),
      ),
    );

    Overlay.of(context).insert(_overlayEntry!);
  }

  @override
  Widget build(BuildContext context) {
    return CompositedTransformTarget(
      link: _layerLink,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: _handleTap,
        child: Visibility(
          visible: !(widget.hideTriggerWhenOpen && _isOpen),
          maintainSize: true,
          maintainAnimation: true,
          maintainState: true,
          child: widget.child,
        ),
      ),
    );
  }
}

/// Mobile/tablet modal sheet content.
class _MobileSheetContent<T> extends StatelessWidget {
  const _MobileSheetContent({
    required this.items,
    required this.onSelected,
    this.selectedValue,
    this.title,
  });

  final List<AdaptiveDropdownItem<T>> items;
  final ValueChanged<T> onSelected;
  final T? selectedValue;
  final String? title;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        if (title != null) ...[
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 16, 16, 12),
            child: Text(
              title!,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          const AppDivider(),
        ],
        ...items.map((item) {
          final isSelected = item.value == selectedValue;
          return InkWell(
            onTap: item.enabled ? () => onSelected(item.value) : null,
            splashColor: Colors.transparent,
            highlightColor: Colors.transparent,
            child: Container(
              padding: const EdgeInsets.symmetric(vertical: 14, horizontal: 16),
              color: isSelected
                  ? colorScheme.primary.withOpacity(0.08)
                  : Colors.transparent,
              child: Row(
                children: [
                  Expanded(
                    child: DefaultTextStyle.merge(
                      style: TextStyle(
                        color: item.enabled
                            ? colorScheme.onSurface
                            : colorScheme.onSurface.withOpacity(0.38),
                        fontWeight: isSelected
                            ? FontWeight.w600
                            : FontWeight.normal,
                      ),
                      child: item.child,
                    ),
                  ),
                  if (isSelected)
                    Icon(Icons.check, size: 20, color: colorScheme.primary),
                ],
              ),
            ),
          );
        }),
        // Safe area padding for bottom with minimum inset
        SizedBox(
          height: math.max(MediaQuery.of(context).viewPadding.bottom, 15),
        ),
      ],
    );
  }
}

/// Content for the desktop dropdown popup.
class _DesktopDropdownContent<T> extends StatelessWidget {
  const _DesktopDropdownContent({
    required this.items,
    required this.onSelected,
    this.selectedValue,
    this.title,
    this.borderRadius = 12.0,
  });

  final List<AdaptiveDropdownItem<T>> items;
  final T? selectedValue;
  final String? title;
  final ValueChanged<T> onSelected;
  final double borderRadius;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        if (title != null) ...[
          Padding(
            padding: const EdgeInsets.fromLTRB(12, 10, 12, 6),
            child: Text(
              title!,
              style: theme.textTheme.labelMedium?.copyWith(
                color: colorScheme.onSurfaceVariant,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          const AppDivider(),
        ],
        Flexible(
          child: SingleChildScrollView(
            padding: EdgeInsets.only(top: title == null ? 4 : 0),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                for (int i = 0; i < items.length; i++)
                  _DesktopPopupItem<T>(
                    item: items[i],
                    isSelected: items[i].value == selectedValue,
                    isLast: i == items.length - 1,
                    borderRadius: borderRadius,
                    onTap: () => onSelected(items[i].value),
                  ),
              ],
            ),
          ),
        ),
      ],
    );
  }
}

/// Individual item in the desktop popup.
class _DesktopPopupItem<T> extends StatefulWidget {
  const _DesktopPopupItem({
    required this.item,
    required this.isSelected,
    required this.onTap,
    this.isLast = false,
    this.borderRadius = 12.0,
  });

  final AdaptiveDropdownItem<T> item;
  final bool isSelected;
  final VoidCallback onTap;
  final bool isLast;
  final double borderRadius;

  @override
  State<_DesktopPopupItem<T>> createState() => _DesktopPopupItemState<T>();
}

class _DesktopPopupItemState<T> extends State<_DesktopPopupItem<T>> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    final backgroundColor = widget.isSelected
        ? colorScheme.primary.withOpacity(0.08)
        : _isHovered
        ? colorScheme.primary.withOpacity(0.04)
        : Colors.transparent;

    final borderRadius = widget.isLast
        ? BorderRadius.only(
            bottomLeft: Radius.circular(widget.borderRadius),
            bottomRight: Radius.circular(widget.borderRadius),
          )
        : BorderRadius.zero;

    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      cursor: widget.item.enabled
          ? SystemMouseCursors.click
          : SystemMouseCursors.basic,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: widget.item.enabled ? widget.onTap : null,
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 100),
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
          decoration: BoxDecoration(
            color: backgroundColor,
            borderRadius: borderRadius,
          ),
          child: Row(
            children: [
              Expanded(
                child: DefaultTextStyle.merge(
                  style: TextStyle(
                    color: widget.item.enabled
                        ? colorScheme.onSurface
                        : colorScheme.onSurface.withOpacity(0.38),
                    fontWeight: widget.isSelected
                        ? FontWeight.w600
                        : FontWeight.normal,
                  ),
                  child: widget.item.child,
                ),
              ),
              if (widget.isSelected)
                Icon(Icons.check, size: 18, color: colorScheme.primary),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/core/widgets/app_switch.dart ---
import 'package:flutter/material.dart';

class AppSwitch extends StatelessWidget {
  const AppSwitch({super.key, required this.value, this.onChanged});

  final bool value;
  final ValueChanged<bool>? onChanged;

  @override
  Widget build(BuildContext context) {
    return Switch.adaptive(
      value: value,
      onChanged: onChanged,
      activeColor: Theme.of(context).colorScheme.primary,
    );
  }
}
--- FILE: lib/core/widgets/local_loading_overlay.dart ---
import 'package:flutter/material.dart';

class LocalLoadingOverlay extends StatelessWidget {
  const LocalLoadingOverlay({
    super.key,
    required this.isLoading,
    required this.child,
    this.barrierColor,
  });

  final bool isLoading;
  final Widget child;
  final Color? barrierColor;

  @override
  Widget build(BuildContext context) {
    if (!isLoading) return child;

    return Stack(
      children: [
        child,
        Positioned.fill(
          child: AbsorbPointer(
            child: Container(
              color: barrierColor ?? const Color(0x33000000),
              child: const Center(child: CircularProgressIndicator()),
            ),
          ),
        ),
      ],
    );
  }
}
--- FILE: lib/core/widgets/session_expired_listener.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../app/router_provider.dart';
import '../../features/auth/providers/auth_provider.dart';
import '../network/network_providers.dart';

/// Widget che ascolta il provider sessionExpiredProvider e
/// esegue logout automatico quando la sessione scade.
class SessionExpiredListener extends ConsumerWidget {
  const SessionExpiredListener({super.key, required this.child});

  final Widget child;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    ref.listen<int>(sessionExpiredProvider, (previous, next) {
      if (previous != null && next > previous) {
        _handleSessionExpired(context, ref);
      }
    });

    return child;
  }

  void _handleSessionExpired(BuildContext context, WidgetRef ref) {
    // Esegui logout silenzioso (senza chiamata API, sessione gi√† scaduta)
    ref.read(authProvider.notifier).logout(silent: true);

    // Redirect diretto al login senza dialog
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(routerProvider).go('/login');
    });
  }
}
--- FILE: lib/core/widgets/labeled_form_field.dart ---
import 'package:flutter/material.dart';

/// Widget che mostra una label sopra un campo form.
/// Usato per uniformare il layout dei form in tutta l'app.
class LabeledFormField extends StatelessWidget {
  const LabeledFormField({
    super.key,
    required this.label,
    required this.child,
    this.labelSpacing = 6.0,
  });

  /// Label del campo.
  final String label;

  /// Widget figlio (es. TextFormField, DropdownButtonFormField, ecc.).
  final Widget child;

  /// Spacing tra label e campo. Default 6.0.
  final double labelSpacing;

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(label, style: const TextStyle(fontWeight: FontWeight.w600)),
        SizedBox(height: labelSpacing),
        child,
      ],
    );
  }
}
--- FILE: lib/core/widgets/desktop_popup_container.dart ---
import 'package:flutter/material.dart';

/// Alignment for the desktop popup relative to the trigger.
enum PopupAlignment { left, right }

/// Vertical position for the popup relative to the trigger.
enum PopupVerticalPosition { below, above }

/// A reusable container for desktop anchored popups with consistent styling.
/// Provides: dismiss layer, animation, border, positioning.
class DesktopPopupContainer extends StatefulWidget {
  const DesktopPopupContainer({
    super.key,
    required this.link,
    required this.triggerWidth,
    required this.triggerHeight,
    required this.onDismiss,
    required this.child,
    this.popupWidth,
    this.maxHeight = 300,
    this.borderRadius = 12.0,
    this.alignment = PopupAlignment.left,
    this.verticalPosition = PopupVerticalPosition.below,
  });

  /// The layer link to anchor the popup to the trigger.
  final LayerLink link;

  /// The width of the trigger widget.
  final double triggerWidth;

  /// The height of the trigger widget.
  final double triggerHeight;

  /// Called when the popup should be dismissed.
  final VoidCallback onDismiss;

  /// The content of the popup.
  final Widget child;

  /// Width of the popup. If null, matches the trigger width.
  final double? popupWidth;

  /// Maximum height of the popup.
  final double maxHeight;

  /// Border radius of the popup.
  final double borderRadius;

  /// Alignment of the popup relative to the trigger.
  final PopupAlignment alignment;

  /// Vertical position of the popup (above or below the trigger).
  final PopupVerticalPosition verticalPosition;

  @override
  State<DesktopPopupContainer> createState() => _DesktopPopupContainerState();
}

class _DesktopPopupContainerState extends State<DesktopPopupContainer>
    with SingleTickerProviderStateMixin {
  late final AnimationController _animationController;
  late final Animation<double> _fadeAnimation;
  late final Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 150),
      vsync: this,
    );
    _fadeAnimation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeOut,
    );
    _scaleAnimation = Tween<double>(begin: 0.95, end: 1.0).animate(
      CurvedAnimation(parent: _animationController, curve: Curves.easeOut),
    );
    _animationController.forward();
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final effectiveWidth = widget.popupWidth ?? widget.triggerWidth;
    final isAbove = widget.verticalPosition == PopupVerticalPosition.above;

    // Horizontal offset based on alignment
    final horizontalOffset = widget.alignment == PopupAlignment.right
        ? widget.triggerWidth - effectiveWidth
        : 0.0;

    // Vertical offset and anchors based on position
    final Alignment targetAnchor;
    final Alignment followerAnchor;
    final EdgeInsets padding;

    if (isAbove) {
      // Popup appears above the trigger, growing downward
      targetAnchor = Alignment.topLeft;
      followerAnchor = Alignment.topLeft;
      padding = const EdgeInsets.only(bottom: 4);
    } else {
      targetAnchor = Alignment.bottomLeft;
      followerAnchor = Alignment.topLeft;
      padding = const EdgeInsets.only(top: 4);
    }

    final offset = Offset(horizontalOffset, 0);

    // Scale alignment for animation
    final scaleAlignment = isAbove
        ? (widget.alignment == PopupAlignment.right
              ? Alignment.bottomRight
              : Alignment.bottomLeft)
        : (widget.alignment == PopupAlignment.right
              ? Alignment.topRight
              : Alignment.topLeft);

    return Stack(
      children: [
        // Dismiss layer
        Positioned.fill(
          child: GestureDetector(
            behavior: HitTestBehavior.translucent,
            onTap: widget.onDismiss,
            child: const ColoredBox(color: Colors.transparent),
          ),
        ),
        // Popup
        CompositedTransformFollower(
          link: widget.link,
          showWhenUnlinked: false,
          offset: offset,
          targetAnchor: targetAnchor,
          followerAnchor: followerAnchor,
          child: FadeTransition(
            opacity: _fadeAnimation,
            child: ScaleTransition(
              scale: _scaleAnimation,
              alignment: scaleAlignment,
              child: Padding(
                padding: padding,
                child: Material(
                  elevation: 8,
                  color: colorScheme.surface,
                  borderRadius: BorderRadius.circular(widget.borderRadius),
                  clipBehavior: Clip.antiAlias,
                  child: Container(
                    width: effectiveWidth,
                    constraints: BoxConstraints(maxHeight: widget.maxHeight),
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(widget.borderRadius),
                      border: Border.all(color: Colors.grey.withOpacity(0.35)),
                    ),
                    child: widget.child,
                  ),
                ),
              ),
            ),
          ),
        ),
      ],
    );
  }
}
--- FILE: lib/core/widgets/phone_input_field.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../l10n/l10_extension.dart';
/// Lista dei prefissi telefonici pi√π comuni
const kPhonePrefixes = <PhonePrefix>[
  PhonePrefix('+39', 'IT', 'üáÆüáπ'),
  PhonePrefix('+1', 'US', 'üá∫üá∏'),
  PhonePrefix('+44', 'GB', 'üá¨üáß'),
  PhonePrefix('+49', 'DE', 'üá©üá™'),
  PhonePrefix('+33', 'FR', 'üá´üá∑'),
  PhonePrefix('+34', 'ES', 'üá™üá∏'),
  PhonePrefix('+41', 'CH', 'üá®üá≠'),
  PhonePrefix('+43', 'AT', 'üá¶üáπ'),
  PhonePrefix('+31', 'NL', 'üá≥üá±'),
  PhonePrefix('+32', 'BE', 'üáßüá™'),
  PhonePrefix('+351', 'PT', 'üáµüáπ'),
  PhonePrefix('+48', 'PL', 'üáµüá±'),
  PhonePrefix('+420', 'CZ', 'üá®üáø'),
  PhonePrefix('+385', 'HR', 'üá≠üá∑'),
  PhonePrefix('+386', 'SI', 'üá∏üáÆ'),
  PhonePrefix('+40', 'RO', 'üá∑üá¥'),
  PhonePrefix('+30', 'GR', 'üá¨üá∑'),
  PhonePrefix('+7', 'RU', 'üá∑üá∫'),
  PhonePrefix('+86', 'CN', 'üá®üá≥'),
  PhonePrefix('+81', 'JP', 'üáØüáµ'),
  PhonePrefix('+82', 'KR', 'üá∞üá∑'),
  PhonePrefix('+91', 'IN', 'üáÆüá≥'),
  PhonePrefix('+61', 'AU', 'üá¶üá∫'),
  PhonePrefix('+55', 'BR', 'üáßüá∑'),
  PhonePrefix('+52', 'MX', 'üá≤üáΩ'),
  PhonePrefix('+54', 'AR', 'üá¶üá∑'),
];

/// Modello per un prefisso telefonico
class PhonePrefix {
  final String code;
  final String countryCode;
  final String flag;

  const PhonePrefix(this.code, this.countryCode, this.flag);

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PhonePrefix &&
          runtimeType == other.runtimeType &&
          code == other.code;

  @override
  int get hashCode => code.hashCode;
}

/// Estrae prefisso e numero da un telefono completo
/// Ritorna (prefix, number)
(String prefix, String number) parsePhoneWithPrefix(
  String? phone, {
  String defaultPrefix = '+39',
}) {
  if (phone == null || phone.isEmpty) {
    return (defaultPrefix, '');
  }

  final cleaned = phone.replaceAll(RegExp(r'\s+'), '');

  // Cerca un prefisso conosciuto
  for (final p in kPhonePrefixes) {
    if (cleaned.startsWith(p.code)) {
      return (p.code, cleaned.substring(p.code.length));
    }
  }

  // Prova a estrarre un prefisso generico +XX o +XXX
  if (cleaned.startsWith('+')) {
    final match = RegExp(r'^\+\d{1,3}').firstMatch(cleaned);
    if (match != null) {
      return (match.group(0)!, cleaned.substring(match.end));
    }
  }

  // Nessun prefisso trovato, usa il default
  return (defaultPrefix, phone);
}

/// Combina prefisso e numero in un formato standard
String formatPhoneWithPrefix(String prefix, String number) {
  final cleanNumber = number.replaceAll(RegExp(r'\s+'), '');
  if (cleanNumber.isEmpty) return '';
  return '$prefix $cleanNumber';
}

/// Widget per input telefono con prefisso selezionabile
class PhoneInputField extends StatefulWidget {
  const PhoneInputField({
    super.key,
    this.labelText,
    required this.defaultPrefix,
    this.initialPhone,
    this.onChanged,
    this.validator,
    this.textInputAction = TextInputAction.next,
    this.isDense = false,
    this.useOutlineBorder = false,
  });

  /// Label opzionale. Se null, il campo non mostra label interna.
  final String? labelText;
  final String defaultPrefix;
  final String? initialPhone;
  final ValueChanged<String>? onChanged;
  final FormFieldValidator<String>? validator;
  final TextInputAction textInputAction;

  /// Se true, usa InputDecoration.isDense = true.
  final bool isDense;

  /// Se true, usa OutlineInputBorder invece del default UnderlineInputBorder.
  final bool useOutlineBorder;

  @override
  State<PhoneInputField> createState() => PhoneInputFieldState();
}

class PhoneInputFieldState extends State<PhoneInputField> {
  late String _selectedPrefix;
  late final TextEditingController _controller;

  @override
  void initState() {
    super.initState();
    final (prefix, number) = parsePhoneWithPrefix(
      widget.initialPhone,
      defaultPrefix: widget.defaultPrefix,
    );
    _selectedPrefix = prefix;
    _controller = TextEditingController(text: _formatNumber(number));
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  /// Ritorna il numero di telefono completo (prefisso + numero)
  String get fullPhone {
    final number = _controller.text.replaceAll(RegExp(r'\s+'), '');
    if (number.isEmpty) return '';
    return '$_selectedPrefix $number';
  }

  /// Ritorna solo il numero senza prefisso
  String get numberOnly => _controller.text.replaceAll(RegExp(r'\s+'), '');

  /// Ritorna il prefisso selezionato
  String get prefix => _selectedPrefix;

  String _formatNumber(String number) {
    final digits = number.replaceAll(RegExp(r'\s+'), '');
    if (digits.isEmpty) return '';

    final buffer = StringBuffer();
    for (var i = 0; i < digits.length; i++) {
      if (i == 3 || i == 6) {
        buffer.write(' ');
      }
      buffer.write(digits[i]);
    }
    return buffer.toString();
  }

  void _notifyChange() {
    widget.onChanged?.call(fullPhone);
  }

  @override
  Widget build(BuildContext context) {
    return TextFormField(
      controller: _controller,
      decoration: InputDecoration(
        labelText: widget.labelText,
        isDense: widget.isDense,
        border: widget.useOutlineBorder ? const OutlineInputBorder() : null,
        prefixIcon: _PrefixDropdown(
          selectedPrefix: _selectedPrefix,
          onChanged: (newPrefix) {
            setState(() => _selectedPrefix = newPrefix);
            _notifyChange();
          },
        ),
      ),
      keyboardType: TextInputType.phone,
      textInputAction: widget.textInputAction,
      inputFormatters: [
        FilteringTextInputFormatter.allow(RegExp(r'[0-9\s]')),
        _PhoneNumberFormatter(),
      ],
      onChanged: (_) => _notifyChange(),
      validator:
          widget.validator ??
          (v) {
            final t = v?.trim().replaceAll(RegExp(r'\s+'), '') ?? '';
            if (t.isEmpty) return null; // optional
            if (!RegExp(r'^\d{6,15}$').hasMatch(t)) {
              return context.l10n.validationInvalidPhone;
            }
            return null;
          },
    );
  }
}

/// Dropdown per selezionare il prefisso
class _PrefixDropdown extends StatelessWidget {
  const _PrefixDropdown({
    required this.selectedPrefix,
    required this.onChanged,
  });

  final String selectedPrefix;
  final ValueChanged<String> onChanged;

  @override
  Widget build(BuildContext context) {
    // Trova il prefisso corrente nella lista, altrimenti usa il primo
    final currentPrefix = kPhonePrefixes.firstWhere(
      (p) => p.code == selectedPrefix,
      orElse: () => kPhonePrefixes.first,
    );

    return Padding(
      padding: const EdgeInsets.only(left: 12),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: currentPrefix.code,
          isDense: true,
          items: kPhonePrefixes.map((p) {
            return DropdownMenuItem<String>(
              value: p.code,
              child: Text(
                '${p.flag} ${p.code}',
                style: const TextStyle(fontSize: 14),
              ),
            );
          }).toList(),
          onChanged: (value) {
            if (value != null) {
              onChanged(value);
            }
          },
          selectedItemBuilder: (context) {
            return kPhonePrefixes.map((p) {
              return Center(
                child: Text(
                  '${p.flag} ${p.code}',
                  style: const TextStyle(fontSize: 14),
                ),
              );
            }).toList();
          },
        ),
      ),
    );
  }
}

/// Formatta il numero di telefono aggiungendo spazi per leggibilit√†
class _PhoneNumberFormatter extends TextInputFormatter {
  @override
  TextEditingValue formatEditUpdate(
    TextEditingValue oldValue,
    TextEditingValue newValue,
  ) {
    final digitsOnly = newValue.text.replaceAll(RegExp(r'\s+'), '');

    if (digitsOnly.isEmpty) {
      return newValue.copyWith(text: '');
    }

    final buffer = StringBuffer();
    for (var i = 0; i < digitsOnly.length; i++) {
      if (i == 3 || i == 6) {
        buffer.write(' ');
      }
      buffer.write(digitsOnly[i]);
    }

    final formatted = buffer.toString();

    return TextEditingValue(
      text: formatted,
      selection: TextSelection.collapsed(offset: formatted.length),
    );
  }
}
--- FILE: lib/core/widgets/global_loading_overlay.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../app/providers/global_loading_provider.dart';

class GlobalLoadingOverlay extends ConsumerWidget {
  const GlobalLoadingOverlay({
    super.key,
    required this.child,
  });

  final Widget child;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final isLoading = ref.watch(globalLoadingProvider) > 0;

    return Stack(
      children: [
        child,
        if (isLoading)
          Positioned.fill(
            child: AbsorbPointer(
              child: Container(
                color: const Color(0x33000000),
                child: const Center(child: CircularProgressIndicator()),
              ),
            ),
          ),
      ],
    );
  }
}
--- FILE: lib/core/widgets/app_dividers.dart ---
import 'package:flutter/material.dart';

/// Divider standard per bottom sheet (stile coerente con creazione appuntamento).
class AppDivider extends StatelessWidget {
  const AppDivider({super.key});

  @override
  Widget build(BuildContext context) {
    return const Divider(height: 1, thickness: 0.5, color: Color(0x1F000000));
  }
}
--- FILE: lib/core/widgets/reorder_toggle_panel.dart ---
import 'package:flutter/material.dart';

/// Container che dispone una serie di widget con spacing orizzontale e wrap
/// automatico per evitare overflow su schermi stretti.
class ReorderTogglePanel extends StatelessWidget {
  final bool isWide;
  final List<Widget> children;

  const ReorderTogglePanel({
    super.key,
    required this.isWide,
    required this.children,
  });

  @override
  Widget build(BuildContext context) {
    return Wrap(spacing: 8, runSpacing: 8, children: children);
  }
}
--- FILE: lib/core/validation/staff_planning_validator.dart ---
import '../models/staff_planning.dart';

/// Risultato della validazione di uno StaffPlanning.
class StaffPlanningValidationResult {
  final bool isValid;
  final List<String> errors;
  final List<String> warnings;

  const StaffPlanningValidationResult({
    required this.isValid,
    this.errors = const [],
    this.warnings = const [],
  });

  factory StaffPlanningValidationResult.valid({
    List<String> warnings = const [],
  }) => StaffPlanningValidationResult(isValid: true, warnings: warnings);

  factory StaffPlanningValidationResult.invalid(
    List<String> errors, {
    List<String> warnings = const [],
  }) => StaffPlanningValidationResult(
    isValid: false,
    errors: errors,
    warnings: warnings,
  );
}

/// Validatore per StaffPlanning.
///
/// Implementa le regole definite in docs/STAFF_PLANNING_MODEL.md:
/// - Obbligatori: valid_from, type, template A (e B se biweekly)
/// - valid_to ‚â• valid_from quando presente
/// - Non sovrapposizione intervalli per stesso staff
/// - Template coerenti con type
class StaffPlanningValidator {
  /// Valida un planning per creazione.
  ///
  /// [planning] il nuovo planning da validare.
  /// [existingPlannings] non usato - l'API fa auto-split.
  StaffPlanningValidationResult validateForCreate(
    StaffPlanning planning,
    // ignore: avoid_unused_constructor_parameters
    List<StaffPlanning> existingPlannings,
  ) {
    final errors = <String>[];
    final warnings = <String>[];

    // 1. Validazioni base
    _validateBasicRules(planning, errors, warnings);

    if (errors.isNotEmpty) {
      return StaffPlanningValidationResult.invalid(errors, warnings: warnings);
    }

    // 2. Validazioni template
    _validateTemplates(planning, errors);

    // 3. Non validare overlap lato client: l'API fa auto-split automatico

    return errors.isEmpty
        ? StaffPlanningValidationResult.valid(warnings: warnings)
        : StaffPlanningValidationResult.invalid(errors, warnings: warnings);
  }

  /// Valida un planning per aggiornamento.
  ///
  /// [planning] il planning modificato.
  /// [existingPlannings] non usato - l'API fa auto-split.
  /// [originalPlanning] il planning originale prima delle modifiche.
  StaffPlanningValidationResult validateForUpdate(
    StaffPlanning planning,
    // ignore: avoid_unused_constructor_parameters
    List<StaffPlanning> existingPlannings,
    StaffPlanning originalPlanning,
  ) {
    final errors = <String>[];
    final warnings = <String>[];

    // 1. Validazioni base
    _validateBasicRules(planning, errors, warnings);

    if (errors.isNotEmpty) {
      return StaffPlanningValidationResult.invalid(errors, warnings: warnings);
    }

    // 2. Validazioni template
    _validateTemplates(planning, errors);

    // 3. Non validare overlap lato client: l'API fa auto-split automatico

    // 4. Warning per cambio type senza adeguare template
    if (originalPlanning.type != planning.type) {
      if (planning.type == StaffPlanningType.biweekly &&
          planning.templateB == null) {
        errors.add('Cambio a biweekly richiede template B');
      }
    }

    // 5. Warning per shift validFrom in biweekly (altera parit√† A/B)
    if (planning.type == StaffPlanningType.biweekly &&
        originalPlanning.validFrom != planning.validFrom) {
      warnings.add(
        'Spostare valid_from in un planning biweekly altera la parit√† del ciclo A/B '
        'per tutto l\'intervallo',
      );
    }

    return errors.isEmpty
        ? StaffPlanningValidationResult.valid(warnings: warnings)
        : StaffPlanningValidationResult.invalid(errors, warnings: warnings);
  }

  /// Validazioni base comuni.
  void _validateBasicRules(
    StaffPlanning planning,
    List<String> errors,
    List<String> warnings,
  ) {
    // valid_to ‚â• valid_from quando presente
    if (planning.validTo != null) {
      final from = DateUtils.dateOnly(planning.validFrom);
      final to = DateUtils.dateOnly(planning.validTo!);
      if (to.isBefore(from)) {
        errors.add('valid_to non pu√≤ essere precedente a valid_from');
      }
    }
  }

  /// Validazioni sui template.
  void _validateTemplates(StaffPlanning planning, List<String> errors) {
    // Template A obbligatorio
    if (planning.templateA == null) {
      errors.add('Template A √® obbligatorio');
      return;
    }

    // Per biweekly, template B obbligatorio
    if (planning.type == StaffPlanningType.biweekly &&
        planning.templateB == null) {
      errors.add('Template B √® obbligatorio per pianificazione biweekly');
    }

    // Validazione formato slot in ogni template
    for (final template in planning.templates) {
      _validateTemplateSlots(template, errors);
    }
  }

  /// Validazione slot di un template.
  void _validateTemplateSlots(StaffPlanningWeekTemplate template, List<String> errors) {
    final maxSlotIndex = ((24 * 60) ~/ StaffPlanning.planningStepMinutes) - 1;

    for (final entry in template.daySlots.entries) {
      final day = entry.key;
      final slots = entry.value;

      // day_of_week deve essere 1-7
      if (day < 1 || day > 7) {
        errors.add('day_of_week invalido: $day (deve essere 1-7)');
      }

      // Slot devono essere indici validi rispetto al planning slot.
      for (final slot in slots) {
        if (slot < 0 || slot > maxSlotIndex) {
          errors.add(
            'Slot index invalido: $slot nel giorno $day '
            '(deve essere 0-$maxSlotIndex per slot da ${StaffPlanning.planningStepMinutes} minuti)',
          );
        }
      }
    }
  }
}
--- FILE: lib/app/app_constants.dart ---
/// Flag applicativo per controllare se lo staff pu√≤ essere associato a pi√π
/// sedi contemporaneamente. Quando √® `false`, il form di creazione/modifica
/// consente una sola sede per membro del team e forza la selezione singola.
const bool kAllowStaffMultiLocationSelection = false;
--- FILE: lib/app/router.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../core/l10n/l10_extension.dart';
// Importa le nuove schermate
import '../features/agenda/presentation/agenda_screen.dart';
import '../features/auth/presentation/profile_screen.dart';
import '../features/auth/presentation/reset_password_screen.dart';
import '../features/bookings_list/presentation/bookings_list_screen.dart';
import '../features/business/presentation/operators_screen.dart';
import '../features/clients/presentation/clients_screen.dart';
import '../features/reports/presentation/reports_screen.dart';
import '../features/services/presentation/services_screen.dart';
import '../features/staff/presentation/staff_week_overview_screen.dart';
import '../features/staff/presentation/team_screen.dart';
// Importa la nostra "Shell"
import 'scaffold_with_navigation.dart';

// 1. Definiamo una chiave globale per la nostra Shell (necessaria)
final _rootNavigatorKey = GlobalKey<NavigatorState>();

/// üîπ Router globale dell‚Äôapp
final GoRouter appRouter = GoRouter(
  initialLocation: '/agenda',
  navigatorKey: _rootNavigatorKey,

  debugLogDiagnostics: kDebugMode,

  errorBuilder: (context, state) => Scaffold(
    appBar: AppBar(title: Text(context.l10n.errorTitle)),
    body: Center(
      child: Text(
        context.l10n.errorNotFound(state.uri.path),
        style: const TextStyle(color: Colors.redAccent),
      ),
    ),
  ),

  // 2. Definiamo la nostra navigazione con `StatefulShellRoute`
  routes: [
    StatefulShellRoute.indexedStack(
      builder: (context, state, navigationShell) {
        return ScaffoldWithNavigation(navigationShell: navigationShell);
      },

      branches: [
        // --- Ramo 0: Agenda ---
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/agenda',
              name: 'agenda',
              builder: (BuildContext context, GoRouterState state) {
                final q = state.uri.queryParameters['clientId'];
                final initialClientId = q == null ? null : int.tryParse(q);
                return AgendaScreen(initialClientId: initialClientId);
              },
            ),
          ],
        ),

        // --- Ramo 1: Clienti ---
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/clienti',
              name: 'clienti',
              builder: (BuildContext context, GoRouterState state) =>
                  const ClientsScreen(),
            ),
          ],
        ),

        // --- Ramo 2: Servizi ---
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/servizi',
              name: 'servizi',
              builder: (BuildContext context, GoRouterState state) =>
                  const ServicesScreen(),
            ),
          ],
        ),

        // --- Ramo 3: Staff ---
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/staff',
              name: 'staff',
              builder: (BuildContext context, GoRouterState state) =>
                  const TeamScreen(),
            ),
          ],
        ),

        // --- Ramo 4: Report ---
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/report',
              name: 'report',
              builder: (BuildContext context, GoRouterState state) =>
                  const ReportsScreen(),
            ),
          ],
        ),

        // --- Ramo 5: Elenco Prenotazioni ---
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/prenotazioni',
              name: 'prenotazioni',
              builder: (BuildContext context, GoRouterState state) =>
                  const BookingsListScreen(),
            ),
          ],
        ),
      ],
    ),
    GoRoute(
      path: '/staff-availability',
      name: 'staff-availability',
      parentNavigatorKey: _rootNavigatorKey,
      builder: (BuildContext context, GoRouterState state) =>
          const StaffWeekOverviewScreen(),
    ),
    // Route per profilo utente
    GoRoute(
      path: '/profilo',
      name: 'profilo',
      parentNavigatorKey: _rootNavigatorKey,
      builder: (BuildContext context, GoRouterState state) =>
          const ProfileScreen(),
    ),
    // Route per operatori business
    GoRoute(
      path: '/operatori/:businessId',
      name: 'operatori',
      parentNavigatorKey: _rootNavigatorKey,
      builder: (BuildContext context, GoRouterState state) {
        final businessId = int.parse(state.pathParameters['businessId']!);
        return OperatorsScreen(businessId: businessId);
      },
    ),
    // Route per reset password (da email invito)
    GoRoute(
      path: '/reset-password/:token',
      name: 'reset-password',
      parentNavigatorKey: _rootNavigatorKey,
      builder: (BuildContext context, GoRouterState state) {
        final token = state.pathParameters['token']!;
        return ResetPasswordScreen(token: token);
      },
    ),
  ],
);
--- FILE: lib/app/scaffold_with_navigation.dart ---
// Cleaned duplicate header
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/widgets/agenda_control_components.dart';
import 'package:agenda_backend/app/widgets/agenda_staff_filter_selector.dart';
import 'package:agenda_backend/app/widgets/top_controls.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/widgets/agenda_dividers.dart';
import 'package:agenda_backend/features/auth/providers/current_business_user_provider.dart';
import 'package:agenda_backend/features/bookings_list/providers/bookings_list_provider.dart';
import 'package:agenda_backend/features/booking_notifications/providers/booking_notifications_provider.dart';
import 'package:agenda_backend/features/class_events/presentation/class_events_screen.dart';
import 'package:agenda_backend/features/reports/providers/reports_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:intl/intl.dart';

import '../core/l10n/l10_extension.dart';
import '../core/models/location.dart';
import '../core/widgets/adaptive_dropdown.dart';
import '../core/widgets/app_bottom_sheet.dart';
import '../core/widgets/app_buttons.dart';
import '../core/widgets/global_loading_overlay.dart';
import '../features/agenda/presentation/dialogs/add_block_dialog.dart';
import '../features/agenda/presentation/widgets/agenda_top_controls.dart';
import '../features/agenda/presentation/widgets/booking_dialog.dart';
import '../features/agenda/providers/business_providers.dart';
import '../features/agenda/providers/date_range_provider.dart';
import '../features/agenda/providers/layout_config_provider.dart';
import '../features/agenda/providers/location_providers.dart';
import '../features/auth/providers/auth_provider.dart';
import '../features/business/presentation/dialogs/invite_operator_dialog.dart';
import '../features/business/presentation/dialogs/location_closure_dialog.dart';
import '../features/business/providers/location_closures_provider.dart';
import '../features/business/providers/superadmin_selected_business_provider.dart';
import '../features/clients/presentation/dialogs/client_edit_dialog.dart';
import '../features/clients/providers/clients_providers.dart';
import '../features/services/presentation/dialogs/category_dialog.dart';
import '../features/services/presentation/dialogs/service_dialog.dart';
import '../features/services/presentation/dialogs/service_package_dialog.dart';
import '../features/services/providers/service_categories_provider.dart';
import '../features/services/providers/services_provider.dart';
import '../features/services/providers/services_reorder_provider.dart';
import '../features/staff/presentation/dialogs/location_dialog.dart';
import '../features/staff/presentation/dialogs/staff_dialog.dart';
import '../features/staff/providers/staff_providers.dart';
import '../features/staff/providers/staff_reorder_provider.dart';

Widget _buildAddButtonContent({
  required bool showLabelEffective,
  required bool compact,
  required String label,
  required Color onContainer,
}) {
  if (compact) {
    return showLabelEffective
        ? Text(
            label,
            style: TextStyle(color: onContainer, fontWeight: FontWeight.w600),
          )
        : Icon(Icons.add_outlined, size: 22, color: onContainer);
  }
  if (!showLabelEffective) {
    return Icon(Icons.add_outlined, size: 22, color: onContainer);
  }
  return Row(
    mainAxisSize: MainAxisSize.min,
    children: [
      Icon(Icons.add_outlined, size: 22, color: onContainer),
      const SizedBox(width: 8),
      Text(
        label,
        style: TextStyle(color: onContainer, fontWeight: FontWeight.w600),
      ),
    ],
  );
}

class ScaffoldWithNavigation extends ConsumerWidget {
  const ScaffoldWithNavigation({super.key, required this.navigationShell});

  final StatefulNavigationShell navigationShell;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final formFactor = ref.watch(formFactorProvider);
    final isAgenda = navigationShell.currentIndex == 0;
    final isClients = navigationShell.currentIndex == 1;
    final isServices = navigationShell.currentIndex == 2;
    final isStaff = navigationShell.currentIndex == 3;
    final isReport = navigationShell.currentIndex == 4;
    final isBookingsList = navigationShell.currentIndex == 5;
    final isBookingNotifications = navigationShell.currentIndex == 10;
    final isClosures = navigationShell.currentIndex == 7;
    final isPermessi = navigationShell.currentIndex == 9;
    final currentPath = GoRouterState.of(context).uri.path;
    final isClassEvents = currentPath == '/altro/classi';
    final agendaDate = ref.watch(agendaDateProvider);
    final today = DateUtils.dateOnly(DateTime.now());
    final isToday = DateUtils.isSameDay(agendaDate, today);
    final isPast = agendaDate.isBefore(today);
    final user = ref.watch(authProvider).user;
    final isSuperadmin = user?.isSuperadmin ?? false;
    final showClientsNav = ref.watch(currentUserCanManageClientsProvider);
    final canCreateAgendaItems = ref.watch(
      currentUserCanManageBookingsProvider,
    );
    final canManageServices = ref.watch(currentUserCanManageServicesProvider);
    final canViewStaff = ref.watch(currentUserCanViewStaffProvider);
    final canViewReports = ref.watch(currentUserCanViewReportsProvider);
    final canManageOperators = ref.watch(canManageOperatorsProvider);
    final canManageClosures = ref.watch(canManageBusinessSettingsProvider);
    final businessesAsync = ref.watch(businessesProvider);
    final hasMultipleBusinesses = businessesAsync.maybeWhen(
      data: (businesses) => businesses.length > 1,
      orElse: () => false,
    );
    final showSwitchBusiness = isSuperadmin || hasMultipleBusinesses;

    // Per mobile e desktop usiamo destinazioni compatte con "Altro"
    final mobileDestinations =
        _ScaffoldWithNavigationHelpers.getMobileDestinations(
          context,
          showSwitchBusiness: showSwitchBusiness,
          includeClients: showClientsNav,
        );

    // Quando non siamo su oggi, mostra freccia per tornare a oggi
    // Freccia destra se nel passato (vai avanti), sinistra se nel futuro (torna indietro)
    // Destinazioni mobile risolte (con freccia per oggi se necessario)
    final resolvedMobileDestinations = isAgenda && !isToday
        ? [
            NavigationDestination(
              iconData: isPast ? Icons.arrow_forward : Icons.arrow_back,
              selectedIconData: isPast ? Icons.arrow_forward : Icons.arrow_back,
              label: context.l10n.agendaToday,
            ),
            ...mobileDestinations.skip(1),
          ]
        : mobileDestinations;

    if (formFactor == AppFormFactor.desktop) {
      final layoutConfig = ref.watch(layoutConfigProvider);
      final dividerColor = Theme.of(context).dividerColor;
      const dividerThickness = 1.0;
      // Desktop usa le stesse destinazioni del mobile (con "Altro")
      final railDestinations =
          _ScaffoldWithNavigationHelpers.toRailDestinations(
            resolvedMobileDestinations,
          );

      final isTablet = formFactor == AppFormFactor.tablet;

      // Azioni specifiche per tab (menu utente √® nella rail)
      List<Widget> buildActions() {
        final List<Widget> actions = [];
        if (isAgenda) {
          if (canCreateAgendaItems) {
            actions.add(const _AgendaAddAction());
          }
        } else if (isServices && canManageServices) {
          actions.add(const _ToolbarLocationSelectorAction());
          actions.add(const _ServicesAddAction());
        } else if (isClients && showClientsNav) {
          actions.add(const _ClientsAddAction());
        } else if (isStaff && canViewStaff) {
          actions.add(const _TeamAddAction());
        } else if (isReport && canViewReports) {
          actions.add(_ReportRefreshAction(ref: ref));
        } else if (isBookingsList) {
          actions.add(_BookingsListRefreshAction(ref: ref));
        } else if (isClassEvents) {
          actions.add(const _ToolbarLocationSelectorAction());
          if (canManageServices) {
            actions.add(const _ClassEventsAddAction());
          }
        } else if (isBookingNotifications) {
          actions.add(_BookingNotificationsRefreshAction(ref: ref));
        } else if (isClosures && canManageClosures) {
          actions.add(const _ClosuresAddAction());
        } else if (isPermessi && canManageOperators) {
          actions.add(const _PermessiAddAction());
        }
        return actions;
      }

      // Mappa indice corrente a indice compatto per desktop.
      int desktopCurrentIndex;
      if (!showClientsNav) {
        desktopCurrentIndex = navigationShell.currentIndex == 0 ? 0 : 1;
      } else if (navigationShell.currentIndex <= 1) {
        // Agenda o Clienti
        desktopCurrentIndex = navigationShell.currentIndex;
      } else {
        // Tutto il resto (Servizi, Staff, Report, Prenotazioni, Altro, Chiusure, Profilo) ‚Üí evidenzia "Altro"
        desktopCurrentIndex = 2;
      }

      return GlobalLoadingOverlay(
        child: Scaffold(
          appBar: AppBar(
            titleSpacing: isTablet && isAgenda
                ? 4
                : NavigationToolbar.kMiddleSpacing,
            title: isAgenda
                ? const AgendaTopControls()
                : isReport
                ? Text(context.l10n.reportsTitle)
                : isBookingsList
                ? Text(context.l10n.bookingsListTitle)
                : isClassEvents
                ? Text(context.l10n.classEventsTitle)
                : isBookingNotifications
                ? Text(context.l10n.bookingNotificationsTitle)
                : isClosures
                ? Text(context.l10n.closuresTitle)
                : isPermessi
                ? Text(context.l10n.permissionsTitle)
                : const SizedBox.shrink(),
            centerTitle: false,
            toolbarHeight: 76,
            actionsPadding: const EdgeInsets.only(right: 6),
            actions: buildActions(),
          ),
          body: Row(
            children: [
              Theme(
                data: Theme.of(context).copyWith(
                  splashColor: Colors.transparent,
                  highlightColor: Colors.transparent,
                  hoverColor: Colors.transparent,
                ),
                child: NavigationRail(
                  selectedIndex: desktopCurrentIndex,
                  onDestinationSelected: (index) => _handleDesktopNavTap(
                    context,
                    index,
                    ref,
                    includeClients: showClientsNav,
                  ),
                  labelType: NavigationRailLabelType.none,
                  useIndicator: false, // disattiva highlight di sistema su tap
                  // BusinessSelector rimosso - superadmin usa /businesses
                  destinations: railDestinations,
                ),
              ),
              _RailDivider(
                topInset: layoutConfig.headerHeight,
                color: dividerColor,
                thickness: dividerThickness,
              ),
              Expanded(child: navigationShell),
            ],
          ),
        ),
      );
    }

    final isTablet = formFactor == AppFormFactor.tablet;
    final isMobile = formFactor == AppFormFactor.mobile;
    // Su mobile e tablet il date switcher √® in basso, non nell'AppBar
    final showBottomDateSwitcher = isAgenda && (isTablet || isMobile);
    final bottomNavColor =
        Theme.of(context).bottomNavigationBarTheme.backgroundColor ??
        Theme.of(context).colorScheme.surface;

    // Azioni specifiche per tab (menu utente √® nella BNB)
    List<Widget> buildMobileActions() {
      final List<Widget> actions = [];
      if (isAgenda) {
        if (formFactor == AppFormFactor.mobile) {
          actions.add(
            const _AgendaFilterActions(padding: EdgeInsets.only(left: 8)),
          );
        }
        if (canCreateAgendaItems) {
          actions.add(const _AgendaAddAction(compact: true));
        }
      } else if (isServices && canManageServices) {
        actions.add(const _ToolbarLocationSelectorAction(compact: true));
        actions.add(const _ServicesAddAction(compact: true));
      } else if (isClients && showClientsNav) {
        actions.add(const _ClientsAddAction(compact: true));
      } else if (isStaff && canViewStaff) {
        actions.add(const _TeamAddAction(compact: true));
      } else if (isReport && canViewReports) {
        actions.add(_ReportRefreshAction(ref: ref));
      } else if (isBookingsList) {
        actions.add(_BookingsListRefreshAction(ref: ref));
      } else if (isClassEvents) {
        actions.add(const _ToolbarLocationSelectorAction(compact: true));
        if (canManageServices) {
          actions.add(const _ClassEventsAddAction(compact: true));
        }
      } else if (isBookingNotifications) {
        actions.add(_BookingNotificationsRefreshAction(ref: ref));
      } else if (isClosures && canManageClosures) {
        actions.add(const _ClosuresAddAction(compact: true));
      } else if (isPermessi && canManageOperators) {
        actions.add(const _PermessiAddAction(compact: true));
      }
      return actions;
    }

    // Su mobile, mappa l'indice corrente a quello compatto
    // Desktop: 0=Agenda, 1=Clienti, 2=Servizi, 3=Staff, 4=Report, 5=Prenotazioni, 6=Altro, 7=Chiusure, 8=Profilo
    // Mobile:  0=Agenda, 1=Clienti, 2=Altro
    int mobileCurrentIndex;
    if (!showClientsNav) {
      mobileCurrentIndex = navigationShell.currentIndex == 0 ? 0 : 1;
    } else if (navigationShell.currentIndex <= 1) {
      // Agenda o Clienti
      mobileCurrentIndex = navigationShell.currentIndex;
    } else {
      // Tutto il resto (Servizi, Staff, Report, Prenotazioni, Altro, Chiusure, Profilo) ‚Üí evidenzia "Altro"
      mobileCurrentIndex = 2;
    }

    return GlobalLoadingOverlay(
      child: Scaffold(
        appBar: AppBar(
          toolbarHeight: isTablet ? 76 : 64,
          titleSpacing: isAgenda ? 4 : NavigationToolbar.kMiddleSpacing,
          title: isAgenda
              ? const AgendaTopControls(compact: true)
              : isReport
              ? Text(context.l10n.reportsTitle)
              : isBookingsList
              ? Text(context.l10n.bookingsListTitle)
              : isClassEvents
              ? Text(context.l10n.classEventsTitle)
              : isBookingNotifications
              ? Text(context.l10n.bookingNotificationsTitle)
              : isClosures
              ? Text(context.l10n.closuresTitle)
              : isPermessi
              ? Text(context.l10n.permissionsTitle)
              : const SizedBox.shrink(),
          centerTitle: false,
          actionsPadding: const EdgeInsets.only(right: 6),
          actions: buildMobileActions(),
        ),
        body: navigationShell,
        bottomNavigationBar: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (showBottomDateSwitcher) ...[
              const AgendaHorizontalDivider(),
              Padding(
                padding: const EdgeInsets.symmetric(vertical: 8.0),
                child: const _MobileAgendaDateSwitcher(),
              ),
            ],
            ColoredBox(
              color: bottomNavColor,
              child: SafeArea(
                top: false,
                left: false,
                right: false,
                minimum: const EdgeInsets.only(bottom: 15),
                child: BottomNavigationBar(
                  currentIndex: mobileCurrentIndex,
                  onTap: (index) => _handleMobileNavTap(
                    context,
                    index,
                    ref,
                    includeClients: showClientsNav,
                  ),
                  type: BottomNavigationBarType.fixed,
                  items: resolvedMobileDestinations
                      .map(
                        (d) => BottomNavigationBarItem(
                          icon: Icon(d.iconData),
                          activeIcon: Icon(d.selectedIconData),
                          label: d.label,
                        ),
                      )
                      .toList(),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _goBranch(
    int index,
    WidgetRef ref, {
    bool forceInitialLocation = false,
  }) {
    // Protezione: i branch validi sono 0-6
    if (index < 0 || index > 6) {
      debugPrint('_goBranch: invalid index $index, ignoring');
      return;
    }

    if (index == 0 && navigationShell.currentIndex == 0) {
      final selectedDate = ref.read(agendaDateProvider);
      final today = DateUtils.dateOnly(DateTime.now());
      if (!DateUtils.isSameDay(selectedDate, today)) {
        ref.read(agendaDateProvider.notifier).setToday();
      }
    }

    // Ricarica i provider quando si cambia tab per forzare il refresh dei dati
    if (index != navigationShell.currentIndex) {
      _refreshProvidersForTab(index, ref);
    }

    navigationShell.goBranch(
      index,
      initialLocation:
          forceInitialLocation || index == navigationShell.currentIndex,
    );
  }

  /// Ricarica i provider relativi alla tab selezionata
  void _refreshProvidersForTab(int index, WidgetRef ref) {
    final canManageSettings = ref.read(canManageBusinessSettingsProvider);
    final canManageClients = ref.read(currentUserCanManageClientsProvider);
    final canViewServices = ref.read(currentUserCanViewServicesProvider);
    final canViewStaff = ref.read(currentUserCanViewStaffProvider);
    switch (index) {
      case 0: // Agenda
        if (canManageSettings) {
          ref.read(locationClosuresProvider.notifier).refresh();
        }
        break;
      case 1: // Clienti
        if (canManageClients) {
          ref.read(clientsProvider.notifier).setSearchQuery('');
          ref.read(clientsProvider.notifier).refresh();
          ref.read(clientAppointmentsRefreshProvider.notifier).bump();
        }
        break;
      case 2: // Servizi
        if (canViewServices) {
          ref.read(servicesProvider.notifier).refresh();
        }
        break;
      case 3: // Staff
        if (canViewStaff) {
          ref.read(allStaffProvider.notifier).refresh();
          ref.read(locationsProvider.notifier).refresh();
        }
        break;
    }
  }

  /// Gestisce tap su navigation desktop (compatta come mobile):
  /// - Index 0, 1: navigazione normale (Agenda, Clienti)
  /// - Index 2: naviga a "Altro" (schermata con cards)
  /// - Index 3: Cambia Business (se presente) o Logout
  /// - Index 4: Logout (se Cambia Business presente)
  void _handleDesktopNavTap(
    BuildContext context,
    int desktopIndex,
    WidgetRef ref, {
    required bool includeClients,
  }) {
    final isSuperadmin = ref.read(authProvider).user?.isSuperadmin ?? false;
    final businessesAsync = ref.read(businessesProvider);
    final hasMultipleBusinesses = businessesAsync.maybeWhen(
      data: (businesses) => businesses.length > 1,
      orElse: () => false,
    );
    final showSwitchBusiness = isSuperadmin || hasMultipleBusinesses;
    final baseCount = includeClients ? 3 : 2;
    final logoutIndex = showSwitchBusiness ? baseCount + 1 : baseCount;
    final switchBusinessIndex = showSwitchBusiness ? baseCount : -1;

    if (desktopIndex == logoutIndex) {
      _handleLogout(context, ref);
      return;
    }
    if (desktopIndex == switchBusinessIndex) {
      _goToBusinessSwitcher(context, ref);
      return;
    }
    if (desktopIndex == 0) {
      _goBranch(0, ref);
      return;
    }
    if (includeClients && desktopIndex == 1) {
      _goBranch(1, ref);
      return;
    }
    final moreIndex = includeClients ? 2 : 1;
    if (desktopIndex == moreIndex) {
      _goBranch(6, ref, forceInitialLocation: true);
    }
  }

  /// Gestisce tap su navigation mobile:
  /// - Index 0, 1: navigazione normale (Agenda, Clienti)
  /// - Index 2: naviga a "Altro" (schermata con cards)
  /// - Index 3: Cambia Business (se presente) o Logout
  /// - Index 4: Logout (se Cambia Business presente)
  void _handleMobileNavTap(
    BuildContext context,
    int mobileIndex,
    WidgetRef ref, {
    required bool includeClients,
  }) {
    final isSuperadmin = ref.read(authProvider).user?.isSuperadmin ?? false;
    final businessesAsync = ref.read(businessesProvider);
    final hasMultipleBusinesses = businessesAsync.maybeWhen(
      data: (businesses) => businesses.length > 1,
      orElse: () => false,
    );
    final showSwitchBusiness = isSuperadmin || hasMultipleBusinesses;
    final baseCount = includeClients ? 3 : 2;
    final logoutIndex = showSwitchBusiness ? baseCount + 1 : baseCount;
    final switchBusinessIndex = showSwitchBusiness ? baseCount : -1;

    if (mobileIndex == logoutIndex) {
      _handleLogout(context, ref);
      return;
    }
    if (mobileIndex == switchBusinessIndex) {
      _goToBusinessSwitcher(context, ref);
      return;
    }
    if (mobileIndex == 0) {
      _goBranch(0, ref);
      return;
    }
    if (includeClients && mobileIndex == 1) {
      _goBranch(1, ref);
      return;
    }
    final moreIndex = includeClients ? 2 : 1;
    if (mobileIndex == moreIndex) {
      _goBranch(6, ref, forceInitialLocation: true);
    }
  }

  void _goToBusinessSwitcher(BuildContext context, WidgetRef ref) {
    final isSuperadmin = ref.read(authProvider).user?.isSuperadmin ?? false;
    invalidateBusinessScopedProviders(ref);
    if (isSuperadmin) {
      ref.read(superadminSelectedBusinessProvider.notifier).clear();
      context.go('/businesses');
      return;
    }
    context.go('/my-businesses?switch=1');
  }

  void _handleLogout(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.authLogout),
        content: const Text('Vuoi uscire dal gestionale?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text(l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () {
              Navigator.of(context).pop();
              ref.read(authProvider.notifier).logout();
            },
            child: Text(l10n.authLogout),
          ),
        ],
      ),
    );
  }
}

class _AgendaAddAction extends ConsumerWidget {
  const _AgendaAddAction({this.compact = false});
  final bool compact;
  static const double _actionButtonHeight = 40;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final agendaDate = ref.watch(agendaDateProvider);
    final currentUserRole = ref.watch(currentUserRoleProvider);
    final currentUserStaffId = ref.watch(currentUserStaffIdProvider);
    final initialStaffIdForNewBooking =
        (currentUserRole == 'staff' &&
            currentUserStaffId != null &&
            currentUserStaffId > 0)
        ? currentUserStaffId
        : null;
    final scheme = Theme.of(context).colorScheme;
    final onContainer = scheme.onSecondaryContainer;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective =
        showLabel ||
        formFactor == AppFormFactor.tablet ||
        formFactor == AppFormFactor.desktop;
    const iconOnlyWidth = 46.0;
    final bool isIconOnly = !showLabelEffective;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: AdaptiveDropdown<String>(
        modalTitle: l10n.agendaAddTitle,
        alignment: AdaptiveDropdownAlignment.right,
        verticalPosition: AdaptiveDropdownVerticalPosition.above,
        forcePopup: true,
        hideTriggerWhenOpen: true,
        popupWidth: 200,
        items: [
          AdaptiveDropdownItem(
            value: 'appointment',
            child: Text(l10n.agendaAddAppointment),
          ),
          AdaptiveDropdownItem(
            value: 'block',
            child: Text(l10n.agendaAddBlock),
          ),
        ],
        onSelected: (value) {
          if (value == 'appointment') {
            showBookingDialog(
              context,
              ref,
              date: agendaDate,
              autoOpenDatePicker: true,
              initialStaffId: initialStaffIdForNewBooking,
            );
          } else if (value == 'block') {
            showAddBlockDialog(
              context,
              ref,
              date: agendaDate,
              initialStaffId: initialStaffIdForNewBooking,
            );
          }
        },
        child: Material(
          elevation: 0,
          color: scheme.secondaryContainer,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
          clipBehavior: Clip.antiAlias,
          child: SizedBox(
            height: _actionButtonHeight,
            width: isIconOnly ? iconOnlyWidth : null,
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              child: _buildAddButtonContent(
                showLabelEffective: showLabelEffective,
                compact: compact,
                label: l10n.agendaAdd,
                onContainer: onContainer,
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class _AgendaFilterActions extends ConsumerWidget {
  const _AgendaFilterActions({
    this.padding = const EdgeInsets.symmetric(horizontal: 8),
  });

  static const double _actionButtonHeight = 40;
  static const double _iconOnlyWidth = 46;
  static const double _locationComboWidth = 200;
  static const double _spacing = 8;
  final EdgeInsetsGeometry padding;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final scheme = Theme.of(context).colorScheme;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective =
        showLabel ||
        formFactor == AppFormFactor.tablet ||
        formFactor == AppFormFactor.desktop;
    final staffCount = ref.watch(staffForCurrentLocationProvider).length;
    final locations = ref.watch(locationsProvider);
    final currentLocationId = ref.watch(currentLocationIdProvider);
    // Mostra selettore staff solo se pu√≤ vedere tutti gli appuntamenti
    final canViewAll = ref.watch(canViewAllAppointmentsProvider);
    final showStaffSelector = canViewAll && staffCount > 1;
    final showLocationSelector = locations.length > 1;

    if (!showStaffSelector && !showLocationSelector) {
      return const SizedBox.shrink();
    }

    Widget buildActionLabel(IconData icon, String label) {
      return showLabelEffective
          ? Row(
              mainAxisSize: MainAxisSize.max,
              children: [
                Icon(icon, size: 22),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    label,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            )
          : Icon(icon, size: 22);
    }

    return Padding(
      padding: padding,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (showStaffSelector)
            AgendaStaffFilterSelector(
              compactBuilder: (context, onPressed, tooltip) {
                return Tooltip(
                  message: tooltip,
                  child: SizedBox(
                    height: _actionButtonHeight,
                    width: showLabelEffective ? null : _iconOnlyWidth,
                    child: AppOutlinedActionButton(
                      onPressed: onPressed,
                      padding: const EdgeInsets.symmetric(
                        horizontal: 12,
                        vertical: 8,
                      ),
                      borderRadius: BorderRadius.circular(8),
                      borderColor: scheme.primary,
                      foregroundColor: scheme.primary,
                      child: buildActionLabel(
                        Icons.badge_outlined,
                        l10n.staffFilterTitle,
                      ),
                    ),
                  ),
                );
              },
            ),
          if (showStaffSelector && showLocationSelector)
            const SizedBox(width: _spacing),
          if (showLocationSelector)
            Tooltip(
              message: l10n.agendaSelectLocation,
              child: SizedBox(
                height: _actionButtonHeight,
                width: showLabelEffective ? _locationComboWidth : _iconOnlyWidth,
                child: AppOutlinedActionButton(
                  onPressed: () => _showLocationSheet(
                    context,
                    ref,
                    locations,
                    currentLocationId,
                    l10n.agendaSelectLocation,
                  ),
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  borderRadius: BorderRadius.circular(8),
                  borderColor: scheme.primary,
                  foregroundColor: scheme.primary,
                  child: buildActionLabel(
                    Icons.place_outlined,
                    l10n.agendaSelectLocation,
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }

  Future<void> _showLocationSheet(
    BuildContext context,
    WidgetRef ref,
    List<Location> locations,
    int currentLocationId,
    String title,
  ) async {
    final result = await AppBottomSheet.show<int?>(
      context: context,
      builder: (ctx) => LocationSheetContent(
        locations: locations,
        currentLocationId: currentLocationId,
        title: title,
        onSelected: (id) => Navigator.of(ctx).pop(id),
      ),
      useRootNavigator: true,
      padding: EdgeInsets.zero,
    );

    if (result != null) {
      ref.read(currentLocationIdProvider.notifier).set(result);
    }
  }
}

class _ToolbarLocationSelectorAction extends ConsumerWidget {
  const _ToolbarLocationSelectorAction({this.compact = false});

  static const double _actionButtonHeight = 40;
  static const double _iconOnlyWidth = 46;
  static const double _locationComboWidth = 200;

  final bool compact;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final locations = ref.watch(locationsProvider);
    if (locations.length <= 1) {
      return const SizedBox.shrink();
    }

    final currentLocationId = ref.watch(currentLocationIdProvider);
    final l10n = context.l10n;
    final scheme = Theme.of(context).colorScheme;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);

    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective =
        showLabel ||
        formFactor == AppFormFactor.tablet ||
        formFactor == AppFormFactor.desktop;
    final bool isIconOnly = !showLabelEffective;
    final selectedLocationName = locations
        .where((location) => location.id == currentLocationId)
        .map((location) => location.name)
        .firstOrNull;
    final buttonLabel = selectedLocationName ?? l10n.agendaSelectLocation;

    Widget buildActionLabel(IconData icon, String label) {
      return showLabelEffective
          ? Row(
              mainAxisSize: MainAxisSize.max,
              children: [
                Icon(icon, size: 22),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    label,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            )
          : Icon(icon, size: 22);
    }

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: Tooltip(
        message: l10n.agendaSelectLocation,
        child: SizedBox(
          height: _actionButtonHeight,
          width: isIconOnly ? _iconOnlyWidth : _locationComboWidth,
          child: AppOutlinedActionButton(
            onPressed: () => _showLocationSheet(
              context,
              ref,
              locations,
              currentLocationId,
              l10n.agendaSelectLocation,
            ),
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            borderRadius: BorderRadius.circular(8),
            borderColor: scheme.primary,
            foregroundColor: scheme.primary,
            child: buildActionLabel(
              Icons.place_outlined,
              buttonLabel,
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _showLocationSheet(
    BuildContext context,
    WidgetRef ref,
    List<Location> locations,
    int currentLocationId,
    String title,
  ) async {
    final result = await AppBottomSheet.show<int?>(
      context: context,
      builder: (ctx) => LocationSheetContent(
        locations: locations,
        currentLocationId: currentLocationId,
        title: title,
        onSelected: (id) => Navigator.of(ctx).pop(id),
      ),
      useRootNavigator: true,
      padding: EdgeInsets.zero,
    );

    if (result != null) {
      ref.read(currentLocationIdProvider.notifier).set(result);
    }
  }
}

class _ServicesAddAction extends ConsumerWidget {
  const _ServicesAddAction({this.compact = false});
  final bool compact;
  static const double _actionButtonHeight = 40;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final scheme = Theme.of(context).colorScheme;
    final onContainer = scheme.onSecondaryContainer;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective =
        showLabel ||
        formFactor == AppFormFactor.tablet ||
        formFactor == AppFormFactor.desktop;
    final services = ref.watch(servicesProvider).value ?? [];
    final categories = ref.watch(serviceCategoriesProvider);
    const iconOnlyWidth = 46.0;
    final bool isIconOnly = !showLabelEffective;
    Widget buildActionLabel(IconData icon, String label) {
      return showLabelEffective
          ? Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(icon, size: 22),
                const SizedBox(width: 8),
                Text(label),
              ],
            )
          : Icon(icon, size: 22);
    }

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          ...[
            Tooltip(
              message: l10n.reorderTitle,
              child: SizedBox(
                height: _actionButtonHeight,
                width: isIconOnly ? iconOnlyWidth : null,
                child: AppOutlinedActionButton(
                  onPressed: () {
                    ref.read(servicesReorderPanelProvider.notifier).toggle();
                  },
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  borderRadius: BorderRadius.circular(8),
                  borderColor: scheme.primary,
                  foregroundColor: scheme.primary,
                  child: buildActionLabel(Icons.sort, l10n.reorderTitle),
                ),
              ),
            ),
            const SizedBox(width: 8),
          ],
          AdaptiveDropdown<String>(
            modalTitle: l10n.agendaAdd,
            alignment: AdaptiveDropdownAlignment.right,
            verticalPosition: AdaptiveDropdownVerticalPosition.above,
            forcePopup: true,
            hideTriggerWhenOpen: true,
            popupWidth: 200,
            items: [
              AdaptiveDropdownItem(
                value: 'category',
                child: Text(l10n.createCategoryButtonLabel),
              ),
              AdaptiveDropdownItem(
                value: 'service',
                child: Text(l10n.servicesNewServiceMenu),
              ),
              AdaptiveDropdownItem(
                value: 'package',
                child: Text(l10n.servicePackageNewMenu),
              ),
            ],
            onSelected: (value) {
              if (value == 'category') {
                showCategoryDialog(context, ref);
              } else if (value == 'service') {
                showServiceDialog(context, ref, requireCategorySelection: true);
              } else if (value == 'package') {
                showServicePackageDialog(
                  context,
                  ref,
                  services: services,
                  categories: categories,
                );
              }
            },
            child: Material(
              elevation: 0,
              color: scheme.secondaryContainer,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
              clipBehavior: Clip.antiAlias,
              child: SizedBox(
                height: _actionButtonHeight,
                width: isIconOnly ? iconOnlyWidth : null,
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  child: _buildAddButtonContent(
                    showLabelEffective: showLabelEffective,
                    compact: compact,
                    label: l10n.agendaAdd,
                    onContainer: onContainer,
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _TeamAddAction extends ConsumerWidget {
  const _TeamAddAction({this.compact = false});
  final bool compact;
  static const double _actionButtonHeight = 40;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final scheme = Theme.of(context).colorScheme;
    final onContainer = scheme.onSecondaryContainer;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective = showLabel || formFactor != AppFormFactor.mobile;
    const iconOnlyWidth = 46.0;
    final bool isIconOnly = !showLabelEffective;

    // Controlla se ci sono staff e locations per determinare visibilit√† pulsanti
    final staffAsync = ref.watch(allStaffProvider);
    final staffCount = staffAsync.value?.length ?? 0;
    final locations = ref.watch(locationsProvider);
    final locationCount = locations.length;
    final canManageStaff = ref.watch(currentUserCanManageStaffProvider);

    Widget buildActionLabel(IconData icon, String label) {
      return showLabelEffective
          ? Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(icon, size: 22),
                const SizedBox(width: 8),
                Text(label),
              ],
            )
          : Icon(icon, size: 22);
    }

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Pulsante Disponibilit√†: visibile solo se almeno 1 staff
          if (staffCount >= 1) ...[
            Tooltip(
              message: l10n.staffHubAvailabilityTitle,
              child: SizedBox(
                height: _actionButtonHeight,
                width: isIconOnly ? iconOnlyWidth : null,
                child: AppOutlinedActionButton(
                  onPressed: () => context.pushNamed('staff-availability'),
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  borderRadius: BorderRadius.circular(8),
                  borderColor: scheme.primary,
                  foregroundColor: scheme.primary,
                  child: buildActionLabel(
                    Icons.schedule_outlined,
                    l10n.staffHubAvailabilityTitle,
                  ),
                ),
              ),
            ),
            const SizedBox(width: 8),
          ],
          // Pulsante Modifica ordinamento: solo per ruoli con permesso di modifica
          if (canManageStaff && (staffCount >= 2 || locationCount >= 2)) ...[
            Tooltip(
              message: l10n.reorderTitle,
              child: SizedBox(
                height: _actionButtonHeight,
                width: isIconOnly ? iconOnlyWidth : null,
                child: AppOutlinedActionButton(
                  onPressed: () {
                    ref.read(teamReorderPanelProvider.notifier).toggle();
                  },
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  borderRadius: BorderRadius.circular(8),
                  borderColor: scheme.primary,
                  foregroundColor: scheme.primary,
                  child: buildActionLabel(Icons.sort, l10n.reorderTitle),
                ),
              ),
            ),
            const SizedBox(width: 8),
          ],
          if (canManageStaff)
            AdaptiveDropdown<String>(
              modalTitle: l10n.agendaAdd,
              alignment: AdaptiveDropdownAlignment.right,
              verticalPosition: AdaptiveDropdownVerticalPosition.above,
              forcePopup: true,
              hideTriggerWhenOpen: true,
              popupWidth: 220,
              items: [
                AdaptiveDropdownItem(
                  value: 'location',
                  child: Text(l10n.teamNewLocationTitle),
                ),
                AdaptiveDropdownItem(
                  value: 'staff',
                  child: Text(l10n.teamNewStaffTitle),
                ),
              ],
              onSelected: (value) {
                if (value == 'location') {
                  showLocationDialog(context, ref);
                } else if (value == 'staff') {
                  showStaffDialog(context, ref);
                }
              },
              child: Material(
                elevation: 0,
                color: scheme.secondaryContainer,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
                clipBehavior: Clip.antiAlias,
                child: SizedBox(
                  height: _actionButtonHeight,
                  width: isIconOnly ? iconOnlyWidth : null,
                  child: Padding(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 8,
                    ),
                    child: _buildAddButtonContent(
                      showLabelEffective: showLabelEffective,
                      compact: compact,
                      label: l10n.agendaAdd,
                      onContainer: onContainer,
                    ),
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }
}

class _ClientsAddAction extends ConsumerWidget {
  const _ClientsAddAction({this.compact = false});
  final bool compact;
  static const double _actionButtonHeight = 40;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective = showLabel || formFactor != AppFormFactor.mobile;
    const iconOnlyWidth = 46.0;
    final bool isIconOnly = !showLabelEffective;
    if (compact) {
      return Padding(
        padding: const EdgeInsets.symmetric(horizontal: 8),
        child: GestureDetector(
          onTap: () async {
            await showClientEditDialog(context, ref);
          },
          child: Builder(
            builder: (buttonContext) {
              final scheme = Theme.of(buttonContext).colorScheme;
              final onContainer = scheme.onSecondaryContainer;
              return Material(
                elevation: 0,
                color: scheme.secondaryContainer,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
                clipBehavior: Clip.antiAlias,
                child: SizedBox(
                  height: _actionButtonHeight,
                  width: isIconOnly ? iconOnlyWidth : null,
                  child: Padding(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 8,
                    ),
                    child: _buildAddButtonContent(
                      showLabelEffective: showLabelEffective,
                      compact: compact,
                      label: l10n.agendaAdd,
                      onContainer: onContainer,
                    ),
                  ),
                ),
              );
            },
          ),
        ),
      );
    }
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: GestureDetector(
        onTap: () async {
          await showClientEditDialog(context, ref);
        },
        child: Builder(
          builder: (buttonContext) {
            final scheme = Theme.of(buttonContext).colorScheme;
            final onContainer = scheme.onSecondaryContainer;
            return Material(
              elevation: 0,
              color: scheme.secondaryContainer,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
              clipBehavior: Clip.antiAlias,
              child: SizedBox(
                height: _actionButtonHeight,
                width: isIconOnly ? iconOnlyWidth : null,
                child: Padding(
                  padding: const EdgeInsets.fromLTRB(12, 8, 28, 8),
                  child: _buildAddButtonContent(
                    showLabelEffective: showLabelEffective,
                    compact: compact,
                    label: l10n.agendaAdd,
                    onContainer: onContainer,
                  ),
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}

class _MobileAgendaDateSwitcher extends ConsumerWidget {
  const _MobileAgendaDateSwitcher();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final agendaDate = ref.watch(agendaDateProvider);
    final dateController = ref.read(agendaDateProvider.notifier);
    final localeTag = Localizations.localeOf(context).toLanguageTag();
    final label = DateFormat('EEE d MMM', localeTag).format(agendaDate);

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: AgendaDateSwitcher(
        label: label,
        selectedDate: agendaDate,
        onPrevious: dateController.previousDay,
        onNext: dateController.nextDay,
        onPreviousWeek: dateController.previousWeek,
        onNextWeek: dateController.nextWeek,
        onPreviousMonth: dateController.previousMonth,
        onNextMonth: dateController.nextMonth,
        onSelectDate: (date) {
          dateController.set(DateUtils.dateOnly(date));
        },
        isCompact: true,
      ),
    );
  }
}

class _ScaffoldWithNavigationHelpers {
  /// Destinazioni compatte per mobile e desktop (con "Altro")
  static List<NavigationDestination> getMobileDestinations(
    BuildContext context, {
    bool showSwitchBusiness = false,
    bool includeClients = true,
  }) {
    final l10n = context.l10n;
    return [
      NavigationDestination(
        iconData: Icons.calendar_month_outlined,
        selectedIconData: Icons.calendar_month,
        label: l10n.navAgenda,
      ),
      if (includeClients)
        NavigationDestination(
          iconData: Icons.people_outline,
          selectedIconData: Icons.people,
          label: l10n.navClients,
        ),
      NavigationDestination(
        iconData: Icons.more_horiz_outlined,
        selectedIconData: Icons.more_horiz,
        label: l10n.navMore,
      ),
      // Cambia Business
      if (showSwitchBusiness)
        NavigationDestination(
          iconData: Icons.business_outlined,
          selectedIconData: Icons.business,
          label: l10n.switchBusiness,
        ),
      // Esci / Logout
      NavigationDestination(
        iconData: Icons.logout_outlined,
        selectedIconData: Icons.logout,
        label: l10n.authLogout,
      ),
    ];
  }

  static List<NavigationRailDestination> toRailDestinations(
    List<NavigationDestination> destinations,
  ) {
    return destinations
        .map(
          (d) => NavigationRailDestination(
            icon: _NavIcon(icon: d.iconData, label: d.label),
            selectedIcon: _NavIcon(
              icon: d.selectedIconData,
              label: d.label,
              selected: true,
            ),
            label: Text(d.label),
          ),
        )
        .toList();
  }
}

class _RailDivider extends StatelessWidget {
  const _RailDivider({
    required this.topInset,
    required this.color,
    required this.thickness,
  });

  final double topInset;
  final Color color;
  final double thickness;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: thickness,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final availableHeight = constraints.maxHeight;
          final inset = topInset.clamp(0.0, availableHeight);

          return Column(
            children: [
              SizedBox(height: inset),
              Expanded(child: Container(color: color)),
            ],
          );
        },
      ),
    );
  }
}

class _NavIcon extends StatefulWidget {
  const _NavIcon({
    required this.icon,
    required this.label,
    this.selected = false,
  });

  final IconData icon;
  final String label;
  final bool selected;

  @override
  State<_NavIcon> createState() => _NavIconState();
}

class _NavIconState extends State<_NavIcon> {
  static const double _size = 52;
  static const double _iconSize = 24;

  bool _hovering = false;

  void _handleHover(bool hovering) {
    if (_hovering == hovering) return;
    setState(() => _hovering = hovering);
  }

  @override
  Widget build(BuildContext context) {
    final scheme = Theme.of(context).colorScheme;

    final iconColor = scheme.onSecondary.withOpacity(
      widget.selected ? 0.95 : 0.7,
    );

    final labelColor = scheme.onSecondary.withOpacity(
      widget.selected ? 0.95 : 0.65,
    );

    Color backgroundColor = Colors.transparent;

    if (widget.selected || _hovering) {
      // effetto "selected" o "hover": fill leggero
      backgroundColor = scheme.onSecondary.withOpacity(
        widget.selected ? 0.11 : 0.08,
      );
    }

    final baseTheme = Theme.of(context);

    return MouseRegion(
      onEnter: (_) => _handleHover(true),
      onExit: (_) => _handleHover(false),
      child: Theme(
        // disattiva splash / highlight di sistema su tap/long-press
        data: baseTheme.copyWith(
          splashColor: Colors.transparent,
          highlightColor: Colors.transparent,
          hoverColor: Colors.transparent,
        ),
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          curve: Curves.easeInOut,
          width: _size,
          height: _size + 16, // Altezza extra per la label
          decoration: BoxDecoration(
            color: backgroundColor,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(widget.icon, color: iconColor, size: _iconSize),
              const SizedBox(height: 2),
              Text(
                widget.label,
                style: TextStyle(
                  color: labelColor,
                  fontSize: 10,
                  fontWeight: widget.selected
                      ? FontWeight.w600
                      : FontWeight.w500,
                ),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class NavigationDestination {
  const NavigationDestination({
    required this.iconData,
    required this.selectedIconData,
    required this.label,
  });
  final IconData iconData;
  final IconData selectedIconData;
  final String label;
}

/// Refresh button for Report screen
class _ReportRefreshAction extends StatelessWidget {
  const _ReportRefreshAction({required this.ref});

  final WidgetRef ref;

  @override
  Widget build(BuildContext context) {
    return IconButton(
      onPressed: () => ref.read(reportsProvider.notifier).refresh(),
      icon: const Icon(Icons.refresh),
      tooltip: context.l10n.actionRefresh,
    );
  }
}

/// Refresh button for BookingsList screen
class _BookingsListRefreshAction extends StatelessWidget {
  const _BookingsListRefreshAction({required this.ref});

  final WidgetRef ref;

  @override
  Widget build(BuildContext context) {
    final businessId = ref.read(currentLocationProvider).businessId;
    return IconButton(
      onPressed: () =>
          ref.read(bookingsListProvider.notifier).loadBookings(businessId),
      icon: const Icon(Icons.refresh),
      tooltip: context.l10n.actionRefresh,
    );
  }
}

/// Refresh button for BookingNotifications screen
class _BookingNotificationsRefreshAction extends StatelessWidget {
  const _BookingNotificationsRefreshAction({required this.ref});

  final WidgetRef ref;

  @override
  Widget build(BuildContext context) {
    final businessId = ref.read(currentLocationProvider).businessId;
    return IconButton(
      onPressed: () => ref
          .read(bookingNotificationsProvider.notifier)
          .loadNotifications(businessId),
      icon: const Icon(Icons.refresh),
      tooltip: context.l10n.actionRefresh,
    );
  }
}

/// Add button for ClassEvents screen
class _ClassEventsAddAction extends ConsumerWidget {
  const _ClassEventsAddAction({this.compact = false});

  final bool compact;
  static const double _actionButtonHeight = 40;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective = showLabel || formFactor != AppFormFactor.mobile;
    const iconOnlyWidth = 46.0;
    final bool isIconOnly = !showLabelEffective;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: GestureDetector(
        onTap: () => showCreateClassTypeDialog(context, ref),
        child: Builder(
          builder: (buttonContext) {
            final scheme = Theme.of(buttonContext).colorScheme;
            final onContainer = scheme.onSecondaryContainer;
            return Material(
              elevation: 0,
              color: scheme.secondaryContainer,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
              clipBehavior: Clip.antiAlias,
              child: SizedBox(
                height: _actionButtonHeight,
                width: isIconOnly ? iconOnlyWidth : null,
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  child: _buildAddButtonContent(
                    showLabelEffective: showLabelEffective,
                    compact: compact,
                    label: l10n.classEventsAddButton,
                    onContainer: onContainer,
                  ),
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}

/// Add button for Closures screen
class _ClosuresAddAction extends ConsumerWidget {
  const _ClosuresAddAction({this.compact = false});
  final bool compact;
  static const double _actionButtonHeight = 40;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective = showLabel || formFactor != AppFormFactor.mobile;
    const iconOnlyWidth = 46.0;
    final bool isIconOnly = !showLabelEffective;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: GestureDetector(
        onTap: () => LocationClosureDialog.show(context),
        child: Builder(
          builder: (buttonContext) {
            final scheme = Theme.of(buttonContext).colorScheme;
            final onContainer = scheme.onSecondaryContainer;
            return Material(
              elevation: 0,
              color: scheme.secondaryContainer,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
              clipBehavior: Clip.antiAlias,
              child: SizedBox(
                height: _actionButtonHeight,
                width: isIconOnly ? iconOnlyWidth : null,
                child: Padding(
                  padding: compact
                      ? const EdgeInsets.symmetric(horizontal: 12, vertical: 8)
                      : const EdgeInsets.fromLTRB(12, 8, 28, 8),
                  child: _buildAddButtonContent(
                    showLabelEffective: showLabelEffective,
                    compact: compact,
                    label: l10n.agendaAdd,
                    onContainer: onContainer,
                  ),
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}

/// Add button for Permessi screen
class _PermessiAddAction extends ConsumerWidget {
  const _PermessiAddAction({this.compact = false});
  final bool compact;
  static const double _actionButtonHeight = 40;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective = showLabel || formFactor != AppFormFactor.mobile;
    const iconOnlyWidth = 46.0;
    final bool isIconOnly = !showLabelEffective;
    final businessId = ref.watch(currentBusinessIdProvider);

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: GestureDetector(
        onTap: () => showDialog(
          context: context,
          builder: (ctx) => InviteOperatorDialog(businessId: businessId),
        ),
        child: Builder(
          builder: (buttonContext) {
            final scheme = Theme.of(buttonContext).colorScheme;
            final onContainer = scheme.onSecondaryContainer;
            return Material(
              elevation: 0,
              color: scheme.secondaryContainer,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
              clipBehavior: Clip.antiAlias,
              child: SizedBox(
                height: _actionButtonHeight,
                width: isIconOnly ? iconOnlyWidth : null,
                child: Padding(
                  padding: compact
                      ? const EdgeInsets.symmetric(horizontal: 12, vertical: 8)
                      : const EdgeInsets.fromLTRB(12, 8, 28, 8),
                  child: _buildAddButtonContent(
                    showLabelEffective: showLabelEffective,
                    compact: compact,
                    label: l10n.agendaAdd,
                    onContainer: onContainer,
                  ),
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}
--- FILE: lib/app/providers/form_factor_provider.dart ---
import 'dart:ui' as ui;

import 'package:flutter/widgets.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'form_factor_provider.g.dart';

// Definiamo i tre layout che ci interessano
enum AppFormFactor { mobile, tablet, desktop }

AppFormFactor _formFactorForWidth(double width) {
  if (width >= 1024) return AppFormFactor.desktop;
  if (width >= 600) return AppFormFactor.tablet;
  return AppFormFactor.mobile;
}

@riverpod
class FormFactorNotifier extends _$FormFactorNotifier {
  @override
  AppFormFactor build() {
    final binding = WidgetsFlutterBinding.ensureInitialized();
    final dispatcher = binding.platformDispatcher;
    final ui.FlutterView? view = dispatcher.views.isNotEmpty
        ? dispatcher.views.first
        : dispatcher.implicitView;

    if (view != null) {
      final logicalSize = view.physicalSize / view.devicePixelRatio;
      return _formFactorForWidth(logicalSize.width);
    }

    return AppFormFactor.mobile;
  }

  /// Aggiorna il form factor in base alla larghezza dello schermo.
  /// Usa lo stesso breakpoint di 600px che usi nel resto dell'app.
  void update(double screenWidth) {
    final newFactor = _formFactorForWidth(screenWidth);

    // Aggiorna lo stato solo se il form factor cambia
    if (state != newFactor) {
      state = newFactor;
    }
  }
}
--- FILE: lib/app/providers/form_factor_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'form_factor_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(FormFactorNotifier)
const formFactorProvider = FormFactorNotifierProvider._();

final class FormFactorNotifierProvider
    extends $NotifierProvider<FormFactorNotifier, AppFormFactor> {
  const FormFactorNotifierProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'formFactorProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$formFactorNotifierHash();

  @$internal
  @override
  FormFactorNotifier create() => FormFactorNotifier();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AppFormFactor value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AppFormFactor>(value),
    );
  }
}

String _$formFactorNotifierHash() =>
    r'c2d345138b8b938ff84a110cd4b6bf3dda7a605e';

abstract class _$FormFactorNotifier extends $Notifier<AppFormFactor> {
  AppFormFactor build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<AppFormFactor, AppFormFactor>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AppFormFactor, AppFormFactor>,
              AppFormFactor,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/app/providers/global_loading_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

class GlobalLoadingNotifier extends Notifier<int> {
  @override
  int build() => 0;

  void show() {
    state = state + 1;
  }

  void hide() {
    if (state > 0) {
      state = state - 1;
    }
  }
}

final globalLoadingProvider = NotifierProvider<GlobalLoadingNotifier, int>(
  GlobalLoadingNotifier.new,
);
--- FILE: lib/app/theme/extensions.dart ---
import 'package:flutter/material.dart';

class AppInteractionColors extends ThemeExtension<AppInteractionColors> {
  const AppInteractionColors({
    required this.hoverFill,
    required this.pressedFill,
    required this.alternatingRowFill,
  });

  final Color hoverFill;
  final Color pressedFill;

  /// Colore di sfondo per righe alternate (es. liste, tabelle)
  final Color alternatingRowFill;

  @override
  AppInteractionColors copyWith({
    Color? hoverFill,
    Color? pressedFill,
    Color? alternatingRowFill,
  }) {
    return AppInteractionColors(
      hoverFill: hoverFill ?? this.hoverFill,
      pressedFill: pressedFill ?? this.pressedFill,
      alternatingRowFill: alternatingRowFill ?? this.alternatingRowFill,
    );
  }

  @override
  AppInteractionColors lerp(AppInteractionColors? other, double t) {
    if (other == null) return this;
    return AppInteractionColors(
      hoverFill: Color.lerp(hoverFill, other.hoverFill, t) ?? hoverFill,
      pressedFill: Color.lerp(pressedFill, other.pressedFill, t) ?? pressedFill,
      alternatingRowFill:
          Color.lerp(alternatingRowFill, other.alternatingRowFill, t) ??
          alternatingRowFill,
    );
  }

  @override
  int get hashCode => Object.hash(hoverFill, pressedFill, alternatingRowFill);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is AppInteractionColors &&
        other.hoverFill == hoverFill &&
        other.pressedFill == pressedFill &&
        other.alternatingRowFill == alternatingRowFill;
  }
}
--- FILE: lib/app/theme/app_spacing.dart ---
/// Costanti di spacing configurabili a livello applicativo.
/// Modifica questi valori per cambiare lo spacing in tutta l'app.
abstract class AppSpacing {
  AppSpacing._();
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // General spacing
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Spacing piccolo generico.
  static const double small = 8.0;

  /// Spacing medio generico.
  static const double medium = 12.0;

  /// Spacing grande generico.
  static const double large = 24.0;

  /// Spacing extra large generico.
  static const double xLarge = 60.0;

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Form spacing
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  /// Spacing verticale tra la prima riga dei form e il titolo.
  static const double formFirstRowSpacing = large;

  /// Spacing verticale tra le righe dei form (es. tra data/ora e servizio).
  static const double formRowSpacing = xLarge;

  /// Spacing orizzontale tra i campi sulla stessa riga (es. tra data e ora).
  static const double formFieldSpacing = medium;

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Bottom sheet spacing
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Spacing tra il contenuto del form e i pulsanti azioni.
  static const double formToActionsSpacing = xLarge;

  /// Spacing tra i pulsanti azioni.
  static const double actionButtonSpacing = small;
}
--- FILE: lib/app/theme/theme_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'theme.dart';
import 'theme_config.dart';

/// üîπ Notifier moderno per gestire il tema dinamico
class ThemeNotifier extends Notifier<AppThemeConfig> {
  @override
  AppThemeConfig build() => const AppThemeConfig(
    seedColor: colorPrimary1,
    brightness: Brightness.light,
  );

  /// Cambia il colore principale (seed color)
  void updateSeed(Color color) {
    state = state.copyWith(seedColor: color);
  }

  /// Inverte la modalit√† chiara/scura
  void toggleBrightness() {
    if (state.brightness != Brightness.light) {
      state = state.copyWith(brightness: Brightness.light);
    }
  }
}

/// üîπ Provider globale per il tema (versione Notifier)
final themeNotifierProvider = NotifierProvider<ThemeNotifier, AppThemeConfig>(
  ThemeNotifier.new,
);
--- FILE: lib/app/theme/theme_config.dart ---
import 'package:flutter/material.dart';

class AppThemeConfig {
  final Color seedColor;
  final Brightness brightness;

  const AppThemeConfig({
    required this.seedColor,
    this.brightness = Brightness.dark,
  });

  AppThemeConfig copyWith({Color? seedColor, Brightness? brightness}) {
    return AppThemeConfig(
      seedColor: seedColor ?? this.seedColor,
      brightness: brightness ?? this.brightness,
    );
  }
}
--- FILE: lib/app/theme/theme.dart ---
import 'package:flutter/material.dart';

import 'extensions.dart';
import 'theme_config.dart';

const colorPrimary1 = Color(0xFF141414); // colore base scuro
const colorPrimary2 = Color(0xFFFEFEFE); // colore contrasto chiaro
const _appFontFamily = 'Roboto';
const List<String> _emojiFontFallback = [
  'Apple Color Emoji',
  'Segoe UI Emoji',
  'Segoe UI Symbol',
  'Noto Color Emoji',
  'Noto Emoji',
  'Emoji',
  'sans-serif',
];

TextTheme _withEmojiFallback(TextTheme textTheme) {
  TextStyle? apply(TextStyle? style) =>
      style?.copyWith(fontFamilyFallback: _emojiFontFallback);

  return textTheme.copyWith(
    displayLarge: apply(textTheme.displayLarge),
    displayMedium: apply(textTheme.displayMedium),
    displaySmall: apply(textTheme.displaySmall),
    headlineLarge: apply(textTheme.headlineLarge),
    headlineMedium: apply(textTheme.headlineMedium),
    headlineSmall: apply(textTheme.headlineSmall),
    titleLarge: apply(textTheme.titleLarge),
    titleMedium: apply(textTheme.titleMedium),
    titleSmall: apply(textTheme.titleSmall),
    bodyLarge: apply(textTheme.bodyLarge),
    bodyMedium: apply(textTheme.bodyMedium),
    bodySmall: apply(textTheme.bodySmall),
    labelLarge: apply(textTheme.labelLarge),
    labelMedium: apply(textTheme.labelMedium),
    labelSmall: apply(textTheme.labelSmall),
  );
}

/// Crea un tema coerente partendo dal seed definito in [AppThemeConfig].
ThemeData buildTheme(AppThemeConfig _, Brightness brightness) {
  final isDark = brightness == Brightness.dark;

  //const colorPrimary3 = Color(0xFFE5B24F); // accento caldo

  final background = isDark ? colorPrimary1 : colorPrimary2;
  final surface = background;
  final primary = colorPrimary1;
  final onPrimary = colorPrimary2;
  final onBackground = isDark ? colorPrimary2 : colorPrimary1;

  final colorScheme = ColorScheme(
    brightness: brightness,
    primary: primary,
    onPrimary: onPrimary,
    secondary: primary,
    onSecondary: onPrimary,
    error: Colors.red,
    onError: colorPrimary2,
    background: background,
    onBackground: onBackground,
    surface: surface,
    onSurface: onBackground,
  );

  final base = ThemeData(
    useMaterial3: true,
    colorScheme: colorScheme,
    brightness: brightness,
    scaffoldBackgroundColor: background,
    canvasColor: surface,
    fontFamily: _appFontFamily,
  );

  final titleStyle =
      base.textTheme.titleLarge ??
      const TextStyle(fontSize: 18, fontWeight: FontWeight.w600);

  final hoverFill = isDark
      ? colorPrimary2.withOpacity(0.12)
      : colorPrimary1.withOpacity(0.01);
  final pressedFill = isDark
      ? colorPrimary2.withOpacity(0.18)
      : colorPrimary1.withOpacity(0.1);
  final alternatingRowFill = isDark
      ? colorPrimary2.withOpacity(0.05)
      : colorPrimary1.withOpacity(0.03);

  final themeWithPalette = base.copyWith(
    appBarTheme: AppBarTheme(
      backgroundColor: colorPrimary2,
      foregroundColor: colorPrimary1,
      centerTitle: true,
      surfaceTintColor: Colors.transparent,
      elevation: 0,
      iconTheme: const IconThemeData(color: colorPrimary1),
      titleTextStyle: titleStyle.copyWith(color: colorPrimary1),
    ),
    cardTheme: CardThemeData(
      color: surface,
      surfaceTintColor: Colors.transparent,
      elevation: 0,
      margin: const EdgeInsets.all(8),
      shape: RoundedRectangleBorder(
        borderRadius: const BorderRadius.all(Radius.circular(12)),
        side: BorderSide(color: onBackground.withOpacity(0.1), width: 0.5),
      ),
    ),
    textTheme: _withEmojiFallback(
      base.textTheme.apply(
        bodyColor: onBackground,
        displayColor: onBackground,
        fontFamily: _appFontFamily,
      ),
    ),
    iconTheme: IconThemeData(color: onBackground),
    dividerColor: onBackground.withOpacity(0.12),
    floatingActionButtonTheme: FloatingActionButtonThemeData(
      backgroundColor: primary,
      foregroundColor: onPrimary,
    ),
    navigationRailTheme: NavigationRailThemeData(
      backgroundColor: colorPrimary1,
      selectedIconTheme: const IconThemeData(color: colorPrimary2, size: 32),
      unselectedIconTheme: const IconThemeData(color: colorPrimary2, size: 32),
      selectedLabelTextStyle: const TextStyle(
        color: colorPrimary2,
        fontWeight: FontWeight.w600,
      ),
      unselectedLabelTextStyle: const TextStyle(color: colorPrimary2),
      minWidth: 80,
      indicatorColor: Colors.transparent,
    ),
    bottomNavigationBarTheme: BottomNavigationBarThemeData(
      backgroundColor: colorPrimary1,
      selectedItemColor: colorPrimary2,
      unselectedItemColor: colorPrimary2.withOpacity(0.5),
      selectedIconTheme: const IconThemeData(color: colorPrimary2, size: 26),
      unselectedIconTheme: IconThemeData(color: colorPrimary2.withOpacity(0.5)),
      selectedLabelStyle: const TextStyle(
        fontWeight: FontWeight.w600,
        fontSize: 12,
      ),
      unselectedLabelStyle: const TextStyle(
        fontWeight: FontWeight.w400,
        fontSize: 11,
      ),
      showUnselectedLabels: true,
      type: BottomNavigationBarType.fixed,
    ),
    // Colori ON globali per Switch/Radio in linea con il primary dell'app
    switchTheme: base.switchTheme.copyWith(
      overlayColor: MaterialStateProperty.all(Colors.transparent),
      thumbColor: MaterialStateProperty.resolveWith(
        (states) => states.contains(MaterialState.selected)
            ? colorScheme.primary
            : null,
      ),
      trackColor: MaterialStateProperty.resolveWith(
        (states) => states.contains(MaterialState.selected)
            ? colorScheme.primary.withOpacity(0.35)
            : null,
      ),
    ),
    radioTheme: base.radioTheme.copyWith(
      overlayColor: MaterialStateProperty.all(Colors.transparent),
      fillColor: MaterialStateProperty.resolveWith(
        (states) => states.contains(MaterialState.selected)
            ? colorScheme.primary
            : null,
      ),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        backgroundColor: primary,
        foregroundColor: onPrimary,
        textStyle: const TextStyle(fontWeight: FontWeight.w600),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
      ),
    ),
  );

  return themeWithPalette.copyWith(
    extensions: <ThemeExtension<dynamic>>[
      AppInteractionColors(
        hoverFill: hoverFill,
        pressedFill: pressedFill,
        alternatingRowFill: alternatingRowFill,
      ),
    ],
  );
}
--- FILE: lib/app/router_provider.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../core/l10n/l10_extension.dart';
import '../features/agenda/presentation/agenda_screen.dart';
import '../features/agenda/providers/business_providers.dart';
import '../features/auth/domain/auth_state.dart';
import '../features/auth/presentation/change_password_screen.dart';
import '../features/auth/presentation/login_screen.dart';
import '../features/auth/presentation/profile_screen.dart';
import '../features/auth/presentation/reset_password_screen.dart';
import '../features/auth/providers/auth_provider.dart';
import '../features/auth/providers/current_business_user_provider.dart';
import '../features/booking_notifications/presentation/booking_notifications_screen.dart';
import '../features/bookings_list/presentation/bookings_list_screen.dart';
import '../features/business/presentation/business_list_screen.dart';
import '../features/business/presentation/invitation_accept_screen.dart';
import '../features/business/presentation/location_closures_screen.dart';
import '../features/business/presentation/operators_screen.dart';
import '../features/business/presentation/user_business_switch_screen.dart';
import '../features/business/providers/superadmin_selected_business_provider.dart';
import '../features/class_events/presentation/class_events_screen.dart';
import '../features/clients/presentation/clients_screen.dart';
import '../features/crm/presentation/screens/crm_client_detail_screen.dart';
import '../features/crm/presentation/screens/crm_clients_screen.dart';
import '../features/crm/presentation/screens/crm_home_screen.dart';
import '../features/crm/presentation/screens/crm_import_export_screen.dart';
import '../features/crm/presentation/screens/crm_segments_screen.dart';
import '../features/crm/presentation/screens/crm_tags_screen.dart';
import '../features/crm/presentation/screens/crm_tasks_screen.dart';
import '../features/more/presentation/more_screen.dart';
import '../features/reports/presentation/reports_screen.dart';
import '../features/services/presentation/services_screen.dart';
import '../features/staff/presentation/staff_week_overview_screen.dart';
import '../features/staff/presentation/team_screen.dart';
import 'scaffold_with_navigation.dart';

final _rootNavigatorKey = GlobalKey<NavigatorState>();
final rootNavigatorKeyProvider = Provider<GlobalKey<NavigatorState>>(
  (ref) => _rootNavigatorKey,
);

/// Provider derivato che cambia SOLO quando cambia l'autenticazione effettiva
/// NON quando cambia solo l'errorMessage (evita rebuild inutili del router)
final _routerAuthStateProvider =
    Provider<
      ({bool isAuthenticated, bool isSuperadmin, bool isInitialOrLoading})
    >((ref) {
      final authState = ref.watch(authProvider);
      return (
        isAuthenticated: authState.isAuthenticated,
        isSuperadmin: authState.user?.isSuperadmin ?? false,
        isInitialOrLoading:
            authState.status == AuthStatus.initial ||
            authState.status == AuthStatus.loading,
      );
    });

/// Provider per il router con supporto autenticazione.
final routerProvider = Provider<GoRouter>((ref) {
  // Usa il provider derivato per evitare rebuild quando cambia solo errorMessage
  final authInfo = ref.watch(_routerAuthStateProvider);
  final isAuthenticated = authInfo.isAuthenticated;
  final isSuperadmin = authInfo.isSuperadmin;
  final isInitialOrLoading = authInfo.isInitialOrLoading;

  return GoRouter(
    navigatorKey: _rootNavigatorKey,
    initialLocation: '/login',
    debugLogDiagnostics: kDebugMode,

    // Refresh router quando cambia lo stato auth
    refreshListenable: _AuthNotifier(ref),

    redirect: (context, state) {
      final browserPath = Uri.base.path;
      final isInvitationBrowserUrl =
          browserPath == '/invitation' ||
          browserPath.startsWith('/invitation/');
      final browserLocation = Uri.base.hasQuery
          ? '${Uri.base.path}?${Uri.base.query}'
          : Uri.base.path;

      // Single source of truth for invitation deep-links:
      // if browser URL is /invitation/{token}, keep router locked there.
      if (isInvitationBrowserUrl) {
        final allowLeaveInvitation =
            state.uri.queryParameters['leave_invitation'] == '1';
        if (allowLeaveInvitation) {
          return null;
        }
        final stateLocation = state.uri.hasQuery
            ? '${state.uri.path}?${state.uri.query}'
            : state.uri.path;
        if (stateLocation != browserLocation) {
          return browserLocation;
        }
        return null;
      }

      final isLoggingIn = state.matchedLocation == '/login';
      final isOnBusinessList = state.matchedLocation == '/businesses';
      final isOnUserBusinessSwitch = state.matchedLocation == '/my-businesses';
      final invitationPath = state.uri.path;
      final isInvitationPage =
          invitationPath == '/invitation' ||
          invitationPath.startsWith('/invitation/');
      final canManageClients = ref.read(currentUserCanManageClientsProvider);
      final canViewServices = ref.read(currentUserCanViewServicesProvider);
      final canViewStaff = ref.read(currentUserCanViewStaffProvider);
      final canManageOperators = ref.read(canManageOperatorsProvider);
      final canManageBusinessSettings = ref.read(
        canManageBusinessSettingsProvider,
      );
      final canViewReports = ref.read(currentUserCanViewReportsProvider);
      final canAccessClassEvents = ref.read(currentUserCanViewServicesProvider);
      final currentBusinessId = ref.read(currentBusinessIdProvider);
      final superadminSelectedBusiness = ref.read(
        superadminSelectedBusinessProvider,
      );

      // Durante il caricamento iniziale, non fare redirect
      if (isInitialOrLoading) {
        return null;
      }

      // Pagine pubbliche che non richiedono autenticazione
      final isPublicPage =
          isLoggingIn ||
          state.matchedLocation.startsWith('/reset-password') ||
          isInvitationPage;

      // Se non loggato e non su pagina pubblica, vai al login
      if (!isAuthenticated && !isPublicPage) {
        return '/login';
      }

      // Se loggato e sulla pagina login
      if (isAuthenticated && isLoggingIn) {
        final redirect = state.uri.queryParameters['redirect'];
        if (redirect != null && redirect.startsWith('/')) {
          return redirect;
        }
        // Dopo login: superadmin su lista business admin, utenti normali su selettore personale.
        return isSuperadmin ? '/businesses' : '/my-businesses';
      }

      // Business list admin solo per superadmin.
      if (isAuthenticated && !isSuperadmin && isOnBusinessList) {
        return '/my-businesses';
      }

      // Se superadmin va alla schermata switch user, riporta alla lista admin.
      if (isAuthenticated && isSuperadmin && isOnUserBusinessSwitch) {
        return '/businesses';
      }

      // Per utenti non superadmin:
      // - /my-businesses √® usata in due casi:
      //   1) selezione iniziale (business non ancora selezionato)
      //   2) switch esplicito dal menu (?switch=1)
      // - se esiste gi√† un business corrente e non √® uno switch esplicito,
      //   evita rimbalzi tornando in agenda.
      if (isAuthenticated && !isSuperadmin && isOnUserBusinessSwitch) {
        final isExplicitSwitch = state.uri.queryParameters['switch'] == '1';
        if (!isExplicitSwitch && currentBusinessId > 0) {
          return '/agenda';
        }
      }

      // Se superadmin tenta di accedere all'agenda senza aver selezionato un business
      if (isAuthenticated &&
          isSuperadmin &&
          superadminSelectedBusiness == null &&
          !isInvitationPage &&
          !isOnBusinessList &&
          !isOnUserBusinessSwitch &&
          !isLoggingIn) {
        return '/businesses';
      }

      // Route guard by explicit permissions.
      if (isAuthenticated && !isSuperadmin) {
        final path = state.uri.path;
        if (path == '/clienti' && !canManageClients) return '/agenda';
        if (path.startsWith('/altro/crm')) return '/agenda';
        if (path == '/servizi' && !canViewServices) return '/agenda';
        if (path == '/staff' && !canViewStaff) return '/agenda';
        if (path == '/staff-availability' && !canViewStaff) return '/agenda';
        if (path == '/report' && !canViewReports) return '/agenda';
        if (path == '/chiusure' && !canManageBusinessSettings) return '/agenda';
        if (path == '/altro/classi' && !canAccessClassEvents) return '/agenda';
        if (path == '/permessi' && !canManageOperators) return '/agenda';
        if (path.startsWith('/operatori/') && !canManageOperators) {
          return '/agenda';
        }
      }

      return null;
    },

    errorBuilder: (context, state) => Scaffold(
      appBar: AppBar(title: Text(context.l10n.errorTitle)),
      body: Center(
        child: Text(
          context.l10n.errorNotFound(state.uri.path),
          style: const TextStyle(color: Colors.redAccent),
        ),
      ),
    ),

    routes: [
      // Route login (fuori dalla shell)
      GoRoute(
        path: '/login',
        name: 'login',
        builder: (context, state) =>
            LoginScreen(redirectTo: state.uri.queryParameters['redirect']),
      ),

      GoRoute(
        path: '/invitation/:token',
        name: 'invitation',
        builder: (context, state) {
          final token = state.pathParameters['token']!;
          return InvitationAcceptScreen(token: token);
        },
      ),

      // Route reset password (fuori dalla shell, pubblica)
      GoRoute(
        path: '/reset-password/:token',
        name: 'reset-password',
        builder: (context, state) {
          final token = state.pathParameters['token']!;
          return ResetPasswordScreen(token: token);
        },
      ),

      // Route lista business per superadmin (fuori dalla shell)
      GoRoute(
        path: '/businesses',
        name: 'businesses',
        builder: (context, state) => const BusinessListScreen(),
      ),

      // Route selezione business per utenti non superadmin
      GoRoute(
        path: '/my-businesses',
        name: 'my-businesses',
        builder: (context, state) => const UserBusinessSwitchScreen(),
      ),

      // Shell con navigazione principale
      StatefulShellRoute.indexedStack(
        builder: (context, state, navigationShell) {
          return ScaffoldWithNavigation(navigationShell: navigationShell);
        },
        branches: [
          // --- Ramo 0: Agenda ---
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/agenda',
                name: 'agenda',
                builder: (BuildContext context, GoRouterState state) {
                  final q = state.uri.queryParameters['clientId'];
                  final initialClientId = q == null ? null : int.tryParse(q);
                  return AgendaScreen(initialClientId: initialClientId);
                },
              ),
            ],
          ),

          // --- Ramo 1: Clienti ---
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/clienti',
                name: 'clienti',
                builder: (BuildContext context, GoRouterState state) =>
                    const ClientsScreen(),
              ),
            ],
          ),

          // --- Ramo 2: Servizi ---
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/servizi',
                name: 'servizi',
                builder: (BuildContext context, GoRouterState state) =>
                    const ServicesScreen(),
              ),
            ],
          ),

          // --- Ramo 3: Staff ---
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/staff',
                name: 'staff',
                builder: (BuildContext context, GoRouterState state) =>
                    const TeamScreen(),
              ),
            ],
          ),

          // --- Ramo 4: Report ---
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/report',
                name: 'report',
                builder: (BuildContext context, GoRouterState state) =>
                    const ReportsScreen(),
              ),
            ],
          ),

          // --- Ramo 5: Elenco Prenotazioni ---
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/prenotazioni',
                name: 'prenotazioni',
                builder: (BuildContext context, GoRouterState state) =>
                    const BookingsListScreen(),
              ),
            ],
          ),

          // --- Ramo 6: Altro (schermata con cards) ---
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/altro',
                name: 'altro',
                builder: (BuildContext context, GoRouterState state) =>
                    const MoreScreen(),
                routes: [
                  GoRoute(
                    path: 'classi',
                    name: 'class-events',
                    builder: (BuildContext context, GoRouterState state) =>
                        const ClassEventsScreen(),
                  ),
                  GoRoute(
                    path: 'crm',
                    name: 'crm-home',
                    builder: (BuildContext context, GoRouterState state) =>
                        const CrmHomeScreen(),
                    routes: [
                      GoRoute(
                        path: 'clienti',
                        name: 'crm-clienti',
                        builder: (BuildContext context, GoRouterState state) =>
                            const CrmClientsScreen(),
                      ),
                      GoRoute(
                        path: 'clienti/:clientId',
                        name: 'crm-cliente-dettaglio',
                        builder: (BuildContext context, GoRouterState state) {
                          final clientId = int.tryParse(
                            state.pathParameters['clientId'] ?? '',
                          );
                          return CrmClientDetailScreen(clientId: clientId ?? 0);
                        },
                      ),
                      GoRoute(
                        path: 'segmenti',
                        name: 'crm-segmenti',
                        builder: (BuildContext context, GoRouterState state) =>
                            const CrmSegmentsScreen(),
                      ),
                      GoRoute(
                        path: 'task',
                        name: 'crm-task',
                        builder: (BuildContext context, GoRouterState state) =>
                            const CrmTasksScreen(),
                      ),
                      GoRoute(
                        path: 'tag',
                        name: 'crm-tag',
                        builder: (BuildContext context, GoRouterState state) =>
                            const CrmTagsScreen(),
                      ),
                      GoRoute(
                        path: 'import-export',
                        name: 'crm-import-export',
                        builder: (BuildContext context, GoRouterState state) =>
                            const CrmImportExportScreen(),
                      ),
                    ],
                  ),
                ],
              ),
            ],
          ),

          // --- Ramo 7: Chiusure ---
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/chiusure',
                name: 'chiusure',
                builder: (BuildContext context, GoRouterState state) =>
                    const LocationClosuresScreen(),
              ),
            ],
          ),

          // --- Ramo 8: Profilo ---
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/profilo',
                name: 'profilo',
                builder: (BuildContext context, GoRouterState state) =>
                    const ProfileScreen(),
              ),
            ],
          ),

          // --- Ramo 9: Permessi ---
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/permessi',
                name: 'permessi',
                builder: (BuildContext context, GoRouterState state) =>
                    const OperatorsScreen(),
              ),
            ],
          ),

          // --- Ramo 10: Notifiche Prenotazioni ---
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/notifiche-prenotazioni',
                name: 'notifiche-prenotazioni',
                builder: (BuildContext context, GoRouterState state) =>
                    const BookingNotificationsScreen(),
              ),
            ],
          ),
        ],
      ),

      // Route esterne alla shell
      GoRoute(
        path: '/staff-availability',
        name: 'staff-availability',
        parentNavigatorKey: _rootNavigatorKey,
        builder: (BuildContext context, GoRouterState state) =>
            const StaffWeekOverviewScreen(),
      ),

      // Route cambio password
      GoRoute(
        path: '/change-password',
        name: 'change-password',
        parentNavigatorKey: _rootNavigatorKey,
        builder: (BuildContext context, GoRouterState state) =>
            const ChangePasswordScreen(),
      ),

      // Route operatori business
      GoRoute(
        path: '/operatori/:businessId',
        name: 'operatori',
        parentNavigatorKey: _rootNavigatorKey,
        builder: (BuildContext context, GoRouterState state) {
          final businessId = int.parse(state.pathParameters['businessId']!);
          return OperatorsScreen(businessId: businessId);
        },
      ),
    ],
  );
});

/// Notifier per aggiornare il router quando cambia l'auth state.
class _AuthNotifier extends ChangeNotifier {
  _AuthNotifier(this._ref) {
    _ref.listen(authProvider, (previous, next) {
      // Se l'utente si disconnette, resetta la selezione business del superadmin
      if (previous?.isAuthenticated == true && !next.isAuthenticated) {
        _ref.read(superadminSelectedBusinessProvider.notifier).clear();
        invalidateBusinessScopedProviders(_ref);
      }
      notifyListeners();
    });
  }

  final Ref _ref;
}
--- FILE: lib/app/app.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/l10n/l10_extension.dart';
import '/core/l10n/l10n.dart';
import '../core/widgets/layout_config_auto_listener.dart';
import '../core/widgets/session_expired_listener.dart';
import 'router_provider.dart';
import 'theme/theme.dart';
import 'theme/theme_provider.dart';

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeConfig = ref.watch(themeNotifierProvider);
    final router = ref.watch(routerProvider);
    return MaterialApp.router(
      debugShowCheckedModeBanner: false,
      title: 'Agenda Platform',
      routerConfig: router,
      themeMode: ThemeMode.light,
      theme: buildTheme(themeConfig, Brightness.light),
      localizationsDelegates: const [
        L10n.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: L10n.delegate.supportedLocales,
      locale: const Locale('it'),

      // 2. SPOSTA IL LISTENER QUI
      builder: (context, child) {
        final localizedTitle = context.l10n.appTitle;
        return Title(
          title: localizedTitle,
          color: Theme.of(context).scaffoldBackgroundColor,
          // Questo widget ora aggiorner√† i provider globali
          // prima che qualsiasi schermata venga costruita.
          child: SessionExpiredListener(
            child: LayoutConfigAutoListener(
              child: child ?? const SizedBox.shrink(),
            ),
          ),
        );
      },
    );
  }
}
--- FILE: lib/app/widgets/business_selector.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../core/models/business.dart';
import '../../core/utils/initials_utils.dart';
import '../../features/agenda/providers/business_providers.dart';
import '../../features/business/providers/superadmin_selected_business_provider.dart';
import '../../features/auth/providers/auth_provider.dart';

/// Selettore business per superadmin.
/// Mostra nel leading della NavigationRail.
class BusinessSelector extends ConsumerWidget {
  const BusinessSelector({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authProvider);
    final isSuperadmin = authState.user?.isSuperadmin ?? false;

    // Solo superadmin vede il selettore
    if (!isSuperadmin) return const SizedBox.shrink();

    final businessesAsync = ref.watch(businessesProvider);
    final currentBusinessId = ref.watch(currentBusinessIdProvider);

    return businessesAsync.when(
      data: (businesses) => _BusinessDropdown(
        businesses: businesses,
        currentBusinessId: currentBusinessId,
        onChanged: (id) {
          ref.read(currentBusinessIdProvider.notifier).selectByUser(id);
          ref.read(superadminSelectedBusinessProvider.notifier).select(id);
        },
      ),
      loading: () => const Padding(
        padding: EdgeInsets.all(12),
        child: SizedBox(
          width: 24,
          height: 24,
          child: CircularProgressIndicator(strokeWidth: 2),
        ),
      ),
      error: (_, __) => const SizedBox.shrink(),
    );
  }
}

class _BusinessDropdown extends StatelessWidget {
  const _BusinessDropdown({
    required this.businesses,
    required this.currentBusinessId,
    required this.onChanged,
  });

  final List<Business> businesses;
  final int currentBusinessId;
  final void Function(int) onChanged;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    if (businesses.isEmpty) {
      return const SizedBox.shrink();
    }

    final currentBusiness = businesses.firstWhere(
      (b) => b.id == currentBusinessId,
      orElse: () => businesses.first,
    );
    final currentBusinessInitial = InitialsUtils.fromName(
      currentBusiness.name,
      maxChars: 1,
    );

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 12),
      child: PopupMenuButton<int>(
        offset: const Offset(56, 0),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        tooltip: 'Seleziona business',
        onSelected: onChanged,
        itemBuilder: (context) => businesses.map((b) {
          final isSelected = b.id == currentBusinessId;
          final businessInitial = InitialsUtils.fromName(b.name, maxChars: 1);
          return PopupMenuItem<int>(
            value: b.id,
            child: Row(
              children: [
                CircleAvatar(
                  radius: 14,
                  backgroundColor: isSelected
                      ? colorScheme.primaryContainer
                      : colorScheme.surfaceContainerHighest,
                  child: Text(
                    businessInitial.isNotEmpty ? businessInitial : '?',
                    style: TextStyle(
                      fontSize: 12,
                      fontWeight: FontWeight.w600,
                      color: isSelected
                          ? colorScheme.onPrimaryContainer
                          : colorScheme.onSurfaceVariant,
                    ),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                    b.name,
                    style: TextStyle(
                      fontWeight: isSelected
                          ? FontWeight.w600
                          : FontWeight.normal,
                    ),
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                if (isSelected)
                  Icon(Icons.check, size: 18, color: colorScheme.primary),
              ],
            ),
          );
        }).toList(),
        child: Container(
          width: 40,
          height: 40,
          decoration: BoxDecoration(
            color: colorScheme.primaryContainer,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Center(
            child: Text(
              currentBusinessInitial.isNotEmpty ? currentBusinessInitial : '?',
              style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.w700,
                color: colorScheme.onPrimaryContainer,
              ),
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/app/widgets/agenda_staff_filter_selector.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/extensions.dart';
import 'package:agenda_backend/app/widgets/agenda_control_components.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/staff.dart';
import 'package:agenda_backend/core/widgets/app_dividers.dart';
import 'package:agenda_backend/core/widgets/desktop_popup_container.dart';
import 'package:agenda_backend/features/agenda/domain/staff_filter_mode.dart';
import 'package:agenda_backend/features/agenda/providers/staff_filter_providers.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Selector per filtrare lo staff visualizzato nell'agenda.
/// [isCompact] = true: solo icona (mobile/tablet)
/// [isCompact] = false: pill con icona + label + freccia (desktop)
class AgendaStaffFilterSelector extends ConsumerStatefulWidget {
  const AgendaStaffFilterSelector({
    super.key,
    this.isCompact = true,
    this.compactBuilder,
  });

  final bool isCompact;
  final Widget Function(
    BuildContext context,
    VoidCallback onPressed,
    String tooltip,
  )?
  compactBuilder;

  @override
  ConsumerState<AgendaStaffFilterSelector> createState() =>
      _AgendaStaffFilterSelectorState();
}

class _AgendaStaffFilterSelectorState
    extends ConsumerState<AgendaStaffFilterSelector> {
  bool _isHovered = false;
  final LayerLink _layerLink = LayerLink();
  OverlayEntry? _overlayEntry;
  bool _isOpen = false;

  @override
  void dispose() {
    _removeOverlay();
    super.dispose();
  }

  void _removeOverlay() {
    _overlayEntry?.remove();
    _overlayEntry = null;
    if (_isOpen) {
      _isOpen = false;
      setState(() => _isHovered = false);
    }
  }

  void _handleTap() {
    final formFactor = ref.read(formFactorProvider);

    if (formFactor == AppFormFactor.desktop) {
      _showDesktopPopup();
    } else {
      _showMobileSheet(context);
    }
  }

  void _showDesktopPopup() {
    if (_overlayEntry != null) {
      _removeOverlay();
      return;
    }

    setState(() => _isHovered = true);
    _isOpen = true;

    final renderBox = context.findRenderObject() as RenderBox;
    final triggerSize = renderBox.size;

    _overlayEntry = OverlayEntry(
      builder: (overlayContext) => DesktopPopupContainer(
        link: _layerLink,
        triggerWidth: triggerSize.width,
        triggerHeight: triggerSize.height,
        popupWidth: 280,
        maxHeight: 400,
        onDismiss: _removeOverlay,
        child: _StaffFilterPopupContent(onDismiss: _removeOverlay),
      ),
    );

    Overlay.of(context).insert(_overlayEntry!);
  }

  Future<void> _showMobileSheet(BuildContext context) async {
    setState(() => _isHovered = true);
    await showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      useRootNavigator: true,
      builder: (_) => const _StaffFilterSheet(),
    );
    setState(() => _isHovered = false);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final formFactor = ref.watch(formFactorProvider);
    if (widget.isCompact) {
      Future<void> onPressed() => _showMobileSheet(context);
      if (widget.compactBuilder != null) {
        return widget.compactBuilder!(
          context,
          onPressed,
          l10n.staffFilterTooltip,
        );
      }
      return IconButton(
        tooltip: l10n.staffFilterTooltip,
        icon: const Icon(Icons.badge_outlined),
        iconSize: formFactor == AppFormFactor.mobile ? 22 : 33,
        onPressed: onPressed,
      );
    }

    // Desktop mode: pill style like AgendaLocationSelector
    final colorScheme = Theme.of(context).colorScheme;
    final interactions = Theme.of(context).extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = _isHovered
        ? Color.alphaBlend(hoverFill, colorScheme.surface)
        : colorScheme.surface;

    final mode = ref.watch(staffFilterModeProvider);
    final label = _getModeLabel(l10n, mode);

    return CompositedTransformTarget(
      link: _layerLink,
      child: MouseRegion(
        onEnter: (_) {
          if (!_isHovered && !_isOpen) setState(() => _isHovered = true);
        },
        onExit: (_) {
          if (_isHovered && !_isOpen) setState(() => _isHovered = false);
        },
        child: GestureDetector(
          onTap: _handleTap,
          child: Semantics(
            button: true,
            label: l10n.staffFilterTooltip,
            child: ClipRRect(
              borderRadius: kAgendaPillRadius,
              child: Container(
                height: kAgendaControlHeight,
                decoration: BoxDecoration(
                  borderRadius: kAgendaPillRadius,
                  border: Border.all(color: Colors.grey.withOpacity(0.35)),
                  color: backgroundColor,
                ),
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: kAgendaControlHorizontalPadding,
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Flexible(
                        child: Text(label, overflow: TextOverflow.ellipsis),
                      ),
                      const SizedBox(width: 8),
                      const Icon(Icons.keyboard_arrow_down_rounded, size: 20),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  String _getModeLabel(dynamic l10n, StaffFilterMode mode) {
    switch (mode) {
      case StaffFilterMode.allTeam:
        return l10n.staffFilterAllTeam;
      case StaffFilterMode.onDutyTeam:
        return l10n.staffFilterOnDuty;
      case StaffFilterMode.custom:
        final selectedIds = ref.read(selectedStaffIdsProvider);
        final count = selectedIds.length;
        if (count == 0) return l10n.staffFilterAllTeam;
        return '$count';
    }
  }
}

/// Content widget for the staff filter desktop popup.
class _StaffFilterPopupContent extends ConsumerWidget {
  const _StaffFilterPopupContent({required this.onDismiss});

  final VoidCallback onDismiss;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final mode = ref.watch(staffFilterModeProvider);
    final allStaff = ref.watch(staffForCurrentLocationProvider);
    final selectedIds = ref.watch(selectedStaffIdsProvider);
    final onDutyIds = ref.watch(onDutyStaffIdsProvider);

    return SingleChildScrollView(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Padding(
            padding: const EdgeInsets.fromLTRB(12, 10, 12, 6),
            child: Text(
              l10n.staffFilterTitle,
              style: theme.textTheme.labelMedium?.copyWith(
                color: colorScheme.onSurfaceVariant,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          const AppDivider(),

          // Opzione: Tutto il team
          _DesktopFilterOptionTile(
            title: l10n.staffFilterAllTeam,
            isSelected: mode == StaffFilterMode.allTeam,
            onTap: () {
              ref
                  .read(staffFilterModeProvider.notifier)
                  .set(StaffFilterMode.allTeam);
              onDismiss();
            },
          ),

          // Opzione: Team di turno
          _DesktopFilterOptionTile(
            title: l10n.staffFilterOnDuty,
            isSelected: mode == StaffFilterMode.onDutyTeam,
            onTap: () {
              ref
                  .read(staffFilterModeProvider.notifier)
                  .set(StaffFilterMode.onDutyTeam);
              onDismiss();
            },
          ),

          // Divider
          const AppDivider(),

          // Header staff
          Padding(
            padding: const EdgeInsets.fromLTRB(12, 8, 12, 4),
            child: Text(
              l10n.staffFilterSelectMembers,
              style: theme.textTheme.bodySmall?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
          ),

          // Lista staff con checkbox
          for (final staff in allStaff)
            _DesktopStaffMemberTile(
              staff: staff,
              isSelected: _isStaffSelected(
                mode,
                selectedIds,
                onDutyIds,
                staff.id,
              ),
              onChanged: (selected) {
                if (mode != StaffFilterMode.custom) {
                  final ids = mode == StaffFilterMode.onDutyTeam
                      ? onDutyIds.toList()
                      : allStaff.map((s) => s.id).toList();
                  ref.read(selectedStaffIdsProvider.notifier).setFromList(ids);
                  ref
                      .read(staffFilterModeProvider.notifier)
                      .set(StaffFilterMode.custom);
                }
                ref.read(selectedStaffIdsProvider.notifier).toggle(staff.id);
              },
            ),

          const SizedBox(height: 8),
        ],
      ),
    );
  }

  bool _isStaffSelected(
    StaffFilterMode mode,
    Set<int> selectedIds,
    Set<int> onDutyIds,
    int staffId,
  ) {
    switch (mode) {
      case StaffFilterMode.allTeam:
        return true;
      case StaffFilterMode.onDutyTeam:
        return onDutyIds.contains(staffId);
      case StaffFilterMode.custom:
        return selectedIds.contains(staffId);
    }
  }
}

class _DesktopFilterOptionTile extends StatefulWidget {
  const _DesktopFilterOptionTile({
    required this.title,
    required this.isSelected,
    required this.onTap,
  });

  final String title;
  final bool isSelected;
  final VoidCallback onTap;

  @override
  State<_DesktopFilterOptionTile> createState() =>
      _DesktopFilterOptionTileState();
}

class _DesktopFilterOptionTileState extends State<_DesktopFilterOptionTile> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      cursor: SystemMouseCursors.click,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: widget.onTap,
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 100),
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
          color: widget.isSelected
              ? colorScheme.primary.withOpacity(0.08)
              : _isHovered
              ? colorScheme.primary.withOpacity(0.04)
              : Colors.transparent,
          child: Row(
            children: [
              Icon(
                widget.isSelected
                    ? Icons.radio_button_checked
                    : Icons.radio_button_unchecked,
                color: widget.isSelected ? colorScheme.primary : null,
                size: 20,
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  widget.title,
                  style: TextStyle(
                    fontWeight: widget.isSelected
                        ? FontWeight.w600
                        : FontWeight.normal,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _DesktopStaffMemberTile extends StatefulWidget {
  const _DesktopStaffMemberTile({
    required this.staff,
    required this.isSelected,
    required this.onChanged,
  });

  final Staff staff;
  final bool isSelected;
  final ValueChanged<bool> onChanged;

  @override
  State<_DesktopStaffMemberTile> createState() =>
      _DesktopStaffMemberTileState();
}

class _DesktopStaffMemberTileState extends State<_DesktopStaffMemberTile> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      cursor: SystemMouseCursors.click,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: () => widget.onChanged(!widget.isSelected),
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 100),
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
          color: _isHovered
              ? colorScheme.primary.withOpacity(0.04)
              : Colors.transparent,
          child: Row(
            children: [
              StaffCircleAvatar(
                height: 28,
                color: widget.staff.color,
                isHighlighted: widget.isSelected,
                initials: widget.staff.initials,
              ),
              const SizedBox(width: 12),
              Expanded(child: Text(widget.staff.displayName)),
              Checkbox(
                value: widget.isSelected,
                onChanged: (value) => widget.onChanged(value ?? false),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// Mobile/tablet bottom sheet for staff filter.
class _StaffFilterSheet extends ConsumerWidget {
  const _StaffFilterSheet();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final mode = ref.watch(staffFilterModeProvider);
    final allStaff = ref.watch(staffForCurrentLocationProvider);
    final selectedIds = ref.watch(selectedStaffIdsProvider);
    final onDutyIds = ref.watch(onDutyStaffIdsProvider);

    return SafeArea(
      child: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Handle
            const SizedBox(height: 8),
            Center(
              child: Container(
                width: 40,
                height: 4,
                decoration: BoxDecoration(
                  color: Colors.grey.shade300,
                  borderRadius: BorderRadius.circular(4),
                ),
              ),
            ),
            const SizedBox(height: 12),

            // Header
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 8, 16, 8),
              child: Text(
                l10n.staffFilterTitle,
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
            const AppDivider(),

            // Opzione: Tutto il team
            _MobileFilterOptionTile(
              title: l10n.staffFilterAllTeam,
              isSelected: mode == StaffFilterMode.allTeam,
              onTap: () {
                ref
                    .read(staffFilterModeProvider.notifier)
                    .set(StaffFilterMode.allTeam);
                Navigator.of(context).pop();
              },
            ),

            // Opzione: Team di turno
            _MobileFilterOptionTile(
              title: l10n.staffFilterOnDuty,
              isSelected: mode == StaffFilterMode.onDutyTeam,
              onTap: () {
                ref
                    .read(staffFilterModeProvider.notifier)
                    .set(StaffFilterMode.onDutyTeam);
                Navigator.of(context).pop();
              },
            ),

            // Divider
            const AppDivider(),

            // Header staff
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 12, 16, 4),
              child: Text(
                l10n.staffFilterSelectMembers,
                style: theme.textTheme.bodySmall?.copyWith(
                  color: theme.colorScheme.onSurfaceVariant,
                ),
              ),
            ),

            // Lista staff con checkbox
            for (final staff in allStaff)
              _MobileStaffMemberTile(
                staff: staff,
                isSelected: _isStaffSelected(
                  mode,
                  selectedIds,
                  onDutyIds,
                  staff.id,
                ),
                onChanged: (selected) {
                  if (mode != StaffFilterMode.custom) {
                    final ids = mode == StaffFilterMode.onDutyTeam
                        ? onDutyIds.toList()
                        : allStaff.map((s) => s.id).toList();
                    ref
                        .read(selectedStaffIdsProvider.notifier)
                        .setFromList(ids);
                    ref
                        .read(staffFilterModeProvider.notifier)
                        .set(StaffFilterMode.custom);
                  }
                  ref.read(selectedStaffIdsProvider.notifier).toggle(staff.id);
                },
              ),

            const SizedBox(height: 16),
          ],
        ),
      ),
    );
  }

  bool _isStaffSelected(
    StaffFilterMode mode,
    Set<int> selectedIds,
    Set<int> onDutyIds,
    int staffId,
  ) {
    switch (mode) {
      case StaffFilterMode.allTeam:
        return true;
      case StaffFilterMode.onDutyTeam:
        return onDutyIds.contains(staffId);
      case StaffFilterMode.custom:
        return selectedIds.contains(staffId);
    }
  }
}

class _MobileFilterOptionTile extends StatelessWidget {
  const _MobileFilterOptionTile({
    required this.title,
    required this.isSelected,
    required this.onTap,
  });

  final String title;
  final bool isSelected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return ListTile(
      title: Text(title),
      leading: Icon(
        isSelected ? Icons.radio_button_checked : Icons.radio_button_unchecked,
        color: isSelected ? theme.colorScheme.primary : null,
      ),
      onTap: onTap,
    );
  }
}

class _MobileStaffMemberTile extends StatelessWidget {
  const _MobileStaffMemberTile({
    required this.staff,
    required this.isSelected,
    required this.onChanged,
  });

  final Staff staff;
  final bool isSelected;
  final ValueChanged<bool> onChanged;

  @override
  Widget build(BuildContext context) {
    return ListTile(
      leading: StaffCircleAvatar(
        height: 32,
        color: staff.color,
        isHighlighted: isSelected,
        initials: staff.initials,
      ),
      title: Text(staff.displayName),
      trailing: Checkbox(
        value: isSelected,
        onChanged: (value) => onChanged(value ?? false),
      ),
      onTap: () => onChanged(!isSelected),
    );
  }
}
--- FILE: lib/app/widgets/user_menu_button.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../core/l10n/l10_extension.dart';
import '../../core/models/user.dart';
import '../../core/utils/app_version.dart';
import '../../features/auth/providers/auth_provider.dart';

/// Avatar utente riutilizzabile.
class UserAvatar extends StatelessWidget {
  const UserAvatar({super.key, required this.user, this.radius = 16});

  final User user;
  final double radius;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    return CircleAvatar(
      radius: radius,
      backgroundColor: colorScheme.primaryContainer,
      child: Text(
        user.initials,
        style: TextStyle(
          fontSize: radius * 0.75,
          fontWeight: FontWeight.w600,
          color: colorScheme.onPrimaryContainer,
        ),
      ),
    );
  }
}

/// Widget per mostrare il menu utente nell'AppBar.
/// Mostra avatar con iniziali e menu con logout.
class UserMenuButton extends ConsumerWidget {
  const UserMenuButton({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authProvider);
    final user = authState.user;

    if (user == null) return const SizedBox.shrink();

    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return PopupMenuButton<String>(
      offset: const Offset(0, 48),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 8),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            UserAvatar(user: user, radius: 16),
            const SizedBox(width: 8),
            Icon(Icons.arrow_drop_down, color: colorScheme.onSurfaceVariant),
          ],
        ),
      ),
      itemBuilder: (context) =>
          buildMenuItems(context, theme, colorScheme, user),
      onSelected: (value) {
        if (value == 'logout') {
          handleLogout(context, ref);
        } else if (value == 'profile') {
          context.push('/profilo');
        } else if (value == 'change_password') {
          context.push('/change-password');
        }
      },
    );
  }

  static List<PopupMenuEntry<String>> buildMenuItems(
    BuildContext context,
    ThemeData theme,
    ColorScheme colorScheme,
    User user,
  ) {
    return [
      PopupMenuItem<String>(
        enabled: false,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              user.fullName,
              style: theme.textTheme.titleSmall?.copyWith(
                fontWeight: FontWeight.w600,
              ),
            ),
            const SizedBox(height: 2),
            Text(
              user.email,
              style: theme.textTheme.bodySmall?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
            if (user.isSuperadmin) ...[
              const SizedBox(height: 4),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: colorScheme.tertiaryContainer,
                  borderRadius: BorderRadius.circular(4),
                ),
                child: Text(
                  'Superadmin',
                  style: TextStyle(
                    fontSize: 10,
                    fontWeight: FontWeight.w600,
                    color: colorScheme.onTertiaryContainer,
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
      const PopupMenuDivider(),
      // Cambia password
      PopupMenuItem<String>(
        value: 'change_password',
        child: Row(
          children: [
            Icon(Icons.lock_outline, size: 20, color: colorScheme.primary),
            const SizedBox(width: 12),
            const Text('Cambia password'),
          ],
        ),
      ),
      PopupMenuItem<String>(
        value: 'logout',
        child: Row(
          children: [
            Icon(Icons.logout, size: 20, color: colorScheme.error),
            const SizedBox(width: 12),
            Text(
              context.l10n.authLogout,
              style: TextStyle(color: colorScheme.error),
            ),
          ],
        ),
      ),
      const PopupMenuDivider(),
      // Versione app
      PopupMenuItem<String>(
        enabled: false,
        height: 32,
        child: Text(
          'v${getAppVersion()}',
          style: theme.textTheme.bodySmall?.copyWith(
            color: colorScheme.onSurfaceVariant.withValues(alpha: 0.6),
            fontSize: 11,
          ),
        ),
      ),
    ];
  }

  static void handleLogout(BuildContext context, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(context.l10n.authLogout),
        content: const Text('Vuoi uscire dal gestionale?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text(context.l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () {
              Navigator.of(context).pop();
              // NON pulisce le preferenze: l'ultimo business viene ricordato
              ref.read(authProvider.notifier).logout();
            },
            child: Text(context.l10n.authLogout),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/app/widgets/top_controls.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/widgets/agenda_control_components.dart';
import 'package:agenda_backend/app/widgets/agenda_staff_filter_selector.dart';
import 'package:agenda_backend/app/widgets/top_controls_scaffold.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/location.dart';
import 'package:agenda_backend/core/widgets/app_dividers.dart';
import 'package:agenda_backend/core/widgets/no_scrollbar_behavior.dart';
import 'package:agenda_backend/features/agenda/providers/layout_config_provider.dart';
import 'package:agenda_backend/features/auth/providers/current_business_user_provider.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

enum TopControlsMode { agenda, staff }

class TopControls extends ConsumerWidget {
  const TopControls.agenda({super.key, this.compact = false})
    : mode = TopControlsMode.agenda,
      todayLabel = null,
      labelOverride = null;

  const TopControls.staff({
    super.key,
    this.todayLabel,
    this.labelOverride,
    this.compact = false,
  }) : mode = TopControlsMode.staff;

  final TopControlsMode mode;

  final bool compact;
  final String? todayLabel;
  final String? labelOverride;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final formFactor = ref.watch(formFactorProvider);

    return TopControlsScaffold(
      applyLayoutInset: formFactor == AppFormFactor.desktop,
      builder: TopControlsBuilder.adaptive(
        mobile: (context, data) => _buildMobile(context, data, ref),
        tablet: (context, data) => _buildTablet(context, data, ref),
        desktop: (context, data) => _buildDesktop(context, data, ref),
      ),
    );
  }

  Widget _buildMobile(
    BuildContext context,
    TopControlsData data,
    WidgetRef ref,
  ) {
    // Su mobile per agenda, il date picker √® in basso (come tablet)
    // In agenda mobile i filtri (staff/location) sono in AppBar actions.
    // Qui non mostriamo la combo location a sinistra per evitare duplicati.
    if (mode == TopControlsMode.agenda) {
      return const SizedBox.shrink();
    }

    // Per staff, mostra il date switcher settimanale
    final weekMeta = _resolveWeekMeta(data);
    final label = weekMeta.label;
    final selectedDate = weekMeta.effectivePickerDate;

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        AgendaDateSwitcher(
          label: label,
          selectedDate: selectedDate,
          onPrevious: null,
          onNext: null,
          onPreviousWeek: data.dateController.previousWeek,
          onNextWeek: data.dateController.nextWeek,
          onPreviousMonth: null,
          onNextMonth: null,
          onSelectDate: (date) {
            data.dateController.set(DateUtils.dateOnly(date));
          },
          useWeekRangePicker: true,
          isCompact: compact,
        ),
        const SizedBox(width: 8),
        if (data.locations.length > 1) ...[
          const SizedBox(width: 16),
          Align(
            alignment: AlignmentDirectional.centerStart,
            child: AgendaLocationSelector(
              locations: data.locations,
              current: data.currentLocation,
              onSelected: (locationId) {
                data.locationController.set(locationId);
                if (mode == TopControlsMode.staff) {
                  ref
                      .read(staffSectionLocationIdProvider.notifier)
                      .set(locationId);
                }
              },
              iconOnly: true,
            ),
          ),
        ],
      ],
    );
  }

  Widget _buildTablet(
    BuildContext context,
    TopControlsData data,
    WidgetRef ref,
  ) {
    _StaffWeekMeta? weekMeta;
    String label;
    DateTime selectedDate;
    if (mode == TopControlsMode.agenda) {
      label = _formatSingleDate(data);
      selectedDate = data.agendaDate;
    } else {
      weekMeta = _resolveWeekMeta(data);
      label = weekMeta.label;
      selectedDate = weekMeta.effectivePickerDate;
    }
    final showTopDateSwitcher =
        mode != TopControlsMode.agenda &&
        !(mode == TopControlsMode.staff &&
            data.formFactor == AppFormFactor.mobile);

    final layoutConfig = ref.watch(layoutConfigProvider);

    return Row(
      mainAxisSize: MainAxisSize.max,
      children: [
        if (showTopDateSwitcher) ...[
          Flexible(
            child: AgendaDateSwitcher(
              label: label,
              selectedDate: selectedDate,
              onPreviousWeek: mode == TopControlsMode.staff
                  ? data.dateController.previousWeek
                  : null,
              onNextWeek: mode == TopControlsMode.staff
                  ? data.dateController.nextWeek
                  : null,
              onSelectDate: (date) {
                data.dateController.set(DateUtils.dateOnly(date));
              },
              useWeekRangePicker: mode == TopControlsMode.staff,
              isCompact: compact,
            ),
          ),
        ],
        if (mode == TopControlsMode.agenda)
          SizedBox(width: layoutConfig.hourColumnWidth),
        // Il selettore staff √® mostrato solo se l'utente pu√≤ vedere tutti gli appuntamenti
        // e se ci sono pi√π membri staff nella location
        if (mode == TopControlsMode.agenda &&
            ref.watch(canViewAllAppointmentsProvider) &&
            ref.watch(staffForCurrentLocationProvider).length > 1) ...[
          const Align(
            alignment: AlignmentDirectional.centerStart,
            child: AgendaStaffFilterSelector(isCompact: false),
          ),
        ],
        if (data.locations.length > 1) ...[
          const SizedBox(width: 16),
          Align(
            alignment: AlignmentDirectional.centerStart,
            child: AgendaLocationSelector(
              locations: data.locations,
              current: data.currentLocation,
              onSelected: (locationId) {
                data.locationController.set(locationId);
                if (mode == TopControlsMode.staff) {
                  ref
                      .read(staffSectionLocationIdProvider.notifier)
                      .set(locationId);
                }
              },
            ),
          ),
        ],
      ],
    );
  }

  Widget _buildDesktop(
    BuildContext context,
    TopControlsData data,
    WidgetRef ref,
  ) {
    _StaffWeekMeta? weekMeta;
    String label;
    DateTime selectedDate;
    if (mode == TopControlsMode.agenda) {
      label = _formatSingleDate(data);
      selectedDate = data.agendaDate;
    } else {
      weekMeta = _resolveWeekMeta(data);
      label = weekMeta.label;
      selectedDate = weekMeta.effectivePickerDate;
    }
    final showStaffSelector =
        mode == TopControlsMode.agenda &&
        ref.watch(canViewAllAppointmentsProvider) &&
        ref.watch(staffForCurrentLocationProvider).length > 1;
    final showLocationSelector = data.locations.length > 1;

    List<Widget> buildChildren({required bool allowFlex}) {
      return [
        if (allowFlex)
          Flexible(
            child: AgendaDateSwitcher(
              label: label,
              selectedDate: selectedDate,
              onPrevious: mode == TopControlsMode.agenda
                  ? data.dateController.previousDay
                  : null,
              onNext: mode == TopControlsMode.agenda
                  ? data.dateController.nextDay
                  : null,
              onPreviousWeek:
                  mode == TopControlsMode.agenda ||
                      mode == TopControlsMode.staff
                  ? data.dateController.previousWeek
                  : null,
              onNextWeek:
                  mode == TopControlsMode.agenda ||
                      mode == TopControlsMode.staff
                  ? data.dateController.nextWeek
                  : null,
              onPreviousMonth: mode == TopControlsMode.agenda
                  ? data.dateController.previousMonth
                  : null,
              onNextMonth: mode == TopControlsMode.agenda
                  ? data.dateController.nextMonth
                  : null,
              onSelectDate: (date) {
                data.dateController.set(DateUtils.dateOnly(date));
              },
              useWeekRangePicker: mode == TopControlsMode.staff,
            ),
          )
        else
          AgendaDateSwitcher(
            label: label,
            selectedDate: selectedDate,
            onPrevious: mode == TopControlsMode.agenda
                ? data.dateController.previousDay
                : null,
            onNext: mode == TopControlsMode.agenda
                ? data.dateController.nextDay
                : null,
            onPreviousWeek:
                mode == TopControlsMode.agenda || mode == TopControlsMode.staff
                ? data.dateController.previousWeek
                : null,
            onNextWeek:
                mode == TopControlsMode.agenda || mode == TopControlsMode.staff
                ? data.dateController.nextWeek
                : null,
            onPreviousMonth: mode == TopControlsMode.agenda
                ? data.dateController.previousMonth
                : null,
            onNextMonth: mode == TopControlsMode.agenda
                ? data.dateController.nextMonth
                : null,
            onSelectDate: (date) {
              data.dateController.set(DateUtils.dateOnly(date));
            },
            useWeekRangePicker: mode == TopControlsMode.staff,
          ),
        if (showStaffSelector) const SizedBox(width: 16),
        if (showStaffSelector)
          const Align(
            alignment: AlignmentDirectional.centerStart,
            child: AgendaStaffFilterSelector(isCompact: false),
          ),
        if (showLocationSelector) ...[
          const SizedBox(width: 16),
          if (mode == TopControlsMode.staff)
            Align(
              alignment: AlignmentDirectional.centerStart,
              child: StaffLocationSelector(
                locations: data.locations,
                currentLocationId: ref.watch(staffSectionLocationIdProvider),
                onSelected: ref
                    .read(staffSectionLocationIdProvider.notifier)
                    .set,
              ),
            )
          else
            Align(
              alignment: AlignmentDirectional.centerStart,
              child: AgendaLocationSelector(
                locations: data.locations,
                current: data.currentLocation,
                onSelected: data.locationController.set,
              ),
            ),
        ],
      ];
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        final useScrollFallback =
            constraints.hasBoundedWidth && constraints.maxWidth < 420;
        if (useScrollFallback) {
          return ScrollConfiguration(
            behavior: const NoScrollbarBehavior(),
            child: SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: buildChildren(allowFlex: false),
              ),
            ),
          );
        }
        return Row(children: buildChildren(allowFlex: true));
      },
    );
  }

  String _formatSingleDate(TopControlsData data) {
    final localeTag = data.locale.toLanguageTag();
    return DateFormat('EEE d MMM', localeTag).format(data.agendaDate);
  }

  _StaffWeekMeta _resolveWeekMeta(TopControlsData data) {
    final agendaDate = data.agendaDate;
    final locale = Intl.canonicalizedLocale(data.locale.toString());

    String buildWeekRangeLabel(DateTime start, DateTime end, String localeTag) {
      final sameYear = start.year == end.year;
      final sameMonth = sameYear && start.month == end.month;
      if (sameMonth) {
        final d1 = DateFormat('d', localeTag).format(start);
        final d2m = DateFormat('d MMM', localeTag).format(end);
        return '$d1‚Äì$d2m';
      }
      if (sameYear) {
        final s = DateFormat('d MMM', localeTag).format(start);
        final e = DateFormat('d MMM', localeTag).format(end);
        return '$s ‚Äì $e';
      }
      final s = DateFormat('d MMM y', localeTag).format(start);
      final e = DateFormat('d MMM y', localeTag).format(end);
      return '$s ‚Äì $e';
    }

    final deltaToMonday = (agendaDate.weekday - DateTime.monday) % 7;
    final pickerInitialDate = DateUtils.dateOnly(
      agendaDate.subtract(Duration(days: deltaToMonday)),
    );
    final todayDate = DateUtils.dateOnly(DateTime.now());
    final weekStart = pickerInitialDate;
    final weekEnd = weekStart.add(const Duration(days: 6));
    final defaultLabel = buildWeekRangeLabel(weekStart, weekEnd, locale);
    final formattedDate = labelOverride ?? defaultLabel;
    final isTodayInWeek =
        !todayDate.isBefore(weekStart) && !todayDate.isAfter(weekEnd);
    final effectivePickerDate = isTodayInWeek ? todayDate : weekEnd;

    return _StaffWeekMeta(
      label: formattedDate,
      effectivePickerDate: effectivePickerDate,
    );
  }
}

class _StaffWeekMeta {
  const _StaffWeekMeta({
    required this.label,
    required this.effectivePickerDate,
  });

  final String label;
  final DateTime effectivePickerDate;
}

/// Content widget for the location bottom sheet, consistent with other dropdowns.
class LocationSheetContent extends StatelessWidget {
  const LocationSheetContent({
    super.key,
    required this.locations,
    required this.currentLocationId,
    required this.title,
    required this.onSelected,
    this.showAllLocationsOption = false,
    this.allLocationsLabel,
  });

  final List<Location> locations;
  final int?
  currentLocationId; // null = "Tutte le sedi" se showAllLocationsOption
  final String title;
  final ValueChanged<int?> onSelected;
  final bool showAllLocationsOption;
  final String? allLocationsLabel;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    final maxHeight = MediaQuery.of(context).size.height * 0.8;
    final itemCount = locations.length + (showAllLocationsOption ? 1 : 0);

    return ConstrainedBox(
      constraints: BoxConstraints(maxHeight: maxHeight),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 16, 16, 12),
            child: Text(
              title,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          const AppDivider(),
          Expanded(
            child: ListView.builder(
              itemCount: itemCount,
              itemBuilder: (ctx, index) {
                // Prima voce: "Tutte le sedi" se abilitato
                if (showAllLocationsOption && index == 0) {
                  final isSelected = currentLocationId == null;
                  return InkWell(
                    onTap: () => onSelected(null),
                    splashColor: Colors.transparent,
                    highlightColor: Colors.transparent,
                    child: Container(
                      padding: const EdgeInsets.symmetric(
                        vertical: 14,
                        horizontal: 16,
                      ),
                      color: isSelected
                          ? colorScheme.primary.withOpacity(0.08)
                          : Colors.transparent,
                      child: Row(
                        children: [
                          Expanded(
                            child: Text(
                              allLocationsLabel ?? context.l10n.allLocations,
                              style: TextStyle(
                                color: colorScheme.onSurface,
                                fontWeight: isSelected
                                    ? FontWeight.w600
                                    : FontWeight.normal,
                              ),
                            ),
                          ),
                          if (isSelected)
                            Icon(
                              Icons.check,
                              size: 20,
                              color: colorScheme.primary,
                            ),
                        ],
                      ),
                    ),
                  );
                }

                final locationIndex = showAllLocationsOption
                    ? index - 1
                    : index;
                final loc = locations[locationIndex];
                final isSelected = loc.id == currentLocationId;
                return InkWell(
                  onTap: () => onSelected(loc.id),
                  splashColor: Colors.transparent,
                  highlightColor: Colors.transparent,
                  child: Container(
                    padding: const EdgeInsets.symmetric(
                      vertical: 14,
                      horizontal: 16,
                    ),
                    color: isSelected
                        ? colorScheme.primary.withOpacity(0.08)
                        : Colors.transparent,
                    child: Row(
                      children: [
                        Expanded(
                          child: Text(
                            loc.name,
                            style: TextStyle(
                              color: colorScheme.onSurface,
                              fontWeight: isSelected
                                  ? FontWeight.w600
                                  : FontWeight.normal,
                            ),
                          ),
                        ),
                        if (isSelected)
                          Icon(
                            Icons.check,
                            size: 20,
                            color: colorScheme.primary,
                          ),
                      ],
                    ),
                  ),
                );
              },
            ),
          ),
          SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
        ],
      ),
    );
  }
}
--- FILE: lib/app/widgets/agenda_control_components.dart ---
import 'package:agenda_backend/app/theme/extensions.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/location.dart';
import 'package:agenda_backend/core/widgets/adaptive_dropdown.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

const double kAgendaControlHeight = 40;
const double kAgendaControlHorizontalPadding = 20;
const double kAgendaMinDateLabelWidth = 120;
const BorderRadius kAgendaPillRadius = BorderRadius.all(Radius.circular(999));
const double kAgendaDividerWidth = 1;

class AgendaRoundedButton extends StatelessWidget {
  const AgendaRoundedButton({super.key, required this.label, this.onTap});

  final String label;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final interactions = Theme.of(context).extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final pressedFill =
        interactions?.pressedFill ?? colorScheme.primary.withOpacity(0.1);
    final disabledFill = colorScheme.surface.withOpacity(0.6);
    final disabledForeground = colorScheme.onSurface.withOpacity(0.38);
    final enabledText = colorScheme.onSurface;
    final disabledBorder = colorScheme.onSurface.withOpacity(0.12);
    final enabledBorder = Colors.grey.withOpacity(0.35);

    return SizedBox(
      height: kAgendaControlHeight,
      child: OutlinedButton(
        style:
            OutlinedButton.styleFrom(
              shape: const RoundedRectangleBorder(
                borderRadius: kAgendaPillRadius,
              ),
              padding: const EdgeInsets.symmetric(
                horizontal: kAgendaControlHorizontalPadding,
              ),
              side: BorderSide(color: enabledBorder),
            ).copyWith(
              backgroundColor: MaterialStateProperty.resolveWith((states) {
                if (states.contains(MaterialState.disabled)) {
                  return disabledFill;
                }
                if (states.contains(MaterialState.pressed)) return pressedFill;
                if (states.contains(MaterialState.hovered)) return hoverFill;
                return colorScheme.surface;
              }),
              foregroundColor: MaterialStateProperty.resolveWith((states) {
                if (states.contains(MaterialState.disabled)) {
                  return disabledForeground;
                }
                return enabledText;
              }),
              overlayColor: MaterialStateProperty.all(Colors.transparent),
              elevation: MaterialStateProperty.resolveWith(
                (states) =>
                    states.contains(MaterialState.hovered) &&
                        !states.contains(MaterialState.disabled)
                    ? 6
                    : 0,
              ),
              shadowColor: MaterialStateProperty.all(
                Colors.black.withOpacity(0.08),
              ),
              side: MaterialStateProperty.resolveWith(
                (states) => BorderSide(
                  color: states.contains(MaterialState.disabled)
                      ? disabledBorder
                      : enabledBorder,
                ),
              ),
            ),
        onPressed: onTap,
        child: Text(label),
      ),
    );
  }
}

class AgendaDateSwitcher extends StatefulWidget {
  const AgendaDateSwitcher({
    super.key,
    required this.label,
    required this.selectedDate,
    this.useWeekRangePicker = false,
    this.isCompact = false,
    this.onPrevious,
    this.onPreviousWeek,
    this.onNext,
    this.onNextWeek,
    this.onPreviousMonth,
    this.onNextMonth,
    required this.onSelectDate,
  });

  final String label;
  final DateTime selectedDate;
  // When true, tapping the label opens a DateRangePicker pre-filled with the
  // week (Mon-Sun) containing selectedDate, and normalizes user choice to that week.
  final bool useWeekRangePicker;

  /// Variante compatta: disegna solo il bottone testo+icona senza frecce laterali.
  final bool isCompact;
  final VoidCallback? onPrevious;
  final VoidCallback? onPreviousWeek;
  final VoidCallback? onNext;
  final VoidCallback? onNextWeek;
  final VoidCallback? onPreviousMonth;
  final VoidCallback? onNextMonth;
  final ValueChanged<DateTime> onSelectDate;

  @override
  State<AgendaDateSwitcher> createState() => _AgendaDateSwitcherState();
}

class _AgendaDateSwitcherState extends State<AgendaDateSwitcher> {
  Future<void> _handleTap(BuildContext context) async {
    final initialDate = widget.selectedDate;
    final firstDate = DateTime(initialDate.year - 3);
    final lastDate = DateTime(initialDate.year + 3);

    if (widget.useWeekRangePicker) {
      // Custom lightweight week picker: tap qualsiasi giorno -> settimana Mon-Dom
      final selectedMonday = await _showWeekPickerDialog(
        context: context,
        anchor: initialDate,
        firstDate: firstDate,
        lastDate: lastDate,
      );
      if (selectedMonday != null &&
          !DateUtils.isSameDay(selectedMonday, widget.selectedDate)) {
        widget.onSelectDate(selectedMonday);
      }
      return;
    }

    // Default single-date dialog
    final picked = await showGeneralDialog<DateTime>(
      context: context,
      barrierDismissible: true,
      barrierColor: Colors.black.withOpacity(0.12),
      barrierLabel: MaterialLocalizations.of(context).modalBarrierDismissLabel,
      transitionDuration: const Duration(milliseconds: 180),
      transitionBuilder: (context, animation, secondaryAnimation, child) {
        final curved = CurvedAnimation(
          parent: animation,
          curve: Curves.easeOut,
        );
        return FadeTransition(
          opacity: curved,
          child: ScaleTransition(
            scale: Tween<double>(begin: 0.96, end: 1).animate(curved),
            child: child,
          ),
        );
      },
      pageBuilder: (dialogContext, _, __) {
        final theme = Theme.of(dialogContext);
        final localizations = MaterialLocalizations.of(dialogContext);
        final borderColor = theme.dividerColor.withOpacity(0.24);
        final baseHeadline =
            theme.datePickerTheme.headerHeadlineStyle ??
            theme.textTheme.titleLarge ??
            const TextStyle(fontSize: 18);
        final datePickerTheme = theme.datePickerTheme.copyWith(
          headerHeadlineStyle: baseHeadline.copyWith(
            fontWeight: FontWeight.w700,
          ),
        );

        return Center(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
            child: Material(
              elevation: 12,
              color: theme.colorScheme.surface,
              borderRadius: const BorderRadius.all(Radius.circular(12)),
              child: ConstrainedBox(
                constraints: const BoxConstraints(minWidth: 280, maxWidth: 360),
                child: DecoratedBox(
                  decoration: BoxDecoration(
                    borderRadius: const BorderRadius.all(Radius.circular(12)),
                    border: Border.all(color: borderColor, width: 1),
                  ),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Theme(
                        data: theme.copyWith(datePickerTheme: datePickerTheme),
                        child: CalendarDatePicker(
                          initialDate: initialDate,
                          firstDate: firstDate,
                          lastDate: lastDate,
                          onDateChanged: (selected) {
                            Navigator.of(
                              dialogContext,
                            ).pop(DateUtils.dateOnly(selected));
                          },
                        ),
                      ),
                      Align(
                        alignment: Alignment.centerRight,
                        child: Padding(
                          padding: const EdgeInsets.fromLTRB(0, 0, 8, 8),
                          child: TextButton(
                            onPressed: () => Navigator.of(dialogContext).pop(),
                            child: Text(localizations.cancelButtonLabel),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        );
      },
    );

    if (picked != null && !DateUtils.isSameDay(picked, widget.selectedDate)) {
      widget.onSelectDate(picked);
    }
  }

  @override
  Widget build(BuildContext context) {
    /*if (widget.isCompact) {
      return _CompactDateSwitcher(
        label: widget.label,
        onTap: () => _handleTap(context),
      );
    }*/
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    final interactions = Theme.of(context).extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = colorScheme.surface;
    final l10n = context.l10n;
    final borderColor = Colors.grey.withOpacity(0.35);

    const double dividerWidth = kAgendaDividerWidth;
    final double arrowExtent = kAgendaControlHeight;
    final double navIconSize = arrowExtent <= 32 ? 16.0 : 18.0;
    const BorderRadius leftRadius = BorderRadius.only(
      topLeft: Radius.circular(999),
      bottomLeft: Radius.circular(999),
    );
    const BorderRadius rightRadius = BorderRadius.only(
      topRight: Radius.circular(999),
      bottomRight: Radius.circular(999),
    );

    return Container(
      height: kAgendaControlHeight,
      decoration: BoxDecoration(
        borderRadius: kAgendaPillRadius,
        border: Border.all(color: borderColor),
        color: backgroundColor,
      ),
      child: LayoutBuilder(
        builder: (context, constraints) {
          final maxWidth = constraints.maxWidth;
          const compactBreakpoint = 330.0;
          final compactByBreakpoint =
              maxWidth.isFinite && maxWidth > 0 && maxWidth < compactBreakpoint;
          double horizontalPadding = compactByBreakpoint
              ? 12.0
              : kAgendaControlHorizontalPadding;
          final labelSemantics = MaterialLocalizations.of(
            context,
          ).datePickerHelpText;

          Widget buildDivider(VoidCallback onTap) => GestureDetector(
            behavior: HitTestBehavior.opaque,
            onTap: onTap,
            child: SizedBox(
              width: dividerWidth,
              height: kAgendaControlHeight,
              child: DecoratedBox(
                decoration: BoxDecoration(color: borderColor.withOpacity(0.5)),
              ),
            ),
          );

          Widget buildStaticDivider() => SizedBox(
            width: dividerWidth,
            height: kAgendaControlHeight,
            child: DecoratedBox(
              decoration: BoxDecoration(color: borderColor.withOpacity(0.5)),
            ),
          );

          Widget buildArrowButton(
            _NavButtonSpec spec,
            BorderRadius borderRadius,
          ) {
            return _HoverableRegion(
              onTap: spec.onTap,
              semanticsLabel: spec.semanticsLabel,
              hoverColor: hoverFill,
              width: arrowExtent,
              borderRadius: borderRadius,
              child: Center(
                child: spec.iconWidget ?? Icon(spec.icon, size: navIconSize),
              ),
            );
          }

          Widget buildLabelRegion() => _HoverableRegion(
            onTap: () => _handleTap(context),
            semanticsLabel: labelSemantics,
            hoverColor: hoverFill,
            minWidth: kAgendaMinDateLabelWidth,
            padding: EdgeInsets.symmetric(horizontal: horizontalPadding),
            child: Align(
              alignment: Alignment.center,
              child: Text(
                widget.label,
                style: textTheme.titleMedium,
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
          );

          List<Widget> buildNavButtons(
            List<_NavButtonSpec> specs, {
            BorderRadius? firstRadius,
            BorderRadius? lastRadius,
          }) {
            final widgets = <Widget>[];
            for (var i = 0; i < specs.length; i++) {
              if (i > 0) {
                widgets.add(buildStaticDivider());
              }
              final spec = specs[i];
              BorderRadius buttonRadius = BorderRadius.zero;
              if (i == 0 && firstRadius != null) {
                buttonRadius = firstRadius;
              }
              if (i == specs.length - 1 && lastRadius != null) {
                buttonRadius = lastRadius;
              }
              widgets.add(buildArrowButton(spec, buttonRadius));
            }
            return widgets;
          }

          final leadingSpecs = <_NavButtonSpec>[];
          if (widget.onPreviousMonth != null) {
            leadingSpecs.add(
              _NavButtonSpec(
                iconWidget: widget.onPrevious != null
                    ? _TripleArrowIcons(
                        icon: Icons.keyboard_arrow_left,
                        iconSize: navIconSize,
                        width: arrowExtent,
                      )
                    : null,

                icon: widget.onPrevious == null
                    ? Icons.keyboard_double_arrow_left
                    : null,
                onTap: widget.onPreviousMonth!,
                semanticsLabel: l10n.agendaPrevMonth,
              ),
            );
          }
          if (widget.onPreviousWeek != null) {
            leadingSpecs.add(
              _NavButtonSpec(
                icon: widget.onPrevious != null
                    ? Icons.keyboard_double_arrow_left
                    : Icons.keyboard_arrow_left,
                onTap: widget.onPreviousWeek!,
                semanticsLabel: l10n.agendaPrevWeek,
              ),
            );
          }
          if (widget.onPrevious != null) {
            leadingSpecs.add(
              _NavButtonSpec(
                icon: Icons.keyboard_arrow_left,
                onTap: widget.onPrevious ?? () {},
                semanticsLabel: l10n.agendaPrevDay,
              ),
            );
          }

          final trailingSpecs = <_NavButtonSpec>[];
          if (widget.onNext != null) {
            trailingSpecs.add(
              _NavButtonSpec(
                icon: Icons.keyboard_arrow_right,
                onTap: widget.onNext ?? () {},
                semanticsLabel: l10n.agendaNextDay,
              ),
            );
          }
          if (widget.onNextWeek != null) {
            trailingSpecs.add(
              _NavButtonSpec(
                icon: widget.onNext != null
                    ? Icons.keyboard_double_arrow_right
                    : Icons.keyboard_arrow_right,
                onTap: widget.onNextWeek!,
                semanticsLabel: l10n.agendaNextWeek,
              ),
            );
          }
          if (widget.onNextMonth != null) {
            trailingSpecs.add(
              _NavButtonSpec(
                iconWidget: widget.onNext != null
                    ? _TripleArrowIcons(
                        icon: Icons.keyboard_arrow_right,
                        iconSize: navIconSize,
                        width: arrowExtent,
                      )
                    : null,
                icon: widget.onNext == null
                    ? Icons.keyboard_double_arrow_right
                    : null,
                onTap: widget.onNextMonth!,
                semanticsLabel: l10n.agendaNextMonth,
              ),
            );
          }

          final leadingInternalDividers = leadingSpecs.length > 1
              ? leadingSpecs.length - 1
              : 0;
          final trailingInternalDividers = trailingSpecs.length > 1
              ? trailingSpecs.length - 1
              : 0;
          final nonCompactMinWidth =
              (leadingSpecs.length * arrowExtent) +
              (leadingInternalDividers * dividerWidth) +
              dividerWidth +
              kAgendaMinDateLabelWidth +
              dividerWidth +
              (trailingSpecs.length * arrowExtent) +
              (trailingInternalDividers * dividerWidth);
          final isCompact =
              compactByBreakpoint ||
              (maxWidth.isFinite && maxWidth > 0 && maxWidth < nonCompactMinWidth);
          horizontalPadding = isCompact ? 12.0 : kAgendaControlHorizontalPadding;

          final labelRegion = buildLabelRegion();
          final children = <Widget>[
            ...buildNavButtons(
              leadingSpecs,
              firstRadius: leadingSpecs.isNotEmpty ? leftRadius : null,
            ),
            buildDivider(() => _handleTap(context)),
          ];

          if (isCompact) {
            children.add(Expanded(child: labelRegion));
          } else {
            children.add(labelRegion);
          }

          children.addAll([
            buildDivider(() => _handleTap(context)),
            ...buildNavButtons(
              trailingSpecs,
              lastRadius: trailingSpecs.isNotEmpty ? rightRadius : null,
            ),
          ]);

          return Row(
            mainAxisSize: isCompact ? MainAxisSize.max : MainAxisSize.min,
            children: children,
          );
        },
      ),
    );
  }
}

/// Shows a simple dialog with a month grid. Selecting any day returns the Monday
/// of that week. Month navigation supported. Highlights the whole week.
Future<DateTime?> _showWeekPickerDialog({
  required BuildContext context,
  required DateTime anchor,
  required DateTime firstDate,
  required DateTime lastDate,
}) async {
  return showGeneralDialog<DateTime>(
    context: context,
    barrierDismissible: true,
    barrierColor: Colors.black.withOpacity(0.12),
    barrierLabel: MaterialLocalizations.of(context).modalBarrierDismissLabel,
    transitionDuration: const Duration(milliseconds: 180),
    transitionBuilder: (context, animation, secondary, child) {
      final curved = CurvedAnimation(parent: animation, curve: Curves.easeOut);
      return FadeTransition(
        opacity: curved,
        child: ScaleTransition(
          scale: Tween<double>(begin: 0.96, end: 1).animate(curved),
          child: child,
        ),
      );
    },
    pageBuilder: (dialogContext, _, __) {
      return _WeekPickerContent(
        anchor: anchor,
        firstDate: firstDate,
        lastDate: lastDate,
      );
    },
  );
}

class _WeekPickerContent extends StatefulWidget {
  const _WeekPickerContent({
    required this.anchor,
    required this.firstDate,
    required this.lastDate,
  });
  final DateTime anchor;
  final DateTime firstDate;
  final DateTime lastDate;

  @override
  State<_WeekPickerContent> createState() => _WeekPickerContentState();
}

class _NavButtonSpec {
  const _NavButtonSpec({
    this.icon,
    this.iconWidget,
    required this.onTap,
    required this.semanticsLabel,
  }) : assert(icon != null || iconWidget != null);

  final IconData? icon;
  final Widget? iconWidget;
  final VoidCallback onTap;
  final String semanticsLabel;
}

class _TripleArrowIcons extends StatelessWidget {
  const _TripleArrowIcons({
    required this.icon,
    required this.iconSize,
    required this.width,
  });

  final IconData icon;
  final double iconSize;
  final double width;

  @override
  Widget build(BuildContext context) {
    final color = Theme.of(context).iconTheme.color;
    return SizedBox(
      width: width,
      height: iconSize,
      child: Stack(
        clipBehavior: Clip.none,
        children: List.generate(3, (index) {
          final spacing = iconSize * 0.3;
          return Positioned(
            left: (width - iconSize) / 2 + (index - 1) * spacing,
            child: Icon(icon, size: iconSize, color: color),
          );
        }),
      ),
    );
  }
}

class _WeekPickerContentState extends State<_WeekPickerContent> {
  late DateTime _focusedMonth; // first day of focused month
  DateTime? _hoverDay;
  late DateTime _selectedMonday;

  @override
  void initState() {
    super.initState();
    _focusedMonth = DateTime(widget.anchor.year, widget.anchor.month, 1);
    _selectedMonday = _mondayOf(widget.anchor);
  }

  DateTime _mondayOf(DateTime d) =>
      d.subtract(Duration(days: d.weekday - DateTime.monday));

  bool _inSameWeek(DateTime day, DateTime monday) {
    final diff = day.difference(monday).inDays;
    return diff >= 0 && diff < 7;
  }

  void _changeMonth(int delta) {
    setState(() {
      _focusedMonth = DateTime(
        _focusedMonth.year,
        _focusedMonth.month + delta,
        1,
      );
    });
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final locale = Localizations.localeOf(context).toString();
    final monthLabel = DateFormat('MMMM y', locale).format(_focusedMonth);
    final localizations = MaterialLocalizations.of(context);
    final firstGridDay = _mondayOf(_focusedMonth);
    // 6 weeks grid
    final days = List.generate(42, (i) => firstGridDay.add(Duration(days: i)));
    final hoveredWeekMonday = _hoverDay != null ? _mondayOf(_hoverDay!) : null;

    Color weekBg(bool inSelected, bool inHovered) {
      final base = theme.colorScheme.primary;
      if (inSelected) return base.withOpacity(0.18);
      if (inHovered) return base.withOpacity(0.10);
      return Colors.transparent;
    }

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Material(
          elevation: 12,
          color: theme.colorScheme.surface,
          borderRadius: const BorderRadius.all(Radius.circular(12)),
          child: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 320, maxWidth: 360),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                // Header
                Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  child: Row(
                    children: [
                      IconButton(
                        tooltip: localizations.previousMonthTooltip,
                        onPressed: () => _changeMonth(-1),
                        icon: const Icon(Icons.chevron_left),
                      ),
                      Expanded(
                        child: Center(
                          child: Text(
                            monthLabel,
                            style: theme.textTheme.titleMedium?.copyWith(
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ),
                      ),
                      IconButton(
                        tooltip: localizations.nextMonthTooltip,
                        onPressed: () => _changeMonth(1),
                        icon: const Icon(Icons.chevron_right),
                      ),
                    ],
                  ),
                ),
                const Divider(height: 1),
                // Weekday headers (Mon-Sun)
                Padding(
                  padding: const EdgeInsets.only(top: 8, left: 8, right: 8),
                  child: Row(
                    children: [
                      // Use MaterialLocalizations (shortWeekdays) starting from Monday.
                      // MaterialLocalizations non espone shortWeekdays; generiamo abbreviazioni
                      // localizzate usando DateFormat('E'). Partiamo dal luned√¨.
                      for (int i = 0; i < 7; i++)
                        Expanded(
                          child: Center(
                            child: Text(
                              DateFormat('E', locale).format(
                                _mondayOf(_focusedMonth).add(Duration(days: i)),
                              ),
                              style: theme.textTheme.labelSmall?.copyWith(
                                fontWeight: FontWeight.w600,
                              ),
                            ),
                          ),
                        ),
                      // end weekday headers
                    ],
                  ),
                ),
                const SizedBox(height: 4),
                // Grid
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 8),
                  child: Column(
                    children: [
                      for (int w = 0; w < 6; w++) ...[
                        Row(
                          children: [
                            for (int d = 0; d < 7; d++) ...[
                              Builder(
                                builder: (context) {
                                  final day = days[w * 7 + d];
                                  // final mondayOfDay = _mondayOf(day); // not needed after normalization on tap
                                  final inSelectedWeek = _inSameWeek(
                                    day,
                                    _selectedMonday,
                                  );
                                  final inHoveredWeek =
                                      hoveredWeekMonday != null &&
                                      _inSameWeek(day, hoveredWeekMonday);
                                  final isOutOfRange =
                                      day.isBefore(widget.firstDate) ||
                                      day.isAfter(widget.lastDate);
                                  final isCurrentMonth =
                                      day.month == _focusedMonth.month;

                                  return Expanded(
                                    child: GestureDetector(
                                      onTap: isOutOfRange
                                          ? null
                                          : () {
                                              final newMonday = _mondayOf(day);
                                              Navigator.of(context).pop(
                                                DateUtils.dateOnly(newMonday),
                                              );
                                            },
                                      child: MouseRegion(
                                        onEnter: (_) =>
                                            setState(() => _hoverDay = day),
                                        onExit: (_) =>
                                            setState(() => _hoverDay = null),
                                        child: AnimatedContainer(
                                          duration: const Duration(
                                            milliseconds: 120,
                                          ),
                                          margin: const EdgeInsets.symmetric(
                                            vertical: 2,
                                            horizontal: 2,
                                          ),
                                          decoration: BoxDecoration(
                                            color: weekBg(
                                              inSelectedWeek,
                                              inHoveredWeek,
                                            ),
                                            borderRadius: BorderRadius.circular(
                                              8,
                                            ),
                                          ),
                                          height: 40,
                                          alignment: Alignment.center,
                                          child: Text(
                                            '${day.day}',
                                            style: theme.textTheme.bodySmall
                                                ?.copyWith(
                                                  fontWeight: FontWeight.w500,
                                                  color: isOutOfRange
                                                      ? theme.disabledColor
                                                      : (isCurrentMonth
                                                            ? theme
                                                                  .colorScheme
                                                                  .onSurface
                                                            : theme
                                                                  .colorScheme
                                                                  .onSurface
                                                                  .withOpacity(
                                                                    0.45,
                                                                  )),
                                                ),
                                          ),
                                        ),
                                      ),
                                    ),
                                  );
                                },
                              ),
                            ],
                          ],
                        ),
                      ],
                    ],
                  ),
                ),
                const SizedBox(height: 8),
                Padding(
                  padding: const EdgeInsets.fromLTRB(12, 0, 12, 12),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      TextButton(
                        onPressed: () => Navigator.of(context).pop(),
                        child: Text(localizations.cancelButtonLabel),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class _HoverableRegion extends StatefulWidget {
  const _HoverableRegion({
    required this.onTap,
    required this.semanticsLabel,
    required this.hoverColor,
    required this.child,
    this.width,
    this.minWidth,
    this.padding,
    this.borderRadius = BorderRadius.zero,
  });

  final VoidCallback onTap;
  final String semanticsLabel;
  final Color hoverColor;
  final Widget child;
  final double? width;
  final double? minWidth;
  final EdgeInsetsGeometry? padding;
  final BorderRadius borderRadius;

  @override
  State<_HoverableRegion> createState() => _HoverableRegionState();
}

class _HoverableRegionState extends State<_HoverableRegion> {
  bool _hovered = false;

  @override
  Widget build(BuildContext context) {
    final constraints = widget.minWidth != null
        ? BoxConstraints(minWidth: widget.minWidth!)
        : const BoxConstraints();

    Widget content = widget.child;
    if (widget.padding != null) {
      content = Padding(padding: widget.padding!, child: content);
    }

    return Semantics(
      button: true,
      label: widget.semanticsLabel,
      child: MouseRegion(
        cursor: SystemMouseCursors.click,
        onEnter: (_) => setState(() => _hovered = true),
        onExit: (_) => setState(() => _hovered = false),
        child: GestureDetector(
          behavior: HitTestBehavior.opaque,
          onTap: widget.onTap,
          child: ClipRRect(
            borderRadius: widget.borderRadius,
            child: AnimatedContainer(
              duration: const Duration(milliseconds: 120),
              curve: Curves.easeOut,
              width: widget.width,
              constraints: constraints,
              height: kAgendaControlHeight,
              color: _hovered ? widget.hoverColor : Colors.transparent,
              child: content,
            ),
          ),
        ),
      ),
    );
  }
}

/// Versione compact del date switcher con stile pill.
class _CompactDateSwitcher extends StatefulWidget {
  const _CompactDateSwitcher({required this.label, required this.onTap});

  final String label;
  final VoidCallback onTap;

  @override
  State<_CompactDateSwitcher> createState() => _CompactDateSwitcherState();
}

class _CompactDateSwitcherState extends State<_CompactDateSwitcher> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final interactions = Theme.of(context).extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = _isHovered
        ? Color.alphaBlend(hoverFill, colorScheme.surface)
        : colorScheme.surface;

    return InkWell(
      onHover: (hovering) {
        if (hovering != _isHovered) {
          setState(() => _isHovered = hovering);
        }
      },
      onTap: widget.onTap,
      highlightColor: Colors.transparent,
      borderRadius: kAgendaPillRadius,
      child: ClipRRect(
        borderRadius: kAgendaPillRadius,
        child: Container(
          height: kAgendaControlHeight,
          decoration: BoxDecoration(
            borderRadius: kAgendaPillRadius,
            border: Border.all(color: Colors.grey.withOpacity(0.35)),
            color: backgroundColor,
          ),
          child: Padding(
            padding: const EdgeInsets.symmetric(
              horizontal: kAgendaControlHorizontalPadding,
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  Icons.calendar_today_outlined,
                  size: 18,
                  color: colorScheme.onSurface,
                ),
                const SizedBox(width: 8),
                Flexible(
                  child: Text(widget.label, overflow: TextOverflow.ellipsis),
                ),
                const SizedBox(width: 8),
                const Icon(Icons.keyboard_arrow_down_rounded, size: 20),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class AgendaLocationSelector extends ConsumerStatefulWidget {
  const AgendaLocationSelector({
    super.key,
    required this.locations,
    required this.current,
    required this.onSelected,
    this.iconOnly = false,
  });

  final List<Location> locations;
  final Location current;
  final void Function(int id) onSelected;
  final bool iconOnly;

  @override
  ConsumerState<AgendaLocationSelector> createState() =>
      _AgendaLocationSelectorState();
}

class _AgendaLocationSelectorState
    extends ConsumerState<AgendaLocationSelector> {
  static const double _fixedWidth = 200;
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final interactions = Theme.of(context).extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = _isHovered
        ? Color.alphaBlend(hoverFill, colorScheme.surface)
        : colorScheme.surface;
    final l10n = context.l10n;

    return AdaptiveDropdown<int>(
      items: [
        for (final location in widget.locations)
          AdaptiveDropdownItem<int>(
            value: location.id,
            child: Text(location.name),
          ),
      ],
      selectedValue: widget.current.id,
      onSelected: widget.onSelected,
      modalTitle: l10n.agendaSelectLocation,
      popupWidth: 200,
      useRootNavigator: true,
      onOpened: () => setState(() => _isHovered = true),
      onClosed: () => setState(() => _isHovered = false),
      child: MouseRegion(
        onEnter: (_) {
          if (!_isHovered) setState(() => _isHovered = true);
        },
        onExit: (_) {
          if (_isHovered) setState(() => _isHovered = false);
        },
        child: Semantics(
          button: true,
          label: l10n.agendaSelectLocation,
          child: widget.iconOnly
              ? Tooltip(
                  message: l10n.agendaSelectLocation,
                  child: Container(
                    height: kAgendaControlHeight,
                    width: kAgendaControlHeight,
                    alignment: Alignment.center,
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(
                        kAgendaControlHeight / 2,
                      ),
                      color: backgroundColor,
                    ),
                    child: Icon(
                      Icons.place_outlined,
                      size: 30,
                      color: colorScheme.onSurfaceVariant,
                    ),
                  ),
                )
              : ClipRRect(
                  borderRadius: kAgendaPillRadius,
                  child: SizedBox(
                    width: _fixedWidth,
                    child: Container(
                      height: kAgendaControlHeight,
                      decoration: BoxDecoration(
                        borderRadius: kAgendaPillRadius,
                        border: Border.all(color: Colors.grey.withOpacity(0.35)),
                        color: backgroundColor,
                      ),
                      child: Padding(
                        padding: const EdgeInsets.symmetric(
                          horizontal: kAgendaControlHorizontalPadding,
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Expanded(
                              child: Text(
                                widget.current.name,
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                            const SizedBox(width: 8),
                            const Icon(
                              Icons.keyboard_arrow_down_rounded,
                              size: 20,
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),
                ),
        ),
      ),
    );
  }
}

/// Selettore di location per la sezione Staff.
/// Include l'opzione "Tutte le sedi" come valore di default (null).
class StaffLocationSelector extends ConsumerStatefulWidget {
  const StaffLocationSelector({
    super.key,
    required this.locations,
    required this.currentLocationId,
    required this.onSelected,
  });

  final List<Location> locations;
  final int? currentLocationId; // null = "Tutte le sedi"
  final void Function(int? id) onSelected;

  @override
  ConsumerState<StaffLocationSelector> createState() =>
      _StaffLocationSelectorState();
}

class _StaffLocationSelectorState extends ConsumerState<StaffLocationSelector> {
  static const double _fixedWidth = 200;
  bool _isHovered = false;

  String _getDisplayName(BuildContext context) {
    if (widget.currentLocationId == null) {
      return context.l10n.allLocations;
    }
    final location = widget.locations.firstWhere(
      (l) => l.id == widget.currentLocationId,
      orElse: () => widget.locations.first,
    );
    return location.name;
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final interactions = Theme.of(context).extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = _isHovered
        ? Color.alphaBlend(hoverFill, colorScheme.surface)
        : colorScheme.surface;
    final l10n = context.l10n;

    return AdaptiveDropdown<int?>(
      items: [
        // Opzione "Tutte le sedi" come prima voce
        AdaptiveDropdownItem<int?>(value: null, child: Text(l10n.allLocations)),
        // Separator
        for (final location in widget.locations)
          AdaptiveDropdownItem<int?>(
            value: location.id,
            child: Text(location.name),
          ),
      ],
      selectedValue: widget.currentLocationId,
      onSelected: widget.onSelected,
      modalTitle: l10n.agendaSelectLocation,
      popupWidth: 200,
      useRootNavigator: true,
      onOpened: () => setState(() => _isHovered = true),
      onClosed: () => setState(() => _isHovered = false),
      child: MouseRegion(
        onEnter: (_) {
          if (!_isHovered) setState(() => _isHovered = true);
        },
        onExit: (_) {
          if (_isHovered) setState(() => _isHovered = false);
        },
        child: Semantics(
          button: true,
          label: l10n.agendaSelectLocation,
          child: ClipRRect(
            borderRadius: kAgendaPillRadius,
            child: SizedBox(
              width: _fixedWidth,
              child: Container(
                height: kAgendaControlHeight,
                decoration: BoxDecoration(
                  borderRadius: kAgendaPillRadius,
                  border: Border.all(color: Colors.grey.withOpacity(0.35)),
                  color: backgroundColor,
                ),
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: kAgendaControlHorizontalPadding,
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Expanded(
                        child: Text(
                          _getDisplayName(context),
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                      const SizedBox(width: 8),
                      const Icon(Icons.keyboard_arrow_down_rounded, size: 20),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/app/widgets/staff_circle_avatar.dart ---
import 'package:flutter/material.dart';

import '../../core/utils/initials_utils.dart';

String initialsFromName(String name, {int maxChars = 3}) {
  return InitialsUtils.fromName(name, maxChars: maxChars);
}

class StaffCircleAvatar extends StatelessWidget {
  final double height;
  final Color color;
  final bool isHighlighted;
  final String initials;
  final Widget? child;

  const StaffCircleAvatar({
    super.key,
    required this.height,
    required this.color,
    required this.isHighlighted,
    required this.initials,
    this.child,
  });

  @override
  Widget build(BuildContext context) {
    final hasThreeLetterInitials = InitialsUtils.length(initials) == 3;
    final initialsFontSize = height * (hasThreeLetterInitials ? 0.30 : 0.35);
    return Container(
      width: height,
      height: height,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: Border.all(
          color: isHighlighted ? color : color.withOpacity(0.35),
          width: isHighlighted ? 2 : 1,
        ),
      ),
      alignment: Alignment.center,
      child: Container(
        margin: const EdgeInsets.all(2),
        decoration: BoxDecoration(
          shape: BoxShape.circle,
          color: color.withOpacity(0.18),
        ),
        alignment: Alignment.center,
        child: Padding(
          padding: EdgeInsets.all(height * 0.06),
          child: FittedBox(
            fit: BoxFit.scaleDown,
            child: child ??
                Text(
                  initials,
                  style: TextStyle(
                    color: color,
                    fontWeight: FontWeight.w600,
                    fontSize: initialsFontSize,
                  ),
                ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/app/widgets/top_controls_scaffold.dart ---
import 'dart:math' as math;

import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/l10n/l10n.dart';
import 'package:agenda_backend/core/models/location.dart';
import 'package:agenda_backend/features/agenda/domain/config/layout_config.dart';
import 'package:agenda_backend/features/agenda/providers/date_range_provider.dart';
import 'package:agenda_backend/features/agenda/providers/layout_config_provider.dart';
import 'package:agenda_backend/features/agenda/providers/location_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

typedef TopControlsBuilderFn =
    Widget Function(BuildContext context, TopControlsData data);

class TopControlsBuilder {
  TopControlsBuilder.single(TopControlsBuilderFn builder)
    : _single = builder,
      mobile = null,
      tablet = null,
      desktop = null;

  TopControlsBuilder.adaptive({this.mobile, this.tablet, this.desktop})
    : _single = null,
      assert(
        mobile != null || tablet != null || desktop != null,
        L10n.current.errorFormFactorBuilderRequired,
      );

  final TopControlsBuilderFn? _single;
  final TopControlsBuilderFn? mobile;
  final TopControlsBuilderFn? tablet;
  final TopControlsBuilderFn? desktop;

  Widget build(BuildContext context, TopControlsData data) {
    if (_single != null) {
      return _single(context, data);
    }
    final builder = _resolve(data.formFactor);
    return builder(context, data);
  }

  TopControlsBuilderFn _resolve(AppFormFactor factor) {
    TopControlsBuilderFn? resolved;
    switch (factor) {
      case AppFormFactor.mobile:
        resolved = mobile ?? tablet ?? desktop;
        break;
      case AppFormFactor.tablet:
        resolved = tablet ?? desktop ?? mobile;
        break;
      case AppFormFactor.desktop:
        resolved = desktop ?? tablet ?? mobile;
        break;
    }
    if (resolved == null) {
      throw StateError(L10n.current.errorFormFactorBuilderMissing(factor.name));
    }
    return resolved;
  }
}

class TopControlsData {
  const TopControlsData({
    required this.l10n,
    required this.locale,
    required this.agendaDate,
    required this.layoutConfig,
    required this.formFactor,
    required this.locations,
    required this.currentLocation,
    required this.dateController,
    required this.locationController,
  });

  final L10n l10n;
  final Locale locale;
  final DateTime agendaDate;
  final LayoutConfig layoutConfig;
  final AppFormFactor formFactor;
  final List<Location> locations;
  final Location currentLocation;
  final AgendaDateNotifier dateController;
  final CurrentLocationId locationController;

  bool get isToday => DateUtils.isSameDay(agendaDate, DateTime.now());
}

/// Widget wrapper riutilizzabile per i controlli superiori dell'agenda/staff.
///
/// Si occupa di:
/// - leggere i provider condivisi (data corrente, locations, ecc.)
/// - calcolare gli offset comuni (hour column + navigation rail)
/// - mostrare automaticamente il fallback se non ci sono locations
class TopControlsScaffold extends ConsumerWidget {
  const TopControlsScaffold({
    super.key,
    required this.builder,
    this.alignment = AlignmentDirectional.centerStart,
    this.padding = EdgeInsets.zero,
    this.applyLayoutInset = true,
  });

  final TopControlsBuilder builder;
  final AlignmentGeometry alignment;
  final EdgeInsetsGeometry padding;
  // Permette di applicare l'offset calcolato per allineare ai contenuti
  // principali (hour column + navigation rail). Disattivato di default per
  // far partire i controlli esattamente a sinistra nell'app bar.
  final bool applyLayoutInset;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final locations = ref.watch(locationsProvider);
    if (locations.isEmpty) {
      return const SizedBox.shrink();
    }

    final agendaDate = ref.watch(agendaDateProvider);
    final currentLocation = ref.watch(currentLocationProvider);

    final data = TopControlsData(
      l10n: l10n,
      locale: Localizations.localeOf(context),
      agendaDate: agendaDate,
      layoutConfig: layoutConfig,
      formFactor: formFactor,
      locations: locations,
      currentLocation: currentLocation,
      dateController: ref.read(agendaDateProvider.notifier),
      locationController: ref.read(currentLocationIdProvider.notifier),
    );

    final leftInset = applyLayoutInset
        ? _computeLeftInset(context, layoutConfig, formFactor)
        : 0.0;
    Widget child = LayoutBuilder(
      builder: (context, constraints) {
        return builder.build(context, data);
      },
    );

    return Align(
      alignment: alignment,
      child: Padding(
        padding: EdgeInsetsDirectional.only(start: leftInset).add(padding),
        child: child,
      ),
    );
  }

  double _computeLeftInset(
    BuildContext context,
    LayoutConfig layoutConfig,
    AppFormFactor formFactor,
  ) {
    final railTheme = NavigationRailTheme.of(context);
    final railWidth = railTheme.minWidth ?? 72.0;
    const railDividerWidth = 1.0;
    final baseInset =
        layoutConfig.hourColumnWidth - NavigationToolbar.kMiddleSpacing;
    final railInset = formFactor != AppFormFactor.mobile
        ? railWidth + railDividerWidth
        : 0.0;

    return math.max(0.0, baseInset + railInset);
  }
}
--- FILE: lib/features/clients/providers/clients_providers.dart ---
import 'dart:async';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/appointment.dart';
import '../../../core/network/network_providers.dart';
import '../../agenda/providers/business_providers.dart';
import '../../auth/providers/auth_provider.dart';
import '../../auth/providers/current_business_user_provider.dart';
import '../data/clients_api.dart';
import '../data/clients_repository.dart';
import '../domain/client_sort_option.dart';
import '../domain/clients.dart';

// Repository provider con ApiClient
final clientsRepositoryProvider = Provider<ClientsRepository>((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return ClientsRepository(apiClient: apiClient);
});

// ClientsApi provider
final clientsApiProvider = Provider<ClientsApi>((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return ClientsApi(apiClient: apiClient);
});

/// Stato per la lista clienti con paginazione
class ClientsState {
  final List<Client> clients;
  final int total;
  final bool hasMore;
  final bool isLoadingMore;
  final bool isSearching;
  final String searchQuery;
  final ClientSortOption sortOption;

  const ClientsState({
    this.clients = const [],
    this.total = 0,
    this.hasMore = false,
    this.isLoadingMore = false,
    this.isSearching = false,
    this.searchQuery = '',
    this.sortOption = ClientSortOption.nameAsc,
  });

  ClientsState copyWith({
    List<Client>? clients,
    int? total,
    bool? hasMore,
    bool? isLoadingMore,
    bool? isSearching,
    String? searchQuery,
    ClientSortOption? sortOption,
  }) {
    return ClientsState(
      clients: clients ?? this.clients,
      total: total ?? this.total,
      hasMore: hasMore ?? this.hasMore,
      isLoadingMore: isLoadingMore ?? this.isLoadingMore,
      isSearching: isSearching ?? this.isSearching,
      searchQuery: searchQuery ?? this.searchQuery,
      sortOption: sortOption ?? this.sortOption,
    );
  }
}

/// Limite di clienti per pagina
const int _kClientsPageSize = 100;

/// Converte ClientSortOption in stringa per API
String _sortOptionToApiString(ClientSortOption option) {
  return switch (option) {
    ClientSortOption.nameAsc => 'name_asc',
    ClientSortOption.nameDesc => 'name_desc',
    ClientSortOption.lastNameAsc => 'last_name_asc',
    ClientSortOption.lastNameDesc => 'last_name_desc',
    ClientSortOption.createdAtAsc => 'created_asc',
    ClientSortOption.createdAtDesc => 'created_desc',
  };
}

/// AsyncNotifier per caricare i clienti dall'API con paginazione, ricerca e ordinamento lato server
class ClientsNotifier extends AsyncNotifier<ClientsState> {
  Timer? _searchDebounce;
  int _searchRequestId = 0;

  @override
  Future<ClientsState> build() async {
    // Verifica autenticazione
    final authState = ref.watch(authProvider);
    if (!authState.isAuthenticated) {
      return const ClientsState();
    }

    final business = ref.watch(currentBusinessProvider);
    if (business.id <= 0) {
      return const ClientsState();
    }
    if (!ref.watch(currentUserCanManageClientsProvider)) {
      return const ClientsState();
    }

    final repository = ref.watch(clientsRepositoryProvider);
    final response = await repository.getPage(
      business.id,
      limit: _kClientsPageSize,
      offset: 0,
      sort: _sortOptionToApiString(ClientSortOption.nameAsc),
    );
    return ClientsState(
      clients: response.clients,
      total: response.total,
      hasMore: response.hasMore,
    );
  }

  /// Cambia l'ordinamento e ricarica i dati dal server
  Future<void> setSortOption(ClientSortOption option) async {
    final current = state.value;
    if (current == null) return;
    if (current.sortOption == option) return;

    final authState = ref.read(authProvider);
    if (!authState.isAuthenticated) return;

    final business = ref.read(currentBusinessProvider);
    if (business.id <= 0) return;
    if (!ref.read(currentUserCanManageClientsProvider)) {
      state = const AsyncValue.data(ClientsState());
      return;
    }

    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(clientsRepositoryProvider);
      final response = await repository.getPage(
        business.id,
        limit: _kClientsPageSize,
        offset: 0,
        search: current.searchQuery.isNotEmpty ? current.searchQuery : null,
        sort: _sortOptionToApiString(option),
      );
      return ClientsState(
        clients: response.clients,
        total: response.total,
        hasMore: response.hasMore,
        searchQuery: current.searchQuery,
        sortOption: option,
      );
    });
  }

  /// Imposta la query di ricerca e ricarica i dati dal server (con debounce)
  void setSearchQuery(String query) {
    final current = state.value;
    if (current != null) {
      // Aggiorna subito la query nello stato per evitare che UI e campo testo
      // vengano sovrascritti da risposte async (sfarfallio).
      if (current.searchQuery != query) {
        state = AsyncValue.data(current.copyWith(searchQuery: query));
      }
    }

    _searchDebounce?.cancel();
    final requestId = ++_searchRequestId;
    _searchDebounce = Timer(const Duration(milliseconds: 300), () {
      _executeSearch(requestId);
    });
  }

  /// Esegue la ricerca immediatamente
  Future<void> _executeSearch(int requestId) async {
    final current = state.value;
    if (current == null) return;

    final trimmedQuery = current.searchQuery.trim();

    final authState = ref.read(authProvider);
    if (!authState.isAuthenticated) return;

    final business = ref.read(currentBusinessProvider);
    if (business.id <= 0) return;
    if (!ref.read(currentUserCanManageClientsProvider)) {
      state = const AsyncValue.data(ClientsState());
      return;
    }

    // Mantieni i dati visibili, mostra solo indicatore di ricerca
    state = AsyncValue.data(current.copyWith(isSearching: true));

    try {
      final repository = ref.read(clientsRepositoryProvider);
      final response = await repository.getPage(
        business.id,
        limit: _kClientsPageSize,
        offset: 0,
        search: trimmedQuery.isNotEmpty ? trimmedQuery : null,
        sort: _sortOptionToApiString(current.sortOption),
      );
      if (requestId != _searchRequestId) return;

      final latest = state.value ?? current;
      state = AsyncValue.data(
        ClientsState(
          clients: response.clients,
          total: response.total,
          hasMore: response.hasMore,
          searchQuery: latest.searchQuery,
          sortOption: latest.sortOption,
          isSearching: false,
        ),
      );
    } catch (e) {
      if (requestId != _searchRequestId) return;
      // In caso di errore, mantieni i dati precedenti e mostra errore
      state = AsyncValue.data(current.copyWith(isSearching: false));
      // ignore: avoid_print
      print('Error searching clients: $e');
    }
  }

  /// Carica la prossima pagina di clienti
  Future<void> loadMore() async {
    final current = state.value;
    if (current == null || !current.hasMore || current.isLoadingMore) return;

    final authState = ref.read(authProvider);
    if (!authState.isAuthenticated) return;

    final business = ref.read(currentBusinessProvider);
    if (business.id <= 0) return;
    if (!ref.read(currentUserCanManageClientsProvider)) return;

    // Imposta loading state
    state = AsyncValue.data(current.copyWith(isLoadingMore: true));

    try {
      final repository = ref.read(clientsRepositoryProvider);
      final response = await repository.getPage(
        business.id,
        limit: _kClientsPageSize,
        offset: current.clients.length,
        search: current.searchQuery.isNotEmpty ? current.searchQuery : null,
        sort: _sortOptionToApiString(current.sortOption),
      );

      state = AsyncValue.data(
        current.copyWith(
          clients: [...current.clients, ...response.clients],
          total: response.total,
          hasMore: response.hasMore,
          isLoadingMore: false,
        ),
      );
    } catch (e) {
      state = AsyncValue.data(current.copyWith(isLoadingMore: false));
      // ignore: avoid_print
      print('Error loading more clients: $e');
    }
  }

  /// Ricarica i clienti dall'API (mantiene filtri attuali)
  Future<void> refresh() async {
    final authState = ref.read(authProvider);
    if (!authState.isAuthenticated) return;

    final business = ref.read(currentBusinessProvider);
    if (business.id <= 0) return;
    if (!ref.read(currentUserCanManageClientsProvider)) {
      state = const AsyncValue.data(ClientsState());
      return;
    }

    final current = state.value;
    final searchQuery = current?.searchQuery ?? '';
    final sortOption = current?.sortOption ?? ClientSortOption.nameAsc;

    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(clientsRepositoryProvider);
      final response = await repository.getPage(
        business.id,
        limit: _kClientsPageSize,
        offset: 0,
        search: searchQuery.isNotEmpty ? searchQuery : null,
        sort: _sortOptionToApiString(sortOption),
      );
      return ClientsState(
        clients: response.clients,
        total: response.total,
        hasMore: response.hasMore,
        searchQuery: searchQuery,
        sortOption: sortOption,
      );
    });
  }

  /// Aggiunge un nuovo cliente via API e aggiorna lo state locale
  Future<Client> addClient(Client client) async {
    final repository = ref.read(clientsRepositoryProvider);
    final newClient = await repository.add(client);
    final current = state.value ?? const ClientsState();
    // Inserisci all'inizio della lista (sar√† riordinato al prossimo refresh)
    state = AsyncValue.data(
      current.copyWith(
        clients: [newClient, ...current.clients],
        total: current.total + 1,
      ),
    );
    return newClient;
  }

  /// Aggiorna un cliente via API e aggiorna lo state locale
  Future<void> updateClient(Client client) async {
    final repository = ref.read(clientsRepositoryProvider);
    final updated = await repository.save(client);
    final current = state.value ?? const ClientsState();
    state = AsyncValue.data(
      current.copyWith(
        clients: [
          for (final c in current.clients)
            if (c.id == updated.id) updated else c,
        ],
      ),
    );
  }

  /// Soft delete - imposta isArchived = true
  Future<void> deleteClient(int id) async {
    final current = state.value?.clients.firstWhere(
      (c) => c.id == id,
      orElse: () => throw Exception('Client not found'),
    );
    if (current == null) return;
    final archived = current.copyWith(isArchived: true);
    await updateClient(archived);
  }
}

final clientsProvider = AsyncNotifierProvider<ClientsNotifier, ClientsState>(
  ClientsNotifier.new,
);

/// Provider di convenienza che restituisce solo la lista clienti (per retrocompatibilit√†)
final clientsListProvider = Provider<List<Client>>((ref) {
  final asyncState = ref.watch(clientsProvider);
  return asyncState.value?.clients ?? [];
});

/// Provider che restituisce la lista clienti filtrata (gi√† filtrata dal server)
/// I clienti archiviati sono gi√† esclusi dal backend
final filteredClientsProvider = Provider<List<Client>>((ref) {
  return ref.watch(clientsListProvider).where((c) => !c.isArchived).toList();
});

// Indicizzazione rapida per id (restituisce mappa vuota se ancora in caricamento)
final clientsByIdProvider = Provider<Map<int, Client>>((ref) {
  final clients = ref.watch(clientsListProvider);
  return {for (final c in clients) c.id: c};
});

/// Provider per l'ordinamento corrente (legge dallo stato)
final clientSortOptionProvider = Provider<ClientSortOption>((ref) {
  final asyncState = ref.watch(clientsProvider);
  return asyncState.value?.sortOption ?? ClientSortOption.nameAsc;
});

/// Provider per la query di ricerca corrente (legge dallo stato)
final clientSearchQueryProvider = Provider<String>((ref) {
  final asyncState = ref.watch(clientsProvider);
  return asyncState.value?.searchQuery ?? '';
});

/// Provider che restituisce il conteggio totale dei clienti (non archiviati)
/// Usa il totale dal server, non la lista locale
final totalClientsCountProvider = Provider<int>((ref) {
  final asyncState = ref.watch(clientsProvider);
  return asyncState.value?.total ?? 0;
});

// Segmenti
const _kInactiveDays = 90;
const _kNewDays = 45;
const _kFrequentThreshold = 10; // placeholder (in futuro basato su bookings)

DateTime _now() => DateTime.now();

final inactiveClientsProvider = Provider<List<Client>>((ref) {
  final limit = _now().subtract(const Duration(days: _kInactiveDays));
  final allClients = ref.watch(clientsListProvider);
  return allClients
      .where(
        (c) =>
            !c.isArchived &&
            (c.lastVisit == null || c.lastVisit!.isBefore(limit)),
      )
      .toList();
});

final newClientsProvider = Provider<List<Client>>((ref) {
  final limit = _now().subtract(const Duration(days: _kNewDays));
  final allClients = ref.watch(clientsListProvider);
  return allClients
      .where((c) => !c.isArchived && c.createdAt.isAfter(limit))
      .toList();
});

final vipClientsProvider = Provider<List<Client>>((ref) {
  final allClients = ref.watch(clientsListProvider);
  return allClients
      .where((c) => !c.isArchived && (c.tags?.contains('VIP') ?? false))
      .toList();
});

final frequentClientsProvider = Provider<List<Client>>((ref) {
  final allClients = ref.watch(clientsListProvider);
  // Placeholder: usa loyaltyPoints come proxy delle visite
  return allClients
      .where(
        (c) => !c.isArchived && (c.loyaltyPoints ?? 0) >= _kFrequentThreshold,
      )
      .toList();
});

/// Forza il refresh degli appuntamenti cliente quando si entra in sezione.
class ClientAppointmentsRefreshNotifier extends Notifier<int> {
  @override
  int build() => 0;

  void bump() => state++;
}

final clientAppointmentsRefreshProvider =
    NotifierProvider<ClientAppointmentsRefreshNotifier, int>(
      ClientAppointmentsRefreshNotifier.new,
    );

// Provider per caricare appuntamenti di un cliente dall'API.
// Ritorna ClientAppointmentsData con liste upcoming e past gi√† ordinate.
final clientAppointmentsProvider =
    FutureProvider.family<ClientAppointmentsData, int>((ref, clientId) async {
      ref.watch(clientAppointmentsRefreshProvider);
      final api = ref.watch(clientsApiProvider);
      final data = await api.fetchClientAppointments(clientId);
      // Non mostrare appuntamenti di booking "replaced" nella vista cliente.
      // (Quando un booking viene riprogrammato, il precedente viene marcato replaced.)
      return ClientAppointmentsData(
        upcoming: data.upcoming.where((a) => !a.isReplaced).toList(),
        past: data.past.where((a) => !a.isReplaced).toList(),
      );
    });

// Provider di convenienza che unisce upcoming + past in una lista singola
// (usato da bookingIdsByClientProvider per retrocompatibilit√†)
final clientWithAppointmentsProvider = Provider.family<List<Appointment>, int>((
  ref,
  clientId,
) {
  final asyncData = ref.watch(clientAppointmentsProvider(clientId));
  final data = asyncData.value;
  if (data == null) return [];
  return [...data.upcoming, ...data.past];
});

final bookingIdsByClientProvider = Provider.family<Set<int>, int>((
  ref,
  clientId,
) {
  final appointments = ref.watch(clientWithAppointmentsProvider(clientId));
  return appointments.map((a) => a.bookingId).toSet();
});

// ---------------------------------------------------------------------------
// CLIENT PICKER SEARCH PROVIDER
// Provider dedicato per la ricerca clienti nel picker di appuntamenti/prenotazioni.
// Esegue la ricerca lato server per gestire correttamente grandi volumi di clienti.
// ---------------------------------------------------------------------------

/// Limite di clienti per la ricerca nel picker
const int _kPickerSearchLimit = 50;

/// Stato della ricerca clienti nel picker
class ClientPickerSearchState {
  final List<Client> clients;
  final bool isLoading;
  final String searchQuery;
  final String? error;

  const ClientPickerSearchState({
    this.clients = const [],
    this.isLoading = false,
    this.searchQuery = '',
    this.error,
  });

  ClientPickerSearchState copyWith({
    List<Client>? clients,
    bool? isLoading,
    String? searchQuery,
    String? error,
  }) {
    return ClientPickerSearchState(
      clients: clients ?? this.clients,
      isLoading: isLoading ?? this.isLoading,
      searchQuery: searchQuery ?? this.searchQuery,
      error: error,
    );
  }
}

/// Notifier per la ricerca clienti nel picker con debounce
/// Usa autoDispose per resettarsi quando il picker viene chiuso
class ClientPickerSearchNotifier extends Notifier<ClientPickerSearchState> {
  Timer? _searchDebounce;
  int _requestId = 0;

  @override
  ClientPickerSearchState build() {
    ref.onDispose(() {
      _searchDebounce?.cancel();
    });
    // Carica i primi clienti all'apertura (senza filtro)
    _loadInitialClients();
    return const ClientPickerSearchState(isLoading: true);
  }

  /// Carica i primi clienti senza filtro all'apertura del picker
  Future<void> _loadInitialClients() async {
    final requestId = ++_requestId;
    final authState = ref.read(authProvider);
    if (!authState.isAuthenticated) {
      if (!ref.mounted || requestId != _requestId) return;
      state = const ClientPickerSearchState();
      return;
    }

    final business = ref.read(currentBusinessProvider);
    if (business.id <= 0) {
      if (!ref.mounted || requestId != _requestId) return;
      state = const ClientPickerSearchState();
      return;
    }
    if (!ref.read(currentUserCanManageClientsProvider)) {
      if (!ref.mounted || requestId != _requestId) return;
      state = const ClientPickerSearchState();
      return;
    }

    try {
      final repository = ref.read(clientsRepositoryProvider);
      final response = await repository.getPage(
        business.id,
        limit: _kPickerSearchLimit,
        offset: 0,
        sort: 'name_asc',
      );
      if (!ref.mounted || requestId != _requestId) return;
      state = ClientPickerSearchState(
        clients: response.clients.where((c) => !c.isArchived).toList(),
        isLoading: false,
      );
    } catch (e) {
      if (!ref.mounted || requestId != _requestId) return;
      state = ClientPickerSearchState(isLoading: false, error: e.toString());
    }
  }

  /// Imposta la query di ricerca con debounce
  void setSearchQuery(String query) {
    final trimmed = query.trim();

    // Aggiorna subito lo stato visuale della query
    state = state.copyWith(searchQuery: trimmed);

    // Cancella il debounce precedente
    _searchDebounce?.cancel();

    // Se query vuota, ricarica i clienti iniziali
    if (trimmed.isEmpty) {
      state = state.copyWith(isLoading: true);
      _loadInitialClients();
      return;
    }

    // Debounce per evitare troppe chiamate durante la digitazione
    _searchDebounce = Timer(const Duration(milliseconds: 300), () {
      if (!ref.mounted) return;
      _executeSearch(trimmed, ++_requestId);
    });
  }

  /// Esegue la ricerca lato server
  Future<void> _executeSearch(String query, int requestId) async {
    final authState = ref.read(authProvider);
    if (!authState.isAuthenticated) return;

    final business = ref.read(currentBusinessProvider);
    if (business.id <= 0) return;
    if (!ref.read(currentUserCanManageClientsProvider)) {
      if (!ref.mounted || requestId != _requestId) return;
      state = const ClientPickerSearchState();
      return;
    }

    if (!ref.mounted || requestId != _requestId) return;
    state = state.copyWith(isLoading: true, error: null);

    try {
      final repository = ref.read(clientsRepositoryProvider);
      final response = await repository.getPage(
        business.id,
        limit: _kPickerSearchLimit,
        offset: 0,
        search: query,
        sort: 'name_asc',
      );
      if (!ref.mounted || requestId != _requestId) return;
      state = ClientPickerSearchState(
        clients: response.clients.where((c) => !c.isArchived).toList(),
        isLoading: false,
        searchQuery: query,
      );
    } catch (e) {
      if (!ref.mounted || requestId != _requestId) return;
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }

  /// Forza un refresh della ricerca corrente
  Future<void> refresh() async {
    final query = state.searchQuery;
    if (query.isEmpty) {
      state = state.copyWith(isLoading: true);
      await _loadInitialClients();
    } else {
      await _executeSearch(query, ++_requestId);
    }
  }
}

/// Provider per la ricerca clienti nel picker (autoDispose si resetta alla chiusura)
final clientPickerSearchProvider =
    NotifierProvider.autoDispose<
      ClientPickerSearchNotifier,
      ClientPickerSearchState
    >(ClientPickerSearchNotifier.new);
--- FILE: lib/features/clients/utils/client_validators.dart ---
// Intenzionalmente vuoto: placeholder per futuri validator dei clients.
--- FILE: lib/features/clients/utils/client_formatters.dart ---
// Intenzionalmente vuoto: placeholder per futuri formatter dei clients.
--- FILE: lib/features/clients/controllers/clients_search_controller.dart ---
// Intenzionalmente vuoto: placeholder per un eventuale controller di ricerca clients (Riverpod).
--- FILE: lib/features/clients/data/clients_api.dart ---
import '../../../core/models/appointment.dart';
import '../../../core/network/api_client.dart';
import '../../../core/network/api_config.dart';
import '../domain/clients.dart';

/// Struttura per gli appuntamenti di un cliente divisi per tempo
class ClientAppointmentsData {
  final List<Appointment> upcoming;
  final List<Appointment> past;

  ClientAppointmentsData({required this.upcoming, required this.past});
}

/// Risposta paginata per la lista clienti
class ClientsPageResponse {
  final List<Client> clients;
  final int total;
  final int limit;
  final int offset;
  final bool hasMore;

  ClientsPageResponse({
    required this.clients,
    required this.total,
    required this.limit,
    required this.offset,
    required this.hasMore,
  });
}

/// API layer per Clients - chiamate reali a agenda_core
class ClientsApi {
  final ApiClient _apiClient;

  ClientsApi({required ApiClient apiClient}) : _apiClient = apiClient;

  /// GET /v1/clients?business_id=X[&limit=N][&offset=N][&search=term][&sort=name_asc]
  /// Supporta paginazione, ricerca e ordinamento lato server
  Future<ClientsPageResponse> fetchClients(
    int businessId, {
    int? limit,
    int? offset,
    String? search,
    String? sort,
  }) async {
    final data = await _apiClient.getClients(
      businessId,
      limit: limit,
      offset: offset,
      search: search,
      sort: sort,
    );
    final List<dynamic> items = data['clients'] ?? [];
    return ClientsPageResponse(
      clients: items.map((json) => _clientFromJson(json)).toList(),
      total: data['total'] as int? ?? items.length,
      limit: data['limit'] as int? ?? items.length,
      offset: data['offset'] as int? ?? 0,
      hasMore: data['has_more'] as bool? ?? false,
    );
  }

  /// GET /v1/clients/{id}/appointments
  /// Carica tutti gli appuntamenti di un cliente, divisi in passati e futuri.
  Future<ClientAppointmentsData> fetchClientAppointments(int clientId) async {
    final data = await _apiClient.get(
      '${ApiConfig.clients}/$clientId/appointments',
    );

    final List<dynamic> upcomingJson = data['upcoming'] ?? [];
    final List<dynamic> pastJson = data['past'] ?? [];

    return ClientAppointmentsData(
      upcoming: upcomingJson.map((json) => _appointmentFromJson(json)).toList(),
      past: pastJson.map((json) => _appointmentFromJson(json)).toList(),
    );
  }

  /// POST /v1/clients
  Future<Client> createClient(Client client) async {
    final data = await _apiClient.post(
      ApiConfig.clients,
      data: _clientToJson(client),
    );
    return _clientFromJson(data);
  }

  /// PUT /v1/clients/{id}
  Future<Client> updateClient(Client client) async {
    final data = await _apiClient.put(
      '${ApiConfig.clients}/${client.id}',
      data: _clientToJson(client),
    );
    return _clientFromJson(data);
  }

  /// DELETE /v1/clients/{id}
  Future<void> deleteClient(int clientId) async {
    await _apiClient.delete('${ApiConfig.clients}/$clientId');
  }

  /// Converte JSON snake_case in Client
  Client _clientFromJson(Map<String, dynamic> json) {
    return Client(
      id: json['id'] as int,
      businessId: json['business_id'] as int,
      firstName: json['first_name'] as String?,
      lastName: json['last_name'] as String?,
      email: json['email'] as String?,
      phone: json['phone'] as String?,
      gender: json['gender'] as String?,
      birthDate: json['birth_date'] != null
          ? DateTime.parse(json['birth_date'] as String)
          : null,
      city: json['city'] as String?,
      notes: json['notes'] as String?,
      createdAt: DateTime.parse(json['created_at'] as String),
      lastVisit: json['last_visit'] != null
          ? DateTime.parse(json['last_visit'] as String)
          : null,
      loyaltyPoints: json['loyalty_points'] as int?,
      tags: json['tags'] != null
          ? List<String>.from(json['tags'] as List)
          : null,
      isArchived: json['is_archived'] as bool? ?? false,
    );
  }

  /// Converte Client in JSON snake_case
  /// I campi nullable vengono sempre inviati per permettere la rimozione del valore
  Map<String, dynamic> _clientToJson(Client client) {
    return {
      'business_id': client.businessId,
      'first_name': client.firstName,
      'last_name': client.lastName,
      'email': client.email,
      'phone': client.phone,
      'gender': client.gender,
      'birth_date': client.birthDate?.toIso8601String().split('T')[0],
      'city': client.city,
      'notes': client.notes,
      'tags': client.tags,
      'is_archived': client.isArchived,
    };
  }

  /// Converte JSON snake_case in Appointment (per cronologia cliente)
  Appointment _appointmentFromJson(Map<String, dynamic> json) {
    return Appointment(
      id: json['id'] as int,
      bookingId: json['booking_id'] as int,
      businessId: 0, // Non disponibile dalla risposta API semplificata
      locationId: json['location_id'] as int,
      serviceId: json['service_id'] as int,
      serviceVariantId: (json['service_variant_id'] as int?) ?? 0,
      staffId: json['staff_id'] as int,
      clientId: null, // Non necessario nella cronologia
      clientName: '',
      serviceName: json['service_name'] as String? ?? '',
      startTime: DateTime.parse(json['start_time'] as String),
      endTime: DateTime.parse(json['end_time'] as String),
      price: (json['price'] as num?)?.toDouble() ?? 0,
      // `ClientsController::appointments` currently returns booking status as
      // `status` (booking-level), while other endpoints may use `booking_status`.
      bookingStatus:
          json['booking_status'] as String? ?? json['status'] as String?,
    );
  }
}
--- FILE: lib/features/clients/data/clients_repository.dart ---
import '../../../core/network/api_client.dart';
import '../domain/clients.dart';
import 'clients_api.dart';

class ClientsRepository {
  ClientsRepository({required ApiClient apiClient})
    : _api = ClientsApi(apiClient: apiClient);

  final ClientsApi _api;

  /// Carica clienti con paginazione, ricerca e ordinamento
  Future<ClientsPageResponse> getPage(
    int businessId, {
    int? limit,
    int? offset,
    String? search,
    String? sort,
  }) => _api.fetchClients(
    businessId,
    limit: limit,
    offset: offset,
    search: search,
    sort: sort,
  );

  /// Carica tutti i clienti (senza limite)
  Future<List<Client>> getAll(int businessId) async {
    final response = await _api.fetchClients(businessId, limit: 10000);
    return response.clients;
  }

  Future<Client> add(Client client) => _api.createClient(client);
  Future<Client> save(Client client) => _api.updateClient(client);
  Future<void> delete(int clientId) => _api.deleteClient(clientId);
}
--- FILE: lib/features/clients/domain/client_sort_option.dart ---
/// Criteri di ordinamento per la lista clienti
enum ClientSortOption {
  /// Ordina per nome (A-Z)
  nameAsc,

  /// Ordina per nome (Z-A)
  nameDesc,

  /// Ordina per cognome (A-Z)
  lastNameAsc,

  /// Ordina per cognome (Z-A)
  lastNameDesc,

  /// Ordina per data creazione (nuovi prima)
  createdAtDesc,

  /// Ordina per data creazione (vecchi prima)
  createdAtAsc,
}
--- FILE: lib/features/clients/domain/clients.dart ---
class Client {
  final int id;
  final int businessId;
  final String? firstName;
  final String? lastName;
  final String? email;
  final String? phone;
  final String? gender;
  final DateTime? birthDate;
  final String? city;
  final String? notes;
  final DateTime createdAt;
  final DateTime? lastVisit;
  final int? loyaltyPoints;
  final List<String>? tags;
  final bool isArchived;

  const Client({
    required this.id,
    required this.businessId,
    this.firstName,
    this.lastName,
    this.email,
    this.phone,
    this.gender,
    this.birthDate,
    this.city,
    this.notes,
    required this.createdAt,
    this.lastVisit,
    this.loyaltyPoints,
    this.tags,
    this.isArchived = false,
  });

  /// Nome completo (firstName + lastName)
  String get name {
    final parts = <String>[];
    if (firstName != null && firstName!.isNotEmpty) parts.add(firstName!);
    if (lastName != null && lastName!.isNotEmpty) parts.add(lastName!);
    return parts.join(' ');
  }

  /// Prefissi comuni nei cognomi italiani (e alcune varianti internazionali)
  static const _lastNamePrefixes = {
    // Italiani
    'de', 'di', 'da', 'del', 'della', 'delle', 'dei', 'degli',
    'dall', "dall'", 'dalla', 'dallo', 'dalle', 'dagli',
    'la', 'lo', 'li', 'le',
    // Internazionali comuni
    'van', 'von', 'den', 'der', 'ter', 'ten',
    'mc', 'mac', "o'", 'al', 'el', 'ben', 'bin',
  };

  /// Crea un Client a partire da un nome completo, separando automaticamente
  /// nome e cognome. Riconosce cognomi composti con prefissi (es. "La Rosa", "De Luca").
  static ({String? firstName, String? lastName}) splitFullName(
    String fullName,
  ) {
    final trimmed = fullName.trim();
    if (trimmed.isEmpty) {
      return (firstName: null, lastName: null);
    }

    final parts = trimmed.split(RegExp(r'\s+'));
    if (parts.length == 1) {
      // Solo una parola: la consideriamo come firstName
      return (firstName: parts.first, lastName: null);
    }

    if (parts.length == 2) {
      // Due parole: firstName + lastName
      return (firstName: parts[0], lastName: parts[1]);
    }

    // 3+ parole: cerchiamo un prefisso di cognome
    // Partiamo dalla penultima parola e vediamo se √® un prefisso
    int lastNameStartIndex = parts.length - 1;

    for (int i = parts.length - 2; i >= 1; i--) {
      final word = parts[i].toLowerCase().replaceAll("'", "'");
      if (_lastNamePrefixes.contains(word)) {
        lastNameStartIndex = i;
      } else {
        // Se troviamo una parola che non √® un prefisso, ci fermiamo
        break;
      }
    }

    final firstName = parts.sublist(0, lastNameStartIndex).join(' ');
    final lastName = parts.sublist(lastNameStartIndex).join(' ');

    return (firstName: firstName, lastName: lastName);
  }

  Client copyWith({
    int? id,
    int? businessId,
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
    String? gender,
    DateTime? birthDate,
    String? city,
    String? notes,
    DateTime? createdAt,
    DateTime? lastVisit,
    int? loyaltyPoints,
    List<String>? tags,
    bool? isArchived,
  }) {
    return Client(
      id: id ?? this.id,
      businessId: businessId ?? this.businessId,
      firstName: firstName ?? this.firstName,
      lastName: lastName ?? this.lastName,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      gender: gender ?? this.gender,
      birthDate: birthDate ?? this.birthDate,
      city: city ?? this.city,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      lastVisit: lastVisit ?? this.lastVisit,
      loyaltyPoints: loyaltyPoints ?? this.loyaltyPoints,
      tags: tags ?? this.tags,
      isArchived: isArchived ?? this.isArchived,
    );
  }
}
--- FILE: lib/features/clients/presentation/dialogs/client_appointments_dialog.dart ---
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/appointment.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../domain/clients.dart';
import '../../providers/clients_providers.dart';

/// Mostra il dialog con la cronologia appuntamenti del cliente.
/// Su desktop usa un AlertDialog, su tablet/mobile un modal bottom sheet.
Future<void> showClientAppointmentsDialog(
  BuildContext context,
  WidgetRef ref, {
  required Client client,
}) async {
  final formFactor = ref.read(formFactorProvider);
  ref.invalidate(clientAppointmentsProvider(client.id));

  if (formFactor == AppFormFactor.desktop) {
    await showDialog(
      context: context,
      builder: (_) => ClientAppointmentsDialog(client: client),
    );
  } else {
    await AppBottomSheet.show<void>(
      context: context,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      heightFactor: AppBottomSheet.defaultHeightFactor,
      builder: (_) => ClientAppointmentsBottomSheet(client: client),
    );
  }
}

class ClientAppointmentsDialog extends ConsumerWidget {
  const ClientAppointmentsDialog({super.key, required this.client});

  final Client client;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final asyncData = ref.watch(clientAppointmentsProvider(client.id));

    final screenWidth = MediaQuery.of(context).size.width;
    final dialogWidth = screenWidth < 600 ? screenWidth * 0.95 : 500.0;

    return CallbackShortcuts(
      bindings: <ShortcutActivator, VoidCallback>{
        SingleActivator(LogicalKeyboardKey.escape): () =>
            Navigator.of(context, rootNavigator: true).pop(),
      },
      child: Focus(
        autofocus: true,
        child: AlertDialog(
          title: Text(l10n.clientAppointmentsTitle(client.name)),
          content: SizedBox(
            width: dialogWidth,
            height: 400,
            child: asyncData.when(
              loading: () => const Center(child: CircularProgressIndicator()),
              error: (e, _) => Center(child: Text('Errore: $e')),
              data: (data) => DefaultTabController(
                length: 2,
                child: Column(
                  children: [
                    TabBar(
                      tabs: [
                        Tab(
                          text:
                              '${l10n.clientAppointmentsUpcoming} (${data.upcoming.length})',
                        ),
                        Tab(
                          text:
                              '${l10n.clientAppointmentsPast} (${data.past.length})',
                        ),
                      ],
                      labelColor: theme.colorScheme.primary,
                      unselectedLabelColor: theme.colorScheme.onSurfaceVariant,
                      indicatorColor: theme.colorScheme.primary,
                    ),
                    const SizedBox(height: 8),
                    Expanded(
                      child: TabBarView(
                        children: [
                          _AppointmentList(
                            appointments: data.upcoming,
                            emptyMessage: l10n.clientAppointmentsEmpty,
                          ),
                          _AppointmentList(
                            appointments: data.past,
                            emptyMessage: l10n.clientAppointmentsEmpty,
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: Text(l10n.actionClose),
            ),
          ],
        ),
      ),
    );
  }
}

class _AppointmentList extends ConsumerWidget {
  const _AppointmentList({
    required this.appointments,
    required this.emptyMessage,
  });

  final List<Appointment> appointments;
  final String emptyMessage;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    if (appointments.isEmpty) {
      return Center(
        child: Text(
          emptyMessage,
          style: Theme.of(context).textTheme.bodyMedium?.copyWith(
            color: Theme.of(context).colorScheme.onSurfaceVariant,
          ),
        ),
      );
    }

    return ListView.separated(
      itemCount: appointments.length,
      separatorBuilder: (_, __) => const Divider(height: 1),
      itemBuilder: (context, index) {
        final appointment = appointments[index];
        return _AppointmentTile(appointment: appointment);
      },
    );
  }
}

class _AppointmentTile extends ConsumerWidget {
  const _AppointmentTile({required this.appointment});

  final Appointment appointment;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final locale = Localizations.localeOf(context).toLanguageTag();

    // Recupera staff
    final allStaff = ref.watch(sortedAllStaffProvider);
    final staff = allStaff
        .where((s) => s.id == appointment.staffId)
        .firstOrNull;

    final dateFormat = DateFormat('EEE d MMM', locale);
    final timeFormat = DateFormat('HH:mm', locale);

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Data e ora
          SizedBox(
            width: 90,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  dateFormat.format(appointment.startTime),
                  style: theme.textTheme.bodyMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                Text(
                  timeFormat.format(appointment.startTime),
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(width: 12),
          // Servizio e staff
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  appointment.serviceName,
                  style: theme.textTheme.bodyMedium,
                ),
                if (staff != null)
                  Text(
                    staff.name,
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
              ],
            ),
          ),
          // Durata + prezzo
          Column(
            crossAxisAlignment: CrossAxisAlignment.end,
            children: [
              if (appointment.isCancelled)
                Container(
                  margin: const EdgeInsets.only(bottom: 4),
                  padding: const EdgeInsets.symmetric(
                    horizontal: 8,
                    vertical: 3,
                  ),
                  decoration: BoxDecoration(
                    color: theme.colorScheme.error,
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: Text(
                    l10n.clientAppointmentsCancelledBadge,
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 11,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              Text(
                '${appointment.totalDuration} min',
                style: theme.textTheme.bodySmall?.copyWith(
                  color: theme.colorScheme.onSurfaceVariant,
                ),
              ),
              if (appointment.formattedPrice.isNotEmpty)
                Text(
                  appointment.formattedPrice,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                ),
            ],
          ),
        ],
      ),
    );
  }
}

/// Bottom sheet per tablet/mobile.
class ClientAppointmentsBottomSheet extends ConsumerWidget {
  const ClientAppointmentsBottomSheet({super.key, required this.client});

  final Client client;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final asyncData = ref.watch(clientAppointmentsProvider(client.id));

    return asyncData.when(
      loading: () => Scaffold(
        appBar: AppBar(
          title: Text(l10n.clientAppointmentsTitle(client.name)),
          automaticallyImplyLeading: false,
          actions: [
            IconButton(
              icon: const Icon(Icons.close),
              onPressed: () => Navigator.of(context).pop(),
            ),
          ],
        ),
        body: const Center(child: CircularProgressIndicator()),
      ),
      error: (e, _) => Scaffold(
        appBar: AppBar(
          title: Text(l10n.clientAppointmentsTitle(client.name)),
          automaticallyImplyLeading: false,
          actions: [
            IconButton(
              icon: const Icon(Icons.close),
              onPressed: () => Navigator.of(context).pop(),
            ),
          ],
        ),
        body: Center(child: Text('Errore: $e')),
      ),
      data: (data) => DefaultTabController(
        length: 2,
        child: Scaffold(
          appBar: AppBar(
            title: Text(l10n.clientAppointmentsTitle(client.name)),
            automaticallyImplyLeading: false,
            actions: [
              IconButton(
                icon: const Icon(Icons.close),
                onPressed: () => Navigator.of(context).pop(),
              ),
            ],
            bottom: TabBar(
              tabs: [
                Tab(
                  text:
                      '${l10n.clientAppointmentsUpcoming} (${data.upcoming.length})',
                ),
                Tab(
                  text: '${l10n.clientAppointmentsPast} (${data.past.length})',
                ),
              ],
              labelColor: theme.colorScheme.primary,
              unselectedLabelColor: theme.colorScheme.onSurfaceVariant,
              indicatorColor: theme.colorScheme.primary,
            ),
          ),
          body: TabBarView(
            children: [
              _AppointmentList(
                appointments: data.upcoming,
                emptyMessage: l10n.clientAppointmentsEmpty,
              ),
              _AppointmentList(
                appointments: data.past,
                emptyMessage: l10n.clientAppointmentsEmpty,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/clients/presentation/dialogs/client_edit_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../app/theme/app_spacing.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/local_loading_overlay.dart';
import '../../../auth/providers/current_business_user_provider.dart';
import '../../domain/clients.dart';
import '../../providers/clients_providers.dart';
import '../widgets/client_form.dart';

/// Mostra il dialog per creare o modificare un cliente.
/// Su mobile usa un modal bottom sheet full-screen, su tablet/desktop un dialog.
/// Ritorna il [Client] salvato (creato o modificato), oppure null se annullato.
///
/// Se [client] ha un id <= 0, il dialog sar√† in modalit√† creazione.
/// Se [client] ha un id > 0, il dialog sar√† in modalit√† modifica.
Future<Client?> showClientEditDialog(
  BuildContext context,
  WidgetRef ref, {
  Client? client,
}) async {
  final canManageClients = ref.read(currentUserCanManageClientsProvider);
  if (!canManageClients) {
    return null;
  }

  final formFactor = ref.read(formFactorProvider);

  if (formFactor == AppFormFactor.desktop) {
    return await showDialog<Client>(
      context: context,
      barrierDismissible: false,
      builder: (_) => ClientEditDialog(initial: client),
    );
  } else {
    return await AppBottomSheet.show<Client>(
      context: context,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      heightFactor: AppBottomSheet.defaultHeightFactor,
      builder: (_) => ClientEditBottomSheet(initial: client),
    );
  }
}

class ClientEditDialog extends ConsumerStatefulWidget {
  const ClientEditDialog({super.key, this.initial});

  final Client? initial;

  /// Un cliente con id > 0 √® esistente (modifica), altrimenti √® nuovo (creazione).
  bool get isExistingClient => (initial?.id ?? 0) > 0;

  @override
  ConsumerState<ClientEditDialog> createState() => _ClientEditDialogState();
}

class _ClientEditDialogState extends ConsumerState<ClientEditDialog> {
  final _form = GlobalKey<ClientFormState>();
  bool _hasChanges = false;
  bool _isSaving = false;

  @override
  Widget build(BuildContext context) {
    final isEditing = widget.isExistingClient;
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return DismissibleDialog(
      child: Dialog(
        insetPadding: const EdgeInsets.symmetric(horizontal: 32, vertical: 24),
        child: ConstrainedBox(
          constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
          child: LocalLoadingOverlay(
            isLoading: _isSaving,
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text(
                    isEditing ? l10n.clientsEdit : l10n.clientsNew,
                    style: theme.textTheme.headlineSmall,
                  ),
                  const SizedBox(height: 16),
                  Flexible(
                    child: SingleChildScrollView(
                      child: ClientForm(
                        key: _form,
                        initial: widget.initial,
                        onChanged: () {
                          if (!_hasChanges) setState(() => _hasChanges = true);
                        },
                      ),
                    ),
                  ),
                  const SizedBox(height: 24),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      if (isEditing) ...[
                        SizedBox(
                          width: AppButtonStyles.dialogButtonWidth,
                          child: AppAsyncDangerButton(
                            onPressed: _isSaving ? null : _onDelete,
                            padding: AppButtonStyles.dialogButtonPadding,
                            disabled: _isSaving,
                            showSpinner: false,
                            child: Text(l10n.actionDelete),
                          ),
                        ),
                        const Spacer(),
                      ],
                      SizedBox(
                        width: AppButtonStyles.dialogButtonWidth,
                        child: AppOutlinedActionButton(
                          onPressed: _isSaving
                              ? null
                              : () => _onCancel(context),
                          padding: AppButtonStyles.dialogButtonPadding,
                          child: Text(l10n.actionCancel),
                        ),
                      ),
                      const SizedBox(width: 8),
                      SizedBox(
                        width: AppButtonStyles.dialogButtonWidth,
                        child: AppAsyncFilledButton(
                          onPressed: _isSaving ? null : _onSave,
                          padding: AppButtonStyles.dialogButtonPadding,
                          isLoading: _isSaving,
                          showSpinner: false,
                          child: Text(l10n.actionSave),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _onCancel(BuildContext context) async {
    if (_hasChanges) {
      final confirm = await showConfirmDialog(
        context,
        title: Text(context.l10n.discardChangesTitle),
        content: Text(context.l10n.discardChangesMessage),
        confirmLabel: context.l10n.actionDiscard,
        cancelLabel: context.l10n.actionKeepEditing,
      );
      if (!confirm) return;
    }
    if (context.mounted) Navigator.of(context).pop();
  }

  Future<void> _onDelete() async {
    final canManageClients = ref.read(currentUserCanManageClientsProvider);
    if (!canManageClients) return;

    final client = widget.initial;
    if (client == null) return;

    final confirm = await showConfirmDialog(
      context,
      title: Text(context.l10n.deleteClientConfirmTitle),
      content: Text(context.l10n.deleteClientConfirmMessage),
      confirmLabel: context.l10n.actionDelete,
      danger: true,
    );
    if (!confirm) return;

    setState(() => _isSaving = true);
    try {
      await ref.read(clientsProvider.notifier).deleteClient(client.id);
      if (mounted) Navigator.of(context).pop();
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  Future<void> _onSave() async {
    final canManageClients = ref.read(currentUserCanManageClientsProvider);
    if (!canManageClients) return;

    final formState = _form.currentState;
    if (formState == null) return;
    if (!formState.validate()) return;

    setState(() => _isSaving = true);
    try {
      final client = formState.buildClient();
      Client savedClient;
      if (widget.isExistingClient) {
        await ref.read(clientsProvider.notifier).updateClient(client);
        savedClient = client;
      } else {
        savedClient = await ref
            .read(clientsProvider.notifier)
            .addClient(client);
      }
      if (mounted) Navigator.of(context).pop(savedClient);
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }
}

/// Bottom sheet per modifica/creazione cliente su mobile.
/// Usa lo stesso layout degli altri bottom sheet dell'app.
class ClientEditBottomSheet extends ConsumerStatefulWidget {
  const ClientEditBottomSheet({super.key, this.initial});

  final Client? initial;

  /// Un cliente con id > 0 √® esistente (modifica), altrimenti √® nuovo (creazione).
  bool get isExistingClient => (initial?.id ?? 0) > 0;

  @override
  ConsumerState<ClientEditBottomSheet> createState() =>
      _ClientEditBottomSheetState();
}

class _ClientEditBottomSheetState extends ConsumerState<ClientEditBottomSheet> {
  final _form = GlobalKey<ClientFormState>();
  bool _hasChanges = false;
  bool _isSaving = false;

  @override
  Widget build(BuildContext context) {
    final isEditing = widget.isExistingClient;
    final l10n = context.l10n;
    final theme = Theme.of(context);

    final title = isEditing ? l10n.clientsEdit : l10n.clientsNew;

    // Azioni in basso - stesso stile di appointment_dialog
    final actions = <Widget>[
      if (isEditing)
        AppAsyncDangerButton(
          onPressed: _isSaving ? null : _onDelete,
          padding: AppButtonStyles.dialogButtonPadding,
          disabled: _isSaving,
          showSpinner: false,
          child: Text(l10n.actionDelete),
        ),
      AppOutlinedActionButton(
        onPressed: _isSaving ? null : () => _onCancel(context),
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppAsyncFilledButton(
        onPressed: _isSaving ? null : _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        isLoading: _isSaving,
        showSpinner: false,
        child: Text(l10n.actionSave),
      ),
    ];

    // Usa le stesse dimensioni dei bottoni del dialog appuntamento per
    // mantenere coerenza visiva tra i form.
    final bottomActions = actions
        .map(
          (a) => SizedBox(width: AppButtonStyles.dialogButtonWidth, child: a),
        )
        .toList();

    return SafeArea(
      top: false,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final isKeyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
          return LocalLoadingOverlay(
            isLoading: _isSaving,
            child: SizedBox(
              height: constraints.maxHeight,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Expanded(
                    child: SingleChildScrollView(
                      padding: EdgeInsets.only(bottom: 0),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Padding(
                            padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Padding(
                                  padding: const EdgeInsets.only(bottom: 12),
                                  child: Text(
                                    title,
                                    style: theme.textTheme.titleLarge,
                                  ),
                                ),
                                ClientForm(
                                  key: _form,
                                  initial: widget.initial,
                                  onChanged: () {
                                    if (!_hasChanges) {
                                      setState(() => _hasChanges = true);
                                    }
                                  },
                                ),
                                const SizedBox(height: 24),
                                const SizedBox(
                                  height: AppSpacing.formRowSpacing,
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                  if (!isKeyboardOpen) ...[
                    const AppDivider(),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                      child: Align(
                        alignment: bottomActions.length == 3
                            ? Alignment.center
                            : Alignment.centerRight,
                        child: Wrap(
                          alignment: bottomActions.length == 3
                              ? WrapAlignment.center
                              : WrapAlignment.end,
                          spacing: 8,
                          runSpacing: 8,
                          children: bottomActions,
                        ),
                      ),
                    ),
                  ],
                  SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Future<void> _onCancel(BuildContext context) async {
    if (_hasChanges) {
      final confirm = await showConfirmDialog(
        context,
        title: Text(context.l10n.discardChangesTitle),
        content: Text(context.l10n.discardChangesMessage),
        confirmLabel: context.l10n.actionDiscard,
        cancelLabel: context.l10n.actionKeepEditing,
      );
      if (!confirm) return;
    }
    if (context.mounted) Navigator.of(context).pop();
  }

  Future<void> _onDelete() async {
    final canManageClients = ref.read(currentUserCanManageClientsProvider);
    if (!canManageClients) return;

    final client = widget.initial;
    if (client == null) return;

    final confirm = await showConfirmDialog(
      context,
      title: Text(context.l10n.deleteClientConfirmTitle),
      content: Text(context.l10n.deleteClientConfirmMessage),
      confirmLabel: context.l10n.actionDelete,
      danger: true,
    );
    if (!confirm) return;

    setState(() => _isSaving = true);
    try {
      await ref.read(clientsProvider.notifier).deleteClient(client.id);
      if (mounted) Navigator.of(context).pop();
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  Future<void> _onSave() async {
    final canManageClients = ref.read(currentUserCanManageClientsProvider);
    if (!canManageClients) return;

    final formState = _form.currentState;
    if (formState == null) return;
    if (!formState.validate()) return;

    setState(() => _isSaving = true);
    try {
      final client = formState.buildClient();
      Client savedClient;
      if (widget.isExistingClient) {
        await ref.read(clientsProvider.notifier).updateClient(client);
        savedClient = client;
      } else {
        savedClient = await ref
            .read(clientsProvider.notifier)
            .addClient(client);
      }
      if (mounted) Navigator.of(context).pop(savedClient);
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }
}
--- FILE: lib/features/clients/presentation/clients_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/l10n/l10_extension.dart'; // üåç
import '../providers/clients_providers.dart';
import 'widgets/client_list.dart';
import 'widgets/clients_search_field.dart';
import 'widgets/clients_sort_dropdown.dart';

class ClientsScreen extends ConsumerStatefulWidget {
  const ClientsScreen({super.key});

  @override
  ConsumerState<ClientsScreen> createState() => _ClientsScreenState();
}

class _ClientsScreenState extends ConsumerState<ClientsScreen> {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      ref.read(clientAppointmentsRefreshProvider.notifier).bump();
    });
  }

  @override
  Widget build(BuildContext context) {
    final sortOption = ref.watch(clientSortOptionProvider);
    final clientsAsync = ref.watch(clientsProvider);
    final bottomPadding = MediaQuery.of(context).padding.bottom;
    final searchQuery = ref.watch(clientSearchQueryProvider);

    return Scaffold(
      body: clientsAsync.when(
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (e, _) => Center(child: Text('Errore: $e')),
        data: (clientsState) {
          final filteredClients = ref.watch(filteredClientsProvider);
          final totalClients = clientsState.total;
          final hasSearch = searchQuery.trim().isNotEmpty;

          return Padding(
            padding: EdgeInsets.fromLTRB(16, 0, 16, 16 + bottomPadding),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                ClientsSearchField(
                  hintText: context.l10n.clientsTitle,
                  initialValue: searchQuery,
                  onChanged: (v) =>
                      ref.read(clientsProvider.notifier).setSearchQuery(v),
                ),
                const SizedBox(height: 8),
                Row(
                  children: [
                    ClientsSortDropdown(
                      value: sortOption,
                      onChanged: (v) =>
                          ref.read(clientsProvider.notifier).setSortOption(v),
                    ),
                    const Spacer(),
                    Padding(
                      padding: const EdgeInsets.only(right: 8),
                      child: Text(
                        hasSearch
                            ? '${filteredClients.length}/$totalClients ${context.l10n.navClients.toLowerCase()}'
                            : '$totalClients ${context.l10n.navClients.toLowerCase()}',
                        style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                          color: Theme.of(context).colorScheme.outline,
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                const Expanded(child: ClientList()),
              ],
            ),
          );
        },
      ),
    );
  }
}
--- FILE: lib/features/clients/presentation/widgets/clients_filter_chips.dart ---
import 'package:flutter/material.dart';

class ClientsFilterChips extends StatelessWidget {
  final int selectedIndex; // 0=all,1=VIP,2=Inactive,3=New
  final ValueChanged<int> onSelectedIndex;
  final String labelAll;
  final String labelVIP;
  final String labelInactive;
  final String labelNew;

  const ClientsFilterChips({
    super.key,
    required this.selectedIndex,
    required this.onSelectedIndex,
    required this.labelAll,
    required this.labelVIP,
    required this.labelInactive,
    required this.labelNew,
  });

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: Wrap(
        spacing: 8,
        children: [
          ChoiceChip(
            label: Text(labelAll),
            selected: selectedIndex == 0,
            onSelected: (_) => onSelectedIndex(0),
          ),
          ChoiceChip(
            label: Text(labelVIP),
            selected: selectedIndex == 1,
            onSelected: (_) => onSelectedIndex(1),
          ),
          ChoiceChip(
            label: Text(labelInactive),
            selected: selectedIndex == 2,
            onSelected: (_) => onSelectedIndex(2),
          ),
          ChoiceChip(
            label: Text(labelNew),
            selected: selectedIndex == 3,
            onSelected: (_) => onSelectedIndex(3),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/clients/presentation/widgets/clients_sort_dropdown.dart ---
import 'package:agenda_backend/app/theme/extensions.dart';
import 'package:agenda_backend/core/widgets/adaptive_dropdown.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../domain/client_sort_option.dart';

/// Dropdown per selezionare il criterio di ordinamento della lista clienti.
class ClientsSortDropdown extends ConsumerStatefulWidget {
  const ClientsSortDropdown({
    super.key,
    required this.value,
    required this.onChanged,
  });

  final ClientSortOption value;
  final ValueChanged<ClientSortOption> onChanged;

  @override
  ConsumerState<ClientsSortDropdown> createState() =>
      _ClientsSortDropdownState();
}

class _ClientsSortDropdownState extends ConsumerState<ClientsSortDropdown> {
  bool _isHovered = false;

  String _getLabel(ClientSortOption option) {
    final l10n = context.l10n;
    switch (option) {
      case ClientSortOption.nameAsc:
        return l10n.sortByNameAsc;
      case ClientSortOption.nameDesc:
        return l10n.sortByNameDesc;
      case ClientSortOption.lastNameAsc:
        return l10n.sortByLastNameAsc;
      case ClientSortOption.lastNameDesc:
        return l10n.sortByLastNameDesc;
      case ClientSortOption.createdAtDesc:
        return l10n.sortByCreatedAtDesc;
      case ClientSortOption.createdAtAsc:
        return l10n.sortByCreatedAtAsc;
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final interactions = theme.extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = _isHovered
        ? Color.alphaBlend(hoverFill, colorScheme.surface)
        : colorScheme.surface;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      child: AdaptiveDropdown<ClientSortOption>(
        items: [
          AdaptiveDropdownItem(
            value: ClientSortOption.nameAsc,
            child: Text(l10n.sortByNameAsc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.nameDesc,
            child: Text(l10n.sortByNameDesc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.lastNameAsc,
            child: Text(l10n.sortByLastNameAsc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.lastNameDesc,
            child: Text(l10n.sortByLastNameDesc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.createdAtDesc,
            child: Text(l10n.sortByCreatedAtDesc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.createdAtAsc,
            child: Text(l10n.sortByCreatedAtAsc),
          ),
        ],
        selectedValue: widget.value,
        onSelected: widget.onChanged,
        modalTitle: l10n.sortByTitle,
        useRootNavigator: true,
        onOpened: () => setState(() => _isHovered = true),
        onClosed: () => setState(() => _isHovered = false),
        popupWidth: 220,
        child: MouseRegion(
          onEnter: (_) {
            if (!_isHovered) setState(() => _isHovered = true);
          },
          onExit: (_) {
            if (_isHovered) setState(() => _isHovered = false);
          },
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            decoration: BoxDecoration(
              color: backgroundColor,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: colorScheme.outline.withOpacity(0.2)),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(Icons.sort, size: 18, color: colorScheme.onSurfaceVariant),
                const SizedBox(width: 8),
                Flexible(
                  child: Text(
                    _getLabel(widget.value),
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: colorScheme.onSurface,
                    ),
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                const SizedBox(width: 8),
                Icon(
                  Icons.keyboard_arrow_down,
                  size: 20,
                  color: colorScheme.onSurfaceVariant,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/clients/presentation/widgets/client_form.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../app/theme/app_spacing.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/utils/string_utils.dart';
import '../../../../core/widgets/labeled_form_field.dart';
import '../../../../core/widgets/phone_input_field.dart';
import '../../../agenda/providers/business_providers.dart';
import '../../domain/clients.dart';

class ClientForm extends ConsumerStatefulWidget {
  const ClientForm({super.key, this.initial, this.onChanged});

  final Client? initial;
  final VoidCallback? onChanged;

  @override
  ConsumerState<ClientForm> createState() => ClientFormState();
}

class ClientFormState extends ConsumerState<ClientForm> {
  final _formKey = GlobalKey<FormState>();
  final _phoneFieldKey = GlobalKey<PhoneInputFieldState>();

  late final TextEditingController _firstName = TextEditingController(
    text: widget.initial?.firstName ?? '',
  );
  late final TextEditingController _lastName = TextEditingController(
    text: widget.initial?.lastName ?? '',
  );
  late final TextEditingController _email = TextEditingController(
    text: widget.initial?.email ?? '',
  );
  late final TextEditingController _notes = TextEditingController(
    text: widget.initial?.notes ?? '',
  );

  @override
  void dispose() {
    _firstName.dispose();
    _lastName.dispose();
    _email.dispose();
    _notes.dispose();
    super.dispose();
  }

  bool validate() => _formKey.currentState?.validate() ?? false;

  Client buildClient() {
    final base = widget.initial;
    final now = DateTime.now();
    final phoneState = _phoneFieldKey.currentState;
    final fullPhone = phoneState?.fullPhone;

    final firstName = _firstName.text.trim();
    final lastName = _lastName.text.trim();

    return Client(
      id: base?.id ?? -1,
      businessId: base?.businessId ?? ref.read(currentBusinessProvider).id,
      firstName: firstName.isEmpty ? null : StringUtils.toTitleCase(firstName),
      lastName: lastName.isEmpty ? null : StringUtils.toTitleCase(lastName),
      email: _email.text.trim().isEmpty ? null : _email.text.trim(),
      phone: (fullPhone == null || fullPhone.isEmpty) ? null : fullPhone,
      notes: _notes.text.trim().isEmpty ? null : _notes.text.trim(),
      createdAt: base?.createdAt ?? now,
      lastVisit: base?.lastVisit,
      loyaltyPoints: base?.loyaltyPoints,
      tags: base?.tags,
      isArchived: base?.isArchived ?? false,
    );
  }

  @override
  Widget build(BuildContext context) {
    final business = ref.watch(currentBusinessProvider);
    final l10n = context.l10n;
    final formFactor = ref.watch(formFactorProvider);
    final isSingleColumn = formFactor != AppFormFactor.desktop;

    final firstNameField = LabeledFormField(
      label: l10n.formFirstName,
      child: TextFormField(
        controller: _firstName,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        textInputAction: TextInputAction.next,
        textCapitalization: TextCapitalization.words,
        onChanged: (_) {
          _formKey.currentState?.validate();
          widget.onChanged?.call();
        },
        validator: (v) {
          final firstName = v?.trim() ?? '';
          final lastName = _lastName.text.trim();
          if (firstName.isEmpty && lastName.isEmpty) {
            return l10n.validationNameOrLastNameRequired;
          }
          return null;
        },
      ),
    );

    final lastNameField = LabeledFormField(
      label: l10n.formLastName,
      child: TextFormField(
        controller: _lastName,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        textInputAction: TextInputAction.next,
        textCapitalization: TextCapitalization.words,
        onChanged: (_) {
          _formKey.currentState?.validate();
          widget.onChanged?.call();
        },
        validator: (v) {
          final lastName = v?.trim() ?? '';
          final firstName = _firstName.text.trim();
          if (firstName.isEmpty && lastName.isEmpty) {
            return l10n.validationNameOrLastNameRequired;
          }
          return null;
        },
      ),
    );

    final emailField = LabeledFormField(
      label: l10n.formEmail,
      child: TextFormField(
        controller: _email,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        keyboardType: TextInputType.emailAddress,
        textInputAction: TextInputAction.next,
        onChanged: (_) => widget.onChanged?.call(),
        validator: (v) {
          final t = v?.trim() ?? '';
          if (t.isEmpty) return null;
          final emailRegex = RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$');
          if (!emailRegex.hasMatch(t)) {
            return l10n.validationInvalidEmail;
          }
          return null;
        },
      ),
    );

    final phoneField = LabeledFormField(
      label: l10n.formPhone,
      child: PhoneInputField(
        key: _phoneFieldKey,
        defaultPrefix: business.defaultPhonePrefix,
        initialPhone: widget.initial?.phone,
        isDense: true,
        useOutlineBorder: true,
        onChanged: (_) => widget.onChanged?.call(),
        validator: (v) {
          final t = v?.trim().replaceAll(RegExp(r'\s+'), '') ?? '';
          if (t.isEmpty) return null;
          if (!RegExp(r'^\d{6,15}$').hasMatch(t)) {
            return l10n.validationInvalidPhone;
          }
          return null;
        },
      ),
    );

    final notesField = LabeledFormField(
      label: l10n.formNotes,
      child: TextFormField(
        controller: _notes,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        maxLines: 3,
        onChanged: (_) => widget.onChanged?.call(),
      ),
    );

    return Form(
      key: _formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        mainAxisSize: MainAxisSize.min,
        children: [
          if (isSingleColumn) ...[
            firstNameField,
            const SizedBox(height: AppSpacing.formRowSpacing),
            lastNameField,
            const SizedBox(height: AppSpacing.formRowSpacing),
            emailField,
            const SizedBox(height: AppSpacing.formRowSpacing),
            phoneField,
            const SizedBox(height: AppSpacing.formRowSpacing),
            notesField,
          ] else ...[
            // Riga 1: Nome + Cognome
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(child: firstNameField),
                const SizedBox(width: AppSpacing.formFieldSpacing),
                Expanded(child: lastNameField),
              ],
            ),
            const SizedBox(height: AppSpacing.formRowSpacing),

            // Riga 2: Email + Telefono
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(child: emailField),
                const SizedBox(width: AppSpacing.formFieldSpacing),
                Expanded(child: phoneField),
              ],
            ),
            const SizedBox(height: AppSpacing.formRowSpacing),

            // Riga 3: Note (sempre full width)
            notesField,
          ],
        ],
      ),
    );
  }
}
--- FILE: lib/features/clients/presentation/widgets/clients_search_field.dart ---
import 'package:flutter/material.dart';

class ClientsSearchField extends StatefulWidget {
  final String hintText;
  final String initialValue;
  final ValueChanged<String> onChanged;

  const ClientsSearchField({
    super.key,
    required this.hintText,
    this.initialValue = '',
    required this.onChanged,
  });

  @override
  State<ClientsSearchField> createState() => _ClientsSearchFieldState();
}

class _ClientsSearchFieldState extends State<ClientsSearchField> {
  late final TextEditingController _controller;
  late final FocusNode _focusNode;

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController(text: widget.initialValue);
    _focusNode = FocusNode();
  }

  @override
  void didUpdateWidget(covariant ClientsSearchField oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Sincronizza il controller se il valore iniziale cambia dall'esterno.
    // Evita di sovrascrivere mentre l'utente sta digitando (focus attivo),
    // altrimenti le risposte async della ricerca possono causare sfarfallio.
    if (_focusNode.hasFocus) return;
    if (widget.initialValue != oldWidget.initialValue &&
        widget.initialValue != _controller.text) {
      _controller.text = widget.initialValue;
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    _focusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return TextField(
      controller: _controller,
      focusNode: _focusNode,
      decoration: InputDecoration(
        prefixIcon: const Icon(Icons.search),
        hintText: widget.hintText,
        border: const OutlineInputBorder(),
        suffixIcon: _controller.text.isNotEmpty
            ? IconButton(
                icon: const Icon(Icons.clear),
                onPressed: () {
                  _controller.clear();
                  widget.onChanged('');
                  setState(() {});
                },
              )
            : null,
      ),
      onChanged: (value) {
        widget.onChanged(value);
        setState(() {});
      },
    );
  }
}
--- FILE: lib/features/clients/presentation/widgets/client_list.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../auth/providers/current_business_user_provider.dart';
import '../../providers/clients_providers.dart';
import '../dialogs/client_edit_dialog.dart';
import 'client_card.dart';

class ClientList extends ConsumerStatefulWidget {
  const ClientList({super.key});

  @override
  ConsumerState<ClientList> createState() => _ClientListState();
}

class _ClientListState extends ConsumerState<ClientList> {
  final _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
  }

  @override
  void dispose() {
    _scrollController.removeListener(_onScroll);
    _scrollController.dispose();
    super.dispose();
  }

  void _onScroll() {
    if (_scrollController.position.pixels >=
        _scrollController.position.maxScrollExtent - 200) {
      // Carica pi√π clienti quando siamo a 200px dal fondo
      final state = ref.read(clientsProvider).value;
      if (state != null && state.hasMore && !state.isLoadingMore) {
        ref.read(clientsProvider.notifier).loadMore();
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final clients = ref.watch(filteredClientsProvider);
    final clientsState = ref.watch(clientsProvider).value;
    final canManageClients = ref.watch(currentUserCanManageClientsProvider);
    final hasMore = clientsState?.hasMore ?? false;
    final isLoadingMore = clientsState?.isLoadingMore ?? false;

    if (clients.isEmpty) {
      return Center(child: Text(context.l10n.clientsEmpty));
    }

    final isWide = MediaQuery.of(context).size.width >= 900;
    if (isWide) {
      // Griglia responsive
      return LayoutBuilder(
        builder: (context, constraints) {
          final width = constraints.maxWidth;
          final crossAxisCount = (width / 280).floor().clamp(2, 6);
          return GridView.builder(
            controller: _scrollController,
            padding: const EdgeInsets.all(12),
            gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: crossAxisCount,
              mainAxisSpacing: 12,
              crossAxisSpacing: 12,
              childAspectRatio: 1.6,
            ),
            itemCount: clients.length + (hasMore ? 1 : 0),
            itemBuilder: (_, i) {
              if (i >= clients.length) {
                // Loading indicator at the end
                return Center(
                  child: isLoadingMore
                      ? const CircularProgressIndicator()
                      : const SizedBox.shrink(),
                );
              }
              final c = clients[i];
              return ClientCard(
                client: c,
                onTap: canManageClients
                    ? () => showClientEditDialog(context, ref, client: c)
                    : null,
              );
            },
          );
        },
      );
    }

    // Lista verticale
    return ListView.separated(
      controller: _scrollController,
      padding: const EdgeInsets.all(12),
      itemBuilder: (_, i) {
        if (i >= clients.length) {
          // Loading indicator at the end
          return Padding(
            padding: const EdgeInsets.symmetric(vertical: 16),
            child: Center(
              child: isLoadingMore
                  ? const CircularProgressIndicator()
                  : const SizedBox.shrink(),
            ),
          );
        }
        final c = clients[i];
        return ClientCard(
          client: c,
          onTap: canManageClients
              ? () => showClientEditDialog(context, ref, client: c)
              : null,
        );
      },
      separatorBuilder: (_, __) => const SizedBox(height: 8),
      itemCount: clients.length + (hasMore ? 1 : 0),
    );
  }
}
--- FILE: lib/features/clients/presentation/widgets/client_card.dart ---
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:url_launcher/url_launcher.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../auth/providers/current_business_user_provider.dart';
import '../../domain/clients.dart';
import '../../providers/clients_providers.dart';
import '../dialogs/client_appointments_dialog.dart';

class ClientCard extends ConsumerWidget {
  const ClientCard({super.key, required this.client, this.onTap});

  final Client client;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final scheme = theme.colorScheme;
    //final tags = client.tags ?? const [];
    final email = client.email;
    final phone = client.phone;
    final isEmailValid = email != null && _isValidEmail(email);
    final isPhoneValid = phone != null && _isValidPhone(phone);
    final emailTap = isEmailValid ? () => _openEmail(email) : null;
    final phoneTap = isPhoneValid ? () => _openPhone(phone) : null;
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: theme.cardColor,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: theme.dividerColor.withOpacity(0.4)),
        ),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Colonna sinistra: contenuto principale
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      StaffCircleAvatar(
                        height: 36,
                        color: scheme.primary,
                        isHighlighted: false,
                        initials: client.name.isNotEmpty
                            ? initialsFromName(client.name, maxChars: 2)
                            : '?',
                      ),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Text(
                          client.name,
                          style: theme.textTheme.titleMedium,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  if (email != null)
                    _LinkText(
                      text: email,
                      onTap: emailTap,
                      style: theme.textTheme.bodySmall,
                      linkColor: scheme.primary,
                    ),
                  if (client.email != null && client.phone != null)
                    const SizedBox(height: 12),
                  if (phone != null)
                    _LinkText(
                      text: phone,
                      onTap: phoneTap,
                      style: theme.textTheme.bodySmall,
                      linkColor: scheme.primary,
                    ),
                  if (client.lastVisit != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 12),
                      child: Text(
                        _buildLastVisitLabel(context, client.lastVisit!),
                        style: theme.textTheme.labelSmall,
                      ),
                    ),
                ],
              ),
            ),
            // Colonna destra: icone allineate verticalmente
            // Il delete button deve restare sempre allineato in alto a destra
            IntrinsicWidth(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.start,
                crossAxisAlignment: CrossAxisAlignment.end,
                children: [
                  _DeleteButton(client: client),
                  const SizedBox(height: 8),
                  _AppointmentsButton(client: client),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  String _buildLastVisitLabel(BuildContext context, DateTime date) {
    final locale = Localizations.localeOf(context).toLanguageTag();
    // Esempio coerente con altre parti dell'app (e.g. staff widgets): d MMM y
    final formatted = DateFormat('d MMM y', locale).format(date);
    return context.l10n.lastVisitLabel(formatted);
  }
}

class _LinkText extends StatelessWidget {
  const _LinkText({
    required this.text,
    required this.onTap,
    required this.style,
    required this.linkColor,
  });

  final String text;
  final VoidCallback? onTap;
  final TextStyle? style;
  final Color linkColor;

  @override
  Widget build(BuildContext context) {
    final effectiveStyle = onTap == null
        ? style
        : style?.copyWith(
                color: linkColor,
                decoration: TextDecoration.underline,
                decorationColor: linkColor,
              ) ??
              TextStyle(
                color: linkColor,
                decoration: TextDecoration.underline,
                decorationColor: linkColor,
              );
    return InkWell(
      onTap: onTap,
      child: Text(text, style: effectiveStyle),
    );
  }
}

bool _isValidEmail(String email) {
  final trimmed = email.trim();
  if (trimmed.isEmpty) return false;
  final emailRegex = RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$');
  return emailRegex.hasMatch(trimmed);
}

bool _isValidPhone(String phone) {
  final trimmed = phone.trim();
  if (trimmed.isEmpty) return false;
  final normalized = trimmed.replaceAll(RegExp(r'\s+'), '');
  final phoneRegex = RegExp(r'^\+?\d{6,15}$');
  return phoneRegex.hasMatch(normalized);
}

Future<void> _openEmail(String email) async {
  final uri = Uri(scheme: 'mailto', path: email.trim());
  await launchUrl(uri, mode: LaunchMode.externalApplication);
}

Future<void> _openPhone(String phone) async {
  final normalized = phone.trim().replaceAll(RegExp(r'\s+'), '');
  final uri = Uri(scheme: 'tel', path: normalized);
  await launchUrl(uri, mode: LaunchMode.externalApplication);
}

/// Pulsante per aprire il dialog degli appuntamenti del cliente.
/// Non carica i dati in anticipo per evitare troppe chiamate API simultanee.
/// I dati vengono caricati solo all'apertura del dialog.
class _AppointmentsButton extends StatelessWidget {
  const _AppointmentsButton({required this.client});

  final Client client;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return SizedBox(
      height: 32,
      child: Consumer(
        builder: (context, ref, _) => InkWell(
          onTap: () =>
              showClientAppointmentsDialog(context, ref, client: client),
          borderRadius: BorderRadius.circular(8),
          child: Center(
            child: Icon(
              Icons.calendar_month_outlined,
              size: 18,
              color: theme.colorScheme.primary.withOpacity(0.7),
            ),
          ),
        ),
      ),
    );
  }
}

class _DeleteButton extends ConsumerWidget {
  const _DeleteButton({required this.client});

  final Client client;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final canManageClients = ref.watch(currentUserCanManageClientsProvider);

    if (!canManageClients) {
      return const SizedBox(width: 32, height: 32);
    }

    return SizedBox(
      width: 32,
      height: 32,
      child: Align(
        alignment: Alignment.centerRight,
        child: IconButton(
          padding: EdgeInsets.zero,
          iconSize: 18,
          icon: Icon(
            Icons.delete_outline,
            color: theme.colorScheme.error.withOpacity(0.7),
          ),
          onPressed: () => _onDelete(context, ref),
        ),
      ),
    );
  }

  Future<void> _onDelete(BuildContext context, WidgetRef ref) async {
    final confirm = await showConfirmDialog(
      context,
      title: Text(context.l10n.deleteClientConfirmTitle),
      content: Text(context.l10n.deleteClientConfirmMessage),
      confirmLabel: context.l10n.actionDelete,
      danger: true,
    );
    if (!confirm) return;

    ref.read(clientsProvider.notifier).deleteClient(client.id);
  }
}
--- FILE: lib/features/bookings_list/providers/bookings_list_filter_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// State class for bookings list filter (date range and preset).
class BookingsListFilterState {
  const BookingsListFilterState({
    required this.startDate,
    required this.endDate,
    required this.selectedPreset,
  });

  final DateTime startDate;
  final DateTime endDate;
  final String selectedPreset;

  BookingsListFilterState copyWith({
    DateTime? startDate,
    DateTime? endDate,
    String? selectedPreset,
  }) {
    return BookingsListFilterState(
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      selectedPreset: selectedPreset ?? this.selectedPreset,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BookingsListFilterState &&
          runtimeType == other.runtimeType &&
          startDate == other.startDate &&
          endDate == other.endDate &&
          selectedPreset == other.selectedPreset;

  @override
  int get hashCode =>
      startDate.hashCode ^ endDate.hashCode ^ selectedPreset.hashCode;
}

/// Notifier for managing bookings list filter state.
class BookingsListFilterNotifier extends Notifier<BookingsListFilterState> {
  @override
  BookingsListFilterState build() {
    final today = DateUtils.dateOnly(DateTime.now());
    return BookingsListFilterState(
      startDate: today,
      endDate: today,
      selectedPreset: 'today',
    );
  }

  void setDateRange(DateTime start, DateTime end) {
    state = state.copyWith(
      startDate: start,
      endDate: end,
      selectedPreset: 'custom',
    );
  }

  void setPreset(String preset) {
    state = state.copyWith(selectedPreset: preset);
  }

  void applyPreset(String preset) {
    final now = DateTime.now();
    final today = DateUtils.dateOnly(now);

    DateTime startDate;
    DateTime endDate;

    // Per la lista prenotazioni, i preset "correnti" mostrano SEMPRE
    // l'intero periodo (incluso futuro) per vedere cosa c'√® in programma
    switch (preset) {
      case 'today':
        startDate = today;
        endDate = today;
        break;
      case 'month':
        startDate = DateTime(now.year, now.month, 1);
        endDate = DateTime(now.year, now.month + 1, 0); // Fine mese
        break;
      case 'quarter':
        final quarterStartMonth = ((now.month - 1) ~/ 3) * 3 + 1;
        startDate = DateTime(now.year, quarterStartMonth, 1);
        endDate = DateTime(
          now.year,
          quarterStartMonth + 3,
          0,
        ); // Fine trimestre
        break;
      case 'semester':
        final semesterStartMonth = now.month <= 6 ? 1 : 7;
        startDate = DateTime(now.year, semesterStartMonth, 1);
        endDate = DateTime(
          now.year,
          semesterStartMonth + 6,
          0,
        ); // Fine semestre
        break;
      case 'year':
        startDate = DateTime(now.year, 1, 1);
        endDate = DateTime(now.year, 12, 31); // Fine anno
        break;
      case 'last_month':
        final lastMonth = DateTime(now.year, now.month - 1, 1);
        startDate = lastMonth;
        endDate = DateTime(now.year, now.month, 0);
        break;
      case 'last_3_months':
        startDate = DateTime(now.year, now.month - 3, 1);
        endDate = DateTime(now.year, now.month, 0);
        break;
      case 'last_6_months':
        startDate = DateTime(now.year, now.month - 6, 1);
        endDate = DateTime(now.year, now.month, 0);
        break;
      case 'last_year':
        startDate = DateTime(now.year - 1, 1, 1);
        endDate = DateTime(now.year - 1, 12, 31);
        break;
      default:
        // 'custom' - keep current dates
        return;
    }

    state = state.copyWith(
      startDate: startDate,
      endDate: endDate,
      selectedPreset: preset,
    );
  }
}

/// Provider for bookings list filter state.
final bookingsListFilterProvider =
    NotifierProvider<BookingsListFilterNotifier, BookingsListFilterState>(
      BookingsListFilterNotifier.new,
    );
--- FILE: lib/features/bookings_list/providers/bookings_list_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/models/booking_list_item.dart';
import '/core/network/network_providers.dart';

/// Stato per i filtri della lista prenotazioni
class BookingsListFilters {
  final int? locationId;
  final List<int>? locationIds;
  final int? staffId;
  final List<int>? staffIds;
  final List<int>? serviceIds;
  final String? clientSearch;
  final List<String>? status;
  final String? source;
  final String? startDate;
  final String? endDate;
  final bool includePast;
  final String sortBy; // 'appointment' or 'created'
  final String sortOrder; // 'asc' or 'desc'

  const BookingsListFilters({
    this.locationId,
    this.locationIds,
    this.staffId,
    this.staffIds,
    this.serviceIds,
    this.clientSearch,
    this.status,
    this.source,
    this.startDate,
    this.endDate,
    this.includePast = false,
    this.sortBy = 'appointment',
    this.sortOrder = 'desc',
  });

  BookingsListFilters copyWith({
    int? locationId,
    bool clearLocationId = false,
    List<int>? locationIds,
    bool clearLocationIds = false,
    int? staffId,
    bool clearStaffId = false,
    List<int>? staffIds,
    bool clearStaffIds = false,
    List<int>? serviceIds,
    bool clearServiceIds = false,
    String? clientSearch,
    bool clearClientSearch = false,
    List<String>? status,
    bool clearStatus = false,
    String? source,
    bool clearSource = false,
    String? startDate,
    bool clearStartDate = false,
    String? endDate,
    bool clearEndDate = false,
    bool? includePast,
    String? sortBy,
    String? sortOrder,
  }) {
    return BookingsListFilters(
      locationId: clearLocationId ? null : (locationId ?? this.locationId),
      locationIds: clearLocationIds ? null : (locationIds ?? this.locationIds),
      staffId: clearStaffId ? null : (staffId ?? this.staffId),
      staffIds: clearStaffIds ? null : (staffIds ?? this.staffIds),
      serviceIds: clearServiceIds ? null : (serviceIds ?? this.serviceIds),
      clientSearch: clearClientSearch
          ? null
          : (clientSearch ?? this.clientSearch),
      status: clearStatus ? null : (status ?? this.status),
      source: clearSource ? null : (source ?? this.source),
      startDate: clearStartDate ? null : (startDate ?? this.startDate),
      endDate: clearEndDate ? null : (endDate ?? this.endDate),
      includePast: includePast ?? this.includePast,
      sortBy: sortBy ?? this.sortBy,
      sortOrder: sortOrder ?? this.sortOrder,
    );
  }

  /// Resetta tutti i filtri ai valori default
  factory BookingsListFilters.defaultFilters() {
    // Default: ultimi 3 giorni fino a domani
    final today = DateTime.now();
    final threeDaysAgo = today.subtract(const Duration(days: 3));
    final tomorrow = today.add(const Duration(days: 1));

    return BookingsListFilters(
      startDate: _formatDate(threeDaysAgo),
      endDate: _formatDate(tomorrow),
      includePast: true, // Per vedere anche gli appuntamenti passati nel range
    );
  }

  static String _formatDate(DateTime date) {
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
  }

  /// Indica se ci sono filtri attivi (oltre ai default)
  bool get hasActiveFilters {
    return locationId != null ||
        (locationIds != null && locationIds!.isNotEmpty) ||
        staffId != null ||
        (staffIds != null && staffIds!.isNotEmpty) ||
        (serviceIds != null && serviceIds!.isNotEmpty) ||
        (clientSearch != null && clientSearch!.isNotEmpty) ||
        (status != null && status!.isNotEmpty) ||
        (source != null && source!.isNotEmpty);
  }

  @override
  String toString() {
    return 'BookingsListFilters(locationId: $locationId, locationIds: $locationIds, staffId: $staffId, staffIds: $staffIds, serviceIds: $serviceIds, clientSearch: $clientSearch, status: $status, source: $source, startDate: $startDate, endDate: $endDate, includePast: $includePast, sortBy: $sortBy, sortOrder: $sortOrder)';
  }
}

/// Provider per i filtri correnti
final bookingsListFiltersProvider =
    NotifierProvider<BookingsListFiltersNotifier, BookingsListFilters>(
      BookingsListFiltersNotifier.new,
    );

class BookingsListFiltersNotifier extends Notifier<BookingsListFilters> {
  @override
  BookingsListFilters build() => BookingsListFilters.defaultFilters();

  void updateFilters(BookingsListFilters filters) {
    state = filters;
  }

  void setLocationId(int? locationId) {
    state = state.copyWith(
      locationId: locationId,
      clearLocationId: locationId == null,
      clearLocationIds: true,
    );
  }

  void setLocationIds(List<int>? locationIds) {
    state = state.copyWith(
      locationIds: locationIds,
      clearLocationIds: locationIds == null || locationIds.isEmpty,
      clearLocationId: true,
    );
  }

  void setStaffId(int? staffId) {
    state = state.copyWith(
      staffId: staffId,
      clearStaffId: staffId == null,
      clearStaffIds: true,
    );
  }

  void setStaffIds(List<int>? staffIds) {
    state = state.copyWith(
      staffIds: staffIds,
      clearStaffIds: staffIds == null || staffIds.isEmpty,
      clearStaffId: true,
    );
  }

  void setServiceIds(List<int>? serviceIds) {
    state = state.copyWith(
      serviceIds: serviceIds,
      clearServiceIds: serviceIds == null || serviceIds.isEmpty,
    );
  }

  void setClientSearch(String? search) {
    state = state.copyWith(
      clientSearch: search,
      clearClientSearch: search == null || search.isEmpty,
    );
  }

  void setStatus(List<String>? status) {
    state = state.copyWith(status: status, clearStatus: status == null);
  }

  void setSource(String? source) {
    state = state.copyWith(
      source: source,
      clearSource: source == null || source.isEmpty,
    );
  }

  void setDateRange(String? startDate, String? endDate) {
    state = state.copyWith(
      startDate: startDate,
      endDate: endDate,
      clearStartDate: startDate == null,
      clearEndDate: endDate == null,
    );
  }

  void setIncludePast(bool includePast) {
    state = state.copyWith(includePast: includePast);
  }

  void setSortBy(String sortBy) {
    state = state.copyWith(sortBy: sortBy);
  }

  void setSortOrder(String sortOrder) {
    state = state.copyWith(sortOrder: sortOrder);
  }

  void toggleSortOrder() {
    state = state.copyWith(
      sortOrder: state.sortOrder == 'asc' ? 'desc' : 'asc',
    );
  }

  void reset() {
    state = BookingsListFilters.defaultFilters();
  }
}

/// Stato per la lista prenotazioni (include paginazione)
class BookingsListState {
  final List<BookingListItem> bookings;
  final int total;
  final int offset;
  final int limit;
  final bool isLoading;
  final bool isLoadingMore;
  final String? error;

  const BookingsListState({
    this.bookings = const [],
    this.total = 0,
    this.offset = 0,
    this.limit = 50,
    this.isLoading = false,
    this.isLoadingMore = false,
    this.error,
  });

  bool get hasMore => offset + bookings.length < total;
  bool get isEmpty => bookings.isEmpty && !isLoading;

  BookingsListState copyWith({
    List<BookingListItem>? bookings,
    int? total,
    int? offset,
    int? limit,
    bool? isLoading,
    bool? isLoadingMore,
    String? error,
    bool clearError = false,
  }) {
    return BookingsListState(
      bookings: bookings ?? this.bookings,
      total: total ?? this.total,
      offset: offset ?? this.offset,
      limit: limit ?? this.limit,
      isLoading: isLoading ?? this.isLoading,
      isLoadingMore: isLoadingMore ?? this.isLoadingMore,
      error: clearError ? null : (error ?? this.error),
    );
  }
}

/// Provider per la lista prenotazioni con stato
final bookingsListProvider =
    NotifierProvider<BookingsListNotifier, BookingsListState>(
      BookingsListNotifier.new,
    );

class BookingsListNotifier extends Notifier<BookingsListState> {
  @override
  BookingsListState build() => const BookingsListState();

  /// Carica la prima pagina (reset)
  Future<void> loadBookings(int businessId) async {
    final filters = ref.read(bookingsListFiltersProvider);
    state = state.copyWith(isLoading: true, clearError: true);

    try {
      final apiClient = ref.read(apiClientProvider);
      final response = await apiClient.getBookingsList(
        businessId: businessId,
        locationId: filters.locationId,
        locationIds: filters.locationIds,
        staffId: filters.staffId,
        staffIds: filters.staffIds,
        serviceIds: filters.serviceIds,
        clientSearch: filters.clientSearch,
        status: filters.status,
        source: filters.source,
        startDate: filters.startDate,
        endDate: filters.endDate,
        includePast: filters.includePast,
        sortBy: filters.sortBy,
        sortOrder: filters.sortOrder,
        limit: state.limit,
        offset: 0,
      );

      final result = BookingListResult.fromJson(response);
      state = state.copyWith(
        bookings: result.bookings,
        total: result.total,
        offset: 0,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }

  /// Carica la pagina successiva (append)
  Future<void> loadMore(int businessId) async {
    if (state.isLoadingMore || !state.hasMore) return;

    final filters = ref.read(bookingsListFiltersProvider);
    state = state.copyWith(isLoadingMore: true);

    try {
      final apiClient = ref.read(apiClientProvider);
      final newOffset = state.offset + state.limit;

      final response = await apiClient.getBookingsList(
        businessId: businessId,
        locationId: filters.locationId,
        locationIds: filters.locationIds,
        staffId: filters.staffId,
        staffIds: filters.staffIds,
        serviceIds: filters.serviceIds,
        clientSearch: filters.clientSearch,
        status: filters.status,
        source: filters.source,
        startDate: filters.startDate,
        endDate: filters.endDate,
        includePast: filters.includePast,
        sortBy: filters.sortBy,
        sortOrder: filters.sortOrder,
        limit: state.limit,
        offset: newOffset,
      );

      final result = BookingListResult.fromJson(response);
      state = state.copyWith(
        bookings: [...state.bookings, ...result.bookings],
        total: result.total,
        offset: newOffset,
        isLoadingMore: false,
      );
    } catch (e) {
      state = state.copyWith(isLoadingMore: false, error: e.toString());
    }
  }

  /// Ricarica dopo cancellazione
  Future<void> refresh(int businessId) async {
    await loadBookings(businessId);
  }

  /// Rimuovi un booking dalla lista (ottimistic update dopo cancellazione)
  void removeBooking(int bookingId) {
    final newList = state.bookings.where((b) => b.id != bookingId).toList();
    state = state.copyWith(
      bookings: newList,
      total: state.total > 0 ? state.total - 1 : 0,
    );
  }
}
--- FILE: lib/features/bookings_list/presentation/bookings_list_screen.dart ---
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:intl/intl.dart';

import '/app/providers/form_factor_provider.dart';
import '/core/l10n/l10_extension.dart';
import '/core/models/booking_list_item.dart';
import '/core/models/service.dart';
import '/core/models/service_category.dart';
import '/core/models/staff.dart';
import '/core/network/network_providers.dart';
import '/core/widgets/feedback_dialog.dart';
import '/features/agenda/providers/date_range_provider.dart';
import '/features/agenda/presentation/dialogs/booking_history_dialog.dart';
import '/features/agenda/providers/location_providers.dart';
import '/features/auth/providers/current_business_user_provider.dart';
import '/features/bookings_list/providers/bookings_list_filter_provider.dart';
import '/features/bookings_list/providers/bookings_list_provider.dart';
import '/features/bookings_list/widgets/bookings_list_header.dart';
import '/features/services/providers/service_categories_provider.dart';
import '/features/services/providers/services_provider.dart';
import '/features/staff/providers/staff_providers.dart';

class BookingsListScreen extends ConsumerStatefulWidget {
  const BookingsListScreen({super.key});

  @override
  ConsumerState<BookingsListScreen> createState() => _BookingsListScreenState();
}

class _BookingsListScreenState extends ConsumerState<BookingsListScreen> {
  static const List<String> _allBookingStatuses = <String>[
    'confirmed',
    'completed',
    'cancelled',
    'no_show',
  ];

  final _scrollController = ScrollController();
  final _clientSearchController = TextEditingController();
  Timer? _clientSearchDebounce;

  // Multi-select filters (like Reports)
  final Set<int> _selectedLocationIds = {};
  final Set<int> _selectedStaffIds = {};
  final Set<int> _selectedServiceIds = {};
  Set<String> _selectedStatuses = _allBookingStatuses.toSet();
  bool _onlineOnly = false;

  List<Staff> _staffScopedByLocations({
    required List<Staff> staff,
    required Set<int> visibleLocationIds,
    Set<int>? selectedLocationIds,
  }) {
    final scopeLocationIds =
        (selectedLocationIds != null && selectedLocationIds.isNotEmpty)
        ? selectedLocationIds
        : visibleLocationIds;

    return staff.where((s) {
      if (s.locationIds.isEmpty) return true;
      return s.locationIds.any(scopeLocationIds.contains);
    }).toList();
  }

  List<Service> _servicesScopedByLocations({
    required List<Service> services,
    required Set<int> visibleLocationIds,
    Set<int>? selectedLocationIds,
  }) {
    final scopeLocationIds =
        (selectedLocationIds != null && selectedLocationIds.isNotEmpty)
        ? selectedLocationIds
        : visibleLocationIds;

    return services.where((s) {
      if (s.locationId == null) return true;
      return scopeLocationIds.contains(s.locationId);
    }).toList();
  }

  Set<int> _forcedLocationIdsForStaff(Set<int> visibleLocationIds) {
    final currentUserRole = ref.read(currentUserRoleProvider);
    final currentUserStaffId = ref.read(currentUserStaffIdProvider);
    if (currentUserRole != 'staff' ||
        currentUserStaffId == null ||
        currentUserStaffId <= 0) {
      return {};
    }

    final allowedLocationIds = ref.read(allowedLocationIdsProvider);
    if (allowedLocationIds != null && allowedLocationIds.isNotEmpty) {
      return allowedLocationIds.toSet().intersection(visibleLocationIds);
    }

    final staff = ref.read(allStaffProvider).value ?? [];
    final member = staff.where((s) => s.id == currentUserStaffId).firstOrNull;
    if (member != null && member.locationIds.isNotEmpty) {
      return member.locationIds.toSet().intersection(visibleLocationIds);
    }

    return {};
  }

  Set<int> _effectiveLocationSelection(Set<int> visibleLocationIds) {
    final forced = _forcedLocationIdsForStaff(visibleLocationIds);
    if (forced.isNotEmpty) return forced;
    return _selectedLocationIds;
  }

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadInitialData();
    });
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _clientSearchController.dispose();
    _clientSearchDebounce?.cancel();
    super.dispose();
  }

  int get _businessId => ref.read(currentLocationProvider).businessId;

  void _onScroll() {
    if (_scrollController.position.pixels >=
        _scrollController.position.maxScrollExtent - 200) {
      ref.read(bookingsListProvider.notifier).loadMore(_businessId);
    }
  }

  Future<void> _loadInitialData() async {
    final currentUserRole = ref.read(currentUserRoleProvider);
    final currentUserStaffId = ref.read(currentUserStaffIdProvider);
    final forcedStaffIds =
        (currentUserRole == 'staff' &&
            currentUserStaffId != null &&
            currentUserStaffId > 0)
        ? <int>[currentUserStaffId]
        : null;
    final visibleLocationIds = ref
        .read(locationsProvider)
        .map((l) => l.id)
        .toSet();
    final effectiveLocationIds = _effectiveLocationSelection(
      visibleLocationIds,
    );

    // Get filter state from provider (UI date range)
    final filterState = ref.read(bookingsListFilterProvider);
    // Get current API filters to preserve sortBy/sortOrder
    final currentFilters = ref.read(bookingsListFiltersProvider);

    // Update filters provider with current selections
    ref
        .read(bookingsListFiltersProvider.notifier)
        .updateFilters(
          BookingsListFilters(
            locationIds: effectiveLocationIds.isNotEmpty
                ? effectiveLocationIds.toList()
                : null,
            staffIds:
                forcedStaffIds ??
                (_selectedStaffIds.isNotEmpty
                    ? _selectedStaffIds.toList()
                    : null),
            serviceIds: _selectedServiceIds.isNotEmpty
                ? _selectedServiceIds.toList()
                : null,
            clientSearch: _clientSearchController.text.isNotEmpty
                ? _clientSearchController.text
                : null,
            status: _selectedStatuses.toList(),
            source: _onlineOnly ? 'online,onlinestaff' : null,
            startDate: _formatDate(filterState.startDate),
            endDate: _formatDate(filterState.endDate),
            includePast: true, // Always include past within range
            sortBy: currentFilters.sortBy,
            sortOrder: currentFilters.sortOrder,
          ),
        );
    await ref.read(bookingsListProvider.notifier).loadBookings(_businessId);
  }

  String _formatDate(DateTime date) {
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
  }

  Future<void> _cancelBooking(BookingListItem booking) async {
    final canManageBookings = ref.read(currentUserCanManageBookingsProvider);
    if (!canManageBookings) return;

    final l10n = context.l10n;
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.bookingsListCancelConfirmTitle),
        content: Text(l10n.bookingsListCancelConfirmMessage),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(false),
            child: Text(l10n.actionCancel),
          ),
          FilledButton(
            style: FilledButton.styleFrom(
              backgroundColor: Theme.of(context).colorScheme.error,
            ),
            onPressed: () => Navigator.of(ctx).pop(true),
            child: Text(l10n.actionConfirm),
          ),
        ],
      ),
    );

    if (confirmed == true && mounted) {
      try {
        final apiClient = ref.read(apiClientProvider);
        await apiClient.deleteBooking(
          locationId: booking.locationId,
          bookingId: booking.id,
        );
        ref.read(bookingsListProvider.notifier).removeBooking(booking.id);
        if (mounted) {
          await FeedbackDialog.showSuccess(
            context,
            title: l10n.bookingsListCancelSuccess,
            message: '',
          );
        }
      } catch (e) {
        if (mounted) {
          await FeedbackDialog.showError(
            context,
            title: l10n.errorTitle,
            message: e.toString(),
          );
        }
      }
    }
  }

  void _viewBookingDetails(BookingListItem booking) {
    if (booking.firstStartTime != null) {
      ref.read(agendaDateProvider.notifier).set(booking.firstStartTime!);
      context.go('/agenda');
    }
  }

  Future<void> _viewBookingHistory(BookingListItem booking) async {
    await showBookingHistoryDialog(
      context,
      ref,
      bookingId: booking.id,
    );
  }

  void _showLocationFilter(BuildContext context) async {
    final currentUserRole = ref.read(currentUserRoleProvider);
    if (currentUserRole == 'staff') return;

    final locations = ref.read(locationsProvider);
    if (locations.isEmpty) return;

    final selected = await showDialog<Set<int>>(
      context: context,
      builder: (ctx) => _LocationFilterDialog(
        locations: locations,
        selected: _selectedLocationIds,
      ),
    );

    if (selected != null) {
      final visibleLocationIds = locations.map((l) => l.id).toSet();
      final staff = ref.read(allStaffProvider).value ?? [];
      final services = ref.read(servicesProvider).value ?? [];
      final filteredStaff = _staffScopedByLocations(
        staff: staff,
        visibleLocationIds: visibleLocationIds,
        selectedLocationIds: selected,
      );
      final filteredServices = _servicesScopedByLocations(
        services: services,
        visibleLocationIds: visibleLocationIds,
        selectedLocationIds: selected,
      );
      final allowedStaffIds = filteredStaff.map((s) => s.id).toSet();
      final allowedServiceIds = filteredServices.map((s) => s.id).toSet();

      setState(() {
        _selectedLocationIds
          ..clear()
          ..addAll(selected);
        _selectedStaffIds.removeWhere((id) => !allowedStaffIds.contains(id));
        _selectedServiceIds.removeWhere(
          (id) => !allowedServiceIds.contains(id),
        );
      });
      _loadInitialData();
    }
  }

  void _showStaffFilter(BuildContext context) async {
    final currentUserRole = ref.read(currentUserRoleProvider);
    if (currentUserRole == 'staff') return;

    final staff = ref.read(allStaffProvider).value ?? [];
    final visibleLocationIds = ref
        .read(locationsProvider)
        .map((l) => l.id)
        .toSet();
    final effectiveLocationIds = _effectiveLocationSelection(
      visibleLocationIds,
    );
    final filteredStaff = _staffScopedByLocations(
      staff: staff,
      visibleLocationIds: visibleLocationIds,
      selectedLocationIds: effectiveLocationIds,
    );
    if (filteredStaff.isEmpty) return;

    final selected = await showDialog<Set<int>>(
      context: context,
      builder: (ctx) =>
          _StaffFilterDialog(staff: filteredStaff, selected: _selectedStaffIds),
    );

    if (selected != null) {
      setState(
        () => _selectedStaffIds
          ..clear()
          ..addAll(selected),
      );
      _loadInitialData();
    }
  }

  void _showServiceFilter(BuildContext context) async {
    final services = ref.read(servicesProvider).value ?? [];
    final visibleLocationIds = ref
        .read(locationsProvider)
        .map((l) => l.id)
        .toSet();
    final effectiveLocationIds = _effectiveLocationSelection(
      visibleLocationIds,
    );
    final filteredServices = _servicesScopedByLocations(
      services: services,
      visibleLocationIds: visibleLocationIds,
      selectedLocationIds: effectiveLocationIds,
    );
    final categories = ref.read(serviceCategoriesProvider);
    if (filteredServices.isEmpty) return;

    final selected = await showDialog<Set<int>>(
      context: context,
      builder: (ctx) => _ServiceFilterDialog(
        services: filteredServices,
        categories: categories,
        selected: _selectedServiceIds,
      ),
    );

    if (selected != null) {
      setState(
        () => _selectedServiceIds
          ..clear()
          ..addAll(selected),
      );
      _loadInitialData();
    }
  }

  void _showStatusFilter(BuildContext context) async {
    final l10n = context.l10n;
    final allStatuses = {
      'confirmed': l10n.bookingsListStatusConfirmed,
      'completed': l10n.bookingsListStatusCompleted,
      'cancelled': l10n.bookingsListStatusCancelled,
      'no_show': l10n.bookingsListStatusNoShow,
    };

    final selected = await showDialog<Set<String>>(
      context: context,
      builder: (ctx) => _MultiSelectDialog<String>(
        title: l10n.bookingsListFilterStatus,
        items: allStatuses,
        selected: _selectedStatuses,
      ),
    );

    if (selected != null && selected.isNotEmpty) {
      setState(() => _selectedStatuses = selected);
      _loadInitialData();
    }
  }

  void _onClientSearchChanged(String value) {
    if (mounted) {
      setState(() {});
    }
    _clientSearchDebounce?.cancel();
    _clientSearchDebounce = Timer(const Duration(milliseconds: 300), () {
      if (!mounted) return;
      _loadInitialData();
    });
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final listState = ref.watch(bookingsListProvider);
    final formFactor = ref.watch(formFactorProvider);
    final isDesktop = formFactor == AppFormFactor.desktop;

    ref.listen<BookingsListState>(bookingsListProvider, (prev, next) {
      if (next.error != null && prev?.error != next.error) {
        FeedbackDialog.showError(
          context,
          title: l10n.errorTitle,
          message: next.error!,
        );
      }
    });

    // Listen for filter changes to reload data
    ref.listen(bookingsListFilterProvider, (prev, next) {
      if (prev != null &&
          (prev.startDate != next.startDate ||
              prev.endDate != next.endDate ||
              prev.selectedPreset != next.selectedPreset)) {
        _loadInitialData();
      }
    });

    // Note: This screen is displayed inside ScaffoldWithNavigation,
    // so it should NOT have its own Scaffold/AppBar.
    // Material wrapper needed for FilterChip widgets.
    return Material(
      child: Column(
        children: [
          // Header with period controls
          const BookingsListHeader(),

          // Filters section (only chips, no date controls)
          _buildFiltersSection(context),

          // Results info
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            child: Row(
              children: [
                Text(
                  l10n.bookingsListTotalCount(listState.total),
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
                const Spacer(),
                _SortControls(
                  filters: ref.watch(bookingsListFiltersProvider),
                  onChanged: _loadInitialData,
                ),
              ],
            ),
          ),

          Divider(
            height: 1,
            indent: 0,
            endIndent: 0,
            color: Theme.of(context).colorScheme.outline.withOpacity(0.2),
          ),

          // Content
          Expanded(child: _buildContent(listState, isDesktop)),
        ],
      ),
    );
  }

  Widget _buildFiltersSection(BuildContext context) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;
    final currentUserRole = ref.watch(currentUserRoleProvider);
    final currentUserStaffId = ref.watch(currentUserStaffIdProvider);
    final isStaffRole =
        currentUserRole == 'staff' &&
        currentUserStaffId != null &&
        currentUserStaffId > 0;

    return Container(
      alignment: Alignment.centerLeft,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerLow,
        border: Border(
          bottom: BorderSide(color: colorScheme.outline.withOpacity(0.2)),
        ),
      ),
      child: Builder(
        builder: (context) {
          final locations = ref.watch(locationsProvider);
          final staff = ref.watch(allStaffProvider).value ?? [];
          final services = ref.watch(servicesProvider).value ?? [];
          final visibleLocationIds = locations.map((l) => l.id).toSet();
          final effectiveLocationIds = _effectiveLocationSelection(
            visibleLocationIds,
          );
          final filteredStaff = _staffScopedByLocations(
            staff: staff,
            visibleLocationIds: visibleLocationIds,
            selectedLocationIds: effectiveLocationIds,
          );
          final filteredServices = _servicesScopedByLocations(
            services: services,
            visibleLocationIds: visibleLocationIds,
            selectedLocationIds: effectiveLocationIds,
          );

          final hasMultipleLocations = locations.length > 1;
          final hasMultipleStaff = filteredStaff.length > 1;
          final hasMultipleServices = filteredServices.length > 1;

          return Wrap(
            alignment: WrapAlignment.start,
            crossAxisAlignment: WrapCrossAlignment.center,
            spacing: 8,
            runSpacing: 8,
            children: [
              if (hasMultipleLocations)
                if (!isStaffRole)
                  _buildFilterChip(
                    context,
                    label: _selectedLocationIds.isEmpty
                        ? l10n.reportsFilterLocations
                        : '${l10n.reportsFilterLocations} (${_selectedLocationIds.length})',
                    selected: _selectedLocationIds.isNotEmpty,
                    onTap: () => _showLocationFilter(context),
                  ),
              if (hasMultipleStaff)
                if (!isStaffRole)
                  _buildFilterChip(
                    context,
                    label: _selectedStaffIds.isEmpty
                        ? l10n.reportsFilterStaff
                        : '${l10n.reportsFilterStaff} (${_selectedStaffIds.length})',
                    selected: _selectedStaffIds.isNotEmpty,
                    onTap: () => _showStaffFilter(context),
                  ),
              if (hasMultipleServices)
                _buildFilterChip(
                  context,
                  label: _selectedServiceIds.isEmpty
                      ? l10n.reportsFilterServices
                      : '${l10n.reportsFilterServices} (${_selectedServiceIds.length})',
                  selected: _selectedServiceIds.isNotEmpty,
                  onTap: () => _showServiceFilter(context),
                ),
              _buildFilterChip(
                context,
                label: l10n.reportsFilterStatus,
                selected:
                    _selectedStatuses.length < _allBookingStatuses.length,
                onTap: () => _showStatusFilter(context),
              ),
              _buildFilterChip(
                context,
                label: l10n.bookingsListSourceOnline,
                selected: _onlineOnly,
                onTap: () {
                  setState(() => _onlineOnly = !_onlineOnly);
                  _loadInitialData();
                },
              ),
              _buildClientSearchField(context),
            ],
          );
        },
      ),
    );
  }

  Widget _buildFilterChip(
    BuildContext context, {
    required String label,
    required bool selected,
    required VoidCallback onTap,
  }) {
    final colorScheme = Theme.of(context).colorScheme;

    return FilterChip(
      label: Text(label),
      selected: selected,
      onSelected: (_) => onTap(),
      selectedColor: colorScheme.primaryContainer,
      checkmarkColor: colorScheme.onPrimaryContainer,
      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
    );
  }

  Widget _buildClientSearchField(BuildContext context) {
    final l10n = context.l10n;
    final availableWidth = MediaQuery.sizeOf(context).width - 32;
    final fieldWidth = availableWidth < 300 ? availableWidth : 300.0;
    const fieldHeight = 34.0;

    return SizedBox(
      width: fieldWidth,
      height: fieldHeight,
      child: TextField(
        controller: _clientSearchController,
        onChanged: _onClientSearchChanged,
        style: Theme.of(context).textTheme.bodyMedium,
        textAlignVertical: TextAlignVertical.center,
        decoration: InputDecoration(
          hintText: l10n.bookingsListFilterClient,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
          ),
          isDense: true,
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 10,
            vertical: 0,
          ),
          prefixIcon: const Icon(Icons.search, size: 17),
          prefixIconConstraints: const BoxConstraints(
            minWidth: 32,
            maxWidth: 32,
            minHeight: fieldHeight,
            maxHeight: fieldHeight,
          ),
          suffixIcon: _clientSearchController.text.isEmpty
              ? null
              : IconButton(
                  icon: const Icon(Icons.clear, size: 17),
                  padding: EdgeInsets.zero,
                  visualDensity: VisualDensity.compact,
                  onPressed: () {
                    _clientSearchController.clear();
                    _onClientSearchChanged('');
                    setState(() {});
                  },
                ),
          suffixIconConstraints: const BoxConstraints(
            minWidth: 32,
            maxWidth: 32,
            minHeight: fieldHeight,
            maxHeight: fieldHeight,
          ),
        ),
      ),
    );
  }

  Widget _buildContent(BookingsListState state, bool isDesktop) {
    final l10n = context.l10n;

    if (state.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (state.error != null) {
      return Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.error_outline,
              size: 48,
              color: Theme.of(context).colorScheme.error,
            ),
            const SizedBox(height: 16),
            Text(state.error!),
            const SizedBox(height: 16),
            FilledButton.icon(
              onPressed: _loadInitialData,
              icon: const Icon(Icons.refresh),
              label: Text(l10n.actionRetry),
            ),
          ],
        ),
      );
    }

    if (state.isEmpty) {
      return Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.event_busy, size: 64, color: Colors.grey),
            const SizedBox(height: 16),
            Text(
              l10n.bookingsListEmpty,
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 8),
            Text(
              l10n.bookingsListEmptyHint,
              style: Theme.of(
                context,
              ).textTheme.bodyMedium?.copyWith(color: Colors.grey),
            ),
          ],
        ),
      );
    }

    if (isDesktop) {
      return _buildDataTable(state);
    } else {
      return _buildCardList(state);
    }
  }

  Widget _buildDataTable(BookingsListState state) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;
    final canManageBookings = ref.watch(currentUserCanManageBookingsProvider);

    return SingleChildScrollView(
      controller: _scrollController,
      child: Column(
        children: [
          SingleChildScrollView(
            scrollDirection: Axis.horizontal,
            child: Theme(
              data: Theme.of(
                context,
              ).copyWith(dividerColor: colorScheme.outline.withOpacity(0.2)),
              child: DataTable(
                dividerThickness: 0.2,
                horizontalMargin: 16,
                headingRowColor: WidgetStateProperty.all(
                  colorScheme.surfaceContainerHighest,
                ),
                columns: [
                  DataColumn(label: Text(l10n.bookingsListColumnDateTime)),
                  DataColumn(label: Text(l10n.bookingsListColumnClient)),
                  DataColumn(label: Text(l10n.bookingsListColumnServices)),
                  DataColumn(label: Text(l10n.bookingsListColumnStaff)),
                  DataColumn(label: Text(l10n.bookingsListColumnStatus)),
                  DataColumn(
                    label: Text(l10n.bookingsListColumnPrice),
                    numeric: true,
                  ),
                  DataColumn(label: Text(l10n.bookingsListColumnCreatedAt)),
                  DataColumn(label: Text(l10n.bookingsListColumnActions)),
                ],
                rows: state.bookings
                    .map(
                      (booking) => _buildDataRow(
                        booking,
                        canManageBookings: canManageBookings,
                      ),
                    )
                    .toList(),
              ),
            ),
          ),
          if (state.isLoadingMore)
            const Padding(
              padding: EdgeInsets.all(16),
              child: CircularProgressIndicator(),
            ),
          if (state.hasMore && !state.isLoadingMore)
            Padding(
              padding: const EdgeInsets.all(16),
              child: OutlinedButton(
                onPressed: () {
                  ref.read(bookingsListProvider.notifier).loadMore(_businessId);
                },
                child: Text(l10n.bookingsListLoadMore),
              ),
            ),
        ],
      ),
    );
  }

  DataRow _buildDataRow(
    BookingListItem booking, {
    required bool canManageBookings,
  }) {
    final l10n = context.l10n;
    final dateFormat = DateFormat('dd/MM/yy HH:mm');
    final dateOnlyFormat = DateFormat('dd/MM/yy');

    return DataRow(
      cells: [
        DataCell(
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              if (booking.source == 'online' || booking.source == 'onlinestaff')
                Padding(
                  padding: const EdgeInsets.only(right: 6),
                  child: Tooltip(
                    message: booking.sourceLabel(context),
                    child: Icon(
                      booking.sourceIcon,
                      size: 16,
                      color: booking.source == 'onlinestaff'
                          ? Colors.red
                          : Theme.of(context).colorScheme.primary,
                    ),
                  ),
                ),
              Text(
                booking.firstStartTime != null
                    ? dateFormat.format(booking.firstStartTime!)
                    : '-',
              ),
            ],
          ),
        ),
        DataCell(
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                booking.clientName ?? l10n.bookingsListNoClient,
                style: TextStyle(
                  fontStyle: booking.clientName == null
                      ? FontStyle.italic
                      : null,
                ),
              ),
              if (booking.clientPhone != null)
                Text(
                  booking.clientPhone!,
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
            ],
          ),
        ),
        DataCell(
          SizedBox(
            width: 200,
            child: Text(
              booking.serviceNames ?? '-',
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ),
        DataCell(Text(booking.staffNames ?? '-')),
        DataCell(_StatusChip(status: booking.status)),
        DataCell(
          Text(
            '‚Ç¨ ${booking.totalPrice.toStringAsFixed(2)}',
            style: const TextStyle(fontWeight: FontWeight.w500),
          ),
        ),
        DataCell(
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                booking.createdAt != null
                    ? dateOnlyFormat.format(booking.createdAt!)
                    : '-',
              ),
              if (booking.creatorName != null)
                Text(
                  booking.creatorName!,
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
            ],
          ),
        ),
        DataCell(
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              IconButton(
                icon: const Icon(Icons.history, size: 20),
                onPressed: () => _viewBookingHistory(booking),
                tooltip: l10n.bookingHistoryTitle,
              ),
              if (booking.status != 'cancelled')
                IconButton(
                  icon: const Icon(Icons.visibility, size: 20),
                  onPressed: () => _viewBookingDetails(booking),
                  tooltip: l10n.bookingsListActionView,
                ),
              if (canManageBookings && booking.status != 'cancelled')
                IconButton(
                  icon: Icon(
                    Icons.cancel,
                    size: 20,
                    color: Theme.of(context).colorScheme.error,
                  ),
                  onPressed: () => _cancelBooking(booking),
                  tooltip: l10n.bookingsListActionCancel,
                ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildCardList(BookingsListState state) {
    final canManageBookings = ref.watch(currentUserCanManageBookingsProvider);

    return ListView.builder(
      controller: _scrollController,
      padding: const EdgeInsets.all(8),
      itemCount: state.bookings.length + (state.hasMore ? 1 : 0),
      itemBuilder: (context, index) {
        if (index >= state.bookings.length) {
          return const Center(
            child: Padding(
              padding: EdgeInsets.all(16),
              child: CircularProgressIndicator(),
            ),
          );
        }
        return _BookingCard(
          booking: state.bookings[index],
          onHistory: () => _viewBookingHistory(state.bookings[index]),
          onView: () => _viewBookingDetails(state.bookings[index]),
          onCancel: () => _cancelBooking(state.bookings[index]),
          canManageBookings: canManageBookings,
          showStatus: _selectedStatuses.length > 1,
        );
      },
    );
  }
}

// ============================================================================
// Filter Dialogs (copied from Reports for consistency)
// ============================================================================

class _LocationFilterDialog extends StatefulWidget {
  const _LocationFilterDialog({
    required this.locations,
    required this.selected,
  });

  final List<dynamic> locations;
  final Set<int> selected;

  @override
  State<_LocationFilterDialog> createState() => _LocationFilterDialogState();
}

class _LocationFilterDialogState extends State<_LocationFilterDialog> {
  late Set<int> _selected;

  @override
  void initState() {
    super.initState();
    _selected = Set<int>.from(widget.selected);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;

    return AlertDialog(
      title: Text(l10n.reportsFilterLocations),
      content: SizedBox(
        width: 300,
        height: 400,
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                TextButton(
                  onPressed: () {
                    setState(() {
                      _selected = widget.locations
                          .map((l) => l.id as int)
                          .toSet();
                    });
                  },
                  child: Text(l10n.actionSelectAll),
                ),
                TextButton(
                  onPressed: () {
                    setState(() => _selected.clear());
                  },
                  child: Text(l10n.actionDeselectAll),
                ),
              ],
            ),
            Divider(
              indent: 0,
              endIndent: 0,
              color: Theme.of(context).colorScheme.outline.withOpacity(0.2),
            ),
            Expanded(
              child: ListView.builder(
                itemCount: widget.locations.length,
                itemBuilder: (context, index) {
                  final location = widget.locations[index];
                  final isSelected = _selected.contains(location.id);

                  return CheckboxListTile(
                    title: Text(location.name),
                    value: isSelected,
                    onChanged: (checked) {
                      setState(() {
                        if (checked == true) {
                          _selected.add(location.id);
                        } else {
                          _selected.remove(location.id);
                        }
                      });
                    },
                  );
                },
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: Text(l10n.actionCancel),
        ),
        FilledButton(
          onPressed: () => Navigator.of(context).pop(_selected),
          child: Text(l10n.actionApply),
        ),
      ],
    );
  }
}

class _StaffFilterDialog extends StatefulWidget {
  const _StaffFilterDialog({required this.staff, required this.selected});

  final List<Staff> staff;
  final Set<int> selected;

  @override
  State<_StaffFilterDialog> createState() => _StaffFilterDialogState();
}

class _StaffFilterDialogState extends State<_StaffFilterDialog> {
  late Set<int> _selected;

  @override
  void initState() {
    super.initState();
    _selected = Set<int>.from(widget.selected);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;

    return AlertDialog(
      title: Text(l10n.reportsFilterStaff),
      content: SizedBox(
        width: 300,
        height: 400,
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                TextButton(
                  onPressed: () {
                    setState(() {
                      _selected = widget.staff.map((s) => s.id).toSet();
                    });
                  },
                  child: Text(l10n.actionSelectAll),
                ),
                TextButton(
                  onPressed: () {
                    setState(() => _selected.clear());
                  },
                  child: Text(l10n.actionDeselectAll),
                ),
              ],
            ),
            Divider(
              indent: 0,
              endIndent: 0,
              color: Theme.of(context).colorScheme.outline.withOpacity(0.2),
            ),
            Expanded(
              child: ListView.builder(
                itemCount: widget.staff.length,
                itemBuilder: (context, index) {
                  final staff = widget.staff[index];
                  final isSelected = _selected.contains(staff.id);

                  return CheckboxListTile(
                    title: Text(staff.name),
                    value: isSelected,
                    onChanged: (checked) {
                      setState(() {
                        if (checked == true) {
                          _selected.add(staff.id);
                        } else {
                          _selected.remove(staff.id);
                        }
                      });
                    },
                  );
                },
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: Text(l10n.actionCancel),
        ),
        FilledButton(
          onPressed: () => Navigator.of(context).pop(_selected),
          child: Text(l10n.actionApply),
        ),
      ],
    );
  }
}

class _ServiceFilterDialog extends StatefulWidget {
  const _ServiceFilterDialog({
    required this.services,
    required this.categories,
    required this.selected,
  });

  final List<Service> services;
  final List<ServiceCategory> categories;
  final Set<int> selected;

  @override
  State<_ServiceFilterDialog> createState() => _ServiceFilterDialogState();
}

class _ServiceFilterDialogState extends State<_ServiceFilterDialog> {
  late Set<int> _selected;
  final Set<int> _expandedCategories = {};

  @override
  void initState() {
    super.initState();
    _selected = Set<int>.from(widget.selected);
    for (final service in widget.services) {
      if (_selected.contains(service.id)) {
        _expandedCategories.add(service.categoryId);
      }
    }
  }

  Map<int, List<Service>> _groupServicesByCategory() {
    final grouped = <int, List<Service>>{};
    for (final service in widget.services) {
      grouped.putIfAbsent(service.categoryId, () => []).add(service);
    }
    return grouped;
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;
    final groupedServices = _groupServicesByCategory();

    final sortedCategories = widget.categories.toList()
      ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));

    final categoryIdsWithServices = groupedServices.keys.toSet();

    final displayItems = <_CategoryDisplayItem>[];
    for (final cat in sortedCategories) {
      if (categoryIdsWithServices.contains(cat.id)) {
        displayItems.add(_CategoryDisplayItem(id: cat.id, name: cat.name));
      }
    }
    if (categoryIdsWithServices.contains(0)) {
      displayItems.add(const _CategoryDisplayItem(id: 0, name: 'Altro'));
    }

    return AlertDialog(
      title: Text(l10n.reportsFilterServices),
      content: SizedBox(
        width: 400,
        height: 500,
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                TextButton(
                  onPressed: () {
                    setState(() {
                      _selected = widget.services.map((s) => s.id).toSet();
                    });
                  },
                  child: Text(l10n.actionSelectAll),
                ),
                TextButton(
                  onPressed: () {
                    setState(() => _selected.clear());
                  },
                  child: Text(l10n.actionDeselectAll),
                ),
              ],
            ),
            Divider(
              indent: 0,
              endIndent: 0,
              color: Theme.of(context).colorScheme.outline.withOpacity(0.2),
            ),
            Expanded(
              child: ListView.builder(
                itemCount: displayItems.length,
                itemBuilder: (context, index) {
                  final categoryItem = displayItems[index];
                  final categoryId = categoryItem.id;
                  final categoryName = categoryItem.name;
                  final services = groupedServices[categoryId] ?? [];

                  if (services.isEmpty) return const SizedBox.shrink();

                  final isExpanded = _expandedCategories.contains(categoryId);
                  final selectedInCategory = services
                      .where((s) => _selected.contains(s.id))
                      .length;
                  final allSelectedInCategory =
                      selectedInCategory == services.length;
                  final someSelectedInCategory =
                      selectedInCategory > 0 && !allSelectedInCategory;

                  return Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      InkWell(
                        onTap: () {
                          setState(() {
                            if (isExpanded) {
                              _expandedCategories.remove(categoryId);
                            } else {
                              _expandedCategories.add(categoryId);
                            }
                          });
                        },
                        child: Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 8,
                            vertical: 12,
                          ),
                          color: colorScheme.surfaceContainerHighest
                              .withOpacity(0.5),
                          child: Row(
                            children: [
                              Icon(
                                isExpanded
                                    ? Icons.expand_less
                                    : Icons.expand_more,
                                size: 20,
                              ),
                              const SizedBox(width: 8),
                              Expanded(
                                child: Text(
                                  categoryName,
                                  style: const TextStyle(
                                    fontWeight: FontWeight.w600,
                                  ),
                                ),
                              ),
                              Text(
                                '$selectedInCategory/${services.length}',
                                style: TextStyle(
                                  color: colorScheme.onSurfaceVariant,
                                  fontSize: 12,
                                ),
                              ),
                              const SizedBox(width: 8),
                              Checkbox(
                                value: allSelectedInCategory
                                    ? true
                                    : someSelectedInCategory
                                    ? null
                                    : false,
                                tristate: true,
                                onChanged: (checked) {
                                  setState(() {
                                    if (checked == true || checked == null) {
                                      for (final s in services) {
                                        _selected.add(s.id);
                                      }
                                    } else {
                                      for (final s in services) {
                                        _selected.remove(s.id);
                                      }
                                    }
                                  });
                                },
                              ),
                            ],
                          ),
                        ),
                      ),
                      if (isExpanded)
                        ...services.map((service) {
                          final isSelected = _selected.contains(service.id);
                          return ListTile(
                            dense: true,
                            contentPadding: const EdgeInsets.only(
                              left: 40,
                              right: 16,
                            ),
                            title: Text(service.name),
                            subtitle: service.price != null
                                ? Text(
                                    '‚Ç¨${service.price!.toStringAsFixed(2)}',
                                    style: TextStyle(
                                      color: colorScheme.onSurfaceVariant,
                                      fontSize: 12,
                                    ),
                                  )
                                : null,
                            trailing: Checkbox(
                              value: isSelected,
                              onChanged: (checked) {
                                setState(() {
                                  if (checked == true) {
                                    _selected.add(service.id);
                                  } else {
                                    _selected.remove(service.id);
                                  }
                                });
                              },
                            ),
                            onTap: () {
                              setState(() {
                                if (isSelected) {
                                  _selected.remove(service.id);
                                } else {
                                  _selected.add(service.id);
                                }
                              });
                            },
                          );
                        }),
                    ],
                  );
                },
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: Text(l10n.actionCancel),
        ),
        FilledButton(
          onPressed: () => Navigator.of(context).pop(_selected),
          child: Text(l10n.actionApply),
        ),
      ],
    );
  }
}

class _CategoryDisplayItem {
  final int id;
  final String name;
  const _CategoryDisplayItem({required this.id, required this.name});
}

class _MultiSelectDialog<T> extends StatefulWidget {
  const _MultiSelectDialog({
    super.key,
    required this.title,
    required this.items,
    required this.selected,
  });

  final String title;
  final Map<T, String> items;
  final Set<T> selected;

  @override
  State<_MultiSelectDialog<T>> createState() => _MultiSelectDialogState<T>();
}

class _MultiSelectDialogState<T> extends State<_MultiSelectDialog<T>> {
  late Set<T> _selected;

  @override
  void initState() {
    super.initState();
    _selected = Set<T>.from(widget.selected);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;

    return AlertDialog(
      title: Text(widget.title),
      content: SizedBox(
        width: 300,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: widget.items.entries.map((entry) {
            final isSelected = _selected.contains(entry.key);
            return CheckboxListTile(
              title: Text(entry.value),
              value: isSelected,
              onChanged: (checked) {
                setState(() {
                  if (checked == true) {
                    _selected.add(entry.key);
                  } else {
                    _selected.remove(entry.key);
                  }
                });
              },
            );
          }).toList(),
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: Text(l10n.actionCancel),
        ),
        FilledButton(
          onPressed: () => Navigator.of(context).pop(_selected),
          child: Text(l10n.actionApply),
        ),
      ],
    );
  }
}

// ============================================================================
// Sort Controls
// ============================================================================

class _SortControls extends ConsumerWidget {
  final BookingsListFilters filters;
  final VoidCallback onChanged;

  const _SortControls({required this.filters, required this.onChanged});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Material(
          color: Colors.transparent,
          child: InkWell(
            borderRadius: BorderRadius.circular(8),
            onTap: () {},
            child: Container(
              height: 36,
              padding: const EdgeInsets.symmetric(horizontal: 12),
              decoration: BoxDecoration(
                border: Border.all(color: colorScheme.outline),
                borderRadius: BorderRadius.circular(8),
              ),
              child: DropdownButtonHideUnderline(
                child: DropdownButton<String>(
                  value: filters.sortBy,
                  isDense: true,
                  icon: Icon(
                    Icons.arrow_drop_down,
                    color: colorScheme.onSurfaceVariant,
                  ),
                  style: Theme.of(context).textTheme.bodyMedium,
                  items: [
                    DropdownMenuItem(
                      value: 'appointment',
                      child: Text(l10n.bookingsListSortByAppointment),
                    ),
                    DropdownMenuItem(
                      value: 'created',
                      child: Text(l10n.bookingsListSortByCreated),
                    ),
                  ],
                  onChanged: (value) {
                    if (value != null) {
                      ref
                          .read(bookingsListFiltersProvider.notifier)
                          .setSortBy(value);
                      onChanged();
                    }
                  },
                ),
              ),
            ),
          ),
        ),
        const SizedBox(width: 4),
        Material(
          color: Colors.transparent,
          child: InkWell(
            borderRadius: BorderRadius.circular(8),
            onTap: () {
              ref.read(bookingsListFiltersProvider.notifier).toggleSortOrder();
              onChanged();
            },
            child: Tooltip(
              message: filters.sortOrder == 'asc'
                  ? l10n.bookingsListSortAsc
                  : l10n.bookingsListSortDesc,
              child: Container(
                height: 36,
                width: 36,
                decoration: BoxDecoration(
                  border: Border.all(color: colorScheme.outline),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Icon(
                  filters.sortOrder == 'asc'
                      ? Icons.arrow_upward
                      : Icons.arrow_downward,
                  size: 18,
                ),
              ),
            ),
          ),
        ),
      ],
    );
  }
}

// ============================================================================
// Status Chip
// ============================================================================

class _StatusChip extends StatelessWidget {
  final String status;

  const _StatusChip({required this.status});

  @override
  Widget build(BuildContext context) {
    Color backgroundColor;
    Color textColor;

    switch (status) {
      case 'confirmed':
        backgroundColor = Colors.green.shade100;
        textColor = Colors.green.shade800;
      case 'cancelled':
        backgroundColor = Colors.red.shade100;
        textColor = Colors.red.shade800;
      case 'completed':
        backgroundColor = Colors.blue.shade100;
        textColor = Colors.blue.shade800;
      case 'no_show':
        backgroundColor = Colors.orange.shade100;
        textColor = Colors.orange.shade800;
      case 'pending':
        backgroundColor = Colors.amber.shade100;
        textColor = Colors.amber.shade800;
      case 'replaced':
        backgroundColor = Colors.grey.shade200;
        textColor = Colors.grey.shade800;
      default:
        backgroundColor = Colors.grey.shade100;
        textColor = Colors.grey.shade800;
    }

    String label;
    switch (status) {
      case 'confirmed':
        label = context.l10n.bookingsListStatusConfirmed;
      case 'cancelled':
        label = context.l10n.bookingsListStatusCancelled;
      case 'completed':
        label = context.l10n.bookingsListStatusCompleted;
      case 'no_show':
        label = context.l10n.bookingsListStatusNoShow;
      case 'pending':
        label = context.l10n.bookingsListStatusPending;
      case 'replaced':
        label = context.l10n.bookingsListStatusReplaced;
      default:
        label = status;
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(4),
      ),
      child: Text(
        label,
        style: TextStyle(
          color: textColor,
          fontSize: 12,
          fontWeight: FontWeight.w500,
        ),
      ),
    );
  }
}

// ============================================================================
// Booking Card (Mobile)
// ============================================================================

class _BookingCard extends StatelessWidget {
  final BookingListItem booking;
  final VoidCallback onHistory;
  final VoidCallback onView;
  final VoidCallback onCancel;
  final bool canManageBookings;
  final bool showStatus;

  const _BookingCard({
    required this.booking,
    required this.onHistory,
    required this.onView,
    required this.onCancel,
    required this.canManageBookings,
    this.showStatus = true,
  });

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final dateFormat = DateFormat('EEE dd/MM HH:mm', 'it_IT');

    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      child: InkWell(
        onTap: booking.status != 'cancelled' ? onView : null,
        borderRadius: BorderRadius.circular(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Padding(
              padding: const EdgeInsets.fromLTRB(12, 12, 12, 0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      if (booking.source == 'online' ||
                          booking.source == 'onlinestaff')
                        Padding(
                          padding: const EdgeInsets.only(right: 6),
                          child: Tooltip(
                            message: booking.sourceLabel(context),
                            child: Icon(
                              booking.sourceIcon,
                              size: 18,
                              color: booking.source == 'onlinestaff'
                                  ? Colors.red
                                  : Theme.of(context).colorScheme.primary,
                            ),
                          ),
                        ),
                      Expanded(
                        child: Text(
                          booking.firstStartTime != null
                              ? dateFormat.format(booking.firstStartTime!)
                              : '-',
                          style: Theme.of(context).textTheme.titleMedium
                              ?.copyWith(fontWeight: FontWeight.w600),
                        ),
                      ),
                      if (showStatus) _StatusChip(status: booking.status),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Row(
                    children: [
                      const Icon(Icons.person_outline, size: 16),
                      const SizedBox(width: 4),
                      Expanded(
                        child: Text(
                          booking.clientName ?? l10n.bookingsListNoClient,
                          style: TextStyle(
                            fontStyle: booking.clientName == null
                                ? FontStyle.italic
                                : null,
                          ),
                        ),
                      ),
                    ],
                  ),
                  if (booking.serviceNames != null) ...[
                    const SizedBox(height: 4),
                    Row(
                      children: [
                        const Icon(Icons.category_outlined, size: 16),
                        const SizedBox(width: 4),
                        Expanded(
                          child: Text(
                            booking.serviceNames!,
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                            style: Theme.of(context).textTheme.bodySmall,
                          ),
                        ),
                      ],
                    ),
                  ],
                  if (booking.staffNames != null) ...[
                    const SizedBox(height: 4),
                    Row(
                      children: [
                        const Icon(Icons.person_pin, size: 16),
                        const SizedBox(width: 4),
                        Expanded(
                          child: Text(
                            booking.staffNames!,
                            style: Theme.of(context).textTheme.bodySmall,
                          ),
                        ),
                      ],
                    ),
                  ],
                ],
              ),
            ),
            Divider(
              height: 16,
              indent: 0,
              endIndent: 0,
              color: Theme.of(context).colorScheme.outline.withOpacity(0.2),
            ),
            Padding(
              padding: const EdgeInsets.fromLTRB(12, 0, 12, 12),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    '‚Ç¨ ${booking.totalPrice.toStringAsFixed(2)}',
                    style: Theme.of(context).textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  Row(
                    children: [
                      IconButton(
                        icon: const Icon(Icons.history),
                        onPressed: onHistory,
                        tooltip: l10n.bookingHistoryTitle,
                        iconSize: 20,
                      ),
                      if (booking.status != 'cancelled')
                        IconButton(
                          icon: const Icon(Icons.visibility),
                          onPressed: onView,
                          tooltip: l10n.bookingsListActionView,
                          iconSize: 20,
                        ),
                      if (canManageBookings && booking.status != 'cancelled')
                        IconButton(
                          icon: Icon(
                            Icons.cancel,
                            color: Theme.of(context).colorScheme.error,
                          ),
                          onPressed: onCancel,
                          tooltip: l10n.bookingsListActionCancel,
                          iconSize: 20,
                        ),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/bookings_list/widgets/bookings_list_header.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '/app/providers/form_factor_provider.dart';
import '/app/widgets/agenda_control_components.dart';
import '/core/l10n/l10_extension.dart';
import '../providers/bookings_list_filter_provider.dart';

/// Header widget for BookingsList screen with period controls only (title and refresh are in AppBar).
class BookingsListHeader extends ConsumerWidget {
  const BookingsListHeader({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final formFactor = ref.watch(formFactorProvider);
    final isCompact = formFactor != AppFormFactor.desktop;
    final filterState = ref.watch(bookingsListFilterProvider);
    final filterNotifier = ref.read(bookingsListFilterProvider.notifier);

    return Container(
      alignment: Alignment.centerLeft,
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: colorScheme.surface,
        border: Border(
          bottom: BorderSide(color: colorScheme.outline.withOpacity(0.2)),
        ),
      ),
      child: _BookingsListControls(
        selectedPreset: filterState.selectedPreset,
        startDate: filterState.startDate,
        endDate: filterState.endDate,
        isCompact: isCompact,
        onPresetChanged: (preset) {
          if (preset == 'custom') {
            _showDateRangePicker(context, ref);
          } else {
            filterNotifier.applyPreset(preset);
          }
        },
        onDateRangeSelected: () => _showDateRangePicker(context, ref),
      ),
    );
  }

  Future<void> _showDateRangePicker(BuildContext context, WidgetRef ref) async {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final l10n = context.l10n;
    final filterState = ref.read(bookingsListFilterProvider);

    final picked = await showDateRangePicker(
      context: context,
      firstDate: DateTime(2020),
      lastDate: DateTime.now().add(const Duration(days: 365)),
      initialDateRange: DateTimeRange(
        start: filterState.startDate,
        end: filterState.endDate,
      ),
      saveText: l10n.actionApply,
      builder: (context, child) {
        return Theme(
          data: theme.copyWith(
            colorScheme: colorScheme.copyWith(
              onPrimary: colorScheme.onPrimary,
              onSurface: colorScheme.onSurface,
            ),
            datePickerTheme: DatePickerThemeData(
              rangeSelectionBackgroundColor: colorScheme.primary.withOpacity(
                0.2,
              ),
              dayForegroundColor: WidgetStateProperty.resolveWith((states) {
                if (states.contains(WidgetState.selected)) {
                  return colorScheme.onPrimary;
                }
                if (states.contains(WidgetState.disabled)) {
                  return colorScheme.onSurface.withOpacity(0.38);
                }
                return colorScheme.onSurface;
              }),
              dayBackgroundColor: WidgetStateProperty.resolveWith((states) {
                if (states.contains(WidgetState.selected)) {
                  return colorScheme.primary;
                }
                return null;
              }),
            ),
          ),
          child: child!,
        );
      },
    );

    if (picked != null) {
      ref
          .read(bookingsListFilterProvider.notifier)
          .setDateRange(picked.start, picked.end);
    }
  }
}

class _BookingsListControls extends StatelessWidget {
  const _BookingsListControls({
    required this.selectedPreset,
    required this.startDate,
    required this.endDate,
    required this.isCompact,
    required this.onPresetChanged,
    required this.onDateRangeSelected,
  });

  final String selectedPreset;
  final DateTime startDate;
  final DateTime endDate;
  final bool isCompact;
  final ValueChanged<String> onPresetChanged;
  final VoidCallback onDateRangeSelected;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final dateFormat = DateFormat('dd/MM/yy');

    return Wrap(
      spacing: 12,
      runSpacing: 8,
      crossAxisAlignment: WrapCrossAlignment.center,
      children: [
        // Preset dropdown
        _PresetDropdown(value: selectedPreset, onChanged: onPresetChanged),

        // Date range display - always visible
        Material(
          color: Colors.transparent,
          child: InkWell(
            onTap: onDateRangeSelected,
            borderRadius: kAgendaPillRadius,
            child: Container(
              height: kAgendaControlHeight,
              padding: const EdgeInsets.symmetric(
                horizontal: kAgendaControlHorizontalPadding,
              ),
              decoration: BoxDecoration(
                border: Border.all(color: Colors.grey.withOpacity(0.35)),
                borderRadius: kAgendaPillRadius,
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(
                    Icons.calendar_today,
                    size: 16,
                    color: colorScheme.primary,
                  ),
                  const SizedBox(width: 8),
                  Text(
                    '${dateFormat.format(startDate)} - ${dateFormat.format(endDate)}',
                    style: theme.textTheme.bodyMedium,
                  ),
                ],
              ),
            ),
          ),
        ),
      ],
    );
  }
}

class _PresetDropdown extends StatelessWidget {
  const _PresetDropdown({required this.value, required this.onChanged});

  final String value;
  final ValueChanged<String> onChanged;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    return Container(
      height: kAgendaControlHeight,
      padding: const EdgeInsets.symmetric(
        horizontal: kAgendaControlHorizontalPadding,
      ),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.grey.withOpacity(0.35)),
        borderRadius: kAgendaPillRadius,
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: value,
          isDense: true,
          icon: const Icon(Icons.arrow_drop_down),
          style: theme.textTheme.bodyMedium,
          onChanged: (v) {
            if (v != null) onChanged(v);
          },
          items: [
            DropdownMenuItem(
              value: 'custom',
              child: Text(l10n.reportsPresetCustom),
            ),
            DropdownMenuItem(
              value: 'today',
              child: Text(l10n.reportsPresetToday),
            ),
            DropdownMenuItem(
              value: 'month',
              child: Text(l10n.reportsPresetMonth),
            ),
            DropdownMenuItem(
              value: 'quarter',
              child: Text(l10n.reportsPresetQuarter),
            ),
            DropdownMenuItem(
              value: 'semester',
              child: Text(l10n.reportsPresetSemester),
            ),
            DropdownMenuItem(
              value: 'year',
              child: Text(l10n.reportsPresetYear),
            ),
            DropdownMenuItem(
              value: 'last_month',
              child: Text(l10n.reportsPresetLastMonth),
            ),
            DropdownMenuItem(
              value: 'last_3_months',
              child: Text(l10n.reportsPresetLast3Months),
            ),
            DropdownMenuItem(
              value: 'last_6_months',
              child: Text(l10n.reportsPresetLast6Months),
            ),
            DropdownMenuItem(
              value: 'last_year',
              child: Text(l10n.reportsPresetLastYear),
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/auth/providers/auth_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/user.dart';
import '../../../core/network/api_client.dart';
import '../../../core/network/network_providers.dart';
import '../../../core/services/preferences_service.dart';
import '../data/auth_repository.dart';
import '../domain/auth_state.dart';

/// Provider per il repository di autenticazione.
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return AuthRepository(apiClient);
});

/// Provider per lo stato di autenticazione.
/// Gestisce il ciclo di vita dell'autenticazione nel gestionale.
final authProvider = NotifierProvider<AuthNotifier, AuthState>(
  AuthNotifier.new,
);

/// Notifier per la gestione dell'autenticazione.
class AuthNotifier extends Notifier<AuthState> {
  static bool _sessionRestored = false;
  static AuthState? _lastState;

  @override
  AuthState build() {
    // Se abbiamo gi√† uno stato salvato (es. errore), mantienilo
    if (_lastState != null && _lastState!.status == AuthStatus.error) {
      final savedState = _lastState!;
      _lastState = null; // Consuma lo stato salvato
      return savedState;
    }

    // Tenta ripristino sessione solo al primo avvio dell'app
    if (!_sessionRestored) {
      _sessionRestored = true;
      _tryRestoreSession();
    }
    return AuthState.initial();
  }

  /// Reset per testing o logout completo
  static void resetSessionFlag() {
    _sessionRestored = false;
    _lastState = null;
  }

  AuthRepository get _repository => ref.read(authRepositoryProvider);

  /// Tenta di ripristinare la sessione da refresh token salvato.
  Future<void> _tryRestoreSession() async {
    state = AuthState.loading();
    try {
      final user = await _repository.tryRestoreSession();
      if (user != null) {
        state = AuthState.authenticated(user);
      } else {
        state = AuthState.unauthenticated();
      }
    } catch (e) {
      state = AuthState.unauthenticated();
    }
  }

  /// Login con email e password.
  /// Ritorna true se il login ha successo, false altrimenti.
  Future<bool> login({required String email, required String password}) async {
    state = AuthState.loading();
    try {
      final user = await _repository.login(email: email, password: password);
      state = AuthState.authenticated(user);
      return true;
    } on ApiException catch (e) {
      final detailsStr = e.details is Map ? (e.details as Map).entries.map((entry) => '${entry.key}: ${entry.value}').join(', ') : null;
      state = AuthState.error(e.message, code: e.code, details: detailsStr);
      return false;
    } catch (e) {
      state = AuthState.error(e.toString(), code: 'network_error', details: e.runtimeType.toString());
      return false;
    }
  }

  /// Logout dell'utente corrente.
  /// Se silent=true, non fa chiamata API (per sessione gi√† scaduta)
  /// Se clearPreferences=true, pulisce tutte le preferenze salvate
  Future<void> logout({
    bool silent = false,
    bool clearPreferences = false,
  }) async {
    if (!silent) {
      try {
        await _repository.logout();
      } catch (_) {
        // Ignora errori durante logout (es. token gi√† invalido)
      }
    }

    // Pulisce le preferenze se richiesto
    if (clearPreferences) {
      try {
        await ref.read(preferencesServiceProvider).clearAll();
      } catch (_) {
        // Ignora errori durante pulizia preferenze
      }
    }

    state = AuthState.unauthenticated();
  }

  /// Pulisce l'errore corrente.
  void clearError() {
    state = state.copyWith(clearError: true);
  }

  /// Verifica se l'utente √® autenticato.
  bool get isAuthenticated => state.isAuthenticated;

  /// Ritorna l'utente corrente (se autenticato).
  User? get currentUser => state.user as User?;

  /// Aggiorna il profilo dell'utente corrente.
  Future<void> updateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
  }) async {
    final updatedUser = await _repository.updateProfile(
      firstName: firstName,
      lastName: lastName,
      email: email,
      phone: phone,
    );
    state = AuthState.authenticated(updatedUser);
  }

  /// Verifica se un token di reset √® valido.
  /// Lancia eccezione se il token √® invalido o scaduto.
  Future<void> verifyResetToken(String token) async {
    await _repository.verifyResetToken(token);
  }

  /// Richiede il reset della password (invia email con link).
  /// Ritorna sempre true per non rivelare se l'email esiste.
  Future<bool> forgotPassword({required String email}) async {
    try {
      await _repository.forgotPassword(email: email);
      return true;
    } catch (e) {
      // Anche in caso di errore, ritorna true per sicurezza
      return true;
    }
  }

  /// Reset password con token (da email di invito/reset).
  Future<void> resetPasswordWithToken({
    required String token,
    required String newPassword,
  }) async {
    await _repository.resetPasswordWithToken(
      token: token,
      newPassword: newPassword,
    );
  }

  /// Cambia password utente autenticato.
  /// Ritorna true se successo, false se errore.
  Future<bool> changePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    try {
      await _repository.changePassword(
        currentPassword: currentPassword,
        newPassword: newPassword,
      );
      return true;
    } catch (e) {
      return false;
    }
  }
}
--- FILE: lib/features/auth/providers/current_business_user_provider.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/network/network_providers.dart';
import '../../agenda/providers/business_providers.dart';
import '../../business/providers/superadmin_selected_business_provider.dart';
import 'auth_provider.dart';

/// Dati del contesto business dell'utente corrente.
/// Contiene scope_type e location_ids per il filtro permessi.
class BusinessUserContext {
  final int userId;
  final int businessId;
  final String role;
  final String scopeType;
  final List<int> locationIds;
  final int? staffId;
  final bool isSuperadmin;
  final bool canManageBookings;
  final bool canManageClients;
  final bool canManageServices;
  final bool canManageStaff;
  final bool canViewReports;

  const BusinessUserContext({
    required this.userId,
    required this.businessId,
    required this.role,
    required this.scopeType,
    required this.locationIds,
    required this.staffId,
    required this.isSuperadmin,
    required this.canManageBookings,
    required this.canManageClients,
    required this.canManageServices,
    required this.canManageStaff,
    required this.canViewReports,
  });

  /// Indica se l'utente ha accesso a tutte le location del business.
  bool get hasBusinessScope => scopeType == 'business';

  /// Indica se l'utente ha accesso limitato a specifiche location.
  bool get hasLocationScope => scopeType == 'locations';

  /// Indica se l'utente √® uno staff (ruolo staff con staffId associato).
  bool get isStaffRole => role == 'staff' && staffId != null;

  factory BusinessUserContext.fromJson(Map<String, dynamic> json) {
    final role = (json['role'] as String? ?? 'staff').trim().toLowerCase();
    final permissions = json['permissions'];
    final defaultCanManageBookings =
        role == 'owner' ||
        role == 'admin' ||
        role == 'manager' ||
        role == 'staff';
    final defaultCanManageClients =
        role == 'owner' || role == 'admin' || role == 'manager';
    final defaultCanManageServices = role == 'owner' || role == 'admin';
    final defaultCanManageStaff = role == 'owner' || role == 'admin';
    final defaultCanViewReports = role == 'owner' || role == 'admin';
    final canManageBookings = permissions is Map
        ? _toBool(
            permissions['can_manage_bookings'],
            fallback: defaultCanManageBookings,
          )
        : defaultCanManageBookings;
    final canManageClients = permissions is Map
        ? _toBool(
            permissions['can_manage_clients'],
            fallback: defaultCanManageClients,
          )
        : defaultCanManageClients;
    final canManageServices = permissions is Map
        ? _toBool(
            permissions['can_manage_services'],
            fallback: defaultCanManageServices,
          )
        : defaultCanManageServices;
    final canManageStaff = permissions is Map
        ? _toBool(
            permissions['can_manage_staff'],
            fallback: defaultCanManageStaff,
          )
        : defaultCanManageStaff;
    final canViewReports = permissions is Map
        ? _toBool(
            permissions['can_view_reports'],
            fallback: defaultCanViewReports,
          )
        : defaultCanViewReports;
    return BusinessUserContext(
      userId: json['user_id'] as int,
      businessId: json['business_id'] as int,
      role: role,
      scopeType: json['scope_type'] as String? ?? 'business',
      locationIds:
          (json['location_ids'] as List<dynamic>?)
              ?.map((e) => e as int)
              .toList() ??
          [],
      staffId: json['staff_id'] as int?,
      isSuperadmin: json['is_superadmin'] as bool? ?? false,
      canManageBookings: canManageBookings,
      canManageClients: canManageClients,
      canManageServices: canManageServices,
      canManageStaff: canManageStaff,
      canViewReports: canViewReports,
    );
  }

  static bool _toBool(dynamic value, {required bool fallback}) {
    if (value is bool) return value;
    if (value is int) return value == 1;
    if (value is String) {
      final normalized = value.trim().toLowerCase();
      if (normalized == '1' || normalized == 'true') return true;
      if (normalized == '0' || normalized == 'false') return false;
    }
    return fallback;
  }
}

bool _isContextForCurrentBusiness(
  BusinessUserContext? context,
  int currentBusinessId,
) {
  if (context == null) return false;
  if (context.isSuperadmin) return true;
  return currentBusinessId > 0 && context.businessId == currentBusinessId;
}

/// Provider asincrono per ottenere il contesto dell'utente corrente nel business.
/// Carica da API: GET /v1/me/business/{business_id}
final currentBusinessUserContextProvider = FutureProvider<BusinessUserContext?>(
  (ref) async {
    final authState = ref.watch(authProvider);
    if (!authState.isAuthenticated) return null;

    final user = authState.user;
    if (user == null) return null;

    // Superadmin: ritorna contesto con accesso completo senza chiamata API
    if (user.isSuperadmin) {
      return BusinessUserContext(
        userId: user.id,
        businessId: 0,
        role: 'superadmin',
        scopeType: 'business',
        locationIds: const [],
        staffId: null,
        isSuperadmin: true,
        canManageBookings: true,
        canManageClients: true,
        canManageServices: true,
        canManageStaff: true,
        canViewReports: true,
      );
    }

    // Ottieni il business ID corrente
    final isSuperadmin = user.isSuperadmin;
    final businessId = isSuperadmin
        ? ref.watch(superadminSelectedBusinessProvider)
        : ref.watch(currentBusinessIdProvider);
    if (businessId == null || businessId <= 0) return null;

    try {
      final apiClient = ref.watch(apiClientProvider);
      final data = await apiClient.getMyBusinessContext(businessId);
      return BusinessUserContext.fromJson(data);
    } catch (e) {
      debugPrint('Error loading business user context: $e');
      return null;
    }
  },
);

/// Provider per verificare se l'utente corrente ha accesso a una specifica location.
final hasLocationAccessProvider = Provider.family<bool, int>((ref, locationId) {
  final currentBusinessId = ref.watch(currentBusinessIdProvider);
  final contextAsync = ref.watch(currentBusinessUserContextProvider);
  final context = contextAsync.when(
    data: (data) => data,
    loading: () => null,
    error: (_, __) => null,
  );

  if (!_isContextForCurrentBusiness(context, currentBusinessId)) {
    return false;
  }

  // Scope business = accesso a tutte le location
  if (context!.hasBusinessScope) return true;

  // Scope locations = verifica se locationId √® nella lista
  return context.locationIds.contains(locationId);
});

/// Provider per ottenere la lista di location IDs accessibili all'utente corrente.
/// Ritorna null se ha accesso a tutte le location (scopeType='business').
final allowedLocationIdsProvider = Provider<List<int>?>((ref) {
  final currentBusinessId = ref.watch(currentBusinessIdProvider);
  final contextAsync = ref.watch(currentBusinessUserContextProvider);
  final context = contextAsync.when(
    data: (data) => data,
    loading: () => null,
    error: (_, __) => null,
  );

  if (!_isContextForCurrentBusiness(context, currentBusinessId)) {
    return null;
  }

  // Scope business = null significa accesso a tutte
  if (context!.hasBusinessScope) return null;

  // Scope locations = ritorna la lista specifica
  return context.locationIds;
});

// ============================================================================
// PROVIDER PERMESSI RUOLO
// ============================================================================

/// Ruolo dell'utente corrente nel business.
/// Ritorna 'staff' come default se non ancora caricato.
final currentUserRoleProvider = Provider<String>((ref) {
  final currentBusinessId = ref.watch(currentBusinessIdProvider);
  final contextAsync = ref.watch(currentBusinessUserContextProvider);
  return contextAsync.when(
    data: (data) => _isContextForCurrentBusiness(data, currentBusinessId)
        ? data!.role
        : 'staff',
    loading: () => 'staff',
    error: (_, __) => 'staff',
  );
});

/// Verifica se l'utente corrente √® admin o owner.
/// Admin pu√≤ gestire altri operatori.
final canManageOperatorsProvider = Provider<bool>((ref) {
  final currentBusinessId = ref.watch(currentBusinessIdProvider);
  final contextAsync = ref.watch(currentBusinessUserContextProvider);
  return contextAsync.when(
    data: (data) {
      if (!_isContextForCurrentBusiness(data, currentBusinessId)) return false;
      if (data!.isSuperadmin) return true;
      return data.role == 'admin' || data.role == 'owner';
    },
    loading: () => false,
    error: (_, __) => false,
  );
});

/// Verifica se l'utente corrente pu√≤ vedere tutti gli appuntamenti.
/// Admin e Manager vedono tutto, Staff vede solo i propri.
final canViewAllAppointmentsProvider = Provider<bool>((ref) {
  final currentBusinessId = ref.watch(currentBusinessIdProvider);
  final contextAsync = ref.watch(currentBusinessUserContextProvider);
  return contextAsync.when(
    data: (data) {
      if (!_isContextForCurrentBusiness(data, currentBusinessId)) return false;
      if (data!.isSuperadmin) return true;
      return data.role == 'admin' ||
          data.role == 'owner' ||
          data.role == 'manager' ||
          data.role == 'viewer';
    },
    loading: () => false,
    error: (_, __) => false,
  );
});

/// Verifica se l'utente corrente pu√≤ modificare impostazioni business.
/// Solo admin e owner.
final canManageBusinessSettingsProvider = Provider<bool>((ref) {
  final currentBusinessId = ref.watch(currentBusinessIdProvider);
  final contextAsync = ref.watch(currentBusinessUserContextProvider);
  return contextAsync.when(
    data: (data) {
      if (!_isContextForCurrentBusiness(data, currentBusinessId)) return false;
      if (data!.isSuperadmin) return true;
      return data.role == 'admin' || data.role == 'owner';
    },
    loading: () => false,
    error: (_, __) => false,
  );
});

/// Verifica se l'utente corrente pu√≤ gestire agenda/prenotazioni.
final currentUserCanManageBookingsProvider = Provider<bool>((ref) {
  final currentBusinessId = ref.watch(currentBusinessIdProvider);
  final contextAsync = ref.watch(currentBusinessUserContextProvider);
  return contextAsync.when(
    data: (data) {
      if (!_isContextForCurrentBusiness(data, currentBusinessId)) return false;
      if (data!.isSuperadmin) return true;
      return data.canManageBookings;
    },
    loading: () => false,
    error: (_, __) => false,
  );
});

/// Verifica se l'utente corrente pu√≤ gestire clienti.
final currentUserCanManageClientsProvider = Provider<bool>((ref) {
  final currentBusinessId = ref.watch(currentBusinessIdProvider);
  final contextAsync = ref.watch(currentBusinessUserContextProvider);
  return contextAsync.when(
    data: (data) {
      if (!_isContextForCurrentBusiness(data, currentBusinessId)) return false;
      if (data!.isSuperadmin) return true;
      return data.canManageClients;
    },
    loading: () => false,
    error: (_, __) => false,
  );
});

/// Verifica se l'utente corrente pu√≤ gestire servizi.
final currentUserCanManageServicesProvider = Provider<bool>((ref) {
  final currentBusinessId = ref.watch(currentBusinessIdProvider);
  final contextAsync = ref.watch(currentBusinessUserContextProvider);
  return contextAsync.when(
    data: (data) {
      if (!_isContextForCurrentBusiness(data, currentBusinessId)) return false;
      if (data!.isSuperadmin) return true;
      return data.canManageServices;
    },
    loading: () => false,
    error: (_, __) => false,
  );
});

/// Verifica se l'utente corrente pu√≤ visualizzare servizi.
/// Include chi pu√≤ gestire e il ruolo viewer.
final currentUserCanViewServicesProvider = Provider<bool>((ref) {
  final currentBusinessId = ref.watch(currentBusinessIdProvider);
  final contextAsync = ref.watch(currentBusinessUserContextProvider);
  return contextAsync.when(
    data: (data) {
      if (!_isContextForCurrentBusiness(data, currentBusinessId)) return false;
      if (data!.isSuperadmin) return true;
      return data.canManageServices || data.role == 'viewer';
    },
    loading: () => false,
    error: (_, __) => false,
  );
});

/// Verifica se l'utente corrente pu√≤ gestire staff.
final currentUserCanManageStaffProvider = Provider<bool>((ref) {
  final currentBusinessId = ref.watch(currentBusinessIdProvider);
  final contextAsync = ref.watch(currentBusinessUserContextProvider);
  return contextAsync.when(
    data: (data) {
      if (!_isContextForCurrentBusiness(data, currentBusinessId)) return false;
      if (data!.isSuperadmin) return true;
      return data.canManageStaff;
    },
    loading: () => false,
    error: (_, __) => false,
  );
});

/// Verifica se l'utente corrente pu√≤ visualizzare staff.
/// Include chi pu√≤ gestire e il ruolo viewer.
final currentUserCanViewStaffProvider = Provider<bool>((ref) {
  final currentBusinessId = ref.watch(currentBusinessIdProvider);
  final contextAsync = ref.watch(currentBusinessUserContextProvider);
  return contextAsync.when(
    data: (data) {
      if (!_isContextForCurrentBusiness(data, currentBusinessId)) return false;
      if (data!.isSuperadmin) return true;
      return data.canManageStaff ||
          data.role == 'manager' ||
          data.role == 'viewer' ||
          data.role == 'staff';
    },
    loading: () => true,
    error: (_, __) => false,
  );
});

/// Provider per ottenere lo staff_id dell'utente corrente (se √® uno staff).
/// Ritorna null se l'utente non √® associato a uno staff.
final currentUserStaffIdProvider = Provider<int?>((ref) {
  final currentBusinessId = ref.watch(currentBusinessIdProvider);
  final contextAsync = ref.watch(currentBusinessUserContextProvider);
  return contextAsync.when(
    data: (data) => _isContextForCurrentBusiness(data, currentBusinessId)
        ? data!.staffId
        : null,
    loading: () => null,
    error: (_, __) => null,
  );
});

/// Verifica se l'utente corrente pu√≤ visualizzare report in base ai permessi.
final currentUserCanViewReportsProvider = Provider<bool>((ref) {
  final currentBusinessId = ref.watch(currentBusinessIdProvider);
  final contextAsync = ref.watch(currentBusinessUserContextProvider);
  return contextAsync.when(
    data: (data) {
      if (!_isContextForCurrentBusiness(data, currentBusinessId)) return false;
      if (data!.isSuperadmin) return true;
      return data.canViewReports;
    },
    loading: () => false,
    error: (_, __) => false,
  );
});
--- FILE: lib/features/auth/data/auth_repository.dart ---
import '../../../core/models/user.dart';
import '../../../core/network/api_client.dart';

/// Repository per l'autenticazione nel gestionale.
/// Gestisce login, logout e recupero profilo utente.
class AuthRepository {
  final ApiClient _apiClient;

  AuthRepository(this._apiClient);

  /// Login utente con email e password.
  /// Ritorna l'utente autenticato.
  Future<User> login({required String email, required String password}) async {
    final data = await _apiClient.login(email, password);
    return User.fromJson(data['user'] as Map<String, dynamic>);
  }

  /// Logout utente corrente.
  /// Invalida la sessione e pulisce i token.
  Future<void> logout() async {
    await _apiClient.logout();
  }

  /// Recupera il profilo dell'utente corrente.
  Future<User> getCurrentUser() async {
    final data = await _apiClient.getMe();
    return User.fromJson(data);
  }

  /// Tenta di ripristinare la sessione da refresh token.
  /// Ritorna l'utente se la sessione √® valida, null altrimenti.
  Future<User?> tryRestoreSession() async {
    final data = await _apiClient.tryRestoreSession();
    if (data != null) {
      return User.fromJson(data);
    }
    return null;
  }

  /// Aggiorna il profilo dell'utente corrente.
  Future<User> updateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
  }) async {
    final data = await _apiClient.updateProfile(
      firstName: firstName,
      lastName: lastName,
      email: email,
      phone: phone,
    );
    return User.fromJson(data);
  }

  /// Verifica se un token di reset √® valido.
  /// Lancia eccezione se il token √® invalido o scaduto.
  Future<void> verifyResetToken(String token) async {
    await _apiClient.verifyResetToken(token);
  }

  /// Richiede il reset della password (invia email con link).
  /// L'API ritorna sempre successo per non rivelare se l'email esiste.
  Future<void> forgotPassword({required String email}) async {
    await _apiClient.forgotPassword(email);
  }

  /// Reset password con token (da email di invito/reset).
  Future<void> resetPasswordWithToken({
    required String token,
    required String newPassword,
  }) async {
    await _apiClient.resetPassword(token: token, password: newPassword);
  }

  /// Cambia password utente autenticato.
  Future<void> changePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    await _apiClient.changePassword(
      currentPassword: currentPassword,
      newPassword: newPassword,
    );
  }
}
--- FILE: lib/features/auth/domain/auth_state.dart ---
/// Stati possibili dell'autenticazione.
enum AuthStatus {
  /// Stato iniziale, verifica sessione in corso.
  initial,

  /// Operazione di login/logout in corso.
  loading,

  /// Utente autenticato.
  authenticated,

  /// Utente non autenticato.
  unauthenticated,

  /// Errore durante autenticazione.
  error,
}

/// Stato dell'autenticazione nel gestionale.
class AuthState {
  final AuthStatus status;
  final dynamic user;
  final String? errorMessage;
  final String? errorCode;
  final String? errorDetails;

  const AuthState({
    this.status = AuthStatus.initial,
    this.user,
    this.errorMessage,
    this.errorCode,
    this.errorDetails,
  });

  /// Verifica se l'utente √® autenticato.
  bool get isAuthenticated =>
      status == AuthStatus.authenticated && user != null;

  /// Verifica se √® in corso un'operazione.
  bool get isLoading => status == AuthStatus.loading;

  /// Verifica se √® nello stato iniziale.
  bool get isInitial => status == AuthStatus.initial;

  AuthState copyWith({
    AuthStatus? status,
    dynamic user,
    String? errorMessage,
    String? errorCode,
    String? errorDetails,
    bool clearUser = false,
    bool clearError = false,
  }) => AuthState(
    status: status ?? this.status,
    user: clearUser ? null : (user ?? this.user),
    errorMessage: clearError ? null : (errorMessage ?? this.errorMessage),
    errorCode: clearError ? null : (errorCode ?? this.errorCode),
    errorDetails: clearError ? null : (errorDetails ?? this.errorDetails),
  );

  factory AuthState.initial() => const AuthState(status: AuthStatus.initial);

  factory AuthState.loading() => const AuthState(status: AuthStatus.loading);

  factory AuthState.authenticated(dynamic user) =>
      AuthState(status: AuthStatus.authenticated, user: user);

  factory AuthState.unauthenticated() =>
      const AuthState(status: AuthStatus.unauthenticated);

  factory AuthState.error(String message, {String? code, String? details}) =>
      AuthState(status: AuthStatus.error, errorMessage: message, errorCode: code, errorDetails: details);
}
--- FILE: lib/features/auth/presentation/profile_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/l10_extension.dart';
import '../../../core/network/api_client.dart';
import '../../../core/utils/initials_utils.dart';
import '../../../core/widgets/app_buttons.dart';
import '../../../core/widgets/feedback_dialog.dart';
import '../../../core/widgets/local_loading_overlay.dart';
import '../providers/auth_provider.dart';

/// Schermata profilo utente.
/// Permette di visualizzare e modificare i propri dati (nome, cognome, email, telefono).
/// Note: This screen is displayed inside ScaffoldWithNavigation,
/// so it should NOT have its own Scaffold/AppBar.
class ProfileScreen extends ConsumerStatefulWidget {
  const ProfileScreen({super.key});

  @override
  ConsumerState<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends ConsumerState<ProfileScreen> {
  final _formKey = GlobalKey<FormState>();
  late final TextEditingController _firstNameController;
  late final TextEditingController _lastNameController;
  late final TextEditingController _emailController;
  late final TextEditingController _phoneController;

  bool _isLoading = false;
  bool _isEditing = false;

  @override
  void initState() {
    super.initState();
    final user = ref.read(authProvider).user;
    _firstNameController = TextEditingController(text: user?.firstName ?? '');
    _lastNameController = TextEditingController(text: user?.lastName ?? '');
    _emailController = TextEditingController(text: user?.email ?? '');
    _phoneController = TextEditingController(text: user?.phone ?? '');
  }

  @override
  void dispose() {
    _firstNameController.dispose();
    _lastNameController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    super.dispose();
  }

  Future<void> _saveChanges() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      await ref
          .read(authProvider.notifier)
          .updateProfile(
            firstName: _firstNameController.text.trim(),
            lastName: _lastNameController.text.trim(),
            email: _emailController.text.trim(),
            phone: _phoneController.text.trim().isEmpty
                ? null
                : _phoneController.text.trim(),
          );

      if (mounted) {
        setState(() {
          _isEditing = false;
          _isLoading = false;
        });
        FeedbackDialog.showSuccess(
          context,
          title: context.l10n.profileUpdateSuccess,
          message: '',
        );
      }
    } on ApiException catch (e) {
      setState(() => _isLoading = false);
      if (mounted) {
        FeedbackDialog.showError(
          context,
          title: context.l10n.errorTitle,
          message: e.message,
        );
      }
    } catch (e) {
      setState(() => _isLoading = false);
      if (mounted) {
        FeedbackDialog.showError(
          context,
          title: context.l10n.errorTitle,
          message: e.toString(),
        );
      }
    }
  }

  void _cancelEditing() {
    final user = ref.read(authProvider).user;
    setState(() {
      _firstNameController.text = user?.firstName ?? '';
      _lastNameController.text = user?.lastName ?? '';
      _emailController.text = user?.email ?? '';
      _phoneController.text = user?.phone ?? '';
      _isEditing = false;
    });
  }

  Future<void> _logout() async {
    await ref.read(authProvider.notifier).logout();
    if (mounted) {
      context.go('/login');
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final authState = ref.watch(authProvider);
    final user = authState.user;

    return Column(
      children: [
        // Content
        Expanded(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24),
            child: Center(
              child: ConstrainedBox(
                constraints: const BoxConstraints(maxWidth: 500),
                child: LocalLoadingOverlay(
                  isLoading: _isLoading,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      // Avatar
                      Center(
                        child: CircleAvatar(
                          radius: 50,
                          backgroundColor: colorScheme.primaryContainer,
                          child: Text(
                            _getInitials(user?.firstName, user?.lastName),
                            style: TextStyle(
                              fontSize: 32,
                              fontWeight: FontWeight.bold,
                              color: colorScheme.onPrimaryContainer,
                            ),
                          ),
                        ),
                      ),
                      const SizedBox(height: 8),

                      // Nome utente
                      Center(
                        child: Text(
                          '${user?.firstName ?? ''} ${user?.lastName ?? ''}'
                              .trim(),
                          style: theme.textTheme.titleLarge?.copyWith(
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                      Center(
                        child: Text(
                          user?.email ?? '',
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: colorScheme.onSurfaceVariant,
                          ),
                        ),
                      ),

                      // Badge superadmin
                      if (user?.isSuperadmin == true) ...[
                        const SizedBox(height: 8),
                        Center(
                          child: Container(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 12,
                              vertical: 4,
                            ),
                            decoration: BoxDecoration(
                              color: colorScheme.tertiaryContainer,
                              borderRadius: BorderRadius.circular(16),
                            ),
                            child: Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Icon(
                                  Icons.admin_panel_settings,
                                  size: 16,
                                  color: colorScheme.onTertiaryContainer,
                                ),
                                const SizedBox(width: 4),
                                Text(
                                  'Superadmin',
                                  style: TextStyle(
                                    color: colorScheme.onTertiaryContainer,
                                    fontWeight: FontWeight.w600,
                                    fontSize: 12,
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ),
                      ],

                      const SizedBox(height: 32),

                      // Form
                      Form(
                        key: _formKey,
                        child: Column(
                          children: [
                            // Nome
                            TextFormField(
                              controller: _firstNameController,
                              enabled: _isEditing,
                              decoration: InputDecoration(
                                labelText: l10n.authFirstName,
                                prefixIcon: const Icon(Icons.person_outline),
                              ),
                              textCapitalization: TextCapitalization.words,
                              validator: (value) {
                                if (value == null || value.trim().isEmpty) {
                                  return l10n.authRequiredField;
                                }
                                return null;
                              },
                            ),
                            const SizedBox(height: 16),

                            // Cognome
                            TextFormField(
                              controller: _lastNameController,
                              enabled: _isEditing,
                              decoration: InputDecoration(
                                labelText: l10n.authLastName,
                                prefixIcon: const Icon(Icons.person_outline),
                              ),
                              textCapitalization: TextCapitalization.words,
                            ),
                            const SizedBox(height: 16),

                            // Email
                            TextFormField(
                              controller: _emailController,
                              enabled: _isEditing,
                              decoration: InputDecoration(
                                labelText: l10n.authEmail,
                                prefixIcon: const Icon(Icons.email_outlined),
                                helperText: _isEditing
                                    ? l10n.profileEmailChangeWarning
                                    : null,
                              ),
                              keyboardType: TextInputType.emailAddress,
                              validator: (value) {
                                if (value == null || value.trim().isEmpty) {
                                  return l10n.authRequiredField;
                                }
                                final emailRegex = RegExp(
                                  r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                                );
                                if (!emailRegex.hasMatch(value.trim())) {
                                  return l10n.authInvalidEmail;
                                }
                                return null;
                              },
                            ),
                            const SizedBox(height: 16),

                            // Telefono
                            TextFormField(
                              controller: _phoneController,
                              enabled: _isEditing,
                              decoration: InputDecoration(
                                labelText: l10n.authPhone,
                                prefixIcon: const Icon(Icons.phone_outlined),
                              ),
                              keyboardType: TextInputType.phone,
                            ),
                          ],
                        ),
                      ),

                      if (!_isEditing) ...[
                        const SizedBox(height: 24),

                        Row(
                          children: [
                            Spacer(),
                            OutlinedButton(
                              onPressed: () =>
                                  setState(() => _isEditing = true),
                              child: Text(l10n.actionEdit),
                            ),
                            Spacer(),
                          ],
                        ),
                      ],
                      // Bottoni modifica
                      if (_isEditing) ...[
                        const SizedBox(height: 24),

                        Row(
                          children: [
                            Expanded(
                              child: OutlinedButton(
                                onPressed: _isLoading ? null : _cancelEditing,
                                child: Text(l10n.actionCancel),
                              ),
                            ),
                            const SizedBox(width: 16),
                            Expanded(
                              child: AppAsyncFilledButton(
                                onPressed: _isLoading ? null : _saveChanges,
                                isLoading: _isLoading,
                                child: Text(l10n.actionSave),
                              ),
                            ),
                          ],
                        ),
                      ],

                      const SizedBox(height: 36),

                      // Azioni account
                      _ActionTile(
                        icon: Icons.lock_outline,
                        title: l10n.profileChangePassword,
                        onTap: () => context.push('/change-password'),
                      ),

                      _ActionTile(
                        icon: Icons.logout,
                        title: l10n.authLogout,
                        onTap: _logout,
                        isDestructive: true,
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
      ],
    );
  }

  String _getInitials(String? firstName, String? lastName) {
    final fullName = '${firstName ?? ''} ${lastName ?? ''}'.trim();
    return InitialsUtils.fromName(fullName, maxChars: 2);
  }
}

/// Tile per le azioni del profilo
class _ActionTile extends StatelessWidget {
  const _ActionTile({
    required this.icon,
    required this.title,
    required this.onTap,
    this.isDestructive = false,
  });

  final IconData icon;
  final String title;
  final VoidCallback onTap;
  final bool isDestructive;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final color = isDestructive ? colorScheme.error : colorScheme.onSurface;

    return ListTile(
      leading: Icon(icon, color: color),
      title: Text(title, style: TextStyle(color: color)),
      trailing: Icon(Icons.chevron_right, color: colorScheme.onSurfaceVariant),
      onTap: onTap,
      contentPadding: EdgeInsets.zero,
    );
  }
}
--- FILE: lib/features/auth/presentation/change_password_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/l10_extension.dart';
import '../../../core/widgets/local_loading_overlay.dart';
import '../providers/auth_provider.dart';

/// Schermata per cambiare la password dell'utente autenticato.
class ChangePasswordScreen extends ConsumerStatefulWidget {
  const ChangePasswordScreen({super.key});

  @override
  ConsumerState<ChangePasswordScreen> createState() =>
      _ChangePasswordScreenState();
}

class _ChangePasswordScreenState extends ConsumerState<ChangePasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final _currentPasswordController = TextEditingController();
  final _newPasswordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  bool _obscureCurrentPassword = true;
  bool _obscureNewPassword = true;
  bool _obscureConfirmPassword = true;
  bool _isLoading = false;

  @override
  void dispose() {
    _currentPasswordController.dispose();
    _newPasswordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  Future<void> _handleChangePassword() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    final success = await ref.read(authProvider.notifier).changePassword(
          currentPassword: _currentPasswordController.text,
          newPassword: _newPasswordController.text,
        );

    setState(() => _isLoading = false);

    if (mounted) {
      if (success) {
        await showDialog<void>(
          context: context,
          builder: (ctx) => AlertDialog(
            title: const Text('Password modificata'),
            content: const Text(
              'La tua password √® stata modificata con successo.',
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(ctx).pop(),
                child: const Text('OK'),
              ),
            ],
          ),
        );
        if (mounted) {
          context.pop();
        }
      } else {
        await showDialog<void>(
          context: context,
          builder: (ctx) => AlertDialog(
            title: const Text('Errore'),
            content: const Text(
              'La password attuale non √® corretta.',
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(ctx).pop(),
                child: const Text('OK'),
              ),
            ],
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.pop(),
        ),
        title: const Text('Cambia password'),
      ),
      body: SafeArea(
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24),
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 400),
              child: LocalLoadingOverlay(
                isLoading: _isLoading,
                child: Form(
                  key: _formKey,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                    // Icon
                    Icon(
                      Icons.lock_reset,
                      size: 64,
                      color: theme.colorScheme.primary,
                    ),
                    const SizedBox(height: 32),

                    // Current password
                    TextFormField(
                      controller: _currentPasswordController,
                      obscureText: _obscureCurrentPassword,
                      textInputAction: TextInputAction.next,
                      decoration: InputDecoration(
                        labelText: 'Password attuale',
                        prefixIcon: const Icon(Icons.lock_outlined),
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscureCurrentPassword
                                ? Icons.visibility_outlined
                                : Icons.visibility_off_outlined,
                          ),
                          onPressed: () {
                            setState(
                              () => _obscureCurrentPassword =
                                  !_obscureCurrentPassword,
                            );
                          },
                        ),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return l10n.authRequiredField;
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),

                    // New password
                    TextFormField(
                      controller: _newPasswordController,
                      obscureText: _obscureNewPassword,
                      textInputAction: TextInputAction.next,
                      decoration: InputDecoration(
                        labelText: 'Nuova password',
                        prefixIcon: const Icon(Icons.lock_outlined),
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscureNewPassword
                                ? Icons.visibility_outlined
                                : Icons.visibility_off_outlined,
                          ),
                          onPressed: () {
                            setState(
                              () =>
                                  _obscureNewPassword = !_obscureNewPassword,
                            );
                          },
                        ),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return l10n.authRequiredField;
                        }
                        if (value.length < 8) {
                          return 'La password deve avere almeno 8 caratteri';
                        }
                        if (!RegExp(r'[A-Z]').hasMatch(value) ||
                            !RegExp(r'[a-z]').hasMatch(value) ||
                            !RegExp(r'[0-9]').hasMatch(value)) {
                          return 'Deve contenere maiuscole, minuscole e numeri';
                        }
                        if (value == _currentPasswordController.text) {
                          return 'La nuova password deve essere diversa';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),

                    // Confirm password
                    TextFormField(
                      controller: _confirmPasswordController,
                      obscureText: _obscureConfirmPassword,
                      textInputAction: TextInputAction.done,
                      decoration: InputDecoration(
                        labelText: 'Conferma nuova password',
                        prefixIcon: const Icon(Icons.lock_outlined),
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscureConfirmPassword
                                ? Icons.visibility_outlined
                                : Icons.visibility_off_outlined,
                          ),
                          onPressed: () {
                            setState(
                              () => _obscureConfirmPassword =
                                  !_obscureConfirmPassword,
                            );
                          },
                        ),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return l10n.authRequiredField;
                        }
                        if (value != _newPasswordController.text) {
                          return 'Le password non corrispondono';
                        }
                        return null;
                      },
                      onFieldSubmitted: (_) => _handleChangePassword(),
                    ),
                    const SizedBox(height: 32),

                    // Submit button
                      FilledButton(
                        onPressed: _isLoading ? null : _handleChangePassword,
                        child: Text(l10n.actionConfirm),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/auth/presentation/login_screen.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../app/providers/global_loading_provider.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../../core/services/credentials_provider.dart';
import '../../../core/utils/app_version.dart';
import '../../../core/widgets/feedback_dialog.dart';
import '../../../core/widgets/global_loading_overlay.dart';
import '../providers/auth_provider.dart';

/// Schermata di login per il gestionale.
/// Richiede autenticazione per accedere al sistema.
class LoginScreen extends ConsumerStatefulWidget {
  const LoginScreen({super.key, this.redirectTo});

  final String? redirectTo;

  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends ConsumerState<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _obscurePassword = true;
  bool _rememberMe = true;
  bool _isLoading = false;
  bool _credentialsLoaded = false;
  String? _errorMessage;

  String get _postLoginRoute {
    final redirect = widget.redirectTo;
    if (redirect != null && redirect.startsWith('/')) {
      return redirect;
    }
    return '/agenda';
  }

  @override
  void initState() {
    super.initState();
    _loadSavedCredentials();
  }

  Future<void> _loadSavedCredentials() async {
    // In debug mode, usa credenziali di test se non ci sono credenziali salvate
    if (kDebugMode && !_credentialsLoaded) {
      _emailController.text = 'dariolarosa@hotmail.com';
      _passwordController.text = 'Abc123@@';
    }

    try {
      final storage = ref.read(credentialsStorageProvider);
      final credentials = await storage.getSavedCredentials();

      if (credentials.email != null && credentials.password != null) {
        if (mounted) {
          setState(() {
            _emailController.text = credentials.email!;
            _passwordController.text = credentials.password!;
            _rememberMe = true;
            _credentialsLoaded = true;
          });
        }
      }
    } catch (e) {
      debugPrint('Error loading saved credentials: $e');
    }
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _handleLogin() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });
    ref.read(globalLoadingProvider.notifier).show();

    final email = _emailController.text.trim();
    final password = _passwordController.text.trim();

    try {
      final success = await ref
          .read(authProvider.notifier)
          .login(email: email, password: password);

      if (!mounted) return;

      if (success) {
        // Salva o cancella le credenziali in base alla scelta dell'utente
        final storage = ref.read(credentialsStorageProvider);
        if (_rememberMe) {
          await storage.saveCredentials(email, password);
        } else {
          await storage.clearCredentials();
        }

        if (!mounted) return;

        // Segnala al browser che l'autofill √® completato con successo
        // Questo triggera la richiesta di salvataggio credenziali
        TextInput.finishAutofillContext();
        context.go(_postLoginRoute);
      } else {
        final authState = ref.read(authProvider);
        final isNetwork = authState.errorCode == 'network_error';
        final details = authState.errorDetails;
        setState(() {
          _errorMessage = isNetwork
              ? '${context.l10n.authNetworkError}${details != null ? '\n[$details]' : ''}'
              : context.l10n.authLoginFailed;
        });
      }
    } catch (e) {
      if (!mounted) return;
      setState(() {
        _errorMessage = '${context.l10n.authNetworkError}\n[${e.runtimeType}]';
      });
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
      ref.read(globalLoadingProvider.notifier).hide();
    }
  }

  @override
  Widget build(BuildContext context) {
    // Osserva solo per redirect se autenticato
    ref.listen(authProvider, (prev, next) {
      if (next.isAuthenticated && mounted) {
        context.go(_postLoginRoute);
      }
    });

    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return GlobalLoadingOverlay(
      child: Scaffold(
        body: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24),
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 400),
              child: AutofillGroup(
                child: Form(
                  key: _formKey,
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      // Logo e titolo
                      Icon(
                        Icons.calendar_month_rounded,
                        size: 72,
                        color: colorScheme.primary,
                      ),
                      const SizedBox(height: 16),
                      Text(
                        l10n.appTitle,
                        style: theme.textTheme.headlineMedium?.copyWith(
                          fontWeight: FontWeight.bold,
                          color: colorScheme.primary,
                        ),
                        textAlign: TextAlign.center,
                      ),
                      const SizedBox(height: 8),
                      Text(
                        l10n.authLoginSubtitle,
                        style: theme.textTheme.bodyLarge?.copyWith(
                          color: colorScheme.onSurfaceVariant,
                        ),
                        textAlign: TextAlign.center,
                      ),
                      const SizedBox(height: 48),

                      // Email
                      TextFormField(
                        controller: _emailController,
                        keyboardType: TextInputType.emailAddress,
                        textInputAction: TextInputAction.next,
                        textCapitalization: TextCapitalization.none,
                        autocorrect: false,
                        enableSuggestions: true,
                        // Email + username per miglior compatibilit√† autofill Safari iOS
                        autofillHints: const [
                          AutofillHints.email,
                          AutofillHints.username,
                        ],
                        decoration: InputDecoration(
                          labelText: l10n.authEmail,
                          prefixIcon: const Icon(Icons.email_outlined),
                          border: const OutlineInputBorder(),
                        ),
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return l10n.authRequiredField;
                          }
                          if (!value.contains('@')) {
                            return l10n.authInvalidEmail;
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),

                      // Password
                      TextFormField(
                        controller: _passwordController,
                        obscureText: _obscurePassword,
                        textInputAction: TextInputAction.done,
                        enableSuggestions: false,
                        autocorrect: false,
                        autofillHints: const [AutofillHints.password],
                        onFieldSubmitted: (_) => _handleLogin(),
                        decoration: InputDecoration(
                          labelText: l10n.authPassword,
                          prefixIcon: const Icon(Icons.lock_outlined),
                          border: const OutlineInputBorder(),
                          suffixIcon: IconButton(
                            icon: Icon(
                              _obscurePassword
                                  ? Icons.visibility_outlined
                                  : Icons.visibility_off_outlined,
                            ),
                            onPressed: () {
                              setState(
                                () => _obscurePassword = !_obscurePassword,
                              );
                            },
                          ),
                        ),
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return l10n.authRequiredField;
                          }
                          if (value.length < 6) {
                            return l10n.authPasswordTooShort;
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 8),

                      // Remember me e forgot password
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Checkbox(
                                value: _rememberMe,
                                onChanged: (value) {
                                  setState(() => _rememberMe = value ?? true);
                                },
                              ),
                              Text(
                                l10n.authRememberMe,
                                style: theme.textTheme.bodyMedium,
                              ),
                            ],
                          ),
                          TextButton(
                            onPressed: () => _showForgotPasswordInfo(context),
                            child: Text(l10n.authForgotPassword),
                          ),
                        ],
                      ),
                      const SizedBox(height: 24),

                      // Errore
                      if (_errorMessage != null) ...[
                        Container(
                          padding: const EdgeInsets.all(12),
                          decoration: BoxDecoration(
                            color: colorScheme.error.withOpacity(0.1),
                            borderRadius: BorderRadius.circular(8),
                            border: Border.all(
                              color: colorScheme.error.withOpacity(0.3),
                            ),
                          ),
                          child: Row(
                            children: [
                              Icon(
                                Icons.error_outline,
                                color: colorScheme.error,
                                size: 20,
                              ),
                              const SizedBox(width: 12),
                              Expanded(
                                child: Text(
                                  _errorMessage!,
                                  style: TextStyle(color: colorScheme.error),
                                ),
                              ),
                            ],
                          ),
                        ),
                        const SizedBox(height: 16),
                      ],

                      // Bottone Login
                      FilledButton(
                        onPressed: _isLoading ? null : _handleLogin,
                        style: FilledButton.styleFrom(
                          padding: const EdgeInsets.symmetric(vertical: 16),
                        ),
                        child: Text(l10n.authLogin),
                      ),
                      const SizedBox(height: 32),

                      // Footer
                      Text(
                        l10n.authLoginFooter,
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: colorScheme.onSurfaceVariant,
                        ),
                        textAlign: TextAlign.center,
                      ),
                      const SizedBox(height: 8),
                      // Versione app
                      Text(
                        'v${getAppVersion()}',
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: colorScheme.onSurfaceVariant.withValues(
                            alpha: 0.6,
                          ),
                          fontSize: 11,
                        ),
                        textAlign: TextAlign.center,
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  void _showForgotPasswordInfo(BuildContext context) {
    final l10n = context.l10n;
    final emailController = TextEditingController();

    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: Text(l10n.authResetPasswordTitle),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(l10n.authResetPasswordMessage),
            const SizedBox(height: 16),
            TextField(
              controller: emailController,
              keyboardType: TextInputType.emailAddress,
              autofocus: true,
              decoration: InputDecoration(
                labelText: l10n.authEmail,
                prefixIcon: const Icon(Icons.email_outlined),
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(dialogContext).pop(),
            child: Text(l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () async {
              final email = emailController.text.trim();
              if (email.isEmpty) return;

              // Chiudi il dialog prima di fare la chiamata
              Navigator.of(dialogContext).pop();

              final success = await ref
                  .read(authProvider.notifier)
                  .forgotPassword(email: email);

              if (!context.mounted) return;

              if (success) {
                await FeedbackDialog.showSuccess(
                  context,
                  title: l10n.authResetPasswordTitle,
                  message: l10n.authResetPasswordSuccess,
                );
              } else {
                await FeedbackDialog.showError(
                  context,
                  title: l10n.errorTitle,
                  message: l10n.authResetPasswordError,
                );
              }
            },
            child: Text(l10n.authResetPasswordSend),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/auth/presentation/reset_password_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/l10_extension.dart';
import '../../../core/widgets/local_loading_overlay.dart';
import '../providers/auth_provider.dart';

/// Schermata per impostare nuova password da link email.
/// Usata per inviti admin e reset password dimenticata.
class ResetPasswordScreen extends ConsumerStatefulWidget {
  final String token;

  const ResetPasswordScreen({required this.token, super.key});

  @override
  ConsumerState<ResetPasswordScreen> createState() =>
      _ResetPasswordScreenState();
}

class _ResetPasswordScreenState extends ConsumerState<ResetPasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  bool _obscurePassword = true;
  bool _obscureConfirmPassword = true;
  bool _isLoading = false;

  // Stato per la verifica iniziale del token
  bool _isVerifyingToken = true;
  bool _tokenValid = false;

  @override
  void initState() {
    super.initState();
    _verifyToken();
  }

  Future<void> _verifyToken() async {
    try {
      await ref.read(authProvider.notifier).verifyResetToken(widget.token);
      if (mounted) {
        setState(() {
          _isVerifyingToken = false;
          _tokenValid = true;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isVerifyingToken = false;
          _tokenValid = false;
        });
        // Mostra dialog bloccante e poi redirect
        await showDialog<void>(
          context: context,
          barrierDismissible: false,
          builder: (ctx) => AlertDialog(
            title: const Text('Link non valido'),
            content: const Text(
              'Il link √® scaduto o √® gi√† stato utilizzato.\n\n'
              'Richiedi un nuovo invito al superadmin.',
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(ctx).pop(),
                child: const Text('Vai al login'),
              ),
            ],
          ),
        );
        if (mounted) {
          context.go('/login');
        }
      }
    }
  }

  @override
  void dispose() {
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  Future<void> _handleResetPassword() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      await ref
          .read(authProvider.notifier)
          .resetPasswordWithToken(
            token: widget.token,
            newPassword: _passwordController.text,
          );

      if (mounted) {
        await showDialog<void>(
          context: context,
          barrierDismissible: false,
          builder: (ctx) => AlertDialog(
            title: const Text('Password impostata'),
            content: const Text(
              'La tua password √® stata impostata con successo.\nOra puoi effettuare il login.',
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(ctx).pop(),
                child: const Text('OK'),
              ),
            ],
          ),
        );
        if (mounted) {
          context.go('/login');
        }
      }
    } catch (e) {
      if (mounted) {
        await showDialog<void>(
          context: context,
          builder: (ctx) => AlertDialog(
            title: const Text('Errore'),
            content: const Text(
              'Il link √® scaduto o non valido.\nRichiedi un nuovo invito al superadmin.',
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(ctx).pop(),
                child: const Text('OK'),
              ),
            ],
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    // Mostra loading mentre verifica il token
    if (_isVerifyingToken) {
      return Scaffold(
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const CircularProgressIndicator(),
              const SizedBox(height: 16),
              Text(
                'Verifica link in corso...',
                style: theme.textTheme.bodyLarge,
              ),
            ],
          ),
        ),
      );
    }

    // Se il token non √® valido, mostra schermata vuota (il dialog far√† redirect)
    if (!_tokenValid) {
      return const Scaffold(body: SizedBox.shrink());
    }

    // Token valido: mostra il form
    return Scaffold(
      body: SafeArea(
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24),
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 400),
              child: LocalLoadingOverlay(
                isLoading: _isLoading,
                child: Form(
                  key: _formKey,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                    // Icon
                    Icon(
                      Icons.lock_reset,
                      size: 64,
                      color: theme.colorScheme.primary,
                    ),
                    const SizedBox(height: 16),

                    // Title
                    Text(
                      'Imposta la tua password',
                      style: theme.textTheme.headlineSmall,
                      textAlign: TextAlign.center,
                    ),
                    const SizedBox(height: 8),

                    // Message
                    Text(
                      'Scegli una password sicura per accedere al tuo gestionale.',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                      textAlign: TextAlign.center,
                    ),
                    const SizedBox(height: 32),

                    // New password
                    TextFormField(
                      controller: _passwordController,
                      obscureText: _obscurePassword,
                      textInputAction: TextInputAction.next,
                      decoration: InputDecoration(
                        labelText: 'Nuova password',
                        prefixIcon: const Icon(Icons.lock_outlined),
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscurePassword
                                ? Icons.visibility_outlined
                                : Icons.visibility_off_outlined,
                          ),
                          onPressed: () {
                            setState(
                              () => _obscurePassword = !_obscurePassword,
                            );
                          },
                        ),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return l10n.authRequiredField;
                        }
                        if (value.length < 8) {
                          return 'La password deve avere almeno 8 caratteri';
                        }
                        if (!RegExp(r'[A-Z]').hasMatch(value) ||
                            !RegExp(r'[a-z]').hasMatch(value) ||
                            !RegExp(r'[0-9]').hasMatch(value)) {
                          return 'Deve contenere maiuscole, minuscole e numeri';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),

                    // Confirm password
                    TextFormField(
                      controller: _confirmPasswordController,
                      obscureText: _obscureConfirmPassword,
                      textInputAction: TextInputAction.done,
                      decoration: InputDecoration(
                        labelText: 'Conferma password',
                        prefixIcon: const Icon(Icons.lock_outlined),
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscureConfirmPassword
                                ? Icons.visibility_outlined
                                : Icons.visibility_off_outlined,
                          ),
                          onPressed: () {
                            setState(
                              () => _obscureConfirmPassword =
                                  !_obscureConfirmPassword,
                            );
                          },
                        ),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return l10n.authRequiredField;
                        }
                        if (value != _passwordController.text) {
                          return 'Le password non corrispondono';
                        }
                        return null;
                      },
                      onFieldSubmitted: (_) => _handleResetPassword(),
                    ),
                    const SizedBox(height: 32),

                    // Submit button
                    FilledButton(
                      onPressed: _isLoading ? null : _handleResetPassword,
                      child: const Text('Imposta password'),
                    ),

                    const SizedBox(height: 16),

                    // Back to login
                    TextButton(
                      onPressed: () => context.go('/login'),
                      child: const Text('Torna al login'),
                    ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/crm/providers/crm_providers.dart ---
import 'dart:async';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/network/network_providers.dart';
import '../../agenda/providers/business_providers.dart';
import '../../auth/providers/current_business_user_provider.dart';
import '../data/crm_repository.dart';
import '../domain/crm_models.dart';

final crmRepositoryProvider = Provider<CrmRepository>((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return CrmRepository(apiClient: apiClient);
});

class CrmClientsState {
  final List<CrmClient> clients;
  final bool hasMore;
  final bool loadingMore;
  final String searchQuery;
  final String statusFilter;
  final String sort;
  final int page;
  final int total;

  const CrmClientsState({
    this.clients = const [],
    this.hasMore = false,
    this.loadingMore = false,
    this.searchQuery = '',
    this.statusFilter = '',
    this.sort = 'last_visit_desc',
    this.page = 1,
    this.total = 0,
  });

  CrmClientsState copyWith({
    List<CrmClient>? clients,
    bool? hasMore,
    bool? loadingMore,
    String? searchQuery,
    String? statusFilter,
    String? sort,
    int? page,
    int? total,
  }) {
    return CrmClientsState(
      clients: clients ?? this.clients,
      hasMore: hasMore ?? this.hasMore,
      loadingMore: loadingMore ?? this.loadingMore,
      searchQuery: searchQuery ?? this.searchQuery,
      statusFilter: statusFilter ?? this.statusFilter,
      sort: sort ?? this.sort,
      page: page ?? this.page,
      total: total ?? this.total,
    );
  }
}

class CrmClientsNotifier extends AsyncNotifier<CrmClientsState> {
  Timer? _debounce;

  @override
  Future<CrmClientsState> build() async {
    final business = ref.watch(currentBusinessProvider);
    final canManage = ref.watch(currentUserCanManageClientsProvider);
    if (!canManage || business.id <= 0) {
      return const CrmClientsState();
    }

    final repo = ref.watch(crmRepositoryProvider);
    final page = await repo.getClients(business.id, page: 1, pageSize: 30);
    return CrmClientsState(
      clients: page.clients,
      hasMore: page.hasMore,
      total: page.total,
    );
  }

  Future<void> refresh() async {
    final current = state.value ?? const CrmClientsState();
    final business = ref.read(currentBusinessProvider);
    if (business.id <= 0) return;

    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repo = ref.read(crmRepositoryProvider);
      final page = await repo.getClients(
        business.id,
        q: current.searchQuery,
        status: current.statusFilter.isEmpty ? null : current.statusFilter,
        sort: current.sort,
        page: 1,
        pageSize: 30,
      );
      return current.copyWith(
        clients: page.clients,
        hasMore: page.hasMore,
        total: page.total,
        page: 1,
      );
    });
  }

  void setSearch(String query) {
    final current = state.value ?? const CrmClientsState();
    state = AsyncValue.data(current.copyWith(searchQuery: query));

    _debounce?.cancel();
    _debounce = Timer(const Duration(milliseconds: 300), () {
      refresh();
    });
  }

  Future<void> setStatusFilter(String status) async {
    final current = state.value ?? const CrmClientsState();
    state = AsyncValue.data(current.copyWith(statusFilter: status));
    await refresh();
  }

  Future<void> setSort(String sort) async {
    final current = state.value ?? const CrmClientsState();
    state = AsyncValue.data(current.copyWith(sort: sort));
    await refresh();
  }

  Future<void> loadMore() async {
    final current = state.value;
    final business = ref.read(currentBusinessProvider);
    if (current == null || !current.hasMore || current.loadingMore || business.id <= 0) return;

    state = AsyncValue.data(current.copyWith(loadingMore: true));

    try {
      final repo = ref.read(crmRepositoryProvider);
      final nextPage = current.page + 1;
      final page = await repo.getClients(
        business.id,
        q: current.searchQuery,
        status: current.statusFilter.isEmpty ? null : current.statusFilter,
        sort: current.sort,
        page: nextPage,
        pageSize: 30,
      );

      state = AsyncValue.data(
        current.copyWith(
          loadingMore: false,
          clients: [...current.clients, ...page.clients],
          hasMore: page.hasMore,
          page: nextPage,
          total: page.total,
        ),
      );
    } catch (_) {
      state = AsyncValue.data(current.copyWith(loadingMore: false));
    }
  }
}

final crmClientsProvider = AsyncNotifierProvider<CrmClientsNotifier, CrmClientsState>(
  CrmClientsNotifier.new,
);

final clientDetailProvider = FutureProvider.family<CrmClient, int>((ref, clientId) async {
  final businessId = ref.watch(currentBusinessIdProvider);
  if (businessId <= 0) throw Exception('Business not selected');
  return ref.watch(crmRepositoryProvider).getClientDetail(businessId, clientId);
});

final clientEventsProvider = FutureProvider.family<List<CrmEvent>, int>((ref, clientId) async {
  final businessId = ref.watch(currentBusinessIdProvider);
  if (businessId <= 0) return const [];
  return ref.watch(crmRepositoryProvider).getClientEvents(businessId, clientId);
});

final clientTasksProvider = FutureProvider.family<List<CrmTask>, int>((ref, clientId) async {
  final businessId = ref.watch(currentBusinessIdProvider);
  if (businessId <= 0) return const [];
  return ref.watch(crmRepositoryProvider).getClientTasks(businessId, clientId);
});

final clientTagsProvider = FutureProvider<List<CrmTag>>((ref) async {
  final businessId = ref.watch(currentBusinessIdProvider);
  if (businessId <= 0) return const [];
  return ref.watch(crmRepositoryProvider).getTags(businessId);
});

final overdueTasksProvider = FutureProvider<List<CrmTask>>((ref) async {
  final businessId = ref.watch(currentBusinessIdProvider);
  if (businessId <= 0) return const [];
  final clients = ref.watch(crmClientsProvider).value?.clients ?? const <CrmClient>[];
  if (clients.isEmpty) return const [];
  final tasks = await ref.watch(crmRepositoryProvider).getClientTasksForAll(businessId, clients);
  return tasks.where((t) => t.isOverdue).toList();
});

class ClientUpsertController extends AsyncNotifier<void> {
  @override
  Future<void> build() async {}

  Future<void> submit(Map<String, dynamic> payload, {int? clientId}) async {
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId <= 0) return;
    state = const AsyncLoading();
    state = await AsyncValue.guard(() async {
      await ref.read(crmRepositoryProvider).upsertClient(businessId, payload, clientId: clientId);
      ref.invalidate(crmClientsProvider);
    });
  }
}

final clientUpsertControllerProvider =
    AsyncNotifierProvider<ClientUpsertController, void>(ClientUpsertController.new);

class ClientMergeController extends AsyncNotifier<void> {
  @override
  Future<void> build() async {}

  Future<void> merge(int sourceClientId, int targetClientId) async {
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId <= 0) return;
    state = const AsyncLoading();
    state = await AsyncValue.guard(() async {
      await ref.read(crmRepositoryProvider).mergeClient(businessId, sourceClientId, targetClientId);
      ref.invalidate(crmClientsProvider);
    });
  }
}

final clientMergeControllerProvider =
    AsyncNotifierProvider<ClientMergeController, void>(ClientMergeController.new);

class ClientTaskController extends AsyncNotifier<void> {
  @override
  Future<void> build() async {}

  Future<void> create(int clientId, Map<String, dynamic> payload) async {
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId <= 0) return;
    state = const AsyncLoading();
    state = await AsyncValue.guard(() async {
      await ref.read(crmRepositoryProvider).createTask(businessId, clientId, payload);
      ref.invalidate(clientTasksProvider(clientId));
      ref.invalidate(overdueTasksProvider);
    });
  }

  Future<void> complete(int clientId, int taskId) async {
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId <= 0) return;
    state = const AsyncLoading();
    state = await AsyncValue.guard(() async {
      await ref.read(crmRepositoryProvider).completeTask(businessId, clientId, taskId);
      ref.invalidate(clientTasksProvider(clientId));
      ref.invalidate(overdueTasksProvider);
    });
  }

  Future<void> reopen(int clientId, int taskId) async {
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId <= 0) return;
    state = const AsyncLoading();
    state = await AsyncValue.guard(() async {
      await ref.read(crmRepositoryProvider).reopenTask(businessId, clientId, taskId);
      ref.invalidate(clientTasksProvider(clientId));
      ref.invalidate(overdueTasksProvider);
    });
  }
}

final clientTaskControllerProvider =
    AsyncNotifierProvider<ClientTaskController, void>(ClientTaskController.new);

class ClientTagController extends AsyncNotifier<void> {
  @override
  Future<void> build() async {}

  Future<void> create(String name, {String? color}) async {
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId <= 0) return;
    state = const AsyncLoading();
    state = await AsyncValue.guard(() async {
      await ref.read(crmRepositoryProvider).createTag(businessId, name, color: color);
      ref.invalidate(clientTagsProvider);
    });
  }

  Future<void> delete(int tagId, {bool force = false}) async {
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId <= 0) return;
    state = const AsyncLoading();
    state = await AsyncValue.guard(() async {
      await ref.read(crmRepositoryProvider).deleteTag(businessId, tagId, force: force);
      ref.invalidate(clientTagsProvider);
      ref.invalidate(crmClientsProvider);
    });
  }
}

final clientTagControllerProvider =
    AsyncNotifierProvider<ClientTagController, void>(ClientTagController.new);

class ClientConsentController extends AsyncNotifier<void> {
  @override
  Future<void> build() async {}

  Future<void> submit(int clientId, Map<String, dynamic> payload) async {
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId <= 0) return;

    state = const AsyncLoading();
    state = await AsyncValue.guard(() async {
      await ref.read(apiClientProvider).put(
            '/v1/businesses/$businessId/clients/$clientId/consents',
            data: payload,
          );
      ref.invalidate(clientDetailProvider(clientId));
    });
  }
}

final clientConsentControllerProvider =
    AsyncNotifierProvider<ClientConsentController, void>(ClientConsentController.new);

class ClientImportController extends AsyncNotifier<Map<String, dynamic>?> {
  @override
  Future<Map<String, dynamic>?> build() async => null;

  Future<void> preview({required String csv, required Map<String, dynamic> mapping}) async {
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId <= 0) return;

    state = const AsyncLoading();
    state = await AsyncValue.guard(
      () => ref.read(crmRepositoryProvider).importCsv(
            businessId,
            csv: csv,
            mapping: mapping,
            dryRun: true,
          ),
    );
  }

  Future<void> commit({required String csv, required Map<String, dynamic> mapping}) async {
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId <= 0) return;

    state = const AsyncLoading();
    state = await AsyncValue.guard(() async {
      final result = await ref.read(crmRepositoryProvider).importCsv(
            businessId,
            csv: csv,
            mapping: mapping,
            dryRun: false,
          );
      ref.invalidate(crmClientsProvider);
      return result;
    });
  }
}

final clientImportControllerProvider =
    AsyncNotifierProvider<ClientImportController, Map<String, dynamic>?>(ClientImportController.new);

final crmSegmentsProvider = FutureProvider<List<CrmSegment>>((ref) async {
  final businessId = ref.watch(currentBusinessIdProvider);
  if (businessId <= 0) return const [];
  return ref.watch(crmRepositoryProvider).getSegments(businessId);
});
--- FILE: lib/features/crm/data/crm_repository.dart ---
import '../../../core/network/api_client.dart';
import '../domain/crm_models.dart';

class CrmRepository {
  final ApiClient _api;

  CrmRepository({required ApiClient apiClient}) : _api = apiClient;

  String _base(int businessId) => '/v1/businesses/$businessId';

  Future<CrmClientsPage> getClients(
    int businessId, {
    String? q,
    String? status,
    String? sort,
    int page = 1,
    int pageSize = 20,
    bool? isArchived,
  }) async {
    final data = await _api.get(
      '${_base(businessId)}/clients',
      queryParameters: {
        if (q != null && q.trim().isNotEmpty) 'q': q.trim(),
        if (status != null && status.isNotEmpty) 'status': status,
        if (sort != null && sort.isNotEmpty) 'sort': sort,
        if (isArchived != null) 'is_archived': isArchived,
        'page': page,
        'page_size': pageSize,
      },
    );

    final items = (data['clients'] as List? ?? const []).whereType<Map>().cast<Map<String, dynamic>>();
    return CrmClientsPage(
      clients: items.map(CrmClient.fromJson).toList(),
      total: (data['total'] as num?)?.toInt() ?? items.length,
      page: (data['page'] as num?)?.toInt() ?? page,
      pageSize: (data['page_size'] as num?)?.toInt() ?? pageSize,
      hasMore: data['has_more'] as bool? ?? false,
    );
  }

  Future<CrmClient> getClientDetail(int businessId, int clientId) async {
    final data = await _api.get('${_base(businessId)}/clients/$clientId');
    return CrmClient.fromJson(data);
  }

  Future<void> upsertClient(int businessId, Map<String, dynamic> payload, {int? clientId}) async {
    if (clientId == null) {
      await _api.post('${_base(businessId)}/clients', data: payload);
    } else {
      await _api.patch('${_base(businessId)}/clients/$clientId', data: payload);
    }
  }

  Future<void> archiveClient(int businessId, int clientId, bool archive) async {
    final suffix = archive ? 'archive' : 'unarchive';
    await _api.post('${_base(businessId)}/clients/$clientId/$suffix');
  }

  Future<List<CrmTag>> getTags(int businessId) async {
    final data = await _api.get('${_base(businessId)}/client-tags');
    final items = (data['tags'] as List? ?? const []).whereType<Map>().cast<Map<String, dynamic>>();
    return items.map(CrmTag.fromJson).toList();
  }

  Future<void> createTag(int businessId, String name, {String? color}) async {
    await _api.post('${_base(businessId)}/client-tags', data: {'name': name, if (color != null) 'color': color});
  }

  Future<void> deleteTag(int businessId, int tagId, {bool force = false}) async {
    await _api.delete('${_base(businessId)}/client-tags/$tagId${force ? '?force=true' : ''}');
  }

  Future<void> replaceClientTags(int businessId, int clientId, List<int> tagIds) async {
    await _api.put('${_base(businessId)}/clients/$clientId/tags', data: {'tag_ids': tagIds});
  }

  Future<List<CrmTask>> getClientTasks(int businessId, int clientId) async {
    final data = await _api.get('${_base(businessId)}/clients/$clientId/tasks');
    final items = (data['tasks'] as List? ?? const []).whereType<Map>().cast<Map<String, dynamic>>();
    return items.map(CrmTask.fromJson).toList();
  }

  Future<List<CrmTask>> getClientTasksForAll(int businessId, List<CrmClient> clients) async {
    final all = <CrmTask>[];
    for (final client in clients) {
      all.addAll(await getClientTasks(businessId, client.id));
    }
    return all;
  }

  Future<void> createTask(int businessId, int clientId, Map<String, dynamic> payload) async {
    await _api.post('${_base(businessId)}/clients/$clientId/tasks', data: payload);
  }

  Future<void> patchTask(int businessId, int clientId, int taskId, Map<String, dynamic> payload) async {
    await _api.patch('${_base(businessId)}/clients/$clientId/tasks/$taskId', data: payload);
  }

  Future<void> completeTask(int businessId, int clientId, int taskId) async {
    await _api.post('${_base(businessId)}/clients/$clientId/tasks/$taskId/complete');
  }

  Future<void> reopenTask(int businessId, int clientId, int taskId) async {
    await _api.post('${_base(businessId)}/clients/$clientId/tasks/$taskId/reopen');
  }

  Future<List<CrmEvent>> getClientEvents(int businessId, int clientId, {int page = 1}) async {
    final data = await _api.get(
      '${_base(businessId)}/clients/$clientId/events',
      queryParameters: {'page': page, 'page_size': 30},
    );
    final items = (data['events'] as List? ?? const []).whereType<Map>().cast<Map<String, dynamic>>();
    return items.map(CrmEvent.fromJson).toList();
  }

  Future<List<CrmSegment>> getSegments(int businessId) async {
    final data = await _api.get('${_base(businessId)}/client-segments');
    final items = (data['segments'] as List? ?? const []).whereType<Map>().cast<Map<String, dynamic>>();
    return items.map(CrmSegment.fromJson).toList();
  }

  Future<void> createSegment(int businessId, String name, Map<String, dynamic> filters) async {
    await _api.post('${_base(businessId)}/client-segments', data: {'name': name, 'filters': filters});
  }

  Future<void> updateSegment(int businessId, int segmentId, String name, Map<String, dynamic> filters) async {
    await _api.patch('${_base(businessId)}/client-segments/$segmentId', data: {'name': name, 'filters': filters});
  }

  Future<void> deleteSegment(int businessId, int segmentId) async {
    await _api.delete('${_base(businessId)}/client-segments/$segmentId');
  }

  Future<Map<String, dynamic>> dedupSuggestions(int businessId, String query) async {
    return _api.get('${_base(businessId)}/clients/dedup/suggestions', queryParameters: {'q': query});
  }

  Future<void> mergeClient(int businessId, int sourceClientId, int targetClientId) async {
    await _api.post('${_base(businessId)}/clients/$sourceClientId/merge-into/$targetClientId');
  }

  Future<Map<String, dynamic>> importCsv(
    int businessId, {
    required String csv,
    required Map<String, dynamic> mapping,
    required bool dryRun,
  }) {
    return _api.post('${_base(businessId)}/clients/import/csv', data: {
      'csv': csv,
      'mapping': mapping,
      'dry_run': dryRun,
    });
  }

  Future<Map<String, dynamic>> exportCsv(int businessId, {int? segmentId}) {
    return _api.get(
      '${_base(businessId)}/clients/export/csv',
      queryParameters: {if (segmentId != null) 'segment_id': segmentId},
    );
  }

  Future<Map<String, dynamic>> gdprExport(int businessId, int clientId) {
    return _api.post('${_base(businessId)}/clients/$clientId/gdpr/export');
  }

  Future<void> gdprDelete(int businessId, int clientId) async {
    await _api.post('${_base(businessId)}/clients/$clientId/gdpr/delete');
  }
}
--- FILE: lib/features/crm/domain/crm_models.dart ---
class CrmClientKpi {
  final int visitsCount;
  final double totalSpent;
  final double avgTicket;
  final DateTime? lastVisit;
  final int noShowCount;

  const CrmClientKpi({
    required this.visitsCount,
    required this.totalSpent,
    required this.avgTicket,
    required this.lastVisit,
    required this.noShowCount,
  });

  factory CrmClientKpi.fromJson(Map<String, dynamic> json) {
    return CrmClientKpi(
      visitsCount: (json['visits_count'] as num?)?.toInt() ?? 0,
      totalSpent: (json['total_spent'] as num?)?.toDouble() ?? 0,
      avgTicket: (json['avg_ticket'] as num?)?.toDouble() ?? 0,
      lastVisit: json['last_visit'] != null
          ? DateTime.tryParse(json['last_visit'] as String)
          : null,
      noShowCount: (json['no_show_count'] as num?)?.toInt() ?? 0,
    );
  }
}

class CrmClient {
  final int id;
  final int businessId;
  final String? firstName;
  final String? lastName;
  final String? email;
  final String? phone;
  final String? city;
  final String status;
  final bool isArchived;
  final List<String> tags;
  final CrmClientKpi kpi;

  const CrmClient({
    required this.id,
    required this.businessId,
    required this.firstName,
    required this.lastName,
    required this.email,
    required this.phone,
    required this.city,
    required this.status,
    required this.isArchived,
    required this.tags,
    required this.kpi,
  });

  String get fullName {
    final parts = <String>[];
    if ((firstName ?? '').trim().isNotEmpty) parts.add(firstName!.trim());
    if ((lastName ?? '').trim().isNotEmpty) parts.add(lastName!.trim());
    return parts.join(' ').trim();
  }

  factory CrmClient.fromJson(Map<String, dynamic> json) {
    return CrmClient(
      id: (json['id'] as num).toInt(),
      businessId: (json['business_id'] as num).toInt(),
      firstName: json['first_name'] as String?,
      lastName: json['last_name'] as String?,
      email: json['email'] as String?,
      phone: json['phone'] as String?,
      city: json['city'] as String?,
      status: (json['status'] as String?) ?? 'active',
      isArchived: json['is_archived'] as bool? ?? false,
      tags: ((json['tags'] as List?) ?? const []).whereType<String>().toList(),
      kpi: CrmClientKpi.fromJson((json['kpi'] as Map?)?.cast<String, dynamic>() ?? const {}),
    );
  }
}

class CrmTag {
  final int id;
  final String name;
  final String? color;

  const CrmTag({required this.id, required this.name, this.color});

  factory CrmTag.fromJson(Map<String, dynamic> json) => CrmTag(
        id: (json['id'] as num).toInt(),
        name: (json['name'] as String?) ?? '',
        color: json['color'] as String?,
      );
}

class CrmTask {
  final int id;
  final int clientId;
  final String title;
  final String status;
  final String priority;
  final DateTime? dueAt;
  final bool isOverdue;

  const CrmTask({
    required this.id,
    required this.clientId,
    required this.title,
    required this.status,
    required this.priority,
    required this.dueAt,
    required this.isOverdue,
  });

  factory CrmTask.fromJson(Map<String, dynamic> json) => CrmTask(
        id: (json['id'] as num).toInt(),
        clientId: (json['client_id'] as num).toInt(),
        title: (json['title'] as String?) ?? '',
        status: (json['status'] as String?) ?? 'open',
        priority: (json['priority'] as String?) ?? 'medium',
        dueAt: json['due_at'] != null ? DateTime.tryParse(json['due_at'] as String) : null,
        isOverdue: json['is_overdue'] as bool? ?? false,
      );
}

class CrmEvent {
  final int id;
  final String eventType;
  final Map<String, dynamic>? payload;
  final DateTime? occurredAt;

  const CrmEvent({
    required this.id,
    required this.eventType,
    required this.payload,
    required this.occurredAt,
  });

  factory CrmEvent.fromJson(Map<String, dynamic> json) => CrmEvent(
        id: (json['id'] as num).toInt(),
        eventType: (json['event_type'] as String?) ?? '',
        payload: (json['payload'] as Map?)?.cast<String, dynamic>(),
        occurredAt: json['occurred_at'] != null ? DateTime.tryParse(json['occurred_at'] as String) : null,
      );
}

class CrmSegment {
  final int id;
  final String name;
  final Map<String, dynamic> filters;

  const CrmSegment({required this.id, required this.name, required this.filters});

  factory CrmSegment.fromJson(Map<String, dynamic> json) => CrmSegment(
        id: (json['id'] as num).toInt(),
        name: (json['name'] as String?) ?? '',
        filters: (json['filters'] as Map?)?.cast<String, dynamic>() ?? const {},
      );
}

class CrmClientsPage {
  final List<CrmClient> clients;
  final int total;
  final int page;
  final int pageSize;
  final bool hasMore;

  const CrmClientsPage({
    required this.clients,
    required this.total,
    required this.page,
    required this.pageSize,
    required this.hasMore,
  });
}
--- FILE: lib/features/crm/presentation/screens/crm_tags_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/widgets/feedback_dialog.dart';
import '../../domain/crm_models.dart';
import '../../providers/crm_providers.dart';

class CrmTagsScreen extends ConsumerWidget {
  const CrmTagsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final cs = theme.colorScheme;
    final tagsAsync = ref.watch(clientTagsProvider);

    return Scaffold(
      appBar: AppBar(
        title: Text(
          l10n.crmTagsTitle,
          style: theme.textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600),
        ),
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _createTag(context, ref),
        icon: const Icon(Icons.add),
        label: Text(l10n.crmCreateTagTitle),
      ),
      body: tagsAsync.when(
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (e, _) => Center(child: Text('$e')),
        data: (tags) {
          if (tags.isEmpty) {
            return Center(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Container(
                    width: 72,
                    height: 72,
                    decoration: BoxDecoration(
                      color: const Color(0xFF8E24AA).withOpacity(0.1),
                      shape: BoxShape.circle,
                    ),
                    child: const Icon(
                      Icons.sell_outlined,
                      size: 36,
                      color: Color(0xFF8E24AA),
                    ),
                  ),
                  const SizedBox(height: 16),
                  Text(
                    l10n.crmTagsEmpty,
                    style: theme.textTheme.bodyLarge
                        ?.copyWith(color: cs.onSurfaceVariant),
                  ),
                  const SizedBox(height: 6),
                  Text(
                    'Crea il primo tag per organizzare i clienti',
                    style: theme.textTheme.bodySmall?.copyWith(
                        color: cs.onSurfaceVariant.withOpacity(0.6)),
                  ),
                ],
              ),
            );
          }
          return ListView.separated(
            padding: const EdgeInsets.fromLTRB(16, 16, 16, 100),
            itemCount: tags.length,
            separatorBuilder: (_, __) => const SizedBox(height: 8),
            itemBuilder: (_, i) => _TagCard(
              tag: tags[i],
              onDelete: () async {
                final confirmed = await showDialog<bool>(
                      context: context,
                      builder: (ctx) => AlertDialog(
                        title: Text(
                            'Elimina tag "${tags[i].name}"'),
                        content: const Text(
                            'Il tag verr√† rimosso da tutti i clienti.'),
                        actions: [
                          TextButton(
                              onPressed: () => Navigator.pop(ctx, false),
                              child: Text(l10n.actionCancel)),
                          FilledButton(
                            style: FilledButton.styleFrom(
                                backgroundColor:
                                    Theme.of(context).colorScheme.error),
                            onPressed: () => Navigator.pop(ctx, true),
                            child: Text(l10n.actionConfirm),
                          ),
                        ],
                      ),
                    ) ??
                    false;

                if (!confirmed) return;
                await ref
                    .read(clientTagControllerProvider.notifier)
                    .delete(tags[i].id, force: true);
                ref.invalidate(clientTagsProvider);
                if (context.mounted) {
                  await FeedbackDialog.showSuccess(
                    context,
                    title: l10n.crmTitle,
                    message: l10n.crmTagDeleted,
                  );
                }
              },
            ),
          );
        },
      ),
    );
  }

  Future<void> _createTag(BuildContext context, WidgetRef ref) async {
    final l10n = context.l10n;
    final nameCtrl = TextEditingController();
    Color selectedColor = const Color(0xFF009688);

    final confirmed = await showDialog<bool>(
          context: context,
          builder: (ctx) => StatefulBuilder(
            builder: (ctx, setState) => AlertDialog(
              title: Text(l10n.crmCreateTagTitle),
              content: SizedBox(
                width: 360,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    TextField(
                      controller: nameCtrl,
                      decoration: InputDecoration(
                        labelText: l10n.crmTagNameLabel,
                        border: const OutlineInputBorder(),
                        isDense: true,
                      ),
                    ),
                    const SizedBox(height: 16),
                    Text(
                      l10n.crmTagColorLabel,
                      style: Theme.of(ctx).textTheme.labelMedium?.copyWith(
                            color: Theme.of(ctx).colorScheme.onSurfaceVariant,
                          ),
                    ),
                    const SizedBox(height: 8),
                    Wrap(
                      spacing: 10,
                      runSpacing: 10,
                      children: _paletteColors.map((c) {
                        final isSelected = selectedColor == c;
                        return GestureDetector(
                          onTap: () => setState(() => selectedColor = c),
                          child: AnimatedContainer(
                            duration: const Duration(milliseconds: 150),
                            width: 32,
                            height: 32,
                            decoration: BoxDecoration(
                              color: c,
                              shape: BoxShape.circle,
                              border: Border.all(
                                color: isSelected
                                    ? Theme.of(ctx).colorScheme.onSurface
                                    : Colors.transparent,
                                width: isSelected ? 3 : 0,
                              ),
                              boxShadow: isSelected
                                  ? [
                                      BoxShadow(
                                        color: c.withOpacity(0.5),
                                        blurRadius: 6,
                                      ),
                                    ]
                                  : null,
                            ),
                            child: isSelected
                                ? const Icon(Icons.check,
                                    size: 16, color: Colors.white)
                                : null,
                          ),
                        );
                      }).toList(),
                    ),
                  ],
                ),
              ),
              actions: [
                TextButton(
                    onPressed: () => Navigator.pop(ctx, false),
                    child: Text(l10n.actionCancel)),
                FilledButton(
                    onPressed: () => Navigator.pop(ctx, true),
                    child: Text(l10n.actionConfirm)),
              ],
            ),
          ),
        ) ??
        false;

    if (!confirmed) return;
    await ref.read(clientTagControllerProvider.notifier).create(
          nameCtrl.text.trim(),
          color: _colorToHex(selectedColor),
        );
    ref.invalidate(clientTagsProvider);
  }
}

class _TagCard extends StatelessWidget {
  final CrmTag tag;
  final Future<void> Function() onDelete;

  const _TagCard({required this.tag, required this.onDelete});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;
    final tagColor = _parseHex(tag.color) ?? const Color(0xFF009688);

    return Card(
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: cs.outline.withOpacity(0.08)),
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 12),
        child: Row(
          children: [
            // Color dot with icon
            Container(
              width: 44,
              height: 44,
              decoration: BoxDecoration(
                color: tagColor,
                shape: BoxShape.circle,
                boxShadow: [
                  BoxShadow(
                    color: tagColor.withOpacity(0.35),
                    blurRadius: 8,
                    offset: const Offset(0, 2),
                  ),
                ],
              ),
              child: const Icon(Icons.sell_rounded,
                  size: 20, color: Colors.white),
            ),
            const SizedBox(width: 14),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    tag.name,
                    style: theme.textTheme.bodyLarge
                        ?.copyWith(fontWeight: FontWeight.w600),
                  ),
                  if (tag.color != null) ...[
                    const SizedBox(height: 2),
                    Text(
                      tag.color!,
                      style: theme.textTheme.bodySmall
                          ?.copyWith(color: cs.onSurfaceVariant),
                    ),
                  ],
                ],
              ),
            ),
            IconButton(
              icon: Icon(Icons.delete_outline,
                  size: 20, color: cs.onSurfaceVariant),
              onPressed: onDelete,
              tooltip: 'Elimina tag',
            ),
          ],
        ),
      ),
    );
  }
}

// ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Color? _parseHex(String? hex) {
  if (hex == null) return null;
  final clean = hex.replaceAll('#', '').trim();
  if (clean.length == 6) {
    final value = int.tryParse('FF$clean', radix: 16);
    if (value != null) return Color(value);
  }
  if (clean.length == 8) {
    final value = int.tryParse(clean, radix: 16);
    if (value != null) return Color(value);
  }
  return null;
}

String _colorToHex(Color color) {
  return '#${color.value.toRadixString(16).padLeft(8, '0').substring(2)}';
}

const _paletteColors = [
  Color(0xFF009688), // teal
  Color(0xFF1565C0), // blue
  Color(0xFF8E24AA), // purple
  Color(0xFFEF6C00), // orange
  Color(0xFF2E7D32), // green
  Color(0xFFC62828), // red
  Color(0xFF0288D1), // light blue
  Color(0xFF546E7A), // blue grey
  Color(0xFFF9A825), // amber
  Color(0xFF37474F), // dark grey
];
--- FILE: lib/features/crm/presentation/screens/crm_import_export_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/widgets/feedback_dialog.dart';
import '../../../agenda/providers/business_providers.dart';
import '../../providers/crm_providers.dart';

class CrmImportExportScreen extends ConsumerStatefulWidget {
  const CrmImportExportScreen({super.key});

  @override
  ConsumerState<CrmImportExportScreen> createState() =>
      _CrmImportExportScreenState();
}

class _CrmImportExportScreenState extends ConsumerState<CrmImportExportScreen> {
  final _csvCtrl = TextEditingController();

  @override
  void dispose() {
    _csvCtrl.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final cs = theme.colorScheme;
    final importState = ref.watch(clientImportControllerProvider);

    return Scaffold(
      appBar: AppBar(
        title: Text(
          l10n.crmImportExportTitle,
          style: theme.textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600),
        ),
      ),
      body: ListView(
        padding: const EdgeInsets.all(16),
        children: [
          // ‚îÄ‚îÄ Import section ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          _SectionCard(
            icon: Icons.upload_file_outlined,
            color: const Color(0xFF1565C0),
            title: l10n.crmImportCsvTitle,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Incolla o inserisci il CSV con header: first_name, last_name, email, phone, city, notes, source',
                  style: theme.textTheme.bodySmall
                      ?.copyWith(color: cs.onSurfaceVariant, height: 1.5),
                ),
                const SizedBox(height: 12),
                TextField(
                  controller: _csvCtrl,
                  minLines: 6,
                  maxLines: 12,
                  style: theme.textTheme.bodySmall?.copyWith(
                    fontFamily: 'monospace',
                  ),
                  decoration: InputDecoration(
                    hintText: l10n.crmImportCsvHint,
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(10),
                    ),
                    filled: true,
                    fillColor: cs.surfaceContainerHighest,
                    contentPadding: const EdgeInsets.all(12),
                  ),
                ),
                const SizedBox(height: 12),
                Row(
                  children: [
                    Expanded(
                      child: OutlinedButton.icon(
                        onPressed: () => _runImport(dryRun: true),
                        icon: const Icon(Icons.preview_outlined, size: 18),
                        label: Text(l10n.crmImportPreview),
                      ),
                    ),
                    const SizedBox(width: 10),
                    Expanded(
                      child: FilledButton.icon(
                        onPressed: () => _runImport(dryRun: false),
                        icon: const Icon(Icons.check_circle_outline, size: 18),
                        label: Text(l10n.crmImportCommit),
                        style: FilledButton.styleFrom(
                          backgroundColor: const Color(0xFF1565C0),
                        ),
                      ),
                    ),
                  ],
                ),
                // Loading indicator
                if (importState.isLoading) ...[
                  const SizedBox(height: 12),
                  const LinearProgressIndicator(),
                ],
                // Result
                if (importState.hasValue && importState.value != null) ...[
                  const SizedBox(height: 12),
                  _ImportResultCard(result: importState.value!),
                ],
                if (importState.hasError) ...[
                  const SizedBox(height: 12),
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: cs.errorContainer.withOpacity(0.3),
                      borderRadius: BorderRadius.circular(10),
                      border: Border.all(color: cs.error.withOpacity(0.3)),
                    ),
                    child: Row(
                      children: [
                        Icon(Icons.error_outline,
                            size: 16, color: cs.error),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            importState.error.toString(),
                            style: theme.textTheme.bodySmall
                                ?.copyWith(color: cs.onErrorContainer),
                          ),
                        ),
                      ],
                    ),
                  ),
                ],
              ],
            ),
          ),
          const SizedBox(height: 16),
          // ‚îÄ‚îÄ Export section ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          _SectionCard(
            icon: Icons.download_outlined,
            color: const Color(0xFF2E7D32),
            title: l10n.crmExportCsvTitle,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  'Esporta tutti i clienti del business in formato CSV e copialo negli appunti.',
                  style: theme.textTheme.bodySmall
                      ?.copyWith(color: cs.onSurfaceVariant, height: 1.5),
                ),
                const SizedBox(height: 12),
                SizedBox(
                  width: double.infinity,
                  child: FilledButton.icon(
                    onPressed: () async {
                      final businessId = ref.read(currentBusinessIdProvider);
                      final res = await ref
                          .read(crmRepositoryProvider)
                          .exportCsv(businessId);
                      final csv = (res['csv'] ?? '').toString();
                      await Clipboard.setData(ClipboardData(text: csv));
                      if (context.mounted) {
                        await FeedbackDialog.showSuccess(
                          context,
                          title: l10n.crmTitle,
                          message: l10n.crmExportCopied,
                        );
                      }
                    },
                    icon: const Icon(Icons.copy_outlined, size: 18),
                    label: Text(l10n.crmExportCsvButton),
                    style: FilledButton.styleFrom(
                      backgroundColor: const Color(0xFF2E7D32),
                    ),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: 32),
        ],
      ),
    );
  }

  Future<void> _runImport({required bool dryRun}) async {
    final csv = _csvCtrl.text.trim();
    if (csv.isEmpty) return;

    const mapping = {
      'first_name': 'first_name',
      'last_name': 'last_name',
      'email': 'email',
      'phone': 'phone',
      'city': 'city',
      'notes': 'notes',
      'source': 'source',
    };

    if (dryRun) {
      await ref
          .read(clientImportControllerProvider.notifier)
          .preview(csv: csv, mapping: mapping);
    } else {
      await ref
          .read(clientImportControllerProvider.notifier)
          .commit(csv: csv, mapping: mapping);
    }
  }
}

// ‚îÄ‚îÄ Section Card ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class _SectionCard extends StatelessWidget {
  final IconData icon;
  final Color color;
  final String title;
  final Widget child;

  const _SectionCard({
    required this.icon,
    required this.color,
    required this.title,
    required this.child,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;

    return Card(
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
        side: BorderSide(color: cs.outline.withOpacity(0.08)),
      ),
      child: Padding(
        padding: const EdgeInsets.all(18),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Container(
                  width: 40,
                  height: 40,
                  decoration: BoxDecoration(
                    color: color.withOpacity(0.12),
                    borderRadius: BorderRadius.circular(11),
                  ),
                  child: Icon(icon, size: 20, color: color),
                ),
                const SizedBox(width: 12),
                Text(
                  title,
                  style: theme.textTheme.titleMedium
                      ?.copyWith(fontWeight: FontWeight.w600),
                ),
              ],
            ),
            const SizedBox(height: 16),
            child,
          ],
        ),
      ),
    );
  }
}

// ‚îÄ‚îÄ Import Result ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class _ImportResultCard extends StatelessWidget {
  final Map<String, dynamic> result;

  const _ImportResultCard({required this.result});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;

    final imported = result['imported'] ?? result['created'] ?? result['inserted'];
    final skipped = result['skipped'] ?? result['duplicates'];
    final errors = result['errors'];
    final total = result['total'];
    final isDryRun = result['dry_run'] == true;

    // Build structured rows
    final rows = <_ResultRow>[];
    if (total != null) {
      rows.add(_ResultRow('Totale righe', total.toString(), cs.onSurfaceVariant));
    }
    if (imported != null) {
      rows.add(_ResultRow(
          isDryRun ? 'Importabili' : 'Importati',
          imported.toString(),
          const Color(0xFF2E7D32)));
    }
    if (skipped != null) {
      rows.add(_ResultRow(
          'Saltati / Duplicati', skipped.toString(), const Color(0xFFEF6C00)));
    }
    if (errors != null) {
      final errCount = errors is List ? errors.length : errors;
      rows.add(_ResultRow(
          'Errori', errCount.toString(), const Color(0xFFC62828)));
    }

    // Fallback: show raw key/value pairs
    if (rows.isEmpty) {
      rows.addAll(result.entries
          .where((e) => e.value != null)
          .map((e) => _ResultRow(e.key, e.value.toString(), cs.onSurfaceVariant))
          .toList());
    }

    final headerColor = isDryRun
        ? const Color(0xFF1565C0)
        : const Color(0xFF2E7D32);
    final headerLabel = isDryRun ? 'Preview dry-run' : 'Import completato';
    final headerIcon = isDryRun ? Icons.preview_outlined : Icons.check_circle_outline;

    return Container(
      decoration: BoxDecoration(
        color: cs.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: cs.outline.withOpacity(0.12)),
      ),
      child: Column(
        children: [
          // Header
          Container(
            padding:
                const EdgeInsets.symmetric(horizontal: 14, vertical: 10),
            decoration: BoxDecoration(
              color: headerColor.withOpacity(0.1),
              borderRadius:
                  const BorderRadius.vertical(top: Radius.circular(12)),
            ),
            child: Row(
              children: [
                Icon(headerIcon, size: 16, color: headerColor),
                const SizedBox(width: 8),
                Text(
                  headerLabel,
                  style: theme.textTheme.labelMedium?.copyWith(
                    color: headerColor,
                    fontWeight: FontWeight.w700,
                  ),
                ),
              ],
            ),
          ),
          // Rows
          Padding(
            padding: const EdgeInsets.all(14),
            child: Column(
              children: rows
                  .map((r) => Padding(
                        padding:
                            const EdgeInsets.symmetric(vertical: 4),
                        child: Row(
                          children: [
                            Text(
                              r.label,
                              style: theme.textTheme.bodySmall?.copyWith(
                                  color: cs.onSurfaceVariant),
                            ),
                            const Spacer(),
                            Text(
                              r.value,
                              style: theme.textTheme.labelMedium?.copyWith(
                                color: r.color,
                                fontWeight: FontWeight.w700,
                              ),
                            ),
                          ],
                        ),
                      ))
                  .toList(),
            ),
          ),
          // Errors detail list
          if (errors is List && errors.isNotEmpty) ...[
            Divider(height: 1, color: cs.outline.withOpacity(0.15)),
            Padding(
              padding: const EdgeInsets.all(14),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Dettaglio errori',
                    style: theme.textTheme.labelSmall?.copyWith(
                      fontWeight: FontWeight.w600,
                      color: const Color(0xFFC62828),
                    ),
                  ),
                  const SizedBox(height: 6),
                  ...errors.take(5).map((e) => Padding(
                        padding: const EdgeInsets.only(bottom: 3),
                        child: Row(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            const Icon(Icons.circle,
                                size: 6, color: Color(0xFFC62828)),
                            const SizedBox(width: 6),
                            Expanded(
                              child: Text(
                                e.toString(),
                                style: theme.textTheme.bodySmall
                                    ?.copyWith(color: cs.onSurfaceVariant),
                              ),
                            ),
                          ],
                        ),
                      )),
                  if (errors.length > 5)
                    Text(
                      '+ altri ${errors.length - 5} errori',
                      style: theme.textTheme.labelSmall?.copyWith(
                          color: const Color(0xFFC62828)),
                    ),
                ],
              ),
            ),
          ],
        ],
      ),
    );
  }
}

class _ResultRow {
  final String label;
  final String value;
  final Color color;

  const _ResultRow(this.label, this.value, this.color);
}
--- FILE: lib/features/crm/presentation/screens/crm_clients_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/widgets/feedback_dialog.dart';
import '../../domain/crm_models.dart';
import '../../providers/crm_providers.dart';

class CrmClientsScreen extends ConsumerWidget {
  const CrmClientsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final state = ref.watch(crmClientsProvider);
    final currentFilter = state.value?.statusFilter ?? '';
    final theme = Theme.of(context);
    final cs = theme.colorScheme;

    return Scaffold(
      appBar: AppBar(
        title: Text(
          l10n.crmClientsTitle,
          style: theme.textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600),
        ),
        actions: [
          IconButton(
            tooltip: l10n.actionRefresh,
            onPressed: () => ref.read(crmClientsProvider.notifier).refresh(),
            icon: const Icon(Icons.refresh_outlined),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _openClientUpsertDialog(context, ref),
        icon: const Icon(Icons.person_add_outlined),
        label: Text(l10n.crmCreateClientTitle),
      ),
      body: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Search bar
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
            child: TextField(
              decoration: InputDecoration(
                hintText: l10n.crmSearchHint,
                prefixIcon: const Icon(Icons.search_outlined),
                filled: true,
                fillColor: cs.surfaceContainerHighest,
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(28),
                  borderSide: BorderSide.none,
                ),
                enabledBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(28),
                  borderSide: BorderSide.none,
                ),
                focusedBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(28),
                  borderSide: BorderSide(color: cs.primary, width: 1.5),
                ),
                contentPadding: const EdgeInsets.symmetric(vertical: 0, horizontal: 16),
              ),
              onChanged: (v) => ref.read(crmClientsProvider.notifier).setSearch(v),
            ),
          ),
          // Status filter chips
          SizedBox(
            height: 52,
            child: ListView(
              scrollDirection: Axis.horizontal,
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              children: [
                _filterChip(context, ref, l10n.crmFilterAll, '', currentFilter, null),
                const SizedBox(width: 8),
                _filterChip(context, ref, l10n.crmStatusLead, 'lead', currentFilter, const Color(0xFF1565C0)),
                const SizedBox(width: 8),
                _filterChip(context, ref, l10n.crmStatusActive, 'active', currentFilter, const Color(0xFF2E7D32)),
                const SizedBox(width: 8),
                _filterChip(context, ref, l10n.crmStatusInactive, 'inactive', currentFilter, const Color(0xFFEF6C00)),
                const SizedBox(width: 8),
                _filterChip(context, ref, l10n.crmStatusLost, 'lost', currentFilter, const Color(0xFFC62828)),
              ],
            ),
          ),
          // Count
          if (state.hasValue && (state.value?.total ?? 0) > 0)
            Padding(
              padding: const EdgeInsets.fromLTRB(20, 0, 16, 6),
              child: Text(
                '${state.value!.total} clienti',
                style: theme.textTheme.labelSmall?.copyWith(color: cs.onSurfaceVariant),
              ),
            ),
          Expanded(
            child: state.when(
              loading: () => const Center(child: CircularProgressIndicator()),
              error: (e, _) => Center(child: Text('$e')),
              data: (data) {
                if (data.clients.isEmpty) {
                  return _EmptyState(
                    icon: Icons.people_outline,
                    label: l10n.crmClientsEmpty,
                  );
                }
                return ListView.separated(
                  padding: const EdgeInsets.fromLTRB(16, 4, 16, 100),
                  itemCount: data.clients.length + (data.hasMore ? 1 : 0),
                  separatorBuilder: (_, __) => const SizedBox(height: 8),
                  itemBuilder: (context, index) {
                    if (index == data.clients.length) {
                      return Padding(
                        padding: const EdgeInsets.symmetric(vertical: 8),
                        child: Center(
                          child: data.loadingMore
                              ? const CircularProgressIndicator()
                              : OutlinedButton.icon(
                                  onPressed: () =>
                                      ref.read(crmClientsProvider.notifier).loadMore(),
                                  icon: const Icon(Icons.expand_more),
                                  label: Text(l10n.crmLoadMore),
                                ),
                        ),
                      );
                    }
                    final c = data.clients[index];
                    return _ClientCard(
                      client: c,
                      onTap: () => context.go('/altro/crm/clienti/${c.id}'),
                      archiveLabel: l10n.crmArchiveAction,
                      gdprLabel: l10n.crmGdprDeleteTitle,
                      onArchive: () async {
                        await ref
                            .read(crmRepositoryProvider)
                            .archiveClient(c.businessId, c.id, true);
                        ref.invalidate(crmClientsProvider);
                      },
                      onGdprDelete: () async {
                        final ok = await showDialog<bool>(
                              context: context,
                              builder: (ctx) => AlertDialog(
                                title: Text(l10n.crmGdprDeleteTitle),
                                content: Text(l10n.crmGdprDeleteConfirm),
                                actions: [
                                  TextButton(
                                    onPressed: () => Navigator.pop(ctx, false),
                                    child: Text(l10n.actionCancel),
                                  ),
                                  FilledButton(
                                    style: FilledButton.styleFrom(
                                        backgroundColor: cs.error),
                                    onPressed: () => Navigator.pop(ctx, true),
                                    child: Text(l10n.actionConfirm),
                                  ),
                                ],
                              ),
                            ) ??
                            false;
                        if (!ok) return;
                        await ref
                            .read(crmRepositoryProvider)
                            .gdprDelete(c.businessId, c.id);
                        ref.invalidate(crmClientsProvider);
                        if (context.mounted) {
                          await FeedbackDialog.showSuccess(
                            context,
                            title: l10n.crmTitle,
                            message: l10n.crmGdprDeleted,
                          );
                        }
                      },
                    );
                  },
                );
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _filterChip(
    BuildContext context,
    WidgetRef ref,
    String label,
    String value,
    String current,
    Color? color,
  ) {
    final isSelected = current == value;
    final resolvedColor = color ?? Theme.of(context).colorScheme.primary;
    return ChoiceChip(
      label: Text(label),
      selected: isSelected,
      selectedColor: resolvedColor.withOpacity(0.15),
      labelStyle: TextStyle(
        color: isSelected ? resolvedColor : null,
        fontWeight: isSelected ? FontWeight.w600 : FontWeight.normal,
      ),
      onSelected: (v) {
        if (v) ref.read(crmClientsProvider.notifier).setStatusFilter(value);
      },
    );
  }

  Future<void> _openClientUpsertDialog(BuildContext context, WidgetRef ref) async {
    final l10n = context.l10n;
    final firstNameCtrl = TextEditingController();
    final lastNameCtrl = TextEditingController();
    final emailCtrl = TextEditingController();
    final phoneCtrl = TextEditingController();

    final confirmed = await showDialog<bool>(
          context: context,
          builder: (ctx) => AlertDialog(
            title: Text(l10n.crmCreateClientTitle),
            content: SizedBox(
              width: 420,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  _dialogField(firstNameCtrl, l10n.authFirstName),
                  const SizedBox(height: 12),
                  _dialogField(lastNameCtrl, l10n.authLastName),
                  const SizedBox(height: 12),
                  _dialogField(emailCtrl, l10n.authEmail,
                      keyboard: TextInputType.emailAddress),
                  const SizedBox(height: 12),
                  _dialogField(phoneCtrl, l10n.authPhone,
                      keyboard: TextInputType.phone),
                ],
              ),
            ),
            actions: [
              TextButton(
                  onPressed: () => Navigator.pop(ctx, false),
                  child: Text(l10n.actionCancel)),
              FilledButton(
                  onPressed: () => Navigator.pop(ctx, true),
                  child: Text(l10n.actionConfirm)),
            ],
          ),
        ) ??
        false;

    if (!confirmed) return;

    await ref.read(clientUpsertControllerProvider.notifier).submit({
      'first_name': firstNameCtrl.text.trim(),
      'last_name': lastNameCtrl.text.trim(),
      'email': emailCtrl.text.trim(),
      'phone': phoneCtrl.text.trim(),
    });

    ref.invalidate(crmClientsProvider);
  }

  Widget _dialogField(TextEditingController ctrl, String label,
      {TextInputType? keyboard}) {
    return TextField(
      controller: ctrl,
      keyboardType: keyboard,
      decoration: InputDecoration(
        labelText: label,
        border: const OutlineInputBorder(),
        isDense: true,
      ),
    );
  }
}

// ‚îÄ‚îÄ Client Card ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class _ClientCard extends StatelessWidget {
  final CrmClient client;
  final VoidCallback onTap;
  final String archiveLabel;
  final String gdprLabel;
  final Future<void> Function() onArchive;
  final Future<void> Function() onGdprDelete;

  const _ClientCard({
    required this.client,
    required this.onTap,
    required this.archiveLabel,
    required this.gdprLabel,
    required this.onArchive,
    required this.onGdprDelete,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;
    final name = client.fullName.isEmpty ? '#${client.id}' : client.fullName;
    final initials = _initials(name);
    final avatarColor = _avatarColor(client.id);

    return Card(
      elevation: 1,
      shadowColor: avatarColor.withOpacity(0.12),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(14),
        side: BorderSide(color: cs.outline.withOpacity(0.08)),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(14),
        child: Padding(
          padding: const EdgeInsets.all(14),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Avatar
              CircleAvatar(
                radius: 22,
                backgroundColor: avatarColor.withOpacity(0.14),
                child: Text(
                  initials,
                  style: theme.textTheme.titleSmall?.copyWith(
                    color: avatarColor,
                    fontWeight: FontWeight.w700,
                  ),
                ),
              ),
              const SizedBox(width: 12),
              // Content
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            name,
                            style: theme.textTheme.titleSmall
                                ?.copyWith(fontWeight: FontWeight.w600),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        const SizedBox(width: 8),
                        _StatusBadge(client.status),
                      ],
                    ),
                    if ((client.email ?? '').isNotEmpty ||
                        (client.phone ?? '').isNotEmpty) ...[
                      const SizedBox(height: 4),
                      Text(
                        [
                          if ((client.email ?? '').isNotEmpty) client.email!,
                          if ((client.phone ?? '').isNotEmpty) client.phone!,
                        ].join(' ¬∑ '),
                        style: theme.textTheme.bodySmall
                            ?.copyWith(color: cs.onSurfaceVariant),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ],
                    const SizedBox(height: 6),
                    Row(
                      children: [
                        Icon(Icons.bar_chart_rounded,
                            size: 13, color: cs.onSurfaceVariant),
                        const SizedBox(width: 3),
                        Text(
                          '${client.kpi.visitsCount} visite',
                          style: theme.textTheme.labelSmall
                              ?.copyWith(color: cs.onSurfaceVariant),
                        ),
                        if (client.kpi.lastVisit != null) ...[
                          const SizedBox(width: 10),
                          Icon(Icons.schedule_outlined,
                              size: 13, color: cs.onSurfaceVariant),
                          const SizedBox(width: 3),
                          Text(
                            _formatDate(client.kpi.lastVisit),
                            style: theme.textTheme.labelSmall
                                ?.copyWith(color: cs.onSurfaceVariant),
                          ),
                        ],
                        if (client.kpi.totalSpent > 0) ...[
                          const SizedBox(width: 10),
                          Icon(Icons.euro_outlined,
                              size: 13, color: cs.onSurfaceVariant),
                          const SizedBox(width: 3),
                          Text(
                            client.kpi.totalSpent.toStringAsFixed(0),
                            style: theme.textTheme.labelSmall
                                ?.copyWith(color: cs.onSurfaceVariant),
                          ),
                        ],
                      ],
                    ),
                    if (client.tags.isNotEmpty) ...[
                      const SizedBox(height: 6),
                      Wrap(
                        spacing: 4,
                        runSpacing: 4,
                        children: client.tags
                            .take(4)
                            .map((t) => _InlineTag(t))
                            .toList(),
                      ),
                    ],
                  ],
                ),
              ),
              // Menu
              PopupMenuButton<String>(
                icon: Icon(Icons.more_vert, size: 20, color: cs.onSurfaceVariant),
                onSelected: (v) async {
                  if (v == 'archive') await onArchive();
                  if (v == 'gdpr') await onGdprDelete();
                },
                itemBuilder: (ctx) {
                  final errorColor = Theme.of(ctx).colorScheme.error;
                  return [
                    PopupMenuItem(
                      value: 'archive',
                      child: Row(children: [
                        const Icon(Icons.archive_outlined, size: 18),
                        const SizedBox(width: 10),
                        Text(archiveLabel),
                      ]),
                    ),
                    const PopupMenuDivider(),
                    PopupMenuItem(
                      value: 'gdpr',
                      child: Row(children: [
                        Icon(Icons.delete_forever_outlined,
                            size: 18, color: errorColor),
                        const SizedBox(width: 10),
                        Text(gdprLabel,
                            style: TextStyle(color: errorColor)),
                      ]),
                    ),
                  ];
                },
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// ‚îÄ‚îÄ Shared visual atoms ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class _StatusBadge extends StatelessWidget {
  final String status;

  const _StatusBadge(this.status);

  @override
  Widget build(BuildContext context) {
    final color = _statusColor(status);
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
      decoration: BoxDecoration(
        color: color.withOpacity(0.12),
        borderRadius: BorderRadius.circular(20),
      ),
      child: Text(
        status,
        style: Theme.of(context).textTheme.labelSmall?.copyWith(
              color: color,
              fontWeight: FontWeight.w600,
            ),
      ),
    );
  }
}

class _InlineTag extends StatelessWidget {
  final String tag;

  const _InlineTag(this.tag);

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 7, vertical: 2),
      decoration: BoxDecoration(
        color: cs.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: cs.outline.withOpacity(0.2)),
      ),
      child: Text(
        tag,
        style: Theme.of(context)
            .textTheme
            .labelSmall
            ?.copyWith(color: cs.onSurfaceVariant),
      ),
    );
  }
}

class _EmptyState extends StatelessWidget {
  final IconData icon;
  final String label;

  const _EmptyState({required this.icon, required this.label});

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 56, color: cs.onSurfaceVariant.withOpacity(0.35)),
          const SizedBox(height: 16),
          Text(
            label,
            style: Theme.of(context)
                .textTheme
                .bodyLarge
                ?.copyWith(color: cs.onSurfaceVariant),
          ),
        ],
      ),
    );
  }
}

// ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Color _statusColor(String status) {
  switch (status) {
    case 'lead':
      return const Color(0xFF1565C0);
    case 'active':
      return const Color(0xFF2E7D32);
    case 'inactive':
      return const Color(0xFFEF6C00);
    case 'lost':
      return const Color(0xFFC62828);
    default:
      return const Color(0xFF546E7A);
  }
}

Color _avatarColor(int id) {
  const colors = [
    Color(0xFF009688),
    Color(0xFF1565C0),
    Color(0xFF8E24AA),
    Color(0xFFEF6C00),
    Color(0xFF2E7D32),
    Color(0xFF0288D1),
  ];
  return colors[id % colors.length];
}

String _initials(String name) {
  final parts = name.trim().split(' ').where((p) => p.isNotEmpty).toList();
  if (parts.isEmpty) return '?';
  if (parts.length == 1) return parts[0][0].toUpperCase();
  return '${parts[0][0]}${parts.last[0]}'.toUpperCase();
}

String _formatDate(DateTime? dt) {
  if (dt == null) return '-';
  return '${dt.day.toString().padLeft(2, '0')}/${dt.month.toString().padLeft(2, '0')}/${dt.year}';
}
--- FILE: lib/features/crm/presentation/screens/crm_tasks_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../domain/crm_models.dart';
import '../../providers/crm_providers.dart';

class CrmTasksScreen extends ConsumerWidget {
  const CrmTasksScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final cs = theme.colorScheme;
    final overdueAsync = ref.watch(overdueTasksProvider);

    return Scaffold(
      appBar: AppBar(
        title: Text(
          l10n.crmTasksTitle,
          style: theme.textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600),
        ),
      ),
      body: overdueAsync.when(
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (e, _) => Center(child: Text('$e')),
        data: (tasks) {
          if (tasks.isEmpty) {
            return Center(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Container(
                    width: 72,
                    height: 72,
                    decoration: BoxDecoration(
                      color: const Color(0xFF2E7D32).withOpacity(0.1),
                      shape: BoxShape.circle,
                    ),
                    child: const Icon(
                      Icons.task_alt_rounded,
                      size: 36,
                      color: Color(0xFF2E7D32),
                    ),
                  ),
                  const SizedBox(height: 16),
                  Text(
                    l10n.crmTasksEmpty,
                    style: theme.textTheme.bodyLarge
                        ?.copyWith(color: cs.onSurfaceVariant),
                  ),
                  const SizedBox(height: 6),
                  Text(
                    'Tutti i task sono in ordine',
                    style: theme.textTheme.bodySmall
                        ?.copyWith(color: cs.onSurfaceVariant.withOpacity(0.6)),
                  ),
                ],
              ),
            );
          }

          return CustomScrollView(
            slivers: [
              // Section header
              SliverToBoxAdapter(
                child: Padding(
                  padding:
                      const EdgeInsets.fromLTRB(16, 16, 16, 8),
                  child: Row(
                    children: [
                      Container(
                        padding: const EdgeInsets.symmetric(
                            horizontal: 10, vertical: 4),
                        decoration: BoxDecoration(
                          color: const Color(0xFFC62828).withOpacity(0.12),
                          borderRadius: BorderRadius.circular(20),
                        ),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Icon(Icons.warning_amber_rounded,
                                size: 14, color: Color(0xFFC62828)),
                            const SizedBox(width: 5),
                            Text(
                              '${tasks.length} in ritardo',
                              style: theme.textTheme.labelMedium?.copyWith(
                                color: const Color(0xFFC62828),
                                fontWeight: FontWeight.w700,
                              ),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              ),
              // Task list
              SliverPadding(
                padding: const EdgeInsets.fromLTRB(16, 0, 16, 24),
                sliver: SliverList.separated(
                  itemCount: tasks.length,
                  separatorBuilder: (_, __) => const SizedBox(height: 8),
                  itemBuilder: (_, i) => _OverdueTaskCard(
                    task: tasks[i],
                    ref: ref,
                    l10n: l10n,
                    onClientTap: () =>
                        context.go('/altro/crm/clienti/${tasks[i].clientId}'),
                  ),
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}

class _OverdueTaskCard extends StatelessWidget {
  final CrmTask task;
  final WidgetRef ref;
  final dynamic l10n;
  final VoidCallback onClientTap;

  const _OverdueTaskCard({
    required this.task,
    required this.ref,
    required this.l10n,
    required this.onClientTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;
    final priorityColor = _priorityColor(task.priority);
    final isDone = task.status == 'done';

    return Card(
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(14),
        side: BorderSide(
          color: task.isOverdue && !isDone
              ? const Color(0xFFC62828).withOpacity(0.25)
              : cs.outline.withOpacity(0.08),
        ),
      ),
      child: Padding(
        padding: const EdgeInsets.all(14),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Priority indicator bar
                Container(
                  width: 4,
                  height: 40,
                  margin: const EdgeInsets.only(right: 12, top: 2),
                  decoration: BoxDecoration(
                    color: isDone
                        ? cs.onSurfaceVariant.withOpacity(0.2)
                        : priorityColor,
                    borderRadius: BorderRadius.circular(2),
                  ),
                ),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        task.title,
                        style: theme.textTheme.bodyMedium?.copyWith(
                          fontWeight: FontWeight.w600,
                          decoration:
                              isDone ? TextDecoration.lineThrough : null,
                          color: isDone ? cs.onSurfaceVariant : null,
                        ),
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                      const SizedBox(height: 6),
                      Row(
                        children: [
                          _Badge(_priorityLabel(task.priority), priorityColor),
                          const SizedBox(width: 6),
                          if (task.isOverdue && !isDone)
                            _Badge('In ritardo', const Color(0xFFC62828)),
                        ],
                      ),
                    ],
                  ),
                ),
              ],
            ),
            const SizedBox(height: 10),
            Row(
              children: [
                // Client link
                InkWell(
                  onTap: onClientTap,
                  borderRadius: BorderRadius.circular(6),
                  child: Padding(
                    padding: const EdgeInsets.symmetric(
                        horizontal: 2, vertical: 2),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(Icons.person_outline,
                            size: 13, color: cs.primary),
                        const SizedBox(width: 3),
                        Text(
                          'Cliente #${task.clientId}',
                          style: theme.textTheme.labelSmall?.copyWith(
                            color: cs.primary,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                if (task.dueAt != null) ...[
                  const SizedBox(width: 12),
                  Icon(Icons.schedule_outlined,
                      size: 13, color: cs.onSurfaceVariant),
                  const SizedBox(width: 3),
                  Text(
                    _formatDate(task.dueAt),
                    style: theme.textTheme.labelSmall?.copyWith(
                      color: task.isOverdue && !isDone
                          ? const Color(0xFFC62828)
                          : cs.onSurfaceVariant,
                      fontWeight: task.isOverdue && !isDone
                          ? FontWeight.w600
                          : null,
                    ),
                  ),
                ],
                const Spacer(),
                if (!isDone)
                  FilledButton.icon(
                    onPressed: () => ref
                        .read(clientTaskControllerProvider.notifier)
                        .complete(task.clientId, task.id),
                    icon: const Icon(Icons.check_rounded, size: 15),
                    label: Text(l10n.crmTaskComplete),
                    style: FilledButton.styleFrom(
                      visualDensity: VisualDensity.compact,
                      backgroundColor: const Color(0xFF2E7D32),
                    ),
                  ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

// ‚îÄ‚îÄ Shared atoms ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class _Badge extends StatelessWidget {
  final String label;
  final Color color;

  const _Badge(this.label, this.color);

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 3),
      decoration: BoxDecoration(
        color: color.withOpacity(0.12),
        borderRadius: BorderRadius.circular(20),
      ),
      child: Text(
        label,
        style: Theme.of(context).textTheme.labelSmall?.copyWith(
              color: color,
              fontWeight: FontWeight.w600,
            ),
      ),
    );
  }
}

// ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Color _priorityColor(String priority) {
  switch (priority) {
    case 'high':
      return const Color(0xFFC62828);
    case 'medium':
      return const Color(0xFFF9A825);
    case 'low':
      return const Color(0xFF546E7A);
    default:
      return const Color(0xFF546E7A);
  }
}

String _priorityLabel(String priority) {
  switch (priority) {
    case 'high':
      return 'Alta';
    case 'medium':
      return 'Media';
    case 'low':
      return 'Bassa';
    default:
      return priority;
  }
}

String _formatDate(DateTime? dt) {
  if (dt == null) return '-';
  return '${dt.day.toString().padLeft(2, '0')}/${dt.month.toString().padLeft(2, '0')}/${dt.year}';
}
--- FILE: lib/features/crm/presentation/screens/crm_segments_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/widgets/feedback_dialog.dart';
import '../../domain/crm_models.dart';
import '../../providers/crm_providers.dart';
import '../../../agenda/providers/business_providers.dart';

class CrmSegmentsScreen extends ConsumerWidget {
  const CrmSegmentsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final cs = theme.colorScheme;
    final segmentsAsync = ref.watch(crmSegmentsProvider);

    return Scaffold(
      appBar: AppBar(
        title: Text(
          l10n.crmSegmentsTitle,
          style: theme.textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600),
        ),
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _openCreateDialog(context, ref),
        icon: const Icon(Icons.add),
        label: Text(l10n.crmCreateSegmentTitle),
      ),
      body: segmentsAsync.when(
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (e, _) => Center(child: Text('$e')),
        data: (segments) {
          if (segments.isEmpty) {
            return Center(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Container(
                    width: 72,
                    height: 72,
                    decoration: BoxDecoration(
                      color: const Color(0xFF5C6BC0).withOpacity(0.1),
                      shape: BoxShape.circle,
                    ),
                    child: const Icon(
                      Icons.filter_alt_outlined,
                      size: 36,
                      color: Color(0xFF5C6BC0),
                    ),
                  ),
                  const SizedBox(height: 16),
                  Text(
                    l10n.crmSegmentsEmpty,
                    style: theme.textTheme.bodyLarge
                        ?.copyWith(color: cs.onSurfaceVariant),
                  ),
                  const SizedBox(height: 6),
                  Text(
                    'Crea un segmento per raggruppare clienti con filtri salvati',
                    textAlign: TextAlign.center,
                    style: theme.textTheme.bodySmall?.copyWith(
                        color: cs.onSurfaceVariant.withOpacity(0.6)),
                  ),
                ],
              ),
            );
          }
          return ListView.separated(
            padding: const EdgeInsets.fromLTRB(16, 16, 16, 100),
            itemCount: segments.length,
            separatorBuilder: (_, __) => const SizedBox(height: 8),
            itemBuilder: (_, i) => _SegmentCard(
              segment: segments[i],
              onDelete: () async {
                final businessId = ref.read(currentBusinessIdProvider);
                final confirmed = await showDialog<bool>(
                      context: context,
                      builder: (ctx) => AlertDialog(
                        title:
                            Text('Elimina "${segments[i].name}"'),
                        content: const Text(
                            'Il segmento verr√† eliminato definitivamente.'),
                        actions: [
                          TextButton(
                              onPressed: () => Navigator.pop(ctx, false),
                              child: Text(l10n.actionCancel)),
                          FilledButton(
                            style: FilledButton.styleFrom(
                                backgroundColor:
                                    Theme.of(context).colorScheme.error),
                            onPressed: () => Navigator.pop(ctx, true),
                            child: Text(l10n.actionConfirm),
                          ),
                        ],
                      ),
                    ) ??
                    false;

                if (!confirmed) return;
                await ref
                    .read(crmRepositoryProvider)
                    .deleteSegment(businessId, segments[i].id);
                ref.invalidate(crmSegmentsProvider);
                if (context.mounted) {
                  await FeedbackDialog.showSuccess(
                    context,
                    title: l10n.crmTitle,
                    message: l10n.crmSegmentDeleted,
                  );
                }
              },
            ),
          );
        },
      ),
    );
  }

  Future<void> _openCreateDialog(BuildContext context, WidgetRef ref) async {
    final l10n = context.l10n;
    final nameCtrl = TextEditingController();
    final queryCtrl = TextEditingController();

    final confirmed = await showDialog<bool>(
          context: context,
          builder: (ctx) => AlertDialog(
            title: Text(l10n.crmCreateSegmentTitle),
            content: SizedBox(
              width: 420,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  TextField(
                    controller: nameCtrl,
                    decoration: InputDecoration(
                      labelText: l10n.crmSegmentNameLabel,
                      border: const OutlineInputBorder(),
                      isDense: true,
                      prefixIcon: const Icon(Icons.label_outlined),
                    ),
                  ),
                  const SizedBox(height: 12),
                  TextField(
                    controller: queryCtrl,
                    decoration: InputDecoration(
                      labelText: l10n.crmSegmentQueryLabel,
                      hintText: 'es. status=active&tag_ids=1,2',
                      border: const OutlineInputBorder(),
                      isDense: true,
                      prefixIcon: const Icon(Icons.search_outlined),
                    ),
                  ),
                ],
              ),
            ),
            actions: [
              TextButton(
                  onPressed: () => Navigator.pop(ctx, false),
                  child: Text(l10n.actionCancel)),
              FilledButton(
                  onPressed: () => Navigator.pop(ctx, true),
                  child: Text(l10n.actionConfirm)),
            ],
          ),
        ) ??
        false;

    if (!confirmed) return;
    final businessId = ref.read(currentBusinessIdProvider);
    await ref.read(crmRepositoryProvider).createSegment(
          businessId,
          nameCtrl.text.trim(),
          {'q': queryCtrl.text.trim()},
        );
    ref.invalidate(crmSegmentsProvider);
  }
}

class _SegmentCard extends StatelessWidget {
  final CrmSegment segment;
  final Future<void> Function() onDelete;

  const _SegmentCard({required this.segment, required this.onDelete});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;
    final filterChips = _formatFilters(segment.filters);

    return Card(
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(14),
        side: BorderSide(color: cs.outline.withOpacity(0.08)),
      ),
      child: Padding(
        padding: const EdgeInsets.all(14),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Container(
              width: 44,
              height: 44,
              decoration: BoxDecoration(
                color: const Color(0xFF5C6BC0).withOpacity(0.12),
                borderRadius: BorderRadius.circular(12),
              ),
              child: const Icon(
                Icons.filter_alt_outlined,
                size: 22,
                color: Color(0xFF5C6BC0),
              ),
            ),
            const SizedBox(width: 14),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    segment.name,
                    style: theme.textTheme.bodyLarge
                        ?.copyWith(fontWeight: FontWeight.w600),
                  ),
                  const SizedBox(height: 6),
                  if (filterChips.isNotEmpty)
                    Wrap(
                      spacing: 6,
                      runSpacing: 4,
                      children: filterChips
                          .map((f) => _FilterChipWidget(f))
                          .toList(),
                    )
                  else
                    Text(
                      'Nessun filtro configurato',
                      style: theme.textTheme.bodySmall
                          ?.copyWith(color: cs.onSurfaceVariant),
                    ),
                ],
              ),
            ),
            IconButton(
              icon: Icon(Icons.delete_outline,
                  size: 20, color: cs.onSurfaceVariant),
              onPressed: onDelete,
              tooltip: 'Elimina segmento',
            ),
          ],
        ),
      ),
    );
  }
}

class _FilterChipWidget extends StatelessWidget {
  final String label;

  const _FilterChipWidget(this.label);

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 3),
      decoration: BoxDecoration(
        color: cs.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: cs.outline.withOpacity(0.2)),
      ),
      child: Text(
        label,
        style: Theme.of(context)
            .textTheme
            .labelSmall
            ?.copyWith(color: cs.onSurfaceVariant),
      ),
    );
  }
}

// ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

List<String> _formatFilters(Map<String, dynamic> filters) {
  return filters.entries
      .where((e) => e.value != null && e.value.toString().isNotEmpty)
      .map((e) {
    final key = _filterKeyLabel(e.key);
    final value = e.value.toString();
    return '$key: $value';
  }).toList();
}

String _filterKeyLabel(String key) {
  switch (key) {
    case 'q':
      return 'Cerca';
    case 'status':
      return 'Stato';
    case 'tag_ids':
      return 'Tag';
    case 'tag_names':
      return 'Tag';
    case 'last_visit_from':
      return 'Ultima visita da';
    case 'last_visit_to':
      return 'Ultima visita a';
    case 'spent_from':
      return 'Spesa minima';
    case 'spent_to':
      return 'Spesa massima';
    case 'visits_from':
      return 'Visite min';
    case 'visits_to':
      return 'Visite max';
    case 'birthday_month':
      return 'Mese compleanno';
    case 'marketing_opt_in':
      return 'Marketing';
    case 'profiling_opt_in':
      return 'Profilazione';
    case 'is_archived':
      return 'Archiviati';
    default:
      return key;
  }
}
--- FILE: lib/features/crm/presentation/screens/crm_home_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../core/l10n/l10_extension.dart';

class CrmHomeScreen extends ConsumerWidget {
  const CrmHomeScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final formFactor = ref.watch(formFactorProvider);
    final isDesktop = formFactor == AppFormFactor.desktop;

    final items = [
      _Entry(
        l10n.crmClientsTitle,
        l10n.crmClientsDescription,
        Icons.people_alt_outlined,
        '/altro/crm/clienti',
        const Color(0xFF009688),
      ),
      _Entry(
        l10n.crmSegmentsTitle,
        l10n.crmSegmentsDescription,
        Icons.filter_alt_outlined,
        '/altro/crm/segmenti',
        const Color(0xFF5C6BC0),
      ),
      _Entry(
        l10n.crmTasksTitle,
        l10n.crmTasksDescription,
        Icons.task_alt_outlined,
        '/altro/crm/task',
        const Color(0xFFEF6C00),
      ),
      _Entry(
        l10n.crmTagsTitle,
        l10n.crmTagsDescription,
        Icons.sell_outlined,
        '/altro/crm/tag',
        const Color(0xFF8E24AA),
      ),
      _Entry(
        l10n.crmImportExportTitle,
        l10n.crmImportExportDescription,
        Icons.import_export_outlined,
        '/altro/crm/import-export',
        const Color(0xFF546E7A),
      ),
    ];

    return Scaffold(
      appBar: AppBar(
        title: Text(
          l10n.crmTitle,
          style: theme.textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600),
        ),
        elevation: 0,
      ),
      body: CustomScrollView(
        slivers: [
          SliverToBoxAdapter(
            child: Padding(
              padding: EdgeInsets.fromLTRB(
                isDesktop ? 32 : 20,
                isDesktop ? 20 : 14,
                isDesktop ? 32 : 20,
                isDesktop ? 20 : 14,
              ),
              child: Text(
                l10n.crmSubtitle,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: colorScheme.onSurfaceVariant,
                ),
              ),
            ),
          ),
          SliverPadding(
            padding: EdgeInsets.symmetric(
              horizontal: isDesktop ? 32 : 16,
              vertical: 4,
            ),
            sliver: isDesktop
                ? _buildGrid(context, items)
                : _buildList(items),
          ),
          const SliverToBoxAdapter(child: SizedBox(height: 32)),
        ],
      ),
    );
  }

  Widget _buildGrid(BuildContext context, List<_Entry> items) {
    final width = MediaQuery.of(context).size.width;
    final columns = width > 1200 ? 4 : (width > 800 ? 3 : 2);
    return SliverGrid(
      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: columns,
        crossAxisSpacing: 16,
        mainAxisSpacing: 16,
        childAspectRatio: columns >= 4 ? 1.12 : 1.0,
      ),
      delegate: SliverChildBuilderDelegate(
        (_, i) => _CardDesktop(item: items[i]),
        childCount: items.length,
      ),
    );
  }

  Widget _buildList(List<_Entry> items) {
    return SliverList(
      delegate: SliverChildBuilderDelegate(
        (_, i) => Padding(
          padding: EdgeInsets.only(bottom: i < items.length - 1 ? 12 : 0),
          child: _CardMobile(item: items[i]),
        ),
        childCount: items.length,
      ),
    );
  }
}

class _Entry {
  final String title, subtitle, path;
  final IconData icon;
  final Color color;

  const _Entry(this.title, this.subtitle, this.icon, this.path, this.color);
}

class _CardDesktop extends StatefulWidget {
  final _Entry item;

  const _CardDesktop({required this.item});

  @override
  State<_CardDesktop> createState() => _CardDesktopState();
}

class _CardDesktopState extends State<_CardDesktop> {
  bool _hovered = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;
    final item = widget.item;

    return MouseRegion(
      onEnter: (_) => setState(() => _hovered = true),
      onExit: (_) => setState(() => _hovered = false),
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        curve: Curves.easeOutCubic,
        transform: Matrix4.identity()..scale(_hovered ? 1.02 : 1.0),
        child: Card(
          elevation: _hovered ? 8 : 2,
          shadowColor: item.color.withOpacity(0.3),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(16),
            side: BorderSide(
              color: _hovered
                  ? item.color.withOpacity(0.5)
                  : cs.outline.withOpacity(0.1),
              width: _hovered ? 2 : 1,
            ),
          ),
          child: InkWell(
            onTap: () => context.go(item.path),
            borderRadius: BorderRadius.circular(16),
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Container(
                    width: 52,
                    height: 52,
                    decoration: BoxDecoration(
                      color: item.color.withOpacity(0.12),
                      borderRadius: BorderRadius.circular(14),
                    ),
                    child: Icon(item.icon, size: 26, color: item.color),
                  ),
                  const Spacer(),
                  Text(
                    item.title,
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                      color: cs.onSurface,
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 6),
                  Text(
                    item.subtitle,
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: cs.onSurfaceVariant,
                      height: 1.4,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 12),
                  Align(
                    alignment: Alignment.centerRight,
                    child: Icon(
                      Icons.arrow_forward_rounded,
                      size: 20,
                      color: _hovered ? item.color : cs.outline.withOpacity(0.5),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class _CardMobile extends StatelessWidget {
  final _Entry item;

  const _CardMobile({required this.item});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;

    return Card(
      elevation: 1,
      shadowColor: item.color.withOpacity(0.2),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(14),
        side: BorderSide(color: cs.outline.withOpacity(0.1)),
      ),
      child: InkWell(
        onTap: () => context.go(item.path),
        borderRadius: BorderRadius.circular(14),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(
                width: 48,
                height: 48,
                decoration: BoxDecoration(
                  color: item.color.withOpacity(0.12),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(item.icon, size: 24, color: item.color),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      item.title,
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w600,
                        color: cs.onSurface,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      item.subtitle,
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: cs.onSurfaceVariant,
                        height: 1.4,
                      ),
                    ),
                  ],
                ),
              ),
              const SizedBox(width: 8),
              Padding(
                padding: const EdgeInsets.only(top: 12),
                child: Icon(
                  Icons.chevron_right,
                  size: 24,
                  color: cs.outline.withOpacity(0.6),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/crm/presentation/screens/crm_client_detail_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/network/network_providers.dart';
import '../../../../core/widgets/feedback_dialog.dart';
import '../../domain/crm_models.dart';
import '../../providers/crm_providers.dart';

class CrmClientDetailScreen extends ConsumerStatefulWidget {
  final int clientId;

  const CrmClientDetailScreen({super.key, required this.clientId});

  @override
  ConsumerState<CrmClientDetailScreen> createState() =>
      _CrmClientDetailScreenState();
}

class _CrmClientDetailScreenState extends ConsumerState<CrmClientDetailScreen>
    with SingleTickerProviderStateMixin {
  late final TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 7, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final detailAsync = ref.watch(clientDetailProvider(widget.clientId));
    final eventsAsync = ref.watch(clientEventsProvider(widget.clientId));
    final tasksAsync = ref.watch(clientTasksProvider(widget.clientId));

    return Scaffold(
      appBar: AppBar(
        title: detailAsync.maybeWhen(
          data: (c) => Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                c.fullName.isEmpty ? '#${c.id}' : c.fullName,
                style: theme.textTheme.titleMedium
                    ?.copyWith(fontWeight: FontWeight.w600),
              ),
              Text(
                c.status,
                style: theme.textTheme.labelSmall?.copyWith(
                  color: _statusColor(c.status),
                  fontWeight: FontWeight.w600,
                ),
              ),
            ],
          ),
          orElse: () => Text(l10n.crmClientDetailTitle),
        ),
        bottom: TabBar(
          controller: _tabController,
          isScrollable: true,
          tabAlignment: TabAlignment.start,
          tabs: [
            Tab(icon: const Icon(Icons.dashboard_outlined, size: 18), text: l10n.crmOverviewTab),
            Tab(icon: const Icon(Icons.timeline_outlined, size: 18), text: l10n.crmTimelineTab),
            Tab(icon: const Icon(Icons.calendar_today_outlined, size: 18), text: l10n.crmBookingsTab),
            Tab(icon: const Icon(Icons.task_alt_outlined, size: 18), text: l10n.crmTasksTab),
            Tab(icon: const Icon(Icons.contacts_outlined, size: 18), text: l10n.crmContactsTab),
            Tab(icon: const Icon(Icons.stars_outlined, size: 18), text: l10n.crmLoyaltyTab),
            Tab(icon: const Icon(Icons.security_outlined, size: 18), text: l10n.crmGdprTab),
          ],
        ),
      ),
      body: detailAsync.when(
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (e, _) => Center(child: Text('$e')),
        data: (client) => TabBarView(
          controller: _tabController,
          children: [
            _OverviewTab(clientId: widget.clientId),
            _TimelineTab(eventsAsync: eventsAsync),
            _BookingsPlaceholder(l10n: l10n),
            _TasksTab(
              tasksAsync: tasksAsync,
              clientId: widget.clientId,
              l10n: l10n,
              ref: ref,
            ),
            _ContactsTab(client: client, ref: ref),
            _LoyaltyTab(client: client, ref: ref, l10n: l10n),
            _GdprTab(
              client: client,
              ref: ref,
              l10n: l10n,
              onDeleted: () => Navigator.of(context).pop(),
            ),
          ],
        ),
      ),
    );
  }
}

// ‚îÄ‚îÄ Overview Tab ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class _OverviewTab extends ConsumerWidget {
  final int clientId;

  const _OverviewTab({required this.clientId});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final detailAsync = ref.watch(clientDetailProvider(clientId));

    return detailAsync.when(
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (e, _) => Center(child: Text('$e')),
      data: (client) {
        final theme = Theme.of(context);
        final cs = theme.colorScheme;
        final name = client.fullName.isEmpty ? '#${client.id}' : client.fullName;
        final avatarColor = _avatarColor(client.id);

        return ListView(
          padding: const EdgeInsets.fromLTRB(16, 20, 16, 32),
          children: [
            // Header card
            Card(
              elevation: 0,
              color: cs.surfaceContainerHighest,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(16),
              ),
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Row(
                  children: [
                    CircleAvatar(
                      radius: 32,
                      backgroundColor: avatarColor.withOpacity(0.18),
                      child: Text(
                        _initials(name),
                        style: theme.textTheme.titleLarge?.copyWith(
                          color: avatarColor,
                          fontWeight: FontWeight.w700,
                        ),
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            name,
                            style: theme.textTheme.titleMedium?.copyWith(
                              fontWeight: FontWeight.w700,
                            ),
                          ),
                          const SizedBox(height: 4),
                          Row(
                            children: [
                              _StatusBadge(client.status),
                              if (client.isArchived) ...[
                                const SizedBox(width: 6),
                                _Badge(
                                  'Archiviato',
                                  const Color(0xFF546E7A),
                                ),
                              ],
                            ],
                          ),
                          if ((client.email ?? '').isNotEmpty ||
                              (client.phone ?? '').isNotEmpty) ...[
                            const SizedBox(height: 6),
                            Text(
                              [
                                if ((client.email ?? '').isNotEmpty)
                                  client.email!,
                                if ((client.phone ?? '').isNotEmpty)
                                  client.phone!,
                              ].join('\n'),
                              style: theme.textTheme.bodySmall
                                  ?.copyWith(color: cs.onSurfaceVariant),
                            ),
                          ],
                          if ((client.city ?? '').isNotEmpty) ...[
                            const SizedBox(height: 4),
                            Row(
                              children: [
                                Icon(Icons.location_on_outlined,
                                    size: 13, color: cs.onSurfaceVariant),
                                const SizedBox(width: 3),
                                Text(
                                  client.city!,
                                  style: theme.textTheme.bodySmall
                                      ?.copyWith(color: cs.onSurfaceVariant),
                                ),
                              ],
                            ),
                          ],
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 20),
            // KPI grid
            Text(
              'KPI',
              style: theme.textTheme.labelMedium?.copyWith(
                color: cs.onSurfaceVariant,
                fontWeight: FontWeight.w600,
                letterSpacing: 0.8,
              ),
            ),
            const SizedBox(height: 10),
            GridView.count(
              crossAxisCount: 2,
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              crossAxisSpacing: 10,
              mainAxisSpacing: 10,
              childAspectRatio: 2.2,
              children: [
                _KpiCard(
                  icon: Icons.calendar_month_outlined,
                  color: const Color(0xFF009688),
                  label: l10n.crmKpiVisits,
                  value: '${client.kpi.visitsCount}',
                ),
                _KpiCard(
                  icon: Icons.euro_rounded,
                  color: const Color(0xFF2E7D32),
                  label: l10n.crmKpiSpent,
                  value: '‚Ç¨${client.kpi.totalSpent.toStringAsFixed(0)}',
                ),
                _KpiCard(
                  icon: Icons.receipt_long_outlined,
                  color: const Color(0xFF1565C0),
                  label: l10n.crmKpiAvgTicket,
                  value: '‚Ç¨${client.kpi.avgTicket.toStringAsFixed(0)}',
                ),
                _KpiCard(
                  icon: Icons.person_off_outlined,
                  color: const Color(0xFFEF6C00),
                  label: l10n.crmKpiNoShow,
                  value: '${client.kpi.noShowCount}',
                ),
              ],
            ),
            // Tags
            if (client.tags.isNotEmpty) ...[
              const SizedBox(height: 20),
              Text(
                'Tag',
                style: theme.textTheme.labelMedium?.copyWith(
                  color: cs.onSurfaceVariant,
                  fontWeight: FontWeight.w600,
                  letterSpacing: 0.8,
                ),
              ),
              const SizedBox(height: 8),
              Wrap(
                spacing: 6,
                runSpacing: 6,
                children: client.tags
                    .map((t) => Chip(
                          label: Text(t),
                          labelStyle: theme.textTheme.labelSmall,
                          visualDensity: VisualDensity.compact,
                          side: BorderSide(
                              color: cs.outline.withOpacity(0.2)),
                        ))
                    .toList(),
              ),
            ],
            // Last visit
            if (client.kpi.lastVisit != null) ...[
              const SizedBox(height: 20),
              Container(
                padding: const EdgeInsets.symmetric(
                    horizontal: 14, vertical: 10),
                decoration: BoxDecoration(
                  color: cs.surfaceContainerHighest,
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Row(
                  children: [
                    Icon(Icons.schedule_outlined,
                        size: 16, color: cs.onSurfaceVariant),
                    const SizedBox(width: 8),
                    Text(
                      'Ultima visita: ${_formatDate(client.kpi.lastVisit)}',
                      style: theme.textTheme.bodySmall
                          ?.copyWith(color: cs.onSurfaceVariant),
                    ),
                  ],
                ),
              ),
            ],
          ],
        );
      },
    );
  }
}

class _KpiCard extends StatelessWidget {
  final IconData icon;
  final Color color;
  final String label;
  final String value;

  const _KpiCard({
    required this.icon,
    required this.color,
    required this.label,
    required this.value,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 14, vertical: 12),
      decoration: BoxDecoration(
        color: cs.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: cs.outline.withOpacity(0.08)),
      ),
      child: Row(
        children: [
          Container(
            width: 36,
            height: 36,
            decoration: BoxDecoration(
              color: color.withOpacity(0.12),
              borderRadius: BorderRadius.circular(10),
            ),
            child: Icon(icon, size: 18, color: color),
          ),
          const SizedBox(width: 10),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Text(
                  value,
                  style: theme.textTheme.titleMedium
                      ?.copyWith(fontWeight: FontWeight.w700),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
                Text(
                  label,
                  style: theme.textTheme.labelSmall
                      ?.copyWith(color: cs.onSurfaceVariant),
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

// ‚îÄ‚îÄ Timeline Tab ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class _TimelineTab extends StatelessWidget {
  final AsyncValue<List<CrmEvent>> eventsAsync;

  const _TimelineTab({required this.eventsAsync});

  @override
  Widget build(BuildContext context) {
    return eventsAsync.when(
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (e, _) => Center(child: Text('$e')),
      data: (events) {
        if (events.isEmpty) {
          return const _EmptyState(
            icon: Icons.timeline_outlined,
            label: 'Nessun evento registrato',
          );
        }
        return ListView.builder(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
          itemCount: events.length,
          itemBuilder: (_, i) => _EventItem(
            event: events[i],
            isLast: i == events.length - 1,
          ),
        );
      },
    );
  }
}

class _EventItem extends StatelessWidget {
  final CrmEvent event;
  final bool isLast;

  const _EventItem({required this.event, required this.isLast});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;
    final style = _eventStyle(event.eventType);
    final icon = style.$1;
    final color = style.$2;
    final label = _eventLabel(event.eventType);

    return IntrinsicHeight(
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Timeline column
          SizedBox(
            width: 44,
            child: Column(
              children: [
                Container(
                  width: 36,
                  height: 36,
                  decoration: BoxDecoration(
                    color: color.withOpacity(0.12),
                    shape: BoxShape.circle,
                  ),
                  child: Icon(icon, size: 18, color: color),
                ),
                if (!isLast)
                  Expanded(
                    child: Container(
                      width: 2,
                      margin: const EdgeInsets.symmetric(vertical: 4),
                      decoration: BoxDecoration(
                        color: cs.outline.withOpacity(0.15),
                        borderRadius: BorderRadius.circular(1),
                      ),
                    ),
                  ),
              ],
            ),
          ),
          const SizedBox(width: 12),
          // Content
          Expanded(
            child: Padding(
              padding: EdgeInsets.only(bottom: isLast ? 0 : 16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      Expanded(
                        child: Text(
                          label,
                          style: theme.textTheme.bodyMedium
                              ?.copyWith(fontWeight: FontWeight.w600),
                        ),
                      ),
                      Text(
                        _formatDate(event.occurredAt),
                        style: theme.textTheme.labelSmall
                            ?.copyWith(color: cs.onSurfaceVariant),
                      ),
                    ],
                  ),
                  if (event.payload != null &&
                      event.payload!.isNotEmpty) ...[
                    const SizedBox(height: 4),
                    Text(
                      _payloadPreview(event.payload!),
                      style: theme.textTheme.bodySmall
                          ?.copyWith(color: cs.onSurfaceVariant),
                      maxLines: 2,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}

// ‚îÄ‚îÄ Tasks Tab ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class _TasksTab extends StatelessWidget {
  final AsyncValue<List<CrmTask>> tasksAsync;
  final int clientId;
  final dynamic l10n;
  final WidgetRef ref;

  const _TasksTab({
    required this.tasksAsync,
    required this.clientId,
    required this.l10n,
    required this.ref,
  });

  @override
  Widget build(BuildContext context) {
    return tasksAsync.when(
      loading: () => const Center(child: CircularProgressIndicator()),
      error: (e, _) => Center(child: Text('$e')),
      data: (tasks) {
        if (tasks.isEmpty) {
          return const _EmptyState(
            icon: Icons.task_alt_outlined,
            label: 'Nessun task',
          );
        }
        return ListView.separated(
          padding: const EdgeInsets.all(16),
          itemCount: tasks.length,
          separatorBuilder: (_, __) => const SizedBox(height: 8),
          itemBuilder: (_, i) => _TaskCard(
            task: tasks[i],
            clientId: clientId,
            l10n: l10n,
            ref: ref,
          ),
        );
      },
    );
  }
}

class _TaskCard extends StatelessWidget {
  final CrmTask task;
  final int clientId;
  final dynamic l10n;
  final WidgetRef ref;

  const _TaskCard({
    required this.task,
    required this.clientId,
    required this.l10n,
    required this.ref,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;
    final priorityColor = _priorityColor(task.priority);
    final isDone = task.status == 'done';

    return Card(
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(
          color: task.isOverdue && !isDone
              ? const Color(0xFFC62828).withOpacity(0.3)
              : cs.outline.withOpacity(0.08),
        ),
      ),
      child: Padding(
        padding: const EdgeInsets.all(14),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                // Priority dot
                Container(
                  width: 8,
                  height: 8,
                  margin: const EdgeInsets.only(right: 8, top: 1),
                  decoration: BoxDecoration(
                    color: isDone
                        ? cs.onSurfaceVariant.withOpacity(0.3)
                        : priorityColor,
                    shape: BoxShape.circle,
                  ),
                ),
                Expanded(
                  child: Text(
                    task.title,
                    style: theme.textTheme.bodyMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                      decoration: isDone
                          ? TextDecoration.lineThrough
                          : null,
                      color: isDone ? cs.onSurfaceVariant : null,
                    ),
                  ),
                ),
                const SizedBox(width: 8),
                if (task.isOverdue && !isDone)
                  _Badge('In ritardo', const Color(0xFFC62828)),
              ],
            ),
            const SizedBox(height: 8),
            Row(
              children: [
                _Badge(
                  _priorityLabel(task.priority),
                  priorityColor,
                ),
                const SizedBox(width: 6),
                _Badge(
                  isDone ? 'Completato' : 'Aperto',
                  isDone
                      ? const Color(0xFF2E7D32)
                      : const Color(0xFF1565C0),
                ),
                const Spacer(),
                if (task.dueAt != null) ...[
                  Icon(Icons.schedule_outlined,
                      size: 13, color: cs.onSurfaceVariant),
                  const SizedBox(width: 3),
                  Text(
                    _formatDate(task.dueAt),
                    style: theme.textTheme.labelSmall?.copyWith(
                      color: task.isOverdue && !isDone
                          ? const Color(0xFFC62828)
                          : cs.onSurfaceVariant,
                    ),
                  ),
                ],
              ],
            ),
            const SizedBox(height: 10),
            Align(
              alignment: Alignment.centerRight,
              child: isDone
                  ? OutlinedButton.icon(
                      onPressed: () => ref
                          .read(clientTaskControllerProvider.notifier)
                          .reopen(clientId, task.id),
                      icon: const Icon(Icons.replay_outlined, size: 16),
                      label: Text(l10n.crmTaskReopen),
                      style: OutlinedButton.styleFrom(
                        visualDensity: VisualDensity.compact,
                      ),
                    )
                  : FilledButton.icon(
                      onPressed: () => ref
                          .read(clientTaskControllerProvider.notifier)
                          .complete(clientId, task.id),
                      icon: const Icon(Icons.check_rounded, size: 16),
                      label: Text(l10n.crmTaskComplete),
                      style: FilledButton.styleFrom(
                        visualDensity: VisualDensity.compact,
                        backgroundColor: const Color(0xFF2E7D32),
                      ),
                    ),
            ),
          ],
        ),
      ),
    );
  }
}

// ‚îÄ‚îÄ Bookings Placeholder ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class _BookingsPlaceholder extends StatelessWidget {
  final dynamic l10n;

  const _BookingsPlaceholder({required this.l10n});

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.calendar_today_outlined,
                size: 48, color: cs.onSurfaceVariant.withOpacity(0.4)),
            const SizedBox(height: 16),
            Text(
              l10n.crmBookingsReuseHint,
              textAlign: TextAlign.center,
              style: Theme.of(context)
                  .textTheme
                  .bodyMedium
                  ?.copyWith(color: cs.onSurfaceVariant),
            ),
          ],
        ),
      ),
    );
  }
}

// ‚îÄ‚îÄ Contacts Tab ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class _ContactsTab extends StatelessWidget {
  final CrmClient client;
  final WidgetRef ref;

  const _ContactsTab({required this.client, required this.ref});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;

    return FutureBuilder<Map<String, dynamic>>(
      future: ref.read(apiClientProvider).get(
          '/v1/businesses/${client.businessId}/clients/${client.id}'),
      builder: (_, snap) {
        if (!snap.hasData) {
          return const Center(child: CircularProgressIndicator());
        }
        final contacts =
            (snap.data!['contacts'] as List? ?? const []);
        if (contacts.isEmpty) {
          return const _EmptyState(
            icon: Icons.contacts_outlined,
            label: 'Nessun contatto aggiuntivo',
          );
        }
        return ListView.separated(
          padding: const EdgeInsets.all(16),
          itemCount: contacts.length,
          separatorBuilder: (_, __) => const SizedBox(height: 8),
          itemBuilder: (_, i) {
            final c = contacts[i] as Map;
            final type = (c['type'] ?? '').toString();
            final value = (c['value'] ?? '').toString();
            final isPrimary = c['is_primary'] == 1 || c['is_primary'] == true;
            final style = _contactTypeStyle(type);

            return Card(
              elevation: 0,
              color: cs.surfaceContainerHighest,
              shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(12)),
              child: ListTile(
                leading: Container(
                  width: 40,
                  height: 40,
                  decoration: BoxDecoration(
                    color: style.$2.withOpacity(0.14),
                    borderRadius: BorderRadius.circular(10),
                  ),
                  child: Icon(style.$1, size: 20, color: style.$2),
                ),
                title: Text(
                  value,
                  style:
                      theme.textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.w600),
                ),
                subtitle: Text(
                  _contactTypeLabel(type),
                  style: theme.textTheme.bodySmall
                      ?.copyWith(color: cs.onSurfaceVariant),
                ),
                trailing: isPrimary
                    ? _Badge('Principale', const Color(0xFF009688))
                    : null,
              ),
            );
          },
        );
      },
    );
  }
}

// ‚îÄ‚îÄ Loyalty Tab ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class _LoyaltyTab extends StatelessWidget {
  final CrmClient client;
  final WidgetRef ref;
  final dynamic l10n;

  const _LoyaltyTab(
      {required this.client, required this.ref, required this.l10n});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return FutureBuilder<Map<String, dynamic>>(
      future: ref.read(apiClientProvider).get(
          '/v1/businesses/${client.businessId}/clients/${client.id}/loyalty'),
      builder: (_, snap) {
        if (!snap.hasData) {
          return const Center(child: CircularProgressIndicator());
        }
        final points = (snap.data!['points'] ?? 0).toString();
        final ledger = (snap.data!['ledger'] as List? ?? const []);

        return ListView(
          padding: const EdgeInsets.all(16),
          children: [
            // Points balance card
            Container(
              padding: const EdgeInsets.all(28),
              decoration: BoxDecoration(
                gradient: const LinearGradient(
                  colors: [Color(0xFF00897B), Color(0xFF00695C)],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                ),
                borderRadius: BorderRadius.circular(20),
                boxShadow: [
                  BoxShadow(
                    color: const Color(0xFF009688).withOpacity(0.3),
                    blurRadius: 16,
                    offset: const Offset(0, 6),
                  ),
                ],
              ),
              child: Column(
                children: [
                  const Icon(Icons.stars_rounded,
                      size: 40, color: Colors.white70),
                  const SizedBox(height: 10),
                  Text(
                    points,
                    style: theme.textTheme.displaySmall?.copyWith(
                      color: Colors.white,
                      fontWeight: FontWeight.w800,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    'punti loyalty',
                    style: theme.textTheme.bodyMedium
                        ?.copyWith(color: Colors.white70),
                  ),
                ],
              ),
            ),
            if (ledger.isNotEmpty) ...[
              const SizedBox(height: 24),
              Text(
                'Storico movimenti',
                style: theme.textTheme.labelMedium?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                  fontWeight: FontWeight.w600,
                  letterSpacing: 0.8,
                ),
              ),
              const SizedBox(height: 10),
              ...ledger.map((entry) {
                final e = entry as Map;
                final delta = (e['delta_points'] as num?)?.toInt() ?? 0;
                final isPositive = delta >= 0;
                return ListTile(
                  leading: Icon(
                    isPositive
                        ? Icons.add_circle_outline
                        : Icons.remove_circle_outline,
                    color: isPositive
                        ? const Color(0xFF2E7D32)
                        : const Color(0xFFC62828),
                  ),
                  title: Text(
                    (e['reason'] ?? '').toString(),
                    style: theme.textTheme.bodyMedium
                        ?.copyWith(fontWeight: FontWeight.w500),
                  ),
                  trailing: Text(
                    '${isPositive ? '+' : ''}$delta pt',
                    style: theme.textTheme.titleSmall?.copyWith(
                      color: isPositive
                          ? const Color(0xFF2E7D32)
                          : const Color(0xFFC62828),
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                );
              }),
            ],
          ],
        );
      },
    );
  }
}

// ‚îÄ‚îÄ GDPR Tab ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class _GdprTab extends StatelessWidget {
  final CrmClient client;
  final WidgetRef ref;
  final dynamic l10n;
  final VoidCallback onDeleted;

  const _GdprTab({
    required this.client,
    required this.ref,
    required this.l10n,
    required this.onDeleted,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final cs = theme.colorScheme;

    return ListView(
      padding: const EdgeInsets.all(20),
      children: [
        Container(
          padding: const EdgeInsets.all(20),
          decoration: BoxDecoration(
            color: cs.errorContainer.withOpacity(0.4),
            borderRadius: BorderRadius.circular(16),
            border: Border.all(color: cs.error.withOpacity(0.25)),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Icon(Icons.security_outlined, color: cs.error, size: 22),
                  const SizedBox(width: 10),
                  Text(
                    'GDPR & Privacy',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w700,
                      color: cs.onErrorContainer,
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 12),
              Text(
                'L\'anonimizzazione rimuove tutti i dati personali identificativi del cliente (nome, email, telefono, indirizzi). L\'operazione √® irreversibile.',
                style: theme.textTheme.bodySmall?.copyWith(
                  color: cs.onErrorContainer.withOpacity(0.8),
                  height: 1.5,
                ),
              ),
              const SizedBox(height: 16),
              SizedBox(
                width: double.infinity,
                child: FilledButton.icon(
                  style: FilledButton.styleFrom(
                    backgroundColor: cs.error,
                    foregroundColor: cs.onError,
                  ),
                  onPressed: () async {
                    final ok = await showDialog<bool>(
                          context: context,
                          builder: (ctx) => AlertDialog(
                            title: Text(l10n.crmGdprDeleteTitle),
                            content: Text(l10n.crmGdprDeleteConfirm),
                            actions: [
                              TextButton(
                                  onPressed: () =>
                                      Navigator.pop(ctx, false),
                                  child: Text(l10n.actionCancel)),
                              FilledButton(
                                style: FilledButton.styleFrom(
                                    backgroundColor: cs.error),
                                onPressed: () =>
                                    Navigator.pop(ctx, true),
                                child: Text(l10n.actionConfirm),
                              ),
                            ],
                          ),
                        ) ??
                        false;
                    if (!ok) return;
                    await ref
                        .read(crmRepositoryProvider)
                        .gdprDelete(client.businessId, client.id);
                    if (!context.mounted) return;
                    await FeedbackDialog.showSuccess(
                      context,
                      title: l10n.crmTitle,
                      message: l10n.crmGdprDeleted,
                    );
                    onDeleted();
                  },
                  icon: const Icon(Icons.delete_forever_outlined),
                  label: Text(l10n.crmGdprDeleteTitle),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}

// ‚îÄ‚îÄ Shared atoms ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class _StatusBadge extends StatelessWidget {
  final String status;

  const _StatusBadge(this.status);

  @override
  Widget build(BuildContext context) {
    final color = _statusColor(status);
    return _Badge(status, color);
  }
}

class _Badge extends StatelessWidget {
  final String label;
  final Color color;

  const _Badge(this.label, this.color);

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 3),
      decoration: BoxDecoration(
        color: color.withOpacity(0.12),
        borderRadius: BorderRadius.circular(20),
      ),
      child: Text(
        label,
        style: Theme.of(context).textTheme.labelSmall?.copyWith(
              color: color,
              fontWeight: FontWeight.w600,
            ),
      ),
    );
  }
}

class _EmptyState extends StatelessWidget {
  final IconData icon;
  final String label;

  const _EmptyState({required this.icon, required this.label});

  @override
  Widget build(BuildContext context) {
    final cs = Theme.of(context).colorScheme;
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 52, color: cs.onSurfaceVariant.withOpacity(0.35)),
          const SizedBox(height: 14),
          Text(
            label,
            style: Theme.of(context)
                .textTheme
                .bodyLarge
                ?.copyWith(color: cs.onSurfaceVariant),
          ),
        ],
      ),
    );
  }
}

// ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Color _statusColor(String status) {
  switch (status) {
    case 'lead':
      return const Color(0xFF1565C0);
    case 'active':
      return const Color(0xFF2E7D32);
    case 'inactive':
      return const Color(0xFFEF6C00);
    case 'lost':
      return const Color(0xFFC62828);
    default:
      return const Color(0xFF546E7A);
  }
}

Color _avatarColor(int id) {
  const colors = [
    Color(0xFF009688),
    Color(0xFF1565C0),
    Color(0xFF8E24AA),
    Color(0xFFEF6C00),
    Color(0xFF2E7D32),
    Color(0xFF0288D1),
  ];
  return colors[id % colors.length];
}

Color _priorityColor(String priority) {
  switch (priority) {
    case 'high':
      return const Color(0xFFC62828);
    case 'medium':
      return const Color(0xFFF9A825);
    case 'low':
      return const Color(0xFF546E7A);
    default:
      return const Color(0xFF546E7A);
  }
}

String _priorityLabel(String priority) {
  switch (priority) {
    case 'high':
      return 'Alta';
    case 'medium':
      return 'Media';
    case 'low':
      return 'Bassa';
    default:
      return priority;
  }
}

String _eventLabel(String type) {
  switch (type) {
    case 'booking_created':
      return 'Prenotazione creata';
    case 'booking_cancelled':
      return 'Prenotazione cancellata';
    case 'booking_no_show':
      return 'No-show';
    case 'payment':
      return 'Pagamento';
    case 'note':
      return 'Nota';
    case 'task':
      return 'Task';
    case 'message':
      return 'Messaggio';
    case 'campaign':
      return 'Campagna';
    case 'merge':
      return 'Merge cliente';
    case 'gdpr_export':
      return 'Export GDPR';
    case 'gdpr_delete':
      return 'Eliminazione GDPR';
    default:
      return type;
  }
}

(IconData, Color) _eventStyle(String type) {
  switch (type) {
    case 'booking_created':
      return (Icons.calendar_today_rounded, const Color(0xFF2E7D32));
    case 'booking_cancelled':
      return (Icons.event_busy_rounded, const Color(0xFFC62828));
    case 'booking_no_show':
      return (Icons.person_off_rounded, const Color(0xFFEF6C00));
    case 'payment':
      return (Icons.payments_rounded, const Color(0xFF1565C0));
    case 'note':
      return (Icons.sticky_note_2_rounded, const Color(0xFF5C6BC0));
    case 'task':
      return (Icons.task_alt_rounded, const Color(0xFF009688));
    case 'message':
      return (Icons.message_rounded, const Color(0xFF0288D1));
    case 'campaign':
      return (Icons.campaign_rounded, const Color(0xFF8E24AA));
    case 'merge':
      return (Icons.merge_rounded, const Color(0xFF546E7A));
    case 'gdpr_export':
      return (Icons.download_rounded, const Color(0xFF546E7A));
    case 'gdpr_delete':
      return (Icons.delete_forever_rounded, const Color(0xFFC62828));
    default:
      return (Icons.history_rounded, const Color(0xFF546E7A));
  }
}

(IconData, Color) _contactTypeStyle(String type) {
  switch (type) {
    case 'email':
      return (Icons.email_outlined, const Color(0xFF1565C0));
    case 'phone':
      return (Icons.phone_outlined, const Color(0xFF2E7D32));
    case 'whatsapp':
      return (Icons.chat_outlined, const Color(0xFF2E7D32));
    case 'instagram':
      return (Icons.photo_camera_outlined, const Color(0xFF8E24AA));
    case 'facebook':
      return (Icons.facebook_outlined, const Color(0xFF1565C0));
    default:
      return (Icons.link_outlined, const Color(0xFF546E7A));
  }
}

String _contactTypeLabel(String type) {
  switch (type) {
    case 'email':
      return 'Email';
    case 'phone':
      return 'Telefono';
    case 'whatsapp':
      return 'WhatsApp';
    case 'instagram':
      return 'Instagram';
    case 'facebook':
      return 'Facebook';
    default:
      return type;
  }
}

String _payloadPreview(Map<String, dynamic> payload) {
  final parts = payload.entries
      .where((e) => e.value != null && e.value.toString().isNotEmpty)
      .take(3)
      .map((e) => '${e.key}: ${e.value}')
      .toList();
  return parts.join(' ¬∑ ');
}

String _formatDate(DateTime? dt) {
  if (dt == null) return '-';
  return '${dt.day.toString().padLeft(2, '0')}/${dt.month.toString().padLeft(2, '0')}/${dt.year}';
}

String _initials(String name) {
  final parts = name.trim().split(' ').where((p) => p.isNotEmpty).toList();
  if (parts.isEmpty) return '?';
  if (parts.length == 1) return parts[0][0].toUpperCase();
  return '${parts[0][0]}${parts.last[0]}'.toUpperCase();
}
--- FILE: lib/features/business/providers/superadmin_selected_business_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/services/preferences_service.dart';
import '../../agenda/providers/agenda_scroll_provider.dart';
import '../../agenda/providers/appointment_providers.dart';
import '../../agenda/providers/booking_reschedule_provider.dart';
import '../../agenda/providers/bookings_provider.dart';
import '../../agenda/providers/date_range_provider.dart';
import '../../agenda/providers/drag_session_provider.dart';
import '../../agenda/providers/dragged_appointment_provider.dart';
import '../../agenda/providers/dragged_base_range_provider.dart';
import '../../agenda/providers/initial_scroll_provider.dart';
import '../../agenda/providers/layout_config_provider.dart';
import '../../agenda/providers/location_providers.dart';
import '../../agenda/providers/pending_drop_provider.dart';
import '../../agenda/providers/resizing_provider.dart';
import '../../agenda/providers/resource_providers.dart';
import '../../agenda/providers/selected_appointment_provider.dart';
import '../../agenda/providers/staff_filter_providers.dart';
import '../../agenda/providers/temp_drag_time_provider.dart';
import '../../agenda/providers/time_blocks_provider.dart';
import '../../auth/providers/current_business_user_provider.dart';
import '../../clients/providers/clients_providers.dart';
import '../../class_events/providers/class_events_providers.dart';
import '../../crm/providers/crm_providers.dart';
import '../../services/providers/service_categories_provider.dart';
import '../../services/providers/services_provider.dart';
import '../../staff/providers/availability_exceptions_provider.dart';
import '../../staff/providers/staff_providers.dart';
import 'location_closures_provider.dart';

/// Notifier per tracciare se il superadmin ha selezionato un business.
/// Quando √® null, mostra la lista business.
/// Salva l'ultimo business visitato nelle preferenze per accesso rapido.
class SuperadminSelectedBusinessNotifier extends Notifier<int?> {
  @override
  int? build() {
    // Carica l'ultimo business salvato dalle preferenze
    final prefs = ref.read(preferencesServiceProvider);
    return prefs.getSuperadminLastBusinessId();
  }

  void select(int businessId) {
    state = businessId;
    // Salva nelle preferenze per accesso rapido al prossimo login
    ref
        .read(preferencesServiceProvider)
        .setSuperadminLastBusinessId(businessId);
  }

  /// Pulisce la selezione e invalida tutti i provider relativi al business.
  void clear() {
    state = null;
    // NON rimuoviamo dalle preferenze: l'utente pu√≤ tornare con "Cambia Business"
    // ma al prossimo login verr√† comunque portato all'ultimo business
  }

  /// Pulisce completamente la selezione, anche dalle preferenze.
  /// Da usare al logout o se il business viene eliminato.
  void clearCompletely() {
    state = null;
    ref.read(preferencesServiceProvider).clearSuperadminLastBusinessId();
  }
}

/// Invalida tutti i provider che contengono dati specifici del business.
/// Da chiamare da UI/router, non dal notifier di selezione business, per evitare
/// dipendenze circolari durante la fase di invalidazione.
void invalidateBusinessScopedProviders(Object refObj) {
  final ref = refObj as dynamic;
  // Staff
  ref.invalidate(allStaffProvider);

  // Locations
  ref.invalidate(locationsProvider);
  ref.invalidate(currentLocationProvider);

  // Services
  ref.invalidate(servicesProvider);
  ref.invalidate(serviceCategoriesProvider);
  ref.invalidate(serviceStaffEligibilityProvider);

  // Clients
  ref.invalidate(clientsProvider);
  ref.invalidate(crmClientsProvider);
  ref.invalidate(clientTagsProvider);
  ref.invalidate(crmSegmentsProvider);
  ref.invalidate(overdueTasksProvider);

  // Appointments
  ref.invalidate(appointmentsProvider);

  // Bookings (prenotazioni con note/clientName)
  ref.invalidate(bookingsProvider);

  // Resources
  ref.invalidate(resourcesProvider);

  // Time Blocks
  ref.invalidate(timeBlocksProvider);

  // Availability Exceptions
  ref.invalidate(availabilityExceptionsProvider);

  // Location Closures
  ref.invalidate(locationClosuresProvider);

  // UI State legato al business (contiene ID di entit√† business-specific)
  ref.invalidate(selectedStaffIdsProvider);
  ref.invalidate(staffFilterModeProvider);
  ref.invalidate(selectedAppointmentProvider);
  ref.invalidate(dragSessionProvider);
  ref.invalidate(draggedAppointmentIdProvider);
  ref.invalidate(draggedBaseRangeProvider);
  ref.invalidate(tempDragTimeProvider);
  ref.invalidate(resizingProvider);
  ref.invalidate(pendingDropProvider);
  ref.invalidate(bookingRescheduleSessionProvider);

  // NOTE: currentBusinessIdProvider NON va invalidato qui perch√© usa ref.listen
  // su superadminSelectedBusinessProvider, quindi si aggiorna automaticamente.
  // Invalidarlo qui creerebbe una dipendenza circolare.

  // Layout e UI state (per sicurezza, anche se sembrano UI-only)
  ref.invalidate(layoutConfigProvider);
  ref.invalidate(agendaDateProvider);
  ref.invalidate(agendaScrollProvider);
  ref.invalidate(initialScrollDoneProvider);
  ref.invalidate(agendaVerticalOffsetProvider);

  // Class events
  ref.invalidate(classEventsProvider);
  ref.invalidate(classTypesProvider);
  ref.invalidate(selectedClassTypeIdProvider);

  // Business User Context (permessi location)
  ref.invalidate(currentBusinessUserContextProvider);
}

final superadminSelectedBusinessProvider =
    NotifierProvider<SuperadminSelectedBusinessNotifier, int?>(
      SuperadminSelectedBusinessNotifier.new,
    );
--- FILE: lib/features/business/providers/business_users_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'business_users_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning
/// Provider per il repository degli operatori.

@ProviderFor(businessUsersRepository)
const businessUsersRepositoryProvider = BusinessUsersRepositoryProvider._();

/// Provider per il repository degli operatori.

final class BusinessUsersRepositoryProvider
    extends
        $FunctionalProvider<
          BusinessUsersRepository,
          BusinessUsersRepository,
          BusinessUsersRepository
        >
    with $Provider<BusinessUsersRepository> {
  /// Provider per il repository degli operatori.
  const BusinessUsersRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'businessUsersRepositoryProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$businessUsersRepositoryHash();

  @$internal
  @override
  $ProviderElement<BusinessUsersRepository> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  BusinessUsersRepository create(Ref ref) {
    return businessUsersRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(BusinessUsersRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<BusinessUsersRepository>(value),
    );
  }
}

String _$businessUsersRepositoryHash() =>
    r'9f3d9ab7572fd99339bb7c1cf46784915cd0faf8';

/// Notifier per gestire gli operatori di un business.

@ProviderFor(BusinessUsersNotifier)
const businessUsersProvider = BusinessUsersNotifierFamily._();

/// Notifier per gestire gli operatori di un business.
final class BusinessUsersNotifierProvider
    extends $NotifierProvider<BusinessUsersNotifier, BusinessUsersState> {
  /// Notifier per gestire gli operatori di un business.
  const BusinessUsersNotifierProvider._({
    required BusinessUsersNotifierFamily super.from,
    required int super.argument,
  }) : super(
         retry: null,
         name: r'businessUsersProvider',
         isAutoDispose: true,
         dependencies: null,
         $allTransitiveDependencies: null,
       );

  @override
  String debugGetCreateSourceHash() => _$businessUsersNotifierHash();

  @override
  String toString() {
    return r'businessUsersProvider'
        ''
        '($argument)';
  }

  @$internal
  @override
  BusinessUsersNotifier create() => BusinessUsersNotifier();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(BusinessUsersState value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<BusinessUsersState>(value),
    );
  }

  @override
  bool operator ==(Object other) {
    return other is BusinessUsersNotifierProvider && other.argument == argument;
  }

  @override
  int get hashCode {
    return argument.hashCode;
  }
}

String _$businessUsersNotifierHash() =>
    r'ad5c91c0763998e097c8aedb9e969dfa063a0858';

/// Notifier per gestire gli operatori di un business.

final class BusinessUsersNotifierFamily extends $Family
    with
        $ClassFamilyOverride<
          BusinessUsersNotifier,
          BusinessUsersState,
          BusinessUsersState,
          BusinessUsersState,
          int
        > {
  const BusinessUsersNotifierFamily._()
    : super(
        retry: null,
        name: r'businessUsersProvider',
        dependencies: null,
        $allTransitiveDependencies: null,
        isAutoDispose: true,
      );

  /// Notifier per gestire gli operatori di un business.

  BusinessUsersNotifierProvider call(int businessId) =>
      BusinessUsersNotifierProvider._(argument: businessId, from: this);

  @override
  String toString() => r'businessUsersProvider';
}

/// Notifier per gestire gli operatori di un business.

abstract class _$BusinessUsersNotifier extends $Notifier<BusinessUsersState> {
  late final _$args = ref.$arg as int;
  int get businessId => _$args;

  BusinessUsersState build(int businessId);
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build(_$args);
    final ref = this.ref as $Ref<BusinessUsersState, BusinessUsersState>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<BusinessUsersState, BusinessUsersState>,
              BusinessUsersState,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/features/business/providers/locations_providers.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../core/network/network_providers.dart';
import '../data/locations_repository.dart';

part 'locations_providers.g.dart';

@riverpod
LocationsRepository locationsRepository(Ref ref) {
  return LocationsRepository(apiClient: ref.watch(apiClientProvider));
}
--- FILE: lib/features/business/providers/business_providers.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../core/network/network_providers.dart';
import '../data/business_repository.dart';

part 'business_providers.g.dart';

@riverpod
BusinessRepository businessRepository(Ref ref) {
  return BusinessRepository(apiClient: ref.watch(apiClientProvider));
}
--- FILE: lib/features/business/providers/business_users_provider.dart ---
import 'package:flutter/foundation.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../app/providers/global_loading_provider.dart';
import '../../../core/models/business_invitation.dart';
import '../../../core/models/business_user.dart';
import '../../../core/network/api_client.dart';
import '../../../core/network/network_providers.dart';
import '../data/business_users_repository.dart';

part 'business_users_provider.g.dart';

/// Provider per il repository degli operatori.
@riverpod
BusinessUsersRepository businessUsersRepository(Ref ref) {
  return BusinessUsersRepository(apiClient: ref.watch(apiClientProvider));
}

/// Stato per la gestione degli operatori di un business.
class BusinessUsersState {
  final List<BusinessUser> users;
  final List<BusinessInvitation> invitations;
  final bool isLoading;
  final String? error;

  const BusinessUsersState({
    this.users = const [],
    this.invitations = const [],
    this.isLoading = false,
    this.error,
  });

  BusinessUsersState copyWith({
    List<BusinessUser>? users,
    List<BusinessInvitation>? invitations,
    bool? isLoading,
    String? error,
  }) => BusinessUsersState(
    users: users ?? this.users,
    invitations: invitations ?? this.invitations,
    isLoading: isLoading ?? this.isLoading,
    error: error,
  );

  /// Utenti attivi (escluso l'utente corrente).
  List<BusinessUser> get activeUsers =>
      users.where((u) => u.status == 'active').toList();

  /// Numero totale di membri (utenti attivi + inviti pendenti).
  int get totalMembers => activeUsers.length + invitations.length;
}

/// Notifier per gestire gli operatori di un business.
@riverpod
class BusinessUsersNotifier extends _$BusinessUsersNotifier {
  @override
  BusinessUsersState build(int businessId) {
    if (businessId <= 0) {
      return const BusinessUsersState(isLoading: false);
    }
    final initial = const BusinessUsersState(isLoading: true);
    // Defer loading to avoid reading state before initialization.
    Future.microtask(_loadData);
    return initial;
  }

  BusinessUsersRepository get _repository =>
      ref.read(businessUsersRepositoryProvider);

  String _toUserError(Object e) {
    if (e is ApiException) return e.message;
    return e.toString();
  }

  /// Carica operatori e inviti.
  Future<void> _loadData() async {
    if (businessId <= 0) {
      if (ref.mounted) {
        state = state.copyWith(isLoading: false, error: null);
      }
      return;
    }
    if (!ref.mounted) return;
    state = state.copyWith(isLoading: true, error: null);
    try {
      final results = await Future.wait([
        _repository.getUsers(businessId),
        _repository.getInvitations(businessId, status: 'all'),
      ]);
      if (!ref.mounted) return;
      state = state.copyWith(
        users: results[0] as List<BusinessUser>,
        invitations: results[1] as List<BusinessInvitation>,
        isLoading: false,
      );
      final owner = state.users.firstWhere(
        (u) => u.role == 'owner',
        orElse: () => const BusinessUser(
          id: 0,
          userId: 0,
          businessId: 0,
          role: '',
          email: '',
          firstName: '',
          lastName: '',
          status: 'active',
        ),
      );
      if (owner.userId != 0) {
        debugPrint(
          'BusinessUsersNotifier owner: userId=${owner.userId}, '
          'email=${owner.email}, '
          'firstName=${owner.firstName}, '
          'lastName=${owner.lastName}, '
          'businessId=$businessId',
        );
      }
    } catch (e) {
      debugPrint('BusinessUsersNotifier._loadData error: $e');
      if (!ref.mounted) return;
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }

  /// Ricarica i dati.
  Future<void> refresh() => _loadData();

  /// Aggiorna un operatore (ruolo e/o scope).
  Future<bool> updateUser({
    required int userId,
    required String role,
    String? scopeType,
    List<int>? locationIds,
    int? staffId,
  }) async {
    final globalLoading = ref.read(globalLoadingProvider.notifier);
    globalLoading.show();
    state = state.copyWith(isLoading: true, error: null);
    try {
      await _repository.updateUser(
        businessId: businessId,
        userId: userId,
        role: role,
        scopeType: scopeType,
        locationIds: locationIds,
        staffId: staffId,
      );
      // Always reload from API after update to keep scope/location state aligned
      // with server-side rules and avoid stale local UI.
      await _loadData();
      return true;
    } catch (e) {
      debugPrint('BusinessUsersNotifier.updateUser error: $e');
      if (ref.mounted) {
        state = state.copyWith(isLoading: false, error: _toUserError(e));
      }
      return false;
    } finally {
      globalLoading.hide();
    }
  }

  /// Rimuove un operatore.
  Future<bool> removeUser(int userId) async {
    final globalLoading = ref.read(globalLoadingProvider.notifier);
    globalLoading.show();
    state = state.copyWith(isLoading: true, error: null);
    try {
      await _repository.removeUser(businessId: businessId, userId: userId);
      if (ref.mounted) {
        state = state.copyWith(
          users: state.users.where((u) => u.userId != userId).toList(),
          isLoading: false,
        );
      }
      return true;
    } catch (e) {
      debugPrint('BusinessUsersNotifier.removeUser error: $e');
      if (ref.mounted) {
        state = state.copyWith(isLoading: false, error: _toUserError(e));
      }
      return false;
    } finally {
      globalLoading.hide();
    }
  }

  /// Crea un nuovo invito.
  Future<BusinessInvitation?> createInvitation({
    required String email,
    required String role,
    String scopeType = 'business',
    List<int>? locationIds,
    int? staffId,
  }) async {
    final globalLoading = ref.read(globalLoadingProvider.notifier);
    globalLoading.show();
    state = state.copyWith(isLoading: true, error: null);
    try {
      final invitation = await _repository.createInvitation(
        businessId: businessId,
        email: email,
        role: role,
        scopeType: scopeType,
        locationIds: locationIds,
        staffId: staffId,
      );
      if (ref.mounted) {
        state = state.copyWith(
          invitations: [...state.invitations, invitation],
          isLoading: false,
        );
      }
      return invitation;
    } catch (e) {
      debugPrint('BusinessUsersNotifier.createInvitation error: $e');
      if (ref.mounted) {
        state = state.copyWith(isLoading: false, error: _toUserError(e));
      }
      return null;
    } finally {
      globalLoading.hide();
    }
  }

  /// Reinvia un invito pendente creando un nuovo token e una nuova scadenza.
  Future<bool> resendInvitation(BusinessInvitation invitation) async {
    if (ref.mounted) {
      state = state.copyWith(isLoading: true, error: null);
    }
    try {
      await _repository.createInvitation(
        businessId: businessId,
        email: invitation.email,
        role: invitation.role,
        scopeType: invitation.scopeType,
        locationIds: invitation.locationIds,
        staffId: invitation.staffId,
      );
      await _loadData();
      return true;
    } catch (e) {
      debugPrint('BusinessUsersNotifier.resendInvitation error: $e');
      if (ref.mounted) {
        state = state.copyWith(isLoading: false, error: _toUserError(e));
      }
      return false;
    }
  }

  /// Elimina un invito.
  Future<bool> deleteInvitation(int invitationId) async {
    final globalLoading = ref.read(globalLoadingProvider.notifier);
    globalLoading.show();
    state = state.copyWith(isLoading: true, error: null);
    try {
      await _repository.deleteInvitation(
        businessId: businessId,
        invitationId: invitationId,
      );
      if (ref.mounted) {
        state = state.copyWith(
          invitations: state.invitations
              .where((i) => i.id != invitationId)
              .toList(),
          isLoading: false,
        );
      }
      return true;
    } catch (e) {
      debugPrint('BusinessUsersNotifier.deleteInvitation error: $e');
      if (ref.mounted) {
        state = state.copyWith(isLoading: false, error: _toUserError(e));
      }
      return false;
    } finally {
      globalLoading.hide();
    }
  }

  /// Pulisce l'errore.
  void clearError() {
    state = state.copyWith(error: null);
  }
}
--- FILE: lib/features/business/providers/business_providers.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'business_providers.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(businessRepository)
const businessRepositoryProvider = BusinessRepositoryProvider._();

final class BusinessRepositoryProvider
    extends
        $FunctionalProvider<
          BusinessRepository,
          BusinessRepository,
          BusinessRepository
        >
    with $Provider<BusinessRepository> {
  const BusinessRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'businessRepositoryProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$businessRepositoryHash();

  @$internal
  @override
  $ProviderElement<BusinessRepository> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  BusinessRepository create(Ref ref) {
    return businessRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(BusinessRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<BusinessRepository>(value),
    );
  }
}

String _$businessRepositoryHash() =>
    r'55bef82ae40b071dbb11c1e495f81fb044151b99';
--- FILE: lib/features/business/providers/locations_providers.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'locations_providers.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(locationsRepository)
const locationsRepositoryProvider = LocationsRepositoryProvider._();

final class LocationsRepositoryProvider
    extends
        $FunctionalProvider<
          LocationsRepository,
          LocationsRepository,
          LocationsRepository
        >
    with $Provider<LocationsRepository> {
  const LocationsRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'locationsRepositoryProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$locationsRepositoryHash();

  @$internal
  @override
  $ProviderElement<LocationsRepository> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  LocationsRepository create(Ref ref) {
    return locationsRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(LocationsRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<LocationsRepository>(value),
    );
  }
}

String _$locationsRepositoryHash() =>
    r'b7c903cb21a57814102a5236a124d97353234b6d';
--- FILE: lib/features/business/providers/closures_filter_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// State for Closures screen filters
class ClosuresFilterState {
  const ClosuresFilterState({
    required this.startDate,
    required this.endDate,
    this.selectedPreset = 'from_today',
  });

  final DateTime startDate;
  final DateTime endDate;
  final String selectedPreset;

  ClosuresFilterState copyWith({
    DateTime? startDate,
    DateTime? endDate,
    String? selectedPreset,
  }) {
    return ClosuresFilterState(
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      selectedPreset: selectedPreset ?? this.selectedPreset,
    );
  }
}

class ClosuresFilterNotifier extends Notifier<ClosuresFilterState> {
  @override
  ClosuresFilterState build() {
    final today = DateUtils.dateOnly(DateTime.now());
    // Default: "A partire da oggi" - from today to far future
    return ClosuresFilterState(
      startDate: today,
      endDate: DateTime(today.year + 10, 12, 31),
      selectedPreset: 'from_today',
    );
  }

  void setDateRange(DateTime start, DateTime end) {
    state = state.copyWith(
      startDate: start,
      endDate: end,
      selectedPreset: 'custom',
    );
  }

  void applyPreset(String preset) {
    final now = DateTime.now();
    final today = DateUtils.dateOnly(now);

    DateTime startDate;
    DateTime endDate;

    switch (preset) {
      case 'from_today':
        startDate = today;
        endDate = DateTime(today.year + 10, 12, 31); // Far future
        break;
      case 'year':
        startDate = DateTime(now.year, 1, 1);
        endDate = DateTime(now.year, 12, 31);
        break;
      case 'last_year':
        startDate = DateTime(now.year - 1, 1, 1);
        endDate = DateTime(now.year - 1, 12, 31);
        break;
      case 'all':
        startDate = DateTime(2000, 1, 1); // Far past
        endDate = DateTime(today.year + 10, 12, 31); // Far future
        break;
      case 'custom':
      default:
        // Keep current dates for custom
        return;
    }

    state = state.copyWith(
      startDate: startDate,
      endDate: endDate,
      selectedPreset: preset,
    );
  }
}

final closuresFilterProvider =
    NotifierProvider<ClosuresFilterNotifier, ClosuresFilterState>(
      ClosuresFilterNotifier.new,
    );
--- FILE: lib/features/business/providers/location_closures_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/models/location_closure.dart';
import '/core/network/network_providers.dart';
import '/features/agenda/providers/business_providers.dart';
import '/features/agenda/providers/location_providers.dart';
import '/features/auth/providers/current_business_user_provider.dart';

/// Provider per gestire le chiusure di un business (multi-location)
final locationClosuresProvider =
    AsyncNotifierProvider<LocationClosuresNotifier, List<LocationClosure>>(
      LocationClosuresNotifier.new,
    );

class LocationClosuresNotifier extends AsyncNotifier<List<LocationClosure>> {
  @override
  Future<List<LocationClosure>> build() async {
    final canManageSettings = ref.watch(canManageBusinessSettingsProvider);
    if (!canManageSettings) {
      return [];
    }
    return _loadClosures();
  }

  Future<List<LocationClosure>> _loadClosures() async {
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId <= 0) {
      return [];
    }

    try {
      final apiClient = ref.read(apiClientProvider);
      final closures = await apiClient.getClosures(businessId);
      return closures;
    } catch (e) {
      // Se errore, ritorna lista vuota
      return [];
    }
  }

  Future<void> refresh() async {
    final canManageSettings = ref.read(canManageBusinessSettingsProvider);
    if (!canManageSettings) {
      state = const AsyncValue.data([]);
      return;
    }
    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() => _loadClosures());
  }

  Future<void> addClosure({
    required List<int> locationIds,
    required DateTime startDate,
    required DateTime endDate,
    String? reason,
  }) async {
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId <= 0) return;

    final apiClient = ref.read(apiClientProvider);
    final closure = await apiClient.createClosure(
      businessId: businessId,
      locationIds: locationIds,
      startDate: startDate,
      endDate: endDate,
      reason: reason,
    );

    state = state.whenData((closures) {
      final newList = [...closures, closure];
      // Ordina per data inizio
      newList.sort((a, b) => a.startDate.compareTo(b.startDate));
      return newList;
    });
  }

  Future<void> updateClosure({
    required int closureId,
    required List<int> locationIds,
    required DateTime startDate,
    required DateTime endDate,
    String? reason,
  }) async {
    final apiClient = ref.read(apiClientProvider);
    final updated = await apiClient.updateClosure(
      closureId: closureId,
      locationIds: locationIds,
      startDate: startDate,
      endDate: endDate,
      reason: reason,
    );

    state = state.whenData((closures) {
      return closures.map((c) => c.id == closureId ? updated : c).toList()
        ..sort((a, b) => a.startDate.compareTo(b.startDate));
    });
  }

  Future<void> deleteClosure(int closureId) async {
    final apiClient = ref.read(apiClientProvider);
    await apiClient.deleteClosure(closureId);

    state = state.whenData((closures) {
      return closures.where((c) => c.id != closureId).toList();
    });
  }
}

/// Provider derivato: chiusure future (a partire da oggi)
final futureLocationClosuresProvider =
    Provider<AsyncValue<List<LocationClosure>>>((ref) {
      final closuresAsync = ref.watch(locationClosuresProvider);
      final today = DateTime.now();
      final todayOnly = DateTime(today.year, today.month, today.day);

      return closuresAsync.whenData((closures) {
        return closures.where((c) {
          // Include se la data fine √® >= oggi
          return !c.endDate.isBefore(todayOnly);
        }).toList();
      });
    });

/// Provider derivato: chiusure passate (terminate prima di oggi)
final pastLocationClosuresProvider =
    Provider<AsyncValue<List<LocationClosure>>>((ref) {
      final closuresAsync = ref.watch(locationClosuresProvider);
      final today = DateTime.now();
      final todayOnly = DateTime(today.year, today.month, today.day);

      return closuresAsync.whenData((closures) {
        return closures.where((c) {
          return c.endDate.isBefore(todayOnly);
        }).toList();
      });
    });

/// Provider per controllare se una data specifica √® un giorno di chiusura per una location specifica
final isDateClosedForLocationProvider =
    Provider.family<bool, ({DateTime date, int locationId})>((ref, params) {
      final closuresAsync = ref.watch(locationClosuresProvider);
      final dateOnly = DateTime(
        params.date.year,
        params.date.month,
        params.date.day,
      );

      return closuresAsync.maybeWhen(
        data: (closures) {
          return closures.any(
            (c) =>
                c.containsDate(dateOnly) &&
                c.locationIds.contains(params.locationId),
          );
        },
        orElse: () => false,
      );
    });

/// Provider derivato: chiusure che si applicano a una location specifica
final closuresForLocationProvider =
    Provider.family<AsyncValue<List<LocationClosure>>, int>((ref, locationId) {
      final closuresAsync = ref.watch(locationClosuresProvider);

      return closuresAsync.whenData((closures) {
        return closures
            .where((c) => c.locationIds.contains(locationId))
            .toList();
      });
    });

/// Provider per controllare se una data specifica √® un giorno di chiusura
/// per la location corrente (usa currentLocationIdProvider)
final isDateClosedProvider = Provider.family<bool, DateTime>((ref, date) {
  final currentLocationId = ref.watch(currentLocationIdProvider);

  return ref.watch(
    isDateClosedForLocationProvider((
      date: date,
      locationId: currentLocationId,
    )),
  );
});
--- FILE: lib/features/business/data/business_api.dart ---
--- FILE: lib/features/business/data/locations_repository.dart ---
import '../../../core/models/location.dart';
import '../../../core/network/api_client.dart';

class LocationsRepository {
  LocationsRepository({required ApiClient apiClient}) : _apiClient = apiClient;

  final ApiClient _apiClient;

  Future<List<Location>> getByBusinessId(int businessId) async {
    final data = await _apiClient.getLocations(businessId);
    return data.map((json) => Location.fromJson(json)).toList();
  }

  Future<Location> create({
    required int businessId,
    required String name,
    String? address,
    String? phone,
    String? email,
    String? timezone,
    int? minBookingNoticeHours,
    int? maxBookingAdvanceDays,
    int? cancellationHours,
    bool? allowCustomerChooseStaff,
    bool? isActive,
  }) async {
    final data = await _apiClient.createLocation(
      businessId: businessId,
      name: name,
      address: address,
      phone: phone,
      email: email,
      timezone: timezone,
      minBookingNoticeHours: minBookingNoticeHours,
      maxBookingAdvanceDays: maxBookingAdvanceDays,
      cancellationHours: cancellationHours,
      allowCustomerChooseStaff: allowCustomerChooseStaff,
      isActive: isActive,
    );
    return Location.fromJson(data);
  }

  Future<Location> update({
    required int locationId,
    String? name,
    String? address,
    String? phone,
    String? email,
    String? timezone,
    int? minBookingNoticeHours,
    int? maxBookingAdvanceDays,
    int? cancellationHours,
    bool? allowCustomerChooseStaff,
    int? onlineBookingSlotIntervalMinutes,
    String? slotDisplayMode,
    int? minGapMinutes,
    bool? isActive,
  }) async {
    final data = await _apiClient.updateLocation(
      locationId: locationId,
      name: name,
      address: address,
      phone: phone,
      email: email,
      timezone: timezone,
      minBookingNoticeHours: minBookingNoticeHours,
      maxBookingAdvanceDays: maxBookingAdvanceDays,
      cancellationHours: cancellationHours,
      allowCustomerChooseStaff: allowCustomerChooseStaff,
      onlineBookingSlotIntervalMinutes: onlineBookingSlotIntervalMinutes,
      slotDisplayMode: slotDisplayMode,
      minGapMinutes: minGapMinutes,
      isActive: isActive,
    );
    return Location.fromJson(data);
  }

  Future<void> delete(int locationId) async {
    await _apiClient.deleteLocation(locationId);
  }
}
--- FILE: lib/features/business/data/business_repository.dart ---
import '../../../core/models/business.dart';
import '../../../core/network/api_client.dart';

class BusinessRepository {
  BusinessRepository({required ApiClient apiClient}) : _apiClient = apiClient;

  final ApiClient _apiClient;

  Future<List<Business>> getAll() async {
    final data = await _apiClient.getBusinesses();
    return data.map((json) => Business.fromJson(json)).toList();
  }

  /// Superadmin: lista tutti i business.
  Future<List<Business>> getAllAdmin({String? search}) async {
    final data = await _apiClient.getAdminBusinesses(search: search);
    return data.map((json) => Business.fromJson(json)).toList();
  }

  /// Superadmin: crea un nuovo business.
  /// Se adminEmail fornito, invia email di benvenuto all'admin.
  Future<Business> createBusiness({
    required String name,
    required String slug,
    String? adminEmail,
    String? email,
    String? phone,
    String? onlineBookingsNotificationEmail,
    String serviceColorPalette = 'legacy',
    String timezone = 'Europe/Rome',
    String currency = 'EUR',
    String? adminFirstName,
    String? adminLastName,
  }) async {
    final data = await _apiClient.createAdminBusiness(
      name: name,
      slug: slug,
      adminEmail: adminEmail,
      email: email,
      phone: phone,
      onlineBookingsNotificationEmail: onlineBookingsNotificationEmail,
      serviceColorPalette: serviceColorPalette,
      timezone: timezone,
      currency: currency,
      adminFirstName: adminFirstName,
      adminLastName: adminLastName,
    );
    // API ritorna { business: {...}, ... }
    final businessJson = data['business'] as Map<String, dynamic>? ?? data;
    return Business.fromJson(businessJson);
  }

  /// Superadmin: aggiorna un business esistente.
  /// Se adminEmail cambia, trasferisce ownership e invia email al nuovo admin.
  Future<Business> updateBusiness({
    required int businessId,
    String? name,
    String? slug,
    String? email,
    String? phone,
    String? onlineBookingsNotificationEmail,
    String? serviceColorPalette,
    String? timezone,
    String? currency,
    String? adminEmail,
  }) async {
    final data = await _apiClient.updateAdminBusiness(
      businessId: businessId,
      name: name,
      slug: slug,
      email: email,
      phone: phone,
      onlineBookingsNotificationEmail: onlineBookingsNotificationEmail,
      serviceColorPalette: serviceColorPalette,
      timezone: timezone,
      currency: currency,
      adminEmail: adminEmail,
    );
    // API ritorna { business: {...} }
    final businessJson = data['business'] as Map<String, dynamic>? ?? data;
    return Business.fromJson(businessJson);
  }

  /// Superadmin: reinvia email di invito all'admin.
  Future<void> resendAdminInvite(int businessId) async {
    await _apiClient.resendAdminInvite(businessId);
  }

  /// Superadmin: sospende/riattiva un business.
  /// Se isSuspended = true, il business mostra un messaggio agli operatori e ai clienti.
  Future<Business> suspendBusiness({
    required int businessId,
    required bool isSuspended,
    String? suspensionMessage,
  }) async {
    final data = await _apiClient.suspendBusiness(
      businessId: businessId,
      isSuspended: isSuspended,
      suspensionMessage: suspensionMessage,
    );
    final businessJson = data['business'] as Map<String, dynamic>? ?? data;
    return Business.fromJson(businessJson);
  }

  /// Superadmin: elimina (soft delete) un business.
  Future<void> deleteBusiness(int businessId) async {
    await _apiClient.deleteAdminBusiness(businessId);
  }
}
--- FILE: lib/features/business/data/business_users_repository.dart ---
import '../../../core/models/business_invitation.dart';
import '../../../core/models/business_user.dart';
import '../../../core/network/api_client.dart';

/// Repository per gestire operatori e inviti di un business.
class BusinessUsersRepository {
  BusinessUsersRepository({required ApiClient apiClient})
    : _apiClient = apiClient;

  final ApiClient _apiClient;

  // ========== OPERATORI ==========

  /// Recupera tutti gli operatori di un business.
  Future<List<BusinessUser>> getUsers(int businessId) async {
    final data = await _apiClient.getBusinessUsers(businessId);
    return data.map((json) => BusinessUser.fromJson(json)).toList();
  }

  /// Aggiorna il ruolo e lo scope di un operatore.
  Future<BusinessUser> updateUser({
    required int businessId,
    required int userId,
    required String role,
    String? scopeType,
    List<int>? locationIds,
    int? staffId,
  }) async {
    final data = await _apiClient.updateBusinessUser(
      businessId: businessId,
      userId: userId,
      role: role,
      scopeType: scopeType,
      locationIds: locationIds,
      staffId: staffId,
    );
    return BusinessUser.fromJson(data);
  }

  /// Rimuove un operatore dal business.
  Future<void> removeUser({
    required int businessId,
    required int userId,
  }) async {
    await _apiClient.removeBusinessUser(businessId: businessId, userId: userId);
  }

  // ========== INVITI ==========

  /// Recupera gli inviti di un business.
  Future<List<BusinessInvitation>> getInvitations(
    int businessId, {
    String status = 'pending',
  }) async {
    final data = await _apiClient.getBusinessInvitations(
      businessId,
      status: status,
    );
    return data.map((json) => BusinessInvitation.fromJson(json)).toList();
  }

  /// Crea un nuovo invito.
  Future<BusinessInvitation> createInvitation({
    required int businessId,
    required String email,
    required String role,
    String scopeType = 'business',
    List<int>? locationIds,
    int? staffId,
  }) async {
    final data = await _apiClient.createBusinessInvitation(
      businessId: businessId,
      email: email,
      role: role,
      scopeType: scopeType,
      locationIds: locationIds,
      staffId: staffId,
    );
    return BusinessInvitation.fromJson(data);
  }

  /// Elimina un invito.
  Future<void> deleteInvitation({
    required int businessId,
    required int invitationId,
  }) async {
    await _apiClient.revokeBusinessInvitation(
      businessId: businessId,
      invitationId: invitationId,
    );
  }

  /// Recupera i dettagli di un invito tramite token.
  Future<Map<String, dynamic>> getInvitationByToken(String token) async {
    return _apiClient.getInvitationByToken(token);
  }

  /// Accetta un invito.
  Future<void> acceptInvitation(String token) async {
    await _apiClient.acceptInvitation(token);
  }

  /// Accetta invito senza login (utente gi√† registrato).
  Future<void> acceptInvitationPublic(String token) async {
    await _apiClient.acceptInvitationPublic(token);
  }

  /// Rifiuta un invito.
  Future<void> declineInvitation(String token) async {
    await _apiClient.declineInvitation(token);
  }

  /// Registra un nuovo account operatore da invito e accetta l'invito.
  Future<Map<String, dynamic>> registerInvitation({
    required String token,
    required String firstName,
    required String lastName,
    required String password,
  }) async {
    return _apiClient.registerInvitation(
      token: token,
      firstName: firstName,
      lastName: lastName,
      password: password,
    );
  }
}
--- FILE: lib/features/business/domain/public_holidays.dart ---
// Gestione delle festivit√† nazionali per paese.
//
// Supporta festivit√† fisse e mobili (come Pasqua e derivate).

/// Rappresenta una festivit√† nazionale.
class PublicHoliday {
  final DateTime date;
  final String name;
  final String nameEn;

  const PublicHoliday({
    required this.date,
    required this.name,
    required this.nameEn,
  });
}

/// Calcola le festivit√† per un determinato paese e anno.
abstract class PublicHolidaysProvider {
  /// Restituisce tutte le festivit√† per l'anno specificato.
  List<PublicHoliday> getHolidays(int year);

  /// Calcola la data di Pasqua per un anno (algoritmo di Gauss/Meeus).
  static DateTime calculateEaster(int year) {
    final a = year % 19;
    final b = year ~/ 100;
    final c = year % 100;
    final d = b ~/ 4;
    final e = b % 4;
    final f = (b + 8) ~/ 25;
    final g = (b - f + 1) ~/ 3;
    final h = (19 * a + b - d - g + 15) % 30;
    final i = c ~/ 4;
    final k = c % 4;
    final l = (32 + 2 * e + 2 * i - h - k) % 7;
    final m = (a + 11 * h + 22 * l) ~/ 451;
    final month = (h + l - 7 * m + 114) ~/ 31;
    final day = ((h + l - 7 * m + 114) % 31) + 1;
    return DateTime(year, month, day);
  }
}

/// Festivit√† italiane.
class ItalianHolidaysProvider extends PublicHolidaysProvider {
  @override
  List<PublicHoliday> getHolidays(int year) {
    final easter = PublicHolidaysProvider.calculateEaster(year);

    return [
      // Festivit√† fisse
      PublicHoliday(
        date: DateTime(year, 1, 1),
        name: 'Capodanno',
        nameEn: "New Year's Day",
      ),
      PublicHoliday(
        date: DateTime(year, 1, 6),
        name: 'Epifania',
        nameEn: 'Epiphany',
      ),
      PublicHoliday(
        date: DateTime(year, 4, 25),
        name: 'Festa della Liberazione',
        nameEn: 'Liberation Day',
      ),
      PublicHoliday(
        date: DateTime(year, 5, 1),
        name: 'Festa dei Lavoratori',
        nameEn: 'Labour Day',
      ),
      PublicHoliday(
        date: DateTime(year, 6, 2),
        name: 'Festa della Repubblica',
        nameEn: 'Republic Day',
      ),
      PublicHoliday(
        date: DateTime(year, 8, 15),
        name: 'Ferragosto',
        nameEn: 'Assumption of Mary',
      ),
      PublicHoliday(
        date: DateTime(year, 11, 1),
        name: 'Tutti i Santi',
        nameEn: "All Saints' Day",
      ),
      PublicHoliday(
        date: DateTime(year, 12, 8),
        name: 'Immacolata Concezione',
        nameEn: 'Immaculate Conception',
      ),
      PublicHoliday(
        date: DateTime(year, 12, 25),
        name: 'Natale',
        nameEn: 'Christmas Day',
      ),
      PublicHoliday(
        date: DateTime(year, 12, 26),
        name: 'Santo Stefano',
        nameEn: "St. Stephen's Day",
      ),
      // Festivit√† mobili (dipendono da Pasqua)
      PublicHoliday(date: easter, name: 'Pasqua', nameEn: 'Easter Sunday'),
      PublicHoliday(
        date: easter.add(const Duration(days: 1)),
        name: 'Luned√¨ dell\'Angelo',
        nameEn: 'Easter Monday',
      ),
    ]..sort((a, b) => a.date.compareTo(b.date));
  }
}

/// Factory per ottenere il provider di festivit√† per un paese.
class PublicHolidaysFactory {
  /// Mappa dei codici paese supportati.
  static const supportedCountries = {'IT': 'Italia', 'Italy': 'Italia'};

  /// Restituisce il provider di festivit√† per il paese specificato.
  /// Se il paese non √® supportato, restituisce null.
  static PublicHolidaysProvider? getProvider(String? countryCode) {
    if (countryCode == null) return null;

    final normalized = countryCode.toUpperCase().trim();

    if (normalized == 'IT' || normalized == 'ITALY' || normalized == 'ITALIA') {
      return ItalianHolidaysProvider();
    }

    // Aggiungi altri paesi qui in futuro
    // if (normalized == 'FR' || normalized == 'FRANCE') {
    //   return FrenchHolidaysProvider();
    // }

    return null;
  }

  /// Restituisce true se il paese √® supportato.
  static bool isSupported(String? countryCode) {
    return getProvider(countryCode) != null;
  }

  /// Restituisce il nome del paese dal codice.
  static String? getCountryName(String? countryCode) {
    if (countryCode == null) return null;

    final normalized = countryCode.toUpperCase().trim();

    if (normalized == 'IT' || normalized == 'ITALY' || normalized == 'ITALIA') {
      return 'Italia';
    }

    return null;
  }
}
--- FILE: lib/features/business/domain/business.dart ---
--- FILE: lib/features/business/presentation/operators_screen.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:intl/intl.dart';

import '../../../app/providers/form_factor_provider.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../../core/models/business_invitation.dart';
import '../../../core/models/business_user.dart';
import '../../../core/models/location.dart';
import '../../../core/utils/initials_utils.dart';
import '../../../core/widgets/app_bottom_sheet.dart';
import '../../../core/widgets/app_dialogs.dart';
import '../../../core/widgets/feedback_dialog.dart';
import '../../agenda/providers/business_providers.dart';
import '../../agenda/providers/location_providers.dart';
import '../providers/business_users_provider.dart';
import 'dialogs/role_selection_dialog.dart';

/// Schermata per la gestione degli operatori di un business.
class OperatorsScreen extends ConsumerWidget {
  const OperatorsScreen({super.key, this.businessId});

  /// Se null, usa currentBusinessIdProvider (navigazione shell, senza Scaffold)
  final int? businessId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final int effectiveBusinessId =
        businessId ?? ref.watch(currentBusinessIdProvider);

    // Se businessId √® passato esplicitamente ‚Üí navigazione push, serve Scaffold con back button
    if (businessId != null) {
      return Scaffold(
        appBar: AppBar(
          leading: IconButton(
            icon: const Icon(Icons.arrow_back),
            onPressed: () => context.pop(),
          ),
          title: Text(context.l10n.permissionsTitle),
        ),
        body: _OperatorsBody(businessId: effectiveBusinessId),
      );
    }

    // Navigazione shell ‚Üí niente Scaffold (la toolbar √® gestita da ScaffoldWithNavigation)
    return _OperatorsBody(businessId: effectiveBusinessId);
  }
}

class _OperatorsBody extends ConsumerStatefulWidget {
  const _OperatorsBody({required this.businessId});

  final int businessId;

  @override
  ConsumerState<_OperatorsBody> createState() => _OperatorsBodyState();
}

class _OperatorsBodyState extends ConsumerState<_OperatorsBody> {
  bool _showHistoricalInvitations = false;

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(businessUsersProvider(widget.businessId));
    final l10n = context.l10n;

    return _buildBody(context, ref, state, l10n);
  }

  Widget _buildBody(
    BuildContext context,
    WidgetRef ref,
    BusinessUsersState state,
    dynamic l10n,
  ) {
    final pendingInvitations = state.invitations.where((i) => i.isPending).toList();
    final historicalInvitations = state.invitations
        // Non mostrare inviti gi√† accettati: l'utente √® ormai un operatore attivo.
        .where((i) => !i.isPending && i.effectiveStatus != 'accepted')
        .toList();

    if (state.isLoading && state.users.isEmpty) {
      return const Center(child: CircularProgressIndicator());
    }

    if (state.error != null && state.users.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(state.error!),
            const SizedBox(height: 16),
            FilledButton(
              onPressed: () => ref
                  .read(businessUsersProvider(widget.businessId).notifier)
                  .refresh(),
              child: Text(l10n.actionConfirm),
            ),
          ],
        ),
      );
    }

    return RefreshIndicator(
      onRefresh: () =>
          ref.read(businessUsersProvider(widget.businessId).notifier).refresh(),
      child: CustomScrollView(
        slivers: [
          if (state.isLoading && state.users.isNotEmpty)
            const SliverToBoxAdapter(
              child: LinearProgressIndicator(minHeight: 2),
            ),
          // Header con sottotitolo
          SliverToBoxAdapter(
            child: Padding(
              padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
              child: Text(
                l10n.operatorsSubtitle,
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
              ),
            ),
          ),

          // Sezione inviti pendenti
          if (pendingInvitations.isNotEmpty) ...[
            SliverToBoxAdapter(
              child: Padding(
                padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                child: Row(
                  children: [
                    Icon(
                      Icons.mail_outline,
                      size: 18,
                      color: Theme.of(context).colorScheme.primary,
                    ),
                    const SizedBox(width: 8),
                    Text(
                      l10n.operatorsPendingInvitesCount(
                        pendingInvitations.length,
                      ),
                      style: Theme.of(context).textTheme.titleSmall?.copyWith(
                        color: Theme.of(context).colorScheme.primary,
                      ),
                    ),
                  ],
                ),
              ),
            ),
            SliverList(
              delegate: SliverChildBuilderDelegate(
                (context, index) => _InvitationTile(
                  invitation: pendingInvitations[index],
                  businessId: widget.businessId,
                  enableActions: !state.isLoading,
                ),
                childCount: pendingInvitations.length,
              ),
            ),
            const SliverToBoxAdapter(
              child: Divider(height: 32, indent: 16, endIndent: 16),
            ),
          ],

          if (historicalInvitations.isNotEmpty)
            SliverToBoxAdapter(
              child: Padding(
                padding: const EdgeInsets.fromLTRB(16, 0, 16, 8),
                child: Align(
                  alignment: Alignment.centerLeft,
                  child: FilterChip(
                    selected: _showHistoricalInvitations,
                    onSelected: (selected) {
                      setState(() => _showHistoricalInvitations = selected);
                    },
                    label: Text(
                      _historicalToggleLabel(
                        context,
                        historicalInvitations.length,
                        _showHistoricalInvitations,
                      ),
                    ),
                  ),
                ),
              ),
            ),

          if (historicalInvitations.isNotEmpty && _showHistoricalInvitations) ...[
            SliverToBoxAdapter(
              child: Padding(
                padding: const EdgeInsets.fromLTRB(16, 0, 16, 8),
                child: Text(
                  l10n.operatorsInvitesHistoryCount(
                    historicalInvitations.length,
                  ),
                  style: Theme.of(context).textTheme.titleSmall?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
              ),
            ),
            SliverList(
              delegate: SliverChildBuilderDelegate(
                (context, index) => _InvitationTile(
                  invitation: historicalInvitations[index],
                  businessId: widget.businessId,
                  enableActions: !state.isLoading,
                ),
                childCount: historicalInvitations.length,
              ),
            ),
            const SliverToBoxAdapter(
              child: Divider(height: 32, indent: 16, endIndent: 16),
            ),
          ],

          // Lista operatori attivi
          if (state.users.isEmpty)
            SliverFillRemaining(
              hasScrollBody: false,
              child: Center(
                child: Text(
                  l10n.operatorsEmpty,
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
              ),
            )
          else
            SliverList(
              delegate: SliverChildBuilderDelegate((context, index) {
                final user = state.users[index];
                // Key composita per forzare rebuild quando cambiano i dati
                return _UserTile(
                  key: ValueKey(
                    '${user.userId}_${user.role}_${user.scopeType}_${user.locationIds.join(',')}',
                  ),
                  user: user,
                  businessId: widget.businessId,
                  enableActions: !state.isLoading,
                );
              }, childCount: state.users.length),
            ),

          // Padding finale
          const SliverToBoxAdapter(child: SizedBox(height: 80)),
        ],
      ),
    );
  }

  String _historicalToggleLabel(
    BuildContext context,
    int count,
    bool selected,
  ) {
    final isEn = Localizations.localeOf(context).languageCode == 'en';
    if (selected) {
      return isEn ? 'Hide invite history' : 'Nascondi storico inviti';
    }
    return isEn ? 'Show invite history ($count)' : 'Mostra storico inviti ($count)';
  }
}

/// Tile per visualizzare un invito pendente.
class _InvitationTile extends ConsumerWidget {
  const _InvitationTile({
    required this.invitation,
    required this.businessId,
    this.enableActions = true,
  });

  final BusinessInvitation invitation;
  final int businessId;
  final bool enableActions;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;
    final dateFormat = DateFormat.yMd();
    final statusColor = _statusColor(colorScheme, invitation.effectiveStatus);
    final statusLabel = _statusLabel(l10n, invitation.effectiveStatus);
    final canResend = enableActions && invitation.isPending;
    final canRevoke = enableActions && invitation.isPending;
    final canDelete = enableActions && !invitation.isPending;
    final resendLabel = Localizations.localeOf(context).languageCode == 'en'
        ? 'Resend invite'
        : 'Reinvia invito';
    final trailing = enableActions
        ? PopupMenuButton<String>(
            onSelected: (value) {
              if (value == 'resend') {
                _resendInvitation(context, ref);
              } else if (value == 'revoke') {
                _confirmRevoke(context, ref);
              } else if (value == 'delete') {
                _confirmDelete(context, ref);
              }
            },
            itemBuilder: (context) {
              final entries = <PopupMenuEntry<String>>[];
              if (canResend) {
                entries.add(
                  PopupMenuItem(
                    value: 'resend',
                    child: Row(
                      children: [
                        const Icon(Icons.refresh, size: 20),
                        const SizedBox(width: 12),
                        Text(resendLabel),
                      ],
                    ),
                  ),
                );
              }
              if (canRevoke) {
                entries.add(
                  PopupMenuItem(
                    value: 'revoke',
                    child: Row(
                      children: [
                        Icon(
                          Icons.block_outlined,
                          size: 20,
                          color: colorScheme.error,
                        ),
                        const SizedBox(width: 12),
                        Text(
                          l10n.operatorsRevokeInvite,
                          style: TextStyle(color: colorScheme.error),
                        ),
                      ],
                    ),
                  ),
                );
              }
              if (canDelete) {
                entries.add(
                  PopupMenuItem(
                    value: 'delete',
                    child: Row(
                      children: [
                        Icon(
                          Icons.delete_outline,
                          size: 20,
                          color: colorScheme.error,
                        ),
                        const SizedBox(width: 12),
                        Text(
                          l10n.operatorsDeleteInvite,
                          style: TextStyle(color: colorScheme.error),
                        ),
                      ],
                    ),
                  ),
                );
              }
              return entries;
            },
          )
        : null;

    return Card(
      margin: const EdgeInsets.fromLTRB(16, 4, 16, 4),
      elevation: 1.5,
      child: ListTile(
        leading: CircleAvatar(
          backgroundColor: colorScheme.primaryContainer,
          child: Icon(Icons.mail_outline, color: colorScheme.onPrimaryContainer),
        ),
        title: Text(invitation.email),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              invitation.roleLabel,
              style: TextStyle(color: colorScheme.onSurfaceVariant),
            ),
            const SizedBox(height: 4),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
              decoration: BoxDecoration(
                color: statusColor.withValues(alpha: 0.14),
                borderRadius: BorderRadius.circular(999),
              ),
              child: Text(
                statusLabel,
                style: Theme.of(context).textTheme.labelSmall?.copyWith(
                  color: statusColor,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
            const SizedBox(height: 4),
            Text(
              invitation.effectiveStatus == 'accepted' &&
                      invitation.acceptedAt != null
                  ? l10n.operatorsAcceptedOn(
                      dateFormat.format(invitation.acceptedAt!),
                    )
                  : l10n.operatorsExpires(
                      dateFormat.format(invitation.expiresAt),
                    ),
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: invitation.effectiveStatus == 'expired'
                    ? colorScheme.error
                    : colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ),
        isThreeLine: true,
        trailing: trailing,
      ),
    );
  }

  Color _statusColor(ColorScheme scheme, String status) {
    return switch (status) {
      'pending' => scheme.primary,
      'accepted' => Colors.green.shade700,
      'declined' => Colors.orange.shade700,
      'revoked' => scheme.onSurfaceVariant,
      'expired' => scheme.error,
      _ => scheme.onSurfaceVariant,
    };
  }

  String _statusLabel(dynamic l10n, String status) {
    return switch (status) {
      'pending' => l10n.operatorsInviteStatusPending,
      'accepted' => l10n.operatorsInviteStatusAccepted,
      'declined' => l10n.operatorsInviteStatusDeclined,
      'revoked' => l10n.operatorsInviteStatusRevoked,
      'expired' => l10n.operatorsInviteStatusExpired,
      _ => status,
    };
  }

  void _confirmDelete(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    showAppConfirmDialog(
      context,
      title: Text(l10n.operatorsDeleteInvite),
      content: Text(l10n.operatorsDeleteInviteConfirm(invitation.email)),
      confirmLabel: l10n.actionDelete,
      danger: true,
      onConfirm: () {
        ref
            .read(businessUsersProvider(businessId).notifier)
            .deleteInvitation(invitation.id);
      },
    );
  }

  void _confirmRevoke(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    showAppConfirmDialog(
      context,
      title: Text(l10n.operatorsRevokeInvite),
      content: Text(l10n.operatorsRevokeInviteConfirm(invitation.email)),
      confirmLabel: l10n.operatorsRevokeInvite,
      danger: true,
      onConfirm: () {
        ref
            .read(businessUsersProvider(businessId).notifier)
            .deleteInvitation(invitation.id);
      },
    );
  }

  Future<void> _resendInvitation(BuildContext context, WidgetRef ref) async {
    final l10n = context.l10n;
    final ok = await ref
        .read(businessUsersProvider(businessId).notifier)
        .resendInvitation(invitation);
    if (!context.mounted) return;

    final message = ok
        ? l10n.operatorsInviteSuccess(invitation.email)
        : (ref.read(businessUsersProvider(businessId)).error ??
              l10n.operatorsInviteError);

    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(message)),
    );
  }
}

/// Tile per visualizzare un operatore attivo.
class _UserTile extends ConsumerWidget {
  const _UserTile({
    super.key,
    required this.user,
    required this.businessId,
    this.enableActions = true,
  });

  final BusinessUser user;
  final int businessId;
  final bool enableActions;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;
    final locations = ref.watch(locationsProvider);
    final canEditRole = enableActions && !user.isCurrentUser && user.role != 'owner';
    final showLocationsInfo = locations.length > 1;
    final enabledLocationsInfo = _buildEnabledLocationsInfo(l10n, locations);

    return Card(
      margin: const EdgeInsets.fromLTRB(16, 4, 16, 4),
      elevation: 1.5,
      child: ListTile(
        onTap: canEditRole
            ? () => _showEditRoleDialog(context, ref, locations)
            : null,
        leading: CircleAvatar(
          backgroundColor: colorScheme.secondaryContainer,
          child: Text(
            _getInitials(user),
            style: TextStyle(
              color: colorScheme.onSecondaryContainer,
              fontWeight: FontWeight.w600,
            ),
          ),
        ),
        title: Row(
          children: [
            Flexible(child: Text(user.fullName)),
            if (user.isCurrentUser) ...[
              const SizedBox(width: 8),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
                decoration: BoxDecoration(
                  color: colorScheme.primaryContainer,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  l10n.operatorsYou,
                  style: Theme.of(context).textTheme.labelSmall?.copyWith(
                    color: colorScheme.onPrimaryContainer,
                  ),
                ),
              ),
            ],
          ],
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              _getRoleLabel(user.role, l10n),
              style: TextStyle(color: colorScheme.onSurfaceVariant),
            ),
            if (showLocationsInfo) ...[
              const SizedBox(height: 4),
              Text(
                '${l10n.teamStaffLocationsLabel}: $enabledLocationsInfo',
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: colorScheme.onSurfaceVariant,
                ),
              ),
            ],
          ],
        ),
        trailing: !canEditRole
            ? null
            : PopupMenuButton<String>(
                onSelected: (value) {
                  if (value == 'edit') {
                    _showEditRoleDialog(context, ref, locations);
                  } else if (value == 'remove') {
                    _confirmRemove(context, ref);
                  }
                },
                itemBuilder: (context) => [
                  PopupMenuItem(
                    value: 'edit',
                    child: Row(
                      children: [
                        const Icon(Icons.edit_outlined, size: 20),
                        const SizedBox(width: 12),
                        Text(l10n.operatorsEditRole),
                      ],
                    ),
                  ),
                  PopupMenuItem(
                    value: 'remove',
                    child: Row(
                      children: [
                        Icon(
                          Icons.person_remove,
                          size: 20,
                          color: colorScheme.error,
                        ),
                        const SizedBox(width: 12),
                        Text(
                          l10n.operatorsRemove,
                          style: TextStyle(color: colorScheme.error),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
      ),
    );
  }

  String _getInitials(BusinessUser user) {
    final fullName = '${user.firstName} ${user.lastName}'.trim();
    final nameInitials = InitialsUtils.fromName(fullName, maxChars: 2);
    if (nameInitials.isEmpty) {
      final emailInitial = InitialsUtils.fromName(user.email, maxChars: 1);
      return emailInitial.isNotEmpty ? emailInitial : '?';
    }
    return nameInitials;
  }

  String _getRoleLabel(String role, dynamic l10n) {
    return switch (role) {
      'owner' => l10n.operatorsRoleOwner,
      'admin' => l10n.operatorsRoleAdmin,
      'manager' => l10n.operatorsRoleManager,
      'staff' => l10n.operatorsRoleStaff,
      'viewer' => 'Viewer',
      _ => role,
    };
  }

  String _buildEnabledLocationsInfo(dynamic l10n, List<Location> locations) {
    if (user.scopeType != 'locations' || user.locationIds.isEmpty) {
      return l10n.allLocations;
    }

    final selectedNames = locations
        .where((location) => user.locationIds.contains(location.id))
        .map((location) => location.name)
        .where((name) => name.trim().isNotEmpty)
        .toList();

    if (selectedNames.isEmpty) {
      return l10n.allLocations;
    }

    return selectedNames.join(', ');
  }

  void _showEditRoleDialog(
    BuildContext context,
    WidgetRef ref,
    List<Location> locations,
  ) {
    final formFactor = ref.read(formFactorProvider);
    final currentLocationIds = user.locationIds.toSet();

    if (formFactor == AppFormFactor.mobile ||
        formFactor == AppFormFactor.tablet) {
      AppBottomSheet.show(
        context: context,
        heightFactor: null,
        builder: (ctx) => RoleSelectionSheet(
          currentRole: user.role,
          currentScopeType: user.scopeType,
          currentLocationIds: user.locationIds,
          locations: locations,
          userName: user.fullName,
          userEmail: user.email,
          onSave:
              ({
                required String role,
                required String scopeType,
                required List<int> locationIds,
              }) async {
                Navigator.of(ctx).pop();
                final selectedLocationIds = scopeType == 'locations'
                    ? locationIds.toSet()
                    : <int>{};
                final hasChanges =
                    role != user.role ||
                    scopeType != user.scopeType ||
                    !setEquals(selectedLocationIds, currentLocationIds);
                if (hasChanges) {
                  final ok = await ref
                      .read(businessUsersProvider(businessId).notifier)
                      .updateUser(
                        userId: user.userId,
                        role: role,
                        scopeType: scopeType,
                        locationIds: scopeType == 'locations'
                            ? selectedLocationIds.toList()
                            : <int>[],
                      );
                  if (!context.mounted || ok) return;
                  final isIt =
                      Localizations.localeOf(context).languageCode == 'it';
                  final message =
                      ref.read(businessUsersProvider(businessId)).error ??
                      (isIt
                          ? 'Impossibile aggiornare i permessi dell\'operatore.'
                          : 'Unable to update operator permissions.');
                  FeedbackDialog.showError(
                    context,
                    title: context.l10n.errorTitle,
                    message: message,
                  );
                }
              },
        ),
      );
    } else {
      showDialog(
        context: context,
        builder: (ctx) => RoleSelectionDialog(
          currentRole: user.role,
          currentScopeType: user.scopeType,
          currentLocationIds: user.locationIds,
          locations: locations,
          userName: user.fullName,
          userEmail: user.email,
          onSave:
              ({
                required String role,
                required String scopeType,
                required List<int> locationIds,
              }) async {
                Navigator.of(ctx).pop();
                final selectedLocationIds = scopeType == 'locations'
                    ? locationIds.toSet()
                    : <int>{};
                final hasChanges =
                    role != user.role ||
                    scopeType != user.scopeType ||
                    !setEquals(selectedLocationIds, currentLocationIds);
                if (hasChanges) {
                  final ok = await ref
                      .read(businessUsersProvider(businessId).notifier)
                      .updateUser(
                        userId: user.userId,
                        role: role,
                        scopeType: scopeType,
                        locationIds: scopeType == 'locations'
                            ? selectedLocationIds.toList()
                            : <int>[],
                      );
                  if (!context.mounted || ok) return;
                  final isIt =
                      Localizations.localeOf(context).languageCode == 'it';
                  final message =
                      ref.read(businessUsersProvider(businessId)).error ??
                      (isIt
                          ? 'Impossibile aggiornare i permessi dell\'operatore.'
                          : 'Unable to update operator permissions.');
                  FeedbackDialog.showError(
                    context,
                    title: context.l10n.errorTitle,
                    message: message,
                  );
                }
              },
        ),
      );
    }
  }

  void _confirmRemove(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    showAppConfirmDialog(
      context,
      title: Text(l10n.operatorsRemove),
      content: Text(l10n.operatorsRemoveConfirm(user.fullName)),
      confirmLabel: l10n.actionConfirm,
      danger: true,
      onConfirm: () {
        ref
            .read(businessUsersProvider(businessId).notifier)
            .removeUser(user.userId);
      },
    );
  }
}
--- FILE: lib/features/business/presentation/invitation_accept_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:intl/intl.dart';

import '../../../core/l10n/l10_extension.dart';
import '../../../core/l10n/l10n.dart';
import '../../../core/models/user.dart';
import '../../../core/network/api_client.dart';
import '../../auth/providers/auth_provider.dart';
import '../providers/business_users_provider.dart';

class InvitationAcceptScreen extends ConsumerStatefulWidget {
  const InvitationAcceptScreen({super.key, required this.token});

  final String token;

  @override
  ConsumerState<InvitationAcceptScreen> createState() =>
      _InvitationAcceptScreenState();
}

class _InvitationAcceptScreenState
    extends ConsumerState<InvitationAcceptScreen> {
  ProviderSubscription? _authSub;
  bool _isLoading = true;
  bool _isAccepting = false;
  bool _isDeclining = false;
  bool _isRegistering = false;
  bool _isRegisterDialogOpen = false;
  bool _accepted = false;
  bool _declined = false;
  bool _isInvalidInvitation = false;
  String? _errorMessage;
  Map<String, dynamic>? _invitation;

  @override
  void initState() {
    super.initState();
    _authSub = ref.listenManual(authProvider, (previous, next) {
      _syncEmailMismatchMessage();
    });
    Future.microtask(_loadInvitation);
  }

  @override
  void dispose() {
    _authSub?.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final authState = ref.watch(authProvider);
    final isAuthenticated = authState.isAuthenticated;
    final isEmailMismatch = _isEmailMismatch(authState);
    final business = _invitation?['business'];
    final businessName = business is Map<String, dynamic>
        ? (business['name'] as String?)
        : null;
    final role = (_invitation?['role'] as String?) ?? '';
    final email = (_invitation?['email'] as String?) ?? '';
    final invitedUserExists = _invitation?['user_exists'] as bool?;
    final showLoginAction = invitedUserExists != false;
    final showRegisterAction = invitedUserExists != true;
    final isPhone = MediaQuery.sizeOf(context).width < 520;
    final expiresAtRaw = _invitation?['expires_at'] as String?;
    final roleLabel = _roleLabel(role, context);

    return Scaffold(
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 24),
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 560),
            child: Card(
              elevation: 0,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(12),
                side: BorderSide(
                  color: Theme.of(context).colorScheme.outlineVariant,
                ),
              ),
              child: Padding(
                padding: const EdgeInsets.all(24),
                child: AnimatedSwitcher(
                  duration: const Duration(milliseconds: 160),
                  child: _isLoading
                      ? _buildLoading(context)
                      : _isInvalidInvitation
                      ? _buildInvalid(context)
                      : isEmailMismatch
                      ? _buildMismatchOnly(context)
                      : (_accepted || _declined)
                      ? _buildSuccess(context)
                      : Column(
                          key: const ValueKey('invitation-content'),
                          crossAxisAlignment: CrossAxisAlignment.stretch,
                          children: [
                            Text(
                              l10n.invitationAcceptTitle,
                              style: Theme.of(context).textTheme.titleLarge
                                  ?.copyWith(fontWeight: FontWeight.w600),
                            ),
                            const SizedBox(height: 8),
                            Text(
                              l10n.invitationAcceptIntro(
                                businessName ?? '-',
                                roleLabel,
                              ),
                              style: Theme.of(context).textTheme.bodyMedium,
                            ),
                            const SizedBox(height: 16),
                            if (_errorMessage != null) ...[
                              _ErrorBanner(message: _errorMessage!),
                              const SizedBox(height: 16),
                            ],
                            _SectionBox(
                              children: [
                                _InfoRow(
                                  icon: Icons.badge_outlined,
                                  label: l10n.operatorsInviteRole,
                                  value: roleLabel,
                                ),
                                Divider(
                                  height: 20,
                                  thickness: 0.5,
                                  color: Theme.of(context)
                                      .colorScheme
                                      .outlineVariant
                                      .withValues(alpha: 0.45),
                                ),
                                _InfoRow(
                                  icon: Icons.alternate_email,
                                  label: l10n.operatorsInviteEmail,
                                  value: email,
                                ),
                                if (expiresAtRaw != null) ...[
                                  Divider(
                                    height: 20,
                                    thickness: 0.5,
                                    color: Theme.of(context)
                                        .colorScheme
                                        .outlineVariant
                                        .withValues(alpha: 0.45),
                                  ),
                                  _InfoRow(
                                    icon: Icons.event_outlined,
                                    label: _expiresLabel(context),
                                    value: l10n.operatorsExpires(
                                      _formatLocalizedDateTime(
                                        context,
                                        expiresAtRaw,
                                      ),
                                    ),
                                  ),
                                ],
                              ],
                            ),
                            if (!isAuthenticated) ...[
                              const SizedBox(height: 12),
                              if (showLoginAction)
                                Text(
                                  l10n.invitationAcceptHintExistingAccount,
                                  style: Theme.of(context).textTheme.bodySmall
                                      ?.copyWith(
                                        color: Theme.of(
                                          context,
                                        ).colorScheme.onSurfaceVariant,
                                      ),
                                ),
                              if (showLoginAction && showRegisterAction)
                                const SizedBox(height: 4),
                              if (showRegisterAction)
                                Text(
                                  l10n.invitationAcceptHintNoAccount,
                                  style: Theme.of(context).textTheme.bodySmall
                                      ?.copyWith(
                                        color: Theme.of(
                                          context,
                                        ).colorScheme.onSurfaceVariant,
                                      ),
                                ),
                            ],
                            const SizedBox(height: 20),
                            if (!isAuthenticated)
                              _buildUnauthenticatedActions(
                                context,
                                isPhone: isPhone,
                                showLoginAction: showLoginAction,
                                showRegisterAction: showRegisterAction,
                              )
                            else
                              _buildAuthenticatedActions(
                                context,
                                isPhone: isPhone,
                              ),
                          ],
                        ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildUnauthenticatedActions(
    BuildContext context, {
    required bool isPhone,
    required bool showLoginAction,
    required bool showRegisterAction,
  }) {
    final l10n = context.l10n;

    final loginButton = FilledButton.tonal(
      onPressed:
          _isDeclining ||
              _isRegistering ||
              _isRegisterDialogOpen ||
              _isAccepting
          ? null
          : () async {
              setState(() {
                _isAccepting = true;
                _errorMessage = null;
              });
              try {
                await ref
                    .read(businessUsersRepositoryProvider)
                    .acceptInvitationPublic(widget.token);
              } on ApiException catch (e) {
                if (!mounted) return;
                setState(() {
                  _errorMessage = _mapApiErrorToMessage(context, e);
                  _isAccepting = false;
                });
                return;
              } catch (_) {
                if (!mounted) return;
                setState(() {
                  _errorMessage = context.l10n.invitationAcceptErrorGeneric;
                  _isAccepting = false;
                });
                return;
              }
              if (!mounted) return;
              setState(() {
                _isAccepting = false;
                _accepted = true;
              });
              if (!context.mounted) return;
              final redirect = Uri.encodeComponent('/agenda');
              context.go('/login?leave_invitation=1&redirect=$redirect');
            },
      child: Text(
        _isAccepting
            ? l10n.invitationAcceptInProgress
            : l10n.invitationAcceptAndLoginAction,
        textAlign: TextAlign.center,
      ),
    );

    final registerButton = FilledButton.tonal(
      onPressed: _isDeclining || _isRegistering
          ? null
          : () {
              _showRegisterDialog();
            },
      child: Text(
        _isRegistering
            ? l10n.invitationRegisterInProgress
            : l10n.invitationRegisterAction,
        textAlign: TextAlign.center,
      ),
    );

    final declineButton = OutlinedButton(
      onPressed: _isDeclining
          ? null
          : () {
              _declineInvitation();
            },
      child: Text(
        _isDeclining
            ? l10n.invitationDeclineInProgress
            : l10n.invitationDeclineButton,
        textAlign: TextAlign.center,
      ),
    );

    final buttons = <Widget>[
      if (showLoginAction) loginButton,
      if (showRegisterAction) registerButton,
      declineButton,
    ];

    if (isPhone && buttons.length == 2) {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [buttons[0], const SizedBox(height: 8), buttons[1]],
      );
    }

    return Row(
      children: [
        if (showLoginAction) Expanded(child: loginButton),
        if (showLoginAction) const SizedBox(width: 8),
        if (showRegisterAction) Expanded(child: registerButton),
        if (showRegisterAction) const SizedBox(width: 8),
        Expanded(child: declineButton),
      ],
    );
  }

  Widget _buildAuthenticatedActions(
    BuildContext context, {
    required bool isPhone,
  }) {
    final l10n = context.l10n;

    final acceptButton = FilledButton(
      onPressed: (_isAccepting || _isDeclining)
          ? null
          : () {
              _acceptInvitation();
            },
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        mainAxisSize: MainAxisSize.min,
        children: [
          if (_isAccepting) ...[
            const SizedBox(
              width: 16,
              height: 16,
              child: CircularProgressIndicator(strokeWidth: 2),
            ),
            const SizedBox(width: 8),
          ],
          Flexible(
            child: Text(
              _isAccepting
                  ? l10n.invitationAcceptInProgress
                  : l10n.invitationAcceptButton,
              textAlign: TextAlign.center,
            ),
          ),
        ],
      ),
    );

    final declineButton = OutlinedButton(
      onPressed: (_isAccepting || _isDeclining)
          ? null
          : () {
              _declineInvitation();
            },
      child: Text(
        _isDeclining
            ? l10n.invitationDeclineInProgress
            : l10n.invitationDeclineButton,
        textAlign: TextAlign.center,
      ),
    );

    if (isPhone) {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [acceptButton, const SizedBox(height: 8), declineButton],
      );
    }

    return Row(
      children: [
        Expanded(child: acceptButton),
        const SizedBox(width: 10),
        Expanded(child: declineButton),
      ],
    );
  }

  Widget _buildLoading(BuildContext context) {
    return Column(
      key: const ValueKey('invitation-loading'),
      mainAxisSize: MainAxisSize.min,
      children: [
        const SizedBox(
          width: 28,
          height: 28,
          child: CircularProgressIndicator(strokeWidth: 2.5),
        ),
        const SizedBox(height: 16),
        Text(
          context.l10n.invitationAcceptLoading,
          style: Theme.of(context).textTheme.bodyMedium,
          textAlign: TextAlign.center,
        ),
      ],
    );
  }

  Widget _buildSuccess(BuildContext context) {
    final l10n = context.l10n;
    if (_declined) {
      return Column(
        key: const ValueKey('invitation-success-declined'),
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Text(
            l10n.invitationDeclineSuccessTitle,
            style: Theme.of(
              context,
            ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600),
          ),
          const SizedBox(height: 8),
          Text(l10n.invitationDeclineSuccessMessage),
        ],
      );
    }

    return Column(
      key: const ValueKey('invitation-success-accepted'),
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        Text(
          l10n.invitationAcceptSuccessTitle,
          style: Theme.of(
            context,
          ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600),
        ),
        const SizedBox(height: 8),
        Text(l10n.invitationAcceptSuccessMessage),
        const SizedBox(height: 16),
        FilledButton(
          onPressed: _goToApplication,
          child: Text(l10n.invitationGoToApplication),
        ),
      ],
    );
  }

  Future<void> _loadInvitation() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final data = await ref
          .read(businessUsersRepositoryProvider)
          .getInvitationByToken(widget.token);

      if (!mounted) return;
      setState(() {
        _invitation = data;
        _isLoading = false;
      });
      _syncEmailMismatchMessage();
    } on ApiException catch (e) {
      if (!mounted) return;
      final isInvalid = _isInvalidInvitationError(e);
      setState(() {
        _isInvalidInvitation = isInvalid;
        _errorMessage = isInvalid
            ? context.l10n.invitationAcceptErrorInvalid
            : _mapApiErrorToMessage(context, e);
        _isLoading = false;
      });
    } catch (_) {
      if (!mounted) return;
      setState(() {
        _errorMessage = context.l10n.invitationAcceptErrorGeneric;
        _isLoading = false;
      });
    }
  }

  void _syncEmailMismatchMessage() {
    if (!mounted || _invitation == null) {
      return;
    }

    final authState = ref.read(authProvider);
    if (!authState.isAuthenticated) {
      if (_errorMessage == context.l10n.invitationAcceptErrorEmailMismatch) {
        setState(() {
          _errorMessage = null;
        });
      }
      return;
    }

    final invitedEmail =
        (_invitation?['email'] as String?)?.trim().toLowerCase() ?? '';
    final currentUser = authState.user;
    final loggedEmail = currentUser is User
        ? currentUser.email.trim().toLowerCase()
        : '';

    if (invitedEmail.isEmpty ||
        loggedEmail.isEmpty ||
        loggedEmail == invitedEmail) {
      if (_errorMessage == context.l10n.invitationAcceptErrorEmailMismatch) {
        setState(() {
          _errorMessage = null;
        });
      }
      return;
    }

    if (_errorMessage != context.l10n.invitationAcceptErrorEmailMismatch) {
      setState(() {
        _errorMessage = context.l10n.invitationAcceptErrorEmailMismatch;
      });
    }
  }

  Future<void> _acceptInvitation() async {
    if (_isAccepting || _accepted) return;
    if (!ref.read(authProvider).isAuthenticated) {
      setState(() {
        _errorMessage = context.l10n.invitationAcceptLoginRequired;
      });
      return;
    }

    setState(() {
      _isAccepting = true;
      _errorMessage = null;
    });

    try {
      await ref
          .read(businessUsersRepositoryProvider)
          .acceptInvitation(widget.token);
      if (!mounted) return;
      setState(() {
        _accepted = true;
        _declined = false;
      });
    } on ApiException catch (e) {
      if (!mounted) return;
      if (_isInvalidInvitationError(e)) {
        setState(() {
          _isInvalidInvitation = true;
        });
        return;
      }
      setState(() {
        _errorMessage = _mapApiErrorToMessage(context, e);
      });
    } catch (_) {
      if (!mounted) return;
      setState(() {
        _errorMessage = context.l10n.invitationAcceptErrorGeneric;
      });
    } finally {
      if (mounted) {
        setState(() {
          _isAccepting = false;
        });
      }
    }
  }

  Future<void> _declineInvitation() async {
    if (_isDeclining || _accepted || _declined) return;

    setState(() {
      _isDeclining = true;
      _errorMessage = null;
    });

    try {
      await ref
          .read(businessUsersRepositoryProvider)
          .declineInvitation(widget.token);
      if (!mounted) return;
      setState(() {
        _declined = true;
        _accepted = false;
      });
    } on ApiException catch (e) {
      if (!mounted) return;
      if (_isInvalidInvitationError(e)) {
        setState(() {
          _isInvalidInvitation = true;
        });
        return;
      }
      setState(() {
        _errorMessage = _mapApiErrorToMessage(context, e);
      });
    } catch (_) {
      if (!mounted) return;
      setState(() {
        _errorMessage = context.l10n.invitationAcceptErrorGeneric;
      });
    } finally {
      if (mounted) {
        setState(() {
          _isDeclining = false;
        });
      }
    }
  }

  Future<void> _showRegisterDialog() async {
    final l10n = context.l10n;
    final firstNameController = TextEditingController();
    final lastNameController = TextEditingController();
    final passwordController = TextEditingController();
    final confirmPasswordController = TextEditingController();
    final formKey = GlobalKey<FormState>();
    String? localError;

    setState(() {
      _isRegisterDialogOpen = true;
    });

    await showDialog<void>(
      context: context,
      barrierDismissible: !_isRegistering,
      builder: (dialogContext) {
        return StatefulBuilder(
          builder: (dialogContext, setDialogState) {
            return AlertDialog(
              title: Text(l10n.invitationRegisterTitle),
              content: SizedBox(
                width: 420,
                child: Form(
                  key: formKey,
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      TextFormField(
                        controller: firstNameController,
                        decoration: InputDecoration(
                          labelText: l10n.formFirstName,
                          border: const OutlineInputBorder(),
                        ),
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return l10n.validationRequired;
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 12),
                      TextFormField(
                        controller: lastNameController,
                        decoration: InputDecoration(
                          labelText: l10n.formLastName,
                          border: const OutlineInputBorder(),
                        ),
                      ),
                      const SizedBox(height: 12),
                      TextFormField(
                        controller: passwordController,
                        obscureText: true,
                        decoration: InputDecoration(
                          labelText: l10n.authPassword,
                          border: const OutlineInputBorder(),
                        ),
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return l10n.validationRequired;
                          }
                          final policyError = _passwordPolicyError(value, l10n);
                          if (policyError != null) {
                            return policyError;
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 12),
                      TextFormField(
                        controller: confirmPasswordController,
                        obscureText: true,
                        decoration: InputDecoration(
                          labelText: l10n.invitationRegisterPasswordConfirm,
                          border: const OutlineInputBorder(),
                        ),
                        validator: (value) {
                          if (value == null || value.isEmpty) {
                            return l10n.validationRequired;
                          }
                          if (value != passwordController.text) {
                            return l10n.invitationRegisterPasswordMismatch;
                          }
                          return null;
                        },
                      ),
                      if (localError != null) ...[
                        const SizedBox(height: 12),
                        Text(
                          localError!,
                          style: TextStyle(
                            color: Theme.of(context).colorScheme.error,
                          ),
                        ),
                      ],
                    ],
                  ),
                ),
              ),
              actions: [
                TextButton(
                  onPressed: _isRegistering
                      ? null
                      : () => Navigator.of(dialogContext).pop(),
                  child: Text(l10n.actionCancel),
                ),
                FilledButton(
                  onPressed: _isRegistering
                      ? null
                      : () async {
                          if (!(formKey.currentState?.validate() ?? false)) {
                            return;
                          }
                          setDialogState(() {
                            localError = null;
                          });
                          final ok = await _registerInvitation(
                            firstName: firstNameController.text.trim(),
                            lastName: lastNameController.text.trim(),
                            password: passwordController.text,
                            confirmPassword: confirmPasswordController.text,
                          );
                          if (!mounted) return;
                          if (ok && dialogContext.mounted) {
                            Navigator.of(dialogContext).pop();
                          } else {
                            setDialogState(() {
                              localError = _errorMessage;
                            });
                          }
                        },
                  child: Text(l10n.invitationRegisterAction),
                ),
              ],
            );
          },
        );
      },
    );

    if (mounted) {
      setState(() {
        _isRegisterDialogOpen = false;
      });
    }
  }

  Future<bool> _registerInvitation({
    required String firstName,
    required String lastName,
    required String password,
    required String confirmPassword,
  }) async {
    if (_isRegistering) return false;
    final policyError = _passwordPolicyError(password, context.l10n);
    if (policyError != null) {
      setState(() {
        _errorMessage = policyError;
      });
      return false;
    }
    if (password != confirmPassword) {
      setState(() {
        _errorMessage = context.l10n.invitationRegisterPasswordMismatch;
      });
      return false;
    }
    setState(() {
      _isRegistering = true;
      _errorMessage = null;
    });
    try {
      await ref
          .read(businessUsersRepositoryProvider)
          .registerInvitation(
            token: widget.token,
            firstName: firstName,
            lastName: lastName,
            password: password,
          );
      if (!mounted) return false;
      setState(() {
        _accepted = true;
        _declined = false;
      });
      return true;
    } on ApiException catch (e) {
      if (!mounted) return false;
      setState(() {
        _errorMessage = _mapApiErrorToMessage(context, e);
      });
      return false;
    } catch (_) {
      if (!mounted) return false;
      setState(() {
        _errorMessage = context.l10n.invitationAcceptErrorGeneric;
      });
      return false;
    } finally {
      if (mounted) {
        setState(() {
          _isRegistering = false;
        });
      }
    }
  }

  String _mapApiErrorToMessage(BuildContext context, ApiException e) {
    final l10n = context.l10n;
    final msg = e.message.toLowerCase();
    if (e.code == 'invitation_email_already_registered') {
      return l10n.invitationRegisterExistingUser;
    }
    if (e.code == 'invitation_account_not_found') {
      return l10n.invitationAcceptRequiresRegistration;
    }

    if (msg.contains('invitation not found')) {
      return l10n.invitationAcceptErrorInvalid;
    }
    if (msg.contains('expired')) {
      return l10n.invitationAcceptErrorExpired;
    }
    if (msg.contains('no longer valid')) {
      return l10n.invitationAcceptErrorInvalid;
    }
    if (msg.contains('different email')) {
      return l10n.invitationAcceptErrorEmailMismatch;
    }

    return l10n.invitationAcceptErrorGeneric;
  }

  bool _isInvalidInvitationError(ApiException e) {
    final msg = e.message.toLowerCase();
    return msg.contains('invitation not found') ||
        msg.contains('expired') ||
        msg.contains('no longer valid');
  }

  String? _passwordPolicyError(String password, L10n l10n) {
    if (password.length < 8) {
      return l10n.invitationRegisterPasswordTooShort;
    }
    final hasUppercase = RegExp(r'[A-Z]').hasMatch(password);
    final hasLowercase = RegExp(r'[a-z]').hasMatch(password);
    final hasNumber = RegExp(r'[0-9]').hasMatch(password);
    if (!hasUppercase || !hasLowercase || !hasNumber) {
      return l10n.invitationRegisterPasswordWeak;
    }
    return null;
  }

  String _roleLabel(String role, BuildContext context) {
    final l10n = context.l10n;
    return switch (role) {
      'admin' => l10n.operatorsRoleAdmin,
      'manager' => l10n.operatorsRoleManager,
      'staff' => l10n.operatorsRoleStaff,
      'viewer' =>
        Localizations.localeOf(context).languageCode == 'it'
            ? 'Visualizzatore'
            : 'Viewer',
      _ => role,
    };
  }

  String _formatLocalizedDateTime(BuildContext context, String raw) {
    final locale = Localizations.localeOf(context).toLanguageTag();
    final parsed =
        DateTime.tryParse(raw) ?? DateTime.tryParse(raw.replaceFirst(' ', 'T'));
    if (parsed == null) return raw;
    return DateFormat.yMMMMd(locale).add_Hm().format(parsed);
  }

  String _expiresLabel(BuildContext context) {
    return Localizations.localeOf(context).languageCode == 'it'
        ? 'Scadenza'
        : 'Expiration';
  }

  Widget _buildInvalid(BuildContext context) {
    return Column(
      key: const ValueKey('invitation-invalid'),
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        Text(
          context.l10n.invitationAcceptErrorInvalid,
          textAlign: TextAlign.center,
          style: Theme.of(
            context,
          ).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.w600),
        ),
      ],
    );
  }

  Widget _buildMismatchOnly(BuildContext context) {
    return Column(
      key: const ValueKey('invitation-email-mismatch'),
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        _ErrorBanner(message: context.l10n.invitationAcceptErrorEmailMismatch),
        const SizedBox(height: 12),
        FilledButton(
          onPressed: _goToApplication,
          child: Text(context.l10n.invitationGoToApplication, textAlign: TextAlign.center),
        ),
      ],
    );
  }

  void _goToApplication() {
    final isAuthenticated = ref.read(authProvider).isAuthenticated;
    if (isAuthenticated) {
      context.go('/agenda?leave_invitation=1');
      return;
    }
    final redirect = Uri.encodeComponent('/agenda');
    context.go('/login?leave_invitation=1&redirect=$redirect');
  }

  bool _isEmailMismatch(authState) {
    if (_invitation == null || !authState.isAuthenticated) return false;
    final invitedEmail =
        (_invitation?['email'] as String?)?.trim().toLowerCase() ?? '';
    final currentUser = authState.user;
    final loggedEmail = currentUser is User
        ? currentUser.email.trim().toLowerCase()
        : '';
    return invitedEmail.isNotEmpty &&
        loggedEmail.isNotEmpty &&
        invitedEmail != loggedEmail;
  }
}

class _InfoRow extends StatelessWidget {
  const _InfoRow({
    required this.icon,
    required this.label,
    required this.value,
  });

  final IconData icon;
  final String label;
  final String value;

  @override
  Widget build(BuildContext context) {
    final scheme = Theme.of(context).colorScheme;
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Icon(icon, size: 18, color: scheme.onSurfaceVariant),
        const SizedBox(width: 10),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                label,
                style: Theme.of(context).textTheme.labelMedium?.copyWith(
                  color: scheme.onSurfaceVariant,
                ),
              ),
              const SizedBox(height: 2),
              Text(
                value,
                style: Theme.of(
                  context,
                ).textTheme.bodyMedium?.copyWith(fontWeight: FontWeight.w600),
              ),
            ],
          ),
        ),
      ],
    );
  }
}

class _SectionBox extends StatelessWidget {
  const _SectionBox({required this.children});

  final List<Widget> children;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(14),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainer,
        borderRadius: BorderRadius.circular(10),
      ),
      child: Column(children: children),
    );
  }
}

class _ErrorBanner extends StatelessWidget {
  const _ErrorBanner({required this.message});

  final String message;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: colorScheme.errorContainer,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Text(
        message,
        style: TextStyle(color: colorScheme.onErrorContainer),
      ),
    );
  }
}
--- FILE: lib/features/business/presentation/user_business_switch_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../app/widgets/user_menu_button.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../../core/models/business.dart';
import '../../../core/models/location.dart';
import '../../../core/utils/initials_utils.dart';
import '../../agenda/providers/business_providers.dart';
import '../../agenda/providers/location_providers.dart';
import '../../auth/providers/current_business_user_provider.dart';
import '../providers/superadmin_selected_business_provider.dart';

/// Schermata selezione business per utenti non superadmin.
/// Mostra solo la lista dei business accessibili, senza azioni CRUD.
class UserBusinessSwitchScreen extends ConsumerWidget {
  const UserBusinessSwitchScreen({super.key});

  Future<void> _selectBusinessAndEnter(
    BuildContext context,
    WidgetRef ref,
    int businessId,
  ) async {
    // 1) Set business scelto
    ref.read(currentBusinessIdProvider.notifier).selectByUser(businessId);

    // 2) Invalida stato business-scoped e contesto permessi
    invalidateBusinessScopedProviders(ref);
    ref.invalidate(currentBusinessUserContextProvider);

    // 3) Attendi locations filtrate per il nuovo business/scope
    List<Location> locations = const [];
    try {
      locations = await ref.read(locationsAsyncProvider.future);
    } catch (_) {
      locations = const [];
    }

    // 4) Seleziona una location valida per evitare fetch con location stale
    if (locations.isNotEmpty) {
      final currentLocationId = ref.read(currentLocationIdProvider);
      final hasCurrent = locations.any((l) => l.id == currentLocationId);
      if (!hasCurrent) {
        ref.read(currentLocationIdProvider.notifier).set(locations.first.id);
      }
    }

    if (context.mounted) {
      context.go('/agenda');
    }
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final businessesAsync = ref.watch(businessesProvider);
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Seleziona Business'),
        centerTitle: true,
        actions: const [UserMenuButton(), SizedBox(width: 8)],
      ),
      body: businessesAsync.when(
        data: (businesses) {
          if (businesses.isEmpty) {
            return Center(
              child: Text(
                'Nessun business disponibile',
                style: theme.textTheme.titleMedium,
              ),
            );
          }

          if (businesses.length == 1) {
            final onlyBusiness = businesses.first;
            WidgetsBinding.instance.addPostFrameCallback((_) {
              _selectBusinessAndEnter(context, ref, onlyBusiness.id);
            });
            return const Center(child: CircularProgressIndicator());
          }

          return _UserBusinessList(
            businesses: businesses,
            onSelect: (business) =>
                _selectBusinessAndEnter(context, ref, business.id),
          );
        },
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, _) => Center(
          child: Text(
            'Errore nel caricamento: $error',
            style: TextStyle(color: colorScheme.error),
            textAlign: TextAlign.center,
          ),
        ),
      ),
    );
  }
}

class _UserBusinessList extends StatelessWidget {
  const _UserBusinessList({required this.businesses, required this.onSelect});

  final List<Business> businesses;
  final void Function(Business business) onSelect;

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final crossAxisCount = constraints.maxWidth > 900
            ? 3
            : constraints.maxWidth > 600
            ? 2
            : 1;

        return GridView.builder(
          padding: const EdgeInsets.all(24),
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: crossAxisCount,
            childAspectRatio: 2.5,
            crossAxisSpacing: 16,
            mainAxisSpacing: 16,
          ),
          itemCount: businesses.length,
          itemBuilder: (context, index) {
            final business = businesses[index];
            final businessInitial = InitialsUtils.fromName(
              business.name,
              maxChars: 1,
            );
            return Card(
              clipBehavior: Clip.antiAlias,
              child: InkWell(
                onTap: () => onSelect(business),
                child: Padding(
                  padding: const EdgeInsets.all(16),
                  child: Row(
                    children: [
                      CircleAvatar(
                        radius: 24,
                        child: Text(businessInitial.isNotEmpty ? businessInitial : '?'),
                      ),
                      const SizedBox(width: 14),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          mainAxisAlignment: MainAxisAlignment.center,
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Text(
                              business.name,
                              style: Theme.of(context).textTheme.titleMedium,
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                            if (business.userRole != null) ...[
                              const SizedBox(height: 2),
                              Text(
                                _roleLabel(context, business.userRole!),
                                style: Theme.of(context).textTheme.bodySmall
                                    ?.copyWith(
                                      color: Theme.of(
                                        context,
                                      ).colorScheme.onSurfaceVariant,
                                    ),
                                maxLines: 1,
                                overflow: TextOverflow.ellipsis,
                              ),
                            ],
                          ],
                        ),
                      ),
                      const SizedBox(width: 4),
                      Icon(
                        Icons.arrow_forward_ios,
                        size: 16,
                        color: Theme.of(context).colorScheme.onSurfaceVariant,
                      ),
                    ],
                  ),
                ),
              ),
            );
          },
        );
      },
    );
  }

  String _roleLabel(BuildContext context, String role) {
    final l10n = context.l10n;
    return switch (role) {
      'admin' => l10n.operatorsRoleAdmin,
      'manager' => l10n.operatorsRoleManager,
      'staff' => l10n.operatorsRoleStaff,
      'viewer' =>
        Localizations.localeOf(context).languageCode == 'it'
            ? 'Visualizzatore'
            : 'Viewer',
      _ => role,
    };
  }
}
--- FILE: lib/features/business/presentation/business_list_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../app/widgets/user_menu_button.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../../core/models/business.dart';
import '../../../core/network/api_client.dart';
import '../../../core/utils/initials_utils.dart';
import '../../../core/widgets/feedback_dialog.dart';
import '../../agenda/providers/business_providers.dart';
import '../providers/business_providers.dart';
import '../providers/superadmin_selected_business_provider.dart';
import 'dialogs/create_business_dialog.dart';
import 'dialogs/edit_business_dialog.dart';

/// Schermata lista business per superadmin.
/// Mostra tutti i business con possibilit√† di selezionarne uno o crearne uno nuovo.
class BusinessListScreen extends ConsumerWidget {
  const BusinessListScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final businessesAsync = ref.watch(businessesProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Seleziona Business'),
        centerTitle: true,
        actions: [
          // Menu utente (profilo, cambia password, logout)
          const UserMenuButton(),
          const SizedBox(width: 8),
        ],
      ),
      body: businessesAsync.when(
        data: (businesses) => _BusinessList(
          businesses: businesses,
          onSelect: (business) => _selectBusiness(context, ref, business),
          onEdit: (business) => _showEditBusinessDialog(context, ref, business),
          onResendInvite: (business) =>
              _showResendInviteDialog(context, ref, business),
          onSuspend: (business) => _showSuspendDialog(context, ref, business),
          onDelete: (business) => _showDeleteDialog(context, ref, business),
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, _) => Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.error_outline, size: 48, color: colorScheme.error),
              const SizedBox(height: 16),
              Text(
                'Errore nel caricamento',
                style: theme.textTheme.titleMedium,
              ),
              const SizedBox(height: 8),
              Text(
                error.toString(),
                style: theme.textTheme.bodySmall?.copyWith(
                  color: colorScheme.onSurfaceVariant,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              FilledButton.tonal(
                onPressed: () => ref.invalidate(businessesProvider),
                child: const Text('Riprova'),
              ),
            ],
          ),
        ),
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _showCreateBusinessDialog(context, ref),
        icon: const Icon(Icons.add),
        label: const Text('Aggiungi'),
      ),
    );
  }

  void _selectBusiness(BuildContext context, WidgetRef ref, Business business) {
    // Imposta il business corrente
    ref.read(currentBusinessIdProvider.notifier).selectByUser(business.id);
    // Segna che il superadmin ha selezionato un business
    ref.read(superadminSelectedBusinessProvider.notifier).select(business.id);
    // Naviga all'agenda
    context.go('/agenda');
  }

  Future<void> _showCreateBusinessDialog(
    BuildContext context,
    WidgetRef ref,
  ) async {
    final created = await showCreateBusinessDialog(context);
    if (created == true) {
      // Forza il refresh della lista
      ref.read(businessesRefreshProvider.notifier).refresh();
    }
  }

  Future<void> _showEditBusinessDialog(
    BuildContext context,
    WidgetRef ref,
    Business business,
  ) async {
    final updated = await showEditBusinessDialog(context, business);
    if (updated == true) {
      // Forza il refresh della lista
      ref.read(businessesRefreshProvider.notifier).refresh();
    }
  }

  Future<void> _showResendInviteDialog(
    BuildContext context,
    WidgetRef ref,
    Business business,
  ) async {
    final l10n = context.l10n;
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Reinvia invito'),
        content: Text(
          business.adminEmail != null
              ? 'Vuoi reinviare l\'email di invito a ${business.adminEmail}?'
              : 'Questo business non ha un admin email configurato.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: Text(l10n.actionCancel),
          ),
          if (business.adminEmail != null)
            FilledButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: const Text('Invia'),
            ),
        ],
      ),
    );

    if (confirmed == true && context.mounted) {
      try {
        final repository = ref.read(businessRepositoryProvider);
        await repository.resendAdminInvite(business.id);

        if (context.mounted) {
          await FeedbackDialog.showSuccess(
            context,
            title: 'Invito inviato',
            message: 'Invito inviato a ${business.adminEmail}',
          );
        }
      } on ApiException catch (e) {
        if (context.mounted) {
          await FeedbackDialog.showError(
            context,
            title: context.l10n.errorTitle,
            message: e.message,
          );
        }
      } catch (e) {
        if (context.mounted) {
          await FeedbackDialog.showError(
            context,
            title: context.l10n.errorTitle,
            message: e.toString(),
          );
        }
      }
    }
  }

  /// Mostra dialog per sospendere/riattivare un business
  Future<void> _showSuspendDialog(
    BuildContext context,
    WidgetRef ref,
    Business business,
  ) async {
    final l10n = context.l10n;
    final isSuspended = business.isSuspended;

    // Se √® gi√† sospeso, mostra dialog per riattivare
    if (isSuspended) {
      final confirmed = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Riattiva Business'),
          content: Text(
            'Vuoi riattivare "${business.name}"?\n\n'
            'Gli operatori e i clienti potranno accedere normalmente.',
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: Text(l10n.actionCancel),
            ),
            FilledButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: const Text('Riattiva'),
            ),
          ],
        ),
      );

      if (confirmed == true && context.mounted) {
        await _executeSuspend(context, ref, business, false, null);
      }
      return;
    }

    // Dialog per sospendere con messaggio
    final messageController = TextEditingController();
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Sospendi Business'),
        content: SizedBox(
          width: 400,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Sospendendo "${business.name}" gli operatori vedranno un avviso '
                'e i clienti non potranno effettuare prenotazioni online.',
              ),
              const SizedBox(height: 16),
              TextField(
                controller: messageController,
                decoration: const InputDecoration(
                  labelText: 'Messaggio di sospensione (opzionale)',
                  hintText: 'Es: Chiuso per ferie fino al 15 gennaio',
                  border: OutlineInputBorder(),
                ),
                maxLines: 2,
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: Text(l10n.actionCancel),
          ),
          FilledButton(
            style: FilledButton.styleFrom(backgroundColor: Colors.orange),
            onPressed: () => Navigator.of(context).pop(true),
            child: const Text('Sospendi'),
          ),
        ],
      ),
    );

    if (confirmed == true && context.mounted) {
      final message = messageController.text.trim().isEmpty
          ? null
          : messageController.text.trim();
      await _executeSuspend(context, ref, business, true, message);
    }
  }

  Future<void> _executeSuspend(
    BuildContext context,
    WidgetRef ref,
    Business business,
    bool isSuspended,
    String? message,
  ) async {
    try {
      final repository = ref.read(businessRepositoryProvider);
      await repository.suspendBusiness(
        businessId: business.id,
        isSuspended: isSuspended,
        suspensionMessage: message,
      );

      if (context.mounted) {
        final snackMessage = isSuspended
            ? '${business.name} sospeso'
            : '${business.name} riattivato';
        await FeedbackDialog.showSuccess(
          context,
          title: 'Operazione completata',
          message: snackMessage,
        );
        // Refresh lista
        ref.read(businessesRefreshProvider.notifier).refresh();
      }
    } on ApiException catch (e) {
      if (context.mounted) {
        await FeedbackDialog.showError(
          context,
          title: context.l10n.errorTitle,
          message: e.message,
        );
      }
    } catch (e) {
      if (context.mounted) {
        await FeedbackDialog.showError(
          context,
          title: context.l10n.errorTitle,
          message: e.toString(),
        );
      }
    }
  }

  /// Mostra dialog per eliminare un business
  Future<void> _showDeleteDialog(
    BuildContext context,
    WidgetRef ref,
    Business business,
  ) async {
    final l10n = context.l10n;

    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Elimina Business'),
        content: Text(
          'Sei sicuro di voler eliminare "${business.name}"?\n\n'
          '‚ö†Ô∏è Questa azione nasconder√† il business dalla lista. '
          'I dati non verranno cancellati definitivamente.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: Text(l10n.actionCancel),
          ),
          FilledButton(
            style: FilledButton.styleFrom(
              backgroundColor: Theme.of(context).colorScheme.error,
            ),
            onPressed: () => Navigator.of(context).pop(true),
            child: Text(l10n.actionDelete),
          ),
        ],
      ),
    );

    if (confirmed == true && context.mounted) {
      try {
        final repository = ref.read(businessRepositoryProvider);
        await repository.deleteBusiness(business.id);

        if (context.mounted) {
          final selectedBusinessId = ref.read(
            superadminSelectedBusinessProvider,
          );
          if (selectedBusinessId == business.id) {
            ref
                .read(superadminSelectedBusinessProvider.notifier)
                .clearCompletely();
          }
          await FeedbackDialog.showSuccess(
            context,
            title: 'Operazione completata',
            message: '${business.name} eliminato',
          );
          // Refresh lista
          ref.read(businessesRefreshProvider.notifier).refresh();
        }
      } on ApiException catch (e) {
        if (context.mounted) {
          await FeedbackDialog.showError(
            context,
            title: context.l10n.errorTitle,
            message: e.message,
          );
        }
      } catch (e) {
        if (context.mounted) {
          await FeedbackDialog.showError(
            context,
            title: context.l10n.errorTitle,
            message: e.toString(),
          );
        }
      }
    }
  }
}

class _BusinessList extends StatelessWidget {
  const _BusinessList({
    required this.businesses,
    required this.onSelect,
    required this.onEdit,
    required this.onResendInvite,
    required this.onSuspend,
    required this.onDelete,
  });

  final List<Business> businesses;
  final void Function(Business) onSelect;
  final void Function(Business) onEdit;
  final void Function(Business) onResendInvite;
  final void Function(Business) onSuspend;
  final void Function(Business) onDelete;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    if (businesses.isEmpty) {
      return Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.business_outlined,
              size: 64,
              color: colorScheme.onSurfaceVariant.withValues(alpha: 0.5),
            ),
            const SizedBox(height: 16),
            Text(
              'Nessun business',
              style: theme.textTheme.titleLarge?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Crea il tuo primo business per iniziare',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ),
      );
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        // Responsive grid
        final crossAxisCount = constraints.maxWidth > 900
            ? 3
            : constraints.maxWidth > 600
            ? 2
            : 1;

        return GridView.builder(
          padding: const EdgeInsets.all(24),
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: crossAxisCount,
            childAspectRatio: 2.5,
            crossAxisSpacing: 16,
            mainAxisSpacing: 16,
          ),
          itemCount: businesses.length,
          itemBuilder: (context, index) {
            final business = businesses[index];
            return _BusinessCard(
              business: business,
              onTap: () => onSelect(business),
              onEdit: () => onEdit(business),
              onResendInvite: () => onResendInvite(business),
              onSuspend: () => onSuspend(business),
              onDelete: () => onDelete(business),
            );
          },
        );
      },
    );
  }
}

class _BusinessCard extends StatelessWidget {
  const _BusinessCard({
    required this.business,
    required this.onTap,
    required this.onEdit,
    required this.onResendInvite,
    required this.onSuspend,
    required this.onDelete,
  });

  final Business business;
  final VoidCallback onTap;
  final VoidCallback onEdit;
  final VoidCallback onResendInvite;
  final VoidCallback onSuspend;
  final VoidCallback onDelete;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final screenWidth = MediaQuery.sizeOf(context).width;
    final isCompact = screenWidth < 400;
    final businessInitial = InitialsUtils.fromName(business.name, maxChars: 1);

    return Card(
      clipBehavior: Clip.antiAlias,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: EdgeInsets.all(isCompact ? 10 : 16),
          child: Row(
            children: [
              // Avatar con iniziale
              CircleAvatar(
                radius: isCompact ? 18 : 24,
                backgroundColor: colorScheme.primaryContainer,
                child: Text(
                  businessInitial.isNotEmpty ? businessInitial : '?',
                  style: TextStyle(
                    fontSize: isCompact ? 14 : 20,
                    fontWeight: FontWeight.bold,
                    color: colorScheme.onPrimaryContainer,
                  ),
                ),
              ),
              SizedBox(width: isCompact ? 10 : 14),
              // Info business
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisAlignment: MainAxisAlignment.center,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            business.name,
                            style:
                                (isCompact
                                        ? theme.textTheme.bodyMedium
                                        : theme.textTheme.titleMedium)
                                    ?.copyWith(fontWeight: FontWeight.w600),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        const SizedBox(width: 6),
                        // Badge sospeso
                        if (business.isSuspended) ...[
                          Container(
                            padding: EdgeInsets.symmetric(
                              horizontal: isCompact ? 4 : 6,
                              vertical: 1,
                            ),
                            decoration: BoxDecoration(
                              color: Colors.orange.withValues(alpha: 0.2),
                              borderRadius: BorderRadius.circular(4),
                            ),
                            child: Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Icon(
                                  Icons.pause_circle,
                                  size: isCompact ? 10 : 12,
                                  color: Colors.orange.shade700,
                                ),
                                SizedBox(width: isCompact ? 2 : 4),
                                Text(
                                  'Sospeso',
                                  style: theme.textTheme.labelSmall?.copyWith(
                                    color: Colors.orange.shade700,
                                    fontWeight: FontWeight.w600,
                                    fontSize: isCompact ? 9 : 11,
                                  ),
                                ),
                              ],
                            ),
                          ),
                          const SizedBox(width: 6),
                        ],
                        // Badge ID
                        Container(
                          padding: EdgeInsets.symmetric(
                            horizontal: isCompact ? 4 : 6,
                            vertical: 1,
                          ),
                          decoration: BoxDecoration(
                            color: colorScheme.surfaceContainerHighest,
                            borderRadius: BorderRadius.circular(4),
                          ),
                          child: Text(
                            'ID: ${business.id}',
                            style: theme.textTheme.labelSmall?.copyWith(
                              color: colorScheme.onSurfaceVariant,
                              fontFamily: 'monospace',
                              fontSize: isCompact ? 9 : 11,
                            ),
                          ),
                        ),
                      ],
                    ),
                    // Slug (sempre) e admin email (solo desktop)
                    if (business.slug != null ||
                        (!isCompact && business.adminEmail != null))
                      SizedBox(height: isCompact ? 2 : 4),
                    if (business.slug != null ||
                        (!isCompact && business.adminEmail != null))
                      Text(
                        [
                          if (business.slug != null) business.slug!,
                          if (!isCompact && business.adminEmail != null)
                            business.adminEmail!,
                        ].join(' ‚Ä¢ '),
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: colorScheme.onSurfaceVariant,
                          fontSize: isCompact ? 11 : null,
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                  ],
                ),
              ),
              // Menu azioni
              PopupMenuButton<String>(
                onSelected: (value) {
                  switch (value) {
                    case 'edit':
                      onEdit();
                    case 'resend':
                      onResendInvite();
                    case 'suspend':
                      onSuspend();
                    case 'delete':
                      onDelete();
                  }
                },
                itemBuilder: (context) => [
                  const PopupMenuItem(
                    value: 'edit',
                    child: ListTile(
                      leading: Icon(Icons.edit_outlined),
                      title: Text('Modifica'),
                      contentPadding: EdgeInsets.zero,
                      dense: true,
                    ),
                  ),
                  const PopupMenuItem(
                    value: 'resend',
                    child: ListTile(
                      leading: Icon(Icons.email_outlined),
                      title: Text('Reinvia invito'),
                      contentPadding: EdgeInsets.zero,
                      dense: true,
                    ),
                  ),
                  PopupMenuItem(
                    value: 'suspend',
                    child: ListTile(
                      leading: Icon(
                        business.isSuspended
                            ? Icons.play_circle_outline
                            : Icons.pause_circle_outline,
                        color: business.isSuspended
                            ? Colors.green
                            : Colors.orange,
                      ),
                      title: Text(
                        business.isSuspended ? 'Riattiva' : 'Sospendi',
                      ),
                      contentPadding: EdgeInsets.zero,
                      dense: true,
                    ),
                  ),
                  const PopupMenuDivider(),
                  PopupMenuItem(
                    value: 'delete',
                    child: ListTile(
                      leading: Icon(
                        Icons.delete_outline,
                        color: Theme.of(context).colorScheme.error,
                      ),
                      title: Text(
                        'Elimina',
                        style: TextStyle(
                          color: Theme.of(context).colorScheme.error,
                        ),
                      ),
                      contentPadding: EdgeInsets.zero,
                      dense: true,
                    ),
                  ),
                ],
                icon: const Icon(Icons.more_vert),
              ),
              // Freccia per entrare (solo su schermi non compatti)
              if (!isCompact) ...[
                const SizedBox(width: 4),
                Icon(
                  Icons.arrow_forward_ios,
                  size: 16,
                  color: colorScheme.onSurfaceVariant,
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/business/presentation/business_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/l10_extension.dart';
import '../../agenda/providers/business_providers.dart';

/// Schermata impostazioni business.
///
/// Permette di accedere alle impostazioni del business corrente:
/// - Gestione operatori
/// - Altre impostazioni future...
class BusinessScreen extends ConsumerWidget {
  const BusinessScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final business = ref.watch(currentBusinessProvider);
    final l10n = context.l10n;

    return Scaffold(
      appBar: AppBar(title: Text(business.name)),
      body: ListView(
        children: [
          // Gestione Operatori
          ListTile(
            leading: const Icon(Icons.supervisor_account_outlined),
            title: Text(l10n.operatorsTitle),
            subtitle: Text(l10n.operatorsSubtitle),
            trailing: const Icon(Icons.chevron_right),
            onTap: () => context.push('/operatori/${business.id}'),
          ),
          const Divider(),
          // Placeholder per future impostazioni
          // ListTile(
          //   leading: const Icon(Icons.settings_outlined),
          //   title: Text('Impostazioni'),
          //   trailing: const Icon(Icons.chevron_right),
          //   onTap: () {},
          // ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/business/presentation/dialogs/import_holidays_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '/core/l10n/l10_extension.dart';
import '/core/models/location.dart';
import '/core/models/location_closure.dart';
import '/core/widgets/app_buttons.dart';
import '/features/business/domain/public_holidays.dart';
import '/features/business/providers/location_closures_provider.dart';

/// Dialog per inserire automaticamente le festivit√† nazionali.
class ImportHolidaysDialog extends ConsumerStatefulWidget {
  const ImportHolidaysDialog({
    super.key,
    required this.locations,
    required this.existingClosures,
  });

  final List<Location> locations;
  final List<LocationClosure> existingClosures;

  static Future<int?> show(
    BuildContext context, {
    required List<Location> locations,
    required List<LocationClosure> existingClosures,
  }) {
    return showDialog<int>(
      context: context,
      builder: (context) => ImportHolidaysDialog(
        locations: locations,
        existingClosures: existingClosures,
      ),
    );
  }

  @override
  ConsumerState<ImportHolidaysDialog> createState() =>
      _ImportHolidaysDialogState();
}

class _ImportHolidaysDialogState extends ConsumerState<ImportHolidaysDialog> {
  late int _selectedYear;
  final Set<int> _selectedLocationIds = {};
  final Set<int> _selectedHolidayIndices = {};
  bool _isSaving = false;

  late List<PublicHoliday> _holidays;
  late PublicHolidaysProvider? _holidaysProvider;

  @override
  void initState() {
    super.initState();
    _selectedYear = DateTime.now().year;

    // Seleziona tutte le location di default
    _selectedLocationIds.addAll(widget.locations.map((l) => l.id));

    // Determina il provider di festivit√† dal paese della prima location
    final country = widget.locations.firstOrNull?.country;
    _holidaysProvider = PublicHolidaysFactory.getProvider(country);

    _loadHolidays();
  }

  void _loadHolidays() {
    if (_holidaysProvider == null) {
      _holidays = [];
      return;
    }

    _holidays = _holidaysProvider!.getHolidays(_selectedYear);

    // Seleziona tutte le festivit√† non ancora presenti
    _selectedHolidayIndices.clear();
    for (var i = 0; i < _holidays.length; i++) {
      if (!_isHolidayAlreadyAdded(_holidays[i])) {
        _selectedHolidayIndices.add(i);
      }
    }
  }

  bool _isHolidayAlreadyAdded(PublicHoliday holiday) {
    // Una festivit√† √® gi√† presente se esiste una chiusura con:
    // - stessa data di inizio
    // - stessa data di fine
    // - che copre tutte le location selezionate
    for (final closure in widget.existingClosures) {
      if (closure.startDate.year == holiday.date.year &&
          closure.startDate.month == holiday.date.month &&
          closure.startDate.day == holiday.date.day &&
          closure.endDate.year == holiday.date.year &&
          closure.endDate.month == holiday.date.month &&
          closure.endDate.day == holiday.date.day) {
        // Verifica che copra almeno una delle location selezionate
        final hasMatchingLocation = _selectedLocationIds.any(
          (id) => closure.locationIds.contains(id),
        );
        if (hasMatchingLocation) {
          return true;
        }
      }
    }
    return false;
  }

  Future<void> _onSave() async {
    if (_selectedHolidayIndices.isEmpty || _selectedLocationIds.isEmpty) {
      return;
    }

    setState(() => _isSaving = true);

    try {
      final notifier = ref.read(locationClosuresProvider.notifier);

      var count = 0;
      for (final index in _selectedHolidayIndices) {
        final holiday = _holidays[index];

        await notifier.addClosure(
          locationIds: _selectedLocationIds.toList(),
          startDate: holiday.date,
          endDate: holiday.date,
          reason: holiday.name,
        );
        count++;
      }

      if (mounted) {
        Navigator.of(context).pop(count);
      }
    } catch (e) {
      if (mounted) {
        setState(() => _isSaving = false);
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text(e.toString())));
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    if (_holidaysProvider == null) {
      return AlertDialog(
        title: Text(l10n.closuresImportHolidaysTitle),
        content: Text(l10n.closuresImportHolidaysUnsupportedCountry),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text(l10n.actionClose),
          ),
        ],
      );
    }

    final dateFormat = DateFormat('EEEE d MMMM', 'it');
    final alreadyAddedCount = _holidays.where(_isHolidayAlreadyAdded).length;

    return AlertDialog(
      title: Text(l10n.closuresImportHolidaysTitle),
      content: SizedBox(
        width: 500,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Anno selector con pulsanti rapidi
            Row(
              children: [
                Text(l10n.closuresImportHolidaysYear),
                const SizedBox(width: 16),
                // Chip per anno corrente
                ChoiceChip(
                  label: Text('${DateTime.now().year}'),
                  selected: _selectedYear == DateTime.now().year,
                  onSelected: (selected) {
                    if (selected) {
                      setState(() {
                        _selectedYear = DateTime.now().year;
                        _loadHolidays();
                      });
                    }
                  },
                ),
                const SizedBox(width: 8),
                // Chip per anno successivo
                ChoiceChip(
                  label: Text('${DateTime.now().year + 1}'),
                  selected: _selectedYear == DateTime.now().year + 1,
                  onSelected: (selected) {
                    if (selected) {
                      setState(() {
                        _selectedYear = DateTime.now().year + 1;
                        _loadHolidays();
                      });
                    }
                  },
                ),
                const SizedBox(width: 8),
                // Chip per anno +2
                ChoiceChip(
                  label: Text('${DateTime.now().year + 2}'),
                  selected: _selectedYear == DateTime.now().year + 2,
                  onSelected: (selected) {
                    if (selected) {
                      setState(() {
                        _selectedYear = DateTime.now().year + 2;
                        _loadHolidays();
                      });
                    }
                  },
                ),
              ],
            ),
            const SizedBox(height: 16),

            // Location selector (se pi√π di una)
            if (widget.locations.length > 1) ...[
              Text(
                l10n.closuresImportHolidaysLocations,
                style: theme.textTheme.titleSmall,
              ),
              const SizedBox(height: 8),
              Wrap(
                spacing: 8,
                runSpacing: 4,
                children: widget.locations.map((location) {
                  final isSelected = _selectedLocationIds.contains(location.id);
                  return FilterChip(
                    label: Text(location.name),
                    selected: isSelected,
                    onSelected: (selected) {
                      setState(() {
                        if (selected) {
                          _selectedLocationIds.add(location.id);
                        } else {
                          _selectedLocationIds.remove(location.id);
                        }
                        _loadHolidays(); // Ricalcola quelle gi√† aggiunte
                      });
                    },
                  );
                }).toList(),
              ),
              const SizedBox(height: 16),
            ],

            // Info festivit√† gi√† presenti
            if (alreadyAddedCount > 0)
              Container(
                padding: const EdgeInsets.all(12),
                margin: const EdgeInsets.only(bottom: 16),
                decoration: BoxDecoration(
                  color: colorScheme.primaryContainer.withOpacity(0.3),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    Icon(
                      Icons.info_outline,
                      size: 20,
                      color: colorScheme.primary,
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        l10n.closuresImportHolidaysAlreadyAdded(
                          alreadyAddedCount,
                        ),
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: colorScheme.primary,
                        ),
                      ),
                    ),
                  ],
                ),
              ),

            // Lista festivit√†
            Text(
              l10n.closuresImportHolidaysList,
              style: theme.textTheme.titleSmall,
            ),
            const SizedBox(height: 8),
            Container(
              height: 300,
              decoration: BoxDecoration(
                border: Border.all(color: colorScheme.outline.withOpacity(0.3)),
                borderRadius: BorderRadius.circular(8),
              ),
              child: ListView.builder(
                itemCount: _holidays.length,
                itemBuilder: (context, index) {
                  final holiday = _holidays[index];
                  final isAlreadyAdded = _isHolidayAlreadyAdded(holiday);
                  final isSelected = _selectedHolidayIndices.contains(index);

                  return CheckboxListTile(
                    value: isSelected,
                    onChanged: isAlreadyAdded
                        ? null
                        : (value) {
                            setState(() {
                              if (value == true) {
                                _selectedHolidayIndices.add(index);
                              } else {
                                _selectedHolidayIndices.remove(index);
                              }
                            });
                          },
                    title: Text(
                      holiday.name,
                      style: TextStyle(
                        color: isAlreadyAdded
                            ? colorScheme.outline
                            : colorScheme.onSurface,
                        decoration: isAlreadyAdded
                            ? TextDecoration.lineThrough
                            : null,
                      ),
                    ),
                    subtitle: Text(
                      dateFormat.format(holiday.date),
                      style: TextStyle(
                        color: isAlreadyAdded
                            ? colorScheme.outline
                            : colorScheme.onSurfaceVariant,
                      ),
                    ),
                    secondary: isAlreadyAdded
                        ? Icon(
                            Icons.check_circle,
                            color: colorScheme.primary,
                            size: 20,
                          )
                        : null,
                  );
                },
              ),
            ),

            // Seleziona tutti / nessuno
            const SizedBox(height: 8),
            Row(
              children: [
                TextButton(
                  onPressed: () {
                    setState(() {
                      _selectedHolidayIndices.clear();
                      for (var i = 0; i < _holidays.length; i++) {
                        if (!_isHolidayAlreadyAdded(_holidays[i])) {
                          _selectedHolidayIndices.add(i);
                        }
                      }
                    });
                  },
                  child: Text(l10n.actionSelectAll),
                ),
                TextButton(
                  onPressed: () {
                    setState(() => _selectedHolidayIndices.clear());
                  },
                  child: Text(l10n.actionDeselectAll),
                ),
              ],
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isSaving ? null : () => Navigator.of(context).pop(),
          child: Text(l10n.actionCancel),
        ),
        AppAsyncFilledButton(
          onPressed:
              _selectedHolidayIndices.isEmpty ||
                  _selectedLocationIds.isEmpty ||
                  _isSaving
              ? null
              : _onSave,
          isLoading: _isSaving,
          child: Text(
            l10n.closuresImportHolidaysAction(_selectedHolidayIndices.length),
          ),
        ),
      ],
    );
  }
}
--- FILE: lib/features/business/presentation/dialogs/create_business_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/network/api_client.dart';
import '../../../../core/widgets/local_loading_overlay.dart';
import '../../../agenda/providers/business_providers.dart';
import '../../providers/business_providers.dart';

/// Dialog per creare un nuovo business (solo superadmin).
/// Richiede l'email dell'admin che ricever√† una mail di benvenuto.
class CreateBusinessDialog extends ConsumerStatefulWidget {
  const CreateBusinessDialog({super.key});

  @override
  ConsumerState<CreateBusinessDialog> createState() =>
      _CreateBusinessDialogState();
}

class _CreateBusinessDialogState extends ConsumerState<CreateBusinessDialog> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _slugController = TextEditingController();
  final _adminEmailController = TextEditingController();
  final _emailController = TextEditingController();
  final _phoneController = TextEditingController();
  final _onlineBookingsNotificationEmailController = TextEditingController();

  bool _isLoading = false;
  String? _error;
  bool _autoGenerateSlug = true;
  String _selectedServiceColorPalette = 'legacy';

  @override
  void initState() {
    super.initState();
    _nameController.addListener(_onNameChanged);
  }

  @override
  void dispose() {
    _nameController.removeListener(_onNameChanged);
    _nameController.dispose();
    _slugController.dispose();
    _adminEmailController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    _onlineBookingsNotificationEmailController.dispose();
    super.dispose();
  }

  void _onNameChanged() {
    if (_autoGenerateSlug) {
      _slugController.text = _generateSlug(_nameController.text);
    }
  }

  String _generateSlug(String name) {
    return name
        .toLowerCase()
        .replaceAll(RegExp(r'[√†√°√¢√£√§√•]'), 'a')
        .replaceAll(RegExp(r'[√®√©√™√´]'), 'e')
        .replaceAll(RegExp(r'[√¨√≠√Æ√Ø]'), 'i')
        .replaceAll(RegExp(r'[√≤√≥√¥√µ√∂]'), 'o')
        .replaceAll(RegExp(r'[√π√∫√ª√º]'), 'u')
        .replaceAll(RegExp(r'[^a-z0-9\s-]'), '')
        .replaceAll(RegExp(r'\s+'), '-')
        .replaceAll(RegExp(r'-+'), '-')
        .replaceAll(RegExp(r'^-|-$'), '');
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      final repository = ref.read(businessRepositoryProvider);

      await repository.createBusiness(
        name: _nameController.text.trim(),
        slug: _slugController.text.trim(),
        adminEmail: _adminEmailController.text.trim().isEmpty
            ? null
            : _adminEmailController.text.trim(),
        email: _emailController.text.trim().isEmpty
            ? null
            : _emailController.text.trim(),
        phone: _phoneController.text.trim().isEmpty
            ? null
            : _phoneController.text.trim(),
        onlineBookingsNotificationEmail:
            _onlineBookingsNotificationEmailController.text.trim().isEmpty
            ? null
            : _onlineBookingsNotificationEmailController.text.trim(),
        serviceColorPalette: _selectedServiceColorPalette,
      );

      // Invalida il provider per ricaricare la lista
      ref.invalidate(businessesProvider);

      // Attendi un frame per permettere al provider di invalidarsi
      await Future.delayed(Duration.zero);

      if (mounted) {
        Navigator.of(context).pop(true);
      }
    } on ApiException catch (e) {
      setState(() {
        _error = e.message;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return AlertDialog(
      title: const Text('Nuovo Business'),
      content: SizedBox(
        width: 400,
        child: LocalLoadingOverlay(
          isLoading: _isLoading,
          child: Form(
            key: _formKey,
            child: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  if (_error != null) ...[
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: colorScheme.errorContainer,
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Row(
                        children: [
                          Icon(
                            Icons.error_outline,
                            color: colorScheme.onErrorContainer,
                            size: 20,
                          ),
                          const SizedBox(width: 8),
                          Expanded(
                            child: Text(
                              _error!,
                              style: TextStyle(
                                color: colorScheme.onErrorContainer,
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(height: 16),
                  ],
                  // Nome
                  TextFormField(
                    controller: _nameController,
                    decoration: const InputDecoration(
                      labelText: 'Nome *',
                      hintText: 'es. Salone Bellezza',
                      prefixIcon: Icon(Icons.business),
                    ),
                    textCapitalization: TextCapitalization.words,
                    validator: (value) {
                      if (value == null || value.trim().isEmpty) {
                        return 'Il nome √® obbligatorio';
                      }
                      if (value.trim().length < 2) {
                        return 'Il nome deve avere almeno 2 caratteri';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                  // Slug
                  TextFormField(
                    controller: _slugController,
                    decoration: InputDecoration(
                      labelText: 'Slug URL *',
                      hintText: 'es. salone-bellezza',
                      prefixIcon: const Icon(Icons.link),
                      helperText: 'Usato per URL: prenota.romeolab.it/slug',
                      suffixIcon: _autoGenerateSlug
                          ? IconButton(
                              icon: const Icon(Icons.edit),
                              tooltip: 'Modifica manualmente',
                              onPressed: () {
                                setState(() => _autoGenerateSlug = false);
                              },
                            )
                          : IconButton(
                              icon: const Icon(Icons.auto_fix_high),
                              tooltip: 'Genera automaticamente',
                              onPressed: () {
                                setState(() {
                                  _autoGenerateSlug = true;
                                  _slugController.text = _generateSlug(
                                    _nameController.text,
                                  );
                                });
                              },
                            ),
                    ),
                    onChanged: (_) {
                      if (_autoGenerateSlug) {
                        setState(() => _autoGenerateSlug = false);
                      }
                    },
                    validator: (value) {
                      if (value == null || value.trim().isEmpty) {
                        return 'Lo slug √® obbligatorio';
                      }
                      if (!RegExp(r'^[a-z0-9-]+$').hasMatch(value)) {
                        return 'Solo lettere minuscole, numeri e trattini';
                      }
                      if (value.length < 3) {
                        return 'Lo slug deve avere almeno 3 caratteri';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                  // Email Admin (opzionale - pu√≤ essere assegnato dopo)
                  TextFormField(
                    controller: _adminEmailController,
                    decoration: const InputDecoration(
                      labelText: 'Email Amministratore',
                      hintText: 'es. mario.rossi@email.it',
                      prefixIcon: Icon(Icons.admin_panel_settings),
                      helperText:
                          'Opzionale: ricever√† email per configurare account',
                    ),
                    keyboardType: TextInputType.emailAddress,
                    validator: (value) {
                      // Solo valida se inserito
                      if (value != null && value.trim().isNotEmpty) {
                        if (!RegExp(
                          r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                        ).hasMatch(value)) {
                          return 'Email non valida';
                        }
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                  // Email Business (opzionale)
                  TextFormField(
                    controller: _emailController,
                    decoration: const InputDecoration(
                      labelText: 'Email Business',
                      hintText: 'es. info@salone.it',
                      prefixIcon: Icon(Icons.email_outlined),
                      helperText: 'Contatto pubblico del business',
                    ),
                    keyboardType: TextInputType.emailAddress,
                    validator: (value) {
                      if (value != null && value.isNotEmpty) {
                        if (!RegExp(
                          r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                        ).hasMatch(value)) {
                          return 'Email non valida';
                        }
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                  // Notifiche prenotazioni online (solo azioni cliente)
                  TextFormField(
                    controller: _onlineBookingsNotificationEmailController,
                    decoration: InputDecoration(
                      labelText:
                          l10n.businessOnlineBookingsNotificationEmailLabel,
                      hintText:
                          l10n.businessOnlineBookingsNotificationEmailHint,
                      prefixIcon: const Icon(Icons.notifications_outlined),
                      helperText:
                          l10n.businessOnlineBookingsNotificationEmailHelper,
                    ),
                    keyboardType: TextInputType.emailAddress,
                    validator: (value) {
                      if (value != null && value.trim().isNotEmpty) {
                        if (!RegExp(
                          r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                        ).hasMatch(value.trim())) {
                          return l10n.authInvalidEmail;
                        }
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                  DropdownButtonFormField<String>(
                    value: _selectedServiceColorPalette,
                    decoration: InputDecoration(
                      labelText: l10n.businessServiceColorPaletteLabel,
                      helperText: l10n.businessServiceColorPaletteHelper,
                      prefixIcon: const Icon(Icons.palette_outlined),
                    ),
                    items: [
                      DropdownMenuItem(
                        value: 'enhanced',
                        child: Text(l10n.businessServiceColorPaletteEnhanced),
                      ),
                      DropdownMenuItem(
                        value: 'legacy',
                        child: Text(l10n.businessServiceColorPaletteLegacy),
                      ),
                    ],
                    onChanged: (value) {
                      if (value == null) return;
                      setState(() => _selectedServiceColorPalette = value);
                    },
                  ),
                  const SizedBox(height: 16),
                  // Telefono
                  TextFormField(
                    controller: _phoneController,
                    decoration: const InputDecoration(
                      labelText: 'Telefono',
                      hintText: 'es. +39 123 456 7890',
                      prefixIcon: Icon(Icons.phone_outlined),
                    ),
                    keyboardType: TextInputType.phone,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    '* Campi obbligatori',
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: colorScheme.onSurfaceVariant,
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
          child: Text(l10n.actionCancel),
        ),
        FilledButton(
          onPressed: _isLoading ? null : _submit,
          child: const Text('Crea Business'),
        ),
      ],
    );
  }
}

/// Mostra il dialog per creare un nuovo business.
Future<bool?> showCreateBusinessDialog(BuildContext context) {
  return showDialog<bool>(
    context: context,
    builder: (context) => const CreateBusinessDialog(),
  );
}
--- FILE: lib/features/business/presentation/dialogs/invite_operator_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/location.dart';
import '../../../../core/models/staff.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/feedback_dialog.dart';
import '../../../../core/widgets/local_loading_overlay.dart';
import '../../../agenda/providers/location_providers.dart';
import '../../../staff/providers/staff_providers.dart';
import '../../providers/business_users_provider.dart';

String _resolveInviteErrorMessage(
  BuildContext context,
  dynamic l10n,
  String rawError,
) {
  final error = rawError.toLowerCase();
  final isIt =
      Localizations.localeOf(context).languageCode.toLowerCase() == 'it';

  String emailUnavailable() => isIt
      ? 'Invio email non disponibile in questo ambiente. Contatta il supporto.'
      : 'Email sending is unavailable in this environment. Please contact support.';

  String emailFailed() => isIt
      ? 'Impossibile inviare l\'email di invito. Riprova pi√π tardi.'
      : 'Unable to send the invitation email. Please try again later.';

  String alreadyHasAccess() => isIt
      ? 'Questo utente ha gi√† accesso al business.'
      : 'This user already has access to the business.';

  if (error.contains('already pending')) {
    return l10n.operatorsInviteAlreadyPending;
  }
  if (error.contains('already has access')) {
    return alreadyHasAccess();
  }
  if (error.contains('failed to send invitation email') ||
      error.contains('mail_provider') ||
      error.contains('mail_from_address') ||
      error.contains('smtp') ||
      error.contains('brevo') ||
      error.contains('mailgun') ||
      error.contains('not configured')) {
    return emailUnavailable();
  }
  if (error.contains('internal_error') || error.contains('network')) {
    return emailFailed();
  }
  return l10n.operatorsInviteError;
}

/// Dialog per invitare un nuovo operatore (desktop).
class InviteOperatorDialog extends ConsumerStatefulWidget {
  const InviteOperatorDialog({super.key, required this.businessId});

  final int businessId;

  @override
  ConsumerState<InviteOperatorDialog> createState() =>
      _InviteOperatorDialogState();
}

class _InviteOperatorDialogState extends ConsumerState<InviteOperatorDialog> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  String _selectedRole = 'staff';
  String _selectedScopeType = 'locations';
  final Set<int> _selectedLocationIds = {};
  int? _selectedStaffId;
  bool _isLoading = false;

  @override
  void dispose() {
    _emailController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final locations = ref.watch(locationsProvider);
    _ensureDefaultSingleLocationForStaff(locations);
    final allStaff = ref.watch(allStaffProvider).value ?? const <Staff>[];
    final availableStaff = _availableStaff(allStaff);

    return AppFormDialog(
      title: Text(l10n.operatorsInviteTitle),
      content: LocalLoadingOverlay(
        isLoading: _isLoading,
        child: Form(
          key: _formKey,
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  l10n.operatorsInviteSubtitle,
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
                const SizedBox(height: 24),
                TextFormField(
                  controller: _emailController,
                  decoration: InputDecoration(
                    labelText: l10n.operatorsInviteEmail,
                    border: const OutlineInputBorder(),
                    prefixIcon: const Icon(Icons.email_outlined),
                  ),
                  keyboardType: TextInputType.emailAddress,
                  autofocus: true,
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.validationRequired;
                    }
                    if (!_isValidEmail(value)) {
                      return l10n.validationInvalidEmail;
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                Text(
                  l10n.operatorsInviteRole,
                  style: Theme.of(context).textTheme.titleSmall,
                ),
                const SizedBox(height: 8),
                _RoleSelector(
                  selectedRole: _selectedRole,
                  onChanged: (role) => setState(() {
                    _selectedRole = role;
                    if (role == 'staff') {
                      _selectedScopeType = 'locations';
                      _selectedLocationIds.clear();
                      if (locations.length == 1) {
                        _selectedLocationIds.add(locations.first.id);
                      }
                    }
                    _enforceSingleLocationForStaff();
                    if (role != 'staff') {
                      _selectedStaffId = null;
                    } else {
                      _clearInvalidSelectedStaff(availableStaff);
                    }
                  }),
                ),
                if (locations.length > 1) ...[
                  const SizedBox(height: 24),
                  const Divider(),
                  const SizedBox(height: 16),
                  if (_selectedRole != 'staff') ...[
                    _ScopeTypeSelector(
                      selectedScopeType: _selectedScopeType,
                      onChanged: (scope) => setState(() {
                        _selectedScopeType = scope;
                        if (scope == 'business') {
                          _selectedLocationIds.clear();
                        }
                        _enforceSingleLocationForStaff();
                        _clearInvalidSelectedStaff(availableStaff);
                      }),
                    ),
                  ],
                  if (_selectedRole == 'staff' || _selectedScopeType == 'locations') ...[
                    const SizedBox(height: 16),
                    _LocationsMultiSelect(
                      locations: locations,
                      selectedIds: _selectedLocationIds,
                      singleSelection: _selectedRole == 'staff',
                      onChanged: (ids) => setState(() {
                        final previousSelection = Set<int>.from(_selectedLocationIds);
                        _selectedLocationIds.clear();
                        if (_selectedRole == 'staff') {
                          if (ids.isNotEmpty) {
                            _selectedLocationIds.add(ids.last);
                          }
                        } else {
                          _selectedLocationIds.addAll(ids);
                        }
                        if (_selectedRole == 'staff' &&
                            previousSelection.length == 1 &&
                            _selectedLocationIds.length == 1 &&
                            previousSelection.first != _selectedLocationIds.first) {
                          _selectedStaffId = null;
                        }
                        _clearInvalidSelectedStaff(availableStaff);
                      }),
                    ),
                  ],
                ],
                if (_selectedRole == 'staff') ...[
                  const SizedBox(height: 16),
                  _StaffSingleSelect(
                    staff: availableStaff,
                    selectedStaffId: _selectedStaffId,
                    isEnabled: _selectedScopeType != 'locations' ||
                        _selectedLocationIds.isNotEmpty,
                    onChanged: (staffId) =>
                        setState(() => _selectedStaffId = staffId),
                  ),
                ],
              ],
            ),
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
          child: Text(l10n.actionCancel),
        ),
        FilledButton(
          onPressed: _isLoading ? null : _submit,
          child: Text(l10n.operatorsInviteSend),
        ),
      ],
    );
  }

  bool _isValidEmail(String email) {
    return RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(email);
  }

  List<Staff> _availableStaff(List<Staff> allStaff) {
    if (_selectedRole != 'staff') return const <Staff>[];
    if (_selectedScopeType != 'locations') return allStaff;
    if (_selectedLocationIds.isEmpty) return const <Staff>[];

    return allStaff
        .where((member) => member.locationIds.any(_selectedLocationIds.contains))
        .toList();
  }

  void _clearInvalidSelectedStaff(List<Staff> availableStaff) {
    if (_selectedStaffId == null) return;
    final exists = availableStaff.any((s) => s.id == _selectedStaffId);
    if (!exists) {
      _selectedStaffId = null;
    }
  }

  void _enforceSingleLocationForStaff() {
    if (_selectedRole == 'staff' &&
        _selectedScopeType == 'locations' &&
        _selectedLocationIds.length > 1) {
      final keep = _selectedLocationIds.last;
      _selectedLocationIds
        ..clear()
        ..add(keep);
    }
  }

  void _ensureDefaultSingleLocationForStaff(List<Location> locations) {
    if (_selectedRole == 'staff' &&
        _selectedScopeType == 'locations' &&
        locations.length == 1 &&
        _selectedLocationIds.isEmpty) {
      _selectedLocationIds.add(locations.first.id);
    }
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) return;

    // Validazione scope
    if (_selectedScopeType == 'locations' && _selectedLocationIds.isEmpty) {
      final isIt = Localizations.localeOf(context).languageCode.toLowerCase() == 'it';
      FeedbackDialog.showError(
        context,
        title: isIt ? 'Attenzione' : 'Warning',
        message: context.l10n.operatorsScopeLocationsRequired,
      );
      return;
    }

    if (_selectedRole == 'staff' &&
        _selectedScopeType == 'locations' &&
        _selectedLocationIds.length > 1) {
      final isIt =
          Localizations.localeOf(context).languageCode.toLowerCase() == 'it';
      FeedbackDialog.showError(
        context,
        title: isIt ? 'Attenzione' : 'Warning',
        message: isIt
            ? 'Per il ruolo Staff puoi selezionare una sola sede.'
            : 'For Staff role you can select only one location.',
      );
      return;
    }

    if (_selectedRole == 'staff' && (_selectedStaffId == null || _selectedStaffId! <= 0)) {
      final isIt = Localizations.localeOf(context).languageCode.toLowerCase() == 'it';
      FeedbackDialog.showError(
        context,
        title: isIt ? 'Attenzione' : 'Warning',
        message: isIt
            ? 'Per il ruolo Staff devi selezionare un membro staff.'
            : 'For Staff role you must select one staff member.',
      );
      return;
    }

    setState(() => _isLoading = true);

    final invitation = await ref
        .read(businessUsersProvider(widget.businessId).notifier)
        .createInvitation(
          email: _emailController.text.trim(),
          role: _selectedRole,
          staffId: _selectedRole == 'staff' ? _selectedStaffId : null,
          scopeType: _selectedScopeType,
          locationIds: _selectedScopeType == 'locations'
              ? _selectedLocationIds.toList()
              : null,
        );

    if (!mounted) return;

    setState(() => _isLoading = false);

    if (invitation != null) {
      Navigator.of(context).pop();
      _showSuccessDialog(context, invitation.email);
    } else {
      _showInviteError(context, ref);
    }
  }

  void _showInviteError(BuildContext context, WidgetRef ref) {
    final state = ref.read(businessUsersProvider(widget.businessId));
    final errorMsg = state.error ?? '';
    final l10n = context.l10n;
    final message = _resolveInviteErrorMessage(context, l10n, errorMsg);

    FeedbackDialog.showError(
      context,
      title: l10n.operatorsInviteError,
      message: message,
    );

    ref.read(businessUsersProvider(widget.businessId).notifier).clearError();
  }

  void _showSuccessDialog(BuildContext context, String email) {
    final l10n = context.l10n;
    FeedbackDialog.showSuccess(
      context,
      title: l10n.operatorsInviteTitle,
      message: l10n.operatorsInviteSuccess(email),
    );
  }
}

/// Bottom sheet per invitare un nuovo operatore (mobile/tablet).
class InviteOperatorSheet extends ConsumerStatefulWidget {
  const InviteOperatorSheet({super.key, required this.businessId});

  final int businessId;

  @override
  ConsumerState<InviteOperatorSheet> createState() =>
      _InviteOperatorSheetState();
}

class _InviteOperatorSheetState extends ConsumerState<InviteOperatorSheet> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  String _selectedRole = 'staff';
  String _selectedScopeType = 'locations';
  final Set<int> _selectedLocationIds = {};
  int? _selectedStaffId;
  bool _isLoading = false;

  @override
  void dispose() {
    _emailController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final locations = ref.watch(locationsProvider);
    _ensureDefaultSingleLocationForStaff(locations);
    final allStaff = ref.watch(allStaffProvider).value ?? const <Staff>[];
    final availableStaff = _availableStaff(allStaff);

    return LocalLoadingOverlay(
      isLoading: _isLoading,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // Header
          Text(
            l10n.operatorsInviteTitle,
            style: Theme.of(context).textTheme.titleLarge,
          ),
          const SizedBox(height: 4),
          Text(
            l10n.operatorsInviteSubtitle,
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
          ),
          const SizedBox(height: 24),

          // Form
          Expanded(
            child: Form(
              key: _formKey,
              child: ListView(
                children: [
                  TextFormField(
                    controller: _emailController,
                    decoration: InputDecoration(
                      labelText: l10n.operatorsInviteEmail,
                      border: const OutlineInputBorder(),
                      prefixIcon: const Icon(Icons.email_outlined),
                    ),
                    keyboardType: TextInputType.emailAddress,
                    autofocus: true,
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.validationRequired;
                      }
                      if (!_isValidEmail(value)) {
                        return l10n.validationInvalidEmail;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 24),
                  Text(
                    l10n.operatorsInviteRole,
                    style: Theme.of(context).textTheme.titleSmall,
                  ),
                  const SizedBox(height: 8),
                _RoleSelector(
                  selectedRole: _selectedRole,
                  onChanged: (role) => setState(() {
                    _selectedRole = role;
                    if (role == 'staff') {
                      _selectedScopeType = 'locations';
                      _selectedLocationIds.clear();
                      if (locations.length == 1) {
                        _selectedLocationIds.add(locations.first.id);
                      }
                    }
                    _enforceSingleLocationForStaff();
                    if (role != 'staff') {
                      _selectedStaffId = null;
                    } else {
                      _clearInvalidSelectedStaff(availableStaff);
                      }
                    }),
                  ),
                  if (locations.length > 1) ...[
                    const SizedBox(height: 24),
                    const Divider(),
                    const SizedBox(height: 16),
                    if (_selectedRole != 'staff') ...[
                      _ScopeTypeSelector(
                        selectedScopeType: _selectedScopeType,
                        onChanged: (scope) => setState(() {
                          _selectedScopeType = scope;
                          if (scope == 'business') {
                            _selectedLocationIds.clear();
                          }
                          _enforceSingleLocationForStaff();
                          _clearInvalidSelectedStaff(availableStaff);
                        }),
                      ),
                    ],
                    if (_selectedRole == 'staff' || _selectedScopeType == 'locations') ...[
                      const SizedBox(height: 16),
                      _LocationsMultiSelect(
                        locations: locations,
                        selectedIds: _selectedLocationIds,
                        singleSelection: _selectedRole == 'staff',
                        onChanged: (ids) => setState(() {
                          final previousSelection = Set<int>.from(_selectedLocationIds);
                          _selectedLocationIds.clear();
                          if (_selectedRole == 'staff') {
                            if (ids.isNotEmpty) {
                              _selectedLocationIds.add(ids.last);
                            }
                          } else {
                            _selectedLocationIds.addAll(ids);
                          }
                          if (_selectedRole == 'staff' &&
                              previousSelection.length == 1 &&
                              _selectedLocationIds.length == 1 &&
                              previousSelection.first != _selectedLocationIds.first) {
                            _selectedStaffId = null;
                          }
                          _clearInvalidSelectedStaff(availableStaff);
                        }),
                      ),
                    ],
                  ],
                  if (_selectedRole == 'staff') ...[
                    const SizedBox(height: 16),
                    _StaffSingleSelect(
                      staff: availableStaff,
                      selectedStaffId: _selectedStaffId,
                      isEnabled: _selectedScopeType != 'locations' ||
                          _selectedLocationIds.isNotEmpty,
                      onChanged: (staffId) =>
                          setState(() => _selectedStaffId = staffId),
                    ),
                  ],
                ],
              ),
            ),
          ),

          // Actions
          const SizedBox(height: 16),
          Row(
            children: [
              Expanded(
                child: OutlinedButton(
                  onPressed: _isLoading
                      ? null
                      : () => Navigator.of(context).pop(),
                  child: Text(l10n.actionCancel),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: FilledButton(
                  onPressed: _isLoading ? null : _submit,
                  child: Text(l10n.operatorsInviteSend),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  bool _isValidEmail(String email) {
    return RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(email);
  }

  List<Staff> _availableStaff(List<Staff> allStaff) {
    if (_selectedRole != 'staff') return const <Staff>[];
    if (_selectedScopeType != 'locations') return allStaff;
    if (_selectedLocationIds.isEmpty) return const <Staff>[];

    return allStaff
        .where((member) => member.locationIds.any(_selectedLocationIds.contains))
        .toList();
  }

  void _clearInvalidSelectedStaff(List<Staff> availableStaff) {
    if (_selectedStaffId == null) return;
    final exists = availableStaff.any((s) => s.id == _selectedStaffId);
    if (!exists) {
      _selectedStaffId = null;
    }
  }

  void _enforceSingleLocationForStaff() {
    if (_selectedRole == 'staff' &&
        _selectedScopeType == 'locations' &&
        _selectedLocationIds.length > 1) {
      final keep = _selectedLocationIds.last;
      _selectedLocationIds
        ..clear()
        ..add(keep);
    }
  }

  void _ensureDefaultSingleLocationForStaff(List<Location> locations) {
    if (_selectedRole == 'staff' &&
        _selectedScopeType == 'locations' &&
        locations.length == 1 &&
        _selectedLocationIds.isEmpty) {
      _selectedLocationIds.add(locations.first.id);
    }
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) return;

    // Validazione scope
    if (_selectedScopeType == 'locations' && _selectedLocationIds.isEmpty) {
      final isIt = Localizations.localeOf(context).languageCode.toLowerCase() == 'it';
      FeedbackDialog.showError(
        context,
        title: isIt ? 'Attenzione' : 'Warning',
        message: context.l10n.operatorsScopeLocationsRequired,
      );
      return;
    }

    if (_selectedRole == 'staff' &&
        _selectedScopeType == 'locations' &&
        _selectedLocationIds.length > 1) {
      final isIt =
          Localizations.localeOf(context).languageCode.toLowerCase() == 'it';
      FeedbackDialog.showError(
        context,
        title: isIt ? 'Attenzione' : 'Warning',
        message: isIt
            ? 'Per il ruolo Staff puoi selezionare una sola sede.'
            : 'For Staff role you can select only one location.',
      );
      return;
    }

    if (_selectedRole == 'staff' && (_selectedStaffId == null || _selectedStaffId! <= 0)) {
      final isIt = Localizations.localeOf(context).languageCode.toLowerCase() == 'it';
      FeedbackDialog.showError(
        context,
        title: isIt ? 'Attenzione' : 'Warning',
        message: isIt
            ? 'Per il ruolo Staff devi selezionare un membro staff.'
            : 'For Staff role you must select one staff member.',
      );
      return;
    }

    setState(() => _isLoading = true);

    final invitation = await ref
        .read(businessUsersProvider(widget.businessId).notifier)
        .createInvitation(
          email: _emailController.text.trim(),
          role: _selectedRole,
          staffId: _selectedRole == 'staff' ? _selectedStaffId : null,
          scopeType: _selectedScopeType,
          locationIds: _selectedScopeType == 'locations'
              ? _selectedLocationIds.toList()
              : null,
        );

    if (!mounted) return;

    setState(() => _isLoading = false);

    if (invitation != null) {
      Navigator.of(context).pop();
      _showSuccessDialog(context, invitation.email);
    } else {
      _showInviteError(context, ref);
    }
  }

  void _showInviteError(BuildContext context, WidgetRef ref) {
    final state = ref.read(businessUsersProvider(widget.businessId));
    final errorMsg = state.error ?? '';
    final l10n = context.l10n;
    final message = _resolveInviteErrorMessage(context, l10n, errorMsg);

    FeedbackDialog.showError(
      context,
      title: l10n.operatorsInviteError,
      message: message,
    );

    ref.read(businessUsersProvider(widget.businessId).notifier).clearError();
  }

  void _showSuccessDialog(BuildContext context, String email) {
    final l10n = context.l10n;
    FeedbackDialog.showSuccess(
      context,
      title: l10n.operatorsInviteTitle,
      message: l10n.operatorsInviteSuccess(email),
    );
  }
}

/// Widget per selezionare un ruolo.
class _RoleSelector extends StatelessWidget {
  const _RoleSelector({required this.selectedRole, required this.onChanged});

  final String selectedRole;
  final ValueChanged<String> onChanged;

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;

    return Column(
      children: [
        _RoleOption(
          role: 'admin',
          label: l10n.operatorsRoleAdmin,
          description: l10n.operatorsRoleAdminDesc,
          icon: Icons.admin_panel_settings,
          isSelected: selectedRole == 'admin',
          onTap: () => onChanged('admin'),
        ),
        const SizedBox(height: 8),
        _RoleOption(
          role: 'manager',
          label: l10n.operatorsRoleManager,
          description: l10n.operatorsRoleManagerDesc,
          icon: Icons.manage_accounts,
          isSelected: selectedRole == 'manager',
          onTap: () => onChanged('manager'),
        ),
        const SizedBox(height: 8),
        _RoleOption(
          role: 'staff',
          label: l10n.operatorsRoleStaff,
          description: l10n.operatorsRoleStaffDesc,
          icon: Icons.person,
          isSelected: selectedRole == 'staff',
          onTap: () => onChanged('staff'),
        ),
        const SizedBox(height: 8),
        _RoleOption(
          role: 'viewer',
          label: l10n.operatorsRoleViewer,
          description: l10n.operatorsRoleViewerDesc,
          icon: Icons.visibility_outlined,
          isSelected: selectedRole == 'viewer',
          onTap: () => onChanged('viewer'),
        ),
      ],
    );
  }
}

/// Singola opzione ruolo.
class _RoleOption extends StatelessWidget {
  const _RoleOption({
    required this.role,
    required this.label,
    required this.description,
    required this.icon,
    required this.isSelected,
    required this.onTap,
  });

  final String role;
  final String label;
  final String description;
  final IconData icon;
  final bool isSelected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: isSelected ? colorScheme.primary : colorScheme.outline,
            width: isSelected ? 2 : 1,
          ),
          color: isSelected
              ? colorScheme.primaryContainer.withOpacity(0.3)
              : null,
        ),
        child: Row(
          children: [
            Icon(
              icon,
              color: isSelected
                  ? colorScheme.primary
                  : colorScheme.onSurfaceVariant,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    label,
                    style: Theme.of(context).textTheme.titleSmall?.copyWith(
                      color: isSelected ? colorScheme.primary : null,
                      fontWeight: isSelected ? FontWeight.w600 : null,
                    ),
                  ),
                  Text(
                    description,
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: colorScheme.onSurfaceVariant,
                    ),
                  ),
                ],
              ),
            ),
            if (isSelected)
              Icon(Icons.check_circle, color: colorScheme.primary),
          ],
        ),
      ),
    );
  }
}

/// Widget per selezionare il tipo di scope (business o locations).
class _ScopeTypeSelector extends StatelessWidget {
  const _ScopeTypeSelector({
    required this.selectedScopeType,
    required this.onChanged,
  });

  final String selectedScopeType;
  final ValueChanged<String> onChanged;

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          l10n.operatorsScopeTitle,
          style: Theme.of(context).textTheme.titleSmall,
        ),
        const SizedBox(height: 8),
        _ScopeOption(
          scopeType: 'business',
          label: l10n.operatorsScopeBusiness,
          description: l10n.operatorsScopeBusinessDesc,
          icon: Icons.business,
          isSelected: selectedScopeType == 'business',
          onTap: () => onChanged('business'),
        ),
        const SizedBox(height: 8),
        _ScopeOption(
          scopeType: 'locations',
          label: l10n.operatorsScopeLocations,
          description: l10n.operatorsScopeLocationsDesc,
          icon: Icons.location_on,
          isSelected: selectedScopeType == 'locations',
          onTap: () => onChanged('locations'),
        ),
      ],
    );
  }
}

/// Singola opzione scope.
class _ScopeOption extends StatelessWidget {
  const _ScopeOption({
    required this.scopeType,
    required this.label,
    required this.description,
    required this.icon,
    required this.isSelected,
    required this.onTap,
  });

  final String scopeType;
  final String label;
  final String description;
  final IconData icon;
  final bool isSelected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: isSelected ? colorScheme.primary : colorScheme.outline,
            width: isSelected ? 2 : 1,
          ),
          color: isSelected
              ? colorScheme.primaryContainer.withOpacity(0.3)
              : null,
        ),
        child: Row(
          children: [
            Icon(
              icon,
              color: isSelected
                  ? colorScheme.primary
                  : colorScheme.onSurfaceVariant,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    label,
                    style: Theme.of(context).textTheme.titleSmall?.copyWith(
                      color: isSelected ? colorScheme.primary : null,
                      fontWeight: isSelected ? FontWeight.w600 : null,
                    ),
                  ),
                  Text(
                    description,
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: colorScheme.onSurfaceVariant,
                    ),
                  ),
                ],
              ),
            ),
            if (isSelected)
              Icon(Icons.check_circle, color: colorScheme.primary),
          ],
        ),
      ),
    );
  }
}

class _StaffSingleSelect extends StatelessWidget {
  const _StaffSingleSelect({
    required this.staff,
    required this.selectedStaffId,
    required this.isEnabled,
    required this.onChanged,
  });

  final List<Staff> staff;
  final int? selectedStaffId;
  final bool isEnabled;
  final ValueChanged<int?> onChanged;

  @override
  Widget build(BuildContext context) {
    final isIt = Localizations.localeOf(context).languageCode.toLowerCase() == 'it';
    final uniqueStaff = <int, Staff>{};
    for (final member in staff) {
      uniqueStaff.putIfAbsent(member.id, () => member);
    }
    final staffItems = uniqueStaff.values.toList();
    final effectiveSelectedId = (selectedStaffId != null &&
            uniqueStaff.containsKey(selectedStaffId))
        ? selectedStaffId
        : null;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          isIt ? 'Membro staff da associare' : 'Staff member to associate',
          style: Theme.of(context).textTheme.titleSmall,
        ),
        const SizedBox(height: 8),
        DropdownButtonFormField<int>(
          value: effectiveSelectedId,
          isExpanded: true,
          decoration: InputDecoration(
            border: const OutlineInputBorder(),
            labelText: isIt ? 'Seleziona staff' : 'Select staff',
          ),
          items: staffItems
              .map(
                (member) => DropdownMenuItem<int>(
                  value: member.id,
                  child: Text(member.displayName),
                ),
              )
              .toList(),
          onChanged: (!isEnabled || staffItems.isEmpty) ? null : onChanged,
        ),
        if (!isEnabled) ...[
          const SizedBox(height: 8),
          Text(
            isIt
                ? 'Seleziona una sede per abilitare la scelta dello staff.'
                : 'Select a location to enable staff selection.',
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
          ),
        ] else if (staffItems.isEmpty) ...[
          const SizedBox(height: 8),
          Text(
            isIt
                ? 'Nessuno staff disponibile per lo scope selezionato.'
                : 'No staff available for the selected scope.',
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ],
    );
  }
}

/// Widget per la selezione multipla delle location.
class _LocationsMultiSelect extends StatelessWidget {
  const _LocationsMultiSelect({
    required this.locations,
    required this.selectedIds,
    required this.singleSelection,
    required this.onChanged,
  });

  final List<Location> locations;
  final Set<int> selectedIds;
  final bool singleSelection;
  final ValueChanged<Set<int>> onChanged;

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;
    final isIt = Localizations.localeOf(context).languageCode.toLowerCase() == 'it';
    final title = singleSelection
        ? (isIt ? 'Seleziona una sede' : 'Select one location')
        : l10n.operatorsScopeSelectLocations;
    final listHeight = (locations.length * 72).clamp(72, 280).toDouble();

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: Theme.of(context).textTheme.titleSmall,
        ),
        const SizedBox(height: 8),
        Container(
          decoration: BoxDecoration(
            border: Border.all(color: colorScheme.outline),
            borderRadius: BorderRadius.circular(12),
          ),
          child: SizedBox(
            height: listHeight,
            child: ListView.separated(
              primary: false,
              itemCount: locations.length,
              separatorBuilder: (_, __) => const Divider(height: 1),
              itemBuilder: (context, index) {
                final location = locations[index];
                if (singleSelection) {
                  return _LocationRadioTile(
                    location: location,
                    selectedId: selectedIds.isEmpty ? null : selectedIds.first,
                    onChanged: (locationId) {
                      onChanged(locationId == null ? <int>{} : <int>{locationId});
                    },
                  );
                }

                return _LocationCheckboxTile(
                  location: location,
                  isSelected: selectedIds.contains(location.id),
                  onChanged: (selected) {
                    final newIds = Set<int>.from(selectedIds);
                    if (selected) {
                      newIds.add(location.id);
                    } else {
                      newIds.remove(location.id);
                    }
                    onChanged(newIds);
                  },
                );
              },
            ),
          ),
        ),
      ],
    );
  }
}

/// Singola checkbox per location.
class _LocationCheckboxTile extends StatelessWidget {
  const _LocationCheckboxTile({
    required this.location,
    required this.isSelected,
    required this.onChanged,
  });

  final Location location;
  final bool isSelected;
  final ValueChanged<bool> onChanged;

  @override
  Widget build(BuildContext context) {
    return CheckboxListTile(
      value: isSelected,
      onChanged: (value) => onChanged(value ?? false),
      title: Text(location.name),
      subtitle: location.address != null
          ? Text(
              location.address!,
              style: Theme.of(context).textTheme.bodySmall,
            )
          : null,
      secondary: const Icon(Icons.store_outlined),
      controlAffinity: ListTileControlAffinity.trailing,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
    );
  }
}

class _LocationRadioTile extends StatelessWidget {
  const _LocationRadioTile({
    required this.location,
    required this.selectedId,
    required this.onChanged,
  });

  final Location location;
  final int? selectedId;
  final ValueChanged<int?> onChanged;

  @override
  Widget build(BuildContext context) {
    return RadioListTile<int>(
      value: location.id,
      groupValue: selectedId,
      onChanged: onChanged,
      title: Text(location.name),
      subtitle: location.address != null
          ? Text(
              location.address!,
              style: Theme.of(context).textTheme.bodySmall,
            )
          : null,
      secondary: const Icon(Icons.store_outlined),
      controlAffinity: ListTileControlAffinity.trailing,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
    );
  }
}
--- FILE: lib/features/business/presentation/dialogs/role_selection_dialog.dart ---
import 'package:flutter/material.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/location.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/feedback_dialog.dart';

typedef RoleScopeSaveCallback =
    Future<void> Function({
      required String role,
      required String scopeType,
      required List<int> locationIds,
    });

/// Dialog per selezionare un ruolo (desktop).
class RoleSelectionDialog extends StatefulWidget {
  const RoleSelectionDialog({
    super.key,
    required this.currentRole,
    required this.currentScopeType,
    required this.currentLocationIds,
    required this.locations,
    required this.userName,
    required this.userEmail,
    required this.onSave,
  });

  final String currentRole;
  final String currentScopeType;
  final List<int> currentLocationIds;
  final List<Location> locations;
  final String userName;
  final String userEmail;
  final RoleScopeSaveCallback onSave;

  @override
  State<RoleSelectionDialog> createState() => _RoleSelectionDialogState();
}

class _RoleSelectionDialogState extends State<RoleSelectionDialog> {
  late String _selectedRole;
  late String _selectedScopeType;
  late Set<int> _selectedLocationIds;

  @override
  void initState() {
    super.initState();
    _selectedRole = widget.currentRole;
    _selectedScopeType = widget.currentScopeType.isNotEmpty
        ? widget.currentScopeType
        : 'business';
    _selectedLocationIds = widget.currentLocationIds.toSet();
    _enforceSingleLocationForStaff();
  }

  void _enforceSingleLocationForStaff() {
    if (_selectedRole == 'staff' &&
        _selectedScopeType == 'locations' &&
        _selectedLocationIds.length > 1) {
      final keep = _selectedLocationIds.last;
      _selectedLocationIds
        ..clear()
        ..add(keep);
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;

    return AppFormDialog(
      title: Text(l10n.operatorsEditRole),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Modifica il ruolo di ${widget.userName}',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
          ),
          const SizedBox(height: 12),
          TextFormField(
            initialValue: widget.userEmail,
            enabled: false,
            decoration: InputDecoration(
              labelText: l10n.operatorsInviteEmail,
              prefixIcon: const Icon(Icons.email_outlined),
            ),
          ),
          const SizedBox(height: 24),
          _RoleRadioList(
            selectedRole: _selectedRole,
            onChanged: (role) => setState(() {
              _selectedRole = role;
              _enforceSingleLocationForStaff();
            }),
          ),
          // Sezione scope solo se pi√π di una location
          if (widget.locations.length > 1) ...[
            const SizedBox(height: 24),
            const Divider(),
            const SizedBox(height: 16),
            _ScopeTypeSelector(
              selectedScopeType: _selectedScopeType,
              onChanged: (scope) => setState(() {
                _selectedScopeType = scope;
                if (scope == 'business') {
                  _selectedLocationIds.clear();
                }
                _enforceSingleLocationForStaff();
              }),
            ),
            if (_selectedScopeType == 'locations') ...[
              const SizedBox(height: 16),
              _LocationsMultiSelect(
                locations: widget.locations,
                selectedIds: _selectedLocationIds,
                onChanged: (ids) => setState(() {
                  _selectedLocationIds.clear();
                  if (_selectedRole == 'staff') {
                    if (ids.isNotEmpty) {
                      _selectedLocationIds.add(ids.last);
                    }
                  } else {
                    _selectedLocationIds.addAll(ids);
                  }
                }),
              ),
            ],
          ],
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: Text(l10n.actionCancel),
        ),
        FilledButton(
          onPressed: () {
            if (_selectedScopeType == 'locations' &&
                _selectedLocationIds.isEmpty) {
              FeedbackDialog.showError(
                context,
                title: l10n.errorTitle,
                message: l10n.operatorsScopeLocationsRequired,
              );
              return;
            }
            if (_selectedRole == 'staff' &&
                _selectedScopeType == 'locations' &&
                _selectedLocationIds.length > 1) {
              final isIt =
                  Localizations.localeOf(context).languageCode == 'it';
              FeedbackDialog.showError(
                context,
                title: l10n.errorTitle,
                message: isIt
                    ? 'Per il ruolo Staff puoi selezionare una sola sede.'
                    : 'For Staff role you can select only one location.',
              );
              return;
            }
            widget.onSave(
              role: _selectedRole,
              scopeType: _selectedScopeType,
              locationIds: _selectedLocationIds.toList(),
            );
          },
          child: Text(l10n.actionSave),
        ),
      ],
    );
  }
}

/// Bottom sheet per selezionare un ruolo (mobile/tablet).
class RoleSelectionSheet extends StatefulWidget {
  const RoleSelectionSheet({
    super.key,
    required this.currentRole,
    required this.currentScopeType,
    required this.currentLocationIds,
    required this.locations,
    required this.userName,
    required this.userEmail,
    required this.onSave,
  });

  final String currentRole;
  final String currentScopeType;
  final List<int> currentLocationIds;
  final List<Location> locations;
  final String userName;
  final String userEmail;
  final RoleScopeSaveCallback onSave;

  @override
  State<RoleSelectionSheet> createState() => _RoleSelectionSheetState();
}

class _RoleSelectionSheetState extends State<RoleSelectionSheet> {
  late String _selectedRole;
  late String _selectedScopeType;
  late Set<int> _selectedLocationIds;

  @override
  void initState() {
    super.initState();
    _selectedRole = widget.currentRole;
    _selectedScopeType = widget.currentScopeType.isNotEmpty
        ? widget.currentScopeType
        : 'business';
    _selectedLocationIds = widget.currentLocationIds.toSet();
    _enforceSingleLocationForStaff();
  }

  void _enforceSingleLocationForStaff() {
    if (_selectedRole == 'staff' &&
        _selectedScopeType == 'locations' &&
        _selectedLocationIds.length > 1) {
      final keep = _selectedLocationIds.last;
      _selectedLocationIds
        ..clear()
        ..add(keep);
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;

    return SingleChildScrollView(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // Header
          Text(
            l10n.operatorsEditRole,
            style: Theme.of(context).textTheme.titleLarge,
          ),
          const SizedBox(height: 4),
          Text(
            'Modifica il ruolo di ${widget.userName}',
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
          ),
          const SizedBox(height: 12),
          TextFormField(
            initialValue: widget.userEmail,
            enabled: false,
            decoration: InputDecoration(
              labelText: l10n.operatorsInviteEmail,
              prefixIcon: const Icon(Icons.email_outlined),
            ),
          ),
          const SizedBox(height: 16),
          _RoleRadioList(
            selectedRole: _selectedRole,
            onChanged: (role) => setState(() {
              _selectedRole = role;
              _enforceSingleLocationForStaff();
            }),
          ),
          // Sezione scope solo se pi√π di una location
          if (widget.locations.length > 1) ...[
            const SizedBox(height: 24),
            const Divider(),
            const SizedBox(height: 16),
            _ScopeTypeSelector(
              selectedScopeType: _selectedScopeType,
              onChanged: (scope) => setState(() {
                _selectedScopeType = scope;
                if (scope == 'business') {
                  _selectedLocationIds.clear();
                }
                _enforceSingleLocationForStaff();
              }),
            ),
            if (_selectedScopeType == 'locations') ...[
              const SizedBox(height: 16),
              _LocationsMultiSelect(
                locations: widget.locations,
                selectedIds: _selectedLocationIds,
                onChanged: (ids) => setState(() {
                  _selectedLocationIds.clear();
                  if (_selectedRole == 'staff') {
                    if (ids.isNotEmpty) {
                      _selectedLocationIds.add(ids.last);
                    }
                  } else {
                    _selectedLocationIds.addAll(ids);
                  }
                }),
              ),
            ],
          ],
          const SizedBox(height: 16),
          Row(
            children: [
              Expanded(
                child: OutlinedButton(
                  onPressed: () => Navigator.of(context).pop(),
                  child: Text(l10n.actionCancel),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: FilledButton(
                  onPressed: () {
                    if (_selectedScopeType == 'locations' &&
                        _selectedLocationIds.isEmpty) {
                      FeedbackDialog.showError(
                        context,
                        title: l10n.errorTitle,
                        message: l10n.operatorsScopeLocationsRequired,
                      );
                      return;
                    }
                    if (_selectedRole == 'staff' &&
                        _selectedScopeType == 'locations' &&
                        _selectedLocationIds.length > 1) {
                      final isIt =
                          Localizations.localeOf(context).languageCode == 'it';
                      FeedbackDialog.showError(
                        context,
                        title: l10n.errorTitle,
                        message: isIt
                            ? 'Per il ruolo Staff puoi selezionare una sola sede.'
                            : 'For Staff role you can select only one location.',
                      );
                      return;
                    }
                    widget.onSave(
                      role: _selectedRole,
                      scopeType: _selectedScopeType,
                      locationIds: _selectedLocationIds.toList(),
                    );
                  },
                  child: Text(l10n.actionSave),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

/// Lista di radio button per la selezione del ruolo.
class _RoleRadioList extends StatelessWidget {
  const _RoleRadioList({required this.selectedRole, required this.onChanged});

  final String selectedRole;
  final ValueChanged<String> onChanged;

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;

    return Column(
      children: [
        _RoleRadioTile(
          value: 'admin',
          groupValue: selectedRole,
          onChanged: onChanged,
          title: l10n.operatorsRoleAdmin,
          subtitle: l10n.operatorsRoleAdminDesc,
          icon: Icons.admin_panel_settings,
        ),
        _RoleRadioTile(
          value: 'manager',
          groupValue: selectedRole,
          onChanged: onChanged,
          title: l10n.operatorsRoleManager,
          subtitle: l10n.operatorsRoleManagerDesc,
          icon: Icons.manage_accounts,
        ),
        _RoleRadioTile(
          value: 'staff',
          groupValue: selectedRole,
          onChanged: onChanged,
          title: l10n.operatorsRoleStaff,
          subtitle: l10n.operatorsRoleStaffDesc,
          icon: Icons.person,
        ),
        _RoleRadioTile(
          value: 'viewer',
          groupValue: selectedRole,
          onChanged: onChanged,
          title: l10n.operatorsRoleViewer,
          subtitle: l10n.operatorsRoleViewerDesc,
          icon: Icons.visibility_outlined,
        ),
      ],
    );
  }
}

/// Singola riga radio per ruolo.
class _RoleRadioTile extends StatelessWidget {
  const _RoleRadioTile({
    required this.value,
    required this.groupValue,
    required this.onChanged,
    required this.title,
    required this.subtitle,
    required this.icon,
  });

  final String value;
  final String groupValue;
  final ValueChanged<String> onChanged;
  final String title;
  final String subtitle;
  final IconData icon;

  @override
  Widget build(BuildContext context) {
    final isSelected = value == groupValue;
    final colorScheme = Theme.of(context).colorScheme;

    return InkWell(
      onTap: () => onChanged(value),
      borderRadius: BorderRadius.circular(8),
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 8),
        child: Row(
          children: [
            Radio<String>(
              value: value,
              groupValue: groupValue,
              onChanged: (v) => onChanged(v!),
            ),
            Icon(
              icon,
              color: isSelected
                  ? colorScheme.primary
                  : colorScheme.onSurfaceVariant,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    title,
                    style: Theme.of(context).textTheme.titleSmall?.copyWith(
                      fontWeight: isSelected ? FontWeight.w600 : null,
                    ),
                  ),
                  Text(
                    subtitle,
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: colorScheme.onSurfaceVariant,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget per selezionare il tipo di scope (business o locations).
class _ScopeTypeSelector extends StatelessWidget {
  const _ScopeTypeSelector({
    required this.selectedScopeType,
    required this.onChanged,
  });

  final String selectedScopeType;
  final ValueChanged<String> onChanged;

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          l10n.operatorsScopeTitle,
          style: Theme.of(context).textTheme.titleSmall,
        ),
        const SizedBox(height: 8),
        _ScopeOption(
          scopeType: 'business',
          label: l10n.operatorsScopeBusiness,
          description: l10n.operatorsScopeBusinessDesc,
          icon: Icons.business,
          isSelected: selectedScopeType == 'business',
          onTap: () => onChanged('business'),
        ),
        const SizedBox(height: 8),
        _ScopeOption(
          scopeType: 'locations',
          label: l10n.operatorsScopeLocations,
          description: l10n.operatorsScopeLocationsDesc,
          icon: Icons.location_on,
          isSelected: selectedScopeType == 'locations',
          onTap: () => onChanged('locations'),
        ),
      ],
    );
  }
}

/// Singola opzione scope.
class _ScopeOption extends StatelessWidget {
  const _ScopeOption({
    required this.scopeType,
    required this.label,
    required this.description,
    required this.icon,
    required this.isSelected,
    required this.onTap,
  });

  final String scopeType;
  final String label;
  final String description;
  final IconData icon;
  final bool isSelected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: isSelected ? colorScheme.primary : colorScheme.outline,
            width: isSelected ? 2 : 1,
          ),
          color: isSelected
              ? colorScheme.primaryContainer.withOpacity(0.3)
              : null,
        ),
        child: Row(
          children: [
            Icon(
              icon,
              color: isSelected
                  ? colorScheme.primary
                  : colorScheme.onSurfaceVariant,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    label,
                    style: Theme.of(context).textTheme.titleSmall?.copyWith(
                      color: isSelected ? colorScheme.primary : null,
                      fontWeight: isSelected ? FontWeight.w600 : null,
                    ),
                  ),
                  Text(
                    description,
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: colorScheme.onSurfaceVariant,
                    ),
                  ),
                ],
              ),
            ),
            if (isSelected)
              Icon(Icons.check_circle, color: colorScheme.primary),
          ],
        ),
      ),
    );
  }
}

/// Widget per la selezione multipla delle location.
class _LocationsMultiSelect extends StatelessWidget {
  const _LocationsMultiSelect({
    required this.locations,
    required this.selectedIds,
    required this.onChanged,
  });

  final List<Location> locations;
  final Set<int> selectedIds;
  final ValueChanged<Set<int>> onChanged;

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          l10n.operatorsScopeSelectLocations,
          style: Theme.of(context).textTheme.titleSmall,
        ),
        const SizedBox(height: 8),
        Container(
          decoration: BoxDecoration(
            border: Border.all(color: colorScheme.outline),
            borderRadius: BorderRadius.circular(12),
          ),
          child: Column(
            children: [
              for (var i = 0; i < locations.length; i++) ...[
                if (i > 0) const Divider(height: 1),
                _LocationCheckboxTile(
                  location: locations[i],
                  isSelected: selectedIds.contains(locations[i].id),
                  onChanged: (selected) {
                    final newIds = Set<int>.from(selectedIds);
                    if (selected) {
                      newIds.add(locations[i].id);
                    } else {
                      newIds.remove(locations[i].id);
                    }
                    onChanged(newIds);
                  },
                ),
              ],
            ],
          ),
        ),
      ],
    );
  }
}

/// Singola checkbox per location.
class _LocationCheckboxTile extends StatelessWidget {
  const _LocationCheckboxTile({
    required this.location,
    required this.isSelected,
    required this.onChanged,
  });

  final Location location;
  final bool isSelected;
  final ValueChanged<bool> onChanged;

  @override
  Widget build(BuildContext context) {
    return CheckboxListTile(
      value: isSelected,
      onChanged: (value) => onChanged(value ?? false),
      title: Text(location.name),
      subtitle: location.address != null
          ? Text(
              location.address!,
              style: Theme.of(context).textTheme.bodySmall,
            )
          : null,
      secondary: const Icon(Icons.store_outlined),
      controlAffinity: ListTileControlAffinity.trailing,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
    );
  }
}
--- FILE: lib/features/business/presentation/dialogs/edit_business_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/business.dart';
import '../../../../core/network/api_client.dart';
import '../../../../core/widgets/local_loading_overlay.dart';
import '../../providers/business_providers.dart';

/// Dialog per modificare un business esistente (solo superadmin).
class EditBusinessDialog extends ConsumerStatefulWidget {
  const EditBusinessDialog({super.key, required this.business});

  final Business business;

  @override
  ConsumerState<EditBusinessDialog> createState() => _EditBusinessDialogState();
}

class _EditBusinessDialogState extends ConsumerState<EditBusinessDialog> {
  final _formKey = GlobalKey<FormState>();
  late final TextEditingController _nameController;
  late final TextEditingController _slugController;
  late final TextEditingController _emailController;
  late final TextEditingController _phoneController;
  late final TextEditingController _adminEmailController;
  late final TextEditingController _onlineBookingsNotificationEmailController;

  bool _isLoading = false;
  String? _error;
  String _selectedServiceColorPalette = 'legacy';

  @override
  void initState() {
    super.initState();
    _nameController = TextEditingController(text: widget.business.name);
    _slugController = TextEditingController(text: widget.business.slug ?? '');
    _emailController = TextEditingController(text: widget.business.email ?? '');
    _phoneController = TextEditingController(text: widget.business.phone ?? '');
    _adminEmailController = TextEditingController(
      text: widget.business.adminEmail ?? '',
    );
    _onlineBookingsNotificationEmailController = TextEditingController(
      text: widget.business.onlineBookingsNotificationEmail ?? '',
    );
    _selectedServiceColorPalette = widget.business.serviceColorPalette;
  }

  @override
  void dispose() {
    _nameController.dispose();
    _slugController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    _adminEmailController.dispose();
    _onlineBookingsNotificationEmailController.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      final repository = ref.read(businessRepositoryProvider);

      // Determina se admin email √® cambiata
      final newAdminEmail = _adminEmailController.text.trim();
      final oldAdminEmail = widget.business.adminEmail ?? '';
      final adminEmailChanged =
          newAdminEmail.isNotEmpty &&
          newAdminEmail.toLowerCase() != oldAdminEmail.toLowerCase();

      // Determina se email notifiche √® cambiata (vuoto => clear)
      final newNotifyEmail = _onlineBookingsNotificationEmailController.text
          .trim();
      final oldNotifyEmail =
          widget.business.onlineBookingsNotificationEmail ?? '';
      final notifyEmailChanged =
          newNotifyEmail.toLowerCase() != oldNotifyEmail.toLowerCase();
      final paletteChanged =
          _selectedServiceColorPalette != widget.business.serviceColorPalette;

      await repository.updateBusiness(
        businessId: widget.business.id,
        name: _nameController.text.trim(),
        slug: _slugController.text.trim(),
        email: _emailController.text.trim().isEmpty
            ? null
            : _emailController.text.trim(),
        // Se l'utente svuota il campo, inviamo stringa vuota per permettere al backend di resettare a NULL.
        onlineBookingsNotificationEmail: notifyEmailChanged
            ? newNotifyEmail
            : null,
        serviceColorPalette: paletteChanged
            ? _selectedServiceColorPalette
            : null,
        phone: _phoneController.text.trim().isEmpty
            ? null
            : _phoneController.text.trim(),
        adminEmail: adminEmailChanged ? newAdminEmail : null,
      );

      if (mounted) {
        Navigator.of(context).pop(true);
      }
    } on ApiException catch (e) {
      setState(() {
        _error = e.message;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return AlertDialog(
      title: const Text('Modifica Business'),
      content: SizedBox(
        width: 400,
        child: LocalLoadingOverlay(
          isLoading: _isLoading,
          child: Form(
            key: _formKey,
            child: SingleChildScrollView(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  if (_error != null) ...[
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: colorScheme.errorContainer,
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Row(
                        children: [
                          Icon(
                            Icons.error_outline,
                            color: colorScheme.onErrorContainer,
                            size: 20,
                          ),
                          const SizedBox(width: 8),
                          Expanded(
                            child: Text(
                              _error!,
                              style: TextStyle(
                                color: colorScheme.onErrorContainer,
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(height: 16),
                  ],

                  // Nome business
                  TextFormField(
                    controller: _nameController,
                    decoration: const InputDecoration(
                      labelText: 'Nome Business *',
                      hintText: 'es. Salone Maria',
                      prefixIcon: Icon(Icons.business),
                    ),
                    textCapitalization: TextCapitalization.words,
                    validator: (value) {
                      if (value == null || value.trim().isEmpty) {
                        return l10n.authRequiredField;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // Slug
                  TextFormField(
                    controller: _slugController,
                    decoration: const InputDecoration(
                      labelText: 'Slug URL *',
                      hintText: 'es. salone-maria',
                      prefixIcon: Icon(Icons.link),
                      helperText: 'Usato per URL pubblico',
                    ),
                    validator: (value) {
                      if (value == null || value.trim().isEmpty) {
                        return l10n.authRequiredField;
                      }
                      // Validate slug format
                      final slugRegex = RegExp(r'^[a-z0-9-]+$');
                      if (!slugRegex.hasMatch(value.trim())) {
                        return 'Solo lettere minuscole, numeri e trattini';
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // Email
                  TextFormField(
                    controller: _emailController,
                    decoration: const InputDecoration(
                      labelText: 'Email',
                      hintText: 'es. info@salone.it',
                      prefixIcon: Icon(Icons.email_outlined),
                    ),
                    keyboardType: TextInputType.emailAddress,
                    validator: (value) {
                      if (value != null && value.trim().isNotEmpty) {
                        final emailRegex = RegExp(
                          r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                        );
                        if (!emailRegex.hasMatch(value.trim())) {
                          return l10n.authInvalidEmail;
                        }
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                  // Email notifiche prenotazioni online
                  TextFormField(
                    controller: _onlineBookingsNotificationEmailController,
                    decoration: InputDecoration(
                      labelText:
                          l10n.businessOnlineBookingsNotificationEmailLabel,
                      hintText:
                          l10n.businessOnlineBookingsNotificationEmailHint,
                      prefixIcon: const Icon(Icons.notifications_outlined),
                      helperText:
                          l10n.businessOnlineBookingsNotificationEmailHelper,
                    ),
                    keyboardType: TextInputType.emailAddress,
                    validator: (value) {
                      if (value != null && value.trim().isNotEmpty) {
                        final emailRegex = RegExp(
                          r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                        );
                        if (!emailRegex.hasMatch(value.trim())) {
                          return l10n.authInvalidEmail;
                        }
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                  DropdownButtonFormField<String>(
                    value: _selectedServiceColorPalette,
                    decoration: InputDecoration(
                      labelText: l10n.businessServiceColorPaletteLabel,
                      helperText: l10n.businessServiceColorPaletteHelper,
                      prefixIcon: const Icon(Icons.palette_outlined),
                    ),
                    items: [
                      DropdownMenuItem(
                        value: 'enhanced',
                        child: Text(l10n.businessServiceColorPaletteEnhanced),
                      ),
                      DropdownMenuItem(
                        value: 'legacy',
                        child: Text(l10n.businessServiceColorPaletteLegacy),
                      ),
                    ],
                    onChanged: (value) {
                      if (value == null) return;
                      setState(() => _selectedServiceColorPalette = value);
                    },
                  ),
                  const SizedBox(height: 16),

                  // Telefono
                  TextFormField(
                    controller: _phoneController,
                    decoration: const InputDecoration(
                      labelText: 'Telefono',
                      hintText: 'es. +39 333 1234567',
                      prefixIcon: Icon(Icons.phone_outlined),
                    ),
                    keyboardType: TextInputType.phone,
                  ),
                  const SizedBox(height: 24),

                  const SizedBox(height: 8),
                  Text(
                    'Amministratore',
                    style: theme.textTheme.titleSmall?.copyWith(
                      color: colorScheme.primary,
                    ),
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Cambiando l\'email admin, verr√† inviato un invito al nuovo amministratore.',
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: colorScheme.onSurfaceVariant,
                    ),
                  ),
                  const SizedBox(height: 12),

                  // Email Admin (opzionale)
                  TextFormField(
                    controller: _adminEmailController,
                    decoration: InputDecoration(
                      labelText: 'Email Admin',
                      hintText: 'es. admin@salone.it',
                      prefixIcon: const Icon(Icons.admin_panel_settings),
                      helperText: widget.business.adminEmail != null
                          ? 'Attuale: ${widget.business.adminEmail}'
                          : 'Opzionale: ricever√† email per configurare account',
                    ),
                    keyboardType: TextInputType.emailAddress,
                    validator: (value) {
                      // Solo valida se inserito
                      if (value != null && value.trim().isNotEmpty) {
                        final emailRegex = RegExp(
                          r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                        );
                        if (!emailRegex.hasMatch(value.trim())) {
                          return l10n.authInvalidEmail;
                        }
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),
                ],
              ),
            ),
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(false),
          child: Text(l10n.actionCancel),
        ),
        FilledButton(
          onPressed: _isLoading ? null : _submit,
          child: const Text('Salva'),
        ),
      ],
    );
  }
}

/// Mostra il dialog per modificare un business.
/// Ritorna `true` se il business √® stato modificato, `false` altrimenti.
Future<bool?> showEditBusinessDialog(BuildContext context, Business business) {
  return showDialog<bool>(
    context: context,
    builder: (context) => EditBusinessDialog(business: business),
  );
}
--- FILE: lib/features/business/presentation/dialogs/location_closure_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '/core/l10n/l10_extension.dart';
import '/core/models/location_closure.dart';
import '/core/widgets/app_buttons.dart';
import '/core/widgets/feedback_dialog.dart';
import '/features/agenda/providers/location_providers.dart';
import '/features/business/providers/location_closures_provider.dart';

/// Dialog per creare o modificare una chiusura (multi-location)
class LocationClosureDialog extends ConsumerStatefulWidget {
  final LocationClosure? closure;

  const LocationClosureDialog({super.key, this.closure});

  static Future<bool?> show(BuildContext context, {LocationClosure? closure}) {
    return showDialog<bool>(
      context: context,
      builder: (_) => LocationClosureDialog(closure: closure),
    );
  }

  @override
  ConsumerState<LocationClosureDialog> createState() =>
      _LocationClosureDialogState();
}

class _LocationClosureDialogState extends ConsumerState<LocationClosureDialog> {
  final _formKey = GlobalKey<FormState>();
  late TextEditingController _reasonController;

  late DateTime _startDate;
  late DateTime _endDate;
  late Set<int> _selectedLocationIds;
  bool _isSaving = false;

  bool get isEditing => widget.closure != null;

  @override
  void initState() {
    super.initState();
    final now = DateTime.now();
    _startDate =
        widget.closure?.startDate ?? DateTime(now.year, now.month, now.day);
    _endDate =
        widget.closure?.endDate ?? DateTime(now.year, now.month, now.day);
    _reasonController = TextEditingController(
      text: widget.closure?.reason ?? '',
    );

    // Initialize selected locations from existing closure or empty
    _selectedLocationIds = widget.closure?.locationIds.toSet() ?? {};
    // Auto-select single location will be done in build() after we have the locations list
  }

  @override
  void dispose() {
    _reasonController.dispose();
    super.dispose();
  }

  Future<void> _selectStartDate() async {
    final picked = await _showAutoCloseDatePicker(
      initialDate: _startDate,
      firstDate: DateTime.now().subtract(const Duration(days: 365)),
      lastDate: DateTime.now().add(const Duration(days: 365 * 3)),
    );
    if (picked != null && mounted) {
      setState(() {
        _startDate = picked;
        // Se la data fine √® prima della nuova data inizio, aggiornala
        if (_endDate.isBefore(_startDate)) {
          _endDate = _startDate;
        }
      });
    }
  }

  Future<void> _selectEndDate() async {
    final picked = await _showAutoCloseDatePicker(
      initialDate: _endDate.isBefore(_startDate) ? _startDate : _endDate,
      firstDate: _startDate,
      lastDate: DateTime.now().add(const Duration(days: 365 * 3)),
    );
    if (picked != null && mounted) {
      setState(() {
        _endDate = picked;
      });
    }
  }

  /// Mostra un date picker che si chiude automaticamente alla selezione
  Future<DateTime?> _showAutoCloseDatePicker({
    required DateTime initialDate,
    required DateTime firstDate,
    required DateTime lastDate,
  }) {
    return showDialog<DateTime>(
      context: context,
      builder: (context) => _AutoCloseDatePickerDialog(
        initialDate: initialDate,
        firstDate: firstDate,
        lastDate: lastDate,
      ),
    );
  }

  void _toggleLocation(int locationId) {
    setState(() {
      if (_selectedLocationIds.contains(locationId)) {
        _selectedLocationIds.remove(locationId);
      } else {
        _selectedLocationIds.add(locationId);
      }
    });
  }

  void _selectAllLocations(List<int> allLocationIds) {
    setState(() {
      _selectedLocationIds = allLocationIds.toSet();
    });
  }

  void _deselectAllLocations() {
    setState(() {
      _selectedLocationIds.clear();
    });
  }

  Future<void> _onSave() async {
    if (!_formKey.currentState!.validate()) return;

    // Validazione date
    if (_endDate.isBefore(_startDate)) {
      FeedbackDialog.showError(
        context,
        title: context.l10n.errorTitle,
        message: context.l10n.closuresInvalidDateRange,
      );
      return;
    }

    // Validazione location
    if (_selectedLocationIds.isEmpty) {
      FeedbackDialog.showError(
        context,
        title: context.l10n.errorTitle,
        message: context.l10n.closuresSelectAtLeastOneLocation,
      );
      return;
    }

    setState(() => _isSaving = true);

    try {
      final notifier = ref.read(locationClosuresProvider.notifier);

      if (isEditing) {
        await notifier.updateClosure(
          closureId: widget.closure!.id,
          locationIds: _selectedLocationIds.toList(),
          startDate: _startDate,
          endDate: _endDate,
          reason: _reasonController.text.trim().isEmpty
              ? null
              : _reasonController.text.trim(),
        );
      } else {
        await notifier.addClosure(
          locationIds: _selectedLocationIds.toList(),
          startDate: _startDate,
          endDate: _endDate,
          reason: _reasonController.text.trim().isEmpty
              ? null
              : _reasonController.text.trim(),
        );
      }

      if (mounted) {
        Navigator.of(context).pop(true);
      }
    } catch (e) {
      if (mounted) {
        String errorMessage = e.toString();
        // Gestisci errore overlap
        if (errorMessage.contains('409') ||
            errorMessage.toLowerCase().contains('overlap')) {
          errorMessage = context.l10n.closuresOverlapError;
        }
        FeedbackDialog.showError(
          context,
          title: context.l10n.errorTitle,
          message: errorMessage,
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isSaving = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final dateFormat = DateFormat.yMMMd(
      Localizations.localeOf(context).languageCode,
    );
    final locations = ref.watch(locationsProvider);
    final hasMultipleLocations = locations.length > 1;

    // Auto-select single location for new closures
    if (!isEditing && locations.length == 1 && _selectedLocationIds.isEmpty) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted && _selectedLocationIds.isEmpty) {
          setState(() {
            _selectedLocationIds.add(locations.first.id);
          });
        }
      });
    }

    final durationDays = _endDate.difference(_startDate).inDays + 1;

    // Build location selection widget (only if multiple locations)
    Widget? locationSelectionWidget;
    if (locations.isEmpty) {
      locationSelectionWidget = Padding(
        padding: const EdgeInsets.symmetric(vertical: 16),
        child: Text(
          l10n.closuresNoLocations,
          style: theme.textTheme.bodyMedium?.copyWith(
            color: theme.colorScheme.outline,
          ),
        ),
      );
    } else if (hasMultipleLocations) {
      final allLocationIds = locations.map((l) => l.id).toList();
      final allSelected = _selectedLocationIds.length == locations.length;

      locationSelectionWidget = Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header with select all/none
          Row(
            children: [
              Icon(
                Icons.location_on,
                size: 20,
                color: theme.colorScheme.primary,
              ),
              const SizedBox(width: 8),
              Text(
                l10n.closuresLocations,
                style: theme.textTheme.titleSmall?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
              ),
              const Spacer(),
              TextButton(
                onPressed: allSelected
                    ? _deselectAllLocations
                    : () => _selectAllLocations(allLocationIds),
                child: Text(
                  allSelected
                      ? l10n.closuresDeselectAll
                      : l10n.closuresSelectAll,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),

          // Location checkboxes
          Container(
            decoration: BoxDecoration(
              border: Border.all(
                color: _selectedLocationIds.isEmpty
                    ? theme.colorScheme.error
                    : theme.colorScheme.outlineVariant,
              ),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Column(
              children: locations.map((location) {
                final isSelected = _selectedLocationIds.contains(location.id);
                return CheckboxListTile(
                  title: Text(location.name),
                  subtitle: (location.address?.isNotEmpty ?? false)
                      ? Text(
                          location.address!,
                          style: theme.textTheme.bodySmall,
                        )
                      : null,
                  value: isSelected,
                  onChanged: (_) => _toggleLocation(location.id),
                  dense: true,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                );
              }).toList(),
            ),
          ),

          if (_selectedLocationIds.isEmpty)
            Padding(
              padding: const EdgeInsets.only(top: 8, left: 12),
              child: Text(
                l10n.closuresSelectAtLeastOneLocation,
                style: theme.textTheme.bodySmall?.copyWith(
                  color: theme.colorScheme.error,
                ),
              ),
            ),
        ],
      );
    }

    return AlertDialog(
      title: Text(isEditing ? l10n.closuresEditTitle : l10n.closuresNewTitle),
      content: SizedBox(
        width: 450,
        child: Form(
          key: _formKey,
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Date picker row
                Row(
                  children: [
                    Expanded(
                      child: _DatePickerField(
                        label: l10n.closuresStartDate,
                        value: _startDate,
                        dateFormat: dateFormat,
                        onTap: _selectStartDate,
                      ),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: _DatePickerField(
                        label: l10n.closuresEndDate,
                        value: _endDate,
                        dateFormat: dateFormat,
                        onTap: _selectEndDate,
                      ),
                    ),
                  ],
                ),

                const SizedBox(height: 8),

                // Duration info
                Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  decoration: BoxDecoration(
                    color: theme.colorScheme.primaryContainer.withOpacity(0.3),
                    borderRadius: BorderRadius.circular(8),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Icon(
                        Icons.calendar_today,
                        size: 16,
                        color: theme.colorScheme.primary,
                      ),
                      const SizedBox(width: 8),
                      Text(
                        l10n.closuresDays(durationDays),
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.primary,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ],
                  ),
                ),

                const SizedBox(height: 24),

                // Location selection (only if multiple locations)
                if (locationSelectionWidget != null) ...[
                  locationSelectionWidget,
                  const SizedBox(height: 24),
                ],

                // Reason field
                TextFormField(
                  controller: _reasonController,
                  decoration: InputDecoration(
                    labelText: l10n.closuresReason,
                    hintText: l10n.closuresReasonHint,
                    border: const OutlineInputBorder(),
                    prefixIcon: const Icon(Icons.notes),
                  ),
                  maxLines: 2,
                  textCapitalization: TextCapitalization.sentences,
                ),
              ],
            ),
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isSaving ? null : () => Navigator.of(context).pop(),
          child: Text(l10n.actionCancel),
        ),
        AppAsyncFilledButton(
          onPressed: _isSaving ? null : _onSave,
          isLoading: _isSaving,
          child: Text(l10n.actionSave),
        ),
      ],
    );
  }
}

class _DatePickerField extends StatelessWidget {
  final String label;
  final DateTime value;
  final DateFormat dateFormat;
  final VoidCallback onTap;

  const _DatePickerField({
    required this.label,
    required this.value,
    required this.dateFormat,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: InputDecorator(
        decoration: InputDecoration(
          labelText: label,
          border: const OutlineInputBorder(),
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 12,
            vertical: 12,
          ),
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(dateFormat.format(value), style: theme.textTheme.bodyLarge),
            Icon(
              Icons.calendar_month,
              color: theme.colorScheme.primary,
              size: 20,
            ),
          ],
        ),
      ),
    );
  }
}

/// Dialog con CalendarDatePicker che si chiude automaticamente alla selezione
class _AutoCloseDatePickerDialog extends StatefulWidget {
  final DateTime initialDate;
  final DateTime firstDate;
  final DateTime lastDate;

  const _AutoCloseDatePickerDialog({
    required this.initialDate,
    required this.firstDate,
    required this.lastDate,
  });

  @override
  State<_AutoCloseDatePickerDialog> createState() =>
      _AutoCloseDatePickerDialogState();
}

class _AutoCloseDatePickerDialogState
    extends State<_AutoCloseDatePickerDialog> {
  late DateTime _selectedDate;

  @override
  void initState() {
    super.initState();
    _selectedDate = widget.initialDate;
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Dialog(
      child: ConstrainedBox(
        constraints: const BoxConstraints(maxWidth: 360),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            CalendarDatePicker(
              initialDate: _selectedDate,
              firstDate: widget.firstDate,
              lastDate: widget.lastDate,
              onDateChanged: (date) {
                // Chiudi il dialog e ritorna la data selezionata
                Navigator.of(context).pop(date);
              },
            ),
            // Pulsante Annulla
            Padding(
              padding: const EdgeInsets.only(bottom: 8, right: 8),
              child: Align(
                alignment: Alignment.centerRight,
                child: TextButton(
                  onPressed: () => Navigator.of(context).pop(),
                  child: Text(
                    MaterialLocalizations.of(context).cancelButtonLabel,
                    style: TextStyle(color: theme.colorScheme.primary),
                  ),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/business/presentation/location_closures_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '/core/l10n/l10_extension.dart';
import '/core/models/location_closure.dart';
import '/core/widgets/feedback_dialog.dart';
import '/features/agenda/providers/location_providers.dart';
import '/features/business/providers/closures_filter_provider.dart';
import '/features/business/providers/location_closures_provider.dart';
import '/features/business/widgets/closures_header.dart';
import 'dialogs/location_closure_dialog.dart' show LocationClosureDialog;

/// Schermata per gestire le chiusure della sede.
class LocationClosuresScreen extends ConsumerStatefulWidget {
  const LocationClosuresScreen({super.key});

  @override
  ConsumerState<LocationClosuresScreen> createState() =>
      _LocationClosuresScreenState();
}

class _LocationClosuresScreenState
    extends ConsumerState<LocationClosuresScreen> {
  @override
  void initState() {
    super.initState();
    // Refresh al caricamento
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.invalidate(locationClosuresProvider);
    });
  }

  Future<void> _deleteClosure(LocationClosure closure) async {
    final l10n = context.l10n;

    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.closuresDeleteConfirm),
        content: Text(l10n.closuresDeleteConfirmMessage),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: Text(l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: FilledButton.styleFrom(
              backgroundColor: Theme.of(context).colorScheme.error,
            ),
            child: Text(l10n.actionDelete),
          ),
        ],
      ),
    );

    if (confirmed == true && mounted) {
      try {
        await ref
            .read(locationClosuresProvider.notifier)
            .deleteClosure(closure.id);
      } catch (e) {
        if (mounted) {
          FeedbackDialog.showError(
            context,
            title: l10n.errorTitle,
            message: e.toString(),
          );
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final closuresAsync = ref.watch(locationClosuresProvider);
    final filterState = ref.watch(closuresFilterProvider);

    return Column(
      children: [
        // Header with period controls (closures-specific)
        const ClosuresHeader(),

        // Content
        Expanded(
          child: closuresAsync.when(
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (error, _) => Center(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(Icons.error_outline, size: 48, color: colorScheme.error),
                  const SizedBox(height: 16),
                  Text(error.toString()),
                  const SizedBox(height: 16),
                  FilledButton(
                    onPressed: () => ref.invalidate(locationClosuresProvider),
                    child: Text(l10n.actionRetry),
                  ),
                ],
              ),
            ),
            data: (closures) {
              // Filtra per range di date
              final filteredClosures = closures.where((c) {
                // Una chiusura √® nel range se si sovrappone con il periodo filtro
                return !c.endDate.isBefore(filterState.startDate) &&
                    !c.startDate.isAfter(filterState.endDate);
              }).toList();

              if (filteredClosures.isEmpty) {
                return _buildEmptyState(context);
              }
              return _buildClosuresList(context, filteredClosures);
            },
          ),
        ),
      ],
    );
  }

  Widget _buildEmptyState(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final filterState = ref.watch(closuresFilterProvider);
    final isAllSelected = filterState.selectedPreset == 'all';

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.event_busy, size: 80, color: theme.colorScheme.outline),
            const SizedBox(height: 24),
            Text(
              isAllSelected ? l10n.closuresEmpty : l10n.closuresEmptyForPeriod,
              style: theme.textTheme.titleLarge?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              l10n.closuresEmptyHint,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.outline,
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildClosuresList(
    BuildContext context,
    List<LocationClosure> closures,
  ) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final today = DateTime.now();
    final todayOnly = DateTime(today.year, today.month, today.day);

    // Separa chiusure future e passate
    final futureClosures = closures
        .where((c) => !c.endDate.isBefore(todayOnly))
        .toList();
    final pastClosures = closures
        .where((c) => c.endDate.isBefore(todayOnly))
        .toList();

    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        // Chiusure future/in corso
        if (futureClosures.isNotEmpty) ...[
          _SectionHeader(
            title: l10n.closuresUpcoming,
            totalDays: futureClosures.fold<int>(
              0,
              (sum, c) => sum + c.durationDays,
            ),
            icon: Icons.event,
            color: theme.colorScheme.primary,
          ),
          const SizedBox(height: 8),
          ...futureClosures.map(
            (c) => _ClosureCard(
              closure: c,
              isActive: c.containsDate(todayOnly),
              onEdit: () => LocationClosureDialog.show(context, closure: c),
              onDelete: () => _deleteClosure(c),
            ),
          ),
        ],

        // Chiusure precedenti
        if (pastClosures.isNotEmpty) ...[
          if (futureClosures.isNotEmpty) const SizedBox(height: 24),
          _SectionHeader(
            title: l10n.closuresPast,
            totalDays: pastClosures.fold<int>(
              0,
              (sum, c) => sum + c.durationDays,
            ),
            icon: Icons.history,
            color: theme.colorScheme.outline,
          ),
          const SizedBox(height: 8),
          ...pastClosures.map(
            (c) => _ClosureCard(
              closure: c,
              isPast: true,
              onEdit: () => LocationClosureDialog.show(context, closure: c),
              onDelete: () => _deleteClosure(c),
            ),
          ),
        ],

        // Padding per FAB
        const SizedBox(height: 80),
      ],
    );
  }
}

class _SectionHeader extends StatelessWidget {
  final String title;
  final int totalDays;
  final IconData icon;
  final Color color;

  const _SectionHeader({
    required this.title,
    required this.totalDays,
    required this.icon,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 8),
      child: Row(
        children: [
          Icon(icon, size: 20, color: color),
          const SizedBox(width: 8),
          Text(
            title,
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.w600,
              color: color,
            ),
          ),
          const SizedBox(width: 8),
          Text(
            l10n.closuresTotalDays(totalDays),
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.colorScheme.outline,
            ),
          ),
        ],
      ),
    );
  }
}

class _ClosureCard extends ConsumerWidget {
  final LocationClosure closure;
  final bool isPast;
  final bool isActive;
  final VoidCallback onEdit;
  final VoidCallback onDelete;

  const _ClosureCard({
    required this.closure,
    this.isPast = false,
    this.isActive = false,
    required this.onEdit,
    required this.onDelete,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final locale = Localizations.localeOf(context).languageCode;
    final dateFormat = DateFormat.yMMMd(locale);

    // Get locations to display their names
    final locations = ref.watch(locationsProvider);

    final isSingleDay =
        closure.startDate.year == closure.endDate.year &&
        closure.startDate.month == closure.endDate.month &&
        closure.startDate.day == closure.endDate.day;

    final cardColor = isPast
        ? theme.colorScheme.surfaceContainerHighest.withOpacity(0.5)
        : null;

    // Build location names string
    String locationNames = '';
    if (locations.isNotEmpty) {
      final names = closure.locationIds
          .map(
            (id) => locations
                .firstWhere((l) => l.id == id, orElse: () => locations.first)
                .name,
          )
          .where((name) => name.isNotEmpty)
          .toList();
      if (names.length == locations.length && locations.length > 1) {
        locationNames = l10n.closuresAllLocations;
      } else {
        locationNames = names.join(', ');
      }
    }

    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      color: cardColor,
      child: InkWell(
        onTap: onEdit,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Date icon/indicator
              Container(
                width: 48,
                height: 48,
                decoration: BoxDecoration(
                  color: isActive
                      ? theme.colorScheme.error
                      : isPast
                      ? theme.colorScheme.outline
                      : theme.colorScheme.primaryContainer,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(
                      closure.startDate.day.toString(),
                      style: theme.textTheme.titleMedium?.copyWith(
                        color: isActive || isPast
                            ? Colors.white
                            : theme.colorScheme.onPrimaryContainer,
                        fontWeight: FontWeight.bold,
                        height: 1,
                      ),
                    ),
                    Text(
                      DateFormat.MMM(
                        locale,
                      ).format(closure.startDate).toUpperCase(),
                      style: theme.textTheme.labelSmall?.copyWith(
                        color:
                            (isActive || isPast
                                    ? Colors.white
                                    : theme.colorScheme.onPrimaryContainer)
                                .withOpacity(0.8),
                        fontSize: 10,
                        height: 1,
                      ),
                    ),
                  ],
                ),
              ),

              const SizedBox(width: 16),

              // Content
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Date range
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            isSingleDay
                                ? dateFormat.format(closure.startDate)
                                : '${dateFormat.format(closure.startDate)} ‚Äî ${dateFormat.format(closure.endDate)}',
                            style: theme.textTheme.titleSmall?.copyWith(
                              fontWeight: FontWeight.w600,
                              color: isPast ? theme.colorScheme.outline : null,
                            ),
                          ),
                        ),
                      ],
                    ),

                    const SizedBox(height: 4),

                    // Duration and reason
                    Row(
                      children: [
                        Icon(
                          Icons.calendar_today,
                          size: 14,
                          color: theme.colorScheme.outline,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          l10n.closuresDays(closure.durationDays),
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: theme.colorScheme.outline,
                          ),
                        ),
                        if (closure.reason != null &&
                            closure.reason!.isNotEmpty) ...[
                          const SizedBox(width: 12),
                          Icon(
                            Icons.notes,
                            size: 14,
                            color: theme.colorScheme.outline,
                          ),
                          const SizedBox(width: 4),
                          Expanded(
                            child: Text(
                              closure.reason!,
                              style: theme.textTheme.bodySmall?.copyWith(
                                color: theme.colorScheme.outline,
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                        ],
                      ],
                    ),

                    // Location names
                    if (locationNames.isNotEmpty) ...[
                      const SizedBox(height: 4),
                      Row(
                        children: [
                          Icon(
                            Icons.location_on,
                            size: 14,
                            color: theme.colorScheme.outline,
                          ),
                          const SizedBox(width: 4),
                          Expanded(
                            child: Text(
                              locationNames,
                              style: theme.textTheme.bodySmall?.copyWith(
                                color: theme.colorScheme.primary,
                                fontWeight: FontWeight.w500,
                              ),
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ],
                ),
              ),

              // Actions
              PopupMenuButton<String>(
                icon: Icon(Icons.more_vert, color: theme.colorScheme.outline),
                onSelected: (value) {
                  if (value == 'edit') {
                    onEdit();
                  } else if (value == 'delete') {
                    onDelete();
                  }
                },
                itemBuilder: (context) => [
                  PopupMenuItem(
                    value: 'edit',
                    child: Row(
                      children: [
                        const Icon(Icons.edit_outlined),
                        const SizedBox(width: 12),
                        Text(l10n.actionEdit),
                      ],
                    ),
                  ),
                  const PopupMenuDivider(),
                  PopupMenuItem(
                    value: 'delete',
                    child: Row(
                      children: [
                        Icon(
                          Icons.delete_outline,
                          color: theme.colorScheme.error,
                        ),
                        const SizedBox(width: 12),
                        Text(
                          l10n.actionDelete,
                          style: TextStyle(color: theme.colorScheme.error),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/business/widgets/closures_header.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '/app/widgets/agenda_control_components.dart';
import '/core/l10n/l10_extension.dart';
import '/core/models/location.dart';
import '/core/models/location_closure.dart';
import '/core/widgets/feedback_dialog.dart';
import '/features/agenda/providers/location_providers.dart';
import '/features/business/domain/public_holidays.dart';
import '/features/business/presentation/dialogs/import_holidays_dialog.dart';
import '../providers/closures_filter_provider.dart';
import '../providers/location_closures_provider.dart';

/// Header widget for Closures screen with period controls.
class ClosuresHeader extends ConsumerWidget {
  const ClosuresHeader({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final l10n = context.l10n;
    final filterState = ref.watch(closuresFilterProvider);
    final filterNotifier = ref.read(closuresFilterProvider.notifier);

    // Location data
    final locations = ref.watch(locationsProvider);
    final currentLocation = ref.watch(currentLocationProvider);
    final showLocationSelector = locations.length > 1;

    // Check if holidays import is available for this country
    final country = currentLocation.country;
    final holidaysAvailable = PublicHolidaysFactory.isSupported(country);

    return Container(
      alignment: Alignment.centerLeft,
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: colorScheme.surface,
        border: Border(
          bottom: BorderSide(color: colorScheme.outline.withOpacity(0.2)),
        ),
      ),
      child: Row(
        children: [
          Expanded(
            child: _ClosuresControls(
              selectedPreset: filterState.selectedPreset,
              startDate: filterState.startDate,
              endDate: filterState.endDate,
              onPresetChanged: (preset) {
                if (preset == 'custom') {
                  _showDateRangePicker(context, ref);
                } else {
                  filterNotifier.applyPreset(preset);
                }
              },
              onDateRangeSelected: () => _showDateRangePicker(context, ref),
              // Location selector props
              showLocationSelector: showLocationSelector,
              locations: locations,
              currentLocation: currentLocation,
              onLocationSelected: (id) {
                ref.read(currentLocationIdProvider.notifier).set(id);
                // Refresh closures after location change
                ref.invalidate(locationClosuresProvider);
              },
            ),
          ),
          // Import holidays button
          if (holidaysAvailable)
            Material(
              color: Colors.transparent,
              child: InkWell(
                onTap: () => _showImportHolidaysDialog(context, ref),
                borderRadius: kAgendaPillRadius,
                child: Container(
                  height: kAgendaControlHeight,
                  padding: const EdgeInsets.symmetric(
                    horizontal: kAgendaControlHorizontalPadding,
                  ),
                  decoration: BoxDecoration(
                    border: Border.all(color: Colors.grey.withOpacity(0.35)),
                    borderRadius: kAgendaPillRadius,
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Icon(
                        Icons.flag_outlined,
                        size: 16,
                        color: colorScheme.primary,
                      ),
                      const SizedBox(width: 8),
                      Text(
                        l10n.closuresImportHolidays,
                        style: theme.textTheme.bodyMedium,
                      ),
                    ],
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }

  Future<void> _showImportHolidaysDialog(
    BuildContext context,
    WidgetRef ref,
  ) async {
    final l10n = context.l10n;
    final locations = ref.read(locationsProvider);
    final closuresAsync = ref.read(locationClosuresProvider);

    final existingClosures = closuresAsync.maybeWhen(
      data: (closures) => closures,
      orElse: () => <LocationClosure>[],
    );

    final count = await ImportHolidaysDialog.show(
      context,
      locations: locations,
      existingClosures: existingClosures,
    );

    if (count != null && count > 0 && context.mounted) {
      await FeedbackDialog.showSuccess(
        context,
        title: l10n.closuresImportHolidaysSuccess(count),
        message: '',
      );
    }
  }

  Future<void> _showDateRangePicker(BuildContext context, WidgetRef ref) async {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final l10n = context.l10n;
    final filterState = ref.read(closuresFilterProvider);

    final picked = await showDateRangePicker(
      context: context,
      firstDate: DateTime(2020),
      lastDate: DateTime.now().add(const Duration(days: 365 * 10)),
      initialDateRange: DateTimeRange(
        start: filterState.startDate,
        end:
            filterState.endDate.isBefore(
              DateTime.now().add(const Duration(days: 365)),
            )
            ? filterState.endDate
            : DateTime.now().add(const Duration(days: 365)),
      ),
      saveText: l10n.actionApply,
      builder: (context, child) {
        return Theme(
          data: theme.copyWith(
            colorScheme: colorScheme.copyWith(
              onPrimary: colorScheme.onPrimary,
              onSurface: colorScheme.onSurface,
            ),
            datePickerTheme: DatePickerThemeData(
              rangeSelectionBackgroundColor: colorScheme.primary.withOpacity(
                0.2,
              ),
              dayForegroundColor: WidgetStateProperty.resolveWith((states) {
                if (states.contains(WidgetState.selected)) {
                  return colorScheme.onPrimary;
                }
                if (states.contains(WidgetState.disabled)) {
                  return colorScheme.onSurface.withOpacity(0.38);
                }
                return colorScheme.onSurface;
              }),
              dayBackgroundColor: WidgetStateProperty.resolveWith((states) {
                if (states.contains(WidgetState.selected)) {
                  return colorScheme.primary;
                }
                return null;
              }),
            ),
          ),
          child: child!,
        );
      },
    );

    if (picked != null) {
      ref
          .read(closuresFilterProvider.notifier)
          .setDateRange(picked.start, picked.end);
    }
  }
}

class _ClosuresControls extends StatelessWidget {
  const _ClosuresControls({
    required this.selectedPreset,
    required this.startDate,
    required this.endDate,
    required this.onPresetChanged,
    required this.onDateRangeSelected,
    required this.showLocationSelector,
    required this.locations,
    required this.currentLocation,
    required this.onLocationSelected,
  });

  final String selectedPreset;
  final DateTime startDate;
  final DateTime endDate;
  final ValueChanged<String> onPresetChanged;
  final VoidCallback onDateRangeSelected;
  final bool showLocationSelector;
  final List<Location> locations;
  final Location currentLocation;
  final void Function(int) onLocationSelected;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final dateFormat = DateFormat('dd/MM/yy');

    // For "from_today", show only start date
    final showEndDate = selectedPreset != 'from_today';

    return Wrap(
      spacing: 12,
      runSpacing: 8,
      crossAxisAlignment: WrapCrossAlignment.center,
      children: [
        // Location selector only if multiple locations
        if (showLocationSelector)
          AgendaLocationSelector(
            locations: locations,
            current: currentLocation,
            onSelected: onLocationSelected,
          ),
        // Preset dropdown
        _PresetDropdown(value: selectedPreset, onChanged: onPresetChanged),

        // Date range display - only show when not "from_today"
        if (selectedPreset == 'custom' ||
            selectedPreset == 'year' ||
            selectedPreset == 'last_year')
          Material(
            color: Colors.transparent,
            child: InkWell(
              onTap: onDateRangeSelected,
              borderRadius: kAgendaPillRadius,
              child: Container(
                height: kAgendaControlHeight,
                padding: const EdgeInsets.symmetric(
                  horizontal: kAgendaControlHorizontalPadding,
                ),
                decoration: BoxDecoration(
                  border: Border.all(color: Colors.grey.withOpacity(0.35)),
                  borderRadius: kAgendaPillRadius,
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      Icons.calendar_today,
                      size: 16,
                      color: colorScheme.primary,
                    ),
                    const SizedBox(width: 8),
                    Text(
                      showEndDate
                          ? '${dateFormat.format(startDate)} - ${dateFormat.format(endDate)}'
                          : dateFormat.format(startDate),
                      style: theme.textTheme.bodyMedium,
                    ),
                  ],
                ),
              ),
            ),
          ),
      ],
    );
  }
}

class _PresetDropdown extends StatelessWidget {
  const _PresetDropdown({required this.value, required this.onChanged});

  final String value;
  final ValueChanged<String> onChanged;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    return Container(
      height: kAgendaControlHeight,
      padding: const EdgeInsets.symmetric(
        horizontal: kAgendaControlHorizontalPadding,
      ),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.grey.withOpacity(0.35)),
        borderRadius: kAgendaPillRadius,
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: value,
          isDense: true,
          icon: const Icon(Icons.arrow_drop_down),
          style: theme.textTheme.bodyMedium,
          onChanged: (v) {
            if (v != null) onChanged(v);
          },
          items: [
            DropdownMenuItem(
              value: 'custom',
              child: Text(l10n.reportsPresetCustom),
            ),
            DropdownMenuItem(
              value: 'from_today',
              child: Text(l10n.closuresFilterFromToday),
            ),
            DropdownMenuItem(
              value: 'year',
              child: Text(l10n.reportsPresetYear),
            ),
            DropdownMenuItem(
              value: 'last_year',
              child: Text(l10n.reportsPresetLastYear),
            ),
            DropdownMenuItem(value: 'all', child: Text(l10n.closuresFilterAll)),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking_notifications/providers/booking_notifications_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/models/booking_notification_item.dart';
import '/core/network/network_providers.dart';

class BookingNotificationsFilters {
  final String? search;
  final List<String>? status;
  final List<String>? channels;
  final String sortBy;
  final String sortOrder;

  const BookingNotificationsFilters({
    this.search,
    this.status,
    this.channels,
    this.sortBy = 'created',
    this.sortOrder = 'desc',
  });

  BookingNotificationsFilters copyWith({
    String? search,
    bool clearSearch = false,
    List<String>? status,
    bool clearStatus = false,
    List<String>? channels,
    bool clearChannels = false,
    String? sortBy,
    String? sortOrder,
  }) {
    return BookingNotificationsFilters(
      search: clearSearch ? null : (search ?? this.search),
      status: clearStatus ? null : (status ?? this.status),
      channels: clearChannels ? null : (channels ?? this.channels),
      sortBy: sortBy ?? this.sortBy,
      sortOrder: sortOrder ?? this.sortOrder,
    );
  }
}

final bookingNotificationsFiltersProvider =
    NotifierProvider<
      BookingNotificationsFiltersNotifier,
      BookingNotificationsFilters
    >(BookingNotificationsFiltersNotifier.new);

class BookingNotificationsFiltersNotifier
    extends Notifier<BookingNotificationsFilters> {
  @override
  BookingNotificationsFilters build() => const BookingNotificationsFilters();

  void setSearch(String? search) {
    state = state.copyWith(
      search: search,
      clearSearch: search == null || search.isEmpty,
    );
  }

  void setStatus(List<String>? status) {
    state = state.copyWith(
      status: status,
      clearStatus: status == null || status.isEmpty,
    );
  }

  void setChannels(List<String>? channels) {
    state = state.copyWith(
      channels: channels,
      clearChannels: channels == null || channels.isEmpty,
    );
  }

  void setSortBy(String sortBy) {
    state = state.copyWith(sortBy: sortBy);
  }

  void toggleSortOrder() {
    state = state.copyWith(
      sortOrder: state.sortOrder == 'asc' ? 'desc' : 'asc',
    );
  }

  void reset() {
    state = const BookingNotificationsFilters();
  }
}

class BookingNotificationsState {
  final List<BookingNotificationItem> notifications;
  final int total;
  final int offset;
  final int limit;
  final bool isLoading;
  final bool isLoadingMore;
  final String? error;

  const BookingNotificationsState({
    this.notifications = const [],
    this.total = 0,
    this.offset = 0,
    this.limit = 50,
    this.isLoading = false,
    this.isLoadingMore = false,
    this.error,
  });

  bool get hasMore => offset + notifications.length < total;
  bool get isEmpty => notifications.isEmpty && !isLoading;

  BookingNotificationsState copyWith({
    List<BookingNotificationItem>? notifications,
    int? total,
    int? offset,
    int? limit,
    bool? isLoading,
    bool? isLoadingMore,
    String? error,
    bool clearError = false,
  }) {
    return BookingNotificationsState(
      notifications: notifications ?? this.notifications,
      total: total ?? this.total,
      offset: offset ?? this.offset,
      limit: limit ?? this.limit,
      isLoading: isLoading ?? this.isLoading,
      isLoadingMore: isLoadingMore ?? this.isLoadingMore,
      error: clearError ? null : (error ?? this.error),
    );
  }
}

final bookingNotificationsProvider =
    NotifierProvider<BookingNotificationsNotifier, BookingNotificationsState>(
      BookingNotificationsNotifier.new,
    );

class BookingNotificationsNotifier extends Notifier<BookingNotificationsState> {
  @override
  BookingNotificationsState build() => const BookingNotificationsState();

  Future<void> loadNotifications(int businessId) async {
    final filters = ref.read(bookingNotificationsFiltersProvider);
    state = state.copyWith(isLoading: true, clearError: true);

    try {
      final apiClient = ref.read(apiClientProvider);
      final response = await apiClient.getBookingNotifications(
        businessId: businessId,
        search: filters.search,
        status: filters.status,
        channels: filters.channels,
        sortBy: filters.sortBy,
        sortOrder: filters.sortOrder,
        limit: state.limit,
        offset: 0,
      );

      final result = BookingNotificationsResult.fromJson(response);
      state = state.copyWith(
        notifications: result.notifications,
        total: result.total,
        offset: 0,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }

  Future<void> loadMore(int businessId) async {
    if (state.isLoadingMore || !state.hasMore) return;

    final filters = ref.read(bookingNotificationsFiltersProvider);
    state = state.copyWith(isLoadingMore: true);

    try {
      final apiClient = ref.read(apiClientProvider);
      final newOffset = state.offset + state.limit;
      final response = await apiClient.getBookingNotifications(
        businessId: businessId,
        search: filters.search,
        status: filters.status,
        channels: filters.channels,
        sortBy: filters.sortBy,
        sortOrder: filters.sortOrder,
        limit: state.limit,
        offset: newOffset,
      );

      final result = BookingNotificationsResult.fromJson(response);
      state = state.copyWith(
        notifications: [...state.notifications, ...result.notifications],
        total: result.total,
        offset: newOffset,
        isLoadingMore: false,
      );
    } catch (e) {
      state = state.copyWith(isLoadingMore: false, error: e.toString());
    }
  }
}
--- FILE: lib/features/booking_notifications/presentation/booking_notifications_screen.dart ---
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '/app/providers/form_factor_provider.dart';
import '/core/l10n/l10_extension.dart';
import '/core/models/booking_notification_item.dart';
import '/core/widgets/feedback_dialog.dart';
import '/features/agenda/providers/location_providers.dart';
import '/features/booking_notifications/providers/booking_notifications_provider.dart';

class BookingNotificationsScreen extends ConsumerStatefulWidget {
  const BookingNotificationsScreen({super.key});

  @override
  ConsumerState<BookingNotificationsScreen> createState() =>
      _BookingNotificationsScreenState();
}

class _BookingNotificationsScreenState
    extends ConsumerState<BookingNotificationsScreen> {
  final _scrollController = ScrollController();
  final _searchController = TextEditingController();
  Timer? _searchDebounce;
  String? _selectedStatus;
  String? _selectedChannel;

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
    WidgetsBinding.instance.addPostFrameCallback((_) => _loadInitialData());
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _searchController.dispose();
    _searchDebounce?.cancel();
    super.dispose();
  }

  int get _businessId => ref.read(currentLocationProvider).businessId;

  String _formatDateTime(BuildContext context, DateTime? dateTime) {
    if (dateTime == null) return context.l10n.bookingNotificationsNotAvailable;
    final locale = Localizations.localeOf(context).toLanguageTag();
    return DateFormat('dd/MM/yyyy HH:mm', locale).format(dateTime.toLocal());
  }

  void _onScroll() {
    if (_scrollController.position.pixels >=
        _scrollController.position.maxScrollExtent - 200) {
      ref.read(bookingNotificationsProvider.notifier).loadMore(_businessId);
    }
  }

  Future<void> _loadInitialData() async {
    await ref
        .read(bookingNotificationsProvider.notifier)
        .loadNotifications(_businessId);
  }

  void _onSearchChanged(String value) {
    ref.read(bookingNotificationsFiltersProvider.notifier).setSearch(value);
    _searchDebounce?.cancel();
    _searchDebounce = Timer(const Duration(milliseconds: 300), () {
      ref
          .read(bookingNotificationsProvider.notifier)
          .loadNotifications(_businessId);
    });
  }

  void _onStatusChanged(String? value) {
    setState(() => _selectedStatus = value);
    ref
        .read(bookingNotificationsFiltersProvider.notifier)
        .setStatus(value == null ? null : [value]);
    ref
        .read(bookingNotificationsProvider.notifier)
        .loadNotifications(_businessId);
  }

  void _onChannelChanged(String? value) {
    setState(() => _selectedChannel = value);
    ref
        .read(bookingNotificationsFiltersProvider.notifier)
        .setChannels(value == null ? null : [value]);
    ref
        .read(bookingNotificationsProvider.notifier)
        .loadNotifications(_businessId);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final state = ref.watch(bookingNotificationsProvider);
    final formFactor = ref.watch(formFactorProvider);
    final isDesktop = formFactor == AppFormFactor.desktop;

    ref.listen<BookingNotificationsState>(bookingNotificationsProvider, (
      prev,
      next,
    ) async {
      if (prev?.error != next.error && next.error != null && mounted) {
        await FeedbackDialog.showError(
          context,
          title: l10n.errorTitle,
          message: next.error!,
        );
      }
    });

    return Scaffold(
      body: Column(
        children: [
          _FiltersBar(
            searchController: _searchController,
            selectedStatus: _selectedStatus,
            selectedChannel: _selectedChannel,
            onSearchChanged: _onSearchChanged,
            onStatusChanged: _onStatusChanged,
            onChannelChanged: _onChannelChanged,
          ),
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 0, 16, 8),
            child: Row(
              children: [
                Text(
                  l10n.bookingNotificationsTotalCount(state.total),
                  style: Theme.of(context).textTheme.bodyMedium,
                ),
              ],
            ),
          ),
          Expanded(child: _buildContent(state, isDesktop: isDesktop)),
        ],
      ),
    );
  }

  Widget _buildContent(
    BookingNotificationsState state, {
    required bool isDesktop,
  }) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    if (state.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (state.error != null) {
      return Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.error_outline, size: 48, color: theme.colorScheme.error),
            const SizedBox(height: 16),
            Text(state.error!),
            const SizedBox(height: 16),
            FilledButton.icon(
              onPressed: _loadInitialData,
              icon: const Icon(Icons.refresh),
              label: Text(l10n.actionRetry),
            ),
          ],
        ),
      );
    }

    if (state.isEmpty) {
      return Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.notifications_off_outlined, size: 64),
            const SizedBox(height: 16),
            Text(
              l10n.bookingNotificationsEmpty,
              style: theme.textTheme.titleMedium,
            ),
            const SizedBox(height: 8),
            Text(
              l10n.bookingNotificationsEmptyHint,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ),
      );
    }

    if (isDesktop) {
      return _buildDataTable(state);
    }
    return _buildCardList(state);
  }

  Widget _buildDataTable(BookingNotificationsState state) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;

    return RefreshIndicator(
      onRefresh: _loadInitialData,
      child: SingleChildScrollView(
        controller: _scrollController,
        child: Column(
          children: [
            SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: Theme(
                data: Theme.of(
                  context,
                ).copyWith(dividerColor: colorScheme.outline.withOpacity(0.2)),
                child: DataTable(
                  dividerThickness: 0.2,
                  horizontalMargin: 16,
                  headingRowColor: WidgetStateProperty.all(
                    colorScheme.surfaceContainerHighest,
                  ),
                  columns: [
                    DataColumn(
                      label: Text(l10n.bookingNotificationsFieldCreatedAt),
                    ),
                    DataColumn(
                      label: Text(l10n.bookingNotificationsFieldSentAt),
                    ),
                    DataColumn(
                      label: Text(l10n.bookingNotificationsFieldClient),
                    ),
                    DataColumn(label: Text(l10n.bookingNotificationsFieldType)),
                    DataColumn(
                      label: Text(l10n.bookingNotificationsFieldRecipient),
                    ),
                    DataColumn(
                      label: Text(l10n.bookingNotificationsFilterStatus),
                    ),
                    DataColumn(
                      label: Text(l10n.bookingNotificationsFieldAppointment),
                    ),
                    DataColumn(
                      label: Text(l10n.bookingNotificationsFieldLocation),
                    ),
                    DataColumn(
                      label: Text(l10n.bookingNotificationsFieldError),
                    ),
                  ],
                  rows: state.notifications.map(_buildDataRow).toList(),
                ),
              ),
            ),
            if (state.isLoadingMore)
              const Padding(
                padding: EdgeInsets.all(16),
                child: CircularProgressIndicator(),
              ),
            if (state.hasMore && !state.isLoadingMore)
              Padding(
                padding: const EdgeInsets.all(16),
                child: OutlinedButton(
                  onPressed: () => ref
                      .read(bookingNotificationsProvider.notifier)
                      .loadMore(_businessId),
                  child: Text(l10n.bookingNotificationsLoadMore),
                ),
              ),
          ],
        ),
      ),
    );
  }

  DataRow _buildDataRow(BookingNotificationItem item) {
    return DataRow(
      cells: [
        DataCell(Text(_formatDateTime(context, item.createdAt))),
        DataCell(Text(item.sentAt != null ? _formatDateTime(context, item.sentAt) : '')),
        DataCell(
          SizedBox(
            width: 180,
            child: Text(
              item.clientName ?? context.l10n.bookingNotificationsNotAvailable,
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ),
        DataCell(
          SizedBox(
            width: 170,
            child: Text(
              item.channelLabel(context),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ),
        DataCell(
          SizedBox(
            width: 220,
            child: Text(
              item.recipientEmail ??
                  context.l10n.bookingNotificationsNotAvailable,
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ),
        DataCell(_NotificationStatusChip(item: item)),
        DataCell(Text(_formatDateTime(context, item.firstStartTime))),
        DataCell(
          SizedBox(
            width: 150,
            child: Text(
              item.locationName ??
                  context.l10n.bookingNotificationsNotAvailable,
              overflow: TextOverflow.ellipsis,
            ),
          ),
        ),
        DataCell(
          SizedBox(
            width: 240,
            child: Text(
              item.errorMessage ?? '-',
              overflow: TextOverflow.ellipsis,
              style: item.errorMessage != null
                  ? TextStyle(color: Theme.of(context).colorScheme.error)
                  : null,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildCardList(BookingNotificationsState state) {
    return RefreshIndicator(
      onRefresh: _loadInitialData,
      child: ListView.builder(
        controller: _scrollController,
        padding: const EdgeInsets.all(8),
        itemCount: state.notifications.length + (state.hasMore ? 1 : 0),
        itemBuilder: (context, index) {
          if (index >= state.notifications.length) {
            return const Center(
              child: Padding(
                padding: EdgeInsets.all(16),
                child: CircularProgressIndicator(),
              ),
            );
          }
          return _NotificationCard(notification: state.notifications[index]);
        },
      ),
    );
  }
}

class _FiltersBar extends StatelessWidget {
  const _FiltersBar({
    required this.searchController,
    required this.selectedStatus,
    required this.selectedChannel,
    required this.onSearchChanged,
    required this.onStatusChanged,
    required this.onChannelChanged,
  });

  final TextEditingController searchController;
  final String? selectedStatus;
  final String? selectedChannel;
  final ValueChanged<String> onSearchChanged;
  final ValueChanged<String?> onStatusChanged;
  final ValueChanged<String?> onChannelChanged;

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;

    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
      child: LayoutBuilder(
        builder: (context, constraints) {
          final availableWidth = constraints.maxWidth;
          final searchWidth = availableWidth < 340 ? availableWidth : 320.0;
          final statusWidth = availableWidth < 240 ? availableWidth : 220.0;
          final typeWidth = availableWidth < 270 ? availableWidth : 250.0;

          return Wrap(
            spacing: 12,
            runSpacing: 12,
            crossAxisAlignment: WrapCrossAlignment.center,
            children: [
              SizedBox(
                width: searchWidth,
                child: TextField(
                  controller: searchController,
                  onChanged: onSearchChanged,
                  decoration: InputDecoration(
                    prefixIcon: const Icon(Icons.search),
                    labelText: l10n.bookingNotificationsSearchLabel,
                    hintText: l10n.bookingNotificationsSearchHint,
                    border: const OutlineInputBorder(),
                    isDense: true,
                  ),
                ),
              ),
              SizedBox(
                width: statusWidth,
                child: DropdownButtonFormField<String?>(
                  value: selectedStatus,
                  isExpanded: true,
                  decoration: InputDecoration(
                    labelText: l10n.bookingNotificationsFilterStatus,
                    border: const OutlineInputBorder(),
                    isDense: true,
                  ),
                  items: [
                    DropdownMenuItem<String?>(
                      value: null,
                      child: Text(
                        l10n.bookingNotificationsStatusAll,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    DropdownMenuItem<String?>(
                      value: 'pending',
                      child: Text(
                        l10n.bookingNotificationsStatusPending,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    DropdownMenuItem<String?>(
                      value: 'processing',
                      child: Text(
                        l10n.bookingNotificationsStatusProcessing,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    DropdownMenuItem<String?>(
                      value: 'sent',
                      child: Text(
                        l10n.bookingNotificationsStatusSent,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    DropdownMenuItem<String?>(
                      value: 'failed',
                      child: Text(
                        l10n.bookingNotificationsStatusFailed,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                  onChanged: onStatusChanged,
                ),
              ),
              SizedBox(
                width: typeWidth,
                child: DropdownButtonFormField<String?>(
                  value: selectedChannel,
                  isExpanded: true,
                  decoration: InputDecoration(
                    labelText: l10n.bookingNotificationsFilterType,
                    border: const OutlineInputBorder(),
                    isDense: true,
                  ),
                  items: [
                    DropdownMenuItem<String?>(
                      value: null,
                      child: Text(
                        l10n.bookingNotificationsTypeAll,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    DropdownMenuItem<String?>(
                      value: 'booking_confirmed',
                      child: Text(
                        l10n.bookingNotificationsChannelConfirmed,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    DropdownMenuItem<String?>(
                      value: 'booking_rescheduled',
                      child: Text(
                        l10n.bookingNotificationsChannelRescheduled,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    DropdownMenuItem<String?>(
                      value: 'booking_cancelled',
                      child: Text(
                        l10n.bookingNotificationsChannelCancelled,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    DropdownMenuItem<String?>(
                      value: 'booking_reminder',
                      child: Text(
                        l10n.bookingNotificationsChannelReminder,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  ],
                  onChanged: onChannelChanged,
                ),
              ),
            ],
          );
        },
      ),
    );
  }
}

class _NotificationCard extends StatelessWidget {
  const _NotificationCard({required this.notification});

  final BookingNotificationItem notification;

  String _formatDateTime(BuildContext context, DateTime? dateTime) {
    if (dateTime == null) return context.l10n.bookingNotificationsNotAvailable;
    final locale = Localizations.localeOf(context).toLanguageTag();
    return DateFormat('dd/MM/yyyy HH:mm', locale).format(dateTime.toLocal());
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: Padding(
        padding: const EdgeInsets.all(14),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Expanded(
                  child: Text(
                    notification.subject?.trim().isNotEmpty == true
                        ? notification.subject!
                        : l10n.bookingNotificationsNoSubject,
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
                _NotificationStatusChip(item: notification),
              ],
            ),
            const SizedBox(height: 8),
            Text(
              '${l10n.bookingNotificationsFieldType}: ${notification.channelLabel(context)}',
              style: theme.textTheme.bodyMedium,
            ),
            if ((notification.clientName ?? '').isNotEmpty)
              Text(
                '${l10n.bookingNotificationsFieldClient}: ${notification.clientName}',
                style: theme.textTheme.bodyMedium,
              ),
            if ((notification.locationName ?? '').isNotEmpty)
              Text(
                '${l10n.bookingNotificationsFieldLocation}: ${notification.locationName}',
                style: theme.textTheme.bodyMedium,
              ),
            if (notification.firstStartTime != null)
              Text(
                '${l10n.bookingNotificationsFieldAppointment}: ${_formatDateTime(context, notification.firstStartTime)}',
                style: theme.textTheme.bodyMedium,
              ),
            Text(
              '${l10n.bookingNotificationsFieldRecipient}: ${notification.recipientEmail ?? l10n.bookingNotificationsNotAvailable}',
              style: theme.textTheme.bodyMedium,
            ),
            Text(
              '${l10n.bookingNotificationsFieldCreatedAt}: ${_formatDateTime(context, notification.createdAt)}',
              style: theme.textTheme.bodySmall,
            ),
            if (notification.sentAt != null)
              Text(
                '${l10n.bookingNotificationsFieldSentAt}: ${_formatDateTime(context, notification.sentAt)}',
                style: theme.textTheme.bodySmall,
              ),
            if ((notification.errorMessage ?? '').isNotEmpty)
              Padding(
                padding: const EdgeInsets.only(top: 6),
                child: Text(
                  '${l10n.bookingNotificationsFieldError}: ${notification.errorMessage}',
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.error,
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}

class _NotificationStatusChip extends StatelessWidget {
  const _NotificationStatusChip({required this.item});

  final BookingNotificationItem item;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: item.statusColor.withValues(alpha: 0.15),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Text(
        item.statusLabel(context),
        style: theme.textTheme.labelMedium?.copyWith(
          color: item.statusColor,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }
}
--- FILE: lib/features/more/presentation/more_screen.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../app/providers/form_factor_provider.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../auth/providers/current_business_user_provider.dart';

/// Schermata "Altro" con cards per le sezioni secondarie
class MoreScreen extends ConsumerWidget {
  const MoreScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final formFactor = ref.watch(formFactorProvider);
    final isDesktop = formFactor == AppFormFactor.desktop;
    final canManageOperators = ref.watch(canManageOperatorsProvider);
    final canManageSettings = ref.watch(canManageBusinessSettingsProvider);
    final canViewServices = ref.watch(currentUserCanViewServicesProvider);
    final canViewStaff = ref.watch(currentUserCanViewStaffProvider);
    final canViewReports = ref.watch(currentUserCanViewReportsProvider);
    final isSuperadmin = ref.watch(currentBusinessUserContextProvider).when(
      data: (data) => data?.isSuperadmin ?? false,
      loading: () => false,
      error: (_, __) => false,
    );
    final canAccessClassEvents = canViewServices && kDebugMode;

    final items = [
      // Servizi - visibile solo a chi pu√≤ gestire impostazioni
      if (canViewServices)
        _MoreItem(
          icon: Icons.category_outlined,
          title: l10n.navServices,
          description: l10n.moreServicesDescription,
          color: const Color(0xFF4CAF50), // Green
          onTap: () => context.go('/servizi'),
        ),
      // Team - visibile solo a chi pu√≤ gestire impostazioni
      if (canViewStaff)
        _MoreItem(
          icon: Icons.badge_outlined,
          title: l10n.navStaff,
          description: l10n.moreTeamDescription,
          color: const Color(0xFF2196F3), // Blue
          onTap: () => context.go('/staff'),
        ),
      // Permessi - visibile solo a chi pu√≤ gestire operatori
      if (canManageOperators)
        _MoreItem(
          icon: Icons.admin_panel_settings_outlined,
          title: l10n.permissionsTitle,
          description: l10n.permissionsDescription,
          color: const Color(0xFF00BCD4), // Cyan
          onTap: () => context.go('/permessi'),
        ),
      if (canViewReports)
        _MoreItem(
          icon: Icons.bar_chart,
          title: l10n.reportsTitle,
          description: l10n.moreReportsDescription,
          color: const Color(0xFFFF9800), // Orange
          onTap: () => context.go('/report'),
        ),
      _MoreItem(
        icon: Icons.list_alt,
        title: l10n.bookingsListTitle,
        description: l10n.moreBookingsDescription,
        color: const Color(0xFF9C27B0), // Purple
        onTap: () => context.go('/prenotazioni'),
      ),
      if (canAccessClassEvents)
        _MoreItem(
          icon: Icons.groups_outlined,
          title: 'Class events',
          description: 'Manage group sessions and participant waitlists',
          color: const Color(0xFF795548),
          onTap: () => context.go('/altro/classi'),
        ),
      if (isSuperadmin)
        _MoreItem(
          icon: Icons.hub_outlined,
          title: l10n.crmTitle,
          description: l10n.crmSubtitle,
          color: const Color(0xFF009688),
          onTap: () => context.go('/altro/crm'),
        ),
      _MoreItem(
        icon: Icons.notifications_outlined,
        title: l10n.bookingNotificationsTitle,
        description: l10n.moreBookingNotificationsDescription,
        color: const Color(0xFF3F51B5), // Indigo
        onTap: () => context.go('/notifiche-prenotazioni'),
      ),
      // Chiusure - visibile solo a chi pu√≤ gestire impostazioni
      if (canManageSettings)
        _MoreItem(
          icon: Icons.event_busy,
          title: l10n.closuresTitle,
          description: l10n.closuresEmptyHint,
          color: const Color(0xFFE91E63), // Pink
          onTap: () => context.go('/chiusure'),
        ),
      _MoreItem(
        icon: Icons.account_circle_outlined,
        title: l10n.profileTitle,
        description: l10n.moreProfileDescription,
        color: const Color(0xFF607D8B), // Blue Grey
        onTap: () => context.go('/profilo'),
      ),
    ];

    return Scaffold(
      body: SafeArea(
        child: CustomScrollView(
          slivers: [
            // Header
            SliverToBoxAdapter(
              child: Padding(
                padding: EdgeInsets.fromLTRB(
                  isDesktop ? 32 : 20,
                  isDesktop ? 24 : 16,
                  isDesktop ? 32 : 20,
                  isDesktop ? 24 : 20,
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      l10n.navMore,
                      style: theme.textTheme.headlineSmall?.copyWith(
                        fontWeight: FontWeight.w600,
                        color: colorScheme.onSurface,
                      ),
                    ),
                    const SizedBox(height: 6),
                    Text(
                      l10n.moreSubtitle,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ],
                ),
              ),
            ),
            // Lista di cards (layout adattivo)
            SliverPadding(
              padding: EdgeInsets.symmetric(horizontal: isDesktop ? 32 : 16),
              sliver: isDesktop
                  ? _buildDesktopGrid(items, context)
                  : _buildMobileList(items),
            ),
            // Padding in fondo
            const SliverToBoxAdapter(child: SizedBox(height: 32)),
          ],
        ),
      ),
    );
  }

  /// Griglia per desktop (4 colonne)
  Widget _buildDesktopGrid(List<_MoreItem> items, BuildContext context) {
    final screenWidth = MediaQuery.of(context).size.width;
    final crossAxisCount = screenWidth > 1200 ? 4 : (screenWidth > 800 ? 3 : 2);
    final childAspectRatio = crossAxisCount >= 4 ? 1.12 : 1.0;

    return SliverGrid(
      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: crossAxisCount,
        crossAxisSpacing: 16,
        mainAxisSpacing: 16,
        childAspectRatio: childAspectRatio,
      ),
      delegate: SliverChildBuilderDelegate(
        (context, index) => _MoreCardDesktop(item: items[index]),
        childCount: items.length,
      ),
    );
  }

  /// Lista per mobile (cards orizzontali che si adattano al contenuto)
  Widget _buildMobileList(List<_MoreItem> items) {
    return SliverList(
      delegate: SliverChildBuilderDelegate(
        (context, index) => Padding(
          padding: EdgeInsets.only(bottom: index < items.length - 1 ? 12 : 0),
          child: _MoreCardMobile(item: items[index]),
        ),
        childCount: items.length,
      ),
    );
  }
}

class _MoreItem {
  final IconData icon;
  final String title;
  final String description;
  final Color color;
  final VoidCallback onTap;

  const _MoreItem({
    required this.icon,
    required this.title,
    required this.description,
    required this.color,
    required this.onTap,
  });
}

/// Card per desktop (layout verticale con aspect ratio fisso)
class _MoreCardDesktop extends StatefulWidget {
  final _MoreItem item;

  const _MoreCardDesktop({required this.item});

  @override
  State<_MoreCardDesktop> createState() => _MoreCardDesktopState();
}

class _MoreCardDesktopState extends State<_MoreCardDesktop> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final item = widget.item;

    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 200),
        curve: Curves.easeOutCubic,
        transform: Matrix4.identity()..scale(_isHovered ? 1.02 : 1.0),
        child: Card(
          elevation: _isHovered ? 8 : 2,
          shadowColor: item.color.withOpacity(0.3),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(16),
            side: BorderSide(
              color: _isHovered
                  ? item.color.withOpacity(0.5)
                  : colorScheme.outline.withOpacity(0.1),
              width: _isHovered ? 2 : 1,
            ),
          ),
          child: InkWell(
            onTap: item.onTap,
            borderRadius: BorderRadius.circular(16),
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Icona con sfondo colorato
                  Container(
                    width: 52,
                    height: 52,
                    decoration: BoxDecoration(
                      color: item.color.withOpacity(0.12),
                      borderRadius: BorderRadius.circular(14),
                    ),
                    child: Icon(item.icon, size: 26, color: item.color),
                  ),
                  const Spacer(),
                  // Titolo
                  Text(
                    item.title,
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                      color: colorScheme.onSurface,
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 6),
                  // Descrizione (troncata se troppo lunga)
                  Text(
                    item.description,
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: colorScheme.onSurfaceVariant,
                      height: 1.4,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 12),
                  // Freccia di navigazione
                  Align(
                    alignment: Alignment.centerRight,
                    child: Icon(
                      Icons.arrow_forward_rounded,
                      size: 20,
                      color: _isHovered
                          ? item.color
                          : colorScheme.outline.withOpacity(0.5),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

/// Card per mobile (layout orizzontale che si adatta al contenuto)
class _MoreCardMobile extends StatelessWidget {
  final _MoreItem item;

  const _MoreCardMobile({required this.item});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Card(
      elevation: 1,
      shadowColor: item.color.withOpacity(0.2),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(14),
        side: BorderSide(color: colorScheme.outline.withOpacity(0.1), width: 1),
      ),
      child: InkWell(
        onTap: item.onTap,
        borderRadius: BorderRadius.circular(14),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Icona con sfondo colorato
              Container(
                width: 48,
                height: 48,
                decoration: BoxDecoration(
                  color: item.color.withOpacity(0.12),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(item.icon, size: 24, color: item.color),
              ),
              const SizedBox(width: 16),
              // Testo (si espande e si adatta)
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      item.title,
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w600,
                        color: colorScheme.onSurface,
                      ),
                    ),
                    const SizedBox(height: 4),
                    // Descrizione completa (senza limite di righe)
                    Text(
                      item.description,
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: colorScheme.onSurfaceVariant,
                        height: 1.4,
                      ),
                    ),
                  ],
                ),
              ),
              const SizedBox(width: 8),
              // Freccia
              Padding(
                padding: const EdgeInsets.only(top: 12),
                child: Icon(
                  Icons.chevron_right,
                  size: 24,
                  color: colorScheme.outline.withOpacity(0.6),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/class_events/providers/class_events_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/models/class_booking.dart';
import '/core/models/class_event.dart';
import '/core/models/class_type.dart';
import '/core/network/network_providers.dart';
import '../../agenda/providers/business_providers.dart';
import '../../agenda/providers/date_range_provider.dart';
import '../../agenda/providers/location_providers.dart';
import '../data/class_events_repository.dart';

final classEventsRepositoryProvider = Provider<ClassEventsRepository>((ref) {
  return ClassEventsRepository(ref.watch(apiClientProvider));
});

final classEventsRangeProvider = Provider<({DateTime from, DateTime to})>((ref) {
  final date = ref.watch(agendaDateProvider);
  final from = DateTime(date.year, date.month, date.day);
  final to = from.add(const Duration(days: 1));
  return (from: from.toUtc(), to: to.toUtc());
});

class SelectedClassTypeIdNotifier extends Notifier<int?> {
  @override
  int? build() {
    // Reset selected class type when switching business.
    ref.watch(currentBusinessIdProvider);
    return null;
  }

  void set(int? classTypeId) => state = classTypeId;

  void clear() => state = null;
}

final selectedClassTypeIdProvider =
    NotifierProvider<SelectedClassTypeIdNotifier, int?>(
      SelectedClassTypeIdNotifier.new,
    );

final classTypesProvider = FutureProvider<List<ClassType>>((ref) async {
  final businessId = ref.watch(currentBusinessIdProvider);
  if (businessId <= 0) return const [];
  final repo = ref.watch(classEventsRepositoryProvider);
  return repo.listClassTypes(businessId: businessId);
});

final classTypesWithInactiveProvider = FutureProvider<List<ClassType>>((ref) async {
  final businessId = ref.watch(currentBusinessIdProvider);
  if (businessId <= 0) return const [];
  final repo = ref.watch(classEventsRepositoryProvider);
  return repo.listClassTypes(businessId: businessId, includeInactive: true);
});

final classEventsProvider = FutureProvider<List<ClassEvent>>((ref) async {
  final businessId = ref.watch(currentBusinessIdProvider);
  if (businessId <= 0) return const [];
  final range = ref.watch(classEventsRangeProvider);
  final location = ref.watch(currentLocationProvider);
  final classTypeId = ref.watch(selectedClassTypeIdProvider);
  final repo = ref.watch(classEventsRepositoryProvider);
  return repo.listEvents(
    businessId: businessId,
    fromUtc: range.from,
    toUtc: range.to,
    locationId: location.id,
    classTypeId: classTypeId,
  );
});

final upcomingClassEventsByTypeProvider =
    FutureProvider.family<List<ClassEvent>, int>((ref, classTypeId) async {
      final businessId = ref.watch(currentBusinessIdProvider);
      if (businessId <= 0 || classTypeId <= 0) return const [];

      final repo = ref.watch(classEventsRepositoryProvider);
      final nowUtc = DateTime.now().toUtc();
      final fromUtc = nowUtc.subtract(const Duration(days: 1));
      final toUtc = nowUtc.add(const Duration(days: 3650));

      final events = await repo.listEvents(
        businessId: businessId,
        fromUtc: fromUtc,
        toUtc: toUtc,
        classTypeId: classTypeId,
      );

      final upcoming = events
          .where(
            (event) =>
                event.endsAtUtc.isAfter(nowUtc) &&
                event.status.toUpperCase() != 'CANCELLED',
          )
          .toList()
        ..sort((a, b) => a.startsAtUtc.compareTo(b.startsAtUtc));

      return upcoming;
    });

final allClassEventsByTypeProvider =
    FutureProvider.family<List<ClassEvent>, int>((ref, classTypeId) async {
      final businessId = ref.watch(currentBusinessIdProvider);
      if (businessId <= 0 || classTypeId <= 0) return const [];

      final repo = ref.watch(classEventsRepositoryProvider);
      final nowUtc = DateTime.now().toUtc();
      final fromUtc = nowUtc.subtract(const Duration(days: 3650));
      final toUtc = nowUtc.add(const Duration(days: 3650));

      final events = await repo.listEvents(
        businessId: businessId,
        fromUtc: fromUtc,
        toUtc: toUtc,
        classTypeId: classTypeId,
      );

      final all = events
          .where((event) => event.status.toUpperCase() != 'CANCELLED')
          .toList()
        ..sort((a, b) => b.startsAtUtc.compareTo(a.startsAtUtc));

      return all;
    });

final upcomingClassEventsCountByTypeProvider =
    FutureProvider.family<int, int>((ref, classTypeId) async {
      final upcoming = await ref.watch(
        upcomingClassEventsByTypeProvider(classTypeId).future,
      );
      return upcoming.length;
    });

final classEventDetailProvider = FutureProvider.family<ClassEvent, int>((
  ref,
  classEventId,
) async {
  final businessId = ref.watch(currentBusinessIdProvider);
  final repo = ref.watch(classEventsRepositoryProvider);
  return repo.getEvent(businessId: businessId, classEventId: classEventId);
});

final classEventParticipantsProvider =
    FutureProvider.family<List<ClassBooking>, int>((ref, classEventId) async {
      final businessId = ref.watch(currentBusinessIdProvider);
      final repo = ref.watch(classEventsRepositoryProvider);
      return repo.participants(businessId: businessId, classEventId: classEventId);
    });

class ClassEventBookingController extends AsyncNotifier<void> {
  @override
  Future<void> build() async {}

  Future<void> book({required int classEventId, int? customerId}) async {
    state = const AsyncLoading();
    final businessId = ref.read(currentBusinessIdProvider);
    final repo = ref.read(classEventsRepositoryProvider);
    try {
      await repo.book(
        businessId: businessId,
        classEventId: classEventId,
        customerId: customerId,
      );
      state = const AsyncData(null);
    } catch (error, stackTrace) {
      state = AsyncError(error, stackTrace);
    }
    ref.invalidate(classEventsProvider);
    ref.invalidate(classEventDetailProvider(classEventId));
    ref.invalidate(classEventParticipantsProvider(classEventId));
  }

  Future<void> cancel({required int classEventId, int? customerId}) async {
    state = const AsyncLoading();
    final businessId = ref.read(currentBusinessIdProvider);
    final repo = ref.read(classEventsRepositoryProvider);
    try {
      await repo.cancelBooking(
        businessId: businessId,
        classEventId: classEventId,
        customerId: customerId,
      );
      state = const AsyncData(null);
    } catch (error, stackTrace) {
      state = AsyncError(error, stackTrace);
    }
    ref.invalidate(classEventsProvider);
    ref.invalidate(classEventDetailProvider(classEventId));
    ref.invalidate(classEventParticipantsProvider(classEventId));
  }
}

final classEventBookingControllerProvider =
    AsyncNotifierProvider<ClassEventBookingController, void>(
      ClassEventBookingController.new,
    );

class ClassEventCreateController extends AsyncNotifier<void> {
  @override
  Future<void> build() async {}

  Future<ClassEvent> create({
    required int classTypeId,
    required String startsAtIsoUtc,
    required String endsAtIsoUtc,
    required int locationId,
    required int staffId,
    required int capacityTotal,
  }) async {
    state = const AsyncLoading();
    final businessId = ref.read(currentBusinessIdProvider);
    final repo = ref.read(classEventsRepositoryProvider);

    try {
      final created = await repo.create(
        businessId: businessId,
        payload: {
          'class_type_id': classTypeId,
          'starts_at': startsAtIsoUtc,
          'ends_at': endsAtIsoUtc,
          'location_id': locationId,
          'staff_id': staffId,
          'capacity_total': capacityTotal,
        },
      );
      state = const AsyncData(null);
      ref.invalidate(classEventsProvider);
      return created;
    } catch (error, stackTrace) {
      state = AsyncError(error, stackTrace);
      rethrow;
    }
  }
}

final classEventCreateControllerProvider =
    AsyncNotifierProvider<ClassEventCreateController, void>(
      ClassEventCreateController.new,
    );

class ClassTypeMutationController extends AsyncNotifier<void> {
  @override
  Future<void> build() async {}

  Future<ClassType> create({
    required String name,
    String? description,
    bool isActive = true,
    List<int>? locationIds,
  }) async {
    state = const AsyncLoading();
    final businessId = ref.read(currentBusinessIdProvider);
    final repo = ref.read(classEventsRepositoryProvider);
    try {
      final created = await repo.createClassType(
        businessId: businessId,
        payload: {
          'name': name.trim(),
          'description': description?.trim().isEmpty == true
              ? null
              : description?.trim(),
          'is_active': isActive,
          if (locationIds != null) 'location_ids': locationIds,
        },
      );
      state = const AsyncData(null);
      ref.invalidate(classTypesProvider);
      ref.invalidate(classTypesWithInactiveProvider);
      ref.invalidate(classEventsProvider);
      return created;
    } catch (error, stackTrace) {
      state = AsyncError(error, stackTrace);
      rethrow;
    }
  }

  Future<ClassType> updateType({
    required int classTypeId,
    required String name,
    String? description,
    required bool isActive,
    List<int>? locationIds,
  }) async {
    state = const AsyncLoading();
    final businessId = ref.read(currentBusinessIdProvider);
    final repo = ref.read(classEventsRepositoryProvider);
    try {
      final updated = await repo.updateClassType(
        businessId: businessId,
        classTypeId: classTypeId,
        payload: {
          'name': name.trim(),
          'description': description?.trim().isEmpty == true
              ? null
              : description?.trim(),
          'is_active': isActive,
          if (locationIds != null) 'location_ids': locationIds,
        },
      );
      state = const AsyncData(null);
      ref.invalidate(classTypesProvider);
      ref.invalidate(classTypesWithInactiveProvider);
      ref.invalidate(classEventsProvider);
      return updated;
    } catch (error, stackTrace) {
      state = AsyncError(error, stackTrace);
      rethrow;
    }
  }

  Future<void> deleteType({required int classTypeId}) async {
    state = const AsyncLoading();
    final businessId = ref.read(currentBusinessIdProvider);
    final repo = ref.read(classEventsRepositoryProvider);
    try {
      await repo.deleteClassType(
        businessId: businessId,
        classTypeId: classTypeId,
      );
      state = const AsyncData(null);
      ref.invalidate(classTypesProvider);
      ref.invalidate(classTypesWithInactiveProvider);
      ref.invalidate(classEventsProvider);
    } catch (error, stackTrace) {
      state = AsyncError(error, stackTrace);
      rethrow;
    }
  }
}

final classTypeMutationControllerProvider =
    AsyncNotifierProvider<ClassTypeMutationController, void>(
      ClassTypeMutationController.new,
    );
--- FILE: lib/features/class_events/data/class_events_repository.dart ---
import '/core/models/class_booking.dart';
import '/core/models/class_event.dart';
import '/core/models/class_type.dart';
import '/core/network/api_client.dart';

class ClassEventsRepository {
  const ClassEventsRepository(this._apiClient);

  final ApiClient _apiClient;

  Future<List<ClassEvent>> listEvents({
    required int businessId,
    required DateTime fromUtc,
    required DateTime toUtc,
    int? locationId,
    int? classTypeId,
  }) {
    return _apiClient.getClassEvents(
      businessId: businessId,
      fromUtc: fromUtc,
      toUtc: toUtc,
      locationId: locationId,
      classTypeId: classTypeId,
    );
  }

  Future<ClassEvent> getEvent({
    required int businessId,
    required int classEventId,
  }) {
    return _apiClient.getClassEvent(
      businessId: businessId,
      classEventId: classEventId,
    );
  }

  Future<List<ClassBooking>> participants({
    required int businessId,
    required int classEventId,
  }) {
    return _apiClient.getClassEventParticipants(
      businessId: businessId,
      classEventId: classEventId,
    );
  }

  Future<ClassBooking> book({
    required int businessId,
    required int classEventId,
    int? customerId,
  }) {
    return _apiClient.bookClassEvent(
      businessId: businessId,
      classEventId: classEventId,
      customerId: customerId,
    );
  }

  Future<void> cancelBooking({
    required int businessId,
    required int classEventId,
    int? customerId,
  }) {
    return _apiClient.cancelClassEventBooking(
      businessId: businessId,
      classEventId: classEventId,
      customerId: customerId,
    );
  }

  Future<ClassEvent> create({
    required int businessId,
    required Map<String, dynamic> payload,
  }) {
    return _apiClient.createClassEvent(businessId: businessId, data: payload);
  }

  Future<ClassEvent> update({
    required int businessId,
    required int classEventId,
    required Map<String, dynamic> payload,
  }) {
    return _apiClient.updateClassEvent(
      businessId: businessId,
      classEventId: classEventId,
      data: payload,
    );
  }

  Future<void> deleteEvent({
    required int businessId,
    required int classEventId,
  }) {
    return _apiClient.deleteClassEvent(
      businessId: businessId,
      classEventId: classEventId,
    );
  }

  Future<List<ClassType>> listClassTypes({
    required int businessId,
    bool includeInactive = false,
  }) {
    return _apiClient.getClassTypes(
      businessId: businessId,
      includeInactive: includeInactive,
    );
  }

  Future<ClassType> createClassType({
    required int businessId,
    required Map<String, dynamic> payload,
  }) {
    return _apiClient.createClassType(businessId: businessId, data: payload);
  }

  Future<ClassType> updateClassType({
    required int businessId,
    required int classTypeId,
    required Map<String, dynamic> payload,
  }) {
    return _apiClient.updateClassType(
      businessId: businessId,
      classTypeId: classTypeId,
      data: payload,
    );
  }

  Future<void> deleteClassType({
    required int businessId,
    required int classTypeId,
  }) {
    return _apiClient.deleteClassType(
      businessId: businessId,
      classTypeId: classTypeId,
    );
  }
}
--- FILE: lib/features/class_events/presentation/class_events_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '/app/providers/form_factor_provider.dart';
import '/core/l10n/date_time_formats.dart';
import '/core/l10n/l10_extension.dart';
import '/core/models/class_event.dart';
import '/core/models/class_type.dart';
import '/core/models/location.dart';
import '/core/models/staff.dart';
import '/core/network/api_client.dart';
import '/core/widgets/app_bottom_sheet.dart';
import '/core/widgets/app_buttons.dart';
import '/core/widgets/feedback_dialog.dart';
import '/features/agenda/providers/date_range_provider.dart';
import '/features/agenda/providers/location_providers.dart';
import '/features/agenda/presentation/widgets/recurrence_picker.dart';
import '/features/agenda/presentation/widgets/recurrence_preview.dart';
import '/features/agenda/presentation/dialogs/recurrence_summary_dialog.dart';
import '/features/agenda/domain/config/layout_config.dart';
import '/features/staff/providers/staff_providers.dart';
import '../../agenda/providers/business_providers.dart';
import '../../auth/providers/current_business_user_provider.dart';
import '../../../core/models/recurrence_rule.dart';
import '../data/class_events_repository.dart';
import '../providers/class_events_providers.dart';

String _resolveClassTypeErrorMessage(Object error, BuildContext context) {
  final l10n = context.l10n;
  if (error is ApiException) {
    if (error.code == 'class_type_in_use') {
      return l10n.classTypesDeleteInUseErrorMessage;
    }
    return error.message;
  }
  return l10n.classTypesMutationErrorMessage;
}

class ClassEventsScreen extends ConsumerWidget {
  const ClassEventsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final classTypesAsync = ref.watch(classTypesWithInactiveProvider);
    final currentLocation = ref.watch(currentLocationProvider);
    final canManageClassTypes = ref.watch(currentUserCanManageServicesProvider);
    final onSurfaceVariant = Theme.of(context).colorScheme.onSurfaceVariant;

    return Column(
      children: [
        Expanded(
          child: classTypesAsync.when(
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (_, __) => Center(child: Text(l10n.errorTitle)),
            data: (classTypes) {
              final filteredClassTypes = classTypes.where((type) {
                if (type.locationIds.isEmpty) return true;
                return type.locationIds.contains(currentLocation.id);
              }).toList();

              if (filteredClassTypes.isEmpty) {
                return Center(
                  child: Text(
                    l10n.classTypesEmpty,
                    style: Theme.of(
                      context,
                    ).textTheme.bodyMedium?.copyWith(color: onSurfaceVariant),
                  ),
                );
              }
              return ListView.separated(
                padding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
                itemCount: filteredClassTypes.length,
                separatorBuilder: (_, __) => const SizedBox(height: 10),
                itemBuilder: (_, index) => _ClassTypeCard(
                  key: ValueKey<int>(filteredClassTypes[index].id),
                  classType: filteredClassTypes[index],
                  canManageClassTypes: canManageClassTypes,
                ),
              );
            },
          ),
        ),
      ],
    );
  }
}

Future<void> showCreateClassTypeDialog(
  BuildContext context,
  WidgetRef ref, {
  ClassType? initial,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final isDesktop = formFactor == AppFormFactor.desktop;
  if (isDesktop) {
    await showDialog<void>(
      context: context,
      builder: (_) => Dialog(
        child: SizedBox(
          width: 520,
          child: _ClassTypeFormDialog(initial: initial),
        ),
      ),
    );
    return;
  }

  await AppBottomSheet.show<void>(
    context: context,
    builder: (_) => _ClassTypeFormDialog(initial: initial),
  );
}

Future<void> showCreateClassEventDialog(
  BuildContext context,
  WidgetRef ref, {
  int? initialClassTypeId,
  ClassEvent? initialEvent,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final isDesktop = formFactor == AppFormFactor.desktop;
  final currentLocation = ref.read(currentLocationProvider);
  final initialDate = ref.read(agendaDateProvider);

  if (isDesktop) {
    await showDialog<void>(
      context: context,
      builder: (_) => Dialog(
        child: SizedBox(
          width: 620,
          child: _CreateClassForm(
            initialClassTypeId: initialClassTypeId,
            initialLocationId: currentLocation.id,
            initialDate: initialDate,
            initialEvent: initialEvent,
          ),
        ),
      ),
    );
    return;
  }

  await AppBottomSheet.show<void>(
    context: context,
    builder: (_) => _CreateClassForm(
      initialClassTypeId: initialClassTypeId,
      initialLocationId: currentLocation.id,
      initialDate: initialDate,
      initialEvent: initialEvent,
    ),
  );
}

class _ClassTypeCard extends ConsumerWidget {
  const _ClassTypeCard({
    super.key,
    required this.classType,
    required this.canManageClassTypes,
  });

  final ClassType classType;
  final bool canManageClassTypes;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final mutationState = ref.watch(classTypeMutationControllerProvider);
    final isLoading = mutationState.isLoading;
    final upcomingCountAsync = ref.watch(
      upcomingClassEventsCountByTypeProvider(classType.id),
    );
    final allSchedulesAsync = ref.watch(
      allClassEventsByTypeProvider(classType.id),
    );
    final colorScheme = Theme.of(context).colorScheme;
    final locations = ref.watch(locationsProvider);
    final businessContext = ref.watch(currentBusinessUserContextProvider).maybeWhen(
          data: (ctx) => ctx,
          orElse: () => null,
        );
    final locationNameById = {
      for (final location in locations) location.id: location.name,
    };
    final hasSingleBusinessLocation = locations.length <= 1;
    final hasSingleOperatorLocation =
        businessContext != null &&
        !businessContext.isSuperadmin &&
        businessContext.hasLocationScope &&
        businessContext.locationIds.length == 1;
    final shouldShowLocationsRow =
        !hasSingleBusinessLocation && !hasSingleOperatorLocation;
    final visibleLocationNames = classType.locationIds
        .map((id) => locationNameById[id])
        .whereType<String>()
        .toList();

    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: colorScheme.outline.withOpacity(0.2)),
      ),
      child: Padding(
        padding: const EdgeInsets.all(14),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Expanded(
                  child: Text(
                    classType.name,
                    style: Theme.of(context).textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                ),
                _ClassTypeStatusChip(isActive: classType.isActive),
              ],
            ),
            if ((classType.description ?? '').trim().isNotEmpty) ...[
              const SizedBox(height: 6),
              Text(
                classType.description!,
                style: Theme.of(context).textTheme.bodySmall,
              ),
            ],
            if (shouldShowLocationsRow) ...[
              const SizedBox(height: 6),
              Row(
                children: [
                  const Icon(Icons.place_outlined, size: 16),
                  const SizedBox(width: 6),
                  Expanded(
                    child: Text(
                      classType.locationIds.isEmpty
                          ? l10n.allLocations
                          : visibleLocationNames.join(', '),
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                  ),
                ],
              ),
            ],
            const SizedBox(height: 10),
            Wrap(
              spacing: 8,
              runSpacing: 8,
              children: [
                if (canManageClassTypes)
                  FilledButton.icon(
                    onPressed: isLoading
                        ? null
                        : () => showCreateClassEventDialog(
                              context,
                              ref,
                              initialClassTypeId: classType.id,
                            ),
                    icon: const Icon(Icons.event_available_outlined),
                    label: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Text(l10n.classTypesActionScheduleClass),
                        switch ((upcomingCountAsync, allSchedulesAsync)) {
                          (AsyncData<int> futureData, AsyncData<List<ClassEvent>> allData) =>
                            Builder(
                              builder: (_) {
                                final futureCount = futureData.value;
                                final expiredCount =
                                    (allData.value.length - futureCount).clamp(0, 1 << 30);
                                if (futureCount == 0 && expiredCount == 0) {
                                  return const SizedBox.shrink();
                                }
                                return Padding(
                                  padding: const EdgeInsets.only(left: 8),
                                  child: Wrap(
                                    spacing: 6,
                                    children: [
                                      if (futureCount > 0)
                                        _ScheduleCountPill(
                                          label: l10n.classEventsFutureBadge,
                                          count: futureCount,
                                          textColor: colorScheme.onPrimary,
                                          backgroundColor: colorScheme.onPrimary.withOpacity(0.14),
                                        ),
                                      if (expiredCount > 0)
                                        _ScheduleCountPill(
                                          label: l10n.classEventsExpiredBadge,
                                          count: expiredCount,
                                          textColor: colorScheme.onPrimary,
                                          backgroundColor: colorScheme.onPrimary.withOpacity(0.22),
                                        ),
                                    ],
                                  ),
                                );
                              },
                            ),
                          _ => const SizedBox.shrink(),
                        },
                      ],
                    ),
                  ),
                if (canManageClassTypes)
                  OutlinedButton.icon(
                    onPressed: isLoading
                        ? null
                        : () => showCreateClassTypeDialog(
                              context,
                              ref,
                              initial: classType,
                            ),
                    icon: const Icon(Icons.edit_outlined),
                    label: Text(l10n.actionEdit),
                  ),
                if (canManageClassTypes)
                  OutlinedButton.icon(
                    onPressed: isLoading
                        ? null
                        : () => _cloneClassType(context, ref, classType),
                    icon: const Icon(Icons.copy_outlined),
                    label: Text(l10n.duplicateAction),
                  ),
                if (canManageClassTypes)
                  OutlinedButton.icon(
                    onPressed: isLoading
                        ? null
                        : () => _deleteClassType(context, ref, classType),
                    icon: const Icon(Icons.delete_outline),
                    label: Text(l10n.actionDelete),
                  ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _cloneClassType(
    BuildContext context,
    WidgetRef ref,
    ClassType source,
  ) async {
    final l10n = context.l10n;
    try {
      final allTypes = await ref.read(classTypesWithInactiveProvider.future);
      final existingNames = allTypes
          .map((type) => type.name.trim().toLowerCase())
          .toSet();
      final baseName = '${source.name.trim()} ${l10n.classTypesCloneSuffix}';
      var candidateName = baseName;
      var counter = 2;
      while (existingNames.contains(candidateName.toLowerCase())) {
        candidateName = '$baseName $counter';
        counter++;
      }

      await ref.read(classTypeMutationControllerProvider.notifier).create(
        name: candidateName,
        description: source.description,
        isActive: source.isActive,
        locationIds: source.locationIds,
      );
      if (!context.mounted) return;
      await FeedbackDialog.showSuccess(
        context,
        title: l10n.classTypesCloneSuccessTitle,
        message: l10n.classTypesCloneSuccessMessage,
      );
    } catch (error) {
      if (!context.mounted) return;
      final message = _resolveClassTypeErrorMessage(error, context);
      await FeedbackDialog.showError(
        context,
        title: l10n.errorTitle,
        message: message,
      );
    }
  }

  Future<void> _deleteClassType(
    BuildContext context,
    WidgetRef ref,
    ClassType classType,
  ) async {
    final l10n = context.l10n;
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.classTypesDeleteConfirmTitle),
        content: Text(l10n.classTypesDeleteConfirmMessage),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(false),
            child: Text(l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () => Navigator.of(ctx).pop(true),
            child: Text(l10n.actionConfirm),
          ),
        ],
      ),
    );
    if (confirmed != true || !context.mounted) return;

    try {
      await ref.read(classTypeMutationControllerProvider.notifier).deleteType(
        classTypeId: classType.id,
      );
      if (!context.mounted) return;
      await FeedbackDialog.showSuccess(
        context,
        title: l10n.classTypesDeleteSuccessTitle,
        message: l10n.classTypesDeleteSuccessMessage,
      );
    } catch (error) {
      if (!context.mounted) return;
      final message = _resolveClassTypeErrorMessage(error, context);
      await FeedbackDialog.showError(
        context,
        title: l10n.errorTitle,
        message: message,
      );
    }
  }
}

class _ClassTypeStatusChip extends StatelessWidget {
  const _ClassTypeStatusChip({required this.isActive});

  final bool isActive;

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;

    final bg = isActive
        ? colorScheme.primaryContainer
        : colorScheme.surfaceContainerHighest;
    final fg = isActive ? colorScheme.onPrimaryContainer : colorScheme.onSurface;

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: bg,
        borderRadius: BorderRadius.circular(999),
      ),
      child: Text(
        isActive ? l10n.classTypesStatusActive : l10n.classTypesStatusInactive,
        style: Theme.of(context).textTheme.labelSmall?.copyWith(color: fg),
      ),
    );
  }
}

class _ScheduleCountPill extends StatelessWidget {
  const _ScheduleCountPill({
    required this.label,
    required this.count,
    required this.textColor,
    required this.backgroundColor,
  });

  final String label;
  final int count;
  final Color textColor;
  final Color backgroundColor;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(999),
      ),
      child: Text(
        '$label $count',
        style: Theme.of(context).textTheme.labelSmall?.copyWith(
          color: textColor,
          fontWeight: FontWeight.w700,
        ),
      ),
    );
  }
}

class _ClassTypeFormDialog extends ConsumerStatefulWidget {
  const _ClassTypeFormDialog({this.initial});

  final ClassType? initial;

  @override
  ConsumerState<_ClassTypeFormDialog> createState() => _ClassTypeFormDialogState();
}

class _ClassTypeFormDialogState extends ConsumerState<_ClassTypeFormDialog> {
  final _formKey = GlobalKey<FormState>();
  late final TextEditingController _nameController;
  late final TextEditingController _descriptionController;
  late bool _isActive;
  late bool _allLocations;
  late Set<int> _selectedLocationIds;

  bool get _isEdit => widget.initial != null;

  @override
  void initState() {
    super.initState();
    _nameController = TextEditingController(text: widget.initial?.name ?? '');
    _descriptionController = TextEditingController(
      text: widget.initial?.description ?? '',
    );
    _isActive = widget.initial?.isActive ?? true;
    _allLocations = (widget.initial?.locationIds.isEmpty ?? true);
    _selectedLocationIds = {...?widget.initial?.locationIds};
  }

  @override
  void dispose() {
    _nameController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final mutationState = ref.watch(classTypeMutationControllerProvider);
    final isLoading = mutationState.isLoading;
    final locations = ref.watch(locationsProvider);
    final businessContext = ref.watch(currentBusinessUserContextProvider).maybeWhen(
          data: (ctx) => ctx,
          orElse: () => null,
        );
    final isLocationScopedOperator =
        businessContext != null &&
        !businessContext.isSuperadmin &&
        businessContext.hasLocationScope;
    final allowedLocationIds = isLocationScopedOperator
        ? businessContext.locationIds.toSet()
        : null;
    final visibleLocations = allowedLocationIds == null
        ? locations
        : locations.where((location) => allowedLocationIds.contains(location.id)).toList();
    final visibleLocationIds = visibleLocations.map((location) => location.id).toSet();
    final hasSingleVisibleLocation = visibleLocations.length == 1;
    final effectiveSelectedLocationIds = _selectedLocationIds
        .where(visibleLocationIds.contains)
        .toSet();
    final allLocationsEnabled = isLocationScopedOperator ? false : _allLocations;
    final shouldShowLocationsSelector =
        !allLocationsEnabled && !hasSingleVisibleLocation;

    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                _isEdit ? l10n.classTypesEditTitle : l10n.classTypesCreateTitle,
                style: Theme.of(context).textTheme.titleLarge,
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _nameController,
                enabled: !isLoading,
                decoration: InputDecoration(
                  labelText: l10n.classTypesFieldName,
                  border: const OutlineInputBorder(),
                ),
                validator: (value) {
                  if ((value ?? '').trim().isEmpty) {
                    return l10n.classEventsValidationRequired;
                  }
                  return null;
                },
              ),
              const SizedBox(height: 12),
              TextFormField(
                controller: _descriptionController,
                enabled: !isLoading,
                maxLines: 3,
                decoration: InputDecoration(
                  labelText: l10n.classTypesFieldDescriptionOptional,
                  border: const OutlineInputBorder(),
                ),
              ),
              const SizedBox(height: 8),
              SwitchListTile(
                contentPadding: EdgeInsets.zero,
                value: _isActive,
                onChanged: isLoading
                    ? null
                    : (value) => setState(() => _isActive = value),
                title: Text(l10n.classTypesFieldIsActive),
              ),
              if (!isLocationScopedOperator) ...[
                const SizedBox(height: 8),
                SwitchListTile(
                  contentPadding: EdgeInsets.zero,
                  value: _allLocations,
                  onChanged: isLoading
                      ? null
                      : (value) => setState(() => _allLocations = value),
                  title: Text(l10n.allLocations),
                ),
              ],
              if (shouldShowLocationsSelector) ...[
                const SizedBox(height: 8),
                _ClassTypeLocationsMultiSelect(
                  locations: visibleLocations,
                  selectedIds: effectiveSelectedLocationIds,
                  enabled: !isLoading,
                  onChanged: (ids) => setState(() {
                    _selectedLocationIds
                      ..clear()
                      ..addAll(ids);
                  }),
                ),
                if (effectiveSelectedLocationIds.isEmpty)
                  Padding(
                    padding: const EdgeInsets.only(top: 6),
                    child: Text(
                      l10n.operatorsScopeLocationsRequired,
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                  ),
              ],
              const SizedBox(height: 12),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  AppOutlinedActionButton(
                    onPressed: isLoading ? null : () => Navigator.of(context).pop(),
                    child: Text(l10n.actionCancel),
                  ),
                  const SizedBox(width: 8),
                  AppAsyncFilledButton(
                    isLoading: isLoading,
                    onPressed: _submit,
                    child: Text(l10n.actionSave),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _submit() async {
    final l10n = context.l10n;
    final businessContext = ref.read(currentBusinessUserContextProvider).maybeWhen(
          data: (ctx) => ctx,
          orElse: () => null,
        );
    final isLocationScopedOperator =
        businessContext != null &&
        !businessContext.isSuperadmin &&
        businessContext.hasLocationScope;
    final allowedLocationIds = isLocationScopedOperator
        ? businessContext.locationIds.toSet()
        : null;
    final locations = ref.read(locationsProvider);
    final visibleLocations = allowedLocationIds == null
        ? locations
        : locations.where((location) => allowedLocationIds.contains(location.id)).toList();
    final hasSingleVisibleLocation = visibleLocations.length == 1;
    final singleVisibleLocationId = hasSingleVisibleLocation
        ? visibleLocations.first.id
        : null;
    final effectiveSelectedLocationIds = _selectedLocationIds
        .where((id) => allowedLocationIds == null || allowedLocationIds.contains(id))
        .toSet();
    final allLocationsEnabled = isLocationScopedOperator ? false : _allLocations;
    final locationIdsForSubmit = allLocationsEnabled
        ? <int>[]
        : hasSingleVisibleLocation && singleVisibleLocationId != null
        ? <int>[singleVisibleLocationId]
        : effectiveSelectedLocationIds.toList();

    if (!_formKey.currentState!.validate()) return;
    if (!allLocationsEnabled && locationIdsForSubmit.isEmpty) {
      await FeedbackDialog.showError(
        context,
        title: l10n.errorTitle,
        message: l10n.operatorsScopeLocationsRequired,
      );
      return;
    }
    try {
      if (_isEdit) {
        await ref.read(classTypeMutationControllerProvider.notifier).updateType(
          classTypeId: widget.initial!.id,
          name: _nameController.text,
          description: _descriptionController.text,
          isActive: _isActive,
          locationIds: locationIdsForSubmit,
        );
      } else {
        await ref.read(classTypeMutationControllerProvider.notifier).create(
          name: _nameController.text,
          description: _descriptionController.text,
          isActive: _isActive,
          locationIds: locationIdsForSubmit,
        );
      }
      if (!mounted) return;
      Navigator.of(context).pop();
      await FeedbackDialog.showSuccess(
        context,
        title: _isEdit
            ? l10n.classTypesUpdateSuccessTitle
            : l10n.classTypesCreateSuccessTitle,
        message: _isEdit
            ? l10n.classTypesUpdateSuccessMessage
            : l10n.classTypesCreateSuccessMessage,
      );
    } catch (error) {
      if (!mounted) return;
      final message = _resolveClassTypeErrorMessage(error, context);
      await FeedbackDialog.showError(
        context,
        title: l10n.errorTitle,
        message: message,
      );
    }
  }
}

class _ClassTypeLocationsMultiSelect extends StatelessWidget {
  const _ClassTypeLocationsMultiSelect({
    required this.locations,
    required this.selectedIds,
    required this.enabled,
    required this.onChanged,
  });

  final List<Location> locations;
  final Set<int> selectedIds;
  final bool enabled;
  final ValueChanged<Set<int>> onChanged;

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;
    final listHeight = (locations.length * 72).clamp(72, 280).toDouble();

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          l10n.operatorsScopeSelectLocations,
          style: Theme.of(context).textTheme.titleSmall,
        ),
        const SizedBox(height: 8),
        Container(
          decoration: BoxDecoration(
            border: Border.all(color: colorScheme.outline),
            borderRadius: BorderRadius.circular(12),
          ),
          child: SizedBox(
            height: listHeight,
            child: ListView.separated(
              primary: false,
              itemCount: locations.length,
              separatorBuilder: (_, __) => const Divider(height: 1),
              itemBuilder: (context, index) {
                final location = locations[index];
                return _ClassTypeLocationCheckboxTile(
                  location: location,
                  isSelected: selectedIds.contains(location.id),
                  enabled: enabled,
                  onChanged: (selected) {
                    final newIds = Set<int>.from(selectedIds);
                    if (selected) {
                      newIds.add(location.id);
                    } else {
                      newIds.remove(location.id);
                    }
                    onChanged(newIds);
                  },
                );
              },
            ),
          ),
        ),
      ],
    );
  }
}

class _ClassTypeLocationCheckboxTile extends StatelessWidget {
  const _ClassTypeLocationCheckboxTile({
    required this.location,
    required this.isSelected,
    required this.enabled,
    required this.onChanged,
  });

  final Location location;
  final bool isSelected;
  final bool enabled;
  final ValueChanged<bool> onChanged;

  @override
  Widget build(BuildContext context) {
    return CheckboxListTile(
      value: isSelected,
      onChanged: enabled ? (value) => onChanged(value ?? false) : null,
      title: Text(location.name),
      subtitle: location.address != null
          ? Text(
              location.address!,
              style: Theme.of(context).textTheme.bodySmall,
            )
          : null,
      secondary: const Icon(Icons.store_outlined),
      controlAffinity: ListTileControlAffinity.trailing,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
    );
  }
}

class _CreateClassForm extends ConsumerStatefulWidget {
  const _CreateClassForm({
    required this.initialLocationId,
    required this.initialDate,
    this.initialClassTypeId,
    this.initialEvent,
  });

  final int initialLocationId;
  final DateTime initialDate;
  final int? initialClassTypeId;
  final ClassEvent? initialEvent;

  @override
  ConsumerState<_CreateClassForm> createState() => _CreateClassFormState();
}

class _CreateClassFormState extends ConsumerState<_CreateClassForm> {
  final _formKey = GlobalKey<FormState>();
  final _capacityController = TextEditingController(text: '1');

  ClassEvent? _editingEvent;
  _CreateClassDraft? _preEditDraft;
  RecurrenceConfig? _recurrenceConfig;
  int? _classTypeId;
  int? _locationId;
  int? _staffId;
  bool _showSchedulingForm = false;
  late DateTime _date;
  TimeOfDay _startTime = const TimeOfDay(hour: 9, minute: 0);
  TimeOfDay _endTime = const TimeOfDay(hour: 10, minute: 0);
  bool _showExpiredSchedules = false;

  @override
  void initState() {
    super.initState();
    _editingEvent = widget.initialEvent;
    if (_editingEvent != null) {
      _showSchedulingForm = true;
      _applyEventToForm(_editingEvent!);
    } else {
      _classTypeId = widget.initialClassTypeId;
      _locationId = widget.initialLocationId;
      _date = DateTime(
        widget.initialDate.year,
        widget.initialDate.month,
        widget.initialDate.day,
      );
      _showSchedulingForm = false;
    }
  }

  @override
  void dispose() {
    _capacityController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final classTypesAsync = ref.watch(classTypesProvider);
    final staffAsync = ref.watch(allStaffProvider);
    final locations = ref.watch(locationsProvider);
    final createState = ref.watch(classEventCreateControllerProvider);
    final isLoading = createState.isLoading;
    final l10n = context.l10n;
    final isEditMode = _editingEvent != null;
    final isFormMode = _showSchedulingForm || isEditMode;

    final classTypes = classTypesAsync.value ?? const <ClassType>[];
    final allStaff = staffAsync.value ?? const <Staff>[];
    final filteredLocations = _locationsForSelectedClassType(
      locations: locations,
      classTypes: classTypes,
      selectedClassTypeId: _classTypeId,
    );
    final staff = _staffForSelectedLocation(staffAsync.value ?? const <Staff>[]);

    if (classTypes.isNotEmpty && _classTypeId == null) {
      _classTypeId = classTypes.first.id;
    }
    if (filteredLocations.isEmpty) {
      _locationId = null;
    } else if (_locationId == null ||
        !filteredLocations.any((loc) => loc.id == _locationId)) {
      _locationId = filteredLocations.first.id;
    }
    _staffId = _resolveSelectedStaffId(staff);

    final schedulesAsync = _classTypeId == null
        ? const AsyncValue<List<ClassEvent>>.data(<ClassEvent>[])
        : ref.watch(allClassEventsByTypeProvider(_classTypeId!));
    final locationNameById = {for (final location in locations) location.id: location.name};
    final staffNameById = {for (final member in allStaff) member.id: member.displayName};
    final dateFormat = DateFormat('dd/MM/yyyy');
    final timeFormat = DateFormat('HH:mm');

    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Form(
          key: _formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                isEditMode
                    ? l10n.classEventsEditTitle
                    : l10n.classEventsCreateTitle,
                style: Theme.of(context).textTheme.titleLarge,
              ),
              if (!isFormMode && !isEditMode) ...[
                const SizedBox(height: 8),
                OutlinedButton.icon(
                  onPressed: () {
                    setState(() => _showSchedulingForm = true);
                  },
                  icon: const Icon(Icons.add),
                  label: Text(l10n.classEventsNewScheduleButton),
                ),
              ],
              if (isEditMode) ...[
                const SizedBox(height: 8),
                Text(
                  l10n.classEventsEditModeLabel,
                  style: Theme.of(context).textTheme.bodySmall,
                ),
              ],
              const SizedBox(height: 16),
              if (classTypesAsync.isLoading || staffAsync.isLoading)
                const Padding(
                  padding: EdgeInsets.only(bottom: 12),
                  child: LinearProgressIndicator(),
                ),
              if (classTypesAsync.hasError || staffAsync.hasError)
                Padding(
                  padding: const EdgeInsets.only(bottom: 12),
                  child: Text(
                    l10n.errorTitle,
                    style: TextStyle(color: Theme.of(context).colorScheme.error),
                  ),
                ),
              Expanded(
                child: SingleChildScrollView(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      if (isFormMode && classTypes.isEmpty)
                        Padding(
                          padding: const EdgeInsets.only(top: 6),
                          child: Text(
                            l10n.classEventsNoClassTypes,
                            style: Theme.of(context).textTheme.bodySmall,
                          ),
                        ),
                      if (isFormMode && !isEditMode && filteredLocations.length > 1) ...[
                        const SizedBox(height: 12),
                        DropdownButtonFormField<int>(
                          value: _locationId,
                          decoration: InputDecoration(
                            labelText: l10n.classEventsFieldLocation,
                            border: const OutlineInputBorder(),
                          ),
                          items: filteredLocations
                              .map(
                                (location) => DropdownMenuItem<int>(
                                  value: location.id,
                                  child: Text(location.name),
                                ),
                              )
                              .toList(),
                          onChanged: isLoading
                              ? null
                              : (value) => setState(() {
                                  _locationId = value;
                                  _staffId = null;
                                }),
                          validator: (value) => value == null
                              ? l10n.classEventsValidationRequired
                              : null,
                        ),
                      ],
                      if (isFormMode && !isEditMode && staff.length > 1) ...[
                        const SizedBox(height: 12),
                        DropdownButtonFormField<int>(
                          value: _staffId,
                          decoration: InputDecoration(
                            labelText: l10n.classEventsFieldStaff,
                            border: const OutlineInputBorder(),
                          ),
                          items: staff
                              .map(
                                (member) => DropdownMenuItem<int>(
                                  value: member.id,
                                  child: Text(member.displayName),
                                ),
                              )
                              .toList(),
                          onChanged: isLoading
                              ? null
                              : (value) => setState(() => _staffId = value),
                          validator: (value) => value == null
                              ? l10n.classEventsValidationRequired
                              : null,
                        ),
                      ],
                      if (isFormMode && !isEditMode && staff.isEmpty)
                        Padding(
                          padding: const EdgeInsets.only(top: 6),
                          child: Text(
                            l10n.classEventsNoStaffForLocation,
                            style: Theme.of(context).textTheme.bodySmall,
                          ),
                        ),
                      if (isFormMode) const SizedBox(height: 12),
                      if (isFormMode && filteredLocations.isEmpty)
                        Padding(
                          padding: const EdgeInsets.only(bottom: 12),
                          child: Text(
                            l10n.classEventsNoLocationsForClassType,
                            style: Theme.of(context).textTheme.bodySmall,
                          ),
                        ),
                      if (isFormMode)
                        Row(
                        children: [
                          Expanded(
                            child: _PickerField(
                              label: l10n.classEventsFieldDate,
                              value: _formatDate(_date),
                              icon: Icons.calendar_today_outlined,
                              onTap: isLoading ? null : _pickDate,
                            ),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: TextFormField(
                              controller: _capacityController,
                              keyboardType: TextInputType.number,
                              enabled: !isLoading,
                              decoration: InputDecoration(
                                labelText: l10n.classEventsFieldCapacity,
                                border: const OutlineInputBorder(),
                              ),
                              validator: (value) {
                                final parsed = int.tryParse(value ?? '');
                                if (parsed == null || parsed <= 0) {
                                  return l10n.classEventsValidationRequired;
                                }
                                return null;
                              },
                            ),
                          ),
                        ],
                      ),
                      if (isFormMode) const SizedBox(height: 12),
                      if (isFormMode)
                        Row(
                        children: [
                          Expanded(
                            child: _ScheduleTimeField(
                              label: l10n.classEventsFieldStartTime,
                              time: _startTime,
                              onTap: isLoading
                                  ? null
                                  : () => _pickTime(isStart: true),
                            ),
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: _ScheduleTimeField(
                              label: l10n.classEventsFieldEndTime,
                              time: _endTime,
                              onTap: isLoading
                                  ? null
                                  : () => _pickTime(isStart: false),
                            ),
                          ),
                        ],
                      ),
                      if (isFormMode && !isEditMode) ...[
                        const SizedBox(height: 12),
                        RecurrencePicker(
                          startDate: DateTime(
                            _date.year,
                            _date.month,
                            _date.day,
                            _startTime.hour,
                            _startTime.minute,
                          ),
                          title: l10n.classEventsRepeatSchedule,
                          conflictSkipDescription:
                              l10n.classEventsRecurrenceConflictSkipDescription,
                          conflictForceDescription:
                              l10n.classEventsRecurrenceConflictForceDescription,
                          initialConfig: _recurrenceConfig,
                          onChanged: (config) {
                            setState(() => _recurrenceConfig = config);
                          },
                        ),
                        if (_recurrenceConfig != null) ...[
                          const SizedBox(height: 8),
                          RecurrencePreview(
                            startDate: DateTime(
                              _date.year,
                              _date.month,
                              _date.day,
                              _startTime.hour,
                              _startTime.minute,
                            ),
                            config: _recurrenceConfig!,
                          ),
                        ],
                      ],
                      if (!isFormMode) ...[
                        const SizedBox(height: 16),
                        Text(
                          l10n.classEventsSchedulesListTitle,
                          style: Theme.of(context).textTheme.titleSmall,
                        ),
                        const SizedBox(height: 8),
                        schedulesAsync.when(
                          loading: () => const LinearProgressIndicator(minHeight: 2),
                          error: (_, __) => Text(
                            l10n.errorTitle,
                            style: Theme.of(context).textTheme.bodySmall?.copyWith(
                                  color: Theme.of(context).colorScheme.error,
                                ),
                          ),
                          data: (schedules) {
                            final nowUtc = DateTime.now().toUtc();
                            final hasFuture = schedules.any(
                              (event) => event.endsAtUtc.isAfter(nowUtc),
                            );
                            final hasExpired = schedules.any(
                              (event) => !event.endsAtUtc.isAfter(nowUtc),
                            );
                            final shouldShowToggle = hasFuture && hasExpired;
                            final displayedSchedules = shouldShowToggle && !_showExpiredSchedules
                                ? schedules
                                      .where((event) => event.endsAtUtc.isAfter(nowUtc))
                                      .toList()
                                : schedules;

                            if (displayedSchedules.isEmpty) {
                              return Text(
                                l10n.classEventsSchedulesListEmpty,
                                style: Theme.of(context).textTheme.bodySmall,
                              );
                            }

                            final listHeight = (displayedSchedules.length * 64)
                                .clamp(64, 240)
                                .toDouble();
                            return Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                if (shouldShowToggle)
                                  SwitchListTile(
                                    dense: true,
                                    contentPadding: EdgeInsets.zero,
                                    title: Text(
                                      l10n.classEventsShowExpiredSchedules,
                                      style: Theme.of(context).textTheme.bodySmall,
                                    ),
                                    value: _showExpiredSchedules,
                                    onChanged: (value) {
                                      setState(() => _showExpiredSchedules = value);
                                    },
                                  ),
                                Container(
                                  decoration: BoxDecoration(
                                    border: Border.all(color: Theme.of(context).colorScheme.outline),
                                    borderRadius: BorderRadius.circular(12),
                                  ),
                                  child: SizedBox(
                                    height: listHeight,
                                    child: ListView.separated(
                                      primary: false,
                                      itemCount: displayedSchedules.length,
                                      separatorBuilder: (_, __) => const Divider(height: 1),
                                      itemBuilder: (context, index) {
                                        final schedule = displayedSchedules[index];
                                    final startsAtLocal =
                                        schedule.startsAtLocal ??
                                        schedule.startsAtUtc.toLocal();
                                    final endsAtLocal =
                                        schedule.endsAtLocal ??
                                        schedule.endsAtUtc.toLocal();
                                    final locationName =
                                        locationNameById[schedule.locationId] ?? '#${schedule.locationId}';
                                    final staffName =
                                        staffNameById[schedule.staffId] ?? '#${schedule.staffId}';
                                        return ListTile(
                                      dense: true,
                                      visualDensity: VisualDensity.compact,
                                      onTap: () {
                                        _preEditDraft ??= _captureCurrentDraft();
                                        setState(() {
                                          _showSchedulingForm = true;
                                          _editingEvent = schedule;
                                          _applyEventToForm(schedule);
                                        });
                                      },
                                      leading: const Icon(Icons.event_note_outlined, size: 20),
                                      title: Text(
                                        '${dateFormat.format(startsAtLocal)} ‚Ä¢ '
                                        '${timeFormat.format(startsAtLocal)} - ${timeFormat.format(endsAtLocal)}',
                                      ),
                                      subtitle: Text('$locationName ‚Ä¢ $staffName'),
                                      trailing: IconButton(
                                        tooltip: l10n.actionDelete,
                                        icon: const Icon(Icons.delete_outline),
                                        onPressed: () async {
                                          final confirmed = await showDialog<bool>(
                                            context: context,
                                            builder: (ctx) => AlertDialog(
                                              title: Text(
                                                l10n.classEventsSchedulesDeleteConfirmTitle,
                                              ),
                                              content: Text(
                                                l10n.classEventsSchedulesDeleteConfirmMessage,
                                              ),
                                              actions: [
                                                TextButton(
                                                  onPressed: () =>
                                                      Navigator.of(ctx).pop(false),
                                                  child: Text(l10n.actionCancel),
                                                ),
                                                FilledButton(
                                                  onPressed: () =>
                                                      Navigator.of(ctx).pop(true),
                                                  child: Text(l10n.actionDelete),
                                                ),
                                              ],
                                            ),
                                          );
                                          if (confirmed != true || !context.mounted) return;

                                          try {
                                            final businessId = ref.read(currentBusinessIdProvider);
                                            final repo = ref.read(classEventsRepositoryProvider);
                                            await repo.deleteEvent(
                                              businessId: businessId,
                                              classEventId: schedule.id,
                                            );
                                            ref.invalidate(classEventsProvider);
                                            if (_classTypeId != null) {
                                              ref.invalidate(
                                                allClassEventsByTypeProvider(_classTypeId!),
                                              );
                                              ref.invalidate(
                                                upcomingClassEventsByTypeProvider(_classTypeId!),
                                              );
                                              ref.invalidate(
                                                upcomingClassEventsCountByTypeProvider(_classTypeId!),
                                              );
                                            }
                                            if (!context.mounted) return;
                                            await FeedbackDialog.showSuccess(
                                              context,
                                              title: l10n.classEventsSchedulesDeleteSuccessTitle,
                                              message:
                                                  l10n.classEventsSchedulesDeleteSuccessMessage,
                                            );
                                          } catch (error) {
                                            if (!context.mounted) return;
                                            final message = error is ApiException
                                                ? error.message
                                                : l10n.classEventsCreateErrorMessage;
                                            await FeedbackDialog.showError(
                                              context,
                                              title: l10n.errorTitle,
                                              message: message,
                                            );
                                          }
                                        },
                                      ),
                                    );
                                      },
                                    ),
                                  ),
                                ),
                              ],
                            );
                          },
                        ),
                      ],
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 16),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: [
                  AppOutlinedActionButton(
                    onPressed: isLoading
                        ? null
                        : () {
                            if (isEditMode) {
                              final upcomingCount = _readUpcomingCountSync();
                              setState(() {
                                if (upcomingCount != 1 && _preEditDraft != null) {
                                  _restoreDraft(_preEditDraft!);
                                }
                                _editingEvent = null;
                                _preEditDraft = null;
                                _showSchedulingForm = false;
                              });
                              return;
                            }
                            if (isFormMode) {
                              setState(() => _showSchedulingForm = false);
                              return;
                            }
                            Navigator.of(context).pop();
                          },
                    child: Text(isFormMode ? l10n.actionCancel : l10n.actionClose),
                  ),
                  if (isFormMode) ...[
                    const SizedBox(width: 8),
                    AppAsyncFilledButton(
                      isLoading: isLoading,
                      onPressed: _canSubmit(classTypes: classTypes, staff: staff)
                          ? _submit
                          : null,
                      child: Text(l10n.actionSave),
                    ),
                  ],
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }

  bool _canSubmit({
    required List<ClassType> classTypes,
    required List<Staff> staff,
  }) {
    return classTypes.isNotEmpty && staff.isNotEmpty;
  }

  List<Staff> _staffForSelectedLocation(List<Staff> staff) {
    final locationId = _locationId;
    if (locationId == null) {
      return const [];
    }
    return staff
        .where(
          (member) =>
              member.locationIds.isEmpty || member.locationIds.contains(locationId),
        )
        .toList()
      ..sort((a, b) => a.displayName.compareTo(b.displayName));
  }

  int? _resolveSelectedStaffId(List<Staff> staff) {
    if (staff.isEmpty) return null;
    final selected = _staffId;
    if (selected != null && staff.any((member) => member.id == selected)) {
      return selected;
    }
    return staff.first.id;
  }

  List<Location> _locationsForSelectedClassType({
    required List<Location> locations,
    required List<ClassType> classTypes,
    required int? selectedClassTypeId,
  }) {
    if (selectedClassTypeId == null) {
      return locations;
    }
    final selected = classTypes.where((type) => type.id == selectedClassTypeId);
    if (selected.isEmpty) {
      return locations;
    }
    final locationIds = selected.first.locationIds;
    if (locationIds.isEmpty) {
      return locations;
    }
    final allowed = locationIds.toSet();
    return locations.where((location) => allowed.contains(location.id)).toList();
  }

  Future<void> _pickDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _date,
      firstDate: DateTime.now().subtract(const Duration(days: 3650)),
      lastDate: DateTime.now().add(const Duration(days: 3650)),
    );
    if (picked == null || !mounted) return;
    setState(() {
      _date = DateTime(picked.year, picked.month, picked.day);
    });
  }

  Future<void> _pickTime({required bool isStart}) async {
    final initial = isStart ? _startTime : _endTime;
    final l10n = context.l10n;
    final picked = await _showTimeSelection(
      initial: initial,
      title: isStart ? l10n.classEventsFieldStartTime : l10n.classEventsFieldEndTime,
    );
    if (picked == null || !mounted) return;
    setState(() {
      if (isStart) {
        _startTime = picked;
      } else {
        _endTime = picked;
      }
    });
  }

  Future<TimeOfDay?> _showTimeSelection({
    required TimeOfDay initial,
    required String title,
  }) async {
    final formFactor = ref.read(formFactorProvider);
    if (formFactor != AppFormFactor.desktop) {
      return AppBottomSheet.show<TimeOfDay>(
        context: context,
        padding: EdgeInsets.zero,
        heightFactor: AppBottomSheet.defaultHeightFactor,
        builder: (ctx) => _ScheduleTimeGridPicker(
          initial: initial,
          stepMinutes: 15,
          title: title,
        ),
      );
    }

    return showDialog<TimeOfDay>(
      context: context,
      builder: (ctx) => Dialog(
        insetPadding: const EdgeInsets.symmetric(horizontal: 32, vertical: 24),
        child: ConstrainedBox(
          constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
          child: Padding(
            padding: const EdgeInsets.all(20),
            child: _ScheduleTimeGridPicker(
              initial: initial,
              stepMinutes: 15,
              title: title,
              useSafeArea: false,
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _submit() async {
    final l10n = context.l10n;
    if (!_formKey.currentState!.validate()) return;
    if (_classTypeId == null || _locationId == null || _staffId == null) return;

    final startLocal = DateTime(
      _date.year,
      _date.month,
      _date.day,
      _startTime.hour,
      _startTime.minute,
    );
    final endLocal = DateTime(
      _date.year,
      _date.month,
      _date.day,
      _endTime.hour,
      _endTime.minute,
    );
    if (!endLocal.isAfter(startLocal)) {
      await FeedbackDialog.showError(
        context,
        title: l10n.errorTitle,
        message: l10n.classEventsValidationEndAfterStart,
      );
      return;
    }

    final capacity = int.tryParse(_capacityController.text.trim()) ?? 0;
    if (capacity <= 0) {
      await FeedbackDialog.showError(
        context,
        title: l10n.errorTitle,
        message: l10n.classEventsValidationRequired,
      );
      return;
    }

    try {
      if (_editingEvent != null) {
        final businessId = ref.read(currentBusinessIdProvider);
        final repo = ref.read(classEventsRepositoryProvider);
        final classTypeIdForRefresh = _classTypeId!;
        await repo.update(
          businessId: businessId,
          classEventId: _editingEvent!.id,
          payload: {
            'starts_at': _toApiLocalDateTime(startLocal),
            'ends_at': _toApiLocalDateTime(endLocal),
            'capacity_total': capacity,
          },
        );
        final refreshedDayEvents = await ref.refresh(classEventsProvider.future);
        final refreshedUpcoming = await ref.refresh(
          upcomingClassEventsByTypeProvider(classTypeIdForRefresh).future,
        );
        final _ = await ref.refresh(
          allClassEventsByTypeProvider(classTypeIdForRefresh).future,
        );
        final refreshedCount = await ref.refresh(
          upcomingClassEventsCountByTypeProvider(classTypeIdForRefresh).future,
        );
        if (refreshedCount != refreshedUpcoming.length ||
            refreshedDayEvents.any((event) => event.classTypeId == classTypeIdForRefresh) ==
                false) {
          ref.invalidate(upcomingClassEventsCountByTypeProvider(classTypeIdForRefresh));
        }
        if (!mounted) return;
        setState(() {
          if (refreshedUpcoming.length != 1 && _preEditDraft != null) {
            _restoreDraft(_preEditDraft!);
          }
          _editingEvent = null;
          _preEditDraft = null;
          _showSchedulingForm = false;
        });
        await FeedbackDialog.showSuccess(
          context,
          title: l10n.classEventsSchedulesUpdateSuccessTitle,
          message: l10n.classEventsSchedulesUpdateSuccessMessage,
        );
        return;
      } else if (_recurrenceConfig == null) {
        await ref.read(classEventCreateControllerProvider.notifier).create(
          classTypeId: _classTypeId!,
          startsAtIsoUtc: _toApiLocalDateTime(startLocal),
          endsAtIsoUtc: _toApiLocalDateTime(endLocal),
          locationId: _locationId!,
          staffId: _staffId!,
          capacityTotal: capacity,
        );
        ref.invalidate(upcomingClassEventsByTypeProvider(_classTypeId!));
        ref.invalidate(allClassEventsByTypeProvider(_classTypeId!));
        ref.invalidate(upcomingClassEventsCountByTypeProvider(_classTypeId!));
      } else {
        final businessId = ref.read(currentBusinessIdProvider);
        final repo = ref.read(classEventsRepositoryProvider);
        final recurrenceDates = _recurrenceConfig!.calculateOccurrences(
          startLocal,
        );
        final duration = endLocal.difference(startLocal);
        final conflictStrategy = _recurrenceConfig!.conflictStrategy;
        final existingEvents = await _loadExistingEventsForRecurrence(
          repo: repo,
          businessId: businessId,
          recurrenceDates: recurrenceDates,
          duration: duration,
        );
        final plannedIntervals = <({DateTime start, DateTime end})>[];
        final conflictByRecurrenceIndex = <int, bool>{};
        final previewDates = <PreviewDateItem>[
          for (var i = 0; i < recurrenceDates.length; i++)
            PreviewDateItem(
              recurrenceIndex: i + 1,
              startTime: recurrenceDates[i],
              endTime: recurrenceDates[i].add(duration),
              hasConflict: (() {
                final occurrenceStart = recurrenceDates[i];
                final occurrenceEnd = occurrenceStart.add(duration);
                final hasConflict = _hasStaffConflict(
                  occurrenceStart: occurrenceStart,
                  occurrenceEnd: occurrenceEnd,
                  existingEvents: existingEvents,
                  plannedIntervals: plannedIntervals,
                );
                if (!hasConflict) {
                  plannedIntervals.add(
                    (start: occurrenceStart, end: occurrenceEnd),
                  );
                }
                conflictByRecurrenceIndex[i + 1] = hasConflict;
                return hasConflict;
              })(),
            ),
        ];
        final preview = RecurringPreviewResult(
          totalDates: previewDates.length,
          dates: previewDates,
        );

        if (!mounted) return;
        final excludedIndices = await RecurrencePreviewDialog.show(
          context,
          preview,
          titleText: l10n.classEventsRecurrencePreviewTitle,
          hintText: l10n.classEventsRecurrencePreviewHint,
          confirmLabelBuilder: (count) =>
              l10n.classEventsRecurrencePreviewConfirm(count),
          excludeConflictsByDefault: conflictStrategy == ConflictStrategy.skip,
        );
        if (excludedIndices == null) return;
        final excludedSet = excludedIndices.toSet();

        var createdCount = 0;
        var skippedCount = 0;
        Object? firstError;

        for (var i = 0; i < recurrenceDates.length; i++) {
          final recurrenceIndex = i + 1;
          if (excludedSet.contains(recurrenceIndex)) {
            skippedCount++;
            continue;
          }
          if (conflictStrategy == ConflictStrategy.skip &&
              (conflictByRecurrenceIndex[recurrenceIndex] ?? false)) {
            skippedCount++;
            continue;
          }
          final occurrenceStart = recurrenceDates[i];
          final occurrenceEnd = occurrenceStart.add(duration);
          try {
            await repo.create(
              businessId: businessId,
              payload: {
                'class_type_id': _classTypeId!,
                'starts_at': _toApiLocalDateTime(occurrenceStart),
                'ends_at': _toApiLocalDateTime(occurrenceEnd),
                'location_id': _locationId!,
                'staff_id': _staffId!,
                'capacity_total': capacity,
              },
            );
            createdCount++;
          } catch (error) {
            skippedCount++;
            firstError ??= error;
            if (conflictStrategy == ConflictStrategy.force) {
              rethrow;
            }
          }
        }

        ref.invalidate(classEventsProvider);
        ref.invalidate(allClassEventsByTypeProvider(_classTypeId!));
        ref.invalidate(upcomingClassEventsByTypeProvider(_classTypeId!));
        ref.invalidate(upcomingClassEventsCountByTypeProvider(_classTypeId!));

        if (createdCount == 0 && firstError != null) {
          throw firstError;
        }

        if (mounted) {
          final isIt = Localizations.localeOf(context).languageCode == 'it';
          final recurrenceMessage = skippedCount > 0
              ? (isIt
                    ? 'Programmazioni create: $createdCount. Saltate: $skippedCount.'
                    : 'Schedules created: $createdCount. Skipped: $skippedCount.')
              : (isIt
                    ? 'Programmazioni create: $createdCount.'
                    : 'Schedules created: $createdCount.');
          await FeedbackDialog.showSuccess(
            context,
            title: l10n.classEventsCreateSuccessTitle,
            message: recurrenceMessage,
          );
        }
      }
      if (!mounted) return;
      setState(() {
        _showSchedulingForm = false;
      });
      if (_recurrenceConfig == null) {
        await FeedbackDialog.showSuccess(
          context,
          title: l10n.classEventsCreateSuccessTitle,
          message: l10n.classEventsCreateSuccessMessage,
        );
      }
    } catch (error) {
      if (!mounted) return;
      final message = error is ApiException
          ? error.message
          : l10n.classEventsCreateErrorMessage;
      await FeedbackDialog.showError(
        context,
        title: l10n.errorTitle,
        message: message,
      );
    }
  }

  void _applyEventToForm(ClassEvent event) {
    final startsAtLocal = event.startsAtLocal ?? event.startsAtUtc.toLocal();
    final endsAtLocal = event.endsAtLocal ?? event.endsAtUtc.toLocal();
    _classTypeId = event.classTypeId;
    _locationId = event.locationId;
    _staffId = event.staffId;
    _capacityController.text = event.capacityTotal.toString();
    _date = DateTime(
      startsAtLocal.year,
      startsAtLocal.month,
      startsAtLocal.day,
    );
    _startTime = TimeOfDay(hour: startsAtLocal.hour, minute: startsAtLocal.minute);
    _endTime = TimeOfDay(hour: endsAtLocal.hour, minute: endsAtLocal.minute);
    _recurrenceConfig = null;
  }

  _CreateClassDraft _captureCurrentDraft() {
    return _CreateClassDraft(
      classTypeId: _classTypeId,
      locationId: _locationId,
      staffId: _staffId,
      date: _date,
      startTime: _startTime,
      endTime: _endTime,
      capacityText: _capacityController.text,
      recurrenceConfig: _recurrenceConfig,
    );
  }

  void _restoreDraft(_CreateClassDraft draft) {
    _classTypeId = draft.classTypeId;
    _locationId = draft.locationId;
    _staffId = draft.staffId;
    _date = draft.date;
    _startTime = draft.startTime;
    _endTime = draft.endTime;
    _capacityController.text = draft.capacityText;
    _recurrenceConfig = draft.recurrenceConfig;
  }

  int _readUpcomingCountSync() {
    final classTypeId = _classTypeId;
    if (classTypeId == null) return 0;
    final async = ref.read(upcomingClassEventsByTypeProvider(classTypeId));
    return async.asData?.value.length ?? 0;
  }

  String _formatDate(DateTime value) {
    final day = value.day.toString().padLeft(2, '0');
    final month = value.month.toString().padLeft(2, '0');
    return '$day/$month/${value.year}';
  }

  String _toApiLocalDateTime(DateTime value) {
    final y = value.year.toString().padLeft(4, '0');
    final m = value.month.toString().padLeft(2, '0');
    final d = value.day.toString().padLeft(2, '0');
    final h = value.hour.toString().padLeft(2, '0');
    final min = value.minute.toString().padLeft(2, '0');
    final s = value.second.toString().padLeft(2, '0');
    return '$y-$m-${d}T$h:$min:$s';
  }

  Future<List<ClassEvent>> _loadExistingEventsForRecurrence({
    required ClassEventsRepository repo,
    required int businessId,
    required List<DateTime> recurrenceDates,
    required Duration duration,
  }) async {
    if (recurrenceDates.isEmpty || _staffId == null) {
      return const <ClassEvent>[];
    }

    final fromLocal = recurrenceDates.first.subtract(const Duration(days: 1));
    final toLocal = recurrenceDates.last.add(duration).add(const Duration(days: 1));
    final events = await repo.listEvents(
      businessId: businessId,
      fromUtc: fromLocal.toUtc(),
      toUtc: toLocal.toUtc(),
    );

    return events.where((event) {
      if (event.status.toUpperCase() == 'CANCELLED') return false;
      return event.staffId == _staffId;
    }).toList();
  }

  bool _hasStaffConflict({
    required DateTime occurrenceStart,
    required DateTime occurrenceEnd,
    required List<ClassEvent> existingEvents,
    required List<({DateTime start, DateTime end})> plannedIntervals,
  }) {
    final occurrenceStartUtc = occurrenceStart.toUtc();
    final occurrenceEndUtc = occurrenceEnd.toUtc();

    final conflictsExisting = existingEvents.any((event) {
      final eventStart = event.startsAtUtc.toUtc();
      final eventEnd = event.endsAtUtc.toUtc();
      return occurrenceStartUtc.isBefore(eventEnd) &&
          eventStart.isBefore(occurrenceEndUtc);
    });
    if (conflictsExisting) return true;

    return plannedIntervals.any((interval) {
      final intervalStartUtc = interval.start.toUtc();
      final intervalEndUtc = interval.end.toUtc();
      return occurrenceStartUtc.isBefore(intervalEndUtc) &&
          intervalStartUtc.isBefore(occurrenceEndUtc);
    });
  }

}

class _CreateClassDraft {
  const _CreateClassDraft({
    required this.classTypeId,
    required this.locationId,
    required this.staffId,
    required this.date,
    required this.startTime,
    required this.endTime,
    required this.capacityText,
    required this.recurrenceConfig,
  });

  final int? classTypeId;
  final int? locationId;
  final int? staffId;
  final DateTime date;
  final TimeOfDay startTime;
  final TimeOfDay endTime;
  final String capacityText;
  final RecurrenceConfig? recurrenceConfig;
}

class _ScheduleTimeField extends StatelessWidget {
  const _ScheduleTimeField({
    required this.label,
    required this.time,
    required this.onTap,
  });

  final String label;
  final TimeOfDay time;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    final hour = time.hour.toString().padLeft(2, '0');
    final minute = time.minute.toString().padLeft(2, '0');
    final theme = Theme.of(context);
    final isDisabled = onTap == null;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(4),
      child: InputDecorator(
        decoration: InputDecoration(
          labelText: label,
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 10,
            vertical: 10,
          ),
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(4)),
          isDense: true,
          enabled: !isDisabled,
        ),
        child: Text(
          '$hour:$minute',
          style: theme.textTheme.bodyMedium?.copyWith(
            color: isDisabled
                ? theme.colorScheme.onSurface.withOpacity(0.5)
                : null,
          ),
        ),
      ),
    );
  }
}

class _ScheduleTimeGridPicker extends StatefulWidget {
  const _ScheduleTimeGridPicker({
    required this.initial,
    required this.stepMinutes,
    required this.title,
    this.useSafeArea = true,
  });

  final TimeOfDay initial;
  final int stepMinutes;
  final String title;
  final bool useSafeArea;

  @override
  State<_ScheduleTimeGridPicker> createState() => _ScheduleTimeGridPickerState();
}

class _ScheduleTimeGridPickerState extends State<_ScheduleTimeGridPicker> {
  late final ScrollController _scrollController;
  late final List<TimeOfDay> _entries;
  late final int _selectedIndex;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();
    _entries = <TimeOfDay>[
      for (int m = 0; m < LayoutConfig.hoursInDay * 60; m += widget.stepMinutes)
        TimeOfDay(hour: m ~/ 60, minute: m % 60),
    ];
    _selectedIndex = _entries.indexWhere(
      (time) =>
          time.hour == widget.initial.hour && time.minute == widget.initial.minute,
    );
    WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToSelected());
  }

  void _scrollToSelected() {
    if (!_scrollController.hasClients || _selectedIndex < 0) return;

    const crossAxisCount = 4;
    const mainAxisSpacing = 6.0;
    const childAspectRatio = 2.7;
    const padding = 12.0;

    final screenWidth = MediaQuery.of(context).size.width;
    final availableWidth = screenWidth - padding * 2;
    final itemWidth = (availableWidth - (crossAxisCount - 1) * 6) / crossAxisCount;
    final itemHeight = itemWidth / childAspectRatio;
    final rowHeight = itemHeight + mainAxisSpacing;
    final targetRow = _selectedIndex ~/ crossAxisCount;

    final viewportHeight = _scrollController.position.viewportDimension;
    const headerOffset = 40.0;
    final targetOffset =
        (targetRow * rowHeight) - (viewportHeight / 2) + (rowHeight / 2) + headerOffset;
    final maxScroll = _scrollController.position.maxScrollExtent;
    final clampedOffset = targetOffset.clamp(0.0, maxScroll);

    _scrollController.animateTo(
      clampedOffset,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeOut,
    );
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final content = Padding(
      padding: const EdgeInsets.all(12),
      child: Column(
        mainAxisSize: MainAxisSize.max,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              const Icon(Icons.schedule, size: 18),
              const SizedBox(width: 8),
              Text(
                widget.title,
                style: const TextStyle(fontWeight: FontWeight.w700),
              ),
            ],
          ),
          const SizedBox(height: 10),
          Expanded(
            child: GridView.builder(
              controller: _scrollController,
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 4,
                mainAxisSpacing: 6,
                crossAxisSpacing: 6,
                childAspectRatio: 2.7,
              ),
              itemCount: _entries.length,
              itemBuilder: (context, index) {
                final time = _entries[index];
                final isSelected = index == _selectedIndex;
                return OutlinedButton(
                  style: OutlinedButton.styleFrom(
                    backgroundColor: isSelected
                        ? Theme.of(context).colorScheme.primary.withOpacity(0.1)
                        : null,
                    side: BorderSide(
                      color: isSelected
                          ? Theme.of(context).colorScheme.primary
                          : Theme.of(context).dividerColor,
                    ),
                    padding: const EdgeInsets.symmetric(horizontal: 8),
                  ),
                  onPressed: () => Navigator.pop(context, time),
                  child: Text(DtFmt.hm(context, time.hour, time.minute)),
                );
              },
            ),
          ),
        ],
      ),
    );

    if (!widget.useSafeArea) return content;
    return SafeArea(child: content);
  }
}

class _PickerField extends StatelessWidget {
  const _PickerField({
    required this.label,
    required this.value,
    required this.icon,
    required this.onTap,
  });

  final String label;
  final String value;
  final IconData icon;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: InputDecorator(
        decoration: InputDecoration(
          labelText: label,
          border: const OutlineInputBorder(),
          suffixIcon: Icon(icon),
        ),
        child: Text(value),
      ),
    );
  }
}
--- FILE: lib/features/agenda/providers/dragged_appointment_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Tiene traccia dell‚Äôappuntamento attualmente trascinato.
/// Nessun delay: il fantasma scompare subito al rilascio.
class DraggedAppointmentIdNotifier extends Notifier<int?> {
  @override
  int? build() => null;

  /// Imposta l'ID dell'appuntamento trascinato
  void set(int id) => state = id;

  /// Cancella immediatamente il fantasma
  void clear() => state = null;
}

final draggedAppointmentIdProvider =
    NotifierProvider<DraggedAppointmentIdNotifier, int?>(
      DraggedAppointmentIdNotifier.new,
    );
--- FILE: lib/features/agenda/providers/layout_config_provider.dart ---
import 'dart:async';
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../domain/config/agenda_theme.dart';
import '../domain/config/layout_config.dart';

part 'layout_config_provider.g.dart';

/// Mantiene aggiornata la configurazione del layout agenda (slot/header/hour column).
@riverpod
class LayoutConfigNotifier extends _$LayoutConfigNotifier {
  Timer? _resizeDebounce;

  @override
  LayoutConfig build() {
    ref.onDispose(() {
      _resizeDebounce?.cancel();
    });
    final dispatcher = WidgetsBinding.instance.platformDispatcher;
    final view = dispatcher.implicitView;
    final logicalSize = view != null
        ? Size(
            view.physicalSize.width / view.devicePixelRatio,
            view.physicalSize.height / view.devicePixelRatio,
          )
        : ui.window.physicalSize / ui.window.devicePixelRatio;

    final initialHeaderHeight = logicalSize.width > 0
        ? LayoutConfig.headerHeightForWidth(logicalSize.width)
        : LayoutConfig.defaultHeaderHeight;
    final initialSlotHeight = logicalSize.height > 0
        ? _deriveSlotHeight(logicalSize.height)
        : LayoutConfig.defaultSlotHeight;
    final initialHourWidth = _initialHourColumnWidth();

    return LayoutConfig.initial.copyWith(
      headerHeight: initialHeaderHeight,
      slotHeight: initialSlotHeight,
      hourColumnWidth: initialHourWidth,
    );
  }

  /// Aggiorna dinamicamente l‚Äôaltezza degli slot e dell‚Äôheader
  /// in base alle dimensioni della finestra.
  void updateFromContext(BuildContext context) {
    _resizeDebounce?.cancel();

    final size = MediaQuery.of(context).size;
    final screenWidth = size.width;
    final screenHeight = size.height;

    _resizeDebounce = Timer(const Duration(milliseconds: 100), () {
      final next = state.copyWith(
        slotHeight: _deriveSlotHeight(screenHeight),
        headerHeight: _deriveHeaderHeight(screenWidth),
        hourColumnWidth: _deriveHourColumnWidth(context),
      );

      if (next != state) {
        state = next;
      }
    });
  }

  double _deriveSlotHeight(double screenHeight) {
    if (screenHeight < 700) {
      return LayoutConfig.defaultSlotHeight * 0.8;
    }
    if (screenHeight > 1200) {
      return LayoutConfig.defaultSlotHeight * 1.2;
    }
    return LayoutConfig.defaultSlotHeight;
  }

  double _deriveHeaderHeight(double screenWidth) =>
      LayoutConfig.headerHeightForWidth(screenWidth);

  double _initialHourColumnWidth() {
    const textDirection = TextDirection.ltr;
    const style = AgendaTheme.hourTextStyle;
    return _computeHourColumnWidth(style, textDirection);
  }

  double _deriveHourColumnWidth(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final style = textTheme.bodyMedium ?? AgendaTheme.hourTextStyle;
    final textDirection = Directionality.maybeOf(context) ?? TextDirection.ltr;

    return _computeHourColumnWidth(style, textDirection);
  }

  double _computeHourColumnWidth(TextStyle style, TextDirection textDirection) {
    final painter = TextPainter(
      text: TextSpan(text: '23:59', style: style),
      textDirection: textDirection,
      maxLines: 1,
    )..layout();

    final baseWidth = painter.width;
    const extraPadding = LayoutConfig.horizontalPadding;
    const safety = 6.0; // margine ridotto oltre il testo

    final computed = baseWidth + extraPadding + safety;
    return computed.clamp(48.0, 80.0);
  }

  /// Aggiorna i minuti per slot in base alla scelta utente.
  void setMinutesPerSlot(int minutes) {
    if (!LayoutConfig.isValidSlotDuration(minutes)) {
      return;
    }

    if (state.minutesPerSlot == minutes) {
      return;
    }

    state = state.copyWith(minutesPerSlot: minutes);
  }

  /// Permette di scegliere se usare la larghezza uniforme sul picco di overlap.
  void setUseClusterMaxConcurrency(bool enabled) {
    if (state.useClusterMaxConcurrency == enabled) {
      return;
    }
    state = state.copyWith(useClusterMaxConcurrency: enabled);
  }

  /// Permette di scegliere se usare il colore del servizio per le card.
  void setUseServiceColors(bool enabled) {
    if (state.useServiceColorsForAppointments == enabled) {
      return;
    }
    state = state.copyWith(useServiceColorsForAppointments: enabled);
  }

  /// Permette di mostrare la label del pulsante "Aggiungi" in topbar.
  void setShowTopbarAddLabel(bool enabled) {
    if (state.showTopbarAddLabel == enabled) {
      return;
    }
    state = state.copyWith(showTopbarAddLabel: enabled);
  }
}
--- FILE: lib/features/agenda/providers/highlighted_staff_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Tiene traccia dello staff evidenziato durante il drag
class HighlightedStaffIdNotifier extends Notifier<int?> {
  @override
  int? build() => null;

  void set(int? id) => state = id;
  void clear() => state = null;
}

final highlightedStaffIdProvider =
    NotifierProvider<HighlightedStaffIdNotifier, int?>(
      HighlightedStaffIdNotifier.new,
    );
--- FILE: lib/features/agenda/providers/dragged_last_staff_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Tiene traccia dell'ultima colonna staff attraversata durante il drag.
class DraggedLastStaffNotifier extends Notifier<int?> {
  @override
  int? build() => null;

  void set(int staffId) => state = staffId;
  void clear() => state = null;
}

final draggedLastStaffIdProvider =
    NotifierProvider<DraggedLastStaffNotifier, int?>(
      DraggedLastStaffNotifier.new,
    );
--- FILE: lib/features/agenda/providers/drag_offset_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Distanza verticale (in px) tra il punto di presa e il bordo superiore della card
class DragOffsetNotifier extends Notifier<double?> {
  @override
  double? build() => null;

  void set(double value) => state = value;
  void clear() => state = null;
}

final dragOffsetProvider = NotifierProvider<DragOffsetNotifier, double?>(
  DragOffsetNotifier.new,
);

/// üîπ Distanza orizzontale (in px) tra il punto di presa e il bordo sinistro della card
class DragOffsetXNotifier extends Notifier<double?> {
  @override
  double? build() => null;

  void set(double value) => state = value;
  void clear() => state = null;
}

final dragOffsetXProvider = NotifierProvider<DragOffsetXNotifier, double?>(
  DragOffsetXNotifier.new,
);
--- FILE: lib/features/agenda/providers/layout_config_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'layout_config_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning
/// Mantiene aggiornata la configurazione del layout agenda (slot/header/hour column).

@ProviderFor(LayoutConfigNotifier)
const layoutConfigProvider = LayoutConfigNotifierProvider._();

/// Mantiene aggiornata la configurazione del layout agenda (slot/header/hour column).
final class LayoutConfigNotifierProvider
    extends $NotifierProvider<LayoutConfigNotifier, LayoutConfig> {
  /// Mantiene aggiornata la configurazione del layout agenda (slot/header/hour column).
  const LayoutConfigNotifierProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'layoutConfigProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$layoutConfigNotifierHash();

  @$internal
  @override
  LayoutConfigNotifier create() => LayoutConfigNotifier();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(LayoutConfig value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<LayoutConfig>(value),
    );
  }
}

String _$layoutConfigNotifierHash() =>
    r'a50c2234a17993d2106f79a9dcb393e753f97c9b';

/// Mantiene aggiornata la configurazione del layout agenda (slot/header/hour column).

abstract class _$LayoutConfigNotifier extends $Notifier<LayoutConfig> {
  LayoutConfig build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<LayoutConfig, LayoutConfig>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<LayoutConfig, LayoutConfig>,
              LayoutConfig,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/features/agenda/providers/dragged_card_size_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Tiene la dimensione (Size) della card attualmente trascinata.
/// Serve per calcolare correttamente la percentuale di overlap orizzontale.
class DraggedCardSizeNotifier extends Notifier<Size?> {
  @override
  Size? build() => null;

  void set(Size size) => state = size;
  void clear() => state = null;
}

final draggedCardSizeProvider =
    NotifierProvider<DraggedCardSizeNotifier, Size?>(
      DraggedCardSizeNotifier.new,
    );
--- FILE: lib/features/agenda/providers/drag_session_provider.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

@immutable
class DragSessionState {
  const DragSessionState({
    this.id,
    this.dropHandled = false,
  });

  final int? id;
  final bool dropHandled;

  DragSessionState copyWith({
    int? id,
    bool? dropHandled,
  }) {
    return DragSessionState(
      id: id ?? this.id,
      dropHandled: dropHandled ?? this.dropHandled,
    );
  }
}

class DragSessionNotifier extends Notifier<DragSessionState> {
  int _counter = 0;

  @override
  DragSessionState build() => const DragSessionState();

  int start() {
    final id = ++_counter;
    state = DragSessionState(id: id, dropHandled: false);
    return id;
  }

  void markHandled() {
    if (state.id == null) return;
    state = state.copyWith(dropHandled: true);
  }

  void clear() {
    state = const DragSessionState();
  }
}

final dragSessionProvider =
    NotifierProvider<DragSessionNotifier, DragSessionState>(
  DragSessionNotifier.new,
);
--- FILE: lib/features/agenda/providers/location_providers.dart ---
import 'package:agenda_backend/core/services/preferences_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/location.dart';
import '../../../core/network/network_providers.dart';
import '../../agenda/providers/business_providers.dart';
import '../../auth/providers/auth_provider.dart';
import '../../auth/providers/current_business_user_provider.dart';
import '../../business/providers/locations_providers.dart';
import '../../business/providers/superadmin_selected_business_provider.dart';

///
/// üîπ Provider per ottenere il business ID da usare per caricare le locations
/// Restituisce null se non c'√® un business valido da caricare
///
final businessIdForLocationsProvider = Provider<int?>((ref) {
  final authState = ref.watch(authProvider);

  // Non caricare se non autenticato
  if (!authState.isAuthenticated) {
    return null;
  }

  // Per superadmin: carica solo se ha selezionato un business
  if (authState.user?.isSuperadmin ?? false) {
    final selectedBusiness = ref.watch(superadminSelectedBusinessProvider);
    return selectedBusiness; // null se non selezionato
  }

  // Per utente normale: usa il business da businessesProvider
  final currentBusinessId = ref.watch(currentBusinessIdProvider);
  return currentBusinessId > 0 ? currentBusinessId : null;
});

///
/// üîπ ELENCO LOCATIONS (da API) - FutureProvider per caricamento asincrono
/// Filtra in base ai permessi dell'utente (scopeType: business o locations)
///
final locationsAsyncProvider = FutureProvider<List<Location>>((ref) async {
  final businessId = ref.watch(businessIdForLocationsProvider);
  final authState = ref.watch(authProvider);

  // Se non c'√® un business valido, ritorna lista vuota
  if (businessId == null || businessId <= 0) {
    return [];
  }

  final isSuperadmin = authState.user?.isSuperadmin ?? false;
  Set<int>? allowedIdsSet;
  if (!isSuperadmin) {
    final context = ref.watch(currentBusinessUserContextProvider).maybeWhen(
          data: (ctx) => ctx,
          orElse: () => null,
        );

    // Evita bootstrap con scope non ancora risolto: senza contesto non esporre sedi.
    if (context == null) {
      return [];
    }

    // Guard rail contro contesto stale durante switch business.
    if (!context.isSuperadmin && context.businessId != businessId) {
      return [];
    }

    if (context.hasLocationScope) {
      allowedIdsSet = context.locationIds.toSet();
    }
  }

  final repository = ref.watch(locationsRepositoryProvider);
  final allLocations = await repository.getByBusinessId(businessId);

  // Filtra solo le location attive
  var locations = allLocations.where((l) => l.isActive).toList();

  // Filtra in base ai permessi utente (scopeType)
  final effectiveAllowedIds = allowedIdsSet;
  if (effectiveAllowedIds != null) {
    // L'utente ha accesso limitato a specifiche location
    locations = locations.where((l) => effectiveAllowedIds.contains(l.id)).toList();
  }

  return locations;
});

///
/// üîπ Provider per verificare se le locations sono caricate
///
final locationsLoadedProvider = Provider<bool>((ref) {
  final asyncValue = ref.watch(locationsAsyncProvider);
  return asyncValue.hasValue || asyncValue.hasError;
});

///
/// üîπ ELENCO LOCATIONS (sincrono per compatibilit√†)
///
class LocationsNotifier extends Notifier<List<Location>> {
  @override
  List<Location> build() {
    // Ascolta il FutureProvider
    final asyncValue = ref.watch(locationsAsyncProvider);
    return asyncValue.when(
      data: (locations) => locations,
      loading: () => [],
      error: (_, __) => [],
    );
  }

  /// Ricarica le locations dall'API
  Future<void> refresh() async {
    ref.invalidate(locationsAsyncProvider);
  }

  /// Crea una nuova location tramite API
  Future<Location> create({
    required String name,
    String? address,
    String? phone,
    String? email,
    String? timezone,
    int? minBookingNoticeHours,
    int? maxBookingAdvanceDays,
    int? cancellationHours,
    bool? allowCustomerChooseStaff,
    bool? isActive,
  }) async {
    final business = ref.read(currentBusinessProvider);
    final repository = ref.read(locationsRepositoryProvider);
    final location = await repository.create(
      businessId: business.id,
      name: name,
      address: address,
      phone: phone,
      email: email,
      timezone: timezone,
      minBookingNoticeHours: minBookingNoticeHours,
      maxBookingAdvanceDays: maxBookingAdvanceDays,
      cancellationHours: cancellationHours,
      allowCustomerChooseStaff: allowCustomerChooseStaff,
      isActive: isActive,
    );
    state = [...state, location];
    return location;
  }

  /// Aggiorna una location esistente tramite API
  Future<Location> updateLocation({
    required int locationId,
    String? name,
    String? address,
    String? phone,
    String? email,
    String? timezone,
    int? minBookingNoticeHours,
    int? maxBookingAdvanceDays,
    int? cancellationHours,
    bool? allowCustomerChooseStaff,
    int? onlineBookingSlotIntervalMinutes,
    String? slotDisplayMode,
    int? minGapMinutes,
    bool? isActive,
  }) async {
    final repository = ref.read(locationsRepositoryProvider);
    final updated = await repository.update(
      locationId: locationId,
      name: name,
      address: address,
      phone: phone,
      email: email,
      timezone: timezone,
      minBookingNoticeHours: minBookingNoticeHours,
      maxBookingAdvanceDays: maxBookingAdvanceDays,
      cancellationHours: cancellationHours,
      allowCustomerChooseStaff: allowCustomerChooseStaff,
      onlineBookingSlotIntervalMinutes: onlineBookingSlotIntervalMinutes,
      slotDisplayMode: slotDisplayMode,
      minGapMinutes: minGapMinutes,
      isActive: isActive,
    );
    state = [
      for (final l in state)
        if (l.id == updated.id) updated else l,
    ];
    return updated;
  }

  /// Elimina una location tramite API
  /// [currentLocationId] deve essere passato dal chiamante per evitare dipendenza circolare
  Future<void> deleteLocation(int id, {required int currentLocationId}) async {
    final repository = ref.read(locationsRepositoryProvider);

    await repository.delete(id);

    final filtered = state.where((l) => l.id != id).toList();
    state = filtered;

    // Se era la location corrente, passa alla prima disponibile
    if (filtered.isNotEmpty && currentLocationId == id) {
      ref.read(currentLocationIdProvider.notifier).set(filtered.first.id);
    }
  }

  // === Metodi locali per UI (senza API) ===

  void add(Location location) {
    state = [...state, location];
  }

  void updateItem(Location updated) {
    state = [
      for (final l in state)
        if (l.id == updated.id) updated else l,
    ];
  }

  void delete(int id, {int? currentLocationId}) {
    final filtered = state.where((l) => l.id != id).toList();
    state = filtered;
    if (filtered.isEmpty) return;
    // Se era la location corrente, passa alla prima disponibile
    if (currentLocationId != null && currentLocationId == id) {
      ref.read(currentLocationIdProvider.notifier).set(filtered.first.id);
    }
  }

  Future<void> reorder(int oldIndex, int newIndex) async {
    if (newIndex > oldIndex) newIndex -= 1;
    final list = [...state];
    final item = list.removeAt(oldIndex);
    list.insert(newIndex, item);

    // Aggiorna sortOrder locale
    final reordered = <Location>[];
    for (int i = 0; i < list.length; i++) {
      reordered.add(list[i].copyWith(sortOrder: i));
    }
    state = reordered;

    // Persist to API
    await _persistLocationsOrder(reordered);
  }

  /// Persiste l'ordine delle locations via API
  Future<void> _persistLocationsOrder(List<Location> locations) async {
    try {
      final apiClient = ref.read(apiClientProvider);
      await apiClient.reorderLocations(
        locations: locations
            .map((l) => {'id': l.id, 'sort_order': l.sortOrder})
            .toList(),
      );
    } catch (_) {
      // Ignora errore - utente pu√≤ riprovare
    }
  }

  int nextId() {
    if (state.isEmpty) return 1;
    final maxId = state.map((l) => l.id).reduce((a, b) => a > b ? a : b);
    return maxId + 1;
  }
}

final locationsProvider = NotifierProvider<LocationsNotifier, List<Location>>(
  LocationsNotifier.new,
);

///
/// üîπ LOCATION CORRENTE
///
class CurrentLocationId extends Notifier<int> {
  @override
  int build() {
    final businessId = ref.watch(businessIdForLocationsProvider);
    final locations = ref.watch(locationsProvider);

    // Se non abbiamo locations valide, ritorna 0
    if (locations.isEmpty || businessId == null || businessId <= 0) {
      return 0;
    }

    // Primo caricamento: prova a caricare da preferenze
    final prefs = ref.read(preferencesServiceProvider);
    final savedId = prefs.getCurrentLocationId(businessId);

    // Se c'√® una preferenza salvata e la location esiste ancora, usala
    if (savedId != null && locations.any((l) => l.id == savedId)) {
      return savedId;
    }

    // Altrimenti usa la location di default
    final defaultLocation = locations.firstWhere(
      (l) => l.isDefault,
      orElse: () => locations.first,
    );
    return defaultLocation.id;
  }

  void set(int id) {
    state = id;
    // Salva in preferenze
    final businessId = ref.read(businessIdForLocationsProvider);
    if (businessId != null && businessId > 0) {
      ref.read(preferencesServiceProvider).setCurrentLocationId(businessId, id);
    }
  }
}

final currentLocationIdProvider = NotifierProvider<CurrentLocationId, int>(
  CurrentLocationId.new,
);

final currentLocationProvider = Provider<Location>((ref) {
  final locations = ref.watch(locationsProvider);
  final currentId = ref.watch(currentLocationIdProvider);

  if (locations.isEmpty || currentId == 0) {
    // Ritorna location placeholder mentre carica
    return Location(
      id: 0,
      businessId: 0,
      name: 'Loading...',
      isDefault: false,
      isActive: true,
    );
  }

  return locations.firstWhere(
    (l) => l.id == currentId,
    orElse: () => locations.first,
  );
});

///
/// üîπ VALUTA EFFETTIVA DELLA LOCATION CORRENTE
///
/// Se la location ha una valuta specifica, viene usata.
/// Altrimenti eredita quella del business.
///
final effectiveCurrencyProvider = Provider<String>((ref) {
  final location = ref.watch(currentLocationProvider);
  final business = ref.watch(currentBusinessProvider);
  return location.currency ?? business.currency;
});
--- FILE: lib/features/agenda/providers/business_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/business.dart';
import '../../auth/providers/auth_provider.dart';
import '../../business/providers/business_providers.dart';
import '../../business/providers/superadmin_selected_business_provider.dart';

/// Notifier per forzare il refresh della lista business
class BusinessesRefreshNotifier extends Notifier<int> {
  @override
  int build() => 0;

  void refresh() => state++;
}

final businessesRefreshProvider =
    NotifierProvider<BusinessesRefreshNotifier, int>(
      BusinessesRefreshNotifier.new,
    );

///
/// üîπ ELENCO BUSINESS (da API)
/// Se l'utente √® superadmin, usa endpoint admin.
///
final businessesProvider = FutureProvider<List<Business>>((ref) async {
  // Watch del refresh provider per forzare il ricaricamento
  ref.watch(businessesRefreshProvider);

  final authState = ref.watch(authProvider);

  // ‚ö†Ô∏è Non fare chiamate API se l'utente non √® autenticato
  if (!authState.isAuthenticated) {
    return [];
  }

  final repository = ref.watch(businessRepositoryProvider);

  if (authState.user?.isSuperadmin ?? false) {
    return repository.getAllAdmin();
  }
  return repository.getAll();
});

///
/// üîπ BUSINESS CORRENTE (ID)
///
class CurrentBusinessId extends Notifier<int> {
  int _lastKnownBusinessId = 0;

  @override
  int build() {
    // ‚úÖ Imposta come default il business selezionato (superadmin)
    // oppure il primo business disponibile.
    final authState = ref.watch(authProvider);
    final isSuperadmin = authState.user?.isSuperadmin ?? false;

    // Allinea al business selezionato quando cambia
    // NOTE: non usare fireImmediately qui per evitare letture di `state`
    // prima dell'inizializzazione del provider.
    ref.listen(superadminSelectedBusinessProvider, (previous, next) {
      if (!isSuperadmin) return;
      if (next != null && state != next) {
        _lastKnownBusinessId = next;
        state = next;
      }
    });

    // Aspetta che businessesProvider carichi i dati
    ref.listen(businessesProvider, (previous, next) {
      next.whenData((businesses) {
        if (businesses.isEmpty) {
          if (state != 0) {
            _lastKnownBusinessId = 0;
            state = 0;
          }
          return;
        }

        final selectedBusiness = ref.read(superadminSelectedBusinessProvider);

        if (isSuperadmin && selectedBusiness != null) {
          final exists = businesses.any((b) => b.id == selectedBusiness);
          if (exists) {
            if (state != selectedBusiness) {
              _lastKnownBusinessId = selectedBusiness;
              state = selectedBusiness;
            }
            return;
          }

          // Business non pi√π valido: pulisci preferenze e fallback al primo
          ref
              .read(superadminSelectedBusinessProvider.notifier)
              .clearCompletely();
          if (state != businesses.first.id) {
            _lastKnownBusinessId = businesses.first.id;
            state = businesses.first.id;
          }
          return;
        }

        // Utente non superadmin:
        // mantieni sempre un business valido (mai 0) per evitare rimbalzi di routing
        // quando la lista viene ricaricata o cambia dinamicamente.
        if (state == 0) {
          _lastKnownBusinessId = businesses.first.id;
          state = businesses.first.id;
          return;
        }

        // Se il business corrente non √® pi√π accessibile, fallback al primo disponibile.
        if (!businesses.any((b) => b.id == state)) {
          _lastKnownBusinessId = businesses.first.id;
          state = businesses.first.id;
          return;
        }
      });
    });

    // Inizializzazione deterministica senza leggere `state` in listener immediati.
    final businessesAsync = ref.watch(businessesProvider);
    return businessesAsync.when(
      data: (businesses) {
        if (businesses.isEmpty) return 0;
        final selectedBusiness = ref.watch(superadminSelectedBusinessProvider);
        if (isSuperadmin && selectedBusiness != null) {
          if (businesses.any((b) => b.id == selectedBusiness)) {
            _lastKnownBusinessId = selectedBusiness;
            return selectedBusiness;
          }
        }
        _lastKnownBusinessId = businesses.first.id;
        return businesses.first.id;
      },
      loading: () => _lastKnownBusinessId,
      error: (_, __) => _lastKnownBusinessId,
    );
  }

  /// Selezione esplicita effettuata dall'utente (switch business).
  void selectByUser(int id) {
    if (state != id) {
      _lastKnownBusinessId = id;
      state = id;
    }
  }
}

final currentBusinessIdProvider = NotifierProvider<CurrentBusinessId, int>(
  CurrentBusinessId.new,
);

///
/// üîπ BUSINESS CORRENTE (oggetto)
///
final currentBusinessProvider = Provider<Business>((ref) {
  final businessesAsync = ref.watch(businessesProvider);
  final currentId = ref.watch(currentBusinessIdProvider);

  return businessesAsync.when(
    data: (businesses) {
      if (businesses.isEmpty) {
        return Business(id: 0, name: 'Loading...', createdAt: DateTime.now());
      }

      if (currentId <= 0) {
        return businesses.first;
      }

      final match = businesses.where((b) => b.id == currentId);
      if (match.isNotEmpty) {
        return match.first;
      }

      // Evita fallback silenzioso al primo business quando l'ID corrente
      // √® stale/non valido: i provider dipendenti attendono un ID valido.
      return Business(id: 0, name: 'Loading...', createdAt: DateTime.now());
    },
    loading: () =>
        Business(id: currentId, name: 'Loading...', createdAt: DateTime.now()),
    error: (_, __) =>
        Business(id: currentId, name: 'Error', createdAt: DateTime.now()),
  );
});
--- FILE: lib/features/agenda/providers/appointment_providers.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';

import '../../../core/models/appointment.dart';
import '../../auth/providers/auth_provider.dart';
import '../../auth/providers/current_business_user_provider.dart';
import '../../clients/providers/clients_providers.dart';
import '../../services/providers/services_provider.dart';
import 'booking_reschedule_provider.dart';
import 'bookings_provider.dart';
import 'bookings_repository_provider.dart';
import 'business_providers.dart';
import 'date_range_provider.dart';
import 'location_providers.dart';

/// Arrotonda un DateTime ai 5 minuti pi√π vicini.
/// Es: 10:12 ‚Üí 10:10, 10:13 ‚Üí 10:15
DateTime _roundToNearestFiveMinutes(DateTime dt) {
  final minutes = dt.minute;
  final roundedMinutes = ((minutes + 2) ~/ 5) * 5;
  return DateTime(
    dt.year,
    dt.month,
    dt.day,
    dt.hour,
    0,
  ).add(Duration(minutes: roundedMinutes));
}

class AppointmentsNotifier extends AsyncNotifier<List<Appointment>> {
  @override
  Future<List<Appointment>> build() async {
    // Verifica autenticazione
    final authState = ref.watch(authProvider);
    if (!authState.isAuthenticated) {
      return [];
    }

    final repository = ref.watch(bookingsRepositoryProvider);
    final location = ref.watch(currentLocationProvider);
    final business = ref.watch(currentBusinessProvider);
    final date = ref.watch(agendaDateProvider);

    if (location.id <= 0) {
      return [];
    }

    // Usa il nuovo metodo che ritorna anche i metadata dei booking (incluse le note)
    final result = await repository.getAppointmentsWithMetadata(
      locationId: location.id,
      businessId: business.id,
      date: date,
    );

    // Popola bookingsProvider con i metadata dei booking (incluse le note)
    final bookingsNotifier = ref.read(bookingsProvider.notifier);
    for (final entry in result.bookingMetadata.entries) {
      final metadata = entry.value;
      bookingsNotifier.ensureBooking(
        bookingId: metadata.id,
        businessId: metadata.businessId,
        locationId: metadata.locationId,
        clientId: metadata.clientId,
        clientName: metadata.clientName ?? '',
        notes: metadata.notes,
        status: metadata.status ?? 'confirmed',
      );
    }

    return result.appointments;
  }

  /// Restituisce gli appointments associati a un booking specifico,
  /// ordinati per orario di inizio.
  List<Appointment> getByBookingId(int bookingId) {
    final currentList = state.value ?? [];
    return currentList.where((a) => a.bookingId == bookingId).toList()
      ..sort((a, b) => a.startTime.compareTo(b.startTime));
  }

  void moveAppointment({
    required int appointmentId,
    required int newStaffId,
    required DateTime newStart,
    required DateTime newEnd,
  }) async {
    final currentList = state.value;
    if (currentList == null) return;

    // Trova l'appointment originale per calcolare extra blocked
    final originalAppt = currentList.firstWhere(
      (a) => a.id == appointmentId,
      orElse: () => throw Exception('Appointment not found'),
    );

    // Arrotonda gli orari a multipli di 5 minuti
    final roundedStart = _roundToNearestFiveMinutes(newStart);
    final duration = newEnd.difference(newStart);
    final roundedEnd = roundedStart.add(duration);

    // Calcola extra blocked minutes
    final oldTotalMinutes = originalAppt.endTime
        .difference(originalAppt.startTime)
        .inMinutes;
    final newTotalMinutes = roundedEnd.difference(roundedStart).inMinutes;
    final oldBlocked = originalAppt.blockedExtraMinutes;
    final baseMinutes = oldTotalMinutes - oldBlocked;

    int newBlocked = oldBlocked;
    if (newTotalMinutes <= baseMinutes) {
      newBlocked = 0;
    } else {
      newBlocked = newTotalMinutes - baseMinutes;
    }

    final newList = [
      for (final appt in currentList)
        if (appt.id == appointmentId)
          _applyResizeToAppointment(
            appt,
            staffId: newStaffId,
            startTime: roundedStart,
            endTime: roundedEnd,
          )
        else
          appt,
    ];

    state = AsyncData(newList);

    // API update: chiama l'API per reschedule appointment
    final location = ref.read(currentLocationProvider);
    final repository = ref.read(bookingsRepositoryProvider);

    try {
      await repository.updateAppointment(
        locationId: location.id,
        appointmentId: appointmentId,
        startTime: roundedStart,
        endTime: roundedEnd,
        staffId: newStaffId,
        extraBlockedMinutes: newBlocked,
      );
    } catch (_) {
      // Rollback on error
      state = AsyncData(currentList);
    }
  }

  Future<bool> moveBookingByAnchor({
    required BookingRescheduleSession session,
    required DateTime targetStart,
    required int targetStaffId,
  }) async {
    if (session.items.isEmpty) return false;
    final currentList = state.value;

    final anchor = session.items.firstWhere(
      (i) => i.appointmentId == session.anchorAppointmentId,
      orElse: () => session.items.first,
    );
    final delta = targetStart.difference(anchor.startTime);

    final updates = <int, ({Appointment appointment, int blockedMinutes})>{};
    final updatedStarts = <int, DateTime>{};
    final updatedEnds = <int, DateTime>{};
    final updatedStaffIds = <int, int>{};
    final updatedBlocked = <int, int>{};

    for (final item in session.items) {
      final rawStart = item.startTime.add(delta);
      final rawEnd = item.endTime.add(delta);

      final roundedStart = _roundToNearestFiveMinutes(rawStart);
      final duration = rawEnd.difference(rawStart);
      final roundedEnd = roundedStart.add(duration);

      final oldTotalMinutes = item.endTime.difference(item.startTime).inMinutes;
      final newTotalMinutes = roundedEnd.difference(roundedStart).inMinutes;
      final oldBlocked = item.blockedExtraMinutes;
      final baseMinutes = oldTotalMinutes - oldBlocked;

      int newBlocked = oldBlocked;
      if (newTotalMinutes <= baseMinutes) {
        newBlocked = 0;
      } else {
        newBlocked = newTotalMinutes - baseMinutes;
      }

      final newStaffId = item.appointmentId == anchor.appointmentId
          ? targetStaffId
          : item.staffId;

      updatedStarts[item.appointmentId] = roundedStart;
      updatedEnds[item.appointmentId] = roundedEnd;
      updatedStaffIds[item.appointmentId] = newStaffId;
      updatedBlocked[item.appointmentId] = newBlocked;
    }

    if (currentList != null) {
      for (final appt in currentList) {
        if (!updatedStarts.containsKey(appt.id)) continue;
        updates[appt.id] = (
          appointment: _applyResizeToAppointment(
            appt,
            staffId: updatedStaffIds[appt.id]!,
            startTime: updatedStarts[appt.id]!,
            endTime: updatedEnds[appt.id]!,
          ),
          blockedMinutes: updatedBlocked[appt.id]!,
        );
      }

      final optimistic = [
        for (final appt in currentList)
          if (updates.containsKey(appt.id)) updates[appt.id]!.appointment else appt,
      ];
      state = AsyncData(optimistic);
    }

    final location = ref.read(currentLocationProvider);
    final repository = ref.read(bookingsRepositoryProvider);

    try {
      for (final item in session.items) {
        await repository.updateAppointment(
          locationId: location.id,
          appointmentId: item.appointmentId,
          startTime: updatedStarts[item.appointmentId],
          endTime: updatedEnds[item.appointmentId],
          staffId: updatedStaffIds[item.appointmentId],
          extraBlockedMinutes: updatedBlocked[item.appointmentId],
        );
      }
      ref.invalidateSelf();
      return true;
    } catch (_) {
      if (currentList != null) {
        state = AsyncData(currentList);
      }
      return false;
    }
  }

  Appointment _applyResizeToAppointment(
    Appointment appt, {
    required int staffId,
    required DateTime startTime,
    required DateTime endTime,
  }) {
    final oldTotalMinutes = appt.endTime.difference(appt.startTime).inMinutes;
    final newTotalMinutes = endTime.difference(startTime).inMinutes;
    final oldBlocked = appt.blockedExtraMinutes;
    final baseMinutes = oldTotalMinutes - oldBlocked;

    int newBlocked = oldBlocked;
    if (newTotalMinutes <= baseMinutes) {
      newBlocked = 0;
    } else {
      newBlocked = newTotalMinutes - baseMinutes;
    }

    final processingMinutes = appt.processingExtraMinutes;
    final extraMinutesType = newBlocked > 0
        ? ExtraMinutesType.blocked
        : (processingMinutes > 0 ? ExtraMinutesType.processing : null);
    final extraMinutes = extraMinutesType == ExtraMinutesType.blocked
        ? newBlocked
        : (extraMinutesType == ExtraMinutesType.processing
              ? processingMinutes
              : null);

    return appt.copyWith(
      staffId: staffId,
      startTime: startTime,
      endTime: endTime,
      extraMinutes: extraMinutes,
      extraMinutesType: extraMinutesType,
      extraBlockedMinutes: newBlocked,
      extraProcessingMinutes: processingMinutes,
    );
  }

  /// Elimina un singolo appuntamento (booking_item).
  /// Usa deleteBookingItem per eliminare solo l'item, non l'intero booking.
  void deleteAppointment(int appointmentId) async {
    final currentList = state.value;
    if (currentList == null) return;

    int? relatedBookingId;
    for (final appt in currentList) {
      if (appt.id == appointmentId) {
        relatedBookingId = appt.bookingId;
        break;
      }
    }

    // Se non troviamo il booking, non possiamo eliminare
    if (relatedBookingId == null) {
      return;
    }

    final newList = [
      for (final appt in currentList)
        if (appt.id != appointmentId) appt,
    ];

    state = AsyncData(newList);

    // Aggiorna lo stato locale dei bookings se vuoto
    ref.read(bookingsProvider.notifier).removeIfEmpty(relatedBookingId);

    // API delete: elimina il singolo booking_item
    final repository = ref.read(bookingsRepositoryProvider);

    try {
      await repository.deleteBookingItem(
        bookingId: relatedBookingId,
        itemId: appointmentId,
      );
    } catch (_) {
      // Rollback on error
      state = AsyncData(currentList);
    }
  }

  /// Aggiunge un nuovo appuntamento chiamando l'API
  /// Se bookingId √® fornito, aggiunge un item a un booking esistente
  /// Altrimenti crea un nuovo booking
  Future<Appointment?> addAppointment({
    int? bookingId,
    required int staffId,
    required int serviceId,
    required int serviceVariantId,
    int? clientId,
    required String clientName,
    required String serviceName,
    required DateTime start,
    required DateTime end,
    double? price,
    int? extraMinutes,
    ExtraMinutesType? extraMinutesType,
    int? extraBlockedMinutes,
    int? extraProcessingMinutes,
  }) async {
    final location = ref.read(currentLocationProvider);
    final repository = ref.read(bookingsRepositoryProvider);

    // Arrotonda gli orari a multipli di 5 minuti
    final roundedStart = _roundToNearestFiveMinutes(start);
    final duration = end.difference(start);
    final roundedEnd = roundedStart.add(duration);

    try {
      // Se bookingId √® fornito, aggiungi un item al booking esistente
      if (bookingId != null) {
        final created = await repository.addBookingItem(
          bookingId: bookingId,
          businessId: location.businessId,
          locationId: location.id,
          staffId: staffId,
          serviceId: serviceId,
          serviceVariantId: serviceVariantId,
          startTime: roundedStart,
          endTime: roundedEnd,
          serviceNameSnapshot: serviceName,
          clientNameSnapshot: clientName,
          price: price,
          extraBlockedMinutes: extraBlockedMinutes,
          extraProcessingMinutes: extraProcessingMinutes,
        );

        // Aggiorna lo state locale con il nuovo appuntamento
        final currentList = state.value ?? [];
        state = AsyncData([...currentList, created]);

        return created;
      }

      // Altrimenti crea un nuovo booking
      final bookingResponse = await repository.createBooking(
        locationId: location.id,
        idempotencyKey: const Uuid().v4(),
        serviceIds: [serviceId],
        startTime: roundedStart.toIso8601String(),
        staffId: staffId,
        clientId: clientId,
        notes: null,
      );

      // Refresh state to get the new appointment with correct ID
      ref.invalidateSelf();
      await future; // Wait for refresh

      // Try to find the newly created appointment
      // Since we don't know the ID, we can look for one that matches the bookingId from response
      final currentList = state.value ?? [];
      final created = currentList.firstWhere(
        (a) => a.bookingId == bookingResponse.id,
        orElse: () => throw Exception('Appointment not found after creation'),
      );

      // Ensure booking metadata exists locally (if needed, but API should handle it)
      ref
          .read(bookingsProvider.notifier)
          .ensureBooking(
            bookingId: bookingResponse.id,
            businessId: bookingResponse.businessId,
            locationId: bookingResponse.locationId,
            clientId: bookingResponse.clientId,
            clientName: bookingResponse.clientName ?? clientName,
            notes: bookingResponse.notes,
            status: bookingResponse.status,
            replacesBookingId: bookingResponse.replacesBookingId,
            replacedByBookingId: bookingResponse.replacedByBookingId,
          );

      return created;
    } catch (_) {
      return null;
    }
  }

  /// Aggiorna un appuntamento esistente (match per id)
  Future<void> updateAppointment(Appointment updated) async {
    final currentList = state.value;
    if (currentList == null) return;

    // Arrotonda gli orari a multipli di 5 minuti
    final roundedStart = _roundToNearestFiveMinutes(updated.startTime);
    final duration = updated.endTime.difference(updated.startTime);
    final roundedEnd = roundedStart.add(duration);
    final roundedAppointment = updated.copyWith(
      startTime: roundedStart,
      endTime: roundedEnd,
    );

    final newList = [
      for (final appt in currentList)
        if (appt.id == updated.id) roundedAppointment else appt,
    ];

    state = AsyncData(newList);

    // API update: chiama l'API per reschedule appointment
    final location = ref.read(currentLocationProvider);
    final repository = ref.read(bookingsRepositoryProvider);

    try {
      await repository.updateAppointment(
        locationId: location.id,
        appointmentId: updated.id,
        startTime: roundedStart,
        endTime: roundedEnd,
        staffId: updated.staffId,
        serviceId: updated.serviceId,
        serviceVariantId: updated.serviceVariantId,
        serviceNameSnapshot: updated.serviceName,
        clientId: updated.clientId,
        clientName: updated.clientName,
        clientNameSnapshot: updated.clientName,
        extraBlockedMinutes: updated.extraBlockedMinutes,
        extraProcessingMinutes: updated.extraProcessingMinutes,
        price: updated.price,
        priceExplicitlySet: true,
      );
    } catch (_) {
      // Rollback on error
      state = AsyncData(currentList);
    }
  }

  /// Aggiorna il cliente di tutti gli appuntamenti di una prenotazione.
  /// Chiama l'API per persistere la modifica del client_id nel booking.
  Future<void> updateClientForBooking({
    required int bookingId,
    required int? clientId,
    required String clientName,
  }) async {
    final currentList = state.value;
    if (currentList == null) return;

    // Aggiornamento locale immediato per la UI
    final newList = [
      for (final appt in currentList)
        if (appt.bookingId == bookingId)
          appt.copyWith(clientId: clientId, clientName: clientName)
        else
          appt,
    ];

    state = AsyncData(newList);

    // Chiama API per persistere la modifica
    try {
      final repository = ref.read(bookingsRepositoryProvider);
      final location = ref.read(currentLocationProvider);

      await repository.updateBooking(
        locationId: location.id,
        bookingId: bookingId,
        clientId: clientId,
        clearClient: clientId == null, // Se null, rimuovi il cliente
      );

      // Aggiorna anche il booking locale
      ref
          .read(bookingsProvider.notifier)
          .updateClientForBooking(
            bookingId: bookingId,
            clientId: clientId,
            clientName: clientName,
          );
    } catch (e) {
      // Rollback: ripristina lo stato precedente
      state = AsyncData(currentList);
      rethrow; // Propaga l'errore per gestirlo nella UI
    }
  }

  /// Aggiorna localmente lo stato booking per tutti gli appuntamenti della prenotazione.
  void setBookingStatusForBooking({
    required int bookingId,
    required String status,
  }) {
    final currentList = state.value;
    if (currentList == null) return;

    state = AsyncData([
      for (final appt in currentList)
        if (appt.bookingId == bookingId)
          appt.copyWith(bookingStatus: status)
        else
          appt,
    ]);
  }

  /// Duplica un appuntamento
  Future<Appointment?> duplicateAppointment(
    Appointment original, {
    bool intoSameBooking = true,
  }) async {
    // If intoSameBooking is true, we should add to existing booking.
    // But createBooking creates a NEW booking.
    // The API doesn't seem to support adding item to existing booking yet (store endpoint creates booking).
    // So we can only support creating new booking for now.

    if (intoSameBooking) {
      // Not supported by API yet (need add item to booking endpoint)
      // Fallback to creating new booking or show error?
      // For now, let's create a new booking anyway but maybe warn?
      // Or just implement local duplication if we want to keep UI working without persistence

      // Let's try to create a new booking for now as duplication usually implies new slot
      return addAppointment(
        staffId: original.staffId,
        serviceId: original.serviceId,
        serviceVariantId: original.serviceVariantId,
        clientId: original.clientId,
        clientName: original.clientName,
        serviceName: original.serviceName,
        start: original.startTime, // Should probably be shifted?
        end: original.endTime,
      );
    } else {
      return addAppointment(
        staffId: original.staffId,
        serviceId: original.serviceId,
        serviceVariantId: original.serviceVariantId,
        clientId: original.clientId,
        clientName: original.clientName,
        serviceName: original.serviceName,
        start: original.startTime,
        end: original.endTime,
      );
    }
  }

  /// Cancella tutti gli appuntamenti appartenenti a una prenotazione.
  Future<void> deleteByBooking(int bookingId) async {
    final currentList = state.value;
    if (currentList == null) return;

    final location = ref.read(currentLocationProvider);
    final repository = ref.read(bookingsRepositoryProvider);
    final bookingsNotifier = ref.read(bookingsProvider.notifier);

    try {
      // Associa esplicitamente lo stato "cancelled" prima della cancellazione
      // definitiva della prenotazione.
      await repository.updateBooking(
        locationId: location.id,
        bookingId: bookingId,
        status: 'cancelled',
      );
      bookingsNotifier.setStatus(bookingId, 'cancelled');
      setBookingStatusForBooking(bookingId: bookingId, status: 'cancelled');

      // Chiama API per cancellare il booking
      await repository.deleteBooking(
        locationId: location.id,
        bookingId: bookingId,
      );

      // Aggiorna lo stato locale
      final newList = [
        for (final appt in currentList)
          if (appt.bookingId != bookingId) appt,
      ];

      state = AsyncData(newList);
    } catch (_) {
      // In caso di errore, mantieni lo stato corrente
    }
  }

  /// Crea rapidamente una prenotazione per un client
  Future<Appointment?> createQuickBookingForClient(int clientId) async {
    final clientsById = ref.read(clientsByIdProvider);
    final client = clientsById[clientId];
    if (client == null) return null;

    final agendaDate = ref.read(agendaDateProvider);
    final variants = ref.read(serviceVariantsProvider).value ?? [];
    if (variants.isEmpty) return null;
    final variant = variants.first;

    // Staff idoneo per il servizio e sede corrente
    final eligibleStaff = ref.read(
      eligibleStaffForServiceProvider(variant.serviceId),
    );
    if (eligibleStaff.isEmpty) return null;
    final staffId = eligibleStaff.first;

    // Orario: prossimo quarto d'ora oggi alle max 18:00
    final now = DateTime.now();
    final dayStart = DateUtils.dateOnly(agendaDate);
    DateTime base = now.isBefore(dayStart) ? dayStart : now;
    // clamp to today end
    final dayEnd = dayStart.add(const Duration(days: 1));
    if (base.isAfter(dayEnd)) base = dayStart.add(const Duration(hours: 10));
    final minutes = base.minute;
    final rounded = minutes % 15 == 0
        ? base
        : base.add(Duration(minutes: 15 - (minutes % 15)));
    final start = DateTime(
      dayStart.year,
      dayStart.month,
      dayStart.day,
      rounded.hour,
      rounded.minute,
    );
    final end = start.add(Duration(minutes: variant.durationMinutes));

    return addAppointment(
      staffId: staffId,
      serviceId: variant.serviceId,
      serviceVariantId: variant.id,
      clientId: client.id,
      clientName: client.name,
      serviceName: '',
      start: start,
      end: end,
      price: variant.price,
    );
  }
}

final appointmentsProvider =
    AsyncNotifierProvider<AppointmentsNotifier, List<Appointment>>(
      AppointmentsNotifier.new,
    );

final appointmentsForCurrentLocationProvider = Provider<List<Appointment>>((
  ref,
) {
  final location = ref.watch(currentLocationProvider);
  final currentDate = ref.watch(agendaDateProvider);
  final dayStart = DateUtils.dateOnly(currentDate);
  final dayEnd = dayStart.add(const Duration(days: 1));
  final appointmentsAsync = ref.watch(appointmentsProvider);
  final appointments = appointmentsAsync.value ?? [];

  // Filtro per ruolo: staff vede solo i propri appuntamenti
  final canViewAll = ref.watch(canViewAllAppointmentsProvider);
  final currentUserStaffId = ref.watch(currentUserStaffIdProvider);

  return [
    for (final appt in appointments)
      if (appt.locationId == location.id &&
          !appt.endTime.isBefore(dayStart) &&
          appt.startTime.isBefore(dayEnd) &&
          // Se pu√≤ vedere tutto, mostra. Altrimenti solo i propri
          (canViewAll ||
              currentUserStaffId == null ||
              appt.staffId == currentUserStaffId))
        appt,
  ];
});
--- FILE: lib/features/agenda/providers/date_range_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class AgendaDateNotifier extends Notifier<DateTime> {
  @override
  DateTime build() {
    final initial = DateUtils.dateOnly(DateTime.now());
    return initial;
  }

  void set(DateTime date) {
    final next = DateUtils.dateOnly(date);
    state = next;
  }

  void nextDay() {
    final next = DateUtils.dateOnly(state.add(const Duration(days: 1)));
    state = next;
  }

  void nextWeek() {
    final next = DateUtils.dateOnly(state.add(const Duration(days: 7)));
    state = next;
  }

  void previousDay() {
    final next = DateUtils.dateOnly(state.subtract(const Duration(days: 1)));
    state = next;
  }

  void previousWeek() {
    final next = DateUtils.dateOnly(state.subtract(const Duration(days: 7)));
    state = next;
  }

  void nextMonth() => _shiftMonths(1);

  void previousMonth() => _shiftMonths(-1);

  void _shiftMonths(int delta) {
    final y = state.year;
    final m = state.month;
    final d = state.day;

    // Convert to absolute month index to avoid loop and off-by-one issues
    final abs = y * 12 + (m - 1) + delta;
    final targetYear = abs ~/ 12;
    final targetMonth = (abs % 12) + 1; // back to 1..12

    final dim = DateUtils.getDaysInMonth(targetYear, targetMonth);
    final int safeDay = d <= dim ? d : dim;
    state = DateUtils.dateOnly(DateTime(targetYear, targetMonth, safeDay));
  }

  void setToday() {
    final today = DateUtils.dateOnly(DateTime.now());
    state = today;
  }
}

final agendaDateProvider = NotifierProvider<AgendaDateNotifier, DateTime>(
  AgendaDateNotifier.new,
);
--- FILE: lib/features/agenda/providers/resource_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/appointment.dart';
import '../../../core/models/resource.dart';
import '../../../core/models/service_variant.dart';
import '../../../core/models/service_variant_resource_requirement.dart';
import '../../../core/network/network_providers.dart';
import '../../auth/providers/auth_provider.dart';
import '../../services/providers/services_provider.dart';
import 'appointment_providers.dart';
import 'business_providers.dart';

///
/// RISORSE (caricamento da API)
///
class ResourcesNotifier extends AsyncNotifier<List<Resource>> {
  @override
  Future<List<Resource>> build() async {
    final authState = ref.watch(authProvider);
    if (!authState.isAuthenticated) {
      return [];
    }

    final apiClient = ref.watch(apiClientProvider);
    final business = ref.watch(currentBusinessProvider);

    // Non caricare se business non √® ancora valido
    if (business.id <= 0) {
      return [];
    }

    try {
      final data = await apiClient.getResourcesByBusiness(business.id);
      return data.map(_parseResource).toList();
    } catch (_) {
      return [];
    }
  }

  Resource _parseResource(Map<String, dynamic> json) {
    return Resource(
      id: json['id'] as int,
      locationId: json['location_id'] as int,
      name: json['name'] as String,
      quantity: json['quantity'] as int? ?? 1,
      type: json['type'] as String?,
      note: json['note'] as String?,
    );
  }

  Future<void> refresh() async {
    final authState = ref.read(authProvider);
    if (!authState.isAuthenticated) {
      state = const AsyncData([]);
      return;
    }

    final business = ref.read(currentBusinessProvider);
    if (business.id <= 0) {
      return;
    }

    state = const AsyncLoading();

    try {
      final apiClient = ref.read(apiClientProvider);
      final data = await apiClient.getResourcesByBusiness(business.id);
      state = AsyncData(data.map(_parseResource).toList());
    } catch (e, st) {
      state = AsyncError(e, st);
    }
  }

  Future<Resource> addResource({
    required int locationId,
    required String name,
    String? type,
    int quantity = 1,
    String? note,
  }) async {
    final apiClient = ref.read(apiClientProvider);
    final data = await apiClient.createResource(
      locationId: locationId,
      name: name,
      type: type,
      quantity: quantity,
      note: note,
    );
    final resource = _parseResource(data);
    final current = state.value ?? [];
    state = AsyncData([...current, resource]);
    return resource;
  }

  Future<Resource> updateResource({
    required int resourceId,
    String? name,
    String? type,
    int? quantity,
    String? note,
  }) async {
    final apiClient = ref.read(apiClientProvider);
    final data = await apiClient.updateResource(
      resourceId: resourceId,
      name: name,
      type: type,
      quantity: quantity,
      note: note,
    );
    final updated = _parseResource(data);
    final current = state.value ?? [];
    state = AsyncData([
      for (final r in current)
        if (r.id == updated.id) updated else r,
    ]);
    return updated;
  }

  Future<void> deleteResource(int id) async {
    final apiClient = ref.read(apiClientProvider);
    await apiClient.deleteResource(id);
    final current = state.value ?? [];
    state = AsyncData([
      for (final r in current)
        if (r.id != id) r,
    ]);
  }
}

final resourcesProvider =
    AsyncNotifierProvider<ResourcesNotifier, List<Resource>>(
      ResourcesNotifier.new,
    );

///
/// RISORSE PER LOCATION
///
final locationResourcesProvider = Provider.family<List<Resource>, int>((
  ref,
  locationId,
) {
  final resourcesAsync = ref.watch(resourcesProvider);
  final resources = resourcesAsync.value ?? [];
  return [
    for (final r in resources)
      if (r.locationId == locationId) r,
  ];
});

///
/// REQUISITI RISORSE PER SERVICE VARIANT
///
final serviceVariantResourcesProvider =
    Provider.family<List<ServiceVariantResourceRequirement>, int>((
      ref,
      serviceVariantId,
    ) {
      final variant = ref.watch(serviceVariantByIdProvider(serviceVariantId));
      return variant?.resourceRequirements ?? const [];
    });

typedef ResourceBookingsParams = ({int resourceId, DateTime day});

///
/// APPOINTMENT CHE OCCUPANO UNA RISORSA IN UN GIORNO
///
final resourceBookingsProvider =
    Provider.family<List<Appointment>, ResourceBookingsParams>((ref, params) {
      final resourceId = params.resourceId;
      final day = params.day;

      final dayStart = DateTime(day.year, day.month, day.day);
      final dayEnd = dayStart.add(const Duration(days: 1));

      final appointments = ref.watch(appointmentsProvider).value ?? [];
      final variants = ref.watch(serviceVariantsProvider).value ?? [];

      final variantById = <int, ServiceVariant>{
        for (final v in variants) v.id: v,
      };

      bool usesResource(Appointment appt) {
        final variant = variantById[appt.serviceVariantId];
        if (variant == null) return false;
        for (final req in variant.resourceRequirements) {
          if (req.resourceId == resourceId) return true;
        }
        return false;
      }

      return [
        for (final appt in appointments)
          if (!appt.endTime.isBefore(dayStart) &&
              appt.startTime.isBefore(dayEnd) &&
              usesResource(appt))
            appt,
      ];
    });

typedef ResourceAvailabilityParams = ({
  int serviceVariantId,
  int staffId,
  DateTime start,
  DateTime end,
});

///
/// DISPONIBILIT√Ä RISORSE PER UN NUOVO APPUNTAMENTO
///
final resourceAvailabilityProvider =
    Provider.family<bool, ResourceAvailabilityParams>((ref, params) {
      final serviceVariantId = params.serviceVariantId;
      final start = params.start;
      final end = params.end;

      final variants = ref.watch(serviceVariantsProvider).value ?? [];
      ServiceVariant? currentVariant;
      for (final v in variants) {
        if (v.id == serviceVariantId) {
          currentVariant = v;
          break;
        }
      }

      final requirements = currentVariant?.resourceRequirements ?? const [];
      if (requirements.isEmpty) return true;

      final allResourcesAsync = ref.watch(resourcesProvider);
      final allResources = allResourcesAsync.value ?? [];
      final resourceById = <int, Resource>{
        for (final r in allResources) r.id: r,
      };

      final requirementsByVariantId =
          <int, List<ServiceVariantResourceRequirement>>{
            for (final v in variants) v.id: v.resourceRequirements,
          };

      int unitsForAppointment(int resourceId, Appointment appt) {
        final reqs = requirementsByVariantId[appt.serviceVariantId];
        if (reqs == null) return 0;
        for (final req in reqs) {
          if (req.resourceId == resourceId) {
            return req.unitsRequired;
          }
        }
        return 0;
      }

      for (final req in requirements) {
        final resource = resourceById[req.resourceId];
        if (resource == null) {
          continue;
        }

        final bookings = ref.watch(
          resourceBookingsProvider((resourceId: req.resourceId, day: start)),
        );

        var usedUnits = 0;
        for (final appt in bookings) {
          final hasOverlap =
              appt.endTime.isAfter(start) && appt.startTime.isBefore(end);
          if (!hasOverlap) continue;

          usedUnits += unitsForAppointment(req.resourceId, appt);
        }

        if (usedUnits + req.unitsRequired > resource.quantity) {
          return false;
        }
      }

      return true;
    });
--- FILE: lib/features/agenda/providers/is_resizing_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Provider che tiene traccia se si sta ridimensionando una AppointmentCard.
/// Utilizzato per bloccare lo scroll verticale delle colonne durante il resize.
class IsResizingNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  void start() => state = true;
  void stop() => state = false;
}

final isResizingProvider = NotifierProvider<IsResizingNotifier, bool>(
  IsResizingNotifier.new,
);
--- FILE: lib/features/agenda/providers/time_blocks_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/recurrence_rule.dart';
import '../../../core/models/time_block.dart';
import '../../../core/network/network_providers.dart';
import '../../auth/providers/auth_provider.dart';
import 'date_range_provider.dart';
import 'location_providers.dart';

class TimeBlocksNotifier extends AsyncNotifier<List<TimeBlock>> {
  @override
  Future<List<TimeBlock>> build() async {
    final authState = ref.watch(authProvider);
    if (!authState.isAuthenticated) {
      return [];
    }

    final apiClient = ref.watch(apiClientProvider);
    final location = ref.watch(currentLocationProvider);
    final agendaDate = ref.watch(agendaDateProvider);

    // Non caricare se location non √® ancora valida
    if (location.id <= 0) {
      return [];
    }

    // Carica blocchi per la data corrente dell'agenda (stesso pattern degli appuntamenti)
    final dayStart = DateUtils.dateOnly(agendaDate);
    final dayEnd = dayStart.add(const Duration(days: 1));

    try {
      final data = await apiClient.getTimeBlocks(
        location.id,
        fromDate: _formatDateTime(dayStart),
        toDate: _formatDateTime(dayEnd),
      );
      return data.map(_parseTimeBlock).toList();
    } catch (_) {
      return [];
    }
  }

  String _formatDateTime(DateTime dt) {
    return '${dt.year}-${dt.month.toString().padLeft(2, '0')}-${dt.day.toString().padLeft(2, '0')} '
        '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}:${dt.second.toString().padLeft(2, '0')}';
  }

  TimeBlock _parseTimeBlock(Map<String, dynamic> json) {
    return TimeBlock(
      id: json['id'] as int,
      businessId: json['business_id'] as int,
      locationId: json['location_id'] as int,
      staffIds: (json['staff_ids'] as List).map((e) => e as int).toList(),
      startTime: DateTime.parse(json['start_time'] as String),
      endTime: DateTime.parse(json['end_time'] as String),
      reason: json['reason'] as String?,
      isAllDay: (json['is_all_day'] as int?) == 1,
    );
  }

  Future<void> refresh() async {
    // Invalida il provider per forzare un rebuild con la data corrente
    ref.invalidateSelf();
  }

  /// Aggiunge un nuovo blocco di non disponibilit√†.
  Future<TimeBlock> addBlock({
    required List<int> staffIds,
    required DateTime startTime,
    required DateTime endTime,
    String? reason,
    bool isAllDay = false,
  }) async {
    final apiClient = ref.read(apiClientProvider);
    final location = ref.read(currentLocationProvider);

    final data = await apiClient.createTimeBlock(
      locationId: location.id,
      startTime: _formatDateTime(startTime),
      endTime: _formatDateTime(endTime),
      staffIds: staffIds,
      isAllDay: isAllDay,
      reason: reason,
    );

    final block = _parseTimeBlock(data);
    final current = state.value ?? [];
    state = AsyncData([...current, block]);
    return block;
  }

  /// Aggiunge una serie di blocchi ricorrenti.
  Future<List<TimeBlock>> addRecurringBlocks({
    required List<int> staffIds,
    required DateTime startTime,
    required DateTime endTime,
    required RecurrenceConfig recurrence,
    String? reason,
    bool isAllDay = false,
  }) async {
    final apiClient = ref.read(apiClientProvider);
    final location = ref.read(currentLocationProvider);
    final duration = endTime.difference(startTime);
    final occurrences = recurrence.calculateOccurrences(startTime);
    final createdBlocks = <TimeBlock>[];

    for (final occurrenceStart in occurrences) {
      final data = await apiClient.createTimeBlock(
        locationId: location.id,
        startTime: _formatDateTime(occurrenceStart),
        endTime: _formatDateTime(occurrenceStart.add(duration)),
        staffIds: staffIds,
        isAllDay: isAllDay,
        reason: reason,
      );
      createdBlocks.add(_parseTimeBlock(data));
    }

    final current = state.value ?? [];
    state = AsyncData([...current, ...createdBlocks]);
    return createdBlocks;
  }

  /// Aggiorna un blocco esistente.
  Future<void> updateBlock({
    required int blockId,
    DateTime? startTime,
    DateTime? endTime,
    List<int>? staffIds,
    String? reason,
    bool? isAllDay,
  }) async {
    final apiClient = ref.read(apiClientProvider);

    final data = await apiClient.updateTimeBlock(
      blockId: blockId,
      startTime: startTime != null ? _formatDateTime(startTime) : null,
      endTime: endTime != null ? _formatDateTime(endTime) : null,
      staffIds: staffIds,
      isAllDay: isAllDay,
      reason: reason,
    );

    final updated = _parseTimeBlock(data);
    final current = state.value ?? [];
    state = AsyncData([
      for (final block in current)
        if (block.id == updated.id) updated else block,
    ]);
  }

  /// Elimina un blocco per id.
  Future<void> deleteBlock(int blockId) async {
    final apiClient = ref.read(apiClientProvider);
    await apiClient.deleteTimeBlock(blockId);

    final current = state.value ?? [];
    state = AsyncData([
      for (final block in current)
        if (block.id != blockId) block,
    ]);
  }

  /// Sposta un blocco a un nuovo orario.
  Future<void> moveBlock({
    required int blockId,
    required DateTime newStart,
    required DateTime newEnd,
  }) async {
    await updateBlock(blockId: blockId, startTime: newStart, endTime: newEnd);
  }

  /// Modifica gli staff assegnati a un blocco.
  Future<void> updateBlockStaff({
    required int blockId,
    required List<int> staffIds,
  }) async {
    await updateBlock(blockId: blockId, staffIds: staffIds);
  }
}

final timeBlocksProvider =
    AsyncNotifierProvider<TimeBlocksNotifier, List<TimeBlock>>(
      TimeBlocksNotifier.new,
    );

/// Blocchi filtrati per la sede corrente e la data corrente dell'agenda.
/// Il provider principale gi√† carica solo i blocchi per la data dell'agenda,
/// quindi qui filtriamo solo per location (in caso di blocchi multi-location).
final timeBlocksForCurrentLocationProvider = Provider<List<TimeBlock>>((ref) {
  final location = ref.watch(currentLocationProvider);
  final blocksAsync = ref.watch(timeBlocksProvider);
  final blocks = blocksAsync.value ?? [];

  return [
    for (final block in blocks)
      if (block.locationId == location.id) block,
  ];
});

/// Blocchi per uno staff specifico nella data corrente dell'agenda.
final timeBlocksForStaffProvider = Provider.family<List<TimeBlock>, int>((
  ref,
  staffId,
) {
  final blocks = ref.watch(timeBlocksForCurrentLocationProvider);
  return [
    for (final block in blocks)
      if (block.includesStaff(staffId)) block,
  ];
});
--- FILE: lib/features/agenda/providers/resizing_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Dati della sessione di resize per un singolo appuntamento.
class _ResizingEntry {
  final double baseHeightPx;
  final DateTime startTimeInitial;
  final DateTime endTimeInitial;
  final double currentPreviewHeightPx;
  final DateTime provisionalEndTime;

  const _ResizingEntry({
    required this.baseHeightPx,
    required this.startTimeInitial,
    required this.endTimeInitial,
    required this.currentPreviewHeightPx,
    required this.provisionalEndTime,
  });

  _ResizingEntry copyWith({
    double? baseHeightPx,
    DateTime? startTimeInitial,
    DateTime? endTimeInitial,
    double? currentPreviewHeightPx,
    DateTime? provisionalEndTime,
  }) {
    return _ResizingEntry(
      baseHeightPx: baseHeightPx ?? this.baseHeightPx,
      startTimeInitial: startTimeInitial ?? this.startTimeInitial,
      endTimeInitial: endTimeInitial ?? this.endTimeInitial,
      currentPreviewHeightPx:
          currentPreviewHeightPx ?? this.currentPreviewHeightPx,
      provisionalEndTime: provisionalEndTime ?? this.provisionalEndTime,
    );
  }
}

/// Stato globale del resize (pi√π entry contemporanee per staff multipli).
class ResizingState {
  final Map<int, _ResizingEntry> entries;
  final bool isResizing;

  const ResizingState({this.entries = const {}, this.isResizing = false});

  const ResizingState.initial() : entries = const {}, isResizing = false;

  ResizingState copyWith({
    Map<int, _ResizingEntry>? entries,
    bool? isResizing,
  }) {
    return ResizingState(
      entries: entries ?? this.entries,
      isResizing: isResizing ?? this.isResizing,
    );
  }
}

/// Gestore centralizzato dei resize attivi.
class ResizingNotifier extends Notifier<ResizingState> {
  @override
  ResizingState build() => const ResizingState.initial();

  /// Avvia una nuova sessione di resize per una card specifica.
  void startResize({
    required int appointmentId,
    required double currentHeightPx,
    required DateTime startTime,
    required DateTime endTime,
  }) {
    // üîπ Reset completo della base e altezza provvisoria
    final newEntry = _ResizingEntry(
      baseHeightPx: currentHeightPx,
      startTimeInitial: startTime,
      endTimeInitial: endTime,
      currentPreviewHeightPx: currentHeightPx,
      provisionalEndTime: endTime,
    );

    // üîπ Aggiorna solo la entry corrente senza cancellare le altre
    final updated = Map<int, _ResizingEntry>.from(state.entries);
    updated[appointmentId] = newEntry;

    state = state.copyWith(entries: updated, isResizing: true);
  }

  /// Aggiornamento live durante il drag del bordo inferiore.
  void updateDuringResize({
    required int appointmentId,
    required double deltaDy,
    required double pixelsPerMinute,
    required DateTime dayEnd,
    required int minDurationMinutes,
    required int snapMinutes,
  }) {
    final entry = state.entries[appointmentId];
    if (entry == null) return;

    // üîπ Calcola nuova altezza cumulativa a partire dall'altezza corrente
    double proposedHeightPx = entry.currentPreviewHeightPx + deltaDy;

    final minHeightPx = minDurationMinutes * pixelsPerMinute;
    final rawMaxDurationMinutes =
        dayEnd.difference(entry.startTimeInitial).inMinutes;
    final effectiveMaxDurationMinutes = rawMaxDurationMinutes <= 0
        ? minDurationMinutes
        : rawMaxDurationMinutes < minDurationMinutes
            ? minDurationMinutes
            : rawMaxDurationMinutes;
    final maxHeightPx = effectiveMaxDurationMinutes * pixelsPerMinute;

    // üîπ Applica i limiti min/max consentiti
    proposedHeightPx = proposedHeightPx.clamp(minHeightPx, maxHeightPx).toDouble();

    final proposedDurationMinutes = proposedHeightPx / pixelsPerMinute;

    // üîπ Snap ai minuti impostati solo per il calcolo dell'end time
    final lowerBoundMinutes = minDurationMinutes.toDouble();
    final upperBoundMinutes = effectiveMaxDurationMinutes.toDouble();

    final snappedMinutes = _snapToStep(
      proposedDurationMinutes,
      snapMinutes,
    ).clamp(
      lowerBoundMinutes,
      upperBoundMinutes < lowerBoundMinutes
          ? lowerBoundMinutes
          : upperBoundMinutes,
    );

    // üîπ Nuovo end provvisorio (clamp a fine giornata se necessario)
    DateTime candidateEnd = entry.startTimeInitial.add(
      Duration(minutes: snappedMinutes.round()),
    );
    if (candidateEnd.isAfter(dayEnd)) {
      candidateEnd = dayEnd;
    }

    final updatedEntry = entry.copyWith(
      currentPreviewHeightPx: proposedHeightPx,
      provisionalEndTime: candidateEnd,
    );

    final updated = Map<int, _ResizingEntry>.from(state.entries);
    updated[appointmentId] = updatedEntry;

    state = state.copyWith(entries: updated, isResizing: true);
  }

  /// Conclude il resize e restituisce il nuovo endTime definitivo.
  DateTime? commitResizeAndEnd({required int appointmentId}) {
    final entry = state.entries[appointmentId];
    final finalEnd = entry?.provisionalEndTime;
    if (entry == null) return null;

    // üîπ Prima di rimuovere, resetta la preview height alla base originale
    final resetEntry = entry.copyWith(
      currentPreviewHeightPx: entry.baseHeightPx,
    );

    final updated = Map<int, _ResizingEntry>.from(state.entries);
    updated[appointmentId] = resetEntry;
    updated.remove(appointmentId);

    state = state.copyWith(entries: updated, isResizing: updated.isNotEmpty);

    return finalEnd;
  }

  /// Annulla un resize senza commit.
  void cancelResize({required int appointmentId}) {
    final updated = Map<int, _ResizingEntry>.from(state.entries);
    updated.remove(appointmentId);
    state = state.copyWith(entries: updated, isResizing: updated.isNotEmpty);
  }

  /// Accessori utili.
  double? previewHeightFor(int appointmentId) =>
      state.entries[appointmentId]?.currentPreviewHeightPx;

  DateTime? previewEndTimeFor(int appointmentId) =>
      state.entries[appointmentId]?.provisionalEndTime;

  double _snapToStep(double minutes, int step) {
    if (step <= 1) return minutes;
    final m = minutes / step;
    final rounded = m.round();
    return (rounded * step).toDouble();
  }
}

/// Provider principale di stato di resize.
final resizingProvider = NotifierProvider<ResizingNotifier, ResizingState>(
  ResizingNotifier.new,
);

/// Provider per una singola entry di appointment.
final resizingEntryProvider = Provider.family<_ResizingEntry?, int>(
  (ref, appointmentId) => ref.watch(resizingProvider).entries[appointmentId],
);
--- FILE: lib/features/agenda/providers/fully_occupied_slots_provider.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import 'appointment_providers.dart';
import 'date_range_provider.dart';
import 'layout_config_provider.dart';

part 'fully_occupied_slots_provider.g.dart';

/// Calcola gli indici degli slot completamente occupati per un dato staff.
/// Uno slot √® "completamente occupato" quando la somma delle frazioni di larghezza
/// degli appuntamenti che lo coprono raggiunge o supera il 100%.
@riverpod
Set<int> fullyOccupiedSlots(Ref ref, int staffId) {
  final appointments = ref
      .watch(appointmentsForCurrentLocationProvider)
      .where((a) => a.staffId == staffId)
      .toList();

  if (appointments.isEmpty) return const {};

  final layoutConfig = ref.watch(layoutConfigProvider);
  final agendaDate = ref.watch(agendaDateProvider);
  final minutesPerSlot = layoutConfig.minutesPerSlot;
  final totalSlots = layoutConfig.totalSlots;

  // Calcola la geometria degli appuntamenti per determinare le frazioni di larghezza
  final layoutEntries = appointments
      .map((a) => _LayoutEntry(id: a.id, start: a.startTime, end: a.endTime))
      .toList();

  final geometryMap = _computeLayoutGeometry(
    layoutEntries,
    useClusterMaxConcurrency: layoutConfig.useClusterMaxConcurrency,
  );

  // Per ogni slot, calcola la somma delle frazioni di larghezza coperte
  final fullyOccupied = <int>{};

  for (int slotIndex = 0; slotIndex < totalSlots; slotIndex++) {
    final slotStart = agendaDate.add(
      Duration(minutes: slotIndex * minutesPerSlot),
    );
    final slotEnd = slotStart.add(Duration(minutes: minutesPerSlot));

    // Trova tutti gli appuntamenti che coprono questo slot
    double totalWidthFraction = 0.0;

    for (final appt in appointments) {
      // Verifica se l'appuntamento copre lo slot
      if (appt.startTime.isBefore(slotEnd) && appt.endTime.isAfter(slotStart)) {
        final geometry = geometryMap[appt.id];
        if (geometry != null) {
          totalWidthFraction += geometry.widthFraction;
        }
      }
    }

    // Lo slot √® completamente occupato se la somma >= 1.0 (100%)
    if (totalWidthFraction >= 0.999) {
      fullyOccupied.add(slotIndex);
    }
  }

  return fullyOccupied;
}

// ‚îÄ‚îÄ Classi helper per il calcolo della geometria ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class _LayoutEntry {
  const _LayoutEntry({
    required this.id,
    required this.start,
    required this.end,
  });

  final int id;
  final DateTime start;
  final DateTime end;
}

class _EventGeometry {
  const _EventGeometry({
    required this.leftFraction,
    required this.widthFraction,
  });

  final double leftFraction;
  final double widthFraction;
}

/// Versione semplificata del layout geometry helper.
Map<int, _EventGeometry> _computeLayoutGeometry(
  List<_LayoutEntry> entries, {
  bool useClusterMaxConcurrency = false,
}) {
  if (entries.isEmpty) return const {};

  final sorted = entries.toList()..sort((a, b) => a.start.compareTo(b.start));

  final clusters = <List<_LayoutEntry>>[];
  var currentCluster = <_LayoutEntry>[];
  DateTime? currentMaxEnd;

  for (final entry in sorted) {
    if (currentCluster.isEmpty) {
      currentCluster = [entry];
      currentMaxEnd = entry.end;
      continue;
    }

    if (entry.start.isBefore(currentMaxEnd!)) {
      currentCluster.add(entry);
      if (entry.end.isAfter(currentMaxEnd)) {
        currentMaxEnd = entry.end;
      }
    } else {
      clusters.add(List<_LayoutEntry>.from(currentCluster));
      currentCluster = [entry];
      currentMaxEnd = entry.end;
    }
  }

  if (currentCluster.isNotEmpty) {
    clusters.add(List<_LayoutEntry>.from(currentCluster));
  }

  final geometryMap = <int, _EventGeometry>{};

  for (final cluster in clusters) {
    final concurrencyMap = _computeConcurrency(cluster);

    for (final entry in cluster) {
      final concurrency = concurrencyMap[entry.id] ?? 1;
      final widthFraction = 1 / concurrency;
      geometryMap[entry.id] = _EventGeometry(
        leftFraction: 0, // Non ci serve leftFraction per questo calcolo
        widthFraction: widthFraction,
      );
    }
  }

  return geometryMap;
}

Map<int, int> _computeConcurrency(List<_LayoutEntry> cluster) {
  final result = <int, int>{};

  for (final entry in cluster) {
    int count = 0;
    for (final other in cluster) {
      if (entry.start.isBefore(other.end) && entry.end.isAfter(other.start)) {
        count++;
      }
    }
    result[entry.id] = count;
  }

  return result;
}
--- FILE: lib/features/agenda/providers/dragged_base_range_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Mantiene l'intervallo originale (start, end) della card che sta per
/// essere trascinata. Serve per evitare fallback arbitrari durante il ghost.
class DraggedBaseRangeNotifier extends Notifier<(DateTime, DateTime)?> {
  @override
  (DateTime, DateTime)? build() => null;

  void set(DateTime start, DateTime end) => state = (start, end);
  void clear() => state = null;
}

final draggedBaseRangeProvider =
    NotifierProvider<DraggedBaseRangeNotifier, (DateTime, DateTime)?>(
      DraggedBaseRangeNotifier.new,
    );
--- FILE: lib/features/agenda/providers/bookings_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/booking.dart';
import 'appointment_providers.dart';
import 'business_providers.dart';
import 'location_providers.dart';

class BookingSummary {
  final int bookingId;
  final int itemsCount;
  final double totalPrice;
  final DateTime? start;
  final DateTime? end;

  const BookingSummary({
    required this.bookingId,
    required this.itemsCount,
    required this.totalPrice,
    required this.start,
    required this.end,
  });
}

/// Gestisce i metadati delle prenotazioni (note, clientName, ecc.) e
/// coordina le operazioni di alto livello (cancellazione prenotazione intera).
class BookingsNotifier extends Notifier<Map<int, Booking>> {
  int _nextId = 1;

  @override
  Map<int, Booking> build() => <int, Booking>{};

  /// Crea una nuova prenotazione e restituisce il suo ID.
  int createBooking({int? clientId, String? clientName, String? notes}) {
    final business = ref.read(currentBusinessProvider);
    final location = ref.read(currentLocationProvider);

    final bookingId = _nextId++;
    state = {
      ...state,
      bookingId: Booking(
        id: bookingId,
        businessId: business.id,
        locationId: location.id,
        clientId: clientId,
        clientName: clientName,
        notes: notes,
        status: 'confirmed',
      ),
    };
    return bookingId;
  }

  /// Crea la prenotazione se non esiste gi√† (idempotente).
  void ensureBooking({
    required int bookingId,
    required int businessId,
    required int locationId,
    int? clientId,
    required String clientName,
    String? notes,
    String status = 'confirmed',
    int? replacesBookingId,
    int? replacedByBookingId,
  }) {
    final current = state;
    if (current.containsKey(bookingId)) return;
    state = {
      ...current,
      bookingId: Booking(
        id: bookingId,
        businessId: businessId,
        locationId: locationId,
        clientId: clientId,
        clientName: clientName,
        notes: notes,
        status: status,
        replacesBookingId: replacesBookingId,
        replacedByBookingId: replacedByBookingId,
      ),
    };
  }

  void setNotes(int bookingId, String? notes) {
    final bk = state[bookingId];
    if (bk == null) return;
    state = {
      for (final e in state.entries)
        e.key: e.key == bookingId
            ? bk.copyWith(notes: notes)
            : e.value,
    };
  }

  void setStatus(int bookingId, String status) {
    final bk = state[bookingId];
    if (bk == null) return;
    state = {
      for (final e in state.entries)
        e.key: e.key == bookingId
            ? bk.copyWith(status: status)
            : e.value,
    };
  }

  /// Cancella l'intera prenotazione e tutti i suoi appuntamenti.
  Future<void> deleteBooking(int bookingId) async {
    // Aggiorna appuntamenti in cascata (chiama API)
    await ref.read(appointmentsProvider.notifier).deleteByBooking(bookingId);
    // Rimuovi metadati prenotazione
    final copy = Map<int, Booking>.from(state);
    copy.remove(bookingId);
    state = copy;
  }

  /// Rimuove la prenotazione se non ha pi√π appuntamenti.
  void removeIfEmpty(int bookingId) {
    final appts = ref.read(appointmentsProvider).value ?? [];
    if (appts.any((a) => a.bookingId == bookingId)) return;
    final copy = Map<int, Booking>.from(state);
    copy.remove(bookingId);
    state = copy;
  }

  /// Aggiorna il cliente di un booking locale.
  void updateClientForBooking({
    required int bookingId,
    int? clientId,
    String? clientName,
  }) {
    final bk = state[bookingId];
    if (bk == null) return;
    state = {
      for (final e in state.entries)
        e.key: e.key == bookingId
            ? bk.copyWith(
                clientId: clientId,
                clientName: clientName ?? bk.clientName,
              )
            : e.value,
    };
  }
}

final bookingsProvider = NotifierProvider<BookingsNotifier, Map<int, Booking>>(
  BookingsNotifier.new,
);

/// Riepilogo calcolato su appointment per un booking.
final bookingSummaryProvider = Provider.family<BookingSummary?, int>((ref, id) {
  final appts = (ref.watch(appointmentsProvider).value ?? [])
      .where((a) => a.bookingId == id)
      .toList();
  if (appts.isEmpty) return null;

  appts.sort((a, b) => a.startTime.compareTo(b.startTime));
  final totalPrice = appts.fold<double>(0.0, (sum, a) => sum + (a.price ?? 0));
  return BookingSummary(
    bookingId: id,
    itemsCount: appts.length,
    totalPrice: totalPrice,
    start: appts.first.startTime,
    end: appts.map((a) => a.endTime).reduce((a, b) => a.isAfter(b) ? a : b),
  );
});
--- FILE: lib/features/agenda/providers/agenda_scroll_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/staff.dart';

/// Stato con tutti i controller di scroll sincronizzati
class AgendaScrollState {
  final ScrollController verticalScrollCtrl;
  final ScrollController horizontalScrollCtrl;
  final Map<int, ScrollController> staffScrollCtrls;

  const AgendaScrollState({
    required this.verticalScrollCtrl,
    required this.horizontalScrollCtrl,
    required this.staffScrollCtrls,
  });
}

@immutable
class AgendaScrollKey {
  final Object identity;
  final List<Staff> staff;
  final DateTime date;
  final double initialOffset;

  const AgendaScrollKey({
    required this.identity,
    required this.staff,
    required this.date,
    required this.initialOffset,
  });

  @override
  bool operator ==(Object other) {
    return other is AgendaScrollKey && identical(other.identity, identity);
  }

  @override
  int get hashCode => identity.hashCode;
}

final agendaScrollProvider = Provider.family.autoDispose<AgendaScrollState, AgendaScrollKey>((ref, key) {
  final staffList = key.staff;
  final verticalCtrl = ScrollController(initialScrollOffset: key.initialOffset);
  final horizontalCtrl = ScrollController();
  final Map<int, ScrollController> staffCtrls = {
    for (final s in staffList) s.id: ScrollController(),
  };

  ref.onDispose(() {
    verticalCtrl.dispose();
    horizontalCtrl.dispose();
    for (final controller in staffCtrls.values) {
      controller.dispose();
    }
  });

  return AgendaScrollState(
    verticalScrollCtrl: verticalCtrl,
    horizontalScrollCtrl: horizontalCtrl,
    staffScrollCtrls: staffCtrls,
  );
});
--- FILE: lib/features/agenda/providers/bookings_repository_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'bookings_repository_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(bookingsRepository)
const bookingsRepositoryProvider = BookingsRepositoryProvider._();

final class BookingsRepositoryProvider
    extends
        $FunctionalProvider<
          BookingsRepository,
          BookingsRepository,
          BookingsRepository
        >
    with $Provider<BookingsRepository> {
  const BookingsRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'bookingsRepositoryProvider',
        isAutoDispose: false,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$bookingsRepositoryHash();

  @$internal
  @override
  $ProviderElement<BookingsRepository> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  BookingsRepository create(Ref ref) {
    return bookingsRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(BookingsRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<BookingsRepository>(value),
    );
  }
}

String _$bookingsRepositoryHash() =>
    r'50ae33d4ab0eb3eea9df1a6cfa054ae2ac09cdbb';

@ProviderFor(bookingsApi)
const bookingsApiProvider = BookingsApiProvider._();

final class BookingsApiProvider
    extends $FunctionalProvider<BookingsApi, BookingsApi, BookingsApi>
    with $Provider<BookingsApi> {
  const BookingsApiProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'bookingsApiProvider',
        isAutoDispose: false,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$bookingsApiHash();

  @$internal
  @override
  $ProviderElement<BookingsApi> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  BookingsApi create(Ref ref) {
    return bookingsApi(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(BookingsApi value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<BookingsApi>(value),
    );
  }
}

String _$bookingsApiHash() => r'7dc61534698fed8f7bb33402d8ac248b42c292c5';
--- FILE: lib/features/agenda/providers/agenda_interaction_lock_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'agenda_providers.dart';
import 'is_resizing_provider.dart';
import 'selected_appointment_provider.dart';

/// Stato condiviso che indica se il puntatore √® attualmente sopra una card.
class AgendaCardHoverNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  void setHovering(bool hovering) => state = hovering;

  void enter() => state = true;

  void exit() => state = false;
}

final agendaCardHoverProvider = NotifierProvider<AgendaCardHoverNotifier, bool>(
  AgendaCardHoverNotifier.new,
);

/// Restituisce `true` quando il PageView deve essere disabilitato
/// (drag, resize, hover o card selezionate).
final agendaDayScrollLockProvider = Provider<bool>((ref) {
  final isResizing = ref.watch(isResizingProvider);
  final isDragging = ref.watch(dragPositionProvider) != null;
  final hasSelection = !ref.watch(selectedAppointmentProvider).isEmpty;
  final isHovering = ref.watch(agendaCardHoverProvider);
  return isResizing || isDragging || hasSelection || isHovering;
});
--- FILE: lib/features/agenda/providers/visited_dates_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Provider per tracciare se √® stata effettuata la prima apertura dell'agenda.
/// Lo scroll automatico all'orario corrente avviene SOLO alla prima apertura.
class InitialScrollDoneNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  /// Marca lo scroll iniziale come completato.
  void markDone() {
    state = true;
  }

  /// Reset (usato quando si cambia business).
  void reset() {
    state = false;
  }
}

final initialScrollDoneProvider =
    NotifierProvider<InitialScrollDoneNotifier, bool>(
      InitialScrollDoneNotifier.new,
    );
--- FILE: lib/features/agenda/providers/fully_occupied_slots_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'fully_occupied_slots_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning
/// Calcola gli indici degli slot completamente occupati per un dato staff.
/// Uno slot √® "completamente occupato" quando la somma delle frazioni di larghezza
/// degli appuntamenti che lo coprono raggiunge o supera il 100%.

@ProviderFor(fullyOccupiedSlots)
const fullyOccupiedSlotsProvider = FullyOccupiedSlotsFamily._();

/// Calcola gli indici degli slot completamente occupati per un dato staff.
/// Uno slot √® "completamente occupato" quando la somma delle frazioni di larghezza
/// degli appuntamenti che lo coprono raggiunge o supera il 100%.

final class FullyOccupiedSlotsProvider
    extends $FunctionalProvider<Set<int>, Set<int>, Set<int>>
    with $Provider<Set<int>> {
  /// Calcola gli indici degli slot completamente occupati per un dato staff.
  /// Uno slot √® "completamente occupato" quando la somma delle frazioni di larghezza
  /// degli appuntamenti che lo coprono raggiunge o supera il 100%.
  const FullyOccupiedSlotsProvider._({
    required FullyOccupiedSlotsFamily super.from,
    required int super.argument,
  }) : super(
         retry: null,
         name: r'fullyOccupiedSlotsProvider',
         isAutoDispose: true,
         dependencies: null,
         $allTransitiveDependencies: null,
       );

  @override
  String debugGetCreateSourceHash() => _$fullyOccupiedSlotsHash();

  @override
  String toString() {
    return r'fullyOccupiedSlotsProvider'
        ''
        '($argument)';
  }

  @$internal
  @override
  $ProviderElement<Set<int>> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  Set<int> create(Ref ref) {
    final argument = this.argument as int;
    return fullyOccupiedSlots(ref, argument);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(Set<int> value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<Set<int>>(value),
    );
  }

  @override
  bool operator ==(Object other) {
    return other is FullyOccupiedSlotsProvider && other.argument == argument;
  }

  @override
  int get hashCode {
    return argument.hashCode;
  }
}

String _$fullyOccupiedSlotsHash() =>
    r'cac3293a238229a07421123556e10d4471801e64';

/// Calcola gli indici degli slot completamente occupati per un dato staff.
/// Uno slot √® "completamente occupato" quando la somma delle frazioni di larghezza
/// degli appuntamenti che lo coprono raggiunge o supera il 100%.

final class FullyOccupiedSlotsFamily extends $Family
    with $FunctionalFamilyOverride<Set<int>, int> {
  const FullyOccupiedSlotsFamily._()
    : super(
        retry: null,
        name: r'fullyOccupiedSlotsProvider',
        dependencies: null,
        $allTransitiveDependencies: null,
        isAutoDispose: true,
      );

  /// Calcola gli indici degli slot completamente occupati per un dato staff.
  /// Uno slot √® "completamente occupato" quando la somma delle frazioni di larghezza
  /// degli appuntamenti che lo coprono raggiunge o supera il 100%.

  FullyOccupiedSlotsProvider call(int staffId) =>
      FullyOccupiedSlotsProvider._(argument: staffId, from: this);

  @override
  String toString() => r'fullyOccupiedSlotsProvider';
}
--- FILE: lib/features/agenda/providers/staff_columns_geometry_provider.dart ---
import 'dart:ui';

import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Mappa: staffId -> Rect della colonna in coordinate BODY-LOCAL
class StaffColumnsGeometryNotifier extends Notifier<Map<int, Rect>> {
  @override
  Map<int, Rect> build() => <int, Rect>{};

  void setRect(int staffId, Rect rect) {
    final next = Map<int, Rect>.from(state)..[staffId] = rect;
    state = next;
  }

  void clearFor(int staffId) {
    if (!state.containsKey(staffId)) return;
    final next = Map<int, Rect>.from(state)..remove(staffId);
    state = next;
  }

  void clearAll() => state = <int, Rect>{};
}

final staffColumnsGeometryProvider =
    NotifierProvider<StaffColumnsGeometryNotifier, Map<int, Rect>>(
      StaffColumnsGeometryNotifier.new,
    );
--- FILE: lib/features/agenda/providers/agenda_providers.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Notifier che tiene traccia della posizione globale del drag
class DragPositionNotifier extends Notifier<Offset?> {
  @override
  Offset? build() => null;

  void update(Offset position) => state = position;

  /// ‚úÖ Nuovo metodo pubblico per aggiornare lo stato interpolato
  void set(Offset newValue) => state = newValue;

  void clear() => state = null;
}

final dragPositionProvider = NotifierProvider<DragPositionNotifier, Offset?>(
  DragPositionNotifier.new,
);
--- FILE: lib/features/agenda/providers/bookings_repository_provider.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../core/network/network_providers.dart';
import '../data/bookings_api.dart';
import '../data/bookings_repository.dart';

part 'bookings_repository_provider.g.dart';

@Riverpod(keepAlive: true)
BookingsRepository bookingsRepository(Ref ref) {
  final apiClient = ref.watch(apiClientProvider);
  return BookingsRepository(apiClient: apiClient);
}

@Riverpod(keepAlive: true)
BookingsApi bookingsApi(Ref ref) {
  final apiClient = ref.watch(apiClientProvider);
  return BookingsApi(apiClient: apiClient);
}
--- FILE: lib/features/agenda/providers/booking_reschedule_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/appointment.dart';

@immutable
class BookingRescheduleItemSnapshot {
  const BookingRescheduleItemSnapshot({
    required this.appointmentId,
    required this.staffId,
    required this.startTime,
    required this.endTime,
    required this.blockedExtraMinutes,
  });

  final int appointmentId;
  final int staffId;
  final DateTime startTime;
  final DateTime endTime;
  final int blockedExtraMinutes;
}

@immutable
class BookingRescheduleSession {
  const BookingRescheduleSession({
    required this.bookingId,
    required this.originDate,
    required this.anchorAppointmentId,
    required this.items,
  });

  final int bookingId;
  final DateTime originDate;
  final int anchorAppointmentId;
  final List<BookingRescheduleItemSnapshot> items;
}

class BookingRescheduleNotifier extends Notifier<BookingRescheduleSession?> {
  @override
  BookingRescheduleSession? build() => null;

  void start({
    required int bookingId,
    required DateTime originDate,
    required List<Appointment> bookingAppointments,
  }) {
    final sorted = [...bookingAppointments]
      ..sort((a, b) {
        final byStart = a.startTime.compareTo(b.startTime);
        if (byStart != 0) return byStart;
        return a.id.compareTo(b.id);
      });
    if (sorted.isEmpty) return;

    final items = sorted
        .map(
          (a) => BookingRescheduleItemSnapshot(
            appointmentId: a.id,
            staffId: a.staffId,
            startTime: a.startTime,
            endTime: a.endTime,
            blockedExtraMinutes: a.blockedExtraMinutes,
          ),
        )
        .toList(growable: false);

    state = BookingRescheduleSession(
      bookingId: bookingId,
      originDate: DateUtils.dateOnly(originDate),
      anchorAppointmentId: sorted.first.id,
      items: items,
    );
  }

  void clear() {
    state = null;
  }

  bool get isActive => state != null;
}

final bookingRescheduleSessionProvider =
    NotifierProvider<BookingRescheduleNotifier, BookingRescheduleSession?>(
      BookingRescheduleNotifier.new,
    );
--- FILE: lib/features/agenda/providers/selected_appointment_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/appointment.dart';
import 'appointment_providers.dart';

class SelectedAppointmentsState {
  const SelectedAppointmentsState({
    this.bookingId,
    this.appointmentIds = const <int>{},
  });

  final int? bookingId;
  final Set<int> appointmentIds;

  bool contains(int appointmentId) => appointmentIds.contains(appointmentId);
  bool get isEmpty => appointmentIds.isEmpty;
}

/// üîπ Tiene traccia degli appuntamenti selezionati (tutti quelli della stessa prenotazione)
class SelectedAppointmentNotifier extends Notifier<SelectedAppointmentsState> {
  @override
  SelectedAppointmentsState build() => const SelectedAppointmentsState();

  /// Seleziona tutti gli appuntamenti collegati allo stesso booking dell'appuntamento dato.
  /// Se gi√† selezionati, deseleziona tutto.
  void toggleByAppointment(Appointment appointment) {
    final current = state;
    final alreadySelected =
        current.bookingId == appointment.bookingId &&
        current.contains(appointment.id);
    if (alreadySelected) {
      clear();
      return;
    }

    final allAppointments = ref.read(appointmentsProvider).value ?? [];
    final bookingAppointments = allAppointments
        .where((a) => a.bookingId == appointment.bookingId)
        .map((a) => a.id)
        .toSet();

    state = SelectedAppointmentsState(
      bookingId: appointment.bookingId,
      appointmentIds: bookingAppointments,
    );
  }

  /// Deseleziona tutti gli appuntamenti
  void clear() => state = const SelectedAppointmentsState();
}

final selectedAppointmentProvider =
    NotifierProvider<SelectedAppointmentNotifier, SelectedAppointmentsState>(
      SelectedAppointmentNotifier.new,
    );
--- FILE: lib/features/agenda/providers/agenda_scroll_request_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/appointment.dart';

@immutable
class AgendaScrollRequest {
  const AgendaScrollRequest(this.appointment);

  final Appointment appointment;

  DateTime get date => DateUtils.dateOnly(appointment.startTime);
}

class AgendaScrollRequestNotifier extends Notifier<AgendaScrollRequest?> {
  @override
  AgendaScrollRequest? build() => null;

  void request(Appointment appointment) {
    state = AgendaScrollRequest(appointment);
  }

  void clear() => state = null;
}

final agendaScrollRequestProvider =
    NotifierProvider<AgendaScrollRequestNotifier, AgendaScrollRequest?>(
      AgendaScrollRequestNotifier.new,
    );
--- FILE: lib/features/agenda/providers/temp_drag_time_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Mantiene in memoria temporanea l'intervallo orario stimato
/// (start, end) dell'appuntamento durante il drag.
/// Viene aggiornato in tempo reale dalla StaffColumn mentre l'utente trascina
/// e letto da AppointmentCard per mostrare orari live.
class TempDragTimeNotifier extends Notifier<(DateTime, DateTime)?> {
  @override
  (DateTime, DateTime)? build() => null;

  /// Imposta un nuovo intervallo orario (start, end)
  void setTimes(DateTime start, DateTime end) {
    // aggiorna solo se cambia effettivamente lo slot di riferimento
    if (state == null ||
        state!.$1.minute != start.minute ||
        state!.$1.hour != start.hour) {
      state = (start, end);
    }
  }

  /// Resetta lo stato (nessun drag in corso)
  void clear() => state = null;
}

final tempDragTimeProvider =
    NotifierProvider<TempDragTimeNotifier, (DateTime, DateTime)?>(
      TempDragTimeNotifier.new,
    );
--- FILE: lib/features/agenda/providers/pending_drop_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Dati di un drop in attesa di conferma.
@immutable
class PendingDropData {
  final int appointmentId;
  final int originalStaffId;
  final DateTime originalStart;
  final DateTime originalEnd;
  final int newStaffId;
  final DateTime newStart;
  final DateTime newEnd;

  const PendingDropData({
    required this.appointmentId,
    required this.originalStaffId,
    required this.originalStart,
    required this.originalEnd,
    required this.newStaffId,
    required this.newStart,
    required this.newEnd,
  });
}

/// Notifier per gestire lo stato di un drop in attesa di conferma.
class PendingDropNotifier extends Notifier<PendingDropData?> {
  @override
  PendingDropData? build() => null;

  void setPending(PendingDropData data) {
    state = data;
  }

  void clear() {
    state = null;
  }

  bool get hasPending => state != null;
}

/// Provider per lo stato di drop in attesa di conferma.
final pendingDropProvider =
    NotifierProvider<PendingDropNotifier, PendingDropData?>(
      PendingDropNotifier.new,
    );

/// Provider per verificare se un appuntamento specifico ha un drop pendente.
final isAppointmentPendingDropProvider = Provider.family<bool, int>((
  ref,
  appointmentId,
) {
  final pending = ref.watch(pendingDropProvider);
  return pending?.appointmentId == appointmentId;
});
--- FILE: lib/features/agenda/providers/drag_layer_link_provider.dart ---
import 'dart:async';

import 'package:flutter/widgets.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Gestisce il LayerLink del body (ancora per i feedback)
class DragLayerLinkNotifier extends Notifier<LayerLink> {
  @override
  LayerLink build() => LayerLink();

  void reset() => state = LayerLink();
  void resetOnMicrotask() {
    Future.microtask(() => state = LayerLink());
  }
}

final dragLayerLinkProvider =
    NotifierProvider<DragLayerLinkNotifier, LayerLink>(
      DragLayerLinkNotifier.new,
    );

/// üîπ Gestisce il RenderBox del body (area scrollabile dell‚Äôagenda)
class DragBodyBoxNotifier extends Notifier<RenderBox?> {
  @override
  RenderBox? build() => null;

  void set(RenderBox box) => state = box;
  void scheduleClear() {
    Future.microtask(() => state = null);
  }
}

final dragBodyBoxProvider = NotifierProvider<DragBodyBoxNotifier, RenderBox?>(
  DragBodyBoxNotifier.new,
);
--- FILE: lib/features/agenda/providers/initial_scroll_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Provider per tracciare se √® stata effettuata la prima apertura dell'agenda.
/// Lo scroll automatico all'orario corrente avviene SOLO alla prima apertura.
class InitialScrollDoneNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  /// Marca lo scroll iniziale come completato.
  void markDone() {
    state = true;
  }

  /// Reset (usato quando si cambia business).
  void reset() {
    state = false;
  }
}

final initialScrollDoneProvider =
    NotifierProvider<InitialScrollDoneNotifier, bool>(
      InitialScrollDoneNotifier.new,
    );

/// Provider per mantenere l'offset di scroll verticale dell'agenda.
/// Persiste anche quando il widget viene ricreato.
class AgendaVerticalOffsetNotifier extends Notifier<double?> {
  @override
  double? build() => null; // null = usa l'orario corrente

  void set(double offset) {
    state = offset;
  }

  void reset() {
    state = null;
  }
}

final agendaVerticalOffsetProvider =
    NotifierProvider<AgendaVerticalOffsetNotifier, double?>(
      AgendaVerticalOffsetNotifier.new,
    );
--- FILE: lib/features/agenda/providers/staff_slot_availability_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/availability_exception.dart';
import '../../../core/models/staff_planning.dart';
import '../../../core/services/staff_planning_selector.dart';
import '../../business/providers/location_closures_provider.dart';
import '../../staff/providers/staff_planning_provider.dart';
import '../../staff/providers/availability_exceptions_provider.dart';
import 'date_range_provider.dart';
import 'layout_config_provider.dart';

/// Provider che fornisce la disponibilit√† degli slot per uno staff specifico
/// in base alla data corrente dell'agenda.
///
/// La disponibilit√† finale √® calcolata come:
/// 0. CHECK: Se la data √® in un periodo di chiusura, ritorna Set vuoto
/// 1. Base: planning da API (template settimanale con supporto biweekly A/B)
/// 2. + Eccezioni "available": aggiungono slot disponibili
/// 3. - Eccezioni "unavailable": rimuovono slot disponibili
///
/// Ritorna un `Set<int>` contenente gli indici degli slot DISPONIBILI.
/// - Set vuoto = nessuna disponibilit√† (staff non lavora quel giorno o sede chiusa)
/// - Se non ci sono dati configurati, lo staff √® considerato NON disponibile (comportamento restrittivo)
final staffSlotAvailabilityProvider = Provider.family<Set<int>, int>((
  ref,
  staffId,
) {
  final agendaDate = ref.watch(agendaDateProvider);
  final layoutConfig = ref.watch(layoutConfigProvider);

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // 0Ô∏è‚É£ CHECK: Verifica se la data √® in un periodo di chiusura
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  final isClosed = ref.watch(isDateClosedProvider(agendaDate));
  if (isClosed) {
    // Sede chiusa: tutti gli slot non disponibili
    return const {};
  }

  // Triggera il caricamento automatico dei planning se non gi√† caricati
  ref.watch(ensureStaffPlanningLoadedProvider(staffId));

  // Planning valido per la data corrente (source of truth per lo step planning)
  final planningLookup = ref.watch(
    planningForStaffOnDateProvider((staffId: staffId, date: agendaDate)),
  );
  const planningSlotMinutes = StaffPlanning.planningStepMinutes;
  final planningTotalSlots = (24 * 60) ~/ planningSlotMinutes;

  // 1Ô∏è‚É£ BASE: Planning da API (supporta weekly/biweekly, validit√† temporale)
  Set<int> basePlanningSlots = switch (planningLookup) {
    NoPlanningFound() => <int>{},
    PlanningFound(template: final template) => template.getSlotsForDay(
      agendaDate.weekday,
    ),
    MultiplePlanningsFound() => <int>{},
  };

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // 2Ô∏è‚É£ ECCEZIONI: Applica modifiche per la data specifica
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  final exceptions = ref.watch(
    exceptionsForStaffOnDateProvider((staffId: staffId, date: agendaDate)),
  );

  if (exceptions.isEmpty) {
    return _projectPlanningSlotsToLayoutSlots(
      planningSlots: basePlanningSlots,
      planningSlotMinutes: planningSlotMinutes,
      layoutMinutesPerSlot: layoutConfig.minutesPerSlot,
      layoutTotalSlots: layoutConfig.totalSlots,
    );
  }

  // Applica le eccezioni in ordine
  Set<int> finalPlanningSlots = Set<int>.from(basePlanningSlots);

  for (final exception in exceptions) {
    final exceptionSlots = exception.toSlotIndices(
      minutesPerSlot: planningSlotMinutes,
      totalSlotsPerDay: planningTotalSlots,
    );

    if (exception.type == AvailabilityExceptionType.available) {
      // AGGIUNGE disponibilit√† (es. turno extra)
      finalPlanningSlots = finalPlanningSlots.union(exceptionSlots);
    } else {
      // RIMUOVE disponibilit√† (es. ferie, malattia)
      finalPlanningSlots = finalPlanningSlots.difference(exceptionSlots);
    }
  }

  // 3Ô∏è‚É£ PROIEZIONE: planning step -> slot UI agenda
  return _projectPlanningSlotsToLayoutSlots(
    planningSlots: finalPlanningSlots,
    planningSlotMinutes: planningSlotMinutes,
    layoutMinutesPerSlot: layoutConfig.minutesPerSlot,
    layoutTotalSlots: layoutConfig.totalSlots,
  );
});

Set<int> _projectPlanningSlotsToLayoutSlots({
  required Set<int> planningSlots,
  required int planningSlotMinutes,
  required int layoutMinutesPerSlot,
  required int layoutTotalSlots,
}) {
  if (planningSlots.isEmpty) return const {};

  // Mappa minuti disponibili (0..1439) derivati dagli slot planning.
  final availableMinutes = List<bool>.filled(24 * 60, false);
  for (final slot in planningSlots) {
    final start = slot * planningSlotMinutes;
    final end = start + planningSlotMinutes;
    if (start < 0 || start >= 24 * 60) continue;
    final clampedEnd = end.clamp(0, 24 * 60);
    for (int minute = start; minute < clampedEnd; minute++) {
      availableMinutes[minute] = true;
    }
  }

  // Uno slot UI √® disponibile solo se TUTTI i minuti nel suo intervallo sono disponibili.
  final layoutSlots = <int>{};
  for (int slot = 0; slot < layoutTotalSlots; slot++) {
    final start = slot * layoutMinutesPerSlot;
    final end = (start + layoutMinutesPerSlot).clamp(0, 24 * 60);
    var fullyAvailable = true;
    for (int minute = start; minute < end; minute++) {
      if (!availableMinutes[minute]) {
        fullyAvailable = false;
        break;
      }
    }
    if (fullyAvailable) {
      layoutSlots.add(slot);
    }
  }

  return layoutSlots;
}

/// Provider che verifica se uno slot specifico √® disponibile.
/// Pi√π efficiente per query puntuali.
final isSlotAvailableProvider =
    Provider.family<bool, ({int staffId, int slotIndex})>((ref, params) {
      final availableSlots = ref.watch(
        staffSlotAvailabilityProvider(params.staffId),
      );

      // Se il set √® vuoto, lo staff non √® disponibile
      if (availableSlots.isEmpty) {
        return false;
      }

      return availableSlots.contains(params.slotIndex);
    });

/// Provider che raggruppa gli slot non disponibili consecutivi
/// per ottimizzare il rendering (un solo widget per range).
///
/// Ritorna una lista di (startIndex, count) per ogni range non disponibile.
final unavailableSlotRangesProvider =
    Provider.family<List<({int startIndex, int count})>, int>((ref, staffId) {
      final availableSlots = ref.watch(staffSlotAvailabilityProvider(staffId));
      final layoutConfig = ref.watch(layoutConfigProvider);
      final totalSlots = layoutConfig.totalSlots;

      // Se il set √® vuoto, l'intera giornata √® non disponibile
      if (availableSlots.isEmpty) {
        return [(startIndex: 0, count: totalSlots)];
      }

      final List<({int startIndex, int count})> ranges = [];
      int? rangeStart;
      int rangeCount = 0;

      for (int i = 0; i < totalSlots; i++) {
        final isAvailable = availableSlots.contains(i);

        if (!isAvailable) {
          // Slot non disponibile
          if (rangeStart == null) {
            rangeStart = i;
            rangeCount = 1;
          } else {
            rangeCount++;
          }
        } else {
          // Slot disponibile: chiudi il range precedente se esiste
          if (rangeStart != null) {
            ranges.add((startIndex: rangeStart, count: rangeCount));
            rangeStart = null;
            rangeCount = 0;
          }
        }
      }

      // Chiudi l'ultimo range se necessario
      if (rangeStart != null) {
        ranges.add((startIndex: rangeStart, count: rangeCount));
      }

      return ranges;
    });
--- FILE: lib/features/agenda/providers/staff_filter_providers.dart ---
import 'package:agenda_backend/core/services/preferences_service.dart';
import 'package:agenda_backend/features/auth/providers/current_business_user_provider.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/staff.dart';
import '../domain/staff_filter_mode.dart';
import 'business_providers.dart';
import 'staff_slot_availability_provider.dart';

/// Provider per la modalit√† di filtro staff corrente.
final staffFilterModeProvider =
    NotifierProvider<StaffFilterModeNotifier, StaffFilterMode>(
      StaffFilterModeNotifier.new,
    );

class StaffFilterModeNotifier extends Notifier<StaffFilterMode> {
  @override
  StaffFilterMode build() {
    final businessId = ref.watch(currentBusinessIdProvider);
    if (businessId <= 0) return StaffFilterMode.onDutyTeam;

    // Carica da preferenze salvate
    final prefs = ref.watch(preferencesServiceProvider);
    final saved = prefs.getStaffFilterMode(businessId);
    if (saved != null) {
      return StaffFilterMode.values.firstWhere(
        (m) => m.name == saved,
        orElse: () => StaffFilterMode.onDutyTeam,
      );
    }
    return StaffFilterMode.onDutyTeam;
  }

  void set(StaffFilterMode mode) {
    state = mode;
    // Salva in preferenze
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId > 0) {
      ref
          .read(preferencesServiceProvider)
          .setStaffFilterMode(businessId, mode.name);
    }
  }
}

/// Provider per gli ID degli staff selezionati manualmente.
final selectedStaffIdsProvider =
    NotifierProvider<SelectedStaffIdsNotifier, Set<int>>(
      SelectedStaffIdsNotifier.new,
    );

class SelectedStaffIdsNotifier extends Notifier<Set<int>> {
  @override
  Set<int> build() {
    final businessId = ref.watch(currentBusinessIdProvider);
    if (businessId <= 0) return {};

    // Carica da preferenze salvate
    final prefs = ref.watch(preferencesServiceProvider);
    final saved = prefs.getSelectedStaffIds(businessId);

    // Valida gli ID contro lo staff esistente nella location corrente
    final allStaff = ref.watch(staffForCurrentLocationProvider);
    final validIds = allStaff.map((s) => s.id).toSet();

    // Filtra solo gli ID che esistono ancora
    final validSavedIds = saved.where((id) => validIds.contains(id)).toSet();

    // Se c'erano ID salvati ma ora sono tutti invalidi, pulisci le preferenze
    if (saved.isNotEmpty && validSavedIds.isEmpty) {
      _saveAsync(businessId, {});
    }

    return validSavedIds;
  }

  void _save() {
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId > 0) {
      ref
          .read(preferencesServiceProvider)
          .setSelectedStaffIds(businessId, state);
    }
  }

  // Versione async per cleanup
  void _saveAsync(int businessId, Set<int> ids) {
    ref.read(preferencesServiceProvider).setSelectedStaffIds(businessId, ids);
  }

  void toggle(int staffId) {
    if (state.contains(staffId)) {
      state = {...state}..remove(staffId);
    } else {
      state = {...state, staffId};
    }
    _save();
  }

  void selectAll(List<Staff> staff) {
    state = staff.map((s) => s.id).toSet();
    _save();
  }

  void clear() {
    state = {};
    _save();
  }

  void setFromList(List<int> ids) {
    state = ids.toSet();
    _save();
  }
}

/// Provider che restituisce gli ID dello staff di turno per il giorno corrente.
final onDutyStaffIdsProvider = Provider<Set<int>>((ref) {
  final allStaff = ref.watch(staffForCurrentLocationProvider);
  final onDutyIds = <int>{};

  for (final staff in allStaff) {
    final availableSlots = ref.watch(staffSlotAvailabilityProvider(staff.id));
    // Staff √® di turno se ha almeno uno slot disponibile nel giorno,
    // incluse eventuali eccezioni.
    if (availableSlots.isNotEmpty) {
      onDutyIds.add(staff.id);
    }
  }

  return onDutyIds;
});

/// Provider che restituisce lo staff filtrato in base alla modalit√† selezionata.
/// Se l'utente √® ruolo staff, vede solo se stesso.
final filteredStaffProvider = Provider<List<Staff>>((ref) {
  final allStaff = ref.watch(staffForCurrentLocationProvider);

  // Se l'utente √® ruolo staff, mostra solo se stesso
  final canViewAll = ref.watch(canViewAllAppointmentsProvider);
  final currentUserStaffId = ref.watch(currentUserStaffIdProvider);

  if (!canViewAll && currentUserStaffId != null) {
    return allStaff.where((s) => s.id == currentUserStaffId).toList();
  }

  // Altrimenti applica i filtri normali
  final mode = ref.watch(staffFilterModeProvider);
  final selectedIds = ref.watch(selectedStaffIdsProvider);
  final onDutyIds = ref.watch(onDutyStaffIdsProvider);

  switch (mode) {
    case StaffFilterMode.allTeam:
      return allStaff;

    case StaffFilterMode.onDutyTeam:
      // Restituisce solo lo staff di turno (anche lista vuota se nessuno √® di turno)
      return allStaff.where((s) => onDutyIds.contains(s.id)).toList();

    case StaffFilterMode.custom:
      // Restituisce solo gli staff selezionati (anche lista vuota se nessuno selezionato)
      return allStaff.where((s) => selectedIds.contains(s.id)).toList();
  }
});
--- FILE: lib/features/agenda/data/bookings_api.dart ---
import '../../../core/network/api_client.dart';
import '../domain/booking_response.dart';
import '../presentation/dialogs/recurrence_summary_dialog.dart';

/// Request per creare una serie ricorrente
class RecurringBookingRequest {
  final List<int> serviceIds;
  final int? staffId;
  final Map<String, int>? staffByService;
  final String startTime;
  final int? clientId;
  final String? notes;
  final String frequency;
  final int intervalValue;
  final int? maxOccurrences;
  final String? endDate;
  final String conflictStrategy;
  final List<int>? excludedIndices;

  const RecurringBookingRequest({
    required this.serviceIds,
    this.staffId,
    this.staffByService,
    required this.startTime,
    this.clientId,
    this.notes,
    required this.frequency,
    this.intervalValue = 1,
    this.maxOccurrences,
    this.endDate,
    this.conflictStrategy = 'skip',
    this.excludedIndices,
  });

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{
      'service_ids': serviceIds,
      'start_time': startTime,
      'recurrence': <String, dynamic>{
        'frequency': frequency,
        'interval_value': intervalValue,
        'conflict_strategy': conflictStrategy,
        if (maxOccurrences != null) 'max_occurrences': maxOccurrences,
        if (endDate != null) 'end_date': endDate,
      },
    };
    if (staffId != null) map['staff_id'] = staffId;
    if (staffByService != null) map['staff_by_service'] = staffByService;
    if (clientId != null) map['client_id'] = clientId;
    if (notes != null) map['notes'] = notes;
    if (excludedIndices != null && excludedIndices!.isNotEmpty) {
      map['excluded_indices'] = excludedIndices;
    }
    return map;
  }
}

/// Request item per creazione booking con staff/orario per ogni servizio
/// Include campi opzionali per override dei valori di default del servizio
class BookingItemRequest {
  final int serviceId;
  final int staffId;
  final String startTime;
  // Optional overrides (if null, backend uses service defaults)
  final int? serviceVariantId;
  final int? durationMinutes;
  final int? blockedExtraMinutes;
  final int? processingExtraMinutes;
  final double? price;

  const BookingItemRequest({
    required this.serviceId,
    required this.staffId,
    required this.startTime,
    this.serviceVariantId,
    this.durationMinutes,
    this.blockedExtraMinutes,
    this.processingExtraMinutes,
    this.price,
  });

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{
      'service_id': serviceId,
      'staff_id': staffId,
      'start_time': startTime,
    };
    if (serviceVariantId != null) map['service_variant_id'] = serviceVariantId;
    if (durationMinutes != null) map['duration_minutes'] = durationMinutes;
    if (blockedExtraMinutes != null) {
      map['blocked_extra_minutes'] = blockedExtraMinutes;
    }
    if (processingExtraMinutes != null) {
      map['processing_extra_minutes'] = processingExtraMinutes;
    }
    if (price != null) map['price'] = price;
    return map;
  }
}

/// API layer per Bookings - chiamate reali a agenda_core
class BookingsApi {
  final ApiClient _apiClient;

  BookingsApi({required ApiClient apiClient}) : _apiClient = apiClient;

  /// GET /v1/locations/{location_id}/bookings?date=YYYY-MM-DD[&staff_id=X]
  Future<List<BookingResponse>> fetchBookings({
    required int locationId,
    required String date,
    int? staffId,
  }) async {
    final data = await _apiClient.getBookings(
      locationId: locationId,
      date: date,
      staffId: staffId,
    );
    final List<dynamic> items = data['bookings'] ?? [];
    return items
        .map((json) => BookingResponse.fromJson(json as Map<String, dynamic>))
        .toList();
  }

  /// GET /v1/locations/{location_id}/bookings/{booking_id}
  Future<BookingResponse> fetchBooking({
    required int locationId,
    required int bookingId,
  }) async {
    final data = await _apiClient.getBooking(
      locationId: locationId,
      bookingId: bookingId,
    );
    return BookingResponse.fromJson(data);
  }

  /// POST /v1/locations/{location_id}/bookings
  Future<BookingResponse> createBooking({
    required int locationId,
    required String idempotencyKey,
    required List<int> serviceIds,
    required String startTime,
    int? staffId,
    int? clientId,
    String? notes,
  }) async {
    final data = await _apiClient.createBooking(
      locationId: locationId,
      idempotencyKey: idempotencyKey,
      serviceIds: serviceIds,
      startTime: startTime,
      staffId: staffId,
      clientId: clientId,
      notes: notes,
    );
    return BookingResponse.fromJson(data);
  }

  /// POST /v1/locations/{location_id}/bookings (new items format)
  Future<BookingResponse> createBookingWithItems({
    required int locationId,
    required String idempotencyKey,
    required List<BookingItemRequest> items,
    int? clientId,
    String? notes,
  }) async {
    final data = await _apiClient.createBookingWithItems(
      locationId: locationId,
      idempotencyKey: idempotencyKey,
      items: items.map((i) => i.toJson()).toList(),
      clientId: clientId,
      notes: notes,
    );
    return BookingResponse.fromJson(data);
  }

  /// PUT /v1/locations/{location_id}/bookings/{booking_id}
  Future<void> updateBooking({
    required int locationId,
    required int bookingId,
    String? status,
    String? notes,
    int? clientId,
    bool clearClient = false,
  }) async {
    await _apiClient.updateBooking(
      locationId: locationId,
      bookingId: bookingId,
      status: status,
      notes: notes,
      clientId: clientId,
      clearClient: clearClient,
    );
  }

  /// DELETE /v1/locations/{location_id}/bookings/{booking_id}
  Future<void> deleteBooking({
    required int locationId,
    required int bookingId,
  }) async {
    await _apiClient.deleteBooking(
      locationId: locationId,
      bookingId: bookingId,
    );
  }

  /// GET /v1/locations/{location_id}/appointments?date=YYYY-MM-DD
  Future<List<Map<String, dynamic>>> fetchAppointments({
    required int locationId,
    required String date,
  }) async {
    final data = await _apiClient.getAppointments(
      locationId: locationId,
      date: date,
    );
    final List<dynamic> items = data['appointments'] ?? [];
    return items.map((json) => json as Map<String, dynamic>).toList();
  }

  /// PATCH /v1/locations/{location_id}/appointments/{id}
  Future<void> updateAppointment({
    required int locationId,
    required int appointmentId,
    String? startTime,
    String? endTime,
    int? staffId,
    int? serviceId,
    int? serviceVariantId,
    String? serviceNameSnapshot,
    int? clientId,
    String? clientName,
    String? clientNameSnapshot,
    int? extraBlockedMinutes,
    int? extraProcessingMinutes,
    double? price,
    bool priceExplicitlySet = false,
  }) async {
    await _apiClient.updateAppointment(
      locationId: locationId,
      appointmentId: appointmentId,
      startTime: startTime,
      endTime: endTime,
      staffId: staffId,
      serviceId: serviceId,
      serviceVariantId: serviceVariantId,
      serviceNameSnapshot: serviceNameSnapshot,
      clientId: clientId,
      clientName: clientName,
      clientNameSnapshot: clientNameSnapshot,
      extraBlockedMinutes: extraBlockedMinutes,
      extraProcessingMinutes: extraProcessingMinutes,
      price: price,
      priceExplicitlySet: priceExplicitlySet,
    );
  }

  /// POST /v1/locations/{location_id}/appointments/{id}/cancel
  Future<void> cancelAppointment({
    required int locationId,
    required int appointmentId,
  }) async {
    await _apiClient.cancelAppointment(
      locationId: locationId,
      appointmentId: appointmentId,
    );
  }

  /// POST /v1/bookings/{booking_id}/items
  /// Add a new booking item (appointment) to an existing booking
  Future<Map<String, dynamic>> addBookingItem({
    required int bookingId,
    required int locationId,
    required int staffId,
    required int serviceId,
    required int serviceVariantId,
    required String startTime,
    required String endTime,
    String? serviceNameSnapshot,
    String? clientNameSnapshot,
    double? price,
    int? extraBlockedMinutes,
    int? extraProcessingMinutes,
  }) async {
    return _apiClient.addBookingItem(
      bookingId: bookingId,
      locationId: locationId,
      staffId: staffId,
      serviceId: serviceId,
      serviceVariantId: serviceVariantId,
      startTime: startTime,
      endTime: endTime,
      serviceNameSnapshot: serviceNameSnapshot,
      clientNameSnapshot: clientNameSnapshot,
      price: price,
      extraBlockedMinutes: extraBlockedMinutes,
      extraProcessingMinutes: extraProcessingMinutes,
    );
  }

  /// DELETE /v1/bookings/{booking_id}/items/{item_id}
  /// Delete a single booking item (appointment) from a booking
  Future<void> deleteBookingItem({
    required int bookingId,
    required int itemId,
  }) async {
    await _apiClient.deleteBookingItem(bookingId: bookingId, itemId: itemId);
  }

  /// POST /v1/locations/{location_id}/bookings/recurring/preview
  /// Preview a recurring booking series (without creating)
  /// Returns all dates with conflict information so user can review and exclude dates.
  Future<RecurringPreviewResult> previewRecurringBooking({
    required int locationId,
    required RecurringBookingRequest request,
  }) async {
    final response = await _apiClient.postRawResponse(
      '/v1/locations/$locationId/bookings/recurring/preview',
      data: request.toJson(),
    );
    return RecurringPreviewResult.fromJson(response);
  }

  /// POST /v1/locations/{location_id}/bookings/recurring
  /// Create a recurring booking series
  /// Note: This endpoint returns data at root level (not wrapped in 'data')
  Future<RecurringBookingResult> createRecurringBooking({
    required int locationId,
    required RecurringBookingRequest request,
  }) async {
    final response = await _apiClient.postRawResponse(
      '/v1/locations/$locationId/bookings/recurring',
      data: request.toJson(),
    );
    // Response has success, recurrence_rule_id, etc. at root level
    return RecurringBookingResult.fromJson(response);
  }

  /// GET /v1/bookings/recurring/{rule_id}
  /// Get all bookings in a recurring series
  Future<Map<String, dynamic>> getRecurringSeries({required int ruleId}) async {
    return _apiClient.get('/v1/bookings/recurring/$ruleId');
  }

  /// PATCH /v1/bookings/recurring/{rule_id}
  /// Modify bookings in a recurring series
  Future<Map<String, dynamic>> modifyRecurringSeries({
    required int ruleId,
    required String scope,
    int? fromIndex,
    int? staffId,
    String? notes,
    String? time,
  }) async {
    final queryParams = <String, String>{'scope': scope};
    if (fromIndex != null) queryParams['from_index'] = fromIndex.toString();

    final requestData = <String, dynamic>{};
    if (staffId != null) requestData['staff_id'] = staffId;
    if (notes != null) requestData['notes'] = notes;
    if (time != null) requestData['time'] = time;

    final queryString = queryParams.entries
        .map((e) => '${e.key}=${e.value}')
        .join('&');

    return _apiClient.patch(
      '/v1/bookings/recurring/$ruleId?$queryString',
      data: requestData,
    );
  }

  /// DELETE /v1/bookings/recurring/{rule_id}
  /// Cancel bookings in a recurring series
  Future<Map<String, dynamic>> cancelRecurringSeries({
    required int ruleId,
    required String scope,
    int? fromIndex,
  }) async {
    final queryParams = <String, String>{'scope': scope};
    if (fromIndex != null) queryParams['from_index'] = fromIndex.toString();

    final queryString = queryParams.entries
        .map((e) => '${e.key}=${e.value}')
        .join('&');

    return _apiClient.delete('/v1/bookings/recurring/$ruleId?$queryString');
  }
}
--- FILE: lib/features/agenda/data/bookings_repository.dart ---
import '../../../core/models/appointment.dart';
import '../../../core/network/api_client.dart';
import '../domain/booking_response.dart';
import 'bookings_api.dart';

/// Metadata di un booking estratto dalla risposta appointments
class BookingMetadata {
  final int id;
  final int businessId;
  final int locationId;
  final int? clientId;
  final String? clientName;
  final String? notes;
  final String? status;

  const BookingMetadata({
    required this.id,
    required this.businessId,
    required this.locationId,
    this.clientId,
    this.clientName,
    this.notes,
    this.status,
  });
}

/// Risultato contenente appointments e metadata dei booking
class AppointmentsWithMetadata {
  final List<Appointment> appointments;
  final Map<int, BookingMetadata> bookingMetadata;

  const AppointmentsWithMetadata({
    required this.appointments,
    required this.bookingMetadata,
  });
}

/// Repository per gestione Bookings
/// Converte BookingResponse API in Appointment per uso interno
class BookingsRepository {
  BookingsRepository({required ApiClient apiClient})
    : _api = BookingsApi(apiClient: apiClient);

  final BookingsApi _api;

  /// Carica gli appuntamenti per una location in una data specifica
  Future<List<Appointment>> getAppointments({
    required int locationId,
    required int businessId,
    required DateTime date,
    int? staffId,
  }) async {
    final result = await getAppointmentsWithMetadata(
      locationId: locationId,
      businessId: businessId,
      date: date,
      staffId: staffId,
    );
    return result.appointments;
  }

  /// Carica gli appuntamenti con i metadata dei booking (incluse le note)
  Future<AppointmentsWithMetadata> getAppointmentsWithMetadata({
    required int locationId,
    required int businessId,
    required DateTime date,
    int? staffId,
  }) async {
    final dateStr =
        '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';

    // Usa la nuova API appointments che ritorna direttamente gli appointment items
    try {
      final rawAppointments = await _api.fetchAppointments(
        locationId: locationId,
        date: dateStr,
      );

      final appointments = <Appointment>[];
      final bookingMetadata = <int, BookingMetadata>{};

      for (final json in rawAppointments) {
        appointments.add(_appointmentFromJson(json, businessId));

        // Estrai booking metadata (una volta per booking)
        final bookingId = json['booking_id'] as int;
        if (!bookingMetadata.containsKey(bookingId)) {
          bookingMetadata[bookingId] = BookingMetadata(
            id: bookingId,
            businessId: json['business_id'] as int? ?? businessId,
            locationId: json['location_id'] as int,
            clientId: json['client_id'] as int?,
            clientName: json['client_name'] as String?,
            notes: json['booking_notes'] as String?,
            status: json['booking_status'] as String?,
          );
        }
      }

      return AppointmentsWithMetadata(
        appointments: appointments,
        bookingMetadata: bookingMetadata,
      );
    } catch (e) {
      // Fallback: usa bookings API se appointments non disponibile
      final bookings = await _api.fetchBookings(
        locationId: locationId,
        date: dateStr,
        staffId: staffId,
      );

      final appointments = <Appointment>[];
      final bookingMetadata = <int, BookingMetadata>{};

      for (final booking in bookings) {
        // Estrai booking metadata
        bookingMetadata[booking.id] = BookingMetadata(
          id: booking.id,
          businessId: booking.businessId,
          locationId: booking.locationId,
          clientId: booking.clientId,
          clientName: booking.clientName,
          notes: booking.notes,
          status: booking.status,
        );

        for (final item in booking.items) {
          appointments.add(_toAppointment(booking, item, businessId));
        }
      }

      return AppointmentsWithMetadata(
        appointments: appointments,
        bookingMetadata: bookingMetadata,
      );
    }
  }

  /// Crea un nuovo booking (formato legacy con staff singolo per tutti i servizi)
  Future<BookingResponse> createBooking({
    required int locationId,
    required String idempotencyKey,
    required List<int> serviceIds,
    required String startTime,
    int? staffId,
    int? clientId,
    String? notes,
  }) async {
    return _api.createBooking(
      locationId: locationId,
      idempotencyKey: idempotencyKey,
      serviceIds: serviceIds,
      startTime: startTime,
      staffId: staffId,
      clientId: clientId,
      notes: notes,
    );
  }

  /// Crea un nuovo booking con items (staff e orario separati per ogni servizio)
  Future<BookingResponse> createBookingWithItems({
    required int locationId,
    required String idempotencyKey,
    required List<BookingItemRequest> items,
    int? clientId,
    String? notes,
  }) async {
    return _api.createBookingWithItems(
      locationId: locationId,
      idempotencyKey: idempotencyKey,
      items: items,
      clientId: clientId,
      notes: notes,
    );
  }

  /// Aggiorna un booking esistente
  Future<void> updateBooking({
    required int locationId,
    required int bookingId,
    String? status,
    String? notes,
    int? clientId,
    bool clearClient = false,
  }) {
    return _api.updateBooking(
      locationId: locationId,
      bookingId: bookingId,
      status: status,
      notes: notes,
      clientId: clientId,
      clearClient: clearClient,
    );
  }

  /// Cancella un booking
  Future<void> deleteBooking({
    required int locationId,
    required int bookingId,
  }) async {
    return _api.deleteBooking(locationId: locationId, bookingId: bookingId);
  }

  /// Aggiorna un appuntamento (reschedule)
  Future<void> updateAppointment({
    required int locationId,
    required int appointmentId,
    DateTime? startTime,
    DateTime? endTime,
    int? staffId,
    int? serviceId,
    int? serviceVariantId,
    String? serviceNameSnapshot,
    int? clientId,
    String? clientName,
    String? clientNameSnapshot,
    int? extraBlockedMinutes,
    int? extraProcessingMinutes,
    double? price,
    bool priceExplicitlySet = false,
  }) async {
    return _api.updateAppointment(
      locationId: locationId,
      appointmentId: appointmentId,
      startTime: startTime?.toIso8601String(),
      endTime: endTime?.toIso8601String(),
      staffId: staffId,
      serviceId: serviceId,
      serviceVariantId: serviceVariantId,
      serviceNameSnapshot: serviceNameSnapshot,
      clientId: clientId,
      clientName: clientName,
      clientNameSnapshot: clientNameSnapshot,
      extraBlockedMinutes: extraBlockedMinutes,
      extraProcessingMinutes: extraProcessingMinutes,
      price: price,
      priceExplicitlySet: priceExplicitlySet,
    );
  }

  /// Cancella un appuntamento
  Future<void> cancelAppointment({
    required int locationId,
    required int appointmentId,
  }) async {
    return _api.cancelAppointment(
      locationId: locationId,
      appointmentId: appointmentId,
    );
  }

  /// Aggiunge un nuovo booking item (appointment) a un booking esistente
  Future<Appointment> addBookingItem({
    required int bookingId,
    required int businessId,
    required int locationId,
    required int staffId,
    required int serviceId,
    required int serviceVariantId,
    required DateTime startTime,
    required DateTime endTime,
    String? serviceNameSnapshot,
    String? clientNameSnapshot,
    double? price,
    int? extraBlockedMinutes,
    int? extraProcessingMinutes,
  }) async {
    final json = await _api.addBookingItem(
      bookingId: bookingId,
      locationId: locationId,
      staffId: staffId,
      serviceId: serviceId,
      serviceVariantId: serviceVariantId,
      startTime: startTime.toIso8601String(),
      endTime: endTime.toIso8601String(),
      serviceNameSnapshot: serviceNameSnapshot,
      clientNameSnapshot: clientNameSnapshot,
      price: price,
      extraBlockedMinutes: extraBlockedMinutes,
      extraProcessingMinutes: extraProcessingMinutes,
    );
    return _appointmentFromJson(json, businessId);
  }

  /// Elimina un singolo booking item (appointment) da un booking
  Future<void> deleteBookingItem({
    required int bookingId,
    required int itemId,
  }) async {
    await _api.deleteBookingItem(bookingId: bookingId, itemId: itemId);
  }

  /// Converte JSON appointment API in Appointment interno
  Appointment _appointmentFromJson(Map<String, dynamic> json, int businessId) {
    return Appointment(
      id: json['id'] as int,
      bookingId: json['booking_id'] as int,
      businessId: json['business_id'] as int? ?? businessId,
      locationId: json['location_id'] as int,
      staffId: json['staff_id'] as int,
      serviceId: json['service_id'] as int? ?? 0,
      serviceVariantId: json['service_variant_id'] as int,
      clientId: json['client_id'] as int?,
      clientName: json['client_name'] as String? ?? '',
      serviceName: json['service_name'] as String? ?? 'Servizio',
      startTime: DateTime.parse(json['start_time'] as String),
      endTime: DateTime.parse(json['end_time'] as String),
      price: null, // Non sempre presente
      bookingSource: json['source'] as String?,
      bookingStatus: json['booking_status'] as String?,
      extraMinutes: json['extra_blocked_minutes'] as int?,
      extraMinutesType:
          (json['extra_blocked_minutes'] as int?) != null &&
              json['extra_blocked_minutes'] > 0
          ? ExtraMinutesType.blocked
          : null,
      extraBlockedMinutes: json['extra_blocked_minutes'] as int? ?? 0,
      extraProcessingMinutes: json['extra_processing_minutes'] as int? ?? 0,
    );
  }

  /// Converte un booking item API in Appointment interno
  Appointment _toAppointment(
    BookingResponse booking,
    BookingItemResponse item,
    int businessId,
  ) {
    return Appointment(
      id: item.id,
      bookingId: booking.id,
      businessId: businessId,
      locationId: booking.locationId,
      staffId: item.staffId,
      serviceId: item.serviceId,
      serviceVariantId: item.serviceVariantId ?? item.serviceId,
      clientId: booking.clientId,
      clientName: booking.clientName ?? '',
      serviceName: item.serviceName ?? 'Service ${item.serviceId}',
      startTime: item.startDateTime,
      endTime: item.endDateTime,
      price: item.price,
      bookingSource: booking.source,
      bookingStatus: booking.status,
    );
  }
}
--- FILE: lib/features/agenda/domain/config/agenda_theme.dart ---
import 'package:flutter/material.dart';

/// Tema visivo centralizzato per l'agenda.
/// Definisce colori, spessori, altezze e stili coerenti
/// per tutti i componenti della vista agenda.
///
/// In futuro potrai adattarlo dinamicamente (dark mode, branding, ecc.)
class AgendaTheme {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üé® COLORI BASE
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Colore principale per i separatori verticali/orizzontali
  static Color get dividerColor => Colors.grey.shade300;

  /// Colore per ombre leggere o bordi di separazione
  static Color get shadowColor => Colors.black.withOpacity(0.5);

  /// Colore di sfondo per lo slot orario
  static const Color backgroundHourSlot = Colors.white;

  /// Colore di sfondo per le intestazioni staff
  static Color staffHeaderBackground(Color base) =>
      base.withValues(alpha: 0.15);

  /// Colore del testo nelle intestazioni staff
  static const Color staffHeaderTextColor = Colors.black87;

  /// Colore del bordo di un appuntamento (card)
  static Color get appointmentBorder => Colors.grey.shade400;

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üíß OMBRE & BORDI
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Ombra leggera usata nei divider verticali
  static BoxShadow get subtleShadow =>
      BoxShadow(color: shadowColor, offset: const Offset(1, 0), blurRadius: 2);

  /// Stile base per i separatori verticali
  static BoxDecoration get verticalDividerDecoration =>
      BoxDecoration(color: dividerColor, boxShadow: [subtleShadow]);

  /// Stile base per i separatori orizzontali
  static BoxDecoration get horizontalDividerDecoration =>
      const BoxDecoration(color: Colors.grey);

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üß± STILI TESTO
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  static const TextStyle staffHeaderTextStyle = TextStyle(
    fontWeight: FontWeight.bold,
    color: staffHeaderTextColor,
  );

  static const TextStyle hourTextStyle = TextStyle(
    fontSize: 13,
    fontWeight: FontWeight.bold,
    color: Colors.black87,
  );

  static const TextStyle appointmentTextStyle = TextStyle(
    fontSize: 14,
    color: Colors.black87,
  );

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üëª EFFETTO DRAG / FANTASMA
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Opacit√† del "fantasma" lasciato dalla card originale durante il drag.
  /// Regola questo valore per rendere il ghost pi√π o meno visibile.
  static const double ghostOpacity = 0.50;

  /// Durata dell'effetto fade-out del fantasma dopo il rilascio.
  /// Aumentala per una dissolvenza pi√π lenta e visibile.
  static const Duration ghostFadeDuration = Duration(milliseconds: 500);

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üö´ SLOT NON DISPONIBILI
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Colore delle linee diagonali per slot non disponibili.
  static Color unavailablePatternColor(ColorScheme scheme) =>
      scheme.onSurface.withOpacity(0.25);

  /// Colore di sfondo per slot non disponibili.
  static Color unavailableBackgroundColor(ColorScheme scheme) =>
      scheme.surfaceContainerHighest.withOpacity(0.6);

  /// Spaziatura tra le linee del pattern (in pixel).
  static const double unavailablePatternSpacing = 6.0;

  /// Spessore delle linee del pattern (in pixel).
  static const double unavailablePatternLineWidth = 1.5;
}
--- FILE: lib/features/agenda/domain/config/layout_config.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:flutter/material.dart';

/// Immutable snapshot of the current layout dimensions used by the agenda.
class LayoutConfig {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üìê Costanti strutturali
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  static const int hoursInDay = 24;
  static const List<int> slotDurationOptions = [15, 30, 60, 120];
  static const int minutesPerSlotConst = 15;

  static const double horizontalPadding = 8;
  static const double verticalPadding = 4;
  static const double columnInnerPadding = 2;
  static const double minColumnWidthMobile =
      100; // Larghezza minima colonna su mobile
  static const double minColumnWidthDesktop = 160;
  static const double borderRadius = 8;
  static const double borderWidth = 1;
  static const int maxVisibleStaff = 6;

  /// Larghezza della fascia laterale per il pulsante "+" sugli slot occupati
  static const double addButtonStripWidth = 28;

  static const double defaultHourColumnWidth = 60;
  static const double defaultHeaderHeight = 50;
  static const double defaultSlotHeight = 30;

  static const LayoutConfig initial = LayoutConfig(
    slotHeight: defaultSlotHeight,
    headerHeight: defaultHeaderHeight,
    hourColumnWidth: defaultHourColumnWidth,
    minutesPerSlot: minutesPerSlotConst,
    useClusterMaxConcurrency: true,
    useServiceColorsForAppointments: true,
    enableOccupiedSlotStrip: false,
    showTopbarAddLabel: false,
  );

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üìè Stato dinamico
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  final double slotHeight;
  final double headerHeight;
  final double hourColumnWidth;
  final int minutesPerSlot;
  final bool useClusterMaxConcurrency;
  final bool useServiceColorsForAppointments;

  /// Se true, riserva una fascia laterale quando ci sono slot completamente occupati.
  /// Permette di cliccare sullo spazio libero per creare nuovi appuntamenti.
  final bool enableOccupiedSlotStrip;

  /// Se true, il pulsante "Aggiungi" in topbar mostra anche la label.
  final bool showTopbarAddLabel;

  const LayoutConfig({
    required this.slotHeight,
    required this.headerHeight,
    required this.hourColumnWidth,
    required this.minutesPerSlot,
    required this.useClusterMaxConcurrency,
    required this.useServiceColorsForAppointments,
    required this.enableOccupiedSlotStrip,
    required this.showTopbarAddLabel,
  });

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! LayoutConfig) return false;
    return slotHeight == other.slotHeight &&
        headerHeight == other.headerHeight &&
        hourColumnWidth == other.hourColumnWidth &&
        minutesPerSlot == other.minutesPerSlot &&
        useClusterMaxConcurrency == other.useClusterMaxConcurrency &&
        useServiceColorsForAppointments ==
            other.useServiceColorsForAppointments &&
        enableOccupiedSlotStrip == other.enableOccupiedSlotStrip &&
        showTopbarAddLabel == other.showTopbarAddLabel;
  }

  @override
  int get hashCode => Object.hash(
    slotHeight,
    headerHeight,
    hourColumnWidth,
    minutesPerSlot,
    useClusterMaxConcurrency,
    useServiceColorsForAppointments,
    enableOccupiedSlotStrip,
    showTopbarAddLabel,
  );

  LayoutConfig copyWith({
    double? slotHeight,
    double? headerHeight,
    double? hourColumnWidth,
    int? minutesPerSlot,
    bool? useClusterMaxConcurrency,
    bool? useServiceColorsForAppointments,
    bool? enableOccupiedSlotStrip,
    bool? showTopbarAddLabel,
  }) {
    return LayoutConfig(
      slotHeight: slotHeight ?? this.slotHeight,
      headerHeight: headerHeight ?? this.headerHeight,
      hourColumnWidth: hourColumnWidth ?? this.hourColumnWidth,
      minutesPerSlot: minutesPerSlot ?? this.minutesPerSlot,
      useClusterMaxConcurrency:
          useClusterMaxConcurrency ?? this.useClusterMaxConcurrency,
      useServiceColorsForAppointments:
          useServiceColorsForAppointments ??
          this.useServiceColorsForAppointments,
      enableOccupiedSlotStrip:
          enableOccupiedSlotStrip ?? this.enableOccupiedSlotStrip,
      showTopbarAddLabel: showTopbarAddLabel ?? this.showTopbarAddLabel,
    );
  }

  int get totalSlots => (hoursInDay * 60 ~/ minutesPerSlot);

  double get totalHeight => totalSlots * slotHeight;

  static bool isValidSlotDuration(int minutes) =>
      slotDurationOptions.contains(minutes);

  /// Calcola quanti staff possono essere mostrati in base alla larghezza schermo.
  int computeMaxVisibleStaff(
    double contentWidth, {
    required AppFormFactor formFactor,
  }) {
    final minWidth = formFactor == AppFormFactor.mobile
        ? minColumnWidthMobile
        : minColumnWidthDesktop;

    final usableWidth = contentWidth.clamp(0, double.infinity);
    final maxStaff = (usableWidth / minWidth).floor();
    return maxStaff.clamp(1, maxVisibleStaff);
  }

  /// Calcola dinamicamente la larghezza di ogni colonna staff.
  double computeAdaptiveColumnWidth({
    required double contentWidth,
    required int visibleStaffCount,
    required AppFormFactor formFactor,
  }) {
    final minWidth = formFactor == AppFormFactor.mobile
        ? minColumnWidthMobile
        : minColumnWidthDesktop;

    if (visibleStaffCount <= 0) {
      return minWidth;
    }

    final usableWidth = contentWidth.clamp(0, double.infinity);
    final idealWidth = usableWidth / visibleStaffCount;

    return idealWidth < minWidth ? minWidth : idealWidth;
  }

  /// Altezza header ‚Äúresponsive‚Äù basata sulla larghezza finestra.
  static double headerHeightFor(BuildContext context) {
    final width = MediaQuery.of(context).size.width;
    return headerHeightForWidth(width);
  }

  static double headerHeightForWidth(double width) {
    if (width >= 1024) return 110; // Desktop
    if (width >= 600) return 95; // Tablet
    return 80; // Mobile
  }

  /// Dimensione avatar staff "responsive" basata sulla larghezza finestra.
  static double avatarSizeFor(BuildContext context) {
    final width = MediaQuery.of(context).size.width;
    return avatarSizeForWidth(width);
  }

  static double avatarSizeForWidth(double width) {
    if (width >= 1024) return 65; // Desktop
    if (width >= 600) return 57; // Tablet
    return 52; // Mobile
  }
}
--- FILE: lib/features/agenda/domain/booking_response.dart ---
/// Risposta API per un booking con i suoi items
class BookingResponse {
  final int id;
  final int businessId;
  final int locationId;
  final int? clientId;
  final int? userId;
  final String? clientName;
  final String? notes;
  final String status;
  final String source;
  final double totalPrice;
  final int totalDurationMinutes;
  final String createdAt;
  final String updatedAt;
  final List<BookingItemResponse> items;
  final int? replacesBookingId;
  final int? replacedByBookingId;

  const BookingResponse({
    required this.id,
    required this.businessId,
    required this.locationId,
    this.clientId,
    this.userId,
    this.clientName,
    this.notes,
    required this.status,
    required this.source,
    required this.totalPrice,
    required this.totalDurationMinutes,
    required this.createdAt,
    required this.updatedAt,
    required this.items,
    this.replacesBookingId,
    this.replacedByBookingId,
  });

  /// Indica se questa prenotazione √® stata sostituita da un'altra
  bool get isReplaced => status == 'replaced' || replacedByBookingId != null;

  /// Indica se questa prenotazione sostituisce un'altra
  bool get isReplacement => replacesBookingId != null;

  factory BookingResponse.fromJson(Map<String, dynamic> json) {
    final itemsList = json['items'] as List<dynamic>? ?? [];
    return BookingResponse(
      id: json['id'] as int,
      businessId: json['business_id'] as int,
      locationId: json['location_id'] as int,
      clientId: json['client_id'] as int?,
      userId: json['user_id'] as int?,
      clientName: json['client_name'] as String?,
      notes: json['notes'] as String?,
      status: json['status'] as String? ?? 'pending',
      source: json['source'] as String? ?? 'online',
      totalPrice: (json['total_price'] as num?)?.toDouble() ?? 0.0,
      totalDurationMinutes: json['total_duration_minutes'] as int? ?? 0,
      createdAt: json['created_at'] as String? ?? '',
      updatedAt: json['updated_at'] as String? ?? '',
      items: itemsList
          .map((i) => BookingItemResponse.fromJson(i as Map<String, dynamic>))
          .toList(),
      replacesBookingId: json['replaces_booking_id'] as int?,
      replacedByBookingId: json['replaced_by_booking_id'] as int?,
    );
  }
}

/// Singolo item di un booking (un servizio prenotato)
class BookingItemResponse {
  final int id;
  final int? bookingId;
  final int serviceId;
  final int? serviceVariantId;
  final int staffId;
  final String startTime;
  final String endTime;
  final double price;
  final int durationMinutes;
  final String? serviceName;
  final String? staffDisplayName;

  const BookingItemResponse({
    required this.id,
    this.bookingId,
    required this.serviceId,
    this.serviceVariantId,
    required this.staffId,
    required this.startTime,
    required this.endTime,
    required this.price,
    required this.durationMinutes,
    this.serviceName,
    this.staffDisplayName,
  });

  factory BookingItemResponse.fromJson(Map<String, dynamic> json) {
    return BookingItemResponse(
      id: json['id'] as int,
      bookingId: json['booking_id'] as int?,
      serviceId: json['service_id'] as int,
      serviceVariantId: json['service_variant_id'] as int?,
      staffId: json['staff_id'] as int,
      startTime: json['start_time'] as String,
      endTime: json['end_time'] as String,
      price: (json['price'] as num?)?.toDouble() ?? 0.0,
      durationMinutes: json['duration_minutes'] as int? ?? 0,
      serviceName: json['service_name'] as String?,
      staffDisplayName:
          (json['staff_display_name'] ?? json['staff_name']) as String?,
    );
  }

  /// Converte start_time in DateTime
  DateTime get startDateTime => DateTime.parse(startTime);

  /// Converte end_time in DateTime
  DateTime get endDateTime => DateTime.parse(endTime);
}
--- FILE: lib/features/agenda/domain/staff_filter_mode.dart ---
/// Modalit√† di filtro per lo staff nell'agenda.
enum StaffFilterMode {
  /// Mostra tutto il team (tutti gli staff della location).
  allTeam,

  /// Mostra solo il team di turno (staff con disponibilit√† nel giorno selezionato).
  onDutyTeam,

  /// Selezione manuale di uno o pi√π membri dello staff.
  custom,
}
--- FILE: lib/features/agenda/domain/service_item_data.dart ---
import 'package:flutter/material.dart';

/// Rappresenta un singolo servizio in una prenotazione multi-servizio.
/// Usato internamente nel form di creazione/modifica prenotazione.
class ServiceItemData {
  final String key; // Chiave univoca per identificare l'item nella lista
  final int? appointmentId; // ID dell'appuntamento originale (null se nuovo)
  final int? serviceId;
  final int? serviceVariantId;
  final int? staffId;
  final TimeOfDay startTime;
  final int durationMinutes;
  final int blockedExtraMinutes;
  final int processingExtraMinutes;
  final double? price; // Prezzo personalizzato (null = usa prezzo variante)

  const ServiceItemData({
    required this.key,
    this.appointmentId,
    this.serviceId,
    this.serviceVariantId,
    this.staffId,
    required this.startTime,
    this.durationMinutes = 30,
    this.blockedExtraMinutes = 0,
    this.processingExtraMinutes = 0,
    this.price,
  });

  /// Calcola l'orario di fine basato su startTime e durationMinutes
  TimeOfDay get endTime {
    final totalMinutes =
        startTime.hour * 60 + startTime.minute + durationMinutes;
    return TimeOfDay(
      hour: (totalMinutes ~/ 60) % 24,
      minute: totalMinutes % 60,
    );
  }

  /// Calcola l'orario di fine con durata opzionale esterna (es. da variant)
  TimeOfDay getEndTime([int? externalDuration]) {
    final duration = externalDuration ?? durationMinutes;
    final totalMinutes = startTime.hour * 60 + startTime.minute + duration;
    return TimeOfDay(
      hour: (totalMinutes ~/ 60) % 24,
      minute: totalMinutes % 60,
    );
  }

  /// Calcola il prossimo orario di inizio (per il servizio successivo)
  TimeOfDay get nextStartTime => endTime;

  ServiceItemData copyWith({
    String? key,
    int? appointmentId,
    int? serviceId,
    int? serviceVariantId,
    int? staffId,
    TimeOfDay? startTime,
    int? durationMinutes,
    int? blockedExtraMinutes,
    int? processingExtraMinutes,
    double? price,
  }) {
    return ServiceItemData(
      key: key ?? this.key,
      appointmentId: appointmentId ?? this.appointmentId,
      serviceId: serviceId ?? this.serviceId,
      serviceVariantId: serviceVariantId ?? this.serviceVariantId,
      staffId: staffId ?? this.staffId,
      startTime: startTime ?? this.startTime,
      durationMinutes: durationMinutes ?? this.durationMinutes,
      blockedExtraMinutes: blockedExtraMinutes ?? this.blockedExtraMinutes,
      processingExtraMinutes:
          processingExtraMinutes ?? this.processingExtraMinutes,
      price: price ?? this.price,
    );
  }

  /// Crea una copia azzerando il prezzo personalizzato
  ServiceItemData copyWithPriceCleared() {
    return ServiceItemData(
      key: key,
      appointmentId: appointmentId,
      serviceId: serviceId,
      serviceVariantId: serviceVariantId,
      staffId: staffId,
      startTime: startTime,
      durationMinutes: durationMinutes,
      blockedExtraMinutes: blockedExtraMinutes,
      processingExtraMinutes: processingExtraMinutes,
      price: null,
    );
  }

  /// Crea una copia con serviceId e staffId resettati a null
  ServiceItemData clearService() {
    return ServiceItemData(
      key: key,
      appointmentId: appointmentId,
      serviceId: null,
      serviceVariantId: null,
      staffId: null,
      startTime: startTime,
      durationMinutes: 30,
      blockedExtraMinutes: 0,
      processingExtraMinutes: 0,
      price: null,
    );
  }

  bool get hasBlockedExtra => blockedExtraMinutes > 0;
  bool get hasProcessingExtra => processingExtraMinutes > 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ServiceItemData &&
          runtimeType == other.runtimeType &&
          key == other.key;

  @override
  int get hashCode => key.hashCode;
}
--- FILE: lib/features/agenda/presentation/screens/helper/layout_geometry_helper.dart ---
import 'dart:math' as math;

class LayoutEntry {
  const LayoutEntry({
    required this.id,
    required this.start,
    required this.end,
  });

  final int id;
  final DateTime start;
  final DateTime end;
}

class EventGeometry {
  const EventGeometry({
    required this.leftFraction,
    required this.widthFraction,
  });

  final double leftFraction;
  final double widthFraction;
}

Map<int, EventGeometry> computeLayoutGeometry(
  List<LayoutEntry> entries, {
  bool useClusterMaxConcurrency = false,
}) {
  if (entries.isEmpty) return const {};

  final sorted = entries.toList()
    ..sort((a, b) => a.start.compareTo(b.start));
  final clusters = <List<LayoutEntry>>[];

  var currentCluster = <LayoutEntry>[];
  DateTime? currentMaxEnd;

  for (final entry in sorted) {
    if (currentCluster.isEmpty) {
      currentCluster = [entry];
      currentMaxEnd = entry.end;
      continue;
    }

    if (entry.start.isBefore(currentMaxEnd!)) {
      currentCluster.add(entry);
      if (entry.end.isAfter(currentMaxEnd)) {
        currentMaxEnd = entry.end;
      }
    } else {
      clusters.add(List<LayoutEntry>.from(currentCluster));
      currentCluster = [entry];
      currentMaxEnd = entry.end;
    }
  }

  if (currentCluster.isNotEmpty) {
    clusters.add(List<LayoutEntry>.from(currentCluster));
  }

  final geometryMap = <int, EventGeometry>{};

  for (final cluster in clusters) {
    final columnAssignments = _assignColumns(cluster);
    final concurrencyMap = _computeConcurrency(cluster);

    if (useClusterMaxConcurrency) {
      final clusterMaxConcurrency =
          concurrencyMap.values.fold<int>(1, math.max);
      final totalColumns =
          math.max(clusterMaxConcurrency, 1); // evita divisione per zero

      final columnMap = <int, List<LayoutEntry>>{};
      for (final entry in cluster) {
        final columnIndex = columnAssignments[entry.id] ?? 0;
        columnMap.putIfAbsent(columnIndex, () => []).add(entry);
      }

      for (final entry in cluster) {
        final columnIndex = columnAssignments[entry.id] ?? 0;
        int widthInColumns = 1;

        while (columnIndex + widthInColumns < totalColumns) {
          final candidateColumn = columnIndex + widthInColumns;
          final occupants = columnMap[candidateColumn];
          final hasOverlap = occupants?.any(
                (other) =>
                    _entriesOverlap(entry, other) &&
                    other.id != entry.id,
              ) ??
              false;

          if (hasOverlap) {
            break;
          }

          widthInColumns++;
        }

        for (int col = columnIndex; col < columnIndex + widthInColumns; col++) {
          final list = columnMap.putIfAbsent(col, () => []);
          if (!list.contains(entry)) {
            list.add(entry);
          }
        }

        final widthFraction = widthInColumns / totalColumns;
        final leftFraction = columnIndex / totalColumns;
        geometryMap[entry.id] = EventGeometry(
          leftFraction: leftFraction,
          widthFraction: widthFraction,
        );
      }
    } else {
      for (final entry in cluster) {
        final concurrency = concurrencyMap[entry.id] ?? 1;
        final widthFraction = 1 / concurrency;
        final columnIndex = columnAssignments[entry.id] ?? 0;
        final leftFraction = columnIndex * widthFraction;
        geometryMap[entry.id] = EventGeometry(
          leftFraction: leftFraction,
          widthFraction: widthFraction,
        );
      }
    }
  }

  return geometryMap;
}

bool _entriesOverlap(LayoutEntry a, LayoutEntry b) {
  if (identical(a, b)) return false;
  return a.start.isBefore(b.end) && a.end.isAfter(b.start);
}

Map<int, int> _assignColumns(List<LayoutEntry> cluster) {
  final assignments = <int, int>{};
  final columnEndTimes = <DateTime>[];

  final ordered = cluster.toList()
    ..sort((a, b) {
      final compareStart = a.start.compareTo(b.start);
      if (compareStart != 0) return compareStart;
      return a.end.compareTo(b.end);
    });

  for (final entry in ordered) {
    int assignedColumn = -1;
    for (int i = 0; i < columnEndTimes.length; i++) {
      if (!entry.start.isBefore(columnEndTimes[i])) {
        assignedColumn = i;
        columnEndTimes[i] = entry.end;
        break;
      }
    }

    if (assignedColumn == -1) {
      assignedColumn = columnEndTimes.length;
      columnEndTimes.add(entry.end);
    }

    assignments[entry.id] = assignedColumn;
  }

  return assignments;
}

Map<int, int> _computeConcurrency(List<LayoutEntry> cluster) {
  final concurrencyMap = <int, int>{};

  for (final entry in cluster) {
    final edges = <_Edge>[];

    for (final other in cluster) {
      final overlapStart = entry.start.isAfter(other.start)
          ? entry.start
          : other.start;
      final overlapEnd = entry.end.isBefore(other.end)
          ? entry.end
          : other.end;

      if (overlapStart.isBefore(overlapEnd)) {
        edges.add(_Edge(overlapStart, 1));
        edges.add(_Edge(overlapEnd, -1));
      }
    }

    edges.sort((a, b) {
      final compare = a.instant.compareTo(b.instant);
      if (compare != 0) return compare;
      if (a.delta == b.delta) return 0;
      return a.delta == -1 ? -1 : 1;
    });

    int active = 0;
    int maxActive = 0;
    for (final edge in edges) {
      active += edge.delta;
      if (active > maxActive) {
        maxActive = active;
      }
    }

    concurrencyMap[entry.id] = math.max(maxActive, 1);
  }

  return concurrencyMap;
}

class _Edge {
  const _Edge(this.instant, this.delta);

  final DateTime instant;
  final int delta;
}
--- FILE: lib/features/agenda/presentation/screens/helper/drag_drop_helper.dart ---
import 'package:flutter/material.dart';

import '/core/models/appointment.dart';
import '../../../domain/config/layout_config.dart';

class DropComputationParams {
  const DropComputationParams({
    required this.appointment,
    required this.layoutConfig,
    required this.columnHeight,
    required this.localPointer,
    required this.dragOffsetY,
    required this.draggedCardHeightPx,
    required this.previewTimes,
  });

  final Appointment appointment;
  final LayoutConfig layoutConfig;
  final double columnHeight;
  final Offset localPointer;
  final double dragOffsetY;
  final double draggedCardHeightPx;
  final (DateTime, DateTime)? previewTimes;
}

class DropComputationResult {
  const DropComputationResult({
    required this.newStart,
    required this.newEnd,
  });

  final DateTime newStart;
  final DateTime newEnd;
}

DropComputationResult computeDropResult(DropComputationParams params) {
  final layoutConfig = params.layoutConfig;
  final slotHeight = layoutConfig.slotHeight;
  final minutesPerSlot = layoutConfig.minutesPerSlot;

  final maxYStartPx =
      (params.columnHeight - params.draggedCardHeightPx)
          .clamp(0, params.columnHeight)
          .toDouble();
  final clampedLocalDy =
      params.localPointer.dy.clamp(0.0, params.columnHeight.toDouble());
  final effectiveDy =
      (clampedLocalDy - params.dragOffsetY).clamp(0.0, maxYStartPx).toDouble();

  final rawTop = params.localPointer.dy - params.dragOffsetY;
  final rawBottom = rawTop + params.draggedCardHeightPx;
  final isAboveBounds = rawTop < 0;
  final isBelowBounds = rawBottom > params.columnHeight;

  final appointment = params.appointment;
  final duration = appointment.endTime.difference(appointment.startTime);
  final durationMinutes = duration.inMinutes;

  final baseDate = DateTime(
    appointment.startTime.year,
    appointment.startTime.month,
    appointment.startTime.day,
  );

  DateTime newStart;
  DateTime newEnd;

  final previewTimes = params.previewTimes;
  if (previewTimes != null) {
    newStart = previewTimes.$1;
    newEnd = previewTimes.$2;
  } else {
    final minutesFromTop =
        (effectiveDy / slotHeight) * minutesPerSlot;
    double roundedMinutes = (minutesFromTop / 5).round() * 5;

    const totalMinutes = LayoutConfig.hoursInDay * 60; // 1440
    final maxStartMinutesNum =
        (totalMinutes - durationMinutes).clamp(0, totalMinutes);

    int startMinutes = roundedMinutes.toInt();
    final maxStartMinutes = maxStartMinutesNum.toInt();

    if (startMinutes > maxStartMinutes) startMinutes = maxStartMinutes;
    if (startMinutes < 0) startMinutes = 0;

    final endMinutes =
        (startMinutes + durationMinutes).clamp(0, totalMinutes).toInt();

    newStart = baseDate.add(Duration(minutes: startMinutes));

    final rawEnd = baseDate.add(Duration(minutes: endMinutes));
    final dayBoundary = baseDate.add(const Duration(days: 1));
    newEnd = rawEnd.isAfter(dayBoundary) ? dayBoundary : rawEnd;
  }

  if (isAboveBounds) {
    newStart = baseDate;
    final cappedEnd =
        baseDate.add(Duration(minutes: durationMinutes));
    final dayEnd = baseDate.add(const Duration(days: 1));
    newEnd = cappedEnd.isBefore(dayEnd) ? cappedEnd : dayEnd;
  }

  if (isBelowBounds) {
    final dayEnd = baseDate.add(const Duration(days: 1));
    newEnd = dayEnd;
    final candidateStart =
        dayEnd.subtract(Duration(minutes: durationMinutes));
    newStart = candidateStart.isAfter(baseDate)
        ? candidateStart
        : baseDate;
  }

  return DropComputationResult(
    newStart: newStart,
    newEnd: newEnd,
  );
}
--- FILE: lib/features/agenda/presentation/screens/helper/responsive_layout.dart ---
import 'dart:math' as math;

import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/config/layout_config.dart';

class ResponsiveLayout {
  final double columnWidth;
  final double slotHeight;
  final int maxVisibleStaff;
  final int totalSlots;

  const ResponsiveLayout({
    required this.columnWidth,
    required this.slotHeight,
    required this.maxVisibleStaff,
    required this.totalSlots,
  });

  static ResponsiveLayout of(
    BuildContext context, {
    required int staffCount,
    required LayoutConfig config,
    double? availableWidth,
  }) {
    final screenWidth = availableWidth ?? MediaQuery.of(context).size.width;
    final container = ProviderScope.containerOf(context, listen: false);
    final formFactor = container.read(formFactorProvider);

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // üìê Calcolo larghezza colonne staff
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    final dynamicMaxVisible = formFactor == AppFormFactor.mobile
        ? 3 // Permette fino a 3 colonne su mobile
        : config.computeMaxVisibleStaff(screenWidth, formFactor: formFactor);
    final visibleStaff = staffCount.clamp(1, dynamicMaxVisible);

    final columnWidth = config.computeAdaptiveColumnWidth(
      contentWidth: screenWidth,
      visibleStaffCount: visibleStaff,
      formFactor: formFactor,
    );
    final devicePixelRatio = MediaQuery.of(context).devicePixelRatio;
    final snappedColumnWidth = devicePixelRatio > 0
        ? (columnWidth * devicePixelRatio).floorToDouble() / devicePixelRatio
        : columnWidth;
    final minWidth = formFactor == AppFormFactor.mobile
        ? LayoutConfig.minColumnWidthMobile
        : LayoutConfig.minColumnWidthDesktop;
    final resolvedColumnWidth = math.max(snappedColumnWidth, minWidth);

    return ResponsiveLayout(
      columnWidth: resolvedColumnWidth,
      slotHeight: config.slotHeight,
      maxVisibleStaff: dynamicMaxVisible,
      totalSlots: config.totalSlots,
    );
  }

  double get totalHeight => totalSlots * slotHeight;
}
--- FILE: lib/features/agenda/presentation/screens/helper/free_duration_helper.dart ---
import 'dart:math' as math;

import '../../../../../core/models/appointment.dart';
import '../../../domain/config/layout_config.dart';

/// Computes the amount of free minutes starting from the given [index] slot.
///
/// Behavior:
/// - If the slot is fully occupied by one or more appointments -> returns 0.
/// - If the slot is partially occupied -> returns only the free minutes
///   inside that slot (no look-ahead aggregation).
/// - If the slot is totally free -> extends over subsequent contiguous
///   free slots until the next busy slot (original behavior).
Duration computeFreeDurationForSlot(
  int index,
  List<Appointment> appointments,
  LayoutConfig layout,
) {
  final slotStart = Duration(minutes: index * layout.minutesPerSlot);
  final slotEnd = Duration(minutes: (index + 1) * layout.minutesPerSlot);
  final slotDurationMinutes = layout.minutesPerSlot;

  // Collect overlaps of appointments within the current slot.
  final overlaps =
      <(int, int)>[]; // intervals [start, end) in minutes relative to slot
  for (final a in appointments) {
    final apptStart = Duration(
      hours: a.startTime.hour,
      minutes: a.startTime.minute,
    );
    final apptEnd = Duration(hours: a.endTime.hour, minutes: a.endTime.minute);
    if (slotStart < apptEnd && slotEnd > apptStart) {
      final overlapStart = apptStart > slotStart ? apptStart : slotStart;
      final overlapEnd = apptEnd < slotEnd ? apptEnd : slotEnd;
      final relativeStart = overlapStart.inMinutes - slotStart.inMinutes;
      final relativeEnd = overlapEnd.inMinutes - slotStart.inMinutes;
      overlaps.add((
        relativeStart.clamp(0, slotDurationMinutes),
        relativeEnd.clamp(0, slotDurationMinutes),
      ));
    }
  }

  if (overlaps.isNotEmpty) {
    // Merge intervals to avoid double counting.
    overlaps.sort((a, b) => a.$1.compareTo(b.$1));
    final merged = <(int, int)>[];
    for (final o in overlaps) {
      if (merged.isEmpty) {
        merged.add(o);
      } else {
        final last = merged.last;
        if (o.$1 <= last.$2) {
          merged[merged.length - 1] = (last.$1, math.max(last.$2, o.$2));
        } else {
          merged.add(o);
        }
      }
    }
    final coveredMinutes = merged.fold<int>(
      0,
      (sum, it) => sum + (it.$2 - it.$1),
    );
    if (coveredMinutes >= slotDurationMinutes) {
      return Duration.zero;
    } else {
      return Duration(minutes: slotDurationMinutes - coveredMinutes);
    }
  }

  // Fully free slot: extend to next busy slot.
  int nextBusy = layout.totalSlots;
  for (int i = index + 1; i < layout.totalSlots; i++) {
    final sStart = Duration(minutes: i * layout.minutesPerSlot);
    final sEnd = Duration(minutes: (i + 1) * layout.minutesPerSlot);
    final isBusy = appointments.any((a) {
      final start = Duration(
        hours: a.startTime.hour,
        minutes: a.startTime.minute,
      );
      final end = Duration(hours: a.endTime.hour, minutes: a.endTime.minute);
      return sStart < end && sEnd > start;
    });
    if (isBusy) {
      nextBusy = i;
      break;
    }
  }

  final freeSlotsCount = nextBusy - index;
  final freeMinutes = freeSlotsCount * layout.minutesPerSlot;
  return Duration(minutes: freeMinutes);
}
--- FILE: lib/features/agenda/presentation/screens/widgets/appointment_card_interactive.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/models/appointment.dart';
import '../../../../../../app/providers/form_factor_provider.dart';
import '../../../../../../core/l10n/l10_extension.dart';
import '../../../../../../core/widgets/app_dialogs.dart';
import '../../../../auth/providers/current_business_user_provider.dart';
import '../../../../clients/providers/clients_providers.dart';
import '../../../domain/config/agenda_theme.dart';
import '../../../domain/config/layout_config.dart';
import '../../../providers/agenda_interaction_lock_provider.dart';
import '../../../providers/agenda_providers.dart';
import '../../../providers/appointment_providers.dart';
import '../../../providers/bookings_provider.dart';
import '../../../providers/drag_layer_link_provider.dart';
import '../../../providers/drag_offset_provider.dart';
import '../../../providers/drag_session_provider.dart';
import '../../../providers/dragged_appointment_provider.dart';
import '../../../providers/dragged_base_range_provider.dart';
import '../../../providers/dragged_last_staff_provider.dart';
import '../../../providers/highlighted_staff_provider.dart';
import '../../../providers/is_resizing_provider.dart';
import '../../../providers/layout_config_provider.dart';
import '../../../providers/resizing_provider.dart';
import '../../../providers/selected_appointment_provider.dart';
import '../../../providers/staff_columns_geometry_provider.dart';
import '../../../providers/temp_drag_time_provider.dart';
import '../../widgets/appointment_dialog.dart';

/// üîπ Versione unificata per DESKTOP e MOBILE.
/// Mantiene drag, resize, ghost, select, ma cambia il comportamento del tap:
/// - Desktop ‚Üí seleziona la card.
/// - Mobile ‚Üí apre un bottom sheet con i dettagli.
class AppointmentCardInteractive extends ConsumerStatefulWidget {
  final Appointment appointment;
  final Color color;
  final double? columnWidth;
  final double? columnOffset;
  final double? dragTargetWidth;
  final bool expandToLeft;

  const AppointmentCardInteractive({
    super.key,
    required this.appointment,
    required this.color,
    this.columnWidth,
    this.columnOffset,
    this.dragTargetWidth,
    this.expandToLeft = false,
  });

  @override
  ConsumerState<AppointmentCardInteractive> createState() =>
      _AppointmentCardInteractiveState();
}

class _AppointmentCardInteractiveState
    extends ConsumerState<AppointmentCardInteractive> {
  Size? _lastSize;
  Offset? _lastPointerGlobalPosition;
  bool _isDraggingResize = false;
  bool _blockDragDuringResize = false;
  bool _selectedFromHover = false;
  int? _currentDragSessionId;
  late final AgendaCardHoverNotifier _hoverNotifier;

  static const double _dragBlockZoneHeight = 28.0;
  static const int _minSlotsForDragBlock = 3;

  LayoutConfig get _layoutConfig => ref.read(layoutConfigProvider);

  _CardStatusVisual? _statusVisual(BuildContext context) {
    final status = widget.appointment.bookingStatus;
    if (status == null) return null;

    switch (status) {
      case 'completed':
        return _CardStatusVisual(
          borderColor: Colors.green.shade800,
          fillColor: Colors.green.shade500,
          fillHighlightColor: Colors.green.shade200,
          label: context.l10n.statusCompleted,
        );
      case 'no_show':
        return _CardStatusVisual(
          borderColor: Colors.red.shade800,
          fillColor: Colors.red.shade500,
          fillHighlightColor: Colors.red.shade200,
          label: context.l10n.bookingsListStatusNoShow,
        );
      default:
        return null;
    }
  }

  @override
  void initState() {
    super.initState();
    _hoverNotifier = ref.read(agendaCardHoverProvider.notifier);
  }

  @override
  Widget build(BuildContext context) {
    final selection = ref.watch(selectedAppointmentProvider);
    final draggedId = ref.watch(draggedAppointmentIdProvider);
    final formFactor = ref.watch(formFactorProvider);
    final canManageBookings = ref.watch(currentUserCanManageBookingsProvider);

    final isSelected = selection.contains(widget.appointment.id);
    final isDragging = draggedId == widget.appointment.id;
    final showThickBorder = isSelected || isDragging;

    return MouseRegion(
      onEnter: (_) {
        _hoverNotifier.enter();
        _selectAppointment(ref, fromHover: true);
      },
      onExit: (_) {
        _hoverNotifier.exit();
        if (_selectedFromHover &&
            ref
                .read(selectedAppointmentProvider)
                .contains(widget.appointment.id) &&
            ref.read(draggedAppointmentIdProvider) != widget.appointment.id &&
            !ref.read(isResizingProvider)) {
          ref.read(selectedAppointmentProvider.notifier).clear();
          _selectedFromHover = false;
        }
      },
      child: LayoutBuilder(
        builder: (context, constraints) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            final size = Size(constraints.maxWidth, constraints.maxHeight);
            if (mounted && (_lastSize == null || _lastSize != size)) {
              setState(() => _lastSize = size);
            }
          });

          return Listener(
            onPointerDown: (e) {
              final cardBox = context.findRenderObject() as RenderBox?;
              if (cardBox != null) {
                _lastPointerGlobalPosition = e.position;
                _evaluateDragBlock(cardBox, e.position);
                ref
                    .read(draggedBaseRangeProvider.notifier)
                    .set(
                      widget.appointment.startTime,
                      widget.appointment.endTime,
                    );
                ref
                    .read(draggedLastStaffIdProvider.notifier)
                    .set(widget.appointment.staffId);

                final bodyBox = ref.read(dragBodyBoxProvider);
                if (bodyBox != null) {
                  final cardTopLeftGlobal = cardBox.localToGlobal(Offset.zero);
                  ref
                      .read(dragOffsetProvider.notifier)
                      .set(e.position.dy - cardTopLeftGlobal.dy);
                  ref
                      .read(dragOffsetXProvider.notifier)
                      .set(e.position.dx - cardTopLeftGlobal.dx);
                  final localStart = bodyBox.globalToLocal(e.position);
                  ref.read(dragPositionProvider.notifier).set(localStart);
                }
              }
            },
            onPointerMove: (e) {
              if (_isDraggingResize) {
                _performResizeUpdate(e);
                return;
              }
              final cardBox = context.findRenderObject() as RenderBox?;
              if (cardBox != null) {
                _evaluateDragBlock(cardBox, e.position);
              }
            },
            onPointerUp: (e) {
              if (_isDraggingResize) {
                _performResizeEnd();
                return;
              }
              if (ref.read(dragPositionProvider) != null) {
                ref.read(dragPositionProvider.notifier).clear();
              }
              _updateDragBlock(false);
              ref.read(draggedBaseRangeProvider.notifier).clear();
              ref.read(draggedLastStaffIdProvider.notifier).clear();
            },
            onPointerCancel: (e) {
              if (_isDraggingResize) {
                _performResizeCancel();
                return;
              }
              if (ref.read(dragPositionProvider) != null) {
                ref.read(dragPositionProvider.notifier).clear();
              }
              _updateDragBlock(false);
              ref.read(draggedBaseRangeProvider.notifier).clear();
              ref.read(draggedLastStaffIdProvider.notifier).clear();
            },
            child: GestureDetector(
              onTap: () {
                if (formFactor == AppFormFactor.mobile) {
                  _handleMobileTap();
                } else {
                  _handleDesktopTap();
                }
              },
              child: LongPressDraggable<Appointment>(
                data: widget.appointment,
                feedback: Consumer(
                  builder: (c, r, _) =>
                      _buildFollowerFeedback(c, r, isSelected),
                ),
                feedbackOffset: Offset.zero,
                dragAnchorStrategy: childDragAnchorStrategy,
                maxSimultaneousDrags:
                    (_blockDragDuringResize || !canManageBookings) ? 0 : 1,
                childWhenDragging: _buildCard(
                  isGhost: true,
                  showThickBorder: showThickBorder,
                  isSelected: isSelected,
                ),

                onDragStarted: () {
                  _currentDragSessionId = ref
                      .read(dragSessionProvider.notifier)
                      .start();
                  ref
                      .read(draggedBaseRangeProvider.notifier)
                      .set(
                        widget.appointment.startTime,
                        widget.appointment.endTime,
                      );
                  _selectAppointment(ref);
                  ref
                      .read(draggedAppointmentIdProvider.notifier)
                      .set(widget.appointment.id);

                  final bodyBox = ref.read(dragBodyBoxProvider);
                  if (bodyBox != null && _lastPointerGlobalPosition != null) {
                    final local = bodyBox.globalToLocal(
                      _lastPointerGlobalPosition!,
                    );
                    ref.read(dragPositionProvider.notifier).set(local);
                  }
                },

                onDragUpdate: (details) {
                  final prev = ref.read(dragPositionProvider);
                  final bodyBox = ref.read(dragBodyBoxProvider);
                  if (bodyBox != null) {
                    final local = bodyBox.globalToLocal(details.globalPosition);
                    ref
                        .read(dragPositionProvider.notifier)
                        .set(Offset.lerp(prev, local, 0.85)!);
                  }
                },

                onDragEnd: (details) => _handleDragEnd(ref, details),
                onDragCompleted: () => _handleEnd(ref, keepSelection: true),
                onDraggableCanceled: (_, __) =>
                    _handleEnd(ref, keepSelection: true),

                child: _buildCard(
                  showThickBorder: showThickBorder,
                  isResizingDisabled: isDragging || !canManageBookings,
                  isSelected: isSelected,
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  @override
  void dispose() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _hoverNotifier.exit();
    });
    super.dispose();
  }

  void _handleEnd(WidgetRef ref, {bool keepSelection = false}) {
    ref.read(dragSessionProvider.notifier).clear();
    _currentDragSessionId = null;
    ref.read(draggedAppointmentIdProvider.notifier).clear();
    ref.read(dragOffsetProvider.notifier).clear();
    ref.read(dragOffsetXProvider.notifier).clear();
    ref.read(dragPositionProvider.notifier).clear();
    ref.read(tempDragTimeProvider.notifier).clear();
    if (keepSelection) {
      _selectAppointment(ref);
    } else {
      ref.read(selectedAppointmentProvider.notifier).clear();
    }
    ref.read(draggedBaseRangeProvider.notifier).clear();
    ref.read(draggedLastStaffIdProvider.notifier).clear();
  }

  void _selectAppointment(WidgetRef ref, {bool fromHover = false}) {
    _selectedFromHover = fromHover;
    final sel = ref.read(selectedAppointmentProvider.notifier);
    sel.toggleByAppointment(widget.appointment);
  }

  void _handleDragEnd(WidgetRef ref, DraggableDetails details) {
    final canManageBookings = ref.read(currentUserCanManageBookingsProvider);
    if (!canManageBookings) {
      _handleEnd(ref, keepSelection: false);
      return;
    }

    if (details.wasAccepted) {
      _handleEnd(ref, keepSelection: true);
      return;
    }

    final session = ref.read(dragSessionProvider);
    final handledByTarget =
        session.dropHandled &&
        session.id != null &&
        session.id == _currentDragSessionId;
    if (handledByTarget) {
      _handleEnd(ref, keepSelection: true);
      return;
    }

    final bodyBox = ref.read(dragBodyBoxProvider);
    final columns = ref.read(staffColumnsGeometryProvider);
    if (bodyBox == null || columns.isEmpty) {
      _handleEnd(ref, keepSelection: true);
      return;
    }

    final dragPosLocal = ref.read(dragPositionProvider);
    final lastStaffId = ref.read(draggedLastStaffIdProvider);
    final offY = ref.read(dragOffsetProvider) ?? 0;
    final offX = ref.read(dragOffsetXProvider) ?? 0;
    final pointerGlobal = details.offset + Offset(offX, offY);
    final pointerLocal = bodyBox.globalToLocal(pointerGlobal);
    final releaseOffset = dragPosLocal ?? pointerLocal;
    final bodyOffset = pointerLocal;
    const tolerance = 4.0;

    int? targetStaffId;
    Rect? targetRect;
    for (final entry in columns.entries) {
      final rect = entry.value.inflate(tolerance);
      if (releaseOffset.dx >= rect.left && releaseOffset.dx <= rect.right) {
        targetStaffId = entry.key;
        targetRect = rect;
        break;
      }
    }

    if (targetStaffId == null || targetRect == null) {
      for (final entry in columns.entries) {
        final rect = entry.value.inflate(tolerance);
        if (bodyOffset.dx >= rect.left && bodyOffset.dx <= rect.right) {
          targetStaffId = entry.key;
          targetRect = rect;
          break;
        }
      }
    }

    final int dropStaffId =
        targetStaffId ?? lastStaffId ?? widget.appointment.staffId;
    targetRect ??= columns[dropStaffId];

    if (targetRect == null) {
      _handleEnd(ref, keepSelection: true);
      return;
    }

    double localY = releaseOffset.dy - targetRect.top;
    final slotHeight = _layoutConfig.slotHeight;
    final minutesPerSlot = _layoutConfig.minutesPerSlot;
    final totalMinutes = LayoutConfig.hoursInDay * 60;

    final baseDate = DateTime(
      widget.appointment.startTime.year,
      widget.appointment.startTime.month,
      widget.appointment.startTime.day,
    );

    final durationMinutes = widget.appointment.endTime
        .difference(widget.appointment.startTime)
        .inMinutes;

    final rawMaxStart = totalMinutes - durationMinutes;
    final maxStartMinutes = rawMaxStart < 0 ? 0 : rawMaxStart;

    double minutesFromTop = (localY / slotHeight) * minutesPerSlot;
    int roundedMinutes = ((minutesFromTop / 5).round() * 5).toInt();
    if (roundedMinutes < 0) {
      roundedMinutes = 0;
    } else if (roundedMinutes > maxStartMinutes) {
      roundedMinutes = maxStartMinutes;
    }

    final newStart = baseDate.add(Duration(minutes: roundedMinutes));
    var newEnd = newStart.add(Duration(minutes: durationMinutes));
    final dayBoundary = baseDate.add(const Duration(days: 1));
    if (newEnd.isAfter(dayBoundary)) newEnd = dayBoundary;

    ref
        .read(appointmentsProvider.notifier)
        .moveAppointment(
          appointmentId: widget.appointment.id,
          newStaffId: dropStaffId,
          newStart: newStart,
          newEnd: newEnd,
        );

    _handleEnd(ref, keepSelection: true);
  }

  void _evaluateDragBlock(RenderBox cardBox, Offset globalPosition) {
    final selection = ref.read(selectedAppointmentProvider);
    if (!selection.contains(widget.appointment.id)) {
      _updateDragBlock(false);
      return;
    }

    final localPos = cardBox.globalToLocal(globalPosition);
    final cardHeight = cardBox.size.height;
    final distanceFromBottom = cardHeight - localPos.dy;

    final minHeightForBlocking =
        _layoutConfig.slotHeight * _minSlotsForDragBlock;

    final shouldBlock =
        distanceFromBottom >= 0 &&
        distanceFromBottom <= _dragBlockZoneHeight &&
        cardHeight >= minHeightForBlocking;

    _updateDragBlock(shouldBlock);
  }

  void _updateDragBlock(bool value) {
    if (_blockDragDuringResize == value) return;
    if (!mounted) {
      _blockDragDuringResize = value;
      return;
    }
    setState(() => _blockDragDuringResize = value);
  }

  // üîπ Logica per il tap su DESKTOP/TABLET
  void _handleDesktopTap() async {
    final resizingNow = ref.read(isResizingProvider);
    if (resizingNow) return;

    _selectAppointment(ref);

    ref.read(dragOffsetProvider.notifier).clear();
    ref.read(dragOffsetXProvider.notifier).clear();
    ref.read(dragPositionProvider.notifier).clear();
    ref.read(highlightedStaffIdProvider.notifier).clear();

    // Legge l'appuntamento aggiornato dal provider (potrebbe essere stato
    // modificato tramite resize o drag)
    final currentAppointment = ref
        .read(appointmentsProvider)
        .requireValue
        .firstWhere((a) => a.id == widget.appointment.id);

    // Apre direttamente la vista di modifica dell'appuntamento
    await showAppointmentDialog(context, ref, initial: currentAppointment);

    if (!mounted) return;
    ref.read(selectedAppointmentProvider.notifier).clear();
  }

  // üîπ Logica per il tap su MOBILE (apre il dialogo di modifica come prima)
  void _handleMobileTap() async {
    final resizingNow = ref.read(isResizingProvider);
    if (resizingNow) return;

    _selectAppointment(ref);

    // Legge l'appuntamento aggiornato dal provider (potrebbe essere stato
    // modificato tramite resize o drag)
    final currentAppointment = ref
        .read(appointmentsProvider)
        .requireValue
        .firstWhere((a) => a.id == widget.appointment.id);

    // Apre direttamente la vista di modifica dell'appuntamento
    await showAppointmentDialog(context, ref, initial: currentAppointment);

    if (!mounted) return;
    ref.read(selectedAppointmentProvider.notifier).clear();
  }

  Widget _buildCard({
    bool isGhost = false,
    bool forFeedback = false,
    bool showThickBorder = false,
    bool isResizingDisabled = false,
    required bool isSelected,
    DateTime? overrideStart,
    DateTime? overrideEnd,
  }) {
    final resizingEntry = ref.watch(
      resizingEntryProvider(widget.appointment.id),
    );
    final booking = ref.watch(bookingsProvider)[widget.appointment.bookingId];
    final bookingNotes = booking?.notes?.trim();
    final clientNotes = widget.appointment.clientId != null
        ? ref
              .watch(clientsByIdProvider)[widget.appointment.clientId!]
              ?.notes
              ?.trim()
        : null;
    final hasBookingNotes = bookingNotes != null && bookingNotes.isNotEmpty;
    final hasClientNotes = clientNotes != null && clientNotes.isNotEmpty;
    final hasNotes = hasBookingNotes || hasClientNotes;

    final baseColor = widget.color.withOpacity(0.55);
    const r = BorderRadius.all(Radius.circular(6));

    final startTime = overrideStart ?? widget.appointment.startTime;
    final endTime =
        resizingEntry?.provisionalEndTime ??
        overrideEnd ??
        widget.appointment.endTime;

    final start = _formatTime(startTime);
    final formattedEndTime = _formatTime(endTime);
    final client = widget.appointment.clientName;

    final pieces = <String>[];
    if (widget.appointment.serviceName.isNotEmpty) {
      pieces.add(widget.appointment.serviceName);
    }
    final info = pieces.join(' ‚Äì ');
    final borderWidth = showThickBorder ? 2.5 : 1.0;
    final statusVisual = _statusVisual(context);
    final cardHeight = _lastSize?.height ?? 0;
    final showCompactStatusBar =
        statusVisual != null &&
        !forFeedback &&
        cardHeight > 0 &&
        cardHeight < 34;
    final showStatusIcon = statusVisual != null && !forFeedback;

    final animationDuration = _isDraggingResize || forFeedback
        ? Duration.zero
        : const Duration(milliseconds: 80);
    final animationCurve = _isDraggingResize || forFeedback
        ? Curves.linear
        : Curves.easeOutQuad;

    return Opacity(
      opacity: isGhost ? AgendaTheme.ghostOpacity : 1,
      child: Material(
        borderRadius: r,
        color: Colors.transparent,
        child: AnimatedContainer(
          duration: animationDuration,
          curve: animationCurve,
          decoration: BoxDecoration(
            color: Color.alphaBlend(baseColor, Colors.white),
            borderRadius: r,
            border: Border.all(color: widget.color, width: borderWidth),
            boxShadow: [
              BoxShadow(
                color: widget.color.withOpacity(showThickBorder ? 0.25 : 0.1),
                blurRadius: showThickBorder ? 8 : 4,
                offset: showThickBorder
                    ? const Offset(2, 3)
                    : const Offset(1, 1),
              ),
            ],
          ),
          child: Stack(
            children: [
              if (showCompactStatusBar)
                Positioned(
                  left: 0,
                  top: 0,
                  bottom: 0,
                  child: Container(
                    width: 3,
                    decoration: BoxDecoration(
                      color: statusVisual.borderColor.withOpacity(0.9),
                      borderRadius: const BorderRadius.horizontal(
                        left: Radius.circular(6),
                      ),
                    ),
                  ),
                ),
              _ExtraMinutesBand(
                ratio: _extraMinutesRatio(startTime, endTime),
                color: widget.color,
              ),

              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 4),
                child: Align(
                  alignment: Alignment.topLeft,
                  child: _buildContent(
                    start,
                    formattedEndTime,
                    client,
                    info,
                    showNotes: hasNotes && !forFeedback,
                    bookingSource: forFeedback
                        ? ''
                        : (widget.appointment.bookingSource ?? ''),
                    statusVisual: statusVisual,
                    showStatusIcon: showStatusIcon && !showCompactStatusBar,
                    isRecurring: widget.appointment.isRecurring,
                    recurrenceIndex: widget.appointment.recurrenceIndex,
                    recurrenceTotal: widget.appointment.recurrenceTotal,
                    onNotesTap: hasNotes && !forFeedback
                        ? () => _showNotesDialog(
                            bookingNotes: hasBookingNotes ? bookingNotes : null,
                            clientNotes: hasClientNotes ? clientNotes : null,
                          )
                        : null,
                  ),
                ),
              ),
              if (!forFeedback && !isResizingDisabled && isSelected)
                _buildResizeHandle(),
            ],
          ),
        ),
      ),
    );
  }

  String _formatTime(DateTime time) {
    final dayStart = DateTime(
      widget.appointment.startTime.year,
      widget.appointment.startTime.month,
      widget.appointment.startTime.day,
    );

    final dayBoundary = dayStart.add(const Duration(days: 1));
    if (time.isAtSameMomentAs(dayBoundary)) return '24:00';

    final hours = time.hour.toString().padLeft(2, '0');
    final minutes = time.minute.toString().padLeft(2, '0');
    return '$hours:$minutes';
  }

  // Menu contestuale disabilitato su desktop: rimosso

  Widget _buildContent(
    String start,
    String end,
    String client,
    String info, {
    required bool showNotes,
    required String bookingSource,
    required _CardStatusVisual? statusVisual,
    required bool showStatusIcon,
    bool isRecurring = false,
    int? recurrenceIndex,
    int? recurrenceTotal,
    VoidCallback? onNotesTap,
  }) {
    final formFactor = ref.watch(formFactorProvider);
    final effectiveColumnWidth = widget.columnWidth ?? _lastSize?.width;
    final screenWidth = MediaQuery.of(context).size.width;
    final approxVisibleColumns =
        (effectiveColumnWidth != null &&
            effectiveColumnWidth > 0 &&
            screenWidth > 0)
        ? (screenWidth / effectiveColumnWidth).round()
        : 0;
    // Only on smartphone (AppFormFactor.mobile) and only when the agenda is
    // effectively shown with 3 columns (narrow cards).
    final stackClientUnderTime =
        formFactor == AppFormFactor.mobile && approxVisibleColumns >= 3;

    final trailingIcons = <Widget>[];
    final effectiveCardHeight = _lastSize?.height ?? 0;
    final isCompactIconsLayout =
        (effectiveColumnWidth != null && effectiveColumnWidth < 120) ||
        (effectiveCardHeight > 0 && effectiveCardHeight < 52);
    final maxIcons = isCompactIconsLayout ? 2 : 4;

    // Priorit√†: stato > note > online > ricorrenza
    if (showStatusIcon && statusVisual != null) {
      trailingIcons.add(
        Padding(
          padding: const EdgeInsets.only(left: 4),
          child: Tooltip(
            message: statusVisual.label,
            child: Container(
              width: 12,
              height: 12,
              decoration: BoxDecoration(
                gradient: RadialGradient(
                  center: const Alignment(-0.25, -0.25),
                  radius: 0.95,
                  colors: [
                    statusVisual.fillHighlightColor,
                    statusVisual.fillColor,
                  ],
                ),
                shape: BoxShape.circle,
                border: Border.all(color: statusVisual.borderColor, width: 1.4),
              ),
            ),
          ),
        ),
      );
    }

    if (showNotes) {
      trailingIcons.add(
        Padding(
          padding: const EdgeInsets.only(left: 4),
          child: Tooltip(
            message: context.l10n.appointmentNotesTitle,
            child: InkWell(
              onTap: onNotesTap,
              borderRadius: BorderRadius.circular(6),
              child: const Padding(
                padding: EdgeInsets.all(2),
                child: Icon(
                  Icons.sticky_note_2_outlined,
                  size: 14,
                  color: Colors.black54,
                ),
              ),
            ),
          ),
        ),
      );
    }

    final showSourceIcon =
        bookingSource == 'online' || bookingSource == 'onlinestaff';
    if (showSourceIcon) {
      final isOnlineStaff = bookingSource == 'onlinestaff';
      trailingIcons.add(
        Padding(
          padding: const EdgeInsets.only(left: 4),
          child: Icon(
            Icons.cloud_outlined,
            size: 14,
            color: isOnlineStaff ? Colors.red : Colors.black54,
          ),
        ),
      );
    }

    if (isRecurring) {
      final tooltipText = recurrenceIndex != null && recurrenceTotal != null
          ? context.l10n.recurrenceSeriesOf(recurrenceIndex, recurrenceTotal)
          : context.l10n.recurrenceSeriesIcon;
      trailingIcons.add(
        Padding(
          padding: const EdgeInsets.only(left: 4),
          child: Tooltip(
            message: tooltipText,
            child: const Icon(Icons.repeat, size: 14, color: Colors.black54),
          ),
        ),
      );
    }

    final visibleTrailingIcons = trailingIcons.take(maxIcons).toList();
    return ClipRect(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          Flexible(
            child: Row(
              children: [
                Expanded(
                  child: stackClientUnderTime
                      ? Text(
                          '$start - $end',
                          maxLines: 1,
                          softWrap: false,
                          overflow: TextOverflow.ellipsis,
                          style: const TextStyle(
                            color: Colors.black87,
                            fontWeight: FontWeight.w700,
                          ),
                        )
                      : RichText(
                          maxLines: 1,
                          softWrap: false,
                          overflow: TextOverflow.ellipsis,
                          text: TextSpan(
                            children: [
                              TextSpan(
                                text: '$start - $end  ',
                                style: const TextStyle(
                                  color: Colors.black87,
                                  fontWeight: FontWeight.w700,
                                ),
                              ),
                              TextSpan(
                                text: client,
                                style: const TextStyle(
                                  color: Colors.grey,
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                            ],
                          ),
                        ),
                ),
                if (visibleTrailingIcons.isNotEmpty) ...visibleTrailingIcons,
              ],
            ),
          ),
          if (stackClientUnderTime && client.isNotEmpty)
            Flexible(
              child: Text(
                client,
                maxLines: 1,
                softWrap: false,
                overflow: TextOverflow.ellipsis,
                style: const TextStyle(
                  color: Colors.grey,
                  fontWeight: FontWeight.w600,
                  height: 1.1,
                ),
              ),
            ),
          if (info.isNotEmpty)
            Flexible(
              child: Text(
                info,
                maxLines: 1,
                softWrap: false,
                overflow: TextOverflow.ellipsis,
                style: const TextStyle(
                  fontSize: 11,
                  color: Colors.black54,
                  height: 1.1,
                ),
              ),
            ),
        ],
      ),
    );
  }

  void _showNotesDialog({String? bookingNotes, String? clientNotes}) {
    if ((bookingNotes == null || bookingNotes.trim().isEmpty) &&
        (clientNotes == null || clientNotes.trim().isEmpty)) {
      return;
    }
    final l10n = context.l10n;
    final sections = <Widget>[];
    if (clientNotes != null && clientNotes.trim().isNotEmpty) {
      sections.add(
        Text(
          l10n.clientNoteLabel,
          style: Theme.of(context).textTheme.titleSmall,
        ),
      );
      sections.add(const SizedBox(height: 4));
      sections.add(Text(clientNotes.trim()));
    }
    if (bookingNotes != null && bookingNotes.trim().isNotEmpty) {
      if (sections.isNotEmpty) {
        sections.add(const SizedBox(height: 12));
      }
      sections.add(
        Text(
          l10n.appointmentNoteLabel,
          style: Theme.of(context).textTheme.titleSmall,
        ),
      );
      sections.add(const SizedBox(height: 4));
      sections.add(Text(bookingNotes.trim()));
    }
    showAppInfoDialog(
      context,
      title: Text(l10n.appointmentNotesTitle),
      content: ConstrainedBox(
        constraints: const BoxConstraints(maxWidth: 360),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: sections,
        ),
      ),
      closeLabel: l10n.actionClose,
    );
  }

  double _extraMinutesRatio(DateTime start, DateTime end) {
    final totalMinutes = end.difference(start).inMinutes;
    if (totalMinutes <= 0) return 0;
    final extra = _extraMinutesForAppointment();
    if (extra <= 0) return 0;
    final ratio = extra / totalMinutes;
    if (ratio < 0) return 0;
    if (ratio > 1) return 1;
    return ratio;
  }

  int _extraMinutesForAppointment() {
    return widget.appointment.blockedExtraMinutes;
  }

  void _performResizeUpdate(PointerEvent details) {
    if (_lastPointerGlobalPosition == null) return;
    final currentGlobal = details.position;
    final deltaY = currentGlobal.dy - _lastPointerGlobalPosition!.dy;
    _lastPointerGlobalPosition = currentGlobal;

    final minutesPerPixel =
        _layoutConfig.minutesPerSlot / _layoutConfig.slotHeight;
    final pixelsPerMinute = 1 / minutesPerPixel;
    final dayEnd = DateTime(
      widget.appointment.startTime.year,
      widget.appointment.startTime.month,
      widget.appointment.startTime.day,
    ).add(const Duration(days: 1));

    ref
        .read(resizingProvider.notifier)
        .updateDuringResize(
          appointmentId: widget.appointment.id,
          deltaDy: deltaY,
          pixelsPerMinute: pixelsPerMinute,
          dayEnd: dayEnd,
          minDurationMinutes: 5,
          snapMinutes: 5,
        );
  }

  void _performResizeEnd() async {
    final newEnd = ref
        .read(resizingProvider.notifier)
        .commitResizeAndEnd(appointmentId: widget.appointment.id);

    if (newEnd != null) {
      final appt = widget.appointment;
      final minEnd = appt.startTime.add(const Duration(minutes: 5));
      ref
          .read(appointmentsProvider.notifier)
          .moveAppointment(
            appointmentId: appt.id,
            newStaffId: appt.staffId,
            newStart: appt.startTime,
            newEnd: newEnd.isAfter(minEnd) ? newEnd : minEnd,
          );
    }

    await Future.delayed(const Duration(milliseconds: 100));
    if (mounted) setState(() => _isDraggingResize = false);
    _lastPointerGlobalPosition = null;
    _updateDragBlock(false);
    ref.read(isResizingProvider.notifier).stop();
    ref.invalidate(resizingProvider);
    if (ref.read(dragPositionProvider) != null) {
      ref.read(dragPositionProvider.notifier).clear();
    }
  }

  void _performResizeCancel() {
    ref
        .read(resizingProvider.notifier)
        .cancelResize(appointmentId: widget.appointment.id);
    ref.read(isResizingProvider.notifier).stop();

    if (mounted) {
      setState(() => _isDraggingResize = false);
    }
    _updateDragBlock(false);
    if (ref.read(dragPositionProvider) != null) {
      ref.read(dragPositionProvider.notifier).clear();
    }
  }

  // üîπ Resize identico all‚Äôoriginale
  Widget _buildResizeHandle() {
    return Align(
      alignment: Alignment.bottomCenter,
      child: MouseRegion(
        cursor: SystemMouseCursors.resizeUpDown,
        child: GestureDetector(
          behavior: HitTestBehavior.opaque,
          onVerticalDragStart: (details) {
            final renderBox = context.findRenderObject() as RenderBox?;
            final currentHeightPx = renderBox?.size.height ?? 0;
            _lastPointerGlobalPosition = details.globalPosition;
            _updateDragBlock(true);

            ref
                .read(resizingProvider.notifier)
                .startResize(
                  appointmentId: widget.appointment.id,
                  currentHeightPx: currentHeightPx,
                  startTime: widget.appointment.startTime,
                  endTime: widget.appointment.endTime,
                );
            ref.read(isResizingProvider.notifier).start();
            setState(() => _isDraggingResize = true);
          },
          onVerticalDragUpdate: (details) {
            // Gestito da onPointerMove
          },
          onVerticalDragEnd: (_) {
            // Gestito da onPointerUp
          },
          onVerticalDragCancel: () {
            // Gestito da onPointerCancel
          },
          child: Container(
            height: 20,
            width: double.infinity,
            alignment: Alignment.bottomCenter,
            child: const Padding(
              padding: EdgeInsets.only(bottom: 1),
              child: Icon(Icons.drag_indicator, size: 14, color: Colors.grey),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildFollowerFeedback(
    BuildContext context,
    WidgetRef ref,
    bool isSelected,
  ) {
    final layoutConfig = ref.watch(layoutConfigProvider);
    final times = ref.watch(tempDragTimeProvider);
    final start = times?.$1;
    final end = times?.$2;

    final dragPos = ref.watch(dragPositionProvider);
    final offY = ref.watch(dragOffsetProvider) ?? 0;
    final offX = ref.watch(dragOffsetXProvider) ?? 0;
    final link = ref.watch(dragLayerLinkProvider);

    final highlightedId = ref.watch(highlightedStaffIdProvider);
    final columnsRects = ref.watch(staffColumnsGeometryProvider);

    final padding = LayoutConfig.columnInnerPadding;
    final fallbackWidth = widget.columnWidth ?? _lastSize?.width ?? 180.0;
    double effectiveWidth = widget.dragTargetWidth ?? fallbackWidth;
    if (effectiveWidth <= 0) {
      effectiveWidth = fallbackWidth > 0 ? fallbackWidth : 180.0;
    }
    final h = _lastSize?.height ?? 50.0;

    if (dragPos == null) return const SizedBox.shrink();

    final bodyBox = ref.read(dragBodyBoxProvider);
    final totalHeight = bodyBox?.size.height ?? layoutConfig.totalHeight;
    final cardHeight = h;

    final double unconstrainedTop = dragPos.dy - offY;
    double top = unconstrainedTop;
    double translateY = 0;

    double maxTop = totalHeight - cardHeight;
    if (maxTop < 0) maxTop = 0;

    if (unconstrainedTop < 0) {
      translateY = 0;
      top = 0;
    } else if (unconstrainedTop > maxTop) {
      translateY = 0;
      top = maxTop;
    }

    double left;
    final rect = highlightedId != null ? columnsRects[highlightedId] : null;

    // Limitiamo sempre la X minima all'inizio del body (0 + padding),
    // cos√¨ il feedback non entra mai nell'area della colonna oraria.
    final double globalMinLeft = padding;
    double minLeft = rect != null ? rect.left + padding : padding;
    if (minLeft < globalMinLeft) minLeft = globalMinLeft;

    if (rect != null) {
      left = rect.left + padding;
      final availableWidth = rect.width - padding * 2;
      if (availableWidth > 0 && availableWidth < effectiveWidth) {
        effectiveWidth = availableWidth;
      } else if (availableWidth > 0 && widget.dragTargetWidth == null) {
        effectiveWidth = availableWidth;
      }
      if (left < minLeft) left = minLeft;
    } else {
      left = dragPos.dx - offX - padding;
      if (widget.expandToLeft) left -= (effectiveWidth / 2);
      if (left < minLeft) left = minLeft;
    }

    final dpr = MediaQuery.of(context).devicePixelRatio;
    left = (left * dpr).round() / dpr;
    top = (top * dpr).round() / dpr;
    translateY = (translateY * dpr).round() / dpr;

    // üîπ Se non abbiamo ancora il bodyBox, evitiamo di disegnare il feedback
    if (bodyBox == null) {
      return const SizedBox.shrink();
    }

    // üîπ Clip minimo solo verticalmente, manteniamo la larghezza della card.
    return RepaintBoundary(
      child: CompositedTransformFollower(
        link: link,
        showWhenUnlinked: false,
        offset: Offset(left, top),
        child: SizedBox(
          width: effectiveWidth,
          height: h,
          child: ClipRect(
            child: Transform.translate(
              offset: Offset(0, translateY),
              child: Material(
                color: Colors.transparent,
                borderRadius: const BorderRadius.all(Radius.circular(6)),
                clipBehavior: Clip.antiAlias,
                child: _buildCard(
                  forFeedback: true,
                  showThickBorder: true,
                  overrideStart: start,
                  overrideEnd: end,
                  isSelected: isSelected,
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
} // Closing brace for _AppointmentCardInteractiveState

class _ExtraMinutesBand extends StatelessWidget {
  const _ExtraMinutesBand({required this.ratio, required this.color});

  final double ratio;
  final Color color;

  @override
  Widget build(BuildContext context) {
    if (ratio <= 0) return const SizedBox.shrink();
    return Positioned.fill(
      child: Align(
        alignment: Alignment.bottomCenter,
        child: FractionallySizedBox(
          heightFactor: ratio,
          widthFactor: 1,
          child: Container(
            decoration: BoxDecoration(
              color: color.withOpacity(0.18),
              borderRadius: const BorderRadius.vertical(
                bottom: Radius.circular(6),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class _CardStatusVisual {
  const _CardStatusVisual({
    required this.borderColor,
    required this.fillColor,
    required this.fillHighlightColor,
    required this.label,
  });

  final Color borderColor;
  final Color fillColor;
  final Color fillHighlightColor;
  final String label;
}
--- FILE: lib/features/agenda/presentation/screens/widgets/appointment_card_base.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/models/appointment.dart';
import 'appointment_card_interactive.dart';

/// Wrapper unico che istanzia la versione interattiva
/// per entrambi i form factor (desktop e mobile).
class AppointmentCard extends ConsumerWidget {
  final Appointment appointment;
  final Color color;
  final double? columnWidth;
  final double? columnOffset;
  final double? dragTargetWidth;
  final bool expandToLeft;

  const AppointmentCard({
    super.key,
    required this.appointment,
    required this.color,
    this.columnWidth,
    this.columnOffset,
    this.dragTargetWidth,
    this.expandToLeft = false,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return AppointmentCardInteractive(
      appointment: appointment,
      color: color,
      columnWidth: columnWidth,
      columnOffset: columnOffset,
      dragTargetWidth: dragTargetWidth,
      expandToLeft: expandToLeft,
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/unavailable_slot_pattern.dart ---
import 'package:flutter/material.dart';

import '../../../domain/config/layout_config.dart';

/// Painter leggero che disegna linee diagonali.
/// Usa `isComplex: true` e `willChange: false` per caching automatico.
class _DiagonalPatternPainter extends CustomPainter {
  final Color lineColor;
  final double lineWidth;
  final double spacing;

  const _DiagonalPatternPainter({
    required this.lineColor,
    required this.lineWidth,
    required this.spacing,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = lineColor
      ..strokeWidth = lineWidth
      ..style = PaintingStyle.stroke;

    // Disegna linee diagonali da sinistra-alto a destra-basso
    final double step = spacing;
    final double maxOffset = size.width + size.height;

    for (double offset = -size.height; offset < maxOffset; offset += step) {
      canvas.drawLine(
        Offset(offset, 0),
        Offset(offset + size.height, size.height),
        paint,
      );
    }
  }

  @override
  bool shouldRepaint(covariant _DiagonalPatternPainter oldDelegate) {
    return oldDelegate.lineColor != lineColor ||
        oldDelegate.lineWidth != lineWidth ||
        oldDelegate.spacing != spacing;
  }
}

/// Widget leggero che mostra un pattern a righe diagonali per indicare
/// uno slot non disponibile nell'agenda.
///
/// Ottimizzato per performance:
/// - Nessun state, nessun async
/// - CustomPaint con caching automatico (isComplex + willChange)
/// - RepaintBoundary per isolare i repaint
class UnavailableSlotPattern extends StatelessWidget {
  final double height;
  final Color? patternColor;
  final Color? backgroundColor;
  final double lineWidth;
  final double spacing;
  final BorderRadius? borderRadius;

  const UnavailableSlotPattern({
    super.key,
    required this.height,
    this.patternColor,
    this.backgroundColor,
    this.lineWidth = 1.5,
    this.spacing = 6.0,
    this.borderRadius,
  });

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final effectivePatternColor =
        patternColor ?? colorScheme.onSurface.withOpacity(0.25);
    final effectiveBackgroundColor =
        backgroundColor ?? colorScheme.surfaceContainerHighest.withOpacity(0.6);
    final effectiveBorderRadius = borderRadius ?? BorderRadius.circular(4);

    return DecoratedBox(
      decoration: BoxDecoration(
        color: effectiveBackgroundColor,
        borderRadius: effectiveBorderRadius,
      ),
      child: ClipRRect(
        borderRadius: effectiveBorderRadius,
        child: SizedBox(
          height: height,
          width: double.infinity,
          child: RepaintBoundary(
            child: CustomPaint(
              painter: _DiagonalPatternPainter(
                lineColor: effectivePatternColor,
                lineWidth: lineWidth,
                spacing: spacing,
              ),
              isComplex: true,
              willChange: false,
            ),
          ),
        ),
      ),
    );
  }
}

/// Variante con margini coerenti con le AppointmentCard.
class UnavailableSlotOverlay extends StatelessWidget {
  final double height;
  final double margin;
  final Color? patternColor;
  final Color? backgroundColor;

  const UnavailableSlotOverlay({
    super.key,
    required this.height,
    this.margin = LayoutConfig.columnInnerPadding,
    this.patternColor,
    this.backgroundColor,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: EdgeInsets.all(margin),
      child: UnavailableSlotPattern(
        height: height - (margin * 2),
        patternColor: patternColor,
        backgroundColor: backgroundColor,
      ),
    );
  }
}

/// Widget ottimizzato per coprire un range di slot consecutivi.
class UnavailableSlotRange extends StatelessWidget {
  final int slotCount;
  final double slotHeight;
  final double margin;
  final Color? patternColor;
  final Color? backgroundColor;

  const UnavailableSlotRange({
    super.key,
    required this.slotCount,
    required this.slotHeight,
    this.margin = LayoutConfig.columnInnerPadding,
    this.patternColor,
    this.backgroundColor,
  });

  @override
  Widget build(BuildContext context) {
    final totalHeight = slotCount * slotHeight;
    return Padding(
      padding: EdgeInsets.all(margin),
      child: UnavailableSlotPattern(
        height: totalHeight - (margin * 2),
        patternColor: patternColor,
        backgroundColor: backgroundColor,
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/current_time_line.dart ---
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/config/layout_config.dart';
import '../../../providers/date_range_provider.dart';
import '../../../providers/layout_config_provider.dart';

/// üîπ Linea rossa che indica l'orario corrente.
/// - visibile solo sulla data odierna
/// - sincronizzata minuto per minuto
/// - la posizione verticale effettiva viene corretta con [verticalOffset]
///   passato da AgendaScreen (offset di scroll della giornata).
class CurrentTimeLine extends ConsumerStatefulWidget {
  static const double horizontalMargin = 4.0;

  final double hourColumnWidth;
  final double verticalOffset;
  final double horizontalOffset;

  const CurrentTimeLine({
    super.key,
    required this.hourColumnWidth,
    required this.verticalOffset,
    this.horizontalOffset = 0,
  });

  @override
  ConsumerState<CurrentTimeLine> createState() => _CurrentTimeLineState();
}

class _CurrentTimeLineState extends ConsumerState<CurrentTimeLine> {
  Timer? _minuteTimer;
  double _offset = 0;
  String _label = '';
  late final ProviderSubscription<LayoutConfig> _layoutConfigSub;

  // üîπ Definiamo l'altezza della linea come costante
  static const double _lineHeight = 1.0;
  // üîπ Definiamo il margine/gap che conterr√† la linea
  static const double _lineMargin = CurrentTimeLine.horizontalMargin;

  @override
  void initState() {
    super.initState();

    // Ascolta i cambi di LayoutConfig (slotHeight / minutesPerSlot)
    _layoutConfigSub = ref.listenManual<LayoutConfig>(
      layoutConfigProvider,
      (prev, next) => _updateLine(configOverride: next),
      fireImmediately: true,
    );

    // Aggiornamento minuto per minuto
    _scheduleMinuteSync();
  }

  void _scheduleMinuteSync() {
    final now = DateTime.now();
    final msToNextMinute = 60000 - (now.second * 1000 + now.millisecond);
    _minuteTimer = Timer(Duration(milliseconds: msToNextMinute), () {
      _updateLine();
      _minuteTimer?.cancel();
      _minuteTimer = Timer.periodic(const Duration(minutes: 1), (_) {
        _updateLine();
      });
    });
  }

  void _updateLine({LayoutConfig? configOverride}) {
    final now = DateTime.now();
    final minutesSinceMidnight = now.hour * 60 + now.minute;
    final LayoutConfig config =
        configOverride ?? ref.read(layoutConfigProvider);

    final slotHeight = config.slotHeight;
    final offset = (minutesSinceMidnight / config.minutesPerSlot) * slotHeight;
    final label =
        "${now.hour.toString().padLeft(2, '0')}:${now.minute.toString().padLeft(2, '0')}";

    if (!mounted) return;
    setState(() {
      _offset = offset;
      _label = label;
    });
  }

  @override
  void dispose() {
    _minuteTimer?.cancel();
    _layoutConfigSub.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final selectedDate = ref.watch(agendaDateProvider);
    final today = DateUtils.dateOnly(DateTime.now());
    final isToday = DateUtils.isSameDay(selectedDate, today);
    if (!isToday) {
      return const SizedBox.shrink();
    }

    final layout = ref.read(layoutConfigProvider);

    // üîπ Calcoliamo la posizione Y del CENTRO della linea
    final lineCenterY = _offset - widget.verticalOffset + layout.headerHeight;
    // üîπ Calcoliamo il 'top' per il Positioned
    final lineTopY = lineCenterY - (_lineHeight / 2);

    return Positioned(
      top: lineTopY,
      left: widget.horizontalOffset,
      right: 0,
      child: Stack(
        clipBehavior: Clip.none,
        children: [
          // --- Linea rossa orizzontale (l'elemento di riferimento) ---
          Row(
            children: [
              // Spazio per la colonna oraria
              SizedBox(width: widget.hourColumnWidth - _lineMargin),
              // Linea dalla fine del box fino al bordo destro
              Container(
                width: _lineMargin,
                height: _lineHeight,
                color: Colors.redAccent,
              ),
              Expanded(
                child: Container(height: _lineHeight, color: Colors.redAccent),
              ),
            ],
          ),
          // --- Box dell'orario (centrato verticalmente sulla linea) ---
          Positioned(
            left: -_lineMargin - 1,
            width: widget.hourColumnWidth,
            top: 0,
            child: FractionalTranslation(
              // Sposta il box del 50% della sua altezza verso l'alto
              // cos√¨ il suo centro si allinea con la linea
              translation: const Offset(0, -0.5),
              child: Align(
                alignment: Alignment.center,
                child: Container(
                  width: double.infinity,
                  decoration: BoxDecoration(
                    color: Colors.redAccent,
                    borderRadius: BorderRadius.circular(4),
                  ),
                  padding: const EdgeInsets.symmetric(vertical: 5),
                  child: Text(
                    _label,
                    textAlign: TextAlign.center,
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 11,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/agenda_dividers.dart ---
import 'package:flutter/material.dart';

/// Divider verticale sottile tra la colonna oraria e le colonne staff
class AgendaVerticalDivider extends StatelessWidget {
  final double height;
  final Color color;
  final double thickness;

  /// Altezza della porzione superiore con sfumatura (es. headerHeight)
  final double? fadeTopHeight;

  const AgendaVerticalDivider({
    super.key,
    required this.height,
    this.color = const Color(0xFFBDBDBD),
    this.thickness = 0.5,
    this.fadeTopHeight,
  });

  @override
  Widget build(BuildContext context) {
    // Se fadeTopHeight √® specificato, usa una Column con gradiente in alto
    if (fadeTopHeight != null && fadeTopHeight! > 0) {
      return SizedBox(
        height: height,
        width: thickness,
        child: Column(
          children: [
            // Parte superiore con gradiente sfumato
            Container(
              height: fadeTopHeight,
              width: thickness,
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                  colors: [color.withOpacity(0.0), color],
                  stops: const [0.0, 0.7],
                ),
              ),
            ),
            // Parte inferiore con colore pieno
            Expanded(
              child: Container(width: thickness, color: color),
            ),
          ],
        ),
      );
    }

    // Comportamento originale senza sfumatura
    return SizedBox(
      height: height,
      width: thickness,
      child: DecoratedBox(decoration: BoxDecoration(color: color)),
    );
  }
}

/// Divider orizzontale usato per le righe orarie
class AgendaHorizontalDivider extends StatelessWidget {
  final double thickness;
  final Color color;

  const AgendaHorizontalDivider({
    super.key,
    this.thickness = 0.5,
    this.color = const Color(0xFFBDBDBD),
  });

  @override
  Widget build(BuildContext context) {
    return Divider(height: thickness, thickness: thickness, color: color);
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/hover_slot.dart ---
import 'package:agenda_backend/core/l10n/date_time_formats.dart';
import 'package:flutter/material.dart';

import '../../../domain/config/layout_config.dart';

/// Slot interattivo che reagisce all'hover del mouse.
/// Usa lo stesso margin, borderRadius e spessore del bordo delle AppointmentCard.
class HoverSlot extends StatefulWidget {
  final DateTime slotTime;
  final double height;
  final Color colorPrimary1;

  const HoverSlot({
    super.key,
    required this.slotTime,
    required this.height,
    required this.colorPrimary1,
  });

  @override
  State<HoverSlot> createState() => _HoverSlotState();
}

class _HoverSlotState extends State<HoverSlot> {
  bool _hovered = false;

  @override
  Widget build(BuildContext context) {
    final timeStr = DtFmt.hm(
      context,
      widget.slotTime.hour,
      widget.slotTime.minute,
    );

    final radius = BorderRadius.circular(4);
    final margin = EdgeInsets.all(LayoutConfig.columnInnerPadding);
    final borderWidth = LayoutConfig.borderWidth;

    return MouseRegion(
      onEnter: (_) => setState(() => _hovered = true),
      onExit: (_) => setState(() => _hovered = false),
      child: Container(
        margin: margin,
        height: widget.height - LayoutConfig.columnInnerPadding * 2,
        width: double.infinity,
        decoration: BoxDecoration(
          color: _hovered
              ? widget.colorPrimary1.withOpacity(0.06)
              : Colors.transparent,
          border: Border.all(
            color: _hovered
                ? widget.colorPrimary1.withOpacity(0.1)
                : Colors.transparent,
            width: _hovered ? borderWidth : 0,
          ),
          borderRadius: radius,
        ),
        child: _hovered
            ? Padding(
                padding: const EdgeInsets.all(2),
                child: Align(
                  alignment: Alignment.centerLeft,
                  child: Text(
                    timeStr,
                    style: TextStyle(
                      fontSize: 11,
                      fontWeight: FontWeight.w600,
                      color: widget.colorPrimary1,
                    ),
                  ),
                ),
              )
            : const SizedBox.expand(),
      ),
    );
  }
}

/// Wrapper that builds [HoverSlot] only when the pointer (mouse) or touch is
/// active on the slot. This avoids constructing the (slightly heavier)
/// hover contents for every slot when not needed.
class LazyHoverSlot extends StatefulWidget {
  final DateTime slotTime;
  final double height;
  final Color colorPrimary1;
  final void Function(DateTime)? onTap;

  const LazyHoverSlot({
    super.key,
    required this.slotTime,
    required this.height,
    required this.colorPrimary1,
    this.onTap,
  });

  @override
  State<LazyHoverSlot> createState() => _LazyHoverSlotState();
}

class _LazyHoverSlotState extends State<LazyHoverSlot> {
  bool _show = false;

  void _onEnter(PointerEvent _) {
    setState(() => _show = true);
  }

  void _onExit(PointerEvent _) {
    setState(() => _show = false);
  }

  void _onTapDown(TapDownDetails _) {
    // On touch devices show the hover content while pressing.
    setState(() => _show = true);
  }

  void _onTapUp(TapUpDetails _) {
    // Hide shortly after release to mimic hover disappearing.
    Future.delayed(const Duration(milliseconds: 250), () {
      if (mounted) setState(() => _show = false);
    });
  }

  void _onTapCancel() {
    setState(() => _show = false);
  }

  @override
  Widget build(BuildContext context) {
    // We keep the same size and margin as HoverSlot so layout doesn't jump.
    return MouseRegion(
      onEnter: _onEnter,
      onExit: _onExit,
      child: GestureDetector(
        behavior: HitTestBehavior.translucent,
        onTap: () => widget.onTap?.call(widget.slotTime),
        onTapDown: _onTapDown,
        onTapUp: _onTapUp,
        onTapCancel: _onTapCancel,
        child: SizedBox(
          height: widget.height,
          width: double.infinity,
          child: _show
              ? HoverSlot(
                  slotTime: widget.slotTime,
                  height: widget.height,
                  colorPrimary1: widget.colorPrimary1,
                )
              : Container(),
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/time_block_widget.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../core/l10n/l10_extension.dart';
import '../../../../../core/models/time_block.dart';
import '../../../domain/config/layout_config.dart';
import '../../dialogs/add_block_dialog.dart';

/// Widget per visualizzare un blocco di non disponibilit√† nell'agenda.
class TimeBlockWidget extends ConsumerWidget {
  final TimeBlock block;
  final double height;
  final double width;

  const TimeBlockWidget({
    super.key,
    required this.block,
    required this.height,
    required this.width,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final colorScheme = Theme.of(context).colorScheme;
    final blockColor = colorScheme.error.withOpacity(0.15);
    final borderColor = colorScheme.error.withOpacity(0.5);

    return GestureDetector(
      onTap: () {
        showAddBlockDialog(context, ref, initial: block);
      },
      child: Container(
        width: width,
        height: height,
        decoration: BoxDecoration(
          color: blockColor,
          borderRadius: BorderRadius.circular(LayoutConfig.borderRadius),
          border: Border.all(color: borderColor, width: 1.5),
        ),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(LayoutConfig.borderRadius - 1),
          child: Stack(
            children: [
              // Pattern diagonale
              CustomPaint(
                size: Size(width, height),
                painter: _DiagonalPatternPainter(
                  color: colorScheme.error.withOpacity(0.1),
                ),
              ),
              // Contenuto adattivo: evita overflow quando il blocco e' molto basso.
              LayoutBuilder(
                builder: (context, constraints) {
                  final maxHeight = constraints.maxHeight;
                  if (maxHeight < 18) {
                    return Align(
                      alignment: Alignment.centerLeft,
                      child: Padding(
                        padding: const EdgeInsets.symmetric(horizontal: 4),
                        child: Container(
                          width: 22,
                          height: 2,
                          decoration: BoxDecoration(
                            color: colorScheme.error.withOpacity(0.9),
                            borderRadius: BorderRadius.circular(2),
                          ),
                        ),
                      ),
                    );
                  }

                  final isCompact = maxHeight < 30;
                  final horizontalPadding = isCompact ? 6.0 : 8.0;
                  final verticalPadding = isCompact ? 2.0 : 4.0;

                  return Padding(
                    padding: EdgeInsets.symmetric(
                      horizontal: horizontalPadding,
                      vertical: verticalPadding,
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Row(
                          children: [
                            if (!isCompact) ...[
                              Icon(Icons.block, size: 14, color: colorScheme.error),
                              const SizedBox(width: 4),
                            ],
                            Expanded(
                              child: Text(
                                block.reason ?? 'Blocco',
                                style: TextStyle(
                                  fontSize: isCompact ? 10 : 12,
                                  fontWeight: FontWeight.w600,
                                  color: colorScheme.error,
                                ),
                                maxLines: 1,
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                          ],
                        ),
                        if (maxHeight > 40) ...[
                          const SizedBox(height: 2),
                          Text(
                            _formatTimeRange(context, block),
                            style: TextStyle(
                              fontSize: 10,
                              color: colorScheme.error.withOpacity(0.8),
                            ),
                          ),
                        ],
                      ],
                    ),
                  );
                },
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _formatTimeRange(BuildContext context, TimeBlock block) {
    if (block.isAllDay) {
      return context.l10n.blockAllDay;
    }
    final start =
        '${block.startTime.hour.toString().padLeft(2, '0')}:${block.startTime.minute.toString().padLeft(2, '0')}';
    final end =
        '${block.endTime.hour.toString().padLeft(2, '0')}:${block.endTime.minute.toString().padLeft(2, '0')}';
    return '$start - $end';
  }
}

/// Painter per il pattern diagonale del blocco.
class _DiagonalPatternPainter extends CustomPainter {
  final Color color;

  _DiagonalPatternPainter({required this.color});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 1.0
      ..style = PaintingStyle.stroke;

    const spacing = 8.0;
    final diagonal = size.width + size.height;

    for (double i = -size.height; i < diagonal; i += spacing) {
      canvas.drawLine(
        Offset(i, 0),
        Offset(i + size.height, size.height),
        paint,
      );
    }
  }

  @override
  bool shouldRepaint(covariant _DiagonalPatternPainter oldDelegate) {
    return oldDelegate.color != color;
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/staff_column.dart ---
import 'dart:async';
import 'dart:math' as math;

import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/core/l10n/date_time_formats.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/service_variant.dart';
import 'package:agenda_backend/core/widgets/app_dialogs.dart';
import 'package:agenda_backend/core/widgets/feedback_dialog.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/widgets/hover_slot.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/widgets/unavailable_slot_pattern.dart';
import 'package:agenda_backend/features/auth/providers/current_business_user_provider.dart';
import 'package:agenda_backend/features/agenda/providers/dragged_card_size_provider.dart';
import 'package:agenda_backend/features/agenda/providers/pending_drop_provider.dart';
import 'package:agenda_backend/features/agenda/providers/staff_slot_availability_provider.dart';
import 'package:agenda_backend/features/services/providers/services_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/models/appointment.dart';
import '/core/models/staff.dart';
import '/core/utils/color_utils.dart';
import '../../../domain/config/agenda_theme.dart';
import '../../../domain/config/layout_config.dart';
import '../../../providers/agenda_providers.dart';
import '../../../providers/agenda_scroll_request_provider.dart';
import '../../../providers/appointment_providers.dart';
import '../../../providers/booking_reschedule_provider.dart';
import '../../../providers/date_range_provider.dart';
import '../../../providers/drag_layer_link_provider.dart';
import '../../../providers/drag_offset_provider.dart';
import '../../../providers/drag_session_provider.dart';
import '../../../providers/dragged_appointment_provider.dart';
import '../../../providers/dragged_base_range_provider.dart';
import '../../../providers/dragged_last_staff_provider.dart';
import '../../../providers/fully_occupied_slots_provider.dart';
import '../../../providers/highlighted_staff_provider.dart';
// Nota: isResizingProvider viene gestito a un livello superiore (MultiStaffDayView),
// non √® necessario importarlo qui.
import '../../../providers/layout_config_provider.dart';
import '../../../providers/resizing_provider.dart';
import '../../../providers/selected_appointment_provider.dart';
import '../../../providers/staff_columns_geometry_provider.dart';
import '../../../providers/temp_drag_time_provider.dart';
import '../../../providers/time_blocks_provider.dart';
import '../../widgets/booking_dialog.dart';
import '../helper/drag_drop_helper.dart';
import '../helper/layout_geometry_helper.dart';
import '../widgets/agenda_dividers.dart';
import '../widgets/appointment_card_base.dart';
import '../widgets/time_block_widget.dart';

class StaffColumn extends ConsumerStatefulWidget {
  final Staff staff;
  final List<Appointment> appointments;
  final double columnWidth;
  final bool showRightBorder;
  final bool isInteractionLocked;

  const StaffColumn({
    super.key,
    required this.staff,
    required this.appointments,
    required this.columnWidth,
    required this.isInteractionLocked,
    this.showRightBorder = true,
  });

  @override
  ConsumerState<StaffColumn> createState() => _StaffColumnState();
}

class _StaffColumnState extends ConsumerState<StaffColumn> {
  bool _isHighlighted = false;
  double? _hoverY;
  bool _isApplyingBookingReschedule = false;
  late final ProviderSubscription<Offset?> _dragListener;
  late final HighlightedStaffIdNotifier _highlightedNotifier;
  late final StaffColumnsGeometryNotifier _geometryNotifier;
  late final ProviderSubscription<int?> _highlightSubscription;
  int? _latestHighlightedId;

  // 1. Aggiunta sottoscrizione per il layout
  late final ProviderSubscription<LayoutConfig> _layoutConfigSub;

  @override
  void initState() {
    super.initState();

    _highlightedNotifier = ref.read(highlightedStaffIdProvider.notifier);
    _geometryNotifier = ref.read(staffColumnsGeometryProvider.notifier);
    _latestHighlightedId = ref.read(highlightedStaffIdProvider);
    _highlightSubscription = ref.listenManual<int?>(
      highlightedStaffIdProvider,
      (previous, next) => _latestHighlightedId = next,
    );

    // 2. Pianifica l'aggiornamento della geometria dopo il primo frame
    _scheduleGeometryUpdate();

    // 3. Ascolta i cambi di layout per ri-pianificare l'aggiornamento
    _layoutConfigSub = ref.listenManual<LayoutConfig>(layoutConfigProvider, (
      prev,
      next,
    ) {
      // Aggiorna la geometria solo se le dimensioni cambiano
      if (prev == null ||
          prev.slotHeight != next.slotHeight ||
          prev.headerHeight != next.headerHeight) {
        _scheduleGeometryUpdate();
      }
    });

    _dragListener = ref.listenManual<Offset?>(dragPositionProvider, (
      previous,
      next,
    ) {
      if (!mounted) return;

      final tempTimeNotifier = ref.read(tempDragTimeProvider.notifier);

      if (next == null) {
        if (_isHighlighted || _hoverY != null) {
          setState(() {
            _isHighlighted = false;
            _hoverY = null;
          });
        }
        _highlightedNotifier.clear();
        tempTimeNotifier.clear();
        return;
      }

      final box = context.findRenderObject() as RenderBox?;
      final bodyBox = ref.read(dragBodyBoxProvider);
      if (box == null || bodyBox == null) return;

      final columnTopLeftInBody = bodyBox.globalToLocal(
        box.localToGlobal(Offset.zero),
      );

      // ‚úÖ Aggiorna la geometria solo se cambia realmente (scroll o resize)
      final newRect = Rect.fromLTWH(
        columnTopLeftInBody.dx,
        columnTopLeftInBody.dy,
        box.size.width,
        box.size.height,
      );

      if (_lastGeometryRect == null ||
          (newRect.top - _lastGeometryRect!.top).abs() > 0.5 ||
          (newRect.left - _lastGeometryRect!.left).abs() > 0.5 ||
          (newRect.width - _lastGeometryRect!.width).abs() > 0.5 ||
          (newRect.height - _lastGeometryRect!.height).abs() > 0.5) {
        _lastGeometryRect = newRect;
        _geometryNotifier.setRect(widget.staff.id, newRect);
      }

      final localInColumn = Offset(
        next.dx - columnTopLeftInBody.dx,
        next.dy - columnTopLeftInBody.dy,
      );

      final withinHorizontal =
          localInColumn.dx >= 0 && localInColumn.dx <= box.size.width;
      if (withinHorizontal) {
        final dragOffset = ref.read(dragOffsetProvider);
        final layoutConfig = ref.read(layoutConfigProvider);

        // üîπ Altezza effettiva della card trascinata (fallback 50px se non nota)
        final draggedCardHeightPx =
            ref.read(draggedCardSizeProvider)?.height ?? 50.0;

        // üîπ Punto massimo CONSENTITO per l'inizio della card in pixel
        final maxYStartPx = (box.size.height - draggedCardHeightPx)
            .clamp(0, box.size.height)
            .toDouble();

        // üîπ Y effettiva del "top" della card, clampata ai limiti verticali
        final clampedLocalDy = localInColumn.dy.clamp(
          0.0,
          box.size.height.toDouble(),
        );
        final double effectiveY = (clampedLocalDy - (dragOffset ?? 0))
            .clamp(0, maxYStartPx)
            .toDouble();

        setState(() {
          _hoverY = effectiveY;
          _isHighlighted = true;
        });
        _highlightedNotifier.set(widget.staff.id);
        ref.read(draggedLastStaffIdProvider.notifier).set(widget.staff.id);

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // ‚è± Calcolo orario proposto
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        final slotHeight = layoutConfig.slotHeight;

        // minuti dall'inizio giornata (00:00)
        final minutesFromTop =
            (effectiveY / slotHeight) * layoutConfig.minutesPerSlot;

        // arrotondiamo a step di 5 minuti
        double roundedMinutes = (minutesFromTop / 5).round() * 5;

        // durata dell'appuntamento trascinato
        final draggedId = ref.read(draggedAppointmentIdProvider);
        Duration duration;
        DateTime baseDate;
        if (draggedId != null) {
          final appt = ref
              .read(appointmentsProvider)
              .requireValue
              .firstWhere((a) => a.id == draggedId);
          duration = appt.endTime.difference(appt.startTime);
          baseDate = DateTime(
            appt.startTime.year,
            appt.startTime.month,
            appt.startTime.day,
          );
        } else {
          final baseRange = ref.read(draggedBaseRangeProvider);
          if (baseRange != null) {
            final start = baseRange.$1;
            final end = baseRange.$2;
            duration = end.difference(start);
            baseDate = DateTime(start.year, start.month, start.day);
          } else {
            duration = const Duration(minutes: 30);
            final now = DateTime.now();
            baseDate = DateTime(now.year, now.month, now.day);
          }
        }

        final durationMinutes = duration.inMinutes;

        // üîí Limiti nell'arco della giornata
        const totalMinutes = LayoutConfig.hoursInDay * 60; // 1440
        final maxStartMinutesNum = (totalMinutes - durationMinutes).clamp(
          0,
          totalMinutes,
        );

        if (roundedMinutes > maxStartMinutesNum) {
          roundedMinutes = maxStartMinutesNum.toDouble();
        } else if (roundedMinutes < 0) {
          roundedMinutes = 0;
        }

        final startMinutes = roundedMinutes.toInt();
        final endMinutes = (startMinutes + durationMinutes)
            .clamp(0, totalMinutes)
            .toInt();

        final start = baseDate.add(Duration(minutes: startMinutes));
        var end = baseDate.add(Duration(minutes: endMinutes));

        final dayBoundary = baseDate.add(const Duration(days: 1));
        if (end.isAfter(dayBoundary)) end = dayBoundary;

        // aggiorna l'anteprima oraria mostrata nella card fantasma
        tempTimeNotifier.setTimes(start, end);
      } else if (_isHighlighted) {
        final headerHeight = ref.read(layoutConfigProvider).headerHeight;
        final globalY = next.dy;
        if (globalY > headerHeight - 5) return;

        setState(() {
          _isHighlighted = false;
          _hoverY = null;
        });
        _highlightedNotifier.clear();
        tempTimeNotifier.clear();
      }
    }, fireImmediately: false);
  }

  bool _geometryInitialized = false;
  Timer? _geometryDebounce;
  Rect? _lastGeometryRect;

  void _scheduleGeometryUpdate() {
    // Se gi√† inizializzato e debounce attivo, salta
    if (_geometryInitialized && _geometryDebounce != null) return;

    _geometryDebounce?.cancel();
    _geometryDebounce = Timer(const Duration(milliseconds: 220), () {
      if (!mounted) return;
      final box = context.findRenderObject() as RenderBox?;
      final bodyBox = ref.read(dragBodyBoxProvider);
      if (box == null || bodyBox == null) return;
      if (!box.attached || !bodyBox.attached) return;

      final topLeft = bodyBox.globalToLocal(box.localToGlobal(Offset.zero));
      final newRect = Rect.fromLTWH(
        topLeft.dx,
        topLeft.dy,
        box.size.width,
        box.size.height,
      );

      // ignora microvariazioni
      if (_lastGeometryRect != null &&
          (newRect.top - _lastGeometryRect!.top).abs() < 1.0 &&
          (newRect.left - _lastGeometryRect!.left).abs() < 1.0 &&
          (newRect.width - _lastGeometryRect!.width).abs() < 1.0 &&
          (newRect.height - _lastGeometryRect!.height).abs() < 1.0) {
        return;
      }

      _lastGeometryRect = newRect;
      _geometryInitialized = true; // ‚úÖ segna come inizializzato
      _geometryNotifier.setRect(widget.staff.id, newRect);
    });
  }

  @override
  void dispose() {
    _dragListener.close();
    _highlightSubscription.close();
    _layoutConfigSub.close(); // 5. Ricorda di chiudere la sottoscrizione
    final shouldClearHighlight = _latestHighlightedId == widget.staff.id;
    final staffId = widget.staff.id;
    Future.microtask(() {
      if (shouldClearHighlight) {
        _highlightedNotifier.clear();
      }
      _geometryNotifier.clearFor(staffId);
    });
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final allAppointments = ref.watch(appointmentsForCurrentLocationProvider);
    final staffAppointments = allAppointments
        .where((a) => a.staffId == widget.staff.id)
        .toList();

    // 6. RIMOSSO il blocco addPostFrameCallback da qui

    final layoutConfig = ref.watch(layoutConfigProvider);
    final slotHeight = layoutConfig.slotHeight;
    final totalSlots = layoutConfig.totalSlots;
    final appointmentsNotifier = ref.read(appointmentsProvider.notifier);
    final agendaDate = ref.watch(agendaDateProvider);
    final canManageBookings = ref.watch(currentUserCanManageBookingsProvider);

    // Interaction lock propagated from parent (evaluated once per visible group)
    final isInteractionLocked = widget.isInteractionLocked;
    final rescheduleSession = ref.watch(bookingRescheduleSessionProvider);

    // üîπ Calcola slot pieni PRIMA del layout (solo desktop e se abilitato)
    final formFactor = ref.watch(formFactorProvider);
    final bool showAddButtonStrip =
        layoutConfig.enableOccupiedSlotStrip &&
        formFactor == AppFormFactor.desktop &&
        !isInteractionLocked &&
        canManageBookings;
    final fullyOccupied = showAddButtonStrip
        ? ref.watch(fullyOccupiedSlotsProvider(widget.staff.id))
        : const <int>{};
    final hasFullyOccupiedSlots = fullyOccupied.isNotEmpty;

    // Larghezza disponibile per le card (ridotta se ci sono slot pieni)
    final addButtonWidth = hasFullyOccupiedSlots
        ? LayoutConfig.addButtonStripWidth
        : 0.0;
    final effectiveColumnWidth = widget.columnWidth - addButtonWidth;

    final stackChildren = <Widget>[];

    // üîπ Griglia oraria
    stackChildren.add(
      Column(
        children: List.generate(totalSlots, (index) {
          final slotsPerHour = 60 ~/ layoutConfig.minutesPerSlot;
          final isHourStart = (index + 1) % slotsPerHour == 0;
          return SizedBox(
            height: slotHeight,
            child: Align(
              alignment: Alignment.bottomLeft,
              child: AgendaHorizontalDivider(
                color: Colors.grey.withOpacity(isHourStart ? 0.5 : 0.2),
                thickness: isHourStart ? 1 : 0.5,
              ),
            ),
          );
        }),
      ),
    );

    // üîπ Layer slot non disponibili (texture pattern)
    final unavailableRanges = ref.watch(
      unavailableSlotRangesProvider(widget.staff.id),
    );
    if (unavailableRanges.isNotEmpty) {
      final colorScheme = Theme.of(context).colorScheme;
      final totalHeight = totalSlots * slotHeight;
      stackChildren.add(
        IgnorePointer(
          child: SizedBox(
            height: totalHeight,
            width: double.infinity,
            child: Stack(
              children: [
                for (final range in unavailableRanges)
                  Positioned(
                    top: range.startIndex * slotHeight,
                    left: 0,
                    right: 0,
                    child: UnavailableSlotRange(
                      slotCount: range.count,
                      slotHeight: slotHeight,
                      patternColor: AgendaTheme.unavailablePatternColor(
                        colorScheme,
                      ),
                      backgroundColor: AgendaTheme.unavailableBackgroundColor(
                        colorScheme,
                      ),
                    ),
                  ),
              ],
            ),
          ),
        ),
      );
    }

    // üîπ Layer interattivo HoverSlot (effetto all'hover del mouse)
    stackChildren.add(
      IgnorePointer(
        ignoring: false, // permette l'hover
        child: Column(
          children: List.generate(totalSlots, (index) {
            final slotTime = agendaDate.add(
              Duration(minutes: index * layoutConfig.minutesPerSlot),
            );
            if (!isInteractionLocked && canManageBookings) {
              return LazyHoverSlot(
                slotTime: slotTime,
                height: slotHeight,
                colorPrimary1: Theme.of(context).colorScheme.primary,
                onTap: (dt) => _handleSlotTap(
                  dt: dt,
                  rescheduleSession: rescheduleSession,
                ),
              );
            }

            // Mantieni lo spazio vuoto per evitare salti nel layout.
            return SizedBox(height: slotHeight, width: double.infinity);
          }),
        ),
      ),
    );

    // üîπ Appuntamenti (con larghezza ridotta se ci sono slot pieni)
    stackChildren.addAll(
      _buildAppointments(slotHeight, staffAppointments, effectiveColumnWidth),
    );

    // üîπ Blocchi di non disponibilit√†
    stackChildren.addAll(_buildTimeBlocks(slotHeight));

    // La fascia laterale √® gi√† riservata riducendo effectiveColumnWidth,
    // quindi le card si restringono automaticamente lasciando spazio a destra.

    return DragTarget<Appointment>(
      onWillAcceptWithDetails: (_) {
        if (!canManageBookings) return false;
        setState(() => _isHighlighted = true);
        ref.read(highlightedStaffIdProvider.notifier).set(widget.staff.id);
        return true;
      },
      onLeave: (_) {
        setState(() => _isHighlighted = false);
        ref.read(highlightedStaffIdProvider.notifier).clear();
      },
      onAcceptWithDetails: (details) async {
        if (!canManageBookings) {
          return;
        }
        final previewTimes = ref.read(tempDragTimeProvider);
        setState(() {
          _isHighlighted = false;
          _hoverY = null;
        });
        ref.read(highlightedStaffIdProvider.notifier).clear();
        ref.read(tempDragTimeProvider.notifier).clear();

        final box = context.findRenderObject() as RenderBox?;
        if (box == null) return;

        final dragOffsetY = ref.read(dragOffsetProvider) ?? 0.0;
        final dragOffsetX = ref.read(dragOffsetXProvider) ?? 0.0;
        final pointerGlobal = details.offset + Offset(dragOffsetX, dragOffsetY);
        final localPointer = box.globalToLocal(pointerGlobal);
        final draggedCardHeightPx =
            ref.read(draggedCardSizeProvider)?.height ?? 50.0;

        final dropResult = computeDropResult(
          DropComputationParams(
            appointment: details.data,
            layoutConfig: layoutConfig,
            columnHeight: box.size.height,
            localPointer: localPointer,
            dragOffsetY: dragOffsetY,
            draggedCardHeightPx: draggedCardHeightPx,
            previewTimes: previewTimes,
          ),
        );

        ref.read(dragSessionProvider.notifier).markHandled();

        // Verifica se l'appuntamento √® stato effettivamente spostato
        final hasStaffChanged = details.data.staffId != widget.staff.id;
        final hasTimeChanged =
            details.data.startTime != dropResult.newStart ||
            details.data.endTime != dropResult.newEnd;

        // Se non c'√® stato alcun cambiamento, non mostrare il dialog
        if (!hasStaffChanged && !hasTimeChanged) {
          return;
        }

        // Salva i dati del drop pendente per mostrare la preview
        final pendingData = PendingDropData(
          appointmentId: details.data.id,
          originalStaffId: details.data.staffId,
          originalStart: details.data.startTime,
          originalEnd: details.data.endTime,
          newStaffId: widget.staff.id,
          newStart: dropResult.newStart,
          newEnd: dropResult.newEnd,
        );
        ref.read(pendingDropProvider.notifier).setPending(pendingData);

        // Mostra dialog di conferma prima di applicare lo spostamento
        if (!mounted) {
          ref.read(pendingDropProvider.notifier).clear();
          return;
        }
        final l10n = context.l10n;
        final newTimeStr = DtFmt.hm(
          context,
          dropResult.newStart.hour,
          dropResult.newStart.minute,
        );
        final staffName = widget.staff.displayName;

        final confirmed = await showConfirmDialog(
          context,
          title: Text(l10n.moveAppointmentConfirmTitle),
          content: Text(
            l10n.moveAppointmentConfirmMessage(newTimeStr, staffName),
          ),
          confirmLabel: l10n.actionConfirm,
          cancelLabel: l10n.actionCancel,
        );

        // Pulisci sempre lo stato pendente dopo la decisione
        ref.read(pendingDropProvider.notifier).clear();

        if (confirmed && mounted) {
          appointmentsNotifier.moveAppointment(
            appointmentId: details.data.id,
            newStaffId: widget.staff.id,
            newStart: dropResult.newStart,
            newEnd: dropResult.newEnd,
          );
        }
      },
      builder: (context, candidateData, rejectedData) {
        return GestureDetector(
          onTap: () {
            ref.read(selectedAppointmentProvider.notifier).clear();
          },
          child: SizedBox(
            width: widget.columnWidth,
            child: Container(
              decoration: BoxDecoration(
                color: _isHighlighted
                    ? widget.staff.color.withOpacity(0.01)
                    : Colors.transparent,
                border: widget.showRightBorder
                    ? Border(
                        right: BorderSide(
                          color: Colors.grey.withOpacity(0.5),
                          width: 1.0,
                        ),
                      )
                    : null,
              ),
              child: Stack(children: stackChildren),
            ),
          ),
        );
      },
    );
  }

  List<Widget> _buildAppointments(
    double slotHeight,
    List<Appointment> appointments,
    double columnWidth,
  ) {
    final draggedId = ref.watch(draggedAppointmentIdProvider);
    final layoutConfig = ref.watch(layoutConfigProvider);
    final useServiceColors = layoutConfig.useServiceColorsForAppointments;
    // üîπ Watch fuori dal loop per evitare rebuild multipli
    final pendingDrop = ref.watch(pendingDropProvider);
    final variantsAsync = useServiceColors
        ? ref.watch(serviceVariantsProvider)
        : const AsyncData(<ServiceVariant>[]);
    final variants = variantsAsync.value ?? const <ServiceVariant>[];
    final isInitialVariantsLoading =
        useServiceColors && variantsAsync.isLoading && !variantsAsync.hasValue;
    final neutralServiceColor = Theme.of(
      context,
    ).colorScheme.surfaceContainerHighest;
    // Pre-calcola la mappa dei colori dei servizi (da varianti)
    final serviceColorMap = <int, Color>{};
    for (final variant in variants) {
      if (variant.colorHex != null) {
        serviceColorMap[variant.serviceId] = ColorUtils.fromHex(
          variant.colorHex!,
        );
      }
    }

    final layoutAppointments = appointments.map((appt) {
      final resizingEntry = ref.watch(resizingEntryProvider(appt.id));
      if (resizingEntry != null &&
          resizingEntry.provisionalEndTime != appt.endTime) {
        return appt.copyWith(endTime: resizingEntry.provisionalEndTime);
      }
      return appt;
    }).toList();

    final List<List<Appointment>> overlapGroups = [];
    for (final appt in layoutAppointments) {
      bool added = false;
      for (final group in overlapGroups) {
        if (group.any(
          (g) =>
              appt.startTime.isBefore(g.endTime) &&
              appt.endTime.isAfter(g.startTime),
        )) {
          group.add(appt);
          added = true;
          break;
        }
      }
      if (!added) {
        overlapGroups.add([appt]);
      }
    }

    final positionedAppointments = <Widget>[];

    final originalAppointmentsMap = {for (var a in appointments) a.id: a};
    final layoutEntries = layoutAppointments
        .map((a) => LayoutEntry(id: a.id, start: a.startTime, end: a.endTime))
        .toList();
    final layoutGeometry = computeLayoutGeometry(
      layoutEntries,
      useClusterMaxConcurrency: layoutConfig.useClusterMaxConcurrency,
    );

    for (final group in overlapGroups) {
      final groupWidgets = <Widget>[];
      final groupSize = group.length;
      group.sort((a, b) => a.startTime.compareTo(b.startTime));

      for (int i = 0; i < groupSize; i++) {
        final layoutAppt = group[i];
        final originalAppt = originalAppointmentsMap[layoutAppt.id]!;

        final isDragged = originalAppt.id == draggedId;

        final dayStart = DateTime(
          originalAppt.startTime.year,
          originalAppt.startTime.month,
          originalAppt.startTime.day,
        );

        final startMinutes = originalAppt.startTime
            .difference(dayStart)
            .inMinutes;

        final endMinutes = layoutAppt.endTime.difference(dayStart).inMinutes;

        final double top =
            (startMinutes / layoutConfig.minutesPerSlot) * slotHeight;
        double height =
            ((endMinutes - startMinutes) / layoutConfig.minutesPerSlot) *
            slotHeight;

        final entry = ref.watch(resizingEntryProvider(originalAppt.id));
        if (entry != null) {
          height = entry.currentPreviewHeightPx;
        }

        final geometry =
            layoutGeometry[originalAppt.id] ??
            const EventGeometry(leftFraction: 0, widthFraction: 1);

        // Controlla se questo appuntamento ha un drop pendente (usa variabile pre-calcolata)
        final hasPendingDrop = pendingDrop?.appointmentId == originalAppt.id;
        final isOriginalPosition =
            hasPendingDrop && pendingDrop!.originalStaffId == widget.staff.id;

        double opacity = isDragged ? AgendaTheme.ghostOpacity : 1.0;
        // Se √® la posizione originale durante un drop pendente, mostra semi-trasparente
        if (isOriginalPosition) {
          opacity = AgendaTheme.ghostOpacity;
        }

        // üîπ Costruisci la card (usa columnWidth passato, che √® gi√† ridotto se ci sono slot pieni)
        final padding = LayoutConfig.columnInnerPadding;
        final fullColumnWidth = math.max(columnWidth - padding * 2, 0.0);
        final cardLeft = columnWidth * geometry.leftFraction + padding;
        final cardWidth = math.max(
          columnWidth * geometry.widthFraction - padding * 2,
          0.0,
        );

        Color cardColor;
        if (useServiceColors) {
          if (isInitialVariantsLoading) {
            cardColor = neutralServiceColor;
          } else {
            // Priorit√†: colore del servizio (configurabile dall'operatore).
            final serviceColor = serviceColorMap[originalAppt.serviceId];
            if (serviceColor != null) {
              cardColor = serviceColor;
            } else {
              final variant = ref.watch(
                serviceVariantByIdProvider(originalAppt.serviceVariantId),
              );
              if (variant != null && variant.colorHex != null) {
                cardColor = ColorUtils.fromHex(variant.colorHex!);
              } else {
                // Fallback: colore neutro se servizio senza colore
                cardColor = neutralServiceColor;
              }
            }
          }
        } else {
          // Se non uso colori servizio, usa colore staff
          cardColor = widget.staff.color;
        }

        groupWidgets.add(
          Positioned(
            key: ValueKey(originalAppt.id),
            top: top,
            left: cardLeft,
            width: cardWidth,
            height: height,
            child: Opacity(
              opacity: opacity,
              child: AppointmentCard(
                appointment: originalAppt,
                color: cardColor,
                columnWidth: cardWidth,
                columnOffset: cardLeft,
                dragTargetWidth: fullColumnWidth,
                expandToLeft: i > 0,
              ),
            ),
          ),
        );
      }

      // Posizioniamo i widget del gruppo in ordine inverso, cos√¨ gli
      // appuntamenti che iniziano prima rimangono sopra e non vengono
      // parzialmente coperti da quelli iniziati dopo.
      positionedAppointments.addAll(groupWidgets.reversed);
    }

    // üîπ Aggiungi preview per drop pendente se questa √® la colonna di destinazione
    // (usa la variabile pendingDrop gi√† calcolata all'inizio del metodo)
    if (pendingDrop != null && pendingDrop.newStaffId == widget.staff.id) {
      // Trova l'appuntamento originale nel provider globale
      final allAppointments = ref.watch(appointmentsProvider).value ?? [];
      final originalAppt = allAppointments.cast<Appointment?>().firstWhere(
        (a) => a?.id == pendingDrop.appointmentId,
        orElse: () => null,
      );

      if (originalAppt != null) {
        final dayStart = DateTime(
          pendingDrop.newStart.year,
          pendingDrop.newStart.month,
          pendingDrop.newStart.day,
        );

        final startMinutes = pendingDrop.newStart
            .difference(dayStart)
            .inMinutes;
        final endMinutes = pendingDrop.newEnd.difference(dayStart).inMinutes;

        final double top =
            (startMinutes / layoutConfig.minutesPerSlot) * slotHeight;
        final double height =
            ((endMinutes - startMinutes) / layoutConfig.minutesPerSlot) *
            slotHeight;

        final padding = LayoutConfig.columnInnerPadding;
        final cardWidth = math.max(widget.columnWidth - padding * 2, 0.0);

        Color cardColor;
        if (useServiceColors) {
          if (isInitialVariantsLoading) {
            cardColor = neutralServiceColor;
          } else {
            // Priorit√†: colore del servizio (configurabile dall'operatore).
            final serviceColor = serviceColorMap[originalAppt.serviceId];
            if (serviceColor != null) {
              cardColor = serviceColor;
            } else {
              final variant = ref.watch(
                serviceVariantByIdProvider(originalAppt.serviceVariantId),
              );
              if (variant != null && variant.colorHex != null) {
                cardColor = ColorUtils.fromHex(variant.colorHex!);
              } else {
                // Fallback: colore neutro se servizio senza colore
                cardColor = neutralServiceColor;
              }
            }
          }
        } else {
          // Se non uso colori servizio, usa colore staff
          cardColor = widget.staff.color;
        }

        // Preview card con bordo tratteggiato per indicare la posizione proposta
        positionedAppointments.add(
          Positioned(
            key: const ValueKey('pending_drop_preview'),
            top: top,
            left: padding,
            width: cardWidth,
            height: height,
            child: IgnorePointer(
              child: Container(
                decoration: BoxDecoration(
                  color: cardColor.withOpacity(0.3),
                  borderRadius: BorderRadius.circular(
                    LayoutConfig.borderRadius,
                  ),
                  border: Border.all(
                    color: cardColor,
                    width: 2,
                    strokeAlign: BorderSide.strokeAlignInside,
                  ),
                ),
                child: Center(
                  child: Icon(Icons.arrow_downward, color: cardColor, size: 24),
                ),
              ),
            ),
          ),
        );
      }
    }

    return positionedAppointments;
  }

  /// Costruisce i widget per i blocchi di non disponibilit√† dello staff.
  List<Widget> _buildTimeBlocks(double slotHeight) {
    final blocks = ref.watch(timeBlocksForStaffProvider(widget.staff.id));
    if (blocks.isEmpty) return [];

    final layoutConfig = ref.watch(layoutConfigProvider);
    final agendaDate = ref.watch(agendaDateProvider);
    final dayStart = DateTime(
      agendaDate.year,
      agendaDate.month,
      agendaDate.day,
    );

    final positionedBlocks = <Widget>[];
    final padding = LayoutConfig.columnInnerPadding;
    final cardWidth = math.max(widget.columnWidth - padding * 2, 0.0);

    for (final block in blocks) {
      // Calcola posizione verticale
      final startMinutes = block.startTime.difference(dayStart).inMinutes;
      final endMinutes = block.endTime.difference(dayStart).inMinutes;

      // Clamp ai limiti della giornata visualizzata
      final clampedStartMinutes = startMinutes.clamp(
        0,
        LayoutConfig.hoursInDay * 60,
      );
      final clampedEndMinutes = endMinutes.clamp(
        0,
        LayoutConfig.hoursInDay * 60,
      );

      if (clampedEndMinutes <= clampedStartMinutes) continue;

      final double top =
          (clampedStartMinutes / layoutConfig.minutesPerSlot) * slotHeight;
      final double height =
          ((clampedEndMinutes - clampedStartMinutes) /
              layoutConfig.minutesPerSlot) *
          slotHeight;

      positionedBlocks.add(
        Positioned(
          key: ValueKey('block_${block.id}'),
          top: top,
          left: padding,
          width: cardWidth,
          height: height,
          child: TimeBlockWidget(
            block: block,
            height: height,
            width: cardWidth,
          ),
        ),
      );
    }

    return positionedBlocks;
  }

  Future<void> _handleSlotTap({
    required DateTime dt,
    required BookingRescheduleSession? rescheduleSession,
  }) async {
    if (rescheduleSession == null) {
      showBookingDialog(
        context,
        ref,
        date: DateUtils.dateOnly(dt),
        time: TimeOfDay(hour: dt.hour, minute: dt.minute),
        initialStaffId: widget.staff.id,
      );
      return;
    }

    if (_isApplyingBookingReschedule) return;

    if (rescheduleSession.items.isEmpty) {
      ref.read(bookingRescheduleSessionProvider.notifier).clear();
      if (mounted) {
        await FeedbackDialog.showError(
          context,
          title: context.l10n.errorTitle,
          message: context.l10n.bookingRescheduleMissingBooking,
        );
      }
      return;
    }

    final anchorId = rescheduleSession.anchorAppointmentId;
    final targetStart = DateTime(
      dt.year,
      dt.month,
      dt.day,
      dt.hour,
      dt.minute,
    );

    final l10n = context.l10n;
    final targetDateStr = DtFmt.longDate(context, targetStart);
    final targetTimeStr = DtFmt.hm(
      context,
      targetStart.hour,
      targetStart.minute,
    );

    final confirmed = await showConfirmDialog(
      context,
      title: Text(l10n.bookingRescheduleConfirmTitle),
      content: Text(
        l10n.bookingRescheduleConfirmMessage(
          targetDateStr,
          targetTimeStr,
          widget.staff.displayName,
        ),
      ),
      confirmLabel: l10n.actionConfirm,
      cancelLabel: l10n.actionCancel,
    );
    if (confirmed != true) return;

    setState(() => _isApplyingBookingReschedule = true);
    try {
      final success = await ref
          .read(appointmentsProvider.notifier)
          .moveBookingByAnchor(
            session: rescheduleSession,
            targetStart: targetStart,
            targetStaffId: widget.staff.id,
          );

      if (!mounted) return;

      if (!success) {
        await FeedbackDialog.showError(
          context,
          title: l10n.errorTitle,
          message: l10n.bookingRescheduleMoveFailed,
        );
        return;
      }

      ref.read(bookingRescheduleSessionProvider.notifier).clear();
      final refreshedAppointments = ref.read(appointmentsProvider).value ?? [];
      Appointment? movedAnchor;
      for (final appointment in refreshedAppointments) {
        if (appointment.id == anchorId) {
          movedAnchor = appointment;
          break;
        }
      }
      if (movedAnchor != null) {
        ref.read(agendaScrollRequestProvider.notifier).request(movedAnchor);
      }
    } finally {
      if (mounted) {
        setState(() => _isApplyingBookingReschedule = false);
      } else {
        _isApplyingBookingReschedule = false;
      }
    }
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/components/hour_column.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../domain/config/agenda_theme.dart';
import '../../../../providers/layout_config_provider.dart';
import '../../widgets/agenda_dividers.dart';

class HourColumn extends ConsumerWidget {
  const HourColumn({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final layoutConfig = ref.watch(layoutConfigProvider);
    final slotHeight = layoutConfig.slotHeight;
    final totalSlots = layoutConfig.totalSlots;
    final slotsPerHour = (60 ~/ layoutConfig.minutesPerSlot);

    return Column(
      children: List.generate(totalSlots, (index) {
        final isHourStart = index % slotsPerHour == 0;
        final isMainLine = (index + 1) % slotsPerHour == 0;
        final hour = (index ~/ slotsPerHour);
        final minutes = (index % slotsPerHour) * layoutConfig.minutesPerSlot;

        return SizedBox(
          height: slotHeight,
          child: Stack(
            children: [
              if (isHourStart)
                Align(
                  alignment: Alignment.center,
                  child: Text(
                    "${hour.toString().padLeft(2, '0')}:${minutes.toString().padLeft(2, '0')}",
                    textAlign: TextAlign.center,
                    style: AgendaTheme.hourTextStyle,
                  ),
                ),
              Align(
                alignment: Alignment.bottomLeft,
                child: AgendaHorizontalDivider(
                  color: Colors.grey.withOpacity(isMainLine ? 0.5 : 0.2),
                  thickness: isMainLine ? 1 : 0.5,
                ),
              ),
            ],
          ),
        );
      }),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/components/agenda_staff_header.dart ---
import 'package:flutter/material.dart';

import '../../../../../../core/models/staff.dart';
import '../../../../../../core/widgets/no_scrollbar_behavior.dart';
import 'staff_header_row.dart';

class AgendaStaffHeader extends StatelessWidget {
  const AgendaStaffHeader({
    super.key,
    required this.staffList,
    required this.hourColumnWidth,
    required this.totalHeight,
    required this.headerHeight,
    required this.columnWidth,
    required this.scrollController,
  });

  final List<Staff> staffList;
  final double hourColumnWidth;
  final double totalHeight;
  final double headerHeight;
  final double columnWidth;
  final ScrollController scrollController;

  @override
  Widget build(BuildContext context) {
    return Material(
      elevation: 8,
      shadowColor: Colors.black.withOpacity(0.3),
      surfaceTintColor: Colors.transparent,
      child: DecoratedBox(
        decoration: const BoxDecoration(
          border: Border(
            bottom: BorderSide(color: Color(0x1F000000), width: 0.5),
          ),
        ),
        child: ScrollConfiguration(
          behavior: const NoScrollbarBehavior(),
          child: SingleChildScrollView(
            controller: scrollController,
            scrollDirection: Axis.horizontal,
            physics: const ClampingScrollPhysics(),
            child: StaffHeaderRow(
              staffList: staffList,
              scrollController: scrollController,
              columnWidth: columnWidth,
              hourColumnWidth: hourColumnWidth,
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/components/staff_header_row.dart ---
import 'dart:math' as math;

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../../app/widgets/staff_circle_avatar.dart';
import '../../../../../../core/l10n/l10_extension.dart';
import '../../../../../../core/models/staff.dart';
import '../../../../../../core/widgets/app_dialogs.dart';
import '../../../../domain/config/layout_config.dart';
import '../../../../providers/highlighted_staff_provider.dart';
import '../../../../providers/layout_config_provider.dart';
import '../../../../../staff/presentation/dialogs/staff_dialog.dart';

class StaffHeaderRow extends ConsumerWidget {
  final List<Staff> staffList;
  final ScrollController
  scrollController; // non usato per scrollare qui, ma utile per offset/read
  final double columnWidth;
  final double hourColumnWidth; // NON usato per lasciare spazio iniziale

  const StaffHeaderRow({
    super.key,
    required this.staffList,
    required this.scrollController,
    required this.columnWidth,
    required this.hourColumnWidth,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final headerHeight = ref.watch(layoutConfigProvider).headerHeight;
    final avatarDefault = LayoutConfig.avatarSizeFor(context);
    // Ensure avatar is not larger than available header space to avoid overflow
    final avatarSize = math.min(avatarDefault, headerHeight * 0.55);
    final highlightedId = ref.watch(highlightedStaffIdProvider);

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        ...staffList.asMap().entries.map((entry) {
          final index = entry.key;
          final staff = entry.value;
          final isLast = index == staffList.length - 1;
          final isHighlighted = highlightedId == staff.id;

          final initials = staff.initials;
          final displayName = staff.displayName;

          return Stack(
            children: [
              Container(
                width: columnWidth,
                height: headerHeight,
                padding: EdgeInsets.symmetric(horizontal: headerHeight * 0.08),
                child: Center(
                  child: _StaffHeaderCell(
                    initials: initials,
                    displayName: displayName,
                    avatarSize: avatarSize,
                    isHighlighted: isHighlighted,
                    isBookableOnline: staff.isBookableOnline,
                    color: staff.color,
                    onEdit: () => showStaffDialog(
                      context,
                      ref,
                      initial: staff,
                    ),
                  ),
                ),
              ),
              if (!isLast)
                Positioned(
                  right: 0,
                  top: 0,
                  bottom: 0,
                  child: Container(
                    width: 1,
                    decoration: BoxDecoration(
                      gradient: LinearGradient(
                        begin: Alignment.topCenter,
                        end: Alignment.bottomCenter,
                        colors: [
                          Colors.grey.withOpacity(0.0),
                          Colors.grey.withOpacity(0.25),
                        ],
                        stops: const [0.0, 0.7],
                      ),
                    ),
                  ),
                ),
            ],
          );
        }),
      ],
    );
  }
}

class _StaffHeaderCell extends StatefulWidget {
  const _StaffHeaderCell({
    required this.initials,
    required this.displayName,
    required this.avatarSize,
    required this.isHighlighted,
    required this.isBookableOnline,
    required this.color,
    required this.onEdit,
  });

  final String initials;
  final String displayName;
  final double avatarSize;
  final bool isHighlighted;
  final bool isBookableOnline;
  final Color color;
  final VoidCallback onEdit;

  @override
  State<_StaffHeaderCell> createState() => _StaffHeaderCellState();
}

class _StaffHeaderCellState extends State<_StaffHeaderCell> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      cursor: SystemMouseCursors.click,
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 4),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
        ),
        child: Material(
          color: Colors.transparent,
          child: InkWell(
            onTap: widget.onEdit,
            splashColor: Colors.transparent,
            hoverColor: Colors.transparent,
            highlightColor: Colors.transparent,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Stack(
                  clipBehavior: Clip.none,
                  children: [
                    StaffCircleAvatar(
                      height: widget.avatarSize,
                      color: widget.color,
                      isHighlighted: widget.isHighlighted || _isHovered,
                      initials: widget.initials,
                    ),
                    if (!widget.isBookableOnline)
                      Positioned.fill(
                        child: Align(
                          alignment: const Alignment(0.78, 0.78),
                          child: Transform.translate(
                            offset: Offset(
                              widget.avatarSize * 0.02,
                              widget.avatarSize * 0.02,
                            ),
                            child: Tooltip(
                              message:
                                  context.l10n.staffNotBookableOnlineTooltip,
                              child: GestureDetector(
                                onTap: () {
                                  showAppInfoDialog(
                                    context,
                                    title: Text(
                                      context.l10n
                                          .staffNotBookableOnlineTitle,
                                    ),
                                    content: Text(
                                      context.l10n
                                          .staffNotBookableOnlineMessage,
                                    ),
                                    closeLabel: context.l10n.actionClose,
                                  );
                                },
                                child: Container(
                                  padding: const EdgeInsets.all(2),
                                  decoration: BoxDecoration(
                                    color:
                                        Theme.of(context).colorScheme.surface,
                                    shape: BoxShape.circle,
                                  ),
                                  child: Icon(
                                    Icons.cloud_off_outlined,
                                    size: 14,
                                    color:
                                        Theme.of(context).colorScheme.primary,
                                  ),
                                ),
                              ),
                            ),
                          ),
                        ),
                      ),
                  ],
                ),
                const SizedBox(height: 4),
                Text(
                  widget.displayName,
                  maxLines: 1,
                  textAlign: TextAlign.center,
                  overflow: TextOverflow.ellipsis,
                  style: const TextStyle(
                    fontWeight: FontWeight.w600,
                    fontSize: 11,
                    color: Colors.black87,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/agenda_staff_body.dart ---
import 'package:flutter/material.dart';

import '../../../../../core/models/appointment.dart';
import '../../../../../core/models/staff.dart';
import '../../../../../core/widgets/no_scrollbar_behavior.dart';
import '../../../domain/config/layout_config.dart';
import '../helper/responsive_layout.dart';
import 'staff_column.dart';

class AgendaStaffBody extends StatelessWidget {
  const AgendaStaffBody({
    super.key,
    required this.verticalController,
    required this.horizontalController,
    required this.staffList,
    required this.appointments,
    required this.layoutConfig,
    required this.availableWidth,
    required this.isResizing,
    required this.dragLayerLink,
    required this.bodyKey,
    required this.isInteractionLocked,
  });

  final ScrollController verticalController;
  final ScrollController horizontalController;
  final List<Staff> staffList;
  final List<Appointment> appointments;
  final LayoutConfig layoutConfig;
  final double availableWidth;
  final bool isResizing;
  final LayerLink? dragLayerLink;
  final GlobalKey bodyKey;
  final bool isInteractionLocked;

  @override
  Widget build(BuildContext context) {
    final layout = ResponsiveLayout.of(
      context,
      staffCount: staffList.length,
      config: layoutConfig,
      availableWidth: availableWidth,
    );

    final totalContentWidth = layout.columnWidth * staffList.length;

    // final hourColumnWidth = layoutConfig.hourColumnWidth;

    Widget content = ScrollConfiguration(
      // mantiene l'assenza di scrollbar come prima
      behavior: const NoScrollbarBehavior(),
      child: SingleChildScrollView(
        controller: verticalController,
        physics: isResizing
            ? const NeverScrollableScrollPhysics()
            : const ClampingScrollPhysics(),
        child: Stack(
          children: [
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(
                  child: SingleChildScrollView(
                    controller: horizontalController,
                    scrollDirection: Axis.horizontal,
                    physics: const ClampingScrollPhysics(),
                    clipBehavior: Clip.hardEdge,
                    child: SizedBox(
                      width: totalContentWidth,
                      child: Stack(
                        children: [
                          // üîπ Colonne staff (come prima)
                          Row(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: staffList.asMap().entries.map((entry) {
                              final index = entry.key;
                              final staff = entry.value;
                              final isLast = index == staffList.length - 1;
                              final staffAppointments = appointments
                                  .where(
                                    (appointment) =>
                                        appointment.staffId == staff.id,
                                  )
                                  .toList();

                              return StaffColumn(
                                staff: staff,
                                appointments: staffAppointments,
                                columnWidth: layout.columnWidth,
                                isInteractionLocked: isInteractionLocked,
                                // Questo flag ora √® ignorato all'interno di StaffColumn,
                                // ma lo manteniamo per compatibilit√†.
                                showRightBorder:
                                    staffList.length > 1 && !isLast,
                              );
                            }).toList(),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
            //CurrentTimeLine(hourColumnWidth: hourColumnWidth),
          ],
        ),
      ),
    );

    if (dragLayerLink != null) {
      content = CompositedTransformTarget(
        key: bodyKey,
        link: dragLayerLink!,
        child: content,
      );
    } else {
      content = KeyedSubtree(key: bodyKey, child: content);
    }

    return content;
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/agenda_day.dart ---
import 'package:agenda_backend/features/agenda/presentation/screens/day_view/multi_staff_day_view.dart';
import 'package:agenda_backend/features/agenda/providers/date_range_provider.dart';
import 'package:agenda_backend/features/agenda/providers/initial_scroll_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../core/models/staff.dart';
import '../../../domain/config/layout_config.dart';
import '../../../providers/layout_config_provider.dart';

class AgendaDayController {
  _AgendaDayState? _state;
  double? _pendingOffset;

  void _attach(_AgendaDayState state) {
    _state = state;
    if (_pendingOffset != null) {
      state._jumpToExternalOffset(_pendingOffset!);
      _pendingOffset = null;
    }
  }

  void _detach(_AgendaDayState state) {
    if (_state == state) _state = null;
  }

  void jumpTo(double offset) {
    final state = _state;
    if (state == null) {
      _pendingOffset = offset;
      return;
    }
    state._jumpToExternalOffset(offset);
  }

  void dispose() {
    _state = null;
    _pendingOffset = null;
  }
}

class AgendaDay extends ConsumerStatefulWidget {
  const AgendaDay({
    super.key,
    required this.staffList,
    this.onVerticalOffsetChanged,
    this.controller,
    required this.hourColumnWidth,
    required this.currentTimeVerticalOffset,
  });

  final List<Staff> staffList;
  final ValueChanged<double>? onVerticalOffsetChanged;
  final AgendaDayController? controller;
  final double hourColumnWidth;
  final double currentTimeVerticalOffset;

  @override
  ConsumerState<AgendaDay> createState() => _AgendaDayState();
}

class _AgendaDayState extends ConsumerState<AgendaDay> {
  ScrollController? _centerVerticalController;

  DateTime? _previousDate;
  bool _slideFromRight = true;

  /// Data attualmente attiva per filtrare eventi da widget in uscita
  DateTime? _activeDate;

  @override
  void initState() {
    super.initState();
    widget.controller?._attach(this);
  }

  @override
  void dispose() {
    widget.controller?._detach(this);
    super.dispose();
  }

  /// Ottiene l'offset corrente (dal provider o calcolato dall'orario attuale)
  double _getCurrentScrollOffset() {
    final savedOffset = ref.read(agendaVerticalOffsetProvider);
    if (savedOffset != null) {
      return savedOffset;
    }
    // Prima apertura: usa l'orario corrente
    final layoutConfig = ref.read(layoutConfigProvider);
    return _timelineOffsetForToday(layoutConfig);
  }

  void _handleCenterVerticalController(ScrollController controller) {
    if (_centerVerticalController == controller) return;
    _centerVerticalController = controller;

    // üîπ Scroll all'orario corrente SOLO alla prima apertura dell'app
    final initialScrollDone = ref.read(initialScrollDoneProvider);

    if (initialScrollDone) {
      // Non √® la prima apertura: sincronizza solo la HourColumn con l'offset corrente
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (!mounted || !controller.hasClients) return;
        // Notifica l'offset corrente per sincronizzare la HourColumn
        widget.onVerticalOffsetChanged?.call(_getCurrentScrollOffset());
      });
      return;
    }

    final layoutConfig = ref.read(layoutConfigProvider);
    final initialOffset = _timelineOffsetForToday(layoutConfig);

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted || !controller.hasClients) return;

      // Marca lo scroll iniziale come completato (dopo il build)
      ref.read(initialScrollDoneProvider.notifier).markDone();

      // Centra la timeline al centro della viewport visibile
      final viewportHeight = controller.position.viewportDimension;
      final target = (initialOffset - viewportHeight / 2)
          .clamp(
            controller.position.minScrollExtent,
            controller.position.maxScrollExtent,
          )
          .toDouble();
      controller.jumpTo(target);
      // Salva nel provider
      ref.read(agendaVerticalOffsetProvider.notifier).set(target);
      widget.onVerticalOffsetChanged?.call(target);
    });
  }

  void _jumpToExternalOffset(double offset) {
    final controller = _centerVerticalController;
    if (controller == null || !controller.hasClients) {
      ref.read(agendaVerticalOffsetProvider.notifier).set(offset);
      return;
    }

    final clamped = offset.clamp(
      controller.position.minScrollExtent,
      controller.position.maxScrollExtent,
    );

    if ((controller.offset - clamped).abs() < 0.5) {
      ref.read(agendaVerticalOffsetProvider.notifier).set(clamped);
      return;
    }

    controller.jumpTo(clamped);
    ref.read(agendaVerticalOffsetProvider.notifier).set(clamped);
    widget.onVerticalOffsetChanged?.call(clamped);
  }

  @override
  Widget build(BuildContext context) {
    final date = ref.watch(agendaDateProvider);
    final currentScrollOffset = _getCurrentScrollOffset();

    // calcola direzione
    if (_previousDate != null && _previousDate != date) {
      _slideFromRight = date.isBefore(_previousDate!);
    }
    _previousDate = date;

    // Aggiorna la data attiva per filtrare callback da widget in uscita
    _activeDate = date;

    // üëá AnimatedSwitcher forza animazione visibile anche se Flutter riusa il widget
    return AnimatedSwitcher(
      duration: const Duration(milliseconds: 400),
      reverseDuration: const Duration(milliseconds: 250),
      layoutBuilder: (currentChild, previousChildren) {
        return Stack(
          clipBehavior: Clip.none,
          children: [
            ...previousChildren,
            if (currentChild != null) currentChild,
          ],
        );
      },
      transitionBuilder: (Widget child, Animation<double> animation) {
        final offsetTween = Tween<Offset>(
          begin: _slideFromRight
              ? const Offset(1.0, 0.0)
              : const Offset(-1.0, 0.0),
          end: Offset.zero,
        ).chain(CurveTween(curve: Curves.easeOutCubic));

        // üëá Fade + Slide combinati per rendere visibile la transizione
        return SlideTransition(
          position: animation.drive(offsetTween),
          child: FadeTransition(
            opacity: animation.drive(CurveTween(curve: Curves.easeInOut)),
            child: child,
          ),
        );
      },
      // üëá chiave unica e realmente diversa a ogni data
      child: _AnimatedDayContainer(
        key: ValueKey('day-${date.toIso8601String()}'),
        date: date,
        staffList: widget.staffList,
        currentScrollOffset: currentScrollOffset,
        onVerticalOffsetChanged: (containerDate, offset) {
          // Ignora callback da widget in uscita (durante animazione)
          if (containerDate == _activeDate) {
            _handleScrollOffsetChanged(offset);
          }
        },
        onVerticalControllerChanged: _handleCenterVerticalController,
        hourColumnWidth: widget.hourColumnWidth,
        currentTimeVerticalOffset: widget.currentTimeVerticalOffset,
      ),
    );
  }

  /// Intercetta l'offset scroll per mantenerlo al cambio data
  void _handleScrollOffsetChanged(double offset) {
    ref.read(agendaVerticalOffsetProvider.notifier).set(offset);
    widget.onVerticalOffsetChanged?.call(offset);
  }

  double _timelineOffsetForToday(LayoutConfig layoutConfig) {
    final now = DateTime.now();
    final minutes = now.hour * 60 + now.minute;
    return (minutes / layoutConfig.minutesPerSlot) * layoutConfig.slotHeight;
  }
}

class _AnimatedDayContainer extends StatelessWidget {
  const _AnimatedDayContainer({
    super.key,
    required this.date,
    required this.staffList,
    required this.currentScrollOffset,
    this.onVerticalOffsetChanged,
    required this.onVerticalControllerChanged,
    required this.hourColumnWidth,
    required this.currentTimeVerticalOffset,
  });

  final DateTime date;
  final List<Staff> staffList;
  final double currentScrollOffset;
  final void Function(DateTime date, double offset)? onVerticalOffsetChanged;
  final ValueChanged<ScrollController> onVerticalControllerChanged;
  final double hourColumnWidth;
  final double currentTimeVerticalOffset;

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        return MultiStaffDayView(
          staffList: staffList,
          initialScrollOffset: currentScrollOffset,
          onScrollOffsetChanged: (offset) {
            onVerticalOffsetChanged?.call(date, offset);
          },
          onVerticalControllerChanged: onVerticalControllerChanged,
          hourColumnWidth: hourColumnWidth,
          currentTimeVerticalOffset: currentTimeVerticalOffset,
        );
      },
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/multi_staff_day_view.dart ---
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../core/models/staff.dart';
import '../../../domain/config/layout_config.dart';
import '../../../providers/agenda_interaction_lock_provider.dart';
import '../../../providers/agenda_providers.dart';
import '../../../providers/agenda_scroll_provider.dart';
import '../../../providers/agenda_scroll_request_provider.dart';
import '../../../providers/appointment_providers.dart';
import '../../../providers/date_range_provider.dart';
import '../../../providers/drag_layer_link_provider.dart';
import '../../../providers/is_resizing_provider.dart';
import '../../../providers/layout_config_provider.dart';
import '../helper/responsive_layout.dart';
import '../widgets/current_time_line.dart';
import 'agenda_staff_body.dart';
import 'components/agenda_staff_header.dart';

class MultiStaffDayView extends ConsumerStatefulWidget {
  final List<Staff> staffList;
  final double initialScrollOffset;
  final ValueChanged<double>? onScrollOffsetChanged;
  final ValueChanged<ScrollController>? onVerticalControllerChanged;
  final double hourColumnWidth;
  final double currentTimeVerticalOffset;

  const MultiStaffDayView({
    super.key,
    required this.staffList,
    required this.initialScrollOffset,
    this.onScrollOffsetChanged,
    this.onVerticalControllerChanged,
    required this.hourColumnWidth,
    required this.currentTimeVerticalOffset,
  });

  @override
  ConsumerState<MultiStaffDayView> createState() => _MultiStaffDayViewState();
}

class _MultiStaffDayViewState extends ConsumerState<MultiStaffDayView> {
  // Auto scroll durante il drag
  Timer? _autoScrollTimer;
  static const double _scrollEdgeMargin = 100;
  static const double _scrollSpeed = 20;
  static const Duration _scrollInterval = Duration(milliseconds: 50);
  static const double _autoScrollActivationThreshold = 16;

  late final ProviderSubscription<Offset?> _dragSub;
  late final ProviderSubscription<LayoutConfig> _layoutSub;
  late final ProviderSubscription<AgendaScrollRequest?> _scrollRequestSub;
  late final ProviderSubscription<DateTime> _dateSub;

  final ScrollController _headerHCtrl = ScrollController();
  bool _isSyncing = false;
  Offset? _initialDragPosition;
  bool _autoScrollArmed = false;

  ScrollController? _bodyHorizontalCtrl;
  ScrollController? _verticalCtrl;
  List<int>? _staffSignature;

  late final DragBodyBoxNotifier _dragBodyNotifier;
  AgendaScrollRequest? _pendingScrollRequest;
  Timer? _scrollRetryTimer;

  Timer? _syncDebounce;

  final GlobalKey _bodyKey = GlobalKey();
  final GlobalKey _headerKey = GlobalKey();

  late final Object _scrollIdentity = Object();
  AgendaScrollKey get _scrollKey => AgendaScrollKey(
    identity: _scrollIdentity,
    staff: widget.staffList,
    date: DateTime.now(),
    initialOffset: widget.initialScrollOffset,
  );

  @override
  void initState() {
    super.initState();
    _dragBodyNotifier = ref.read(dragBodyBoxProvider.notifier);

    // Listener drag ‚Üí auto scroll verticale
    _dragSub = ref.listenManual<Offset?>(dragPositionProvider, (prev, next) {
      if (next != null) {
        if (prev == null) {
          _initialDragPosition = next;
          _autoScrollArmed = false;
        }
        _startAutoScroll();
      } else {
        _initialDragPosition = null;
        _autoScrollArmed = false;
        _stopAutoScroll();
      }
    });

    // Listener layoutConfig ‚Üí solo quando cambiano dimensioni rilevanti
    _layoutSub = ref.listenManual<LayoutConfig>(layoutConfigProvider, (
      prev,
      next,
    ) {
      if (prev == null ||
          prev.headerHeight != next.headerHeight ||
          prev.slotHeight != next.slotHeight ||
          prev.hourColumnWidth != next.hourColumnWidth) {
        _scheduleSyncUpdate();
      }
    });

    _scrollRequestSub = ref.listenManual<AgendaScrollRequest?>(
      agendaScrollRequestProvider,
      (prev, next) {
        if (next == null) return;
        final selectedDate = ref.read(agendaDateProvider);
        if (!DateUtils.isSameDay(selectedDate, next.date)) return;
        _pendingScrollRequest = next;
        _scheduleScrollToPending();
      },
    );

    // üîπ Rimosso: lo scroll automatico al cambio data
    // Lo scroll avviene SOLO:
    // 1. Alla prima apertura dell'app (gestito in AgendaDay._handleCenterVerticalController)
    // 2. Dopo creazione/modifica appuntamento (via agendaScrollRequestProvider)
    _dateSub = ref.listenManual<DateTime>(agendaDateProvider, (prev, next) {
      // No-op: non fare scroll automatico al cambio data
    });

    // Prima inizializzazione
    _scheduleSyncUpdate();
  }

  void _scheduleSyncUpdate() {
    _syncDebounce?.cancel();
    _syncDebounce = Timer(const Duration(milliseconds: 180), () {
      if (!mounted) return;
      _registerBodyBox();
      _setupHorizontalSync(force: true);
    });
  }

  void _scheduleScrollToPending() {
    _scrollRetryTimer?.cancel();
    _scrollRetryTimer = Timer(const Duration(milliseconds: 60), () {
      if (!mounted) return;
      _tryScrollToPending();
    });
  }

  void _tryScrollToPending() {
    final request = _pendingScrollRequest;
    if (request == null) return;

    final selectedDate = ref.read(agendaDateProvider);
    if (!DateUtils.isSameDay(selectedDate, request.date)) return;

    final appointments = ref.read(appointmentsForCurrentLocationProvider);
    final target = appointments
        .where((a) => a.id == request.appointment.id)
        .cast()
        .toList();
    if (target.isEmpty) {
      _scheduleScrollToPending();
      return;
    }

    final appointment = target.first;
    final scrollState = ref.read(agendaScrollProvider(_scrollKey));
    final verticalCtrl = scrollState.verticalScrollCtrl;
    final horizontalCtrl = scrollState.horizontalScrollCtrl;
    if (!verticalCtrl.hasClients || !horizontalCtrl.hasClients) {
      _scheduleScrollToPending();
      return;
    }

    final layoutConfig = ref.read(layoutConfigProvider);
    final bodyBox = _bodyKey.currentContext?.findRenderObject() as RenderBox?;
    final viewportHeight =
        bodyBox?.size.height ?? verticalCtrl.position.viewportDimension;
    final viewportWidth =
        bodyBox?.size.width ?? horizontalCtrl.position.viewportDimension;

    final startMinutes =
        appointment.startTime.hour * 60 + appointment.startTime.minute;
    final startOffset =
        (startMinutes / layoutConfig.minutesPerSlot) * layoutConfig.slotHeight;
    final durationMinutes = appointment.endTime
        .difference(appointment.startTime)
        .inMinutes
        .clamp(layoutConfig.minutesPerSlot, 1440);
    final cardHeight =
        (durationMinutes / layoutConfig.minutesPerSlot) *
        layoutConfig.slotHeight;

    final targetY =
        startOffset -
        (viewportHeight - cardHeight).clamp(0, viewportHeight) / 2;
    final maxY = verticalCtrl.position.maxScrollExtent;
    final clampedY = targetY.clamp(0.0, maxY);

    final staffIndex = widget.staffList.indexWhere(
      (s) => s.id == appointment.staffId,
    );
    if (staffIndex >= 0) {
      final layout = ResponsiveLayout.of(
        context,
        staffCount: widget.staffList.length,
        config: layoutConfig,
        availableWidth: viewportWidth,
      );
      final columnWidth = layout.columnWidth;
      final targetX =
          (staffIndex * columnWidth) - (viewportWidth - columnWidth) / 2;
      final maxX = horizontalCtrl.position.maxScrollExtent;
      final clampedX = targetX.clamp(0.0, maxX);
      if ((horizontalCtrl.offset - clampedX).abs() > 0.5) {
        horizontalCtrl.jumpTo(clampedX);
      }
    }

    if ((verticalCtrl.offset - clampedY).abs() > 0.5) {
      verticalCtrl.jumpTo(clampedY);
    }

    _pendingScrollRequest = null;
    ref.read(agendaScrollRequestProvider.notifier).clear();
  }

  void _registerBodyBox() {
    final box = _bodyKey.currentContext?.findRenderObject() as RenderBox?;
    if (box != null) {
      _dragBodyNotifier.set(box);
    }
  }

  void _clearBodyBox() {
    _dragBodyNotifier.scheduleClear();
  }

  void _setupHorizontalSync({bool force = false}) {
    final newSignature = widget.staffList.map((s) => s.id).toList();
    if (!force &&
        _staffSignature != null &&
        listEquals(_staffSignature, newSignature)) {
      return;
    }
    _staffSignature = newSignature;

    final bodyCtrl = ref
        .read(agendaScrollProvider(_scrollKey))
        .horizontalScrollCtrl;

    if (!force && identical(_bodyHorizontalCtrl, bodyCtrl)) {
      return;
    }

    _bodyHorizontalCtrl?.removeListener(_onBodyHorizontalScroll);
    _headerHCtrl.removeListener(_onHeaderHorizontalScroll);

    _bodyHorizontalCtrl = bodyCtrl;
    _bodyHorizontalCtrl?.addListener(_onBodyHorizontalScroll);
    _headerHCtrl.addListener(_onHeaderHorizontalScroll);

    if (_headerHCtrl.hasClients && _bodyHorizontalCtrl!.hasClients) {
      _headerHCtrl.jumpTo(_bodyHorizontalCtrl!.offset);
    }
  }

  void _onBodyHorizontalScroll() {
    final bodyCtrl = _bodyHorizontalCtrl;
    if (_isSyncing || bodyCtrl == null) return;
    if (!bodyCtrl.hasClients || !_headerHCtrl.hasClients) return;

    _isSyncing = true;
    _headerHCtrl.jumpTo(bodyCtrl.offset);
    _isSyncing = false;
  }

  void _onHeaderHorizontalScroll() {
    final bodyCtrl = _bodyHorizontalCtrl;
    if (_isSyncing || bodyCtrl == null) return;
    if (!bodyCtrl.hasClients || !_headerHCtrl.hasClients) return;

    _isSyncing = true;
    bodyCtrl.jumpTo(_headerHCtrl.offset);
    _isSyncing = false;
  }

  void _onVerticalScrollChanged() {
    final controller = _verticalCtrl;
    if (controller == null) return;
    widget.onScrollOffsetChanged?.call(controller.offset);
  }

  void _startAutoScroll() {
    if (_autoScrollTimer != null) return;
    _autoScrollTimer = Timer.periodic(_scrollInterval, (_) {
      if (!mounted) return;

      // dragPos √® in coordinate BODY-LOCAL (DragBodyBox)
      final dragPos = ref.read(dragPositionProvider);
      if (dragPos == null) {
        _stopAutoScroll();
        return;
      }

      final bodyBox = ref.read(dragBodyBoxProvider);
      if (bodyBox == null || !bodyBox.attached) {
        return;
      }

      if (!_autoScrollArmed && _initialDragPosition != null) {
        final deltaX = (dragPos.dx - _initialDragPosition!.dx).abs();
        final deltaY = (dragPos.dy - _initialDragPosition!.dy).abs();
        final maxDelta = deltaX > deltaY ? deltaX : deltaY;
        if (maxDelta < _autoScrollActivationThreshold) return;
        _autoScrollArmed = true;
      }

      final scrollState = ref.read(agendaScrollProvider(_scrollKey));
      final verticalCtrl = scrollState.verticalScrollCtrl;
      final horizontalCtrl = scrollState.horizontalScrollCtrl;
      if (!verticalCtrl.hasClients && !horizontalCtrl.hasClients) return;

      // dragPos √® gi√† in coordinate locali del bodyBox
      final localPos = dragPos;
      final viewHeight = bodyBox.size.height;
      final viewWidth = bodyBox.size.width;

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Auto scroll verticale (comportamento esistente)
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if (verticalCtrl.hasClients) {
        final maxExtent = verticalCtrl.position.maxScrollExtent;
        final current = verticalCtrl.offset;

        double? newOffset;
        if (localPos.dy < _scrollEdgeMargin && current > 0) {
          newOffset = (current - _scrollSpeed).clamp(0, maxExtent);
        } else if (localPos.dy > viewHeight - _scrollEdgeMargin &&
            current < maxExtent) {
          newOffset = (current + _scrollSpeed).clamp(0, maxExtent);
        }

        if (newOffset != null && newOffset != current) {
          verticalCtrl.jumpTo(newOffset);
        }
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Auto scroll orizzontale per raggiungere colonne nascoste
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if (horizontalCtrl.hasClients) {
        final maxHorizontal = horizontalCtrl.position.maxScrollExtent;
        final currentX = horizontalCtrl.offset;

        // Usiamo una soglia relativa alla larghezza visibile,
        // per renderlo affidabile anche con layout molto larghi.
        const double edgeFraction = 0.18; // ~18% ai lati
        final double leftEdge = viewWidth * edgeFraction;
        final double rightEdge = viewWidth * (1 - edgeFraction);

        double? newOffsetX;
        if (localPos.dx < leftEdge && currentX > 0) {
          newOffsetX = (currentX - _scrollSpeed).clamp(0, maxHorizontal);
        } else if (localPos.dx > rightEdge && currentX < maxHorizontal) {
          newOffsetX = (currentX + _scrollSpeed).clamp(0, maxHorizontal);
        }

        if (newOffsetX != null && newOffsetX != currentX) {
          horizontalCtrl.jumpTo(newOffsetX);
        }
      }
    });
  }

  void _stopAutoScroll() {
    _autoScrollTimer?.cancel();
    _autoScrollTimer = null;
    _initialDragPosition = null;
    _autoScrollArmed = false;
  }

  @override
  void dispose() {
    _dragSub.close();
    _layoutSub.close();
    _scrollRequestSub.close();
    _dateSub.close();
    _stopAutoScroll();
    _syncDebounce?.cancel();
    _scrollRetryTimer?.cancel();

    _bodyHorizontalCtrl?.removeListener(_onBodyHorizontalScroll);
    _headerHCtrl.removeListener(_onHeaderHorizontalScroll);
    _verticalCtrl?.removeListener(_onVerticalScrollChanged);

    _clearBodyBox();

    _headerHCtrl.dispose();
    super.dispose();
  }

  @override
  void didUpdateWidget(MultiStaffDayView oldWidget) {
    super.didUpdateWidget(oldWidget);

    // ogni cambio staffList/date ‚Üí resync orizzontale
    _scheduleSyncUpdate();

    // stesso comportamento di prima per isPrimary
    // quando smette di essere primary: pulisce il body
    _clearBodyBox();
  }

  @override
  Widget build(BuildContext context) {
    final appointments = ref.watch(appointmentsForCurrentLocationProvider);
    final scrollState = ref.watch(agendaScrollProvider(_scrollKey));
    final layoutConfig = ref.watch(layoutConfigProvider);
    // Evaluate the interaction lock once here for the current visible group
    final isInteractionLocked = ref.watch(agendaDayScrollLockProvider);

    final verticalCtrl = scrollState.verticalScrollCtrl;
    if (_verticalCtrl != verticalCtrl) {
      _verticalCtrl?.removeListener(_onVerticalScrollChanged);
      _verticalCtrl = verticalCtrl;
      _verticalCtrl?.addListener(_onVerticalScrollChanged);
      widget.onVerticalControllerChanged?.call(verticalCtrl);
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        final availableWidth =
            constraints.hasBoundedWidth && constraints.maxWidth.isFinite
            ? constraints.maxWidth
            : MediaQuery.of(context).size.width;

        final layout = ResponsiveLayout.of(
          context,
          staffCount: widget.staffList.length,
          config: layoutConfig,
          availableWidth: availableWidth,
        );

        final totalHeight = layoutConfig.totalHeight;
        final hourW = layoutConfig.hourColumnWidth;
        final headerHeight = layoutConfig.headerHeight;
        final LayerLink? link = ref.watch(dragLayerLinkProvider);
        final selectedDate = ref.watch(agendaDateProvider);
        final isToday = DateUtils.isSameDay(
          selectedDate,
          DateUtils.dateOnly(DateTime.now()),
        );

        final isResizing = ref.watch(isResizingProvider);

        return Stack(
          clipBehavior: Clip.none,
          children: [
            // BODY scrollabile
            Positioned.fill(
              top: headerHeight,
              child: AgendaStaffBody(
                verticalController: scrollState.verticalScrollCtrl,
                horizontalController: scrollState.horizontalScrollCtrl,
                staffList: widget.staffList,
                appointments: appointments,
                layoutConfig: layoutConfig,
                availableWidth: availableWidth,
                isResizing: isResizing,
                dragLayerLink: link,
                bodyKey: _bodyKey,
                isInteractionLocked: isInteractionLocked,
              ),
            ),
            // LINEA ORARIO (solo per la data odierna)
            if (isToday)
              CurrentTimeLine(
                hourColumnWidth: widget.hourColumnWidth,
                verticalOffset: widget.currentTimeVerticalOffset,
                horizontalOffset:
                    -widget.hourColumnWidth + CurrentTimeLine.horizontalMargin,
              ),
            // HEADER staff
            Positioned(
              top: 0,
              left: 0,
              right: 0,
              height: headerHeight,
              child: KeyedSubtree(
                key: _headerKey,
                child: AgendaStaffHeader(
                  staffList: widget.staffList,
                  hourColumnWidth: hourW,
                  totalHeight: totalHeight,
                  headerHeight: headerHeight,
                  columnWidth: layout.columnWidth,
                  scrollController: _headerHCtrl,
                ),
              ),
            ),
          ],
        );
      },
    );
  }
}
--- FILE: lib/features/agenda/presentation/agenda_screen.dart ---
import 'dart:async';

import 'package:agenda_backend/app/providers/global_loading_provider.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/widgets/no_scrollbar_behavior.dart';
import 'package:agenda_backend/features/agenda/domain/staff_filter_mode.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/day_view/agenda_day.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/day_view/components/hour_column.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/widgets/agenda_dividers.dart';
import 'package:agenda_backend/core/widgets/app_buttons.dart';
import 'package:agenda_backend/features/agenda/providers/appointment_providers.dart';
import 'package:agenda_backend/features/agenda/providers/booking_reschedule_provider.dart';
import 'package:agenda_backend/features/agenda/providers/business_providers.dart';
import 'package:agenda_backend/features/agenda/providers/is_resizing_provider.dart';
import 'package:agenda_backend/features/agenda/providers/layout_config_provider.dart';
import 'package:agenda_backend/features/agenda/providers/staff_filter_providers.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../providers/agenda_scroll_request_provider.dart';
import '../providers/date_range_provider.dart';
import '../providers/location_providers.dart';

class AgendaScreen extends ConsumerStatefulWidget {
  const AgendaScreen({super.key, this.initialClientId});

  /// Se valorizzato, crea automaticamente una prenotazione rapida per il client.
  final int? initialClientId;

  @override
  ConsumerState<AgendaScreen> createState() => _AgendaScreenState();
}

class _AgendaScreenState extends ConsumerState<AgendaScreen> {
  final ScrollController _hourColumnController = ScrollController();
  final AgendaDayController _timelineController = AgendaDayController();
  late final ProviderSubscription<AgendaScrollRequest?> _scrollRequestSub;
  late final ProviderSubscription<int> _locationSub;
  Timer? _pollingTimer;

  /// Intervallo polling: 10 secondi in debug, 5 minuti in produzione
  static const _pollingIntervalDebug = Duration(seconds: 10);
  static const _pollingIntervalProd = Duration(minutes: 5);

  double? _pendingHourOffset;
  bool _pendingApplyScheduled = false;
  bool _quickBookingTriggered = false;

  // üîπ offset verticale "master" della giornata (usato anche dalla CurrentTimeLine)
  double _verticalOffset = 0;

  // üîπ Flag per distinguere polling automatico da altre operazioni
  bool _isPolling = false;

  @override
  void dispose() {
    _pollingTimer?.cancel();
    _scrollRequestSub.close();
    _locationSub.close();
    _timelineController.dispose();
    _hourColumnController.dispose();
    super.dispose();
  }

  void _handleMasterScroll(double offset) {
    // aggiorna l'offset usato dalla CurrentTimeLine
    if (mounted) {
      setState(() {
        _verticalOffset = offset;
      });
    }

    // sincronizza lo scroll della colonna oraria con la timeline
    if (!_hourColumnController.hasClients) {
      _pendingHourOffset = offset;
      _schedulePendingApply();
      return;
    }

    final position = _hourColumnController.position;
    final target = offset.clamp(
      position.minScrollExtent,
      position.maxScrollExtent,
    );

    if ((position.pixels - target).abs() < 0.5) {
      return;
    }

    _hourColumnController.jumpTo(target);
  }

  void _applyPendingOffset() {
    if (!mounted || _pendingHourOffset == null) return;

    if (!_hourColumnController.hasClients) {
      _schedulePendingApply();
      return;
    }

    final position = _hourColumnController.position;
    final target = _pendingHourOffset!.clamp(
      position.minScrollExtent,
      position.maxScrollExtent,
    );

    _hourColumnController.jumpTo(target);
    _pendingHourOffset = null;
  }

  void _schedulePendingApply() {
    if (_pendingApplyScheduled) return;
    _pendingApplyScheduled = true;
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _pendingApplyScheduled = false;
      if (!mounted) return;
      _applyPendingOffset();
    });
  }

  @override
  void initState() {
    super.initState();

    // NOTE: Non chiamiamo refresh() qui perch√©:
    // 1. I provider AsyncNotifier caricano i dati automaticamente nel build()
    // 2. Il refresh al cambio tab avviene in _refreshProvidersForTab()

    // Polling automatico per aggiornare gli appuntamenti
    // Debug: ogni 10 secondi, Produzione: ogni 5 minuti
    final interval = kDebugMode ? _pollingIntervalDebug : _pollingIntervalProd;
    _pollingTimer = Timer.periodic(interval, (_) {
      if (!mounted) return;
      // Ricarica solo gli appuntamenti (dati che cambiano pi√π frequentemente)
      _isPolling = true;
      ref.invalidate(appointmentsProvider);
    });

    _scrollRequestSub = ref.listenManual<AgendaScrollRequest?>(
      agendaScrollRequestProvider,
      (prev, next) {
        if (next == null) return;
        final currentDate = ref.read(agendaDateProvider);
        final targetDate = next.date;
        if (!DateUtils.isSameDay(currentDate, targetDate)) {
          ref.read(agendaDateProvider.notifier).set(targetDate);
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (!mounted) return;
            ref
                .read(agendaScrollRequestProvider.notifier)
                .request(next.appointment);
          });
        }
      },
    );

    _locationSub = ref.listenManual<int>(
      currentLocationIdProvider,
      (prev, next) {
        if (prev == null || prev == next) return;
        final session = ref.read(bookingRescheduleSessionProvider);
        if (session == null) return;
        ref.read(agendaDateProvider.notifier).set(session.originDate);
        ref.read(bookingRescheduleSessionProvider.notifier).clear();
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final ref = this.ref;

    // Controlla se i dati sono ancora in caricamento
    final staffAsync = ref.watch(allStaffProvider);
    final locations = ref.watch(locationsProvider);
    final locationsLoaded = ref.watch(locationsLoadedProvider);
    final currentLocationId = ref.watch(currentLocationIdProvider);
    final appointmentsAsync = ref.watch(appointmentsProvider);
    final rescheduleSession = ref.watch(bookingRescheduleSessionProvider);
    final currentBusinessId = ref.watch(currentBusinessIdProvider);
    final globalLoadingCount = ref.watch(globalLoadingProvider);
    final isGlobalLoading = globalLoadingCount > 0;

    // Ascolta cambi data per resettare il flag polling
    // (se l'utente cambia data durante il polling, deve mostrare loading)
    ref.listen(agendaDateProvider, (prev, next) {
      if (prev != null && !DateUtils.isSameDay(prev, next)) {
        _isPolling = false;
      }
    });

    // Resetta il flag polling quando il caricamento finisce
    if (!appointmentsAsync.isLoading) {
      _isPolling = false;
    }

    // Mostra loading se:
    // 1. Business ID non ancora disponibile
    // 2. Staff in caricamento iniziale (senza dati)
    // 3. Locations non ancora caricate (locationsLoaded = false)
    // 4. Location corrente non ancora selezionata (dopo che ci sono locations)
    // 5. Appuntamenti in caricamento E non √® polling automatico
    final hasLocations = locations.isNotEmpty;
    final isWaitingForBusiness = currentBusinessId <= 0;
    final isWaitingForLocations = !locationsLoaded;
    final isWaitingForLocationSelection =
        locationsLoaded && hasLocations && currentLocationId == 0;
    final isLoading =
        isWaitingForBusiness ||
        (staffAsync.isLoading && !staffAsync.hasValue) ||
        isWaitingForLocations ||
        isWaitingForLocationSelection ||
        (appointmentsAsync.isLoading && !_isPolling && !staffAsync.hasValue);

    final staffList = ref.watch(filteredStaffProvider);
    final staffFilterMode = ref.watch(staffFilterModeProvider);
    final hasStaff = staffList.isNotEmpty;
    final isResizing = ref.watch(isResizingProvider);
    final layoutConfig = ref.watch(layoutConfigProvider);

    final hourColumnWidth = layoutConfig.hourColumnWidth;
    final totalHeight = layoutConfig.totalHeight;

    // Se arriviamo con un clientId e non abbiamo ancora creato la prenotazione rapida
    final initialClientId = widget.initialClientId;
    if (initialClientId != null && !_quickBookingTriggered) {
      // Usa addPostFrame per evitare rebuild loop
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (!mounted) return;
        _quickBookingTriggered = true;
        ref
            .read(appointmentsProvider.notifier)
            .createQuickBookingForClient(initialClientId);
      });
    }

    final hourColumnStack = SizedBox(
      width: hourColumnWidth,
      child: Stack(
        clipBehavior: Clip.none,
        children: [
          Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              DecoratedBox(
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.surface,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.12),
                      offset: const Offset(3, 0),
                      blurRadius: 12,
                      spreadRadius: 0,
                    ),
                  ],
                ),
                child: SizedBox(
                  width: hourColumnWidth,
                  height: layoutConfig.headerHeight,
                ),
              ),
              Expanded(
                child: ScrollConfiguration(
                  behavior: const NoScrollbarBehavior(),
                  child: SingleChildScrollView(
                    controller: _hourColumnController,
                    scrollDirection: Axis.vertical,
                    physics: isResizing || hasStaff
                        ? const NeverScrollableScrollPhysics()
                        : null,
                    child: SizedBox(
                      width: hourColumnWidth,
                      child: const HourColumn(),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );

    final mainRow = Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (hasStaff) hourColumnStack,
        if (hasStaff)
          AgendaVerticalDivider(
            height: totalHeight,
            thickness: 1,
            fadeTopHeight: layoutConfig.headerHeight,
          ),
        Expanded(
          child: AgendaDay(
            staffList: staffList,
            onVerticalOffsetChanged: _handleMasterScroll,
            controller: _timelineController,
            hourColumnWidth: hourColumnWidth,
            currentTimeVerticalOffset: _verticalOffset,
          ),
        ),
      ],
    );

    return Stack(
      children: [
        Positioned.fill(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              if (rescheduleSession != null)
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 10,
                  ),
                  color: Theme.of(
                    context,
                  ).colorScheme.secondaryContainer.withOpacity(0.18),
                  child: Row(
                    children: [
                      Expanded(
                        child: Text(
                          context.l10n.bookingRescheduleModeHint,
                          style: Theme.of(context).textTheme.bodyMedium,
                        ),
                      ),
                      const SizedBox(width: 12),
                      AppOutlinedActionButton(
                        onPressed: () {
                          ref
                              .read(agendaDateProvider.notifier)
                              .set(rescheduleSession.originDate);
                          ref
                              .read(bookingRescheduleSessionProvider.notifier)
                              .clear();
                        },
                        child: Text(context.l10n.bookingRescheduleCancelAction),
                      ),
                    ],
                  ),
                ),
              Expanded(
                child: isLoading
                    // Mostra loading indicator durante il caricamento
                    ? isGlobalLoading
                          ? const SizedBox.shrink()
                          : const Center(child: CircularProgressIndicator())
                    : !hasLocations
                    ? Center(
                        child: Text(
                          context.l10n.agendaNoLocations,
                          style: Theme.of(context).textTheme.titleMedium,
                          textAlign: TextAlign.center,
                        ),
                      )
                    : hasStaff
                    ? mainRow
                    : Center(
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Text(
                              staffFilterMode == StaffFilterMode.onDutyTeam
                                  ? context.l10n.agendaNoOnDutyTeamTitle
                                  : context.l10n.agendaNoSelectedTeamTitle,
                              style: Theme.of(context).textTheme.titleMedium,
                              textAlign: TextAlign.center,
                            ),
                            const SizedBox(height: 12),
                            ElevatedButton(
                              onPressed: () {
                                ref
                                    .read(staffFilterModeProvider.notifier)
                                    .set(StaffFilterMode.allTeam);
                              },
                              child: Text(context.l10n.agendaShowAllTeamButton),
                            ),
                          ],
                        ),
                      ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}
--- FILE: lib/features/agenda/presentation/dialogs/booking_history_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/network/network_providers.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';

/// Mostra il dialog/bottom sheet con lo storico di una prenotazione
Future<void> showBookingHistoryDialog(
  BuildContext context,
  WidgetRef ref, {
  required int bookingId,
}) async {
  final formFactor = ref.read(formFactorProvider);

  final content = _BookingHistoryContent(bookingId: bookingId);

  if (formFactor == AppFormFactor.desktop) {
    await showDialog(
      context: context,
      builder: (_) => Dialog(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 500, maxHeight: 600),
          child: content,
        ),
      ),
    );
  } else {
    await AppBottomSheet.show(
      context: context,
      useRootNavigator: true,
      builder: (_) => content,
      heightFactor: 0.7,
    );
  }
}

class _BookingHistoryContent extends ConsumerStatefulWidget {
  const _BookingHistoryContent({required this.bookingId});

  final int bookingId;

  @override
  ConsumerState<_BookingHistoryContent> createState() =>
      _BookingHistoryContentState();
}

class _BookingHistoryContentState
    extends ConsumerState<_BookingHistoryContent> {
  List<Map<String, dynamic>>? _events;
  bool _isLoading = true;
  String? _error;

  @override
  void initState() {
    super.initState();
    _loadHistory();
  }

  Future<void> _loadHistory() async {
    try {
      final apiClient = ref.read(apiClientProvider);
      final response = await apiClient.getBookingHistory(
        bookingId: widget.bookingId,
      );

      if (mounted) {
        setState(() {
          _events = List<Map<String, dynamic>>.from(response['events'] ?? []);
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _error = e.toString();
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              const Icon(Icons.history),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  l10n.bookingHistoryTitle,
                  style: theme.textTheme.titleLarge,
                ),
              ),
              IconButton(
                icon: const Icon(Icons.close),
                onPressed: () => Navigator.of(context).pop(),
              ),
            ],
          ),
        ),
        const Divider(height: 1),

        // Content
        Flexible(child: _buildContent(l10n, theme)),
      ],
    );
  }

  Widget _buildContent(dynamic l10n, ThemeData theme) {
    if (_isLoading) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const CircularProgressIndicator(),
              const SizedBox(height: 16),
              Text(l10n.bookingHistoryLoading),
            ],
          ),
        ),
      );
    }

    if (_error != null) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(
                Icons.error_outline,
                size: 48,
                color: theme.colorScheme.error,
              ),
              const SizedBox(height: 16),
              Text(
                l10n.bookingHistoryError,
                style: TextStyle(color: theme.colorScheme.error),
              ),
            ],
          ),
        ),
      );
    }

    if (_events == null || _events!.isEmpty) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.inbox_outlined, size: 48, color: theme.hintColor),
              const SizedBox(height: 16),
              Text(
                l10n.bookingHistoryEmpty,
                style: TextStyle(color: theme.hintColor),
              ),
            ],
          ),
        ),
      );
    }

    return ListView.separated(
      padding: const EdgeInsets.symmetric(vertical: 8),
      itemCount: _events!.length,
      separatorBuilder: (_, __) => const Divider(height: 1, indent: 56),
      itemBuilder: (context, index) {
        final event = _events![index];
        return _EventTile(event: event);
      },
    );
  }
}

class _EventTile extends StatelessWidget {
  const _EventTile({required this.event});

  final Map<String, dynamic> event;

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final locale = Localizations.localeOf(context).toString();

    final eventType = event['event_type'] as String? ?? 'unknown';
    final actorType = event['actor_type'] as String? ?? 'system';
    final actorName = event['actor_name'] as String?;
    final createdAt = event['created_at'] as String?;
    final payload = event['payload'] as Map<String, dynamic>? ?? {};

    final (icon, color, title) = _getEventDisplay(eventType, payload, l10n);
    final actorLabel = actorName ?? _getActorLabel(actorType, l10n);

    // Format date with locale-adaptive format
    String formattedDate = '';
    if (createdAt != null) {
      try {
        final date = DateTime.parse(createdAt);
        final dateStr = DateFormat.yMMMd(locale).format(date);
        final timeStr = DateFormat.Hm(locale).format(date);
        formattedDate = '$dateStr, $timeStr';
      } catch (_) {
        formattedDate = createdAt;
      }
    }

    // Build user-friendly description based on event type and payload
    final description = _buildDescription(eventType, payload, locale, l10n);
    final isNotificationSent = eventType == 'booking_notification_sent';
    final recipientEmail =
        (payload['recipient_email'] as String?)?.trim() ?? '';

    return ListTile(
      leading: CircleAvatar(
        backgroundColor: color.withOpacity(0.15),
        child: Icon(icon, color: color, size: 20),
      ),
      title: Text(title),
      subtitle: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (description != null)
            Padding(
              padding: const EdgeInsets.only(bottom: 4),
              child: Text(description, style: theme.textTheme.bodySmall),
            ),
          if (isNotificationSent && recipientEmail.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(bottom: 2),
              child: Text(
                l10n.bookingHistoryNotificationRecipient(recipientEmail),
                style: theme.textTheme.bodySmall,
              ),
            ),
          Text(
            isNotificationSent
                ? l10n.bookingHistoryNotificationSentAt(formattedDate)
                : '$formattedDate ‚Ä¢ $actorLabel',
            style: theme.textTheme.bodySmall?.copyWith(color: theme.hintColor),
          ),
        ],
      ),
      isThreeLine:
          description != null || (isNotificationSent && recipientEmail.isNotEmpty),
    );
  }

  String? _buildDescription(
    String eventType,
    Map<String, dynamic> payload,
    String locale,
    dynamic l10n,
  ) {
    switch (eventType) {
      case 'appointment_updated':
        return _describeAppointmentUpdate(payload, locale);
      case 'booking_created':
        return _describeBookingCreated(payload, locale);
      case 'booking_notification_sent':
        return null;
      case 'booking_cancelled':
        return _describeBookingCancelled(payload, locale);
      case 'booking_item_added':
        return _describeItemAdded(payload);
      case 'booking_item_deleted':
        return _describeItemDeleted(payload);
      case 'booking_updated':
        return _describeBookingUpdate(payload);
      default:
        return null;
    }
  }

  String? _describeAppointmentUpdate(
    Map<String, dynamic> payload,
    String locale,
  ) {
    final before = payload['before'] as Map<String, dynamic>? ?? {};
    final after = payload['after'] as Map<String, dynamic>? ?? {};
    final changedFields =
        (payload['changed_fields'] as List<dynamic>?)?.cast<String>() ?? [];

    if (changedFields.isEmpty) return null;

    final descriptions = <String>[];

    // Check for time/duration changes
    final beforeStart = _parseTime(before['start_time']);
    final beforeEnd = _parseTime(before['end_time']);
    final afterStart = _parseTime(after['start_time']);
    final afterEnd = _parseTime(after['end_time']);

    if (beforeStart != null &&
        beforeEnd != null &&
        afterStart != null &&
        afterEnd != null) {
      final beforeDuration = beforeEnd.difference(beforeStart).inMinutes;
      final afterDuration = afterEnd.difference(afterStart).inMinutes;

      final startChanged = changedFields.contains('start_time');
      final endChanged = changedFields.contains('end_time');

      if (startChanged && endChanged) {
        // Both changed - check if it's a move or resize
        if (beforeDuration == afterDuration) {
          // Same duration = moved
          descriptions.add(
            'Orario spostato da ${_formatTimeWithOptionalDate(beforeStart, locale, reference: afterStart)} a ${_formatTimeWithOptionalDate(afterStart, locale, reference: beforeStart)}',
          );
        } else {
          // Different duration = resized and possibly moved
          if (beforeStart != afterStart) {
            descriptions.add(
              'Orario spostato da ${_formatTimeWithOptionalDate(beforeStart, locale, reference: afterStart)} a ${_formatTimeWithOptionalDate(afterStart, locale, reference: beforeStart)}',
            );
          }
          descriptions.add(
            'Durata modificata da ${_formatDuration(beforeDuration)} a ${_formatDuration(afterDuration)}, termina alle ${_formatTimeWithOptionalDate(afterEnd, locale, reference: afterStart)}',
          );
        }
      } else if (endChanged && !startChanged) {
        // Only end changed = resize
        descriptions.add(
          'Durata modificata da ${_formatDuration(beforeDuration)} a ${_formatDuration(afterDuration)}, termina alle ${_formatTimeWithOptionalDate(afterEnd, locale, reference: afterStart)}',
        );
      } else if (startChanged && !endChanged) {
        // Only start changed (rare)
        descriptions.add(
          'Orario inizio modificato da ${_formatTimeWithOptionalDate(beforeStart, locale, reference: afterStart)} a ${_formatTimeWithOptionalDate(afterStart, locale, reference: beforeStart)}',
        );
      }
    }

    // Check for staff change
    if (changedFields.contains('staff_id')) {
      final beforeStaff = before['staff_id'];
      final afterStaff = after['staff_id'];
      if (beforeStaff != afterStaff) {
        final beforeStaffName = before['staff_name'] as String?;
        final afterStaffName = after['staff_name'] as String?;
        if (beforeStaffName != null && afterStaffName != null) {
          descriptions.add(
            'Operatore cambiato da $beforeStaffName a $afterStaffName',
          );
        } else {
          descriptions.add('Operatore cambiato');
        }
      }
    }

    // Check for price change
    if (changedFields.contains('price')) {
      final beforePrice = (before['price'] as num?)?.toDouble();
      final afterPrice = (after['price'] as num?)?.toDouble();
      if (beforePrice != null && afterPrice != null) {
        descriptions.add(
          'Prezzo modificato da ‚Ç¨${beforePrice.toStringAsFixed(2)} a ‚Ç¨${afterPrice.toStringAsFixed(2)}',
        );
      }
    }

    return descriptions.isNotEmpty ? descriptions.join('\n') : null;
  }

  String? _describeBookingCreated(Map<String, dynamic> payload, String locale) {
    final items = payload['items'] as List<dynamic>?;
    final totalPrice = (payload['total_price'] as num?)?.toDouble();
    final firstStartTime = payload['first_start_time'] as String?;

    final parts = <String>[];

    // Data e ora
    if (firstStartTime != null) {
      try {
        final dateTime = DateTime.parse(firstStartTime);
        final dateStr = DateFormat.yMMMd(locale).format(dateTime);
        final timeStr = DateFormat.Hm(locale).format(dateTime);
        parts.add('$dateStr alle $timeStr');
      } catch (_) {}
    }

    // Staff (dal primo item)
    if (items != null && items.isNotEmpty) {
      final firstItem = items[0] as Map<String, dynamic>?;
      final staffName = firstItem?['staff_name'] as String?;
      if (staffName != null && staffName.isNotEmpty) {
        parts.add('con $staffName');
      }
    }

    // Servizi e prezzo
    if (items != null && items.isNotEmpty) {
      parts.add(
        '${items.length} ${items.length == 1 ? 'servizio' : 'servizi'}',
      );
    }

    if (totalPrice != null && totalPrice > 0) {
      parts.add('‚Ç¨${totalPrice.toStringAsFixed(2)}');
    }

    return parts.isNotEmpty ? parts.join(' ‚Ä¢ ') : null;
  }

  String? _describeBookingCancelled(
    Map<String, dynamic> payload,
    String locale,
  ) {
    final items = payload['items'] as List<dynamic>?;
    if (items != null && items.isNotEmpty) {
      return '${items.length} ${items.length == 1 ? 'appuntamento cancellato' : 'appuntamenti cancellati'}';
    }
    return null;
  }

  String _notificationChannelLabel(String channel, dynamic l10n) {
    switch (channel) {
      case 'booking_confirmed':
        return l10n.bookingHistoryNotificationChannelConfirmed;
      case 'booking_reminder':
        return l10n.bookingHistoryNotificationChannelReminder;
      case 'booking_cancelled':
        return l10n.bookingHistoryNotificationChannelCancelled;
      case 'booking_rescheduled':
        return l10n.bookingHistoryNotificationChannelRescheduled;
      default:
        return channel;
    }
  }

  String? _describeItemAdded(Map<String, dynamic> payload) {
    // Il nome servizio pu√≤ essere in item_data.service_name_snapshot o direttamente in payload
    final itemData = payload['item_data'] as Map<String, dynamic>? ?? {};
    final serviceName =
        itemData['service_name_snapshot'] as String? ??
        payload['service_name'] as String?;
    final price =
        (itemData['price'] as num?)?.toDouble() ??
        (payload['price'] as num?)?.toDouble();

    if (serviceName != null && serviceName.isNotEmpty) {
      if (price != null && price > 0) {
        return 'Aggiunto: $serviceName ‚Ä¢ ‚Ç¨${price.toStringAsFixed(2)}';
      }
      return 'Aggiunto: $serviceName';
    }
    return null;
  }

  String? _describeItemDeleted(Map<String, dynamic> payload) {
    // Il nome servizio pu√≤ essere in deleted_item o direttamente in payload
    final deletedItem = payload['deleted_item'] as Map<String, dynamic>? ?? {};
    final serviceName =
        deletedItem['service_name_snapshot'] as String? ??
        deletedItem['service_name'] as String? ??
        payload['service_name'] as String?;

    if (serviceName != null && serviceName.isNotEmpty) {
      return 'Rimosso: $serviceName';
    }
    return null;
  }

  String? _describeBookingUpdate(Map<String, dynamic> payload) {
    final changedFields =
        (payload['changed_fields'] as List<dynamic>?)?.cast<String>() ?? [];
    final before = payload['before'] as Map<String, dynamic>? ?? {};
    final after = payload['after'] as Map<String, dynamic>? ?? {};

    final descriptions = <String>[];

    if (changedFields.contains('client_id') ||
        changedFields.contains('customer_name')) {
      final beforeName = before['customer_name'] as String?;
      final afterName = after['customer_name'] as String?;
      if (beforeName != null && afterName != null && beforeName != afterName) {
        descriptions.add('Cliente cambiato da "$beforeName" a "$afterName"');
      } else if (afterName != null) {
        descriptions.add('Cliente assegnato: $afterName');
      }
    }

    if (changedFields.contains('notes')) {
      descriptions.add('Note modificate');
    }

    if (changedFields.contains('status')) {
      final afterStatus = after['status'] as String?;
      if (afterStatus != null) {
        descriptions.add('Stato: $afterStatus');
      }
    }

    return descriptions.isNotEmpty ? descriptions.join('\n') : null;
  }

  DateTime? _parseTime(dynamic value) {
    if (value == null) return null;
    if (value is String) {
      try {
        return DateTime.parse(value);
      } catch (_) {
        return null;
      }
    }
    return null;
  }

  String _formatTime(DateTime time, String locale) {
    return DateFormat.Hm(locale).format(time);
  }

  String _formatTimeWithOptionalDate(
    DateTime value,
    String locale, {
    DateTime? reference,
  }) {
    final includeDate =
        reference == null || !DateUtils.isSameDay(value, reference);
    if (!includeDate) {
      return _formatTime(value, locale);
    }
    final date = DateFormat.yMMMd(locale).format(value);
    final time = _formatTime(value, locale);
    return '$date $time';
  }

  String _formatDuration(int minutes) {
    if (minutes < 60) {
      return '$minutes min';
    }
    final hours = minutes ~/ 60;
    final mins = minutes % 60;
    if (mins == 0) {
      return '${hours}h';
    }
    return '${hours}h ${mins}min';
  }

  (IconData, Color, String) _getEventDisplay(
    String eventType,
    Map<String, dynamic> payload,
    dynamic l10n,
  ) {
    switch (eventType) {
      case 'booking_created':
        return (
          Icons.add_circle_outline,
          Colors.green,
          l10n.bookingHistoryEventCreated,
        );
      case 'booking_updated':
        return (
          Icons.edit_outlined,
          Colors.blue,
          l10n.bookingHistoryEventUpdated,
        );
      case 'booking_cancelled':
        return (
          Icons.cancel_outlined,
          Colors.red,
          l10n.bookingHistoryEventCancelled,
        );
      case 'booking_notification_sent':
        final channel = ((payload['channel'] as String?) ?? '').trim();
        return (
          Icons.mail_outline,
          Colors.lightBlue,
          l10n.bookingHistoryEventNotificationSentTitle(
            _notificationChannelLabel(channel, l10n),
          ),
        );
      case 'booking_item_added':
        return (
          Icons.add_box_outlined,
          Colors.teal,
          l10n.bookingHistoryEventItemAdded,
        );
      case 'booking_item_deleted':
        return (
          Icons.indeterminate_check_box_outlined,
          Colors.orange,
          l10n.bookingHistoryEventItemDeleted,
        );
      case 'appointment_updated':
        // Genera titolo dinamico in base ai campi modificati
        final title = _getAppointmentUpdateTitle(payload, l10n);
        return (Icons.update, Colors.purple, title);
      case 'booking_replaced':
      case 'booking_created_by_replace':
        return (
          Icons.swap_horiz,
          Colors.indigo,
          l10n.bookingHistoryEventReplaced,
        );
      default:
        return (Icons.info_outline, Colors.grey, eventType);
    }
  }

  /// Genera un titolo specifico per appointment_updated in base ai campi modificati
  String _getAppointmentUpdateTitle(
    Map<String, dynamic> payload,
    dynamic l10n,
  ) {
    final changedFields =
        (payload['changed_fields'] as List<dynamic>?)?.cast<String>() ?? [];

    if (changedFields.isEmpty) {
      return l10n.bookingHistoryEventAppointmentUpdated;
    }

    // Se cambiano pi√π di un tipo di campo, usa titolo generico
    final hasTimeChange =
        changedFields.contains('start_time') ||
        changedFields.contains('end_time');
    final hasStaffChange = changedFields.contains('staff_id');
    final hasPriceChange = changedFields.contains('price');

    final changeCount = [
      hasTimeChange,
      hasStaffChange,
      hasPriceChange,
    ].where((b) => b).length;

    if (changeCount > 1) {
      // Modifiche multiple, usa titolo generico
      return l10n.bookingHistoryEventUpdated;
    }

    // Singola modifica, usa titolo specifico
    if (hasStaffChange) {
      return l10n.bookingHistoryEventStaffChanged;
    }
    if (hasPriceChange) {
      return l10n.bookingHistoryEventPriceChanged;
    }
    if (hasTimeChange) {
      // Determina se √® cambio orario o solo durata
      final before = payload['before'] as Map<String, dynamic>? ?? {};
      final after = payload['after'] as Map<String, dynamic>? ?? {};
      final beforeStart = _parseTime(before['start_time']);
      final afterStart = _parseTime(after['start_time']);

      if (beforeStart != null &&
          afterStart != null &&
          beforeStart != afterStart) {
        return l10n.bookingHistoryEventTimeChanged;
      }
      // Solo end_time cambiato = cambio durata
      return l10n.bookingHistoryEventDurationChanged;
    }

    return l10n.bookingHistoryEventAppointmentUpdated;
  }

  String _getActorLabel(String actorType, dynamic l10n) {
    switch (actorType) {
      case 'staff':
        return l10n.bookingHistoryActorStaff;
      case 'customer':
        return l10n.bookingHistoryActorCustomer;
      case 'system':
        return l10n.bookingHistoryActorSystem;
      default:
        return actorType;
    }
  }
}
--- FILE: lib/features/agenda/presentation/dialogs/recurrence_summary_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/widgets/app_buttons.dart';

/// Risultato dell'anteprima di una serie ricorrente (prima della creazione)
class RecurringPreviewResult {
  final int totalDates;
  final List<PreviewDateItem> dates;

  const RecurringPreviewResult({required this.totalDates, required this.dates});

  factory RecurringPreviewResult.fromJson(Map<String, dynamic> json) {
    final datesList =
        (json['dates'] as List<dynamic>?)
            ?.map((d) => PreviewDateItem.fromJson(d as Map<String, dynamic>))
            .toList() ??
        [];
    return RecurringPreviewResult(
      totalDates: json['total_dates'] as int,
      dates: datesList,
    );
  }
}

/// Singola data nell'anteprima
class PreviewDateItem {
  final int recurrenceIndex;
  final DateTime startTime;
  final DateTime endTime;
  final bool hasConflict;

  const PreviewDateItem({
    required this.recurrenceIndex,
    required this.startTime,
    required this.endTime,
    required this.hasConflict,
  });

  factory PreviewDateItem.fromJson(Map<String, dynamic> json) {
    return PreviewDateItem(
      recurrenceIndex: json['recurrence_index'] as int,
      startTime: DateTime.parse(json['start_time'] as String),
      endTime: DateTime.parse(json['end_time'] as String),
      hasConflict: json['has_conflict'] as bool? ?? false,
    );
  }
}

/// Risultato della creazione di una serie ricorrente
class RecurringBookingResult {
  final int recurrenceRuleId;
  final int createdCount;
  final int skippedCount;
  final List<RecurringBookingItem> bookings;
  final List<SkippedDateItem> skippedDates;

  const RecurringBookingResult({
    required this.recurrenceRuleId,
    required this.createdCount,
    required this.skippedCount,
    required this.bookings,
    required this.skippedDates,
  });

  factory RecurringBookingResult.fromJson(Map<String, dynamic> json) {
    final bookingsList =
        (json['bookings'] as List<dynamic>?)
            ?.map(
              (b) => RecurringBookingItem.fromJson(b as Map<String, dynamic>),
            )
            .toList() ??
        [];
    final skippedList =
        (json['skipped_dates'] as List<dynamic>?)
            ?.map((s) => SkippedDateItem.fromJson(s as Map<String, dynamic>))
            .toList() ??
        [];
    return RecurringBookingResult(
      recurrenceRuleId: json['recurrence_rule_id'] as int,
      createdCount: json['created_count'] as int,
      skippedCount: json['skipped_count'] as int? ?? 0,
      bookings: bookingsList,
      skippedDates: skippedList,
    );
  }
}

class RecurringBookingItem {
  final int id;
  final int recurrenceIndex;
  final DateTime startTime;
  final String status;

  const RecurringBookingItem({
    required this.id,
    required this.recurrenceIndex,
    required this.startTime,
    required this.status,
  });

  factory RecurringBookingItem.fromJson(Map<String, dynamic> json) {
    return RecurringBookingItem(
      id: json['id'] as int,
      recurrenceIndex: json['recurrence_index'] as int,
      startTime: DateTime.parse(json['start_time'] as String),
      status: json['status'] as String? ?? 'confirmed',
    );
  }
}

/// Data saltata per conflitto
class SkippedDateItem {
  final int recurrenceIndex;
  final DateTime startTime;
  final String reason;

  const SkippedDateItem({
    required this.recurrenceIndex,
    required this.startTime,
    required this.reason,
  });

  factory SkippedDateItem.fromJson(Map<String, dynamic> json) {
    return SkippedDateItem(
      recurrenceIndex: json['recurrence_index'] as int,
      startTime: DateTime.parse(json['start_time'] as String),
      reason: json['reason'] as String? ?? 'conflict',
    );
  }
}

/// Dialog che mostra il riepilogo dopo la creazione di una serie ricorrente
class RecurrenceSummaryDialog extends StatefulWidget {
  const RecurrenceSummaryDialog({
    super.key,
    required this.result,
    this.onDeleteBooking,
  });

  final RecurringBookingResult result;
  final Future<bool> Function(int bookingId)? onDeleteBooking;

  static Future<void> show(
    BuildContext context,
    RecurringBookingResult result, {
    Future<bool> Function(int bookingId)? onDeleteBooking,
  }) {
    return showDialog(
      context: context,
      barrierDismissible: false,
      builder: (ctx) => RecurrenceSummaryDialog(
        result: result,
        onDeleteBooking: onDeleteBooking,
      ),
    );
  }

  @override
  State<RecurrenceSummaryDialog> createState() =>
      _RecurrenceSummaryDialogState();
}

class _RecurrenceSummaryDialogState extends State<RecurrenceSummaryDialog> {
  late List<RecurringBookingItem> _activeBookings;
  late List<int> _deletedBookingIds;
  bool _isDeleting = false;

  @override
  void initState() {
    super.initState();
    _activeBookings = List.from(widget.result.bookings);
    _deletedBookingIds = [];
  }

  Future<void> _deleteBooking(RecurringBookingItem booking) async {
    if (_isDeleting || widget.onDeleteBooking == null) return;

    setState(() => _isDeleting = true);

    try {
      final success = await widget.onDeleteBooking!(booking.id);
      if (success && mounted) {
        setState(() {
          _activeBookings.removeWhere((b) => b.id == booking.id);
          _deletedBookingIds.add(booking.id);
        });
      }
    } finally {
      if (mounted) setState(() => _isDeleting = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final dateFormat = DateFormat('EEE dd MMM yyyy', 'it');
    final timeFormat = DateFormat('HH:mm', 'it');

    // Combina tutte le date (create, eliminate, saltate) ordinate per data
    final allDates = <_CombinedDateItem>[];

    // Aggiungi booking attivi
    for (final booking in _activeBookings) {
      allDates.add(
        _CombinedDateItem(
          recurrenceIndex: booking.recurrenceIndex,
          startTime: booking.startTime,
          type: _DateType.created,
          bookingId: booking.id,
        ),
      );
    }

    // Aggiungi booking eliminati (mostrati come disabilitati)
    for (final booking in widget.result.bookings) {
      if (_deletedBookingIds.contains(booking.id)) {
        allDates.add(
          _CombinedDateItem(
            recurrenceIndex: booking.recurrenceIndex,
            startTime: booking.startTime,
            type: _DateType.deleted,
          ),
        );
      }
    }

    // Aggiungi date saltate
    for (final skipped in widget.result.skippedDates) {
      allDates.add(
        _CombinedDateItem(
          recurrenceIndex: skipped.recurrenceIndex,
          startTime: skipped.startTime,
          type: _DateType.skipped,
        ),
      );
    }

    // Ordina per recurrence_index
    allDates.sort((a, b) => a.recurrenceIndex.compareTo(b.recurrenceIndex));

    return AlertDialog(
      title: Row(
        children: [
          Icon(Icons.check_circle, color: theme.colorScheme.primary, size: 28),
          const SizedBox(width: 12),
          Expanded(child: Text(l10n.recurrenceSummaryTitle)),
        ],
      ),
      content: SizedBox(
        width: 400,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Statistiche
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: theme.colorScheme.primaryContainer.withOpacity(0.3),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  Expanded(
                    child: _StatItem(
                      icon: Icons.event_available,
                      value: '${_activeBookings.length}',
                      label: l10n.recurrenceSummaryCreated(
                        _activeBookings.length,
                      ),
                      color: theme.colorScheme.primary,
                    ),
                  ),
                  if (widget.result.skippedCount > 0 ||
                      _deletedBookingIds.isNotEmpty) ...[
                    const SizedBox(width: 16),
                    Expanded(
                      child: _StatItem(
                        icon: Icons.event_busy,
                        value:
                            '${widget.result.skippedCount + _deletedBookingIds.length}',
                        label: l10n.recurrenceSummarySkipped(
                          widget.result.skippedCount +
                              _deletedBookingIds.length,
                        ),
                        color: theme.colorScheme.error,
                      ),
                    ),
                  ],
                ],
              ),
            ),
            const SizedBox(height: 16),

            // Lista tutte le date
            Text(
              l10n.recurrenceSummaryAppointments,
              style: theme.textTheme.titleSmall,
            ),
            const SizedBox(height: 8),
            ConstrainedBox(
              constraints: const BoxConstraints(maxHeight: 300),
              child: ListView.builder(
                shrinkWrap: true,
                itemCount: allDates.length,
                itemBuilder: (ctx, index) {
                  final item = allDates[index];
                  final isDisabled =
                      item.type == _DateType.skipped ||
                      item.type == _DateType.deleted;

                  return Opacity(
                    opacity: isDisabled ? 0.5 : 1.0,
                    child: ListTile(
                      dense: true,
                      contentPadding: EdgeInsets.zero,
                      leading: CircleAvatar(
                        radius: 14,
                        backgroundColor: isDisabled
                            ? theme.colorScheme.surfaceContainerHighest
                            : theme.colorScheme.primaryContainer,
                        child: isDisabled
                            ? Icon(
                                item.type == _DateType.skipped
                                    ? Icons.block
                                    : Icons.delete_outline,
                                size: 14,
                                color: theme.colorScheme.onSurfaceVariant,
                              )
                            : Text(
                                '${index + 1}',
                                style: theme.textTheme.labelSmall?.copyWith(
                                  color: theme.colorScheme.onPrimaryContainer,
                                ),
                              ),
                      ),
                      title: Text(
                        dateFormat.format(item.startTime),
                        style: theme.textTheme.bodyMedium?.copyWith(
                          decoration: isDisabled
                              ? TextDecoration.lineThrough
                              : null,
                          color: isDisabled
                              ? theme.colorScheme.onSurfaceVariant
                              : null,
                        ),
                      ),
                      subtitle: isDisabled
                          ? Text(
                              item.type == _DateType.skipped
                                  ? l10n.recurrenceSummaryConflict
                                  : l10n.recurrenceSummaryDeleted,
                              style: theme.textTheme.labelSmall?.copyWith(
                                color: theme.colorScheme.error,
                              ),
                            )
                          : null,
                      trailing: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text(
                            timeFormat.format(item.startTime),
                            style: theme.textTheme.bodyMedium?.copyWith(
                              color: isDisabled
                                  ? theme.colorScheme.onSurfaceVariant
                                  : theme.colorScheme.primary,
                              fontWeight: isDisabled ? null : FontWeight.w600,
                            ),
                          ),
                          if (!isDisabled &&
                              widget.onDeleteBooking != null) ...[
                            const SizedBox(width: 8),
                            IconButton(
                              icon: Icon(
                                Icons.delete_outline,
                                size: 20,
                                color: theme.colorScheme.error,
                              ),
                              onPressed: _isDeleting
                                  ? null
                                  : () => _deleteBooking(
                                      _activeBookings.firstWhere(
                                        (b) => b.id == item.bookingId,
                                      ),
                                    ),
                              tooltip: l10n.actionDelete,
                              padding: EdgeInsets.zero,
                              constraints: const BoxConstraints(
                                minWidth: 32,
                                minHeight: 32,
                              ),
                            ),
                          ],
                        ],
                      ),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
      actions: [
        AppFilledButton(
          onPressed: () => Navigator.of(context).pop(),
          child: Text(l10n.actionClose),
        ),
      ],
    );
  }
}

class _StatItem extends StatelessWidget {
  const _StatItem({
    required this.icon,
    required this.value,
    required this.label,
    required this.color,
  });

  final IconData icon;
  final String value;
  final String label;
  final Color color;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Column(
      children: [
        Icon(icon, color: color, size: 24),
        const SizedBox(height: 4),
        Text(
          value,
          style: theme.textTheme.headlineSmall?.copyWith(
            color: color,
            fontWeight: FontWeight.bold,
          ),
        ),
        Text(
          label,
          style: theme.textTheme.labelSmall?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
          textAlign: TextAlign.center,
        ),
      ],
    );
  }
}

enum _DateType { created, skipped, deleted }

class _CombinedDateItem {
  final int recurrenceIndex;
  final DateTime startTime;
  final _DateType type;
  final int? bookingId;

  const _CombinedDateItem({
    required this.recurrenceIndex,
    required this.startTime,
    required this.type,
    this.bookingId,
  });
}

/// Dialog che mostra l'ANTEPRIMA delle date PRIMA della creazione
/// Permette di escludere date prima di confermare
/// Ritorna la lista degli indici da ESCLUDERE, oppure null se annullato
class RecurrencePreviewDialog extends StatefulWidget {
  const RecurrencePreviewDialog({
    super.key,
    required this.preview,
    this.titleText,
    this.hintText,
    this.confirmLabelBuilder,
    this.excludeConflictsByDefault = true,
  });

  final RecurringPreviewResult preview;
  final String? titleText;
  final String? hintText;
  final String Function(int count)? confirmLabelBuilder;
  final bool excludeConflictsByDefault;

  /// Mostra il dialog e ritorna la lista degli indici da escludere.
  /// Ritorna null se l'utente annulla.
  static Future<List<int>?> show(
    BuildContext context,
    RecurringPreviewResult preview, {
    String? titleText,
    String? hintText,
    String Function(int count)? confirmLabelBuilder,
    bool excludeConflictsByDefault = true,
  }) async {
    return showDialog<List<int>>(
      context: context,
      barrierDismissible: false,
      builder: (ctx) => RecurrencePreviewDialog(
        preview: preview,
        titleText: titleText,
        hintText: hintText,
        confirmLabelBuilder: confirmLabelBuilder,
        excludeConflictsByDefault: excludeConflictsByDefault,
      ),
    );
  }

  @override
  State<RecurrencePreviewDialog> createState() =>
      _RecurrencePreviewDialogState();
}

class _RecurrencePreviewDialogState extends State<RecurrencePreviewDialog> {
  late Set<int> _excludedIndices;

  @override
  void initState() {
    super.initState();
    _excludedIndices = widget.excludeConflictsByDefault
        ? widget.preview.dates
              .where((d) => d.hasConflict)
              .map((d) => d.recurrenceIndex)
              .toSet()
        : <int>{};
  }

  void _toggleDate(int index) {
    setState(() {
      if (_excludedIndices.contains(index)) {
        _excludedIndices.remove(index);
      } else {
        _excludedIndices.add(index);
      }
    });
  }

  void _confirm() {
    final selectedCount = widget.preview.dates.length - _excludedIndices.length;
    if (selectedCount == 0) {
      return; // Non permettere creazione senza date selezionate
    }
    Navigator.of(context).pop(_excludedIndices.toList());
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final dateFormat = DateFormat('EEE dd MMM yyyy', 'it');
    final timeFormat = DateFormat('HH:mm', 'it');

    final selectedCount = widget.preview.dates.length - _excludedIndices.length;
    final conflictCount = widget.preview.dates
        .where((d) => d.hasConflict)
        .length;

    return AlertDialog(
      title: Row(
        children: [
          Icon(Icons.preview, color: theme.colorScheme.primary, size: 28),
          const SizedBox(width: 12),
          Expanded(child: Text(widget.titleText ?? l10n.recurrencePreviewTitle)),
        ],
      ),
      content: SizedBox(
        width: 450,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Statistiche
            Container(
              padding: const EdgeInsets.all(12),
              decoration: BoxDecoration(
                color: theme.colorScheme.primaryContainer.withOpacity(0.3),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  Expanded(
                    child: _StatItem(
                      icon: Icons.event_available,
                      value: '$selectedCount',
                      label: l10n.recurrencePreviewSelected(selectedCount),
                      color: theme.colorScheme.primary,
                    ),
                  ),
                  if (conflictCount > 0) ...[
                    const SizedBox(width: 16),
                    Expanded(
                      child: _StatItem(
                        icon: Icons.warning_amber,
                        value: '$conflictCount',
                        label: l10n.recurrencePreviewConflicts(conflictCount),
                        color: theme.colorScheme.error,
                      ),
                    ),
                  ],
                ],
              ),
            ),
            const SizedBox(height: 16),

            // Hint per escludere date
            Text(
              widget.hintText ?? l10n.recurrencePreviewHint,
              style: theme.textTheme.bodySmall?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
            ),
            const SizedBox(height: 8),

            // Lista date con checkbox
            ConstrainedBox(
              constraints: const BoxConstraints(maxHeight: 300),
              child: ListView.builder(
                shrinkWrap: true,
                itemCount: widget.preview.dates.length,
                itemBuilder: (ctx, index) {
                  final date = widget.preview.dates[index];
                  final isExcluded = _excludedIndices.contains(
                    date.recurrenceIndex,
                  );
                  final hasConflict = date.hasConflict;

                  return CheckboxListTile(
                    dense: true,
                    contentPadding: EdgeInsets.zero,
                    controlAffinity: ListTileControlAffinity.leading,
                    value: !isExcluded,
                    onChanged: (val) => _toggleDate(date.recurrenceIndex),
                    secondary: hasConflict
                        ? Tooltip(
                            message: l10n.recurrenceSummaryConflict,
                            child: Icon(
                              Icons.warning_amber,
                              color: theme.colorScheme.error,
                              size: 20,
                            ),
                          )
                        : null,
                    title: Text(
                      dateFormat.format(date.startTime),
                      style: theme.textTheme.bodyMedium?.copyWith(
                        decoration: isExcluded
                            ? TextDecoration.lineThrough
                            : null,
                        color: isExcluded
                            ? theme.colorScheme.onSurfaceVariant
                            : null,
                      ),
                    ),
                    subtitle: hasConflict
                        ? Text(
                            isExcluded
                                ? l10n.recurrencePreviewConflictSkip
                                : l10n.recurrencePreviewConflictForce,
                            style: theme.textTheme.labelSmall?.copyWith(
                              color: isExcluded
                                  ? theme.colorScheme.error
                                  : theme.colorScheme.primary,
                            ),
                          )
                        : Text(
                            timeFormat.format(date.startTime),
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: isExcluded
                                  ? theme.colorScheme.onSurfaceVariant
                                  : theme.colorScheme.primary,
                              fontWeight: isExcluded ? null : FontWeight.w600,
                            ),
                          ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(null),
          child: Text(l10n.actionCancel),
        ),
        const SizedBox(width: 8),
        FilledButton(
          onPressed: selectedCount > 0 ? _confirm : null,
          child: Text(
            widget.confirmLabelBuilder?.call(selectedCount) ??
                l10n.recurrencePreviewConfirm(selectedCount),
          ),
        ),
      ],
    );
  }
}
--- FILE: lib/features/agenda/presentation/dialogs/recurring_action_dialog.dart ---
import 'package:flutter/material.dart';

import '../../../../core/l10n/l10_extension.dart';

/// Enum che rappresenta lo scope dell'azione su una serie ricorrente
enum RecurringActionScope {
  /// Solo questo appuntamento
  single,

  /// Questo appuntamento e tutti i futuri nella serie
  thisAndFuture,

  /// Tutti gli appuntamenti nella serie
  all,
}

/// Risultato del dialog per la cancellazione di una prenotazione ricorrente
class RecurringDeleteResult {
  final RecurringActionScope scope;

  const RecurringDeleteResult({required this.scope});
}

/// Risultato del dialog per la modifica di una prenotazione ricorrente
class RecurringEditResult {
  final RecurringActionScope scope;

  const RecurringEditResult({required this.scope});
}

/// Dialog che chiede all'utente come procedere con la cancellazione
/// di una prenotazione che fa parte di una serie ricorrente.
Future<RecurringDeleteResult?> showRecurringDeleteDialog(
  BuildContext context, {
  required int currentIndex,
  required int totalCount,
}) async {
  return showDialog<RecurringDeleteResult>(
    context: context,
    builder: (context) => _RecurringDeleteDialog(
      currentIndex: currentIndex,
      totalCount: totalCount,
    ),
  );
}

/// Dialog che chiede all'utente come procedere con la modifica
/// di una prenotazione che fa parte di una serie ricorrente.
Future<RecurringEditResult?> showRecurringEditDialog(
  BuildContext context, {
  required int currentIndex,
  required int totalCount,
}) async {
  return showDialog<RecurringEditResult>(
    context: context,
    builder: (context) => _RecurringEditDialog(
      currentIndex: currentIndex,
      totalCount: totalCount,
    ),
  );
}

class _RecurringDeleteDialog extends StatelessWidget {
  final int currentIndex;
  final int totalCount;

  const _RecurringDeleteDialog({
    required this.currentIndex,
    required this.totalCount,
  });

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return AlertDialog(
      title: Row(
        children: [
          Icon(Icons.repeat, color: theme.colorScheme.primary),
          const SizedBox(width: 8),
          Expanded(child: Text(l10n.recurringDeleteTitle)),
        ],
      ),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            l10n.recurringDeleteMessage(currentIndex, totalCount),
            style: theme.textTheme.bodyMedium,
          ),
          const SizedBox(height: 16),
          Text(
            l10n.recurringDeleteChooseScope,
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: Text(l10n.actionCancel),
        ),
        TextButton(
          onPressed: () => Navigator.pop(
            context,
            const RecurringDeleteResult(scope: RecurringActionScope.single),
          ),
          child: Text(l10n.recurringScopeOnlyThis),
        ),
        if (currentIndex < totalCount)
          TextButton(
            onPressed: () => Navigator.pop(
              context,
              const RecurringDeleteResult(
                scope: RecurringActionScope.thisAndFuture,
              ),
            ),
            child: Text(l10n.recurringScopeThisAndFuture),
          ),
        FilledButton(
          style: FilledButton.styleFrom(
            backgroundColor: theme.colorScheme.error,
          ),
          onPressed: () => Navigator.pop(
            context,
            const RecurringDeleteResult(scope: RecurringActionScope.all),
          ),
          child: Text(l10n.recurringScopeAll),
        ),
      ],
    );
  }
}

class _RecurringEditDialog extends StatelessWidget {
  final int currentIndex;
  final int totalCount;

  const _RecurringEditDialog({
    required this.currentIndex,
    required this.totalCount,
  });

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return AlertDialog(
      title: Row(
        children: [
          Icon(Icons.repeat, color: theme.colorScheme.primary),
          const SizedBox(width: 8),
          Expanded(child: Text(l10n.recurringEditTitle)),
        ],
      ),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            l10n.recurringEditMessage(currentIndex, totalCount),
            style: theme.textTheme.bodyMedium,
          ),
          const SizedBox(height: 16),
          Text(
            l10n.recurringEditChooseScope,
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context),
          child: Text(l10n.actionCancel),
        ),
        TextButton(
          onPressed: () => Navigator.pop(
            context,
            const RecurringEditResult(scope: RecurringActionScope.single),
          ),
          child: Text(l10n.recurringScopeOnlyThis),
        ),
        if (currentIndex < totalCount)
          FilledButton(
            onPressed: () => Navigator.pop(
              context,
              const RecurringEditResult(
                scope: RecurringActionScope.thisAndFuture,
              ),
            ),
            child: Text(l10n.recurringScopeThisAndFuture),
          ),
      ],
    );
  }
}
--- FILE: lib/features/agenda/presentation/dialogs/add_block_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:agenda_backend/core/widgets/app_bottom_sheet.dart';
import 'package:agenda_backend/core/widgets/labeled_form_field.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/date_time_formats.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/recurrence_rule.dart';
import '../../../../core/models/time_block.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/app_switch.dart';
import '../../../../core/widgets/local_loading_overlay.dart';
import '../../../auth/providers/current_business_user_provider.dart';
import '../../domain/config/layout_config.dart';
import '../../providers/date_range_provider.dart';
import '../../providers/time_blocks_provider.dart';
import '../widgets/recurrence_picker.dart';

/// Mostra il dialog per creare o modificare un blocco di non disponibilit√†.
Future<void> showAddBlockDialog(
  BuildContext context,
  WidgetRef ref, {
  TimeBlock? initial,
  DateTime? date,
  TimeOfDay? time,
  int? initialStaffId,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final isDesktop = formFactor == AppFormFactor.desktop;

  final dialog = _AddBlockDialog(
    initial: initial,
    initialDate: date,
    initialTime: time,
    initialStaffId: initialStaffId,
    presentation: isDesktop
        ? _BlockDialogPresentation.dialog
        : _BlockDialogPresentation.bottomSheet,
  );

  if (isDesktop) {
    await showDialog(context: context, builder: (_) => dialog);
  } else {
    await AppBottomSheet.show(
      context: context,
      useRootNavigator: true,
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 20),
      builder: (_) => dialog,
    );
  }
}

enum _BlockDialogPresentation { dialog, bottomSheet }

class _AddBlockDialog extends ConsumerStatefulWidget {
  const _AddBlockDialog({
    this.initial,
    this.initialDate,
    this.initialTime,
    this.initialStaffId,
    required this.presentation,
  });

  final TimeBlock? initial;
  final DateTime? initialDate;
  final TimeOfDay? initialTime;
  final int? initialStaffId;
  final _BlockDialogPresentation presentation;

  @override
  ConsumerState<_AddBlockDialog> createState() => _AddBlockDialogState();
}

class _AddBlockDialogState extends ConsumerState<_AddBlockDialog> {
  static const int _timePickerStepMinutes = 5;

  late DateTime _date;
  late TimeOfDay _startTime;
  late TimeOfDay _endTime;
  late Set<int> _selectedStaffIds;
  final _reasonController = TextEditingController();
  final ScrollController _staffScrollController = ScrollController();
  bool _isAllDay = false;
  RecurrenceConfig? _recurrenceConfig;
  String? _staffError;
  String? _timeError;
  bool _isSaving = false;

  @override
  void initState() {
    super.initState();
    final agendaDate = ref.read(agendaDateProvider);

    if (widget.initial != null) {
      final block = widget.initial!;
      _date = DateTime(
        block.startTime.year,
        block.startTime.month,
        block.startTime.day,
      );
      _startTime = TimeOfDay(
        hour: block.startTime.hour,
        minute: block.startTime.minute,
      );
      _endTime = TimeOfDay(
        hour: block.endTime.hour,
        minute: block.endTime.minute,
      );
      _selectedStaffIds = Set.from(block.staffIds);
      _reasonController.text = block.reason ?? '';
      _isAllDay = block.isAllDay;
    } else {
      _date = DateUtils.dateOnly(widget.initialDate ?? agendaDate);
      _startTime = widget.initialTime ?? const TimeOfDay(hour: 10, minute: 0);
      _endTime = TimeOfDay(
        hour: _startTime.hour + 1,
        minute: _startTime.minute,
      );
      _selectedStaffIds = widget.initialStaffId != null
          ? {widget.initialStaffId!}
          : {};
    }

    final role = ref.read(currentUserRoleProvider);
    final staffId = ref.read(currentUserStaffIdProvider);
    if (role == 'staff' && staffId != null && staffId > 0) {
      _selectedStaffIds = {staffId};
    }
  }

  @override
  void dispose() {
    _reasonController.dispose();
    _staffScrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final isEdit = widget.initial != null;
    final staff = ref.watch(staffForCurrentLocationProvider);
    final currentUserRole = ref.watch(currentUserRoleProvider);
    final currentUserStaffId = ref.watch(currentUserStaffIdProvider);
    final isStaffRole =
        currentUserRole == 'staff' &&
        currentUserStaffId != null &&
        currentUserStaffId > 0;
    final visibleStaff = isStaffRole
        ? staff.where((s) => s.id == currentUserStaffId).toList()
        : staff;
    final isDialog = widget.presentation == _BlockDialogPresentation.dialog;

    final title = isEdit ? l10n.blockDialogTitleEdit : l10n.blockDialogTitleNew;
    final content = Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Data
        LabeledFormField(
          label: l10n.formDate,
          child: InkWell(
            onTap: _pickDate,
            child: InputDecorator(
              decoration: const InputDecoration(
                border: OutlineInputBorder(),
                isDense: true,
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    '${_date.day.toString().padLeft(2, '0')}/${_date.month.toString().padLeft(2, '0')}/${_date.year}',
                  ),
                  const Icon(Icons.calendar_today, size: 16),
                ],
              ),
            ),
          ),
        ),
        const SizedBox(height: 12),

        // Giornata intera switch
        Row(
          children: [
            AppSwitch(
              value: _isAllDay,
              onChanged: (v) => setState(() => _isAllDay = v),
            ),
            const SizedBox(width: 8),
            Text(l10n.blockAllDay),
          ],
        ),
        const SizedBox(height: 12),

        // Orari
        if (!_isAllDay) ...[
          Row(
            children: [
              Expanded(
                child: LabeledFormField(
                  label: l10n.blockStartTime,
                  child: InkWell(
                    onTap: () => _pickTime(isStart: true),
                    child: InputDecorator(
                      decoration: InputDecoration(
                        border: const OutlineInputBorder(),
                        isDense: true,
                        errorText: null,
                        enabledBorder: _timeError != null
                            ? OutlineInputBorder(
                                borderSide: BorderSide(
                                  color: Theme.of(context).colorScheme.error,
                                ),
                              )
                            : null,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_startTime.format(context)),
                          const Icon(Icons.schedule, size: 16),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: LabeledFormField(
                  label: l10n.blockEndTime,
                  child: InkWell(
                    onTap: () => _pickTime(isStart: false),
                    child: InputDecorator(
                      decoration: InputDecoration(
                        border: const OutlineInputBorder(),
                        isDense: true,
                        enabledBorder: _timeError != null
                            ? OutlineInputBorder(
                                borderSide: BorderSide(
                                  color: Theme.of(context).colorScheme.error,
                                ),
                              )
                            : null,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_endTime.format(context)),
                          const Icon(Icons.schedule, size: 16),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
          if (_timeError != null)
            Padding(
              padding: const EdgeInsets.only(top: 6, left: 12),
              child: Text(
                _timeError!,
                style: TextStyle(
                  color: Theme.of(context).colorScheme.error,
                  fontSize: 12,
                ),
              ),
            ),
          const SizedBox(height: 12),
        ],

        // Staff selection
        LabeledFormField(
          label: l10n.blockSelectStaff,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(
                decoration: BoxDecoration(
                  border: Border.all(
                    color: _staffError != null
                        ? Theme.of(context).colorScheme.error
                        : Theme.of(context).dividerColor,
                  ),
                  borderRadius: BorderRadius.circular(4),
                ),
                constraints: const BoxConstraints(maxHeight: 200),
                child: Scrollbar(
                  controller: _staffScrollController,
                  thumbVisibility: visibleStaff.length * 48.0 > 200,
                  child: ListView.builder(
                    controller: _staffScrollController,
                    shrinkWrap: true,
                    itemCount: visibleStaff.length,
                    itemBuilder: (context, index) {
                      final member = visibleStaff[index];
                      final isSelected = _selectedStaffIds.contains(member.id);
                      return CheckboxListTile(
                        value: isSelected,
                        onChanged: isStaffRole
                            ? null
                            : (v) {
                                setState(() {
                                  _staffError = null;
                                  if (v == true) {
                                    _selectedStaffIds.add(member.id);
                                  } else {
                                    _selectedStaffIds.remove(member.id);
                                  }
                                });
                              },
                        title: Text(member.name),
                        secondary: StaffCircleAvatar(
                          height: 24,
                          color: member.color,
                          isHighlighted: _selectedStaffIds.contains(member.id),
                          initials: member.initials,
                        ),
                        dense: true,
                        controlAffinity: ListTileControlAffinity.leading,
                      );
                    },
                  ),
                ),
              ),
              if (_staffError != null)
                Padding(
                  padding: const EdgeInsets.only(top: 6, left: 12),
                  child: Text(
                    _staffError!,
                    style: TextStyle(
                      color: Theme.of(context).colorScheme.error,
                      fontSize: 12,
                    ),
                  ),
                ),
            ],
          ),
        ),
        const SizedBox(height: 12),

        // Motivo opzionale
        LabeledFormField(
          label: l10n.blockReason,
          child: TextField(
            controller: _reasonController,
            decoration: InputDecoration(
              hintText: l10n.blockReasonHint,
              border: const OutlineInputBorder(),
              isDense: true,
            ),
          ),
        ),
        if (!isEdit) ...[
          const SizedBox(height: 12),
          RecurrencePicker(
            startDate: _date,
            initialConfig: _recurrenceConfig,
            title: l10n.recurrenceRepeatBlock,
            showConflictHandling: false,
            onChanged: (config) {
              setState(() => _recurrenceConfig = config);
            },
          ),
        ],
      ],
    );

    final actions = [
      if (isEdit)
        AppAsyncDangerButton(
          onPressed: _isSaving ? null : _onDelete,
          padding: AppButtonStyles.dialogButtonPadding,
          disabled: _isSaving,
          showSpinner: false,
          child: Text(l10n.actionDelete),
        ),
      AppOutlinedActionButton(
        onPressed: _isSaving ? null : () => Navigator.of(context).pop(),
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppAsyncFilledButton(
        onPressed: _isSaving ? null : _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        isLoading: _isSaving,
        showSpinner: false,
        child: Text(l10n.actionSave),
      ),
    ];

    final bottomActions = actions
        .map(
          (a) => SizedBox(width: AppButtonStyles.dialogButtonWidth, child: a),
        )
        .toList();

    if (isDialog) {
      return DismissibleDialog(
        child: Dialog(
          insetPadding: const EdgeInsets.symmetric(
            horizontal: 32,
            vertical: 24,
          ),
          child: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
            child: LocalLoadingOverlay(
              isLoading: _isSaving,
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Text(
                      title,
                      style: Theme.of(context).textTheme.headlineSmall,
                    ),
                    const SizedBox(height: 16),
                    Flexible(child: SingleChildScrollView(child: content)),
                    const SizedBox(height: 24),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        if (isEdit) ...[
                          bottomActions.first, // Delete button
                          const Spacer(),
                          bottomActions[1], // Cancel button
                        ] else
                          bottomActions[0], // Cancel button
                        const SizedBox(width: 8),
                        bottomActions.last, // Save button
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      );
    }

    return SafeArea(
      top: false,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final isKeyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
          return LocalLoadingOverlay(
            isLoading: _isSaving,
            child: SizedBox(
              height: constraints.maxHeight,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Expanded(
                    child: SingleChildScrollView(
                      padding: EdgeInsets.only(bottom: 0),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Padding(
                            padding: const EdgeInsets.only(bottom: 12),
                            child: Text(
                              title,
                              style: Theme.of(context).textTheme.titleLarge,
                            ),
                          ),
                          content,
                          const SizedBox(height: 24),
                          const SizedBox(height: AppSpacing.formRowSpacing),
                        ],
                      ),
                    ),
                  ),
                  if (!isKeyboardOpen) ...[
                    const AppDivider(),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(0, 12, 0, 0),
                      child: Align(
                        alignment: bottomActions.length == 3
                            ? Alignment.center
                            : Alignment.centerRight,
                        child: Wrap(
                          alignment: bottomActions.length == 3
                              ? WrapAlignment.center
                              : WrapAlignment.end,
                          spacing: 8,
                          runSpacing: 8,
                          children: bottomActions,
                        ),
                      ),
                    ),
                  ],
                  SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  Future<void> _pickDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _date,
      firstDate: DateTime.now().subtract(const Duration(days: 365)),
      lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
    );
    if (picked != null) {
      setState(() => _date = DateUtils.dateOnly(picked));
    }
  }

  Future<void> _pickTime({required bool isStart}) async {
    final l10n = context.l10n;
    final selected = await AppBottomSheet.show<TimeOfDay>(
      context: context,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      builder: (ctx) {
        final height = MediaQuery.of(ctx).size.height * 0.9;
        return SizedBox(
          height: height,
          child: _TimeGridPicker(
            initial: isStart ? _startTime : _endTime,
            stepMinutes: _timePickerStepMinutes,
            title: isStart ? l10n.blockStartTime : l10n.blockEndTime,
          ),
        );
      },
    );
    if (selected != null) {
      setState(() {
        _timeError = null; // Reset errore quando l'utente modifica
        if (isStart) {
          _startTime = selected;
          // Aggiusta automaticamente l'end time se necessario
          final startMinutes = _startTime.hour * 60 + _startTime.minute;
          final endMinutes = _endTime.hour * 60 + _endTime.minute;
          if (endMinutes <= startMinutes) {
            _endTime = TimeOfDay(
              hour: (_startTime.hour + 1) % 24,
              minute: _startTime.minute,
            );
          }
        } else {
          _endTime = selected;
        }
      });
    }
  }

  Future<void> _onSave() async {
    final l10n = context.l10n;
    final role = ref.read(currentUserRoleProvider);
    final staffId = ref.read(currentUserStaffIdProvider);
    if (role == 'staff' && staffId != null && staffId > 0) {
      _selectedStaffIds = {staffId};
    }
    bool hasError = false;

    // Reset errori
    setState(() {
      _staffError = null;
      _timeError = null;
    });

    if (_selectedStaffIds.isEmpty) {
      setState(() => _staffError = l10n.blockSelectStaffError);
      hasError = true;
    }

    // Validazione orari
    if (!_isAllDay) {
      final startMinutes = _startTime.hour * 60 + _startTime.minute;
      final endMinutes = _endTime.hour * 60 + _endTime.minute;
      if (endMinutes <= startMinutes) {
        setState(() => _timeError = l10n.blockTimeError);
        hasError = true;
      }
    }

    if (hasError) return;

    setState(() => _isSaving = true);
    try {
      final DateTime startDateTime;
      final DateTime endDateTime;

      if (_isAllDay) {
        // Per blocchi giornata intera, usa l'intera giornata lavorativa
        startDateTime = DateTime(_date.year, _date.month, _date.day, 0, 0);
        endDateTime = DateTime(_date.year, _date.month, _date.day, 23, 59);
      } else {
        startDateTime = DateTime(
          _date.year,
          _date.month,
          _date.day,
          _startTime.hour,
          _startTime.minute,
        );
        endDateTime = DateTime(
          _date.year,
          _date.month,
          _date.day,
          _endTime.hour,
          _endTime.minute,
        );
      }

      final reason = _reasonController.text.trim().isEmpty
          ? null
          : _reasonController.text.trim();

      if (widget.initial == null) {
        if (_recurrenceConfig != null) {
          await ref
              .read(timeBlocksProvider.notifier)
              .addRecurringBlocks(
                staffIds: _selectedStaffIds.toList(),
                startTime: startDateTime,
                endTime: endDateTime,
                recurrence: _recurrenceConfig!,
                reason: reason,
                isAllDay: _isAllDay,
              );
        } else {
          // Nuovo blocco singolo
          await ref
              .read(timeBlocksProvider.notifier)
              .addBlock(
                staffIds: _selectedStaffIds.toList(),
                startTime: startDateTime,
                endTime: endDateTime,
                reason: reason,
                isAllDay: _isAllDay,
              );
        }
      } else {
        // Aggiorna blocco esistente
        await ref
            .read(timeBlocksProvider.notifier)
            .updateBlock(
              blockId: widget.initial!.id,
              staffIds: _selectedStaffIds.toList(),
              startTime: startDateTime,
              endTime: endDateTime,
              reason: reason,
              isAllDay: _isAllDay,
            );
      }

      if (!mounted) return;
      Navigator.of(context).pop();
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }

  Future<void> _onDelete() async {
    if (widget.initial != null) {
      setState(() => _isSaving = true);
      try {
        await ref
            .read(timeBlocksProvider.notifier)
            .deleteBlock(widget.initial!.id);
        if (!mounted) return;
        Navigator.of(context).pop();
      } finally {
        if (mounted) setState(() => _isSaving = false);
      }
    }
  }
}

class _TimeGridPicker extends StatefulWidget {
  const _TimeGridPicker({
    required this.initial,
    required this.stepMinutes,
    required this.title,
  });
  final TimeOfDay initial;
  final int stepMinutes;
  final String title;

  @override
  State<_TimeGridPicker> createState() => _TimeGridPickerState();
}

class _TimeGridPickerState extends State<_TimeGridPicker> {
  late final ScrollController _scrollController;
  late final List<TimeOfDay?> _entries;
  late final int _scrollToIndex;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();

    // Genera la lista degli orari con 4 colonne per riga
    _entries = <TimeOfDay?>[];
    for (int m = 0; m < LayoutConfig.hoursInDay * 60; m += widget.stepMinutes) {
      final h = m ~/ 60;
      final mm = m % 60;
      _entries.add(TimeOfDay(hour: h, minute: mm));
    }

    // Verifica se l'orario iniziale √® gi√† nella lista
    int exactIndex = _entries.indexWhere(
      (t) =>
          t != null &&
          t.hour == widget.initial.hour &&
          t.minute == widget.initial.minute,
    );

    if (exactIndex >= 0) {
      // L'orario √® gi√† presente
      _scrollToIndex = exactIndex;
    } else {
      // L'orario non √® presente: inserisci una NUOVA RIGA con l'orario
      // nella colonna corretta e le altre colonne vuote
      final columnsPerRow = 60 ~/ widget.stepMinutes;
      final targetColumn = widget.initial.minute ~/ widget.stepMinutes;
      final baseIndex = (widget.initial.hour + 1) * columnsPerRow;

      // Crea la nuova riga con 4 elementi (solo uno valorizzato)
      final newRow = List<TimeOfDay?>.filled(columnsPerRow, null);
      newRow[targetColumn] = widget.initial;

      // Inserisci la nuova riga
      final insertIndex = baseIndex.clamp(0, _entries.length);
      _entries.insertAll(insertIndex, newRow);

      // L'indice dell'orario selezionato √® la posizione nella nuova riga
      _scrollToIndex = insertIndex + targetColumn;
    }

    // Scroll all'orario dopo il primo frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _scrollToSelected();
    });
  }

  void _scrollToSelected() {
    if (!_scrollController.hasClients) return;

    const crossAxisCount = 4;
    const mainAxisSpacing = 6.0;
    const childAspectRatio = 2.7;
    const padding = 12.0;

    // Usa la larghezza effettiva del context
    final screenWidth = MediaQuery.of(context).size.width;
    final availableWidth = screenWidth - padding * 2;
    final itemWidth =
        (availableWidth - (crossAxisCount - 1) * 6) / crossAxisCount;
    final itemHeight = itemWidth / childAspectRatio;
    final rowHeight = itemHeight + mainAxisSpacing;

    // Calcola la riga dell'elemento target
    final targetRow = _scrollToIndex ~/ crossAxisCount;

    // Calcola l'offset per centrare la riga target
    final viewportHeight = _scrollController.position.viewportDimension;
    // Offset aggiuntivo per centrare meglio (compensa header visivo)
    const headerOffset = 40.0;
    final targetOffset =
        (targetRow * rowHeight) -
        (viewportHeight / 2) +
        (rowHeight / 2) +
        headerOffset;

    // Limita l'offset ai bounds dello scroll
    final maxScroll = _scrollController.position.maxScrollExtent;
    final clampedOffset = targetOffset.clamp(0.0, maxScroll);

    _scrollController.animateTo(
      clampedOffset,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeOut,
    );
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          mainAxisSize: MainAxisSize.max,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Icon(Icons.schedule, size: 18),
                const SizedBox(width: 8),
                Text(
                  widget.title,
                  style: const TextStyle(fontWeight: FontWeight.w700),
                ),
              ],
            ),
            const SizedBox(height: 10),
            Expanded(
              child: GridView.builder(
                controller: _scrollController,
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 4,
                  mainAxisSpacing: 6,
                  crossAxisSpacing: 6,
                  childAspectRatio: 2.7,
                ),
                itemCount: _entries.length,
                itemBuilder: (context, index) {
                  final t = _entries[index];
                  // Se la cella √® vuota, mostra uno spazio vuoto
                  if (t == null) {
                    return const SizedBox.shrink();
                  }
                  // Evidenzia l'orario selezionato
                  final isSelected = index == _scrollToIndex;
                  return OutlinedButton(
                    style: OutlinedButton.styleFrom(
                      backgroundColor: isSelected
                          ? Theme.of(
                              context,
                            ).colorScheme.primary.withOpacity(0.1)
                          : null,
                      side: BorderSide(
                        color: isSelected
                            ? Theme.of(context).colorScheme.primary
                            : Theme.of(context).dividerColor,
                      ),
                      padding: const EdgeInsets.symmetric(horizontal: 8),
                    ),
                    onPressed: () => Navigator.pop(context, t),
                    child: Text(_format(context, t)),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }

  String _format(BuildContext ctx, TimeOfDay t) {
    return DtFmt.hm(ctx, t.hour, t.minute);
  }
}
--- FILE: lib/features/agenda/presentation/widgets/recurrence_preview.dart ---
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/recurrence_rule.dart';

/// Widget che mostra un'anteprima delle date ricorrenti calcolate
class RecurrencePreview extends StatelessWidget {
  const RecurrencePreview({
    super.key,
    required this.startDate,
    required this.config,
    this.maxVisible = 6,
  });

  final DateTime startDate;
  final RecurrenceConfig config;
  final int maxVisible;

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final dates = config.calculateOccurrences(startDate);
    final visibleDates = dates.take(maxVisible).toList();
    final hasMore = dates.length > maxVisible;
    final totalCount = config.maxOccurrences ?? dates.length;

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: theme.colorScheme.primaryContainer.withOpacity(0.3),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: theme.colorScheme.primary.withOpacity(0.3)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Row(
            children: [
              Icon(
                Icons.event_repeat,
                size: 18,
                color: theme.colorScheme.primary,
              ),
              const SizedBox(width: 8),
              Text(
                l10n.recurrencePreviewTitle,
                style: theme.textTheme.labelMedium?.copyWith(
                  color: theme.colorScheme.primary,
                  fontWeight: FontWeight.w600,
                ),
              ),
              const Spacer(),
              Text(
                l10n.recurrencePreviewCount(totalCount),
                style: theme.textTheme.labelSmall?.copyWith(
                  color: theme.colorScheme.onSurfaceVariant,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),

          // Date chips
          Wrap(
            spacing: 6,
            runSpacing: 6,
            children: [
              ...visibleDates.asMap().entries.map((entry) {
                final index = entry.key;
                final date = entry.value;
                final isFirst = index == 0;
                return _DateChip(date: date, isFirst: isFirst, theme: theme);
              }),
              if (hasMore)
                Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 8,
                    vertical: 4,
                  ),
                  decoration: BoxDecoration(
                    color: theme.colorScheme.surfaceContainerHighest,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    '+${dates.length - maxVisible}',
                    style: theme.textTheme.labelSmall?.copyWith(
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
                ),
            ],
          ),

          // Riepilogo frequenza
          const SizedBox(height: 8),
          Text(
            config.toReadableString(),
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
              fontStyle: FontStyle.italic,
            ),
          ),
        ],
      ),
    );
  }
}

class _DateChip extends StatelessWidget {
  const _DateChip({
    required this.date,
    required this.isFirst,
    required this.theme,
  });

  final DateTime date;
  final bool isFirst;
  final ThemeData theme;

  @override
  Widget build(BuildContext context) {
    final dateFormat = DateFormat('dd MMM', 'it');
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: isFirst
            ? theme.colorScheme.primary
            : theme.colorScheme.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Text(
        dateFormat.format(date),
        style: theme.textTheme.labelSmall?.copyWith(
          color: isFirst
              ? theme.colorScheme.onPrimary
              : theme.colorScheme.onSurfaceVariant,
          fontWeight: isFirst ? FontWeight.w600 : FontWeight.normal,
        ),
      ),
    );
  }
}

extension on RecurrenceConfig {
  String toReadableString() {
    final interval = intervalValue;
    switch (frequency) {
      case RecurrenceFrequency.daily:
        if (interval == 1) return 'Ogni giorno';
        return 'Ogni $interval giorni';
      case RecurrenceFrequency.weekly:
        if (interval == 1) return 'Ogni settimana';
        return 'Ogni $interval settimane';
      case RecurrenceFrequency.monthly:
        if (interval == 1) return 'Ogni mese';
        return 'Ogni $interval mesi';
      case RecurrenceFrequency.custom:
        return 'Ogni $interval giorni';
    }
  }
}
--- FILE: lib/features/agenda/presentation/widgets/booking_details_overlay.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../providers/bookings_provider.dart';

Future<void> showBookingDetailsOverlay(
  BuildContext context,
  WidgetRef ref, {
  required int bookingId,
}) async {
  await showModalBottomSheet(
    context: context,
    isScrollControlled: true,
    useRootNavigator: true,
    builder: (_) => _BookingDetailsSheet(bookingId: bookingId),
  );
}

class _BookingDetailsSheet extends ConsumerWidget {
  const _BookingDetailsSheet({required this.bookingId});
  final int bookingId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final summary = ref.watch(bookingSummaryProvider(bookingId));
    final isSingleAppointment = summary?.itemsCount == 1;
    final deleteTitle = isSingleAppointment
        ? l10n.deleteAppointmentConfirmTitle
        : l10n.deleteBookingConfirmTitle;
    final deleteMessage = isSingleAppointment
        ? l10n.deleteAppointmentConfirmMessage
        : l10n.deleteBookingConfirmMessage;
    final bookings = ref.watch(bookingsProvider);
    final booking = bookings[bookingId];

    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  l10n.bookingDetails,
                  style: const TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.w700,
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.close),
                  onPressed: () => Navigator.of(context).pop(),
                ),
              ],
            ),
            const SizedBox(height: 12),
            if (summary != null) ...[
              Row(
                children: [
                  Text('${l10n.bookingItems}: '),
                  Text(
                    '${summary.itemsCount}',
                    style: const TextStyle(fontWeight: FontWeight.w600),
                  ),
                  const SizedBox(width: 16),
                  Text('${l10n.bookingTotal}: '),
                  Text(
                    '${summary.totalPrice.toStringAsFixed(2)}‚Ç¨',
                    style: const TextStyle(fontWeight: FontWeight.w600),
                  ),
                ],
              ),
            ],
            const SizedBox(height: 12),
            Text(
              l10n.bookingNotes,
              style: const TextStyle(fontWeight: FontWeight.w600),
            ),
            const SizedBox(height: 6),
            TextFormField(
              initialValue: booking?.notes ?? '',
              maxLines: 3,
              decoration: const InputDecoration(
                border: OutlineInputBorder(),
                isDense: true,
              ),
              onChanged: (v) => ref
                  .read(bookingsProvider.notifier)
                  .setNotes(bookingId, v.trim().isEmpty ? null : v),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () async {
                      final confirmed = await showDialog<bool>(
                        context: context,
                        builder: (_) => AlertDialog(
                          title: Text(deleteTitle),
                          content: Text(deleteMessage),
                          actions: [
                            TextButton(
                              onPressed: () => Navigator.pop(context, false),
                              child: Text(l10n.actionCancel),
                            ),
                            TextButton(
                              onPressed: () => Navigator.pop(context, true),
                              child: Text(l10n.actionDeleteBooking),
                            ),
                          ],
                        ),
                      );
                      if (confirmed == true) {
                        await ref
                            .read(bookingsProvider.notifier)
                            .deleteBooking(bookingId);
                        if (context.mounted) Navigator.of(context).pop();
                      }
                    },
                    child: Text(l10n.actionDeleteBooking),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 10),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/widgets/service_package_picker_dialog.dart ---
import 'package:flutter/material.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service_package.dart';

Future<ServicePackage?> showServicePackagePickerDialog(
  BuildContext context, {
  required List<ServicePackage> packages,
}) {
  return showDialog<ServicePackage>(
    context: context,
    builder: (ctx) => _ServicePackagePickerDialog(packages: packages),
  );
}

class _ServicePackagePickerDialog extends StatelessWidget {
  const _ServicePackagePickerDialog({required this.packages});

  final List<ServicePackage> packages;

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    return AlertDialog(
      title: Text(l10n.servicePackagesTitle),
      content: SizedBox(
        width: 420,
        child: packages.isEmpty
            ? Text(l10n.servicePackagesEmptyState)
            : ListView.separated(
                shrinkWrap: true,
                itemCount: packages.length,
                separatorBuilder: (_, __) => const Divider(height: 1),
                itemBuilder: (context, index) {
                  final pkg = packages[index];
                  final disabled = !pkg.isActive || pkg.isBroken;
                  final subtitleParts = <String>[
                    '${pkg.serviceCount} ${l10n.servicesLabel}',
                    '${pkg.effectiveDurationMinutes} ${l10n.minutesLabel}',
                  ];
                  return ListTile(
                    enabled: !disabled,
                    title: Text(pkg.name),
                    subtitle: Text(subtitleParts.join(' ¬∑ ')),
                    trailing: disabled
                        ? Icon(
                            pkg.isBroken
                                ? Icons.warning_amber_rounded
                                : Icons.block,
                            color: Theme.of(context).colorScheme.error,
                          )
                        : const Icon(Icons.chevron_right),
                    onTap: disabled
                        ? null
                        : () => Navigator.of(context).pop(pkg),
                  );
                },
              ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: Text(l10n.actionCancel),
        ),
      ],
    );
  }
}
--- FILE: lib/features/agenda/presentation/widgets/service_picker_field.dart ---
import 'package:flutter/material.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../app/theme/extensions.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/popular_service.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';
import '../../../../core/models/service_package.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_dividers.dart';

/// A form field for selecting a service, with services grouped by category.
/// Optionally shows packages in a dedicated section at the top.
///
/// On mobile: opens a bottom sheet with grouped services.
/// On desktop: opens a dialog with grouped services.
class ServicePickerField extends StatefulWidget {
  const ServicePickerField({
    super.key,
    required this.services,
    required this.categories,
    required this.formFactor,
    this.packages,
    this.popularServices,
    this.value,
    this.onChanged,
    this.onPackageSelected,
    this.onClear,
    this.validator,
    this.autovalidateMode = AutovalidateMode.disabled,
    this.autoOpenPicker = false,
    this.onAutoOpenPickerTriggered,
    this.onAutoOpenPickerCompleted,
    this.preselectedStaffServiceIds,
  });

  final List<Service> services;
  final List<ServiceCategory> categories;

  /// Optional list of packages to show in the picker.
  /// If provided, packages will appear in a dedicated section at the top.
  final List<ServicePackage>? packages;

  /// Servizi pi√π prenotati per questa location.
  /// Se fornito e showPopularSection √® true, mostra una sezione dedicata.
  final PopularServicesResult? popularServices;

  /// Lista di service IDs che lo staff preselezionato pu√≤ eseguire.
  /// Se fornita, il picker mostrer√† inizialmente solo questi servizi con
  /// un checkbox per visualizzare tutti i servizi.
  final List<int>? preselectedStaffServiceIds;

  final AppFormFactor formFactor;
  final int? value;
  final ValueChanged<int?>? onChanged;

  /// Callback called when a package is selected.
  /// The package is passed as parameter for expansion.
  final ValueChanged<ServicePackage>? onPackageSelected;

  /// Callback chiamato quando l'utente preme l'icona di rimozione.
  /// Se null, l'icona non viene mostrata.
  final VoidCallback? onClear;
  final FormFieldValidator<int>? validator;
  final bool autoOpenPicker;
  final VoidCallback? onAutoOpenPickerTriggered;
  final VoidCallback? onAutoOpenPickerCompleted;

  /// Modalit√† di autovalidazione. Default: disabled (valida solo su submit).
  final AutovalidateMode autovalidateMode;

  @override
  State<ServicePickerField> createState() => _ServicePickerFieldState();
}

class _ServicePickerFieldState extends State<ServicePickerField> {
  final _formFieldKey = GlobalKey<FormFieldState<int>>();
  bool _autoPickerInvoked = false;
  bool _autoOpenInProgress = false;

  Service? get _selectedService {
    if (widget.value == null) return null;
    return widget.services.where((s) => s.id == widget.value).firstOrNull;
  }

  @override
  void didUpdateWidget(ServicePickerField oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Aggiorna lo stato del FormField quando il valore cambia
    if (oldWidget.value != widget.value) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        final state = _formFieldKey.currentState;
        if (state != null) {
          state.didChange(widget.value);
        }
      });
    }
    if (oldWidget.autoOpenPicker != widget.autoOpenPicker) {
      _autoPickerInvoked = false;
    }
  }

  @override
  Widget build(BuildContext context) {
    return FormField<int>(
      key: _formFieldKey,
      initialValue: widget.value,
      validator: widget.validator,
      autovalidateMode: widget.autovalidateMode,
      builder: (field) {
        final theme = Theme.of(context);
        final hasError = field.hasError;
        final borderColor = hasError
            ? theme.colorScheme.error
            : theme.colorScheme.outline;

        if (widget.autoOpenPicker && !_autoPickerInvoked) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (!mounted || _autoPickerInvoked) return;
            _autoPickerInvoked = true;
            _autoOpenInProgress = true;
            _openPicker(field);
            widget.onAutoOpenPickerTriggered?.call();
          });
        }

        return InkWell(
          onTap: () => _openPicker(field),
          borderRadius: BorderRadius.circular(4),
          child: InputDecorator(
            decoration: InputDecoration(
              labelText: _selectedService != null
                  ? context.l10n.formService
                  : null,
              contentPadding: const EdgeInsets.symmetric(
                horizontal: 12,
                vertical: 16,
              ),
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(4),
                borderSide: BorderSide(color: borderColor),
              ),
              enabledBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(4),
                borderSide: BorderSide(color: borderColor),
              ),
              errorText: field.errorText,
              suffixIcon: _selectedService != null && widget.onClear != null
                  ? IconButton(
                      icon: Icon(
                        Icons.close,
                        color: theme.colorScheme.error,
                        size: 20,
                      ),
                      onPressed: widget.onClear,
                      tooltip: context.l10n.actionDelete,
                    )
                  : const Icon(Icons.arrow_drop_down),
            ),
            child: Text(
              _selectedService?.name ?? context.l10n.selectService,
              style: theme.textTheme.bodyLarge?.copyWith(
                color: _selectedService == null
                    ? theme.colorScheme.onSurfaceVariant.withOpacity(0.7)
                    : null,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        );
      },
    );
  }

  Future<void> _openPicker(FormFieldState<int> field) async {
    if (widget.formFactor == AppFormFactor.desktop) {
      await _openDesktopDialogWithField(field);
    } else {
      await _openBottomSheetWithField(field);
    }
  }

  Future<void> _openBottomSheetWithField(FormFieldState<int> field) async {
    await AppBottomSheet.show<int>(
      context: context,
      heightFactor: AppBottomSheet.defaultHeightFactor,
      padding: EdgeInsets.zero,
      builder: (ctx) => _ServicePickerContent(
        services: widget.services,
        categories: widget.categories,
        packages: widget.packages,
        popularServices: widget.popularServices,
        preselectedStaffServiceIds: widget.preselectedStaffServiceIds,
        selectedId: widget.value,
        onSelected: (id) {
          final wasAutoOpen = _autoOpenInProgress;
          Navigator.of(ctx).pop();
          field.didChange(id);
          field.validate(); // Ri-valida per rimuovere l'errore
          widget.onChanged?.call(id);
          if (wasAutoOpen) {
            _autoOpenInProgress = false;
            widget.onAutoOpenPickerCompleted?.call();
          }
        },
        onPackageSelected: widget.onPackageSelected != null
            ? (package) {
                final wasAutoOpen = _autoOpenInProgress;
                Navigator.of(ctx).pop();
                widget.onPackageSelected!(package);
                if (wasAutoOpen) {
                  _autoOpenInProgress = false;
                  widget.onAutoOpenPickerCompleted?.call();
                }
              }
            : null,
      ),
    );
    _autoOpenInProgress = false;
  }

  Future<void> _openDesktopDialogWithField(FormFieldState<int> field) async {
    await showDialog<int>(
      context: context,
      builder: (ctx) => Dialog(
        insetPadding: const EdgeInsets.symmetric(horizontal: 32, vertical: 24),
        child: ConstrainedBox(
          constraints: const BoxConstraints(
            minWidth: 600,
            maxWidth: 720,
            maxHeight: 500,
          ),
          child: _ServicePickerContent(
            services: widget.services,
            categories: widget.categories,
            packages: widget.packages,
            popularServices: widget.popularServices,
            preselectedStaffServiceIds: widget.preselectedStaffServiceIds,
            selectedId: widget.value,
            onSelected: (id) {
              final wasAutoOpen = _autoOpenInProgress;
              Navigator.of(ctx).pop();
              field.didChange(id);
              field.validate(); // Ri-valida per rimuovere l'errore
              widget.onChanged?.call(id);
              if (wasAutoOpen) {
                _autoOpenInProgress = false;
                widget.onAutoOpenPickerCompleted?.call();
              }
            },
            onPackageSelected: widget.onPackageSelected != null
                ? (package) {
                    final wasAutoOpen = _autoOpenInProgress;
                    Navigator.of(ctx).pop();
                    widget.onPackageSelected!(package);
                    if (wasAutoOpen) {
                      _autoOpenInProgress = false;
                      widget.onAutoOpenPickerCompleted?.call();
                    }
                  }
                : null,
          ),
        ),
      ),
    );
    _autoOpenInProgress = false;
  }
}

/// Content widget for the service picker (used in both bottom sheet and popup).
class _ServicePickerContent extends StatefulWidget {
  const _ServicePickerContent({
    required this.services,
    required this.categories,
    this.packages,
    this.popularServices,
    this.preselectedStaffServiceIds,
    required this.selectedId,
    required this.onSelected,
    this.onPackageSelected,
  });

  final List<Service> services;
  final List<ServiceCategory> categories;
  final List<ServicePackage>? packages;
  final PopularServicesResult? popularServices;
  final List<int>? preselectedStaffServiceIds;
  final int? selectedId;
  final ValueChanged<int?> onSelected;
  final ValueChanged<ServicePackage>? onPackageSelected;

  @override
  State<_ServicePickerContent> createState() => _ServicePickerContentState();
}

class _ServicePickerContentState extends State<_ServicePickerContent> {
  final _searchController = TextEditingController();
  final _searchFocusNode = FocusNode();
  final _scrollController = ScrollController();
  String _searchQuery = '';
  bool _showAllServices = false;

  @override
  void initState() {
    super.initState();
    // Se non c'√® uno staff preselezionato, mostra tutti i servizi
    _showAllServices =
        widget.preselectedStaffServiceIds == null ||
        widget.preselectedStaffServiceIds!.isEmpty;

    // Auto-focus sul campo di ricerca dopo il primo build
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        _searchFocusNode.requestFocus();
      }
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    _searchFocusNode.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  List<Service> get _filteredServices {
    var services = widget.services;

    // Filtra per staff preselezionato (se presente e checkbox non attivo)
    if (!_showAllServices &&
        widget.preselectedStaffServiceIds != null &&
        widget.preselectedStaffServiceIds!.isNotEmpty) {
      services = services
          .where((s) => widget.preselectedStaffServiceIds!.contains(s.id))
          .toList();
    }

    // Filtra per query di ricerca
    if (_searchQuery.isNotEmpty) {
      final query = _searchQuery.toLowerCase();
      services = services
          .where((s) => s.name.toLowerCase().contains(query))
          .toList();
    }

    return services;
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    final filteredServices = _filteredServices;

    final servicesByCategory = <int, List<Service>>{};
    for (final service in filteredServices) {
      (servicesByCategory[service.categoryId] ??= []).add(service);
    }

    final hasServicesMap = <int, bool>{
      for (final category in widget.categories)
        category.id: (servicesByCategory[category.id]?.isNotEmpty ?? false),
    };

    // Sort categories like services section:
    // 1) non-empty before empty, 2) sortOrder, 3) name
    final sortedCategories = [...widget.categories]
      ..sort((a, b) {
        final aEmpty = !(hasServicesMap[a.id] ?? false);
        final bEmpty = !(hasServicesMap[b.id] ?? false);
        if (aEmpty != bEmpty) return aEmpty ? 1 : -1;
        final so = a.sortOrder.compareTo(b.sortOrder);
        return so != 0
            ? so
            : a.name.toLowerCase().compareTo(b.name.toLowerCase());
      });

    // Filter active packages and sort by sortOrder
    var activePackages =
        (widget.packages ?? []).where((p) => p.isActive && !p.isBroken).toList()
          ..sort((a, b) {
            final so = a.sortOrder.compareTo(b.sortOrder);
            return so != 0
                ? so
                : a.name.toLowerCase().compareTo(b.name.toLowerCase());
          });

    // Filtra packages per staff preselezionato (se presente e checkbox non attivo)
    // Lo staff deve poter eseguire TUTTI i servizi inclusi nel pacchetto
    if (!_showAllServices &&
        widget.preselectedStaffServiceIds != null &&
        widget.preselectedStaffServiceIds!.isNotEmpty) {
      activePackages = activePackages.where((p) {
        final packageServiceIds = p.orderedServiceIds;
        return packageServiceIds.every(
          (serviceId) => widget.preselectedStaffServiceIds!.contains(serviceId),
        );
      }).toList();
    }

    // Filtra packages per ricerca
    final filteredPackages = _searchQuery.isEmpty
        ? activePackages
        : activePackages
              .where(
                (p) =>
                    p.name.toLowerCase().contains(_searchQuery.toLowerCase()),
              )
              .toList();

    final showPackages =
        filteredPackages.isNotEmpty && widget.onPackageSelected != null;

    final hasStaffFilter =
        widget.preselectedStaffServiceIds != null &&
        widget.preselectedStaffServiceIds!.isNotEmpty;

    // Mostra checkbox solo se lo staff non ha gi√† tutti i servizi
    final staffHasAllServices =
        hasStaffFilter &&
        widget.preselectedStaffServiceIds!.length >= widget.services.length;
    final showAllServicesCheckbox = hasStaffFilter && !staffHasAllServices;

    // Mostra il campo di ricerca solo se ci sono pi√π di 10 servizi
    // (conta i servizi dopo il filtro staff ma prima della ricerca)
    final servicesBeforeSearch =
        _showAllServices ||
            widget.preselectedStaffServiceIds == null ||
            widget.preselectedStaffServiceIds!.isEmpty
        ? widget.services.length
        : widget.services
              .where((s) => widget.preselectedStaffServiceIds!.contains(s.id))
              .length;
    final showSearchField =
        servicesBeforeSearch > 10 || _searchQuery.isNotEmpty;

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.fromLTRB(16, 8, 16, 12),
          child: Text(
            l10n.formService,
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.w600,
            ),
          ),
        ),
        // Campo di ricerca (solo se > 10 servizi)
        if (showSearchField)
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: TextField(
              controller: _searchController,
              focusNode: _searchFocusNode,
              decoration: InputDecoration(
                hintText: l10n.searchServices,
                prefixIcon: const Icon(Icons.search, size: 20),
                suffixIcon: _searchQuery.isNotEmpty
                    ? IconButton(
                        icon: const Icon(Icons.clear, size: 20),
                        onPressed: () {
                          setState(() {
                            _searchController.clear();
                            _searchQuery = '';
                          });
                        },
                      )
                    : null,
                isDense: true,
                contentPadding: const EdgeInsets.symmetric(
                  horizontal: 12,
                  vertical: 10,
                ),
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
              ),
              onChanged: (value) {
                setState(() {
                  _searchQuery = value;
                });
              },
            ),
          ),
        // Checkbox "Mostra tutti i servizi" (solo se c'√® filtro staff e non ha gi√† tutti)
        if (showAllServicesCheckbox) ...[
          const SizedBox(height: 8),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8),
            child: Row(
              children: [
                Checkbox(
                  value: _showAllServices,
                  onChanged: (value) {
                    setState(() {
                      _showAllServices = value ?? false;
                    });
                  },
                ),
                Expanded(
                  child: GestureDetector(
                    onTap: () {
                      setState(() {
                        _showAllServices = !_showAllServices;
                      });
                    },
                    child: Text(
                      l10n.showAllServices,
                      style: theme.textTheme.bodyMedium,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
        const SizedBox(height: 8),
        const AppDivider(),
        // Service and packages list
        Expanded(
          child: filteredServices.isEmpty && filteredPackages.isEmpty
              ? Center(
                  child: Text(
                    l10n.noServicesFound,
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
                )
              : ListView(
                  controller: _scrollController,
                  children: [
                    // Packages section (if available)
                    if (showPackages)
                      _PackagesSection(
                        packages: filteredPackages,
                        onSelected: widget.onPackageSelected!,
                      ),
                    // Popular services section (if available and search empty)
                    if (_searchQuery.isEmpty &&
                        widget.popularServices != null &&
                        widget.popularServices!.showPopularSection)
                      Builder(
                        builder: (context) {
                          // Filtra servizi popolari per staff preselezionato
                          var filteredPopular =
                              widget.popularServices!.popularServices;
                          if (!_showAllServices &&
                              widget.preselectedStaffServiceIds != null &&
                              widget.preselectedStaffServiceIds!.isNotEmpty) {
                            filteredPopular = filteredPopular
                                .where(
                                  (ps) => widget.preselectedStaffServiceIds!
                                      .contains(ps.serviceId),
                                )
                                .toList();
                          }
                          // Mostra sezione solo se ci sono servizi popolari dopo il filtro
                          if (filteredPopular.isEmpty) {
                            return const SizedBox.shrink();
                          }
                          return _PopularServicesSection(
                            popularServices: filteredPopular,
                            selectedId: widget.selectedId,
                            onSelected: widget.onSelected,
                          );
                        },
                      ),
                    // Categories and services
                    for (final category in sortedCategories)
                      Builder(
                        builder: (ctx) {
                          final categoryServices =
                              (servicesByCategory[category.id] ?? []).toList()
                                ..sort((a, b) {
                                  final so = a.sortOrder.compareTo(b.sortOrder);
                                  return so != 0
                                      ? so
                                      : a.name.toLowerCase().compareTo(
                                          b.name.toLowerCase(),
                                        );
                                });

                          if (categoryServices.isEmpty) {
                            return const SizedBox.shrink();
                          }

                          return _CategorySection(
                            category: category,
                            services: categoryServices,
                            selectedId: widget.selectedId,
                            onSelected: widget.onSelected,
                          );
                        },
                      ),
                  ],
                ),
        ),
      ],
    );
  }
}

/// A section showing packages in a dedicated section.
class _PackagesSection extends StatelessWidget {
  const _PackagesSection({required this.packages, required this.onSelected});

  final List<ServicePackage> packages;
  final ValueChanged<ServicePackage> onSelected;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final interactionColors = theme.extension<AppInteractionColors>();
    final evenBackgroundColor =
        interactionColors?.alternatingRowFill ??
        theme.colorScheme.onSurface.withOpacity(0.04);

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Packages header with accent color
        Container(
          width: double.infinity,
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 20),
          color: theme.colorScheme.secondary,
          child: Center(
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.widgets_outlined,
                  color: theme.colorScheme.onSecondary,
                  size: 18,
                ),
                const SizedBox(width: 8),
                Text(
                  l10n.servicePackagesTitle.toUpperCase(),
                  style: theme.textTheme.labelMedium?.copyWith(
                    color: theme.colorScheme.onSecondary,
                    fontWeight: FontWeight.bold,
                    letterSpacing: 0.5,
                  ),
                ),
              ],
            ),
          ),
        ),
        // Package items with alternating background
        for (int i = 0; i < packages.length; i++)
          _buildPackageTile(
            context,
            packages[i],
            isEven: i.isEven,
            evenBackgroundColor: evenBackgroundColor,
            theme: theme,
          ),
      ],
    );
  }

  Widget _buildPackageTile(
    BuildContext context,
    ServicePackage package, {
    required bool isEven,
    required Color evenBackgroundColor,
    required ThemeData theme,
  }) {
    final priceStr = package.effectivePrice > 0
        ? '‚Ç¨${package.effectivePrice.toStringAsFixed(2)}'
        : null;

    return Material(
      color: isEven ? evenBackgroundColor : Colors.transparent,
      child: InkWell(
        onTap: () => onSelected(package),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          child: Row(
            children: [
              Icon(
                Icons.widgets_outlined,
                color: theme.colorScheme.secondary,
                size: 16,
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      package.name,
                      style: const TextStyle(fontWeight: FontWeight.w500),
                    ),
                    Text(
                      '${package.serviceCount} ${package.serviceCount == 1 ? context.l10n.formService.toLowerCase() : context.l10n.bookingItems.toLowerCase()}',
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ],
                ),
              ),
              if (priceStr != null)
                Text(
                  priceStr,
                  style: theme.textTheme.bodyMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                    color: theme.colorScheme.secondary,
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }
}

/// A section showing the most popular (most booked) services.
class _PopularServicesSection extends StatelessWidget {
  const _PopularServicesSection({
    required this.popularServices,
    required this.selectedId,
    required this.onSelected,
  });

  final List<PopularService> popularServices;
  final int? selectedId;
  final ValueChanged<int?> onSelected;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final interactionColors = theme.extension<AppInteractionColors>();
    final evenBackgroundColor =
        interactionColors?.alternatingRowFill ??
        theme.colorScheme.onSurface.withOpacity(0.04);

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Header with tertiary color (to distinguish from packages and categories)
        Container(
          width: double.infinity,
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 20),
          color: theme.colorScheme.tertiary,
          child: Center(
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.trending_up,
                  color: theme.colorScheme.onTertiary,
                  size: 18,
                ),
                const SizedBox(width: 8),
                Text(
                  l10n.popularServicesTitle.toUpperCase(),
                  style: theme.textTheme.labelMedium?.copyWith(
                    color: theme.colorScheme.onTertiary,
                    fontWeight: FontWeight.bold,
                    letterSpacing: 0.5,
                  ),
                ),
              ],
            ),
          ),
        ),
        // Popular service items with alternating background
        for (int i = 0; i < popularServices.length; i++)
          _buildPopularServiceTile(
            context,
            popularServices[i],
            isEven: i.isEven,
            evenBackgroundColor: evenBackgroundColor,
            theme: theme,
          ),
      ],
    );
  }

  Widget _buildPopularServiceTile(
    BuildContext context,
    PopularService popularService, {
    required bool isEven,
    required Color evenBackgroundColor,
    required ThemeData theme,
  }) {
    final isSelected = popularService.serviceId == selectedId;

    return Material(
      color: isEven ? evenBackgroundColor : Colors.transparent,
      child: InkWell(
        onTap: () => onSelected(popularService.serviceId),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          child: Row(
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      popularService.serviceName,
                      style: const TextStyle(fontWeight: FontWeight.w500),
                    ),
                    // Mostra categoria solo se presente (significa che i servizi
                    // popolari appartengono a categorie diverse)
                    if (popularService.categoryName != null)
                      Text(
                        popularService.categoryName!,
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                      ),
                  ],
                ),
              ),
              if (isSelected)
                Icon(Icons.check, color: theme.colorScheme.primary, size: 20),
            ],
          ),
        ),
      ),
    );
  }
}

/// A section showing a category header and its services.
class _CategorySection extends StatelessWidget {
  const _CategorySection({
    required this.category,
    required this.services,
    required this.selectedId,
    required this.onSelected,
  });

  final ServiceCategory category;
  final List<Service> services;
  final int? selectedId;
  final ValueChanged<int?> onSelected;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    // Colore di sfondo leggero per i servizi con indice pari (even)
    final interactionColors = theme.extension<AppInteractionColors>();
    final evenBackgroundColor =
        interactionColors?.alternatingRowFill ??
        theme.colorScheme.onSurface.withOpacity(0.04);

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Category header with full-width background
        Container(
          width: double.infinity,
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 20),
          color: theme.colorScheme.primary,
          child: Center(
            child: Text(
              category.name.toUpperCase(),
              style: theme.textTheme.labelMedium?.copyWith(
                color: theme.colorScheme.onPrimary,
                fontWeight: FontWeight.bold,
                letterSpacing: 0.5,
              ),
            ),
          ),
        ),
        // Services con sfondo alternato (even)
        for (int i = 0; i < services.length; i++)
          _buildServiceTile(
            context,
            services[i],
            isEven: i.isEven,
            evenBackgroundColor: evenBackgroundColor,
            theme: theme,
          ),
      ],
    );
  }

  Widget _buildServiceTile(
    BuildContext context,
    Service service, {
    required bool isEven,
    required Color evenBackgroundColor,
    required ThemeData theme,
  }) {
    final isSelected = service.id == selectedId;
    return Material(
      color: isEven ? evenBackgroundColor : Colors.transparent,
      child: InkWell(
        onTap: () => onSelected(service.id),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          child: Row(
            children: [
              Expanded(child: Text(service.name)),
              if (isSelected)
                Icon(Icons.check, color: theme.colorScheme.primary, size: 20),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/widgets/appointment_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:agenda_backend/core/l10n/date_time_formats.dart';
import 'package:agenda_backend/core/models/popular_service.dart';
import 'package:agenda_backend/core/widgets/no_scrollbar_behavior.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/appointment.dart';
import '../../../../core/models/service_package.dart';
import '../../../../core/models/service_variant.dart';
import '../../../../core/network/api_client.dart';
import '../../../../core/utils/price_utils.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/feedback_dialog.dart';
import '../../../../core/widgets/local_loading_overlay.dart';
import '../../../auth/providers/current_business_user_provider.dart';
import '../../../clients/domain/clients.dart';
import '../../../clients/presentation/dialogs/client_edit_dialog.dart';
import '../../../clients/providers/clients_providers.dart';
import '../../../services/providers/popular_services_provider.dart';
import '../../../services/providers/service_categories_provider.dart';
import '../../../services/providers/service_packages_provider.dart';
import '../../../services/providers/service_packages_repository_provider.dart';
import '../../../services/providers/services_provider.dart';
import '../../domain/service_item_data.dart';
import '../../providers/agenda_scroll_request_provider.dart';
import '../../providers/appointment_providers.dart';
import '../../providers/booking_reschedule_provider.dart';
import '../../providers/bookings_provider.dart';
import '../../providers/bookings_repository_provider.dart';
import '../../providers/date_range_provider.dart';
import '../../providers/layout_config_provider.dart';
import '../../providers/location_providers.dart';
import '../../providers/staff_slot_availability_provider.dart';
import '../dialogs/booking_history_dialog.dart';
import '../dialogs/recurring_action_dialog.dart';
import 'service_item_card.dart';
import 'service_package_picker_dialog.dart';

/// Show the Appointment dialog for editing an existing appointment.
/// For creating new appointments, use [showBookingDialog] instead.
Future<void> showAppointmentDialog(
  BuildContext context,
  WidgetRef ref, {
  required Appointment initial,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final presentation = formFactor == AppFormFactor.desktop
      ? _AppointmentPresentation.dialog
      : _AppointmentPresentation.bottomSheet;

  final content = _AppointmentDialog(
    initial: initial,
    presentation: presentation,
  );

  if (presentation == _AppointmentPresentation.dialog) {
    await showDialog(context: context, builder: (_) => content);
  } else {
    await AppBottomSheet.show(
      context: context,
      useRootNavigator: true,
      builder: (_) => content,
      padding: const EdgeInsets.symmetric(horizontal: 0, vertical: 16),
      heightFactor: AppBottomSheet.defaultHeightFactor,
    );
  }
}

enum _AppointmentPresentation { dialog, bottomSheet }

class _AppointmentDialog extends ConsumerStatefulWidget {
  const _AppointmentDialog({required this.initial, required this.presentation});

  final Appointment initial;
  final _AppointmentPresentation presentation;

  @override
  ConsumerState<_AppointmentDialog> createState() => _AppointmentDialogState();
}

class _AppointmentDialogState extends ConsumerState<_AppointmentDialog> {
  final _formKey = GlobalKey<FormState>();
  final _notesController = TextEditingController();
  final ScrollController _scrollController = ScrollController();

  late DateTime _date;
  int? _clientId;
  String _clientName = '';
  late final bool _bookingHasSingleAppointment;

  /// Lista di ServiceItemData per i servizi dell'appuntamento
  final List<ServiceItemData> _serviceItems = [];

  /// Contatore per generare chiavi univoche
  int _itemKeyCounter = 0;

  bool _warningDismissed = false;
  bool _midnightWarningVisible = false;
  bool _midnightWarningDismissed = false;
  int? _autoOpenServicePickerIndex;
  bool _isSaving = false;
  bool _isAddingPackage = false;
  late final String _currentBookingStatus;
  String? _selectedBookingStatus;

  /// Stato iniziale per rilevare modifiche
  late DateTime _initialDate;
  late int? _initialClientId;
  late String _initialClientName;
  late String _initialNotes;
  late List<ServiceItemData> _initialServiceItems;

  @override
  void initState() {
    super.initState();

    final appt = widget.initial;
    _date = DateTime(
      appt.startTime.year,
      appt.startTime.month,
      appt.startTime.day,
    );
    _clientId = appt.clientId;
    _clientName = appt.clientName;
    final booking = ref.read(bookingsProvider)[appt.bookingId];
    _currentBookingStatus =
        booking?.status ?? appt.bookingStatus ?? 'confirmed';
    _selectedBookingStatus =
        _availableStatusOptions().contains(_currentBookingStatus)
        ? _currentBookingStatus
        : null;
    Future.microtask(() {
      if (!mounted) return;
      ref
          .read(bookingsProvider.notifier)
          .ensureBooking(
            bookingId: appt.bookingId,
            businessId: appt.businessId,
            locationId: appt.locationId,
            clientId: appt.clientId,
            clientName: appt.clientName,
            // Note: status and replace fields not available from Appointment,
            // they will be populated when booking is loaded from API
          );
    });
    // Leggi le note dalla Booking associata
    _notesController.text = booking?.notes ?? '';

    // Carica tutti gli appuntamenti della stessa prenotazione
    final bookingAppointments = ref
        .read(appointmentsProvider.notifier)
        .getByBookingId(appt.bookingId);
    _bookingHasSingleAppointment = bookingAppointments.length <= 1;

    for (final appointment in bookingAppointments) {
      // Skip appuntamenti con serviceId corrotto (0 o nullo)
      // Questi verranno eliminati quando si salva
      if (appointment.serviceId == 0) {
        continue;
      }

      final baseDuration = _baseDurationFromAppointment(appointment);
      final blockedExtraMinutes = appointment.blockedExtraMinutes;
      final processingExtraMinutes = appointment.processingExtraMinutes;
      _serviceItems.add(
        ServiceItemData(
          key: _nextItemKey(),
          appointmentId: appointment.id, // Traccia l'ID originale
          startTime: TimeOfDay.fromDateTime(appointment.startTime),
          staffId: appointment.staffId,
          serviceId: appointment.serviceId,
          serviceVariantId: appointment.serviceVariantId,
          durationMinutes: baseDuration,
          blockedExtraMinutes: blockedExtraMinutes,
          processingExtraMinutes: processingExtraMinutes,
          price: appointment.price, // Prezzo personalizzato
        ),
      );
    }

    // Se non ci sono appointments (caso raro), aggiungi un item vuoto
    if (_serviceItems.isEmpty) {
      final initialTime = TimeOfDay.fromDateTime(appt.startTime);
      _serviceItems.add(
        ServiceItemData(
          key: _nextItemKey(),
          startTime: initialTime,
          staffId: appt.staffId,
        ),
      );
    }

    // Salva stato iniziale per rilevare modifiche
    _initialDate = _date;
    _initialClientId = _clientId;
    _initialClientName = _clientName;
    _initialNotes = _notesController.text;
    // Copia profonda dei servizi per confronto
    _initialServiceItems = _serviceItems
        .map(
          (s) => ServiceItemData(
            key: s.key,
            appointmentId: s.appointmentId,
            startTime: s.startTime,
            staffId: s.staffId,
            serviceId: s.serviceId,
            serviceVariantId: s.serviceVariantId,
            durationMinutes: s.durationMinutes,
            blockedExtraMinutes: s.blockedExtraMinutes,
            processingExtraMinutes: s.processingExtraMinutes,
          ),
        )
        .toList();
  }

  void _showHistory(BuildContext context) {
    final bookingId = widget.initial.bookingId;
    showBookingHistoryDialog(context, ref, bookingId: bookingId);
  }

  @override
  void dispose() {
    _notesController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  String _nextItemKey() => 'item_${_itemKeyCounter++}';

  int _baseDurationFromAppointment(Appointment appointment) {
    final totalMinutes = appointment.endTime
        .difference(appointment.startTime)
        .inMinutes;
    final extraMinutes = appointment.blockedExtraMinutes;
    final base = totalMinutes - extraMinutes;
    return base > 0 ? base : 0;
  }

  List<String> _availableStatusOptions() {
    return const <String>[
      'confirmed',
      'completed',
      'no_show',
    ];
  }

  String _statusLabel(BuildContext context, String status) {
    final l10n = context.l10n;
    switch (status) {
      case 'confirmed':
        return l10n.statusConfirmed;
      case 'cancelled':
        return l10n.statusCancelled;
      case 'pending':
        return l10n.bookingsListStatusPending;
      case 'completed':
        return l10n.statusCompleted;
      case 'no_show':
        return l10n.bookingsListStatusNoShow;
      default:
        return status;
    }
  }

  /// Verifica se ci sono modifiche non salvate
  bool get _hasUnsavedChanges {
    if (_date != _initialDate) return true;
    if (_clientId != _initialClientId) return true;
    if (_clientName != _initialClientName) return true;
    if (_notesController.text != _initialNotes) return true;
    if (_selectedBookingStatus != null &&
        _selectedBookingStatus != _currentBookingStatus) {
      return true;
    }
    if (_serviceItems.length != _initialServiceItems.length) return true;

    // Confronto dettagliato dei servizi
    for (int i = 0; i < _serviceItems.length; i++) {
      final current = _serviceItems[i];
      final initial = _initialServiceItems[i];
      if (current.serviceId != initial.serviceId) return true;
      if (current.staffId != initial.staffId) return true;
      if (current.startTime != initial.startTime) return true;
      if (current.durationMinutes != initial.durationMinutes) return true;
      if (current.blockedExtraMinutes != initial.blockedExtraMinutes) {
        return true;
      }
      if (current.processingExtraMinutes != initial.processingExtraMinutes) {
        return true;
      }
    }

    return false;
  }

  /// Gestisce la chiusura del dialog con controllo modifiche
  Future<void> _handleClose() async {
    final shouldProceed = await _confirmDiscardChangesIfNeeded();
    if (!shouldProceed) return;
    if (mounted) Navigator.of(context).pop();
  }

  Future<bool> _confirmDiscardChangesIfNeeded() async {
    if (!_hasUnsavedChanges) return true;

    final l10n = context.l10n;
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (_) => AlertDialog(
        title: Text(l10n.discardChangesTitle),
        content: Text(l10n.discardChangesMessage),
        actions: [
          AppOutlinedActionButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text(l10n.actionKeepEditing),
          ),
          AppDangerButton(
            onPressed: () => Navigator.pop(context, true),
            child: Text(l10n.actionDiscard),
          ),
        ],
      ),
    );

    return confirmed == true;
  }

  Future<void> _startBookingReschedule() async {
    if (_isSaving) return;
    final canProceed = await _confirmDiscardChangesIfNeeded();
    if (!canProceed || !mounted) return;

    final bookingAppointments = ref
        .read(appointmentsProvider.notifier)
        .getByBookingId(widget.initial.bookingId);
    if (bookingAppointments.isEmpty) {
      await FeedbackDialog.showError(
        context,
        title: context.l10n.errorTitle,
        message: context.l10n.bookingRescheduleMissingBooking,
      );
      return;
    }

    final currentAgendaDate = ref.read(agendaDateProvider);
    ref
        .read(bookingRescheduleSessionProvider.notifier)
        .start(
          bookingId: widget.initial.bookingId,
          originDate: currentAgendaDate,
          bookingAppointments: bookingAppointments,
        );

    Navigator.of(context).pop();
  }

  /// Gestisce la cancellazione dell'appuntamento/prenotazione
  /// Se l'appuntamento fa parte di una serie ricorrente, mostra un dialog
  /// per scegliere lo scope dell'azione
  Future<void> _handleDelete() async {
    final canManageBookings = ref.read(currentUserCanManageBookingsProvider);
    if (!canManageBookings) return;

    final l10n = context.l10n;
    final appt = widget.initial;

    // Verifica se √® una prenotazione ricorrente
    if (appt.isRecurring &&
        appt.recurrenceRuleId != null &&
        appt.recurrenceIndex != null &&
        appt.recurrenceTotal != null) {
      // Mostra il dialog per le prenotazioni ricorrenti
      final result = await showRecurringDeleteDialog(
        context,
        currentIndex: appt.recurrenceIndex!,
        totalCount: appt.recurrenceTotal!,
      );

      if (result == null) return; // Utente ha annullato

      setState(() => _isSaving = true);
      try {
        final bookingsApi = ref.read(bookingsApiProvider);
        final String scope;
        int? fromIndex;

        switch (result.scope) {
          case RecurringActionScope.single:
            // Cancella solo questo appuntamento con l'API standard
            await ref
                .read(bookingsProvider.notifier)
                .deleteBooking(appt.bookingId);
            if (mounted) Navigator.of(context).pop();
            return;

          case RecurringActionScope.thisAndFuture:
            scope = 'this_and_future';
            fromIndex = appt.recurrenceIndex;

          case RecurringActionScope.all:
            scope = 'all';
        }

        // Chiama l'API per cancellare la serie
        await bookingsApi.cancelRecurringSeries(
          ruleId: appt.recurrenceRuleId!,
          scope: scope,
          fromIndex: fromIndex,
        );

        // Ricarica gli appuntamenti
        ref.invalidate(appointmentsProvider);

        if (mounted) Navigator.of(context).pop();
      } catch (e) {
        if (mounted) {
          await FeedbackDialog.showError(
            context,
            title: l10n.errorTitle,
            message: e.toString(),
          );
        }
      } finally {
        if (mounted) setState(() => _isSaving = false);
      }
    } else {
      // Prenotazione non ricorrente - usa la logica esistente
      final deleteTitle = _bookingHasSingleAppointment
          ? l10n.deleteAppointmentConfirmTitle
          : l10n.deleteBookingConfirmTitle;
      final deleteMessage = _bookingHasSingleAppointment
          ? l10n.deleteAppointmentConfirmMessage
          : l10n.deleteBookingConfirmMessage;

      final confirmed = await showDialog<bool>(
        context: context,
        builder: (_) => AlertDialog(
          title: Text(deleteTitle),
          content: Text(deleteMessage),
          actions: [
            AppOutlinedActionButton(
              onPressed: () => Navigator.pop(context, false),
              child: Text(l10n.actionCancel),
            ),
            AppDangerButton(
              onPressed: () => Navigator.pop(context, true),
              child: Text(l10n.actionDelete),
            ),
          ],
        ),
      );

      if (confirmed == true) {
        setState(() => _isSaving = true);
        try {
          await ref
              .read(bookingsProvider.notifier)
              .deleteBooking(appt.bookingId);
          if (mounted) Navigator.of(context).pop();
        } finally {
          if (mounted) setState(() => _isSaving = false);
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final isDialog = widget.presentation == _AppointmentPresentation.dialog;

    final formFactor = ref.watch(formFactorProvider);
    final services = ref.watch(servicesProvider).value ?? [];
    final serviceCategories = ref.watch(serviceCategoriesProvider);
    final variants = ref.watch(serviceVariantsProvider).value ?? [];
    final clients = ref.watch(clientsListProvider);
    final staff = ref.watch(staffForCurrentLocationProvider);
    final hasPackages =
        (ref.watch(servicePackagesProvider).value ?? []).isNotEmpty;
    final canManageBookings = ref.watch(currentUserCanManageBookingsProvider);
    final currentUserRole = ref.watch(currentUserRoleProvider);
    final currentUserStaffId = ref.watch(currentUserStaffIdProvider);
    final forcedStaffId =
        (currentUserRole == 'staff' &&
            currentUserStaffId != null &&
            currentUserStaffId > 0)
        ? currentUserStaffId
        : null;

    // Usa lo staffId del primo item per i servizi popolari
    final firstStaffId = _serviceItems.isNotEmpty
        ? _serviceItems.first.staffId
        : null;
    final validStaffIds = staff.map((s) => s.id).toSet();
    final effectiveStaffId =
        firstStaffId != null && validStaffIds.contains(firstStaffId)
        ? firstStaffId
        : null;
    final popularServices = effectiveStaffId != null
        ? ref.watch(popularServicesProvider(effectiveStaffId)).value
        : null;

    final title = l10n.appointmentDialogTitleEdit;
    final statusOptions = _availableStatusOptions();

    // Il campo cliente √® bloccato se l'appuntamento
    // aveva gi√† un cliente associato (clientId != null)
    final isClientLocked = widget.initial.clientId != null;

    final conflictFlags = _serviceConflictFlags();
    final eligibleIndices = <int>[];
    for (int i = 0; i < _serviceItems.length; i++) {
      if (_isWarningEligible(_serviceItems[i])) {
        eligibleIndices.add(i);
      }
    }
    final allEligibleConflict =
        eligibleIndices.isNotEmpty &&
        eligibleIndices.every((i) => conflictFlags[i]);
    final showAppointmentWarning =
        eligibleIndices.length > 1 && allEligibleConflict;
    final showServiceWarnings = !showAppointmentWarning;

    final content = ScrollConfiguration(
      behavior: const NoScrollbarBehavior(),
      child: SingleChildScrollView(
        controller: _scrollController,
        child: IgnorePointer(
          ignoring: !canManageBookings,
          child: Form(
            key: _formKey,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const SizedBox(height: AppSpacing.formFirstRowSpacing),
                // Client selection (first)
                _ClientSelectionField(
                  clientId: _clientId,
                  clientName: _clientName,
                  clients: clients,
                  isLocked: isClientLocked,
                  onClientSelected: (id, name) {
                    setState(() {
                      _clientId = id;
                      _clientName = name;
                    });
                  },
                  onClientRemoved: () {
                    setState(() {
                      _clientId = null;
                      _clientName = '';
                    });
                  },
                ),
                const SizedBox(height: AppSpacing.formRowSpacing),
                // Date
                InkWell(
                  onTap: _pickDate,
                  borderRadius: BorderRadius.circular(4),
                  child: InputDecorator(
                    decoration: InputDecoration(
                      labelText: l10n.formDate,
                      contentPadding: const EdgeInsets.symmetric(
                        horizontal: 12,
                        vertical: 12,
                      ),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(4),
                      ),
                      isDense: true,
                    ),
                    child: Text(DtFmt.shortDate(context, _date)),
                  ),
                ),
                const SizedBox(height: AppSpacing.formRowSpacing),
                // Services list
                ..._buildServiceItems(
                  services: services,
                  categories: serviceCategories,
                  variants: variants,
                  allStaff: staff,
                  forcedStaffId: forcedStaffId,
                  formFactor: formFactor,
                  conflictFlags: conflictFlags,
                  showServiceWarnings: showServiceWarnings,
                  serviceWarningMessage:
                      l10n.bookingUnavailableTimeWarningService,
                  popularServices: popularServices,
                  hasPackages: hasPackages,
                ),
                const SizedBox(height: AppSpacing.formRowSpacing),
                // Notes field
                TextFormField(
                  controller: _notesController,
                  decoration: InputDecoration(
                    labelText: l10n.formNotes,
                    alignLabelWithHint: true,
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(4),
                    ),
                  ),
                  maxLines: 3,
                  minLines: 2,
                ),
                if (statusOptions.isNotEmpty) ...[
                  const SizedBox(height: AppSpacing.formRowSpacing),
                  DropdownButtonFormField<String>(
                    value: _selectedBookingStatus,
                    isExpanded: true,
                    decoration: InputDecoration(
                      labelText: l10n.bookingsListFilterStatus,
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(4),
                      ),
                    ),
                    hint: Text(
                      _statusLabel(context, _currentBookingStatus),
                    ),
                    items: [
                      for (final status in statusOptions)
                        DropdownMenuItem<String>(
                          value: status,
                          child: Text(_statusLabel(context, status)),
                        ),
                    ],
                    onChanged: (value) {
                      setState(() => _selectedBookingStatus = value);
                    },
                  ),
                ],
                const SizedBox(height: AppSpacing.formRowSpacing),
              ],
            ),
          ),
        ),
      ),
    );

    final deleteAction = AppAsyncDangerButton(
      onPressed: _isSaving || !canManageBookings ? null : _handleDelete,
      padding: AppButtonStyles.dialogButtonPadding,
      disabled: _isSaving || !canManageBookings,
      showSpinner: false,
      child: Text(l10n.actionDelete),
    );
    final cancelAction = AppOutlinedActionButton(
      onPressed: _isSaving ? null : _handleClose,
      padding: AppButtonStyles.dialogButtonPadding,
      child: Text(l10n.actionCancel),
    );
    final rescheduleAction = AppOutlinedActionButton(
      onPressed: _isSaving || !canManageBookings ? null : _startBookingReschedule,
      padding: AppButtonStyles.dialogButtonPadding,
      child: Text(l10n.actionReschedule),
    );
    final saveAction = AppAsyncFilledButton(
      onPressed: _isSaving || !canManageBookings ? null : _onSave,
      padding: AppButtonStyles.dialogButtonPadding,
      isLoading: _isSaving && canManageBookings,
      showSpinner: false,
      child: Text(l10n.actionSave),
    );
    final actions = [deleteAction, cancelAction, rescheduleAction, saveAction];

    if (isDialog) {
      return PopScope(
        canPop: false,
        onPopInvokedWithResult: (didPop, _) async {
          if (didPop) return;
          await _handleClose();
        },
        child: Dialog(
          insetPadding: const EdgeInsets.symmetric(
            horizontal: 32,
            vertical: 24,
          ),
          child: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
            child: LocalLoadingOverlay(
              isLoading: _isSaving,
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            title,
                            style: Theme.of(context).textTheme.headlineSmall,
                          ),
                        ),
                        IconButton(
                          icon: const Icon(Icons.history),
                          tooltip: l10n.bookingHistoryTitle,
                          onPressed: () => _showHistory(context),
                        ),
                      ],
                    ),
                    const SizedBox(height: 8),
                    Flexible(child: content),
                    const SizedBox(height: AppSpacing.formToActionsSpacing),
                    Padding(
                      padding: const EdgeInsets.only(
                        bottom: AppSpacing.formFirstRowSpacing,
                      ),
                      child: _warningBanner(
                        8,
                        showAppointmentWarning,
                        l10n.bookingUnavailableTimeWarningAppointment,
                      ),
                    ),
                    OverflowBar(
                      alignment: MainAxisAlignment.end,
                      overflowAlignment: OverflowBarAlignment.end,
                      spacing: 8,
                      overflowSpacing: 8,
                      children: [
                        for (final action in actions)
                          SizedBox(
                            width: AppButtonStyles.dialogButtonWidth,
                            child: action,
                          ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      );
    }
    const horizontalPadding = 20.0;
    final isKeyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
    return PopScope(
      canPop: false,
      onPopInvokedWithResult: (didPop, _) async {
        if (didPop) return;
        await _handleClose();
      },
      child: SafeArea(
        top: false,
        left: false,
        right: false,
        child: LocalLoadingOverlay(
          isLoading: _isSaving,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            mainAxisSize: MainAxisSize.min,
            children: [
              Padding(
                padding: EdgeInsets.fromLTRB(
                  horizontalPadding,
                  0,
                  horizontalPadding,
                  12,
                ),
                child: Row(
                  children: [
                    Expanded(
                      child: Text(
                        title,
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                    ),
                    IconButton(
                      icon: const Icon(Icons.history),
                      tooltip: l10n.bookingHistoryTitle,
                      onPressed: () => _showHistory(context),
                    ),
                  ],
                ),
              ),
              Expanded(
                child: Padding(
                  padding: EdgeInsets.symmetric(horizontal: horizontalPadding),
                  child: content,
                ),
              ),
              _warningBanner(
                horizontalPadding,
                showAppointmentWarning,
                l10n.bookingUnavailableTimeWarningAppointment,
              ),
              if (!isKeyboardOpen) ...[
                const AppDivider(),
                Padding(
                  padding: EdgeInsets.fromLTRB(
                    horizontalPadding,
                    AppSpacing.formFirstRowSpacing,
                    horizontalPadding,
                    0,
                  ),
                  child: Column(
                    children: [
                      Row(
                        children: [
                          Expanded(child: cancelAction),
                          const SizedBox(width: 8),
                          Expanded(child: rescheduleAction),
                        ],
                      ),
                      const SizedBox(height: 8),
                      Row(
                        children: [
                          Expanded(child: deleteAction),
                          const SizedBox(width: 8),
                          Expanded(child: saveAction),
                        ],
                      ),
                    ],
                  ),
                ),
              ],
              SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _pickDate() async {
    final picked = await showDialog<DateTime>(
      context: context,
      builder: (context) {
        return Dialog(
          child: CalendarDatePicker(
            initialDate: _date,
            firstDate: DateTime.now().subtract(const Duration(days: 365)),
            lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
            onDateChanged: (value) => Navigator.of(context).pop(value),
          ),
        );
      },
    );
    if (picked != null) {
      setState(() => _date = DateUtils.dateOnly(picked));
    }
  }

  void _scrollFormToBottom() {
    if (!_scrollController.hasClients) return;
    _scrollController.animateTo(
      _scrollController.position.maxScrollExtent,
      duration: const Duration(milliseconds: 250),
      curve: Curves.easeOut,
    );
  }

  int? _forcedStaffIdForCurrentUser() {
    final role = ref.read(currentUserRoleProvider);
    final staffId = ref.read(currentUserStaffIdProvider);
    if (role == 'staff' && staffId != null && staffId > 0) {
      return staffId;
    }
    return null;
  }

  List<Widget> _buildServiceItems({
    required List<dynamic> services,
    required List<dynamic> categories,
    required List<dynamic> variants,
    required List<dynamic> allStaff,
    required int? forcedStaffId,
    required AppFormFactor formFactor,
    required List<bool> conflictFlags,
    required bool showServiceWarnings,
    required String serviceWarningMessage,
    required PopularServicesResult? popularServices,
    required bool hasPackages,
  }) {
    final widgets = <Widget>[];

    // Conta servizi effettivamente selezionati
    final selectedCount = _serviceItems
        .where((s) => s.serviceId != null)
        .length;

    // Calcola i serviceIds dello staff del primo appuntamento (se presente)
    // Questo permette di filtrare i servizi mostrando prima quelli dello staff corrente
    List<int>? preselectedStaffServiceIds;
    final firstItemStaffId = _serviceItems.isNotEmpty
        ? _serviceItems.first.staffId
        : null;
    if (firstItemStaffId != null) {
      final selectedStaff = allStaff.cast<dynamic>().firstWhere(
        (s) => s.id == firstItemStaffId,
        orElse: () => null,
      );
      if (selectedStaff != null) {
        preselectedStaffServiceIds = (selectedStaff.serviceIds as List<int>);
      }
    }

    for (int i = 0; i < _serviceItems.length; i++) {
      final item = forcedStaffId != null
          ? _serviceItems[i].copyWith(staffId: forcedStaffId)
          : _serviceItems[i];
      final TimeOfDay? suggestedStartTime = i > 0
          ? _resolveServiceEndTime(_serviceItems[i - 1], variants.cast())
          : null;
      final variant = item.serviceId != null
          ? variants.cast<ServiceVariant?>().firstWhere(
              (v) => v?.serviceId == item.serviceId,
              orElse: () => null,
            )
          : null;
      final defaultProcessing = variant?.processingTime ?? 0;
      final defaultBlocked = variant?.blockedTime ?? 0;
      final defaultExtraType = defaultBlocked > 0
          ? ExtraMinutesType.blocked
          : (defaultProcessing > 0 ? ExtraMinutesType.processing : null);
      final hasBlockedExtra = item.blockedExtraMinutes > 0;
      final hasProcessingExtra = item.processingExtraMinutes > 0;
      final canAddDefaultExtra = defaultExtraType == ExtraMinutesType.blocked
          ? !hasBlockedExtra
          : (defaultExtraType == ExtraMinutesType.processing
                ? !hasProcessingExtra
                : false);
      final showWarning =
          showServiceWarnings &&
          _isWarningEligible(item) &&
          i < conflictFlags.length &&
          conflictFlags[i];

      // Get eligible staff for this service
      final eligibleStaffIds = item.serviceId != null
          ? ref.watch(eligibleStaffForServiceProvider(item.serviceId!))
          : <int>[];
      final isStaffIneligible =
          item.serviceId != null &&
          item.staffId != null &&
          !eligibleStaffIds.contains(item.staffId);

      final isFirst = i == 0;
      final isLast = i == _serviceItems.length - 1;
      widgets.add(
        Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            if (isFirst) ...[
              Row(
                children: [
                  Text(
                    selectedCount > 0
                        ? context.l10n.servicesSelectedCount(selectedCount)
                        : context.l10n.formServices,
                    style: const TextStyle(fontWeight: FontWeight.w600),
                  ),
                ],
              ),
              const SizedBox(height: 8),
            ],
            Padding(
              padding: const EdgeInsets.only(bottom: 12),
              child: ServiceItemCard(
                index: i,
                item: item,
                services: services.cast(),
                categories: categories.cast(),
                variants: variants.cast(),
                eligibleStaff: eligibleStaffIds,
                allStaff: allStaff.cast(),
                formFactor: formFactor,
                canRemove: _serviceItems.length > 1,
                // Obbligatorio solo se non ci sono altri servizi selezionati
                isServiceRequired: selectedCount == 0,
                onChanged: (updated) => _updateServiceItem(
                  i,
                  updated,
                  forcedStaffId: forcedStaffId,
                ),
                onRemove: () => _removeServiceItem(i),
                onStartTimeChanged: (time) => _updateServiceStartTime(i, time),
                onEndTimeChanged: (time) => _updateServiceEndTime(i, time),
                onDurationChanged: (duration) =>
                    _updateServiceDuration(i, duration),
                suggestedStartTime: suggestedStartTime,
                autoOpenServicePicker: _autoOpenServicePickerIndex == i,
                onServicePickerAutoOpened: _autoOpenServicePickerIndex == i
                    ? () => _onServicePickerAutoOpenedForIndex(i)
                    : null,
                onServicePickerAutoCompleted: _scrollFormToBottom,
                onAutoOpenStaffPickerCompleted: _scrollFormToBottom,
                availabilityWarningMessage: showWarning
                    ? serviceWarningMessage
                    : null,
                staffEligibilityWarningMessage: isStaffIneligible
                    ? context.l10n.bookingStaffNotEligibleWarning
                    : null,
                packages: ref.read(servicePackagesProvider).value,
                popularServices: popularServices,
                onPackageSelected: (package) =>
                    _onPackageSelectedFromPicker(package, i),
                preselectedStaffServiceIds: preselectedStaffServiceIds,
                canSelectStaff: forcedStaffId == null,
              ),
            ),
            if (canAddDefaultExtra) ...[
              if (isLast && item.serviceId != null)
                Row(
                  children: [
                    AppOutlinedActionButton(
                      onPressed: () {
                        setState(() {
                          _serviceItems[i] =
                              defaultExtraType == ExtraMinutesType.blocked
                              ? _serviceItems[i].copyWith(
                                  blockedExtraMinutes: defaultBlocked,
                                )
                              : _serviceItems[i].copyWith(
                                  processingExtraMinutes: defaultProcessing,
                                );
                          _recalculateTimesFrom(i + 1, variants.cast());
                          _clearMidnightWarningIfResolved(variants.cast());
                        });
                      },
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.add, size: 18),
                          const SizedBox(width: 8),
                          Text(context.l10n.additionalTimeSwitch),
                        ],
                      ),
                    ),
                    const Spacer(),
                    AppOutlinedActionButton(
                      onPressed: _isAddingPackage ? null : _addService,
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.add, size: 18),
                          const SizedBox(width: 8),
                          Text(context.l10n.addService),
                        ],
                      ),
                    ),
                    if (hasPackages) ...[
                      const SizedBox(width: 8),
                      AppOutlinedActionButton(
                        onPressed: _isAddingPackage ? null : _addPackage,
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Icon(Icons.widgets_outlined, size: 18),
                            const SizedBox(width: 8),
                            Text(context.l10n.addPackage),
                          ],
                        ),
                      ),
                    ],
                  ],
                )
              else
                Align(
                  alignment: Alignment.centerRight,
                  child: AppOutlinedActionButton(
                    onPressed: () {
                      setState(() {
                        _serviceItems[i] =
                            defaultExtraType == ExtraMinutesType.blocked
                            ? _serviceItems[i].copyWith(
                                blockedExtraMinutes: defaultBlocked,
                              )
                            : _serviceItems[i].copyWith(
                                processingExtraMinutes: defaultProcessing,
                              );
                        _recalculateTimesFrom(i + 1, variants.cast());
                        _clearMidnightWarningIfResolved(variants.cast());
                      });
                    },
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const Icon(Icons.add, size: 18),
                        const SizedBox(width: 8),
                        Text(context.l10n.additionalTimeSwitch),
                      ],
                    ),
                  ),
                ),
              const SizedBox(height: 24),
              if (isLast &&
                  item.serviceId != null &&
                  _midnightWarningVisible &&
                  !_midnightWarningDismissed) ...[
                _midnightWarningBanner(),
                const SizedBox(height: 24),
              ],
            ],
            if (hasBlockedExtra) ...[
              ExtraTimeCard(
                title: context.l10n.fieldBlockedTimeLabel,
                startTime: _baseEndTime(item, variants.cast()),
                durationMinutes: item.blockedExtraMinutes,
                formFactor: formFactor,
                onStartTimeChanged: (_) {},
                onDurationChanged: (duration) {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      blockedExtraMinutes: duration,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                    _clearMidnightWarningIfResolved(variants.cast());
                  });
                },
                onRemove: () {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      blockedExtraMinutes: 0,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                    _clearMidnightWarningIfResolved(variants.cast());
                  });
                },
              ),
              const SizedBox(height: 8),
            ],
            if (hasProcessingExtra) ...[
              ExtraTimeCard(
                title: context.l10n.fieldProcessingTimeLabel,
                startTime: _addMinutes(
                  _baseEndTime(item, variants.cast()),
                  item.blockedExtraMinutes,
                ),
                durationMinutes: item.processingExtraMinutes,
                formFactor: formFactor,
                onStartTimeChanged: (_) {},
                onDurationChanged: (duration) {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      processingExtraMinutes: duration,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                    _clearMidnightWarningIfResolved(variants.cast());
                  });
                },
                onRemove: () {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      processingExtraMinutes: 0,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                    _clearMidnightWarningIfResolved(variants.cast());
                  });
                },
              ),
              const SizedBox(height: 8),
            ],
            if (isLast && item.serviceId != null && !canAddDefaultExtra) ...[
              Align(
                alignment: Alignment.centerRight,
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    AppOutlinedActionButton(
                      onPressed: _isAddingPackage ? null : _addService,
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.add, size: 18),
                          const SizedBox(width: 8),
                          Text(context.l10n.addService),
                        ],
                      ),
                    ),
                    if (hasPackages) ...[
                      const SizedBox(width: 8),
                      AppOutlinedActionButton(
                        onPressed: _isAddingPackage ? null : _addPackage,
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Icon(Icons.widgets_outlined, size: 18),
                            const SizedBox(width: 8),
                            Text(context.l10n.addPackage),
                          ],
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              const SizedBox(height: 8),
              if (_midnightWarningVisible && !_midnightWarningDismissed) ...[
                _midnightWarningBanner(),
                const SizedBox(height: 8),
              ],
            ],
          ],
        ),
      );
    }

    if (_serviceItems.isEmpty) {
      widgets.add(
        Container(
          padding: const EdgeInsets.all(24),
          decoration: BoxDecoration(
            border: Border.all(color: Theme.of(context).colorScheme.outline),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Center(
            child: Text(
              context.l10n.noServicesAdded,
              style: TextStyle(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ),
        ),
      );
    }

    // Riepilogo totali (solo se pi√π di un servizio)
    final selectedServices = _serviceItems
        .where((s) => s.serviceId != null)
        .toList();
    if (selectedServices.length > 1) {
      int totalDurationMinutes = 0;
      double totalPrice = 0;

      for (final item in selectedServices) {
        final variant = variants.cast<ServiceVariant?>().firstWhere(
          (v) => v?.serviceId == item.serviceId,
          orElse: () => null,
        );
        if (variant != null) {
          // Durata base + extra times
          final baseDuration = item.durationMinutes > 0
              ? item.durationMinutes
              : variant.durationMinutes;
          totalDurationMinutes +=
              baseDuration +
              item.blockedExtraMinutes +
              item.processingExtraMinutes;
          // Prezzo (usa price personalizzato o da variant)
          totalPrice += item.price ?? variant.price;
        }
      }

      final hours = totalDurationMinutes ~/ 60;
      final minutes = totalDurationMinutes % 60;
      final durationStr = hours > 0
          ? (minutes > 0 ? '${hours}h ${minutes}min' : '${hours}h')
          : '${minutes}min';

      widgets.add(
        Container(
          margin: const EdgeInsets.only(top: 16),
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.surfaceContainerHighest,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                context.l10n.bookingTotalDuration(durationStr),
                style: const TextStyle(fontWeight: FontWeight.w500),
              ),
              Text(
                context.l10n.bookingTotalPrice(
                  PriceFormatter.format(
                    context: context,
                    amount: totalPrice,
                    currencyCode: PriceFormatter.effectiveCurrency(ref),
                  ),
                ),
                style: const TextStyle(fontWeight: FontWeight.w600),
              ),
            ],
          ),
        ),
      );
    }

    return widgets;
  }

  Widget _warningBanner(
    double horizontalPadding,
    bool hasConflicts,
    String message,
  ) {
    if (!hasConflicts || _warningDismissed) return const SizedBox.shrink();
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.amber.withOpacity(0.18),
        borderRadius: BorderRadius.circular(8),
      ),
      padding: EdgeInsets.fromLTRB(
        horizontalPadding,
        12,
        horizontalPadding,
        12,
      ),
      child: Row(
        children: [
          const Icon(
            Icons.warning_amber_rounded,
            color: Colors.amber,
            size: 20,
          ),
          const SizedBox(width: 10),
          Expanded(
            child: Text(
              message,
              style: const TextStyle(
                color: Color(0xFF8A4D00),
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          IconButton(
            icon: const Icon(Icons.close, size: 18),
            color: const Color(0xFF8A4D00),
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints.tightFor(width: 32, height: 32),
            onPressed: () {
              setState(() => _warningDismissed = true);
            },
          ),
        ],
      ),
    );
  }

  Widget _midnightWarningBanner() {
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.amber.withOpacity(0.18),
        borderRadius: BorderRadius.circular(8),
      ),
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
      child: Row(
        children: [
          const Icon(
            Icons.warning_amber_rounded,
            color: Colors.amber,
            size: 20,
          ),
          const SizedBox(width: 10),
          Expanded(
            child: Text(
              context.l10n.serviceStartsAfterMidnight,
              style: const TextStyle(
                color: Color(0xFF8A4D00),
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          IconButton(
            icon: const Icon(Icons.close, size: 18),
            color: const Color(0xFF8A4D00),
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints.tightFor(width: 32, height: 32),
            onPressed: () {
              setState(() => _midnightWarningDismissed = true);
            },
          ),
        ],
      ),
    );
  }

  void _showMidnightWarning() {
    setState(() {
      _midnightWarningVisible = true;
      _midnightWarningDismissed = false;
    });
  }

  void _clearMidnightWarningIfResolved(List<ServiceVariant> variants) {
    if (!_midnightWarningVisible) return;
    if (!_hasMidnightOverflow(variants)) {
      _midnightWarningVisible = false;
      _midnightWarningDismissed = false;
    }
  }

  bool _hasMidnightOverflow(List<ServiceVariant> variants) {
    for (final item in _serviceItems) {
      final startMinutes = item.startTime.hour * 60 + item.startTime.minute;
      final endTime = _resolveServiceEndTime(item, variants);
      final endMinutes = endTime.hour * 60 + endTime.minute;
      if (endMinutes < startMinutes) return true;
    }
    return false;
  }

  bool _isWarningEligible(ServiceItemData item) {
    return item.serviceId != null && item.staffId != null;
  }

  List<bool> _serviceConflictFlags() {
    final layout = ref.watch(layoutConfigProvider);
    final Map<int, Set<int>> cache = {};
    final flags = <bool>[];

    for (final item in _serviceItems) {
      final staffId = item.staffId;
      if (staffId == null || item.serviceId == null) {
        flags.add(false);
        continue;
      }

      final available = cache.putIfAbsent(
        staffId,
        () => ref.watch(staffSlotAvailabilityProvider(staffId)),
      );

      if (available.isEmpty) {
        flags.add(true);
        continue;
      }

      final startMinutes = item.startTime.hour * 60 + item.startTime.minute;
      final endMinutes = startMinutes + item.durationMinutes;
      final startSlot = startMinutes ~/ layout.minutesPerSlot;
      final endSlot = (endMinutes / layout.minutesPerSlot).ceil();

      var hasConflict = false;
      for (int slot = startSlot; slot < endSlot; slot++) {
        if (!available.contains(slot)) {
          hasConflict = true;
          break;
        }
      }
      flags.add(hasConflict);
    }
    return flags;
  }

  void _addService() {
    final variants = ref.read(serviceVariantsProvider).value ?? [];
    // Calcola l'orario di inizio per il nuovo servizio
    TimeOfDay nextStart;
    if (_serviceItems.isEmpty) {
      // Caso raro: usa l'orario dell'appuntamento originale
      nextStart = TimeOfDay.fromDateTime(widget.initial.startTime);
    } else {
      // Prendi l'ultimo servizio e calcola il suo orario di fine
      final lastItem = _serviceItems.last;
      final lastStartMinutes =
          lastItem.startTime.hour * 60 + lastItem.startTime.minute;
      final lastEnd = _resolveServiceEndTime(lastItem, variants);
      final lastEndMinutes = lastEnd.hour * 60 + lastEnd.minute;

      // Blocca se il servizio precedente termina dopo la mezzanotte
      if (lastEndMinutes < lastStartMinutes) {
        _showMidnightWarning();
        return;
      }
      nextStart = lastEnd;
    }

    // Smart staff selection: usa lo staff dell'ultimo servizio aggiunto
    int? smartStaffId = _serviceItems.isNotEmpty
        ? _serviceItems.last.staffId
        : widget.initial.staffId;

    final newIndex = _serviceItems.length;
    setState(() {
      _clearMidnightWarningIfResolved(variants.cast());
      _serviceItems.add(
        ServiceItemData(
          key: _nextItemKey(),
          startTime: nextStart,
          staffId: smartStaffId,
        ),
      );
      _autoOpenServicePickerIndex = newIndex;
    });
  }

  Future<void> _addPackage() async {
    if (_isAddingPackage) return;

    final l10n = context.l10n;
    final packages = ref.read(servicePackagesProvider).value ?? [];
    if (packages.isEmpty) {
      if (!context.mounted) return;
      await FeedbackDialog.showError(
        context,
        title: l10n.errorTitle,
        message: l10n.servicePackagesEmptyState,
      );
      return;
    }

    setState(() => _isAddingPackage = true);
    final selected = await showServicePackagePickerDialog(
      context,
      packages: packages,
    );
    if (!context.mounted) return;
    if (selected == null) {
      setState(() => _isAddingPackage = false);
      return;
    }

    try {
      final locationId = ref.read(currentLocationProvider).id;
      final repository = ref.read(servicePackagesRepositoryProvider);
      final expansion = await repository.expandPackage(
        locationId: locationId,
        packageId: selected.id,
      );
      if (expansion.serviceIds.isEmpty) {
        if (!mounted) return;
        await FeedbackDialog.showError(
          context,
          title: l10n.errorTitle,
          message: l10n.servicePackageExpandError,
        );
      } else {
        _appendServicesFromPackage(expansion.serviceIds);
      }
    } catch (_) {
      if (!mounted) return;
      await FeedbackDialog.showError(
        context,
        title: l10n.errorTitle,
        message: l10n.servicePackageExpandError,
      );
    } finally {
      if (mounted) {
        setState(() => _isAddingPackage = false);
      }
    }
  }

  /// Called when a package is selected from the service picker.
  /// This expands the package and replaces the current empty service slot.
  Future<void> _onPackageSelectedFromPicker(
    ServicePackage package,
    int currentIndex,
  ) async {
    if (_isAddingPackage) return;

    final l10n = context.l10n;
    setState(() => _isAddingPackage = true);

    try {
      final locationId = ref.read(currentLocationProvider).id;
      final repository = ref.read(servicePackagesRepositoryProvider);
      final expansion = await repository.expandPackage(
        locationId: locationId,
        packageId: package.id,
      );
      if (expansion.serviceIds.isEmpty) {
        if (!mounted) return;
        await FeedbackDialog.showError(
          context,
          title: l10n.errorTitle,
          message: l10n.servicePackageExpandError,
        );
      } else {
        // Capture staff from current slot before removing it
        int? staffIdFromSlot;
        if (_serviceItems.isNotEmpty && currentIndex < _serviceItems.length) {
          staffIdFromSlot = _serviceItems[currentIndex].staffId;
        }
        // Check if we need to remove empty slot
        final shouldRemoveEmpty =
            _serviceItems.isNotEmpty &&
            currentIndex < _serviceItems.length &&
            _serviceItems[currentIndex].serviceId == null;
        // Pass the captured staff and removal index to do everything in one setState
        _appendServicesFromPackage(
          expansion.serviceIds,
          overrideStaffId: staffIdFromSlot,
          removeEmptyAtIndex: shouldRemoveEmpty ? currentIndex : null,
        );
      }
    } catch (_) {
      if (!mounted) return;
      await FeedbackDialog.showError(
        context,
        title: l10n.errorTitle,
        message: l10n.servicePackageExpandError,
      );
    } finally {
      if (mounted) {
        setState(() => _isAddingPackage = false);
      }
    }
  }

  /// Appends services from a package.
  /// If [overrideStaffId] is provided, it will be used for ALL services.
  /// Otherwise, uses smart staff selection (last item's staff or initial).
  /// If [removeEmptyAtIndex] is provided, removes the empty slot at that index
  /// before appending (all in one setState to avoid visual flash).
  void _appendServicesFromPackage(
    List<int> serviceIds, {
    int? overrideStaffId,
    int? removeEmptyAtIndex,
  }) {
    final variants = ref.read(serviceVariantsProvider).value ?? [];

    setState(() {
      // Remove empty slot first if requested (before calculating staff)
      if (removeEmptyAtIndex != null &&
          _serviceItems.isNotEmpty &&
          removeEmptyAtIndex < _serviceItems.length &&
          _serviceItems[removeEmptyAtIndex].serviceId == null) {
        _serviceItems.removeAt(removeEmptyAtIndex);
      }

      // Calculate staff ONCE before the loop to use the same for all services
      final staffIdForAll =
          overrideStaffId ??
          (_serviceItems.isNotEmpty
              ? _serviceItems.last.staffId
              : widget.initial.staffId);

      for (final serviceId in serviceIds) {
        TimeOfDay nextStart;
        if (_serviceItems.isEmpty) {
          nextStart = TimeOfDay.fromDateTime(widget.initial.startTime);
        } else {
          final lastItem = _serviceItems.last;
          final lastStartMinutes =
              lastItem.startTime.hour * 60 + lastItem.startTime.minute;
          final lastEnd = _resolveServiceEndTime(lastItem, variants);
          final lastEndMinutes = lastEnd.hour * 60 + lastEnd.minute;

          if (lastEndMinutes < lastStartMinutes) {
            _showMidnightWarning();
            break;
          }
          nextStart = lastEnd;
        }

        final variant = variants
            .where((v) => v.serviceId == serviceId)
            .firstOrNull;
        final duration = variant?.durationMinutes ?? 30;

        _serviceItems.add(
          ServiceItemData(
            key: _nextItemKey(),
            serviceId: serviceId,
            serviceVariantId: variant?.id,
            startTime: nextStart,
            durationMinutes: duration,
            staffId: staffIdForAll,
            blockedExtraMinutes: variant?.blockedTime ?? 0,
            processingExtraMinutes: variant?.processingTime ?? 0,
          ),
        );
      }

      _clearMidnightWarningIfResolved(variants.cast());
    });
  }

  void _onServicePickerAutoOpenedForIndex(int index) {
    if (_autoOpenServicePickerIndex != index) return;
    setState(() {
      _autoOpenServicePickerIndex = null;
    });
  }

  void _removeServiceItem(int index) {
    if (_serviceItems.length <= 1) return;

    final variants = ref.read(serviceVariantsProvider).value ?? [];

    setState(() {
      _serviceItems.removeAt(index);

      // Ricalcola gli orari per i servizi successivi
      _recalculateTimesFrom(index, variants);
      _clearMidnightWarningIfResolved(variants.cast());
    });
  }

  void _updateServiceItem(
    int index,
    ServiceItemData updated, {
    int? forcedStaffId,
  }) {
    final variants = ref.read(serviceVariantsProvider).value ?? [];
    final oldItem = _serviceItems[index];
    final effectiveUpdated = forcedStaffId != null
        ? updated.copyWith(staffId: forcedStaffId)
        : updated;

    setState(() {
      _serviceItems[index] = effectiveUpdated;

      // Se cambia il servizio, potremmo dover aggiornare lo staff
      // e ricalcolare gli orari successivi
      _recalculateTimesFrom(index + 1, variants);

      // Se lo staff √® ancora null, seleziona automaticamente un eligible
      if (effectiveUpdated.serviceId != null &&
          effectiveUpdated.staffId == null) {
        final newStaffId = _findBestStaff(effectiveUpdated.serviceId!);
        _serviceItems[index] = effectiveUpdated.copyWith(staffId: newStaffId);
      }

      // Propagate staff to subsequent services that don't have a staff yet
      // This is useful when user selects staff on first service of a package
      if (effectiveUpdated.staffId != null &&
          oldItem.staffId != effectiveUpdated.staffId) {
        for (var i = index + 1; i < _serviceItems.length; i++) {
          if (forcedStaffId != null || _serviceItems[i].staffId == null) {
            _serviceItems[i] = _serviceItems[i].copyWith(
              staffId: effectiveUpdated.staffId,
            );
          }
        }
      }

      _clearMidnightWarningIfResolved(variants.cast());
    });
  }

  void _updateServiceStartTime(int index, TimeOfDay newTime) {
    final variants = ref.read(serviceVariantsProvider).value ?? [];
    if (index > 0) {
      final prev = _serviceItems[index - 1];
      final prevStartMinutes = prev.startTime.hour * 60 + prev.startTime.minute;
      final prevEnd = _resolveServiceEndTime(prev, variants);
      final prevEndMinutes = prevEnd.hour * 60 + prevEnd.minute;
      if (prevEndMinutes < prevStartMinutes) {
        _showMidnightWarning();
        return;
      }
    }

    setState(() {
      final updated = _serviceItems[index].copyWith(startTime: newTime);
      _serviceItems[index] = _applyAutoExtraStart(updated, variants);

      // Ricalcola gli orari per i servizi successivi
      _recalculateTimesFrom(index + 1, variants);
      _clearMidnightWarningIfResolved(variants.cast());
    });
  }

  void _updateServiceEndTime(int index, TimeOfDay newEndTime) {
    setState(() {
      final item = _serviceItems[index];

      // Calcola la nuova durata basata sulla differenza tra end e start
      final startMinutes = item.startTime.hour * 60 + item.startTime.minute;
      final endMinutes = newEndTime.hour * 60 + newEndTime.minute;
      var newDuration = endMinutes - startMinutes;

      // Se la durata √® negativa o zero, imposta un minimo di 15 minuti
      if (newDuration <= 0) {
        newDuration = 15;
      }

      _serviceItems[index] = item.copyWith(durationMinutes: newDuration);

      // Ricalcola gli orari per i servizi successivi
      final variants = ref.read(serviceVariantsProvider).value ?? [];
      _serviceItems[index] = _applyAutoExtraStart(
        _serviceItems[index],
        variants,
      );
      _recalculateTimesFrom(index + 1, variants);
      _clearMidnightWarningIfResolved(variants.cast());
    });
  }

  void _updateServiceDuration(int index, int newDuration) {
    setState(() {
      _serviceItems[index] = _serviceItems[index].copyWith(
        durationMinutes: newDuration,
      );

      // Ricalcola gli orari per i servizi successivi
      final variants = ref.read(serviceVariantsProvider).value ?? [];
      _serviceItems[index] = _applyAutoExtraStart(
        _serviceItems[index],
        variants,
      );
      _recalculateTimesFrom(index + 1, variants);
      _clearMidnightWarningIfResolved(variants.cast());
    });
  }

  void _recalculateTimesFrom(int fromIndex, List<ServiceVariant> variants) {
    if (fromIndex <= 0 || fromIndex >= _serviceItems.length) return;

    for (int i = fromIndex; i < _serviceItems.length; i++) {
      final prevItem = _serviceItems[i - 1];
      final prevEnd = _resolveServiceEndTime(prevItem, variants);
      final updated = _serviceItems[i].copyWith(startTime: prevEnd);
      _serviceItems[i] = _applyAutoExtraStart(updated, variants);
    }
  }

  TimeOfDay _resolveServiceEndTime(
    ServiceItemData item,
    List<ServiceVariant> variants,
  ) {
    final baseEnd = _baseEndTime(item, variants);
    final totalExtra = item.blockedExtraMinutes + item.processingExtraMinutes;
    if (totalExtra <= 0) {
      return baseEnd;
    }
    return _addMinutes(baseEnd, totalExtra);
  }

  ServiceItemData _applyAutoExtraStart(
    ServiceItemData item,
    List<ServiceVariant> variants,
  ) {
    return item;
  }

  TimeOfDay _baseEndTime(ServiceItemData item, List<ServiceVariant> variants) {
    final variant = _variantForItem(item, variants);
    final baseDuration = item.durationMinutes > 0
        ? item.durationMinutes
        : (variant?.durationMinutes ?? 30);
    return item.getEndTime(baseDuration);
  }

  ServiceVariant? _variantForItem(
    ServiceItemData item,
    List<ServiceVariant> variants,
  ) {
    if (item.serviceVariantId != null) {
      for (final v in variants) {
        if (v.id == item.serviceVariantId) return v;
      }
    }
    if (item.serviceId != null) {
      for (final v in variants) {
        if (v.serviceId == item.serviceId) return v;
      }
    }
    return null;
  }

  TimeOfDay _addMinutes(TimeOfDay time, int minutes) {
    final totalMinutes = time.hour * 60 + time.minute + minutes;
    return TimeOfDay(
      hour: (totalMinutes ~/ 60) % 24,
      minute: totalMinutes % 60,
    );
  }

  /// Trova lo staff migliore per un servizio:
  /// 1. Primo staff eligible disponibile
  /// 2. null per selezione manuale
  int? _findBestStaff(int serviceId) {
    final eligibleIds = ref.read(eligibleStaffForServiceProvider(serviceId));
    if (eligibleIds.isEmpty) return null;
    return eligibleIds.first;
  }

  Future<void> _onSave() async {
    final canManageBookings = ref.read(currentUserCanManageBookingsProvider);
    if (!canManageBookings) return;
    final forcedStaffId = _forcedStaffIdForCurrentUser();

    final l10n = context.l10n;
    if (!_formKey.currentState!.validate()) return;

    // Verifica che ci sia almeno un servizio selezionato
    // Filtra anche serviceId == 0 (dati corrotti nel DB)
    final validItems = _serviceItems
        .where(
          (item) =>
              item.serviceId != null &&
              item.serviceId! > 0 &&
              item.staffId != null,
        )
        .map(
          (item) => forcedStaffId != null
              ? item.copyWith(staffId: forcedStaffId)
              : item,
        )
        .toList();

    if (validItems.isEmpty) {
      await FeedbackDialog.showError(
        context,
        title: l10n.errorTitle,
        message: l10n.validationRequired,
      );
      return;
    }

    setState(() => _isSaving = true);
    try {
      final variants = ref.read(serviceVariantsProvider).value ?? [];
      final services = ref.read(servicesProvider).value ?? [];

      // Client info (pu√≤ essere null se nessun cliente √® associato)
      final int? clientId = _clientId;
      final String clientName = _clientName.trim();
      final String? notes = _notesController.text.trim().isEmpty
          ? null
          : _notesController.text.trim();

      // Modifica appuntamento esistente
      final bookingId = widget.initial.bookingId;

      // Ottieni gli appuntamenti esistenti per questa prenotazione
      final existingAppointments = ref
          .read(appointmentsProvider.notifier)
          .getByBookingId(bookingId);

      // Verifica se il cliente √® cambiato (aggiunto, rimosso, o sostituito)
      final initialClientId = widget.initial.clientId;
      final clientChanged = initialClientId != clientId;

      // Se il cliente √® cambiato, conferma l'applicazione a tutti gli appuntamenti
      if (clientChanged) {
        // Verifica se ci sono appuntamenti con staff diversi
        final currentStaffId = _serviceItems.isNotEmpty
            ? _serviceItems.first.staffId
            : widget.initial.staffId;
        final hasOtherStaff = existingAppointments.any(
          (a) => a.staffId != currentStaffId,
        );

        // Mostra conferma SOLO se ci sono appuntamenti assegnati ad altri operatori
        if (hasOtherStaff && mounted) {
          final confirmed = await showDialog<bool>(
            context: context,
            builder: (_) => AlertDialog(
              title: Text(l10n.applyClientToAllAppointmentsTitle),
              content: Text(l10n.applyClientToAllAppointmentsMessage),
              actions: [
                TextButton(
                  onPressed: () => Navigator.pop(context, false),
                  child: Text(l10n.actionCancel),
                ),
                TextButton(
                  onPressed: () => Navigator.pop(context, true),
                  child: Text(l10n.actionConfirm),
                ),
              ],
            ),
          );

          if (confirmed != true) {
            // Utente ha annullato, non salvare
            return;
          }
        }
      }

      // Aggiorna tutti i servizi
      final existingIds = existingAppointments.map((a) => a.id).toSet();
      final processedIds = <int>{};
      Appointment? scrollTarget;

      for (int i = 0; i < validItems.length; i++) {
        final item = validItems[i];

        final selectedVariant = variants.firstWhere(
          (v) => v.serviceId == item.serviceId,
        );
        final service = services.firstWhere((s) => s.id == item.serviceId);
        final serviceName = service.name;
        final serviceId = service.id;

        final blockedExtraMinutes = item.blockedExtraMinutes;
        final processingExtraMinutes = item.processingExtraMinutes;
        final extraMinutesType = blockedExtraMinutes > 0
            ? ExtraMinutesType.blocked
            : (processingExtraMinutes > 0 ? ExtraMinutesType.processing : null);
        final extraMinutes = extraMinutesType == ExtraMinutesType.blocked
            ? blockedExtraMinutes
            : (extraMinutesType == ExtraMinutesType.processing
                  ? processingExtraMinutes
                  : 0);
        // Usa prezzo personalizzato se presente, altrimenti prezzo variante
        final effectivePrice =
            item.price ??
            (selectedVariant.isFree ? null : selectedVariant.price);

        final start = DateTime(
          _date.year,
          _date.month,
          _date.day,
          item.startTime.hour,
          item.startTime.minute,
        );

        final baseDuration = item.durationMinutes > 0
            ? item.durationMinutes
            : selectedVariant.durationMinutes;
        final duration =
            baseDuration + (blockedExtraMinutes > 0 ? blockedExtraMinutes : 0);
        final end = start.add(Duration(minutes: duration));

        // Usa appointmentId per determinare se aggiornare o creare
        if (item.appointmentId != null) {
          // Aggiorna appuntamento esistente usando l'ID memorizzato
          final existing = existingAppointments.firstWhere(
            (a) => a.id == item.appointmentId,
          );
          processedIds.add(existing.id);

          final updated = existing.copyWith(
            staffId: item.staffId!,
            serviceId: serviceId,
            serviceVariantId: selectedVariant.id,
            clientId: clientId,
            clientName: clientName,
            serviceName: serviceName,
            startTime: start,
            endTime: end,
            price: effectivePrice,
            extraMinutes: extraMinutes,
            extraMinutesType: extraMinutesType,
            extraBlockedMinutes: blockedExtraMinutes,
            extraProcessingMinutes: processingExtraMinutes,
          );
          await ref
              .read(appointmentsProvider.notifier)
              .updateAppointment(updated);
          scrollTarget ??= updated;
        } else {
          // Crea nuovo appuntamento (aggiunto durante la modifica)
          final created = await ref
              .read(appointmentsProvider.notifier)
              .addAppointment(
                bookingId: bookingId,
                staffId: item.staffId!,
                serviceId: serviceId,
                serviceVariantId: selectedVariant.id,
                clientId: clientId,
                clientName: clientName,
                serviceName: serviceName,
                start: start,
                end: end,
                price: effectivePrice,
                extraMinutes: extraMinutes,
                extraMinutesType: extraMinutesType,
                extraBlockedMinutes: blockedExtraMinutes,
                extraProcessingMinutes: processingExtraMinutes,
              );
          scrollTarget ??= created;
        }
      }

      // Elimina appuntamenti rimossi (quelli in existingIds ma non in processedIds)
      for (final id in existingIds.difference(processedIds)) {
        ref.read(appointmentsProvider.notifier).deleteAppointment(id);
      }

      // Aggiorna le note nella booking associata
      ref.read(bookingsProvider.notifier).setNotes(bookingId, notes);

      // Aggiorna stato prenotazione solo se selezionato e diverso dall'attuale.
      if (_selectedBookingStatus != null &&
          _selectedBookingStatus != _currentBookingStatus) {
        final location = ref.read(currentLocationProvider);
        final repository = ref.read(bookingsRepositoryProvider);
        await repository.updateBooking(
          locationId: location.id,
          bookingId: bookingId,
          status: _selectedBookingStatus,
        );
        ref
            .read(bookingsProvider.notifier)
            .setStatus(bookingId, _selectedBookingStatus!);
        ref
            .read(appointmentsProvider.notifier)
            .setBookingStatusForBooking(
              bookingId: bookingId,
              status: _selectedBookingStatus!,
            );
      }

      // Rimuovi la booking se vuota
      ref.read(bookingsProvider.notifier).removeIfEmpty(bookingId);

      if (scrollTarget != null) {
        ref.read(agendaScrollRequestProvider.notifier).request(scrollTarget);
      }
      if (mounted) {
        Navigator.of(context).pop();
      }
    } catch (error) {
      if (mounted) {
        final message = error is ApiException ? error.message : l10n.errorTitle;
        await FeedbackDialog.showError(
          context,
          title: l10n.errorTitle,
          message: message,
        );
      }
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }
  }
}

class _ClientItem {
  final int id;
  final String name;
  const _ClientItem(this.id, this.name);
}

/// Widget per la selezione del cliente con link cliccabile e hint
class _ClientSelectionField extends ConsumerWidget {
  const _ClientSelectionField({
    required this.clientId,
    required this.clientName,
    required this.clients,
    required this.onClientSelected,
    required this.onClientRemoved,
    this.isLocked = false,
  });

  final int? clientId;
  final String clientName;
  final List<Client> clients;
  final void Function(int? id, String name) onClientSelected;
  final VoidCallback onClientRemoved;
  final bool isLocked;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final hasClient = clientId != null || clientName.isNotEmpty;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          l10n.formClient,
          style: const TextStyle(fontWeight: FontWeight.w600),
        ),
        const SizedBox(height: 6),
        if (hasClient)
          _SelectedClientTile(
            clientName: clientName,
            onTap: isLocked ? null : () => _showClientPicker(context, ref),
            onRemove: isLocked ? null : onClientRemoved,
          )
        else
          InkWell(
            onTap: isLocked ? null : () => _showClientPicker(context, ref),
            borderRadius: BorderRadius.circular(8),
            child: Container(
              width: double.infinity,
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 14),
              decoration: BoxDecoration(
                border: Border.all(
                  color: isLocked
                      ? theme.colorScheme.outline.withOpacity(0.5)
                      : theme.colorScheme.outline,
                ),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.person_add_outlined,
                    size: 20,
                    color: isLocked
                        ? theme.colorScheme.onSurfaceVariant
                        : theme.colorScheme.primary,
                  ),
                  const SizedBox(width: 8),
                  Text(
                    l10n.addClientToAppointment,
                    style: TextStyle(
                      color: isLocked
                          ? theme.colorScheme.onSurfaceVariant
                          : theme.colorScheme.primary,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            ),
          ),
        const SizedBox(height: 6),
        Text(
          isLocked ? l10n.clientLockedHint : l10n.clientOptionalHint,
          style: theme.textTheme.bodySmall?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
      ],
    );
  }

  Future<void> _showClientPicker(BuildContext context, WidgetRef ref) async {
    while (true) {
      final result = await AppBottomSheet.show<_ClientItem?>(
        context: context,
        useRootNavigator: true,
        padding: EdgeInsets.zero,
        heightFactor: AppBottomSheet.defaultHeightFactor,
        builder: (ctx) =>
            _ClientPickerSheet(clients: clients, selectedClientId: clientId),
      );
      if (result == null) {
        // Sheet dismissed without selection, do nothing
        return;
      }
      if (result.id == -2) {
        // "Create new client" was selected
        // result.name contains the search query to pre-populate the form
        if (context.mounted) {
          Client? initialClient;
          if (result.name.isNotEmpty) {
            // Split the search query into first name and last name
            final nameParts = Client.splitFullName(result.name);
            initialClient = Client(
              id: 0,
              businessId: 0,
              firstName: nameParts.firstName,
              lastName: nameParts.lastName,
              createdAt: DateTime.now(),
            );
          }
          final newClient = await showClientEditDialog(
            context,
            ref,
            client: initialClient,
          );
          if (newClient != null) {
            // Client saved, select it and return to appointment form
            onClientSelected(newClient.id, newClient.name);
            return;
          }
          // Client creation cancelled, loop back to show picker again
          continue;
        }
        return;
      } else if (result.id == -1) {
        // "No client for appointment" was selected
        onClientRemoved();
        return;
      } else {
        onClientSelected(result.id, result.name);
        return;
      }
    }
  }
}

/// Tile che mostra il cliente selezionato con opzione per rimuoverlo
class _SelectedClientTile extends StatelessWidget {
  const _SelectedClientTile({
    required this.clientName,
    this.onTap,
    this.onRemove,
  });

  final String clientName;
  final VoidCallback? onTap;
  final VoidCallback? onRemove;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isLocked = onTap == null && onRemove == null;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
        decoration: BoxDecoration(
          border: Border.all(
            color: isLocked
                ? theme.colorScheme.outline.withOpacity(0.5)
                : theme.colorScheme.outline,
          ),
          borderRadius: BorderRadius.circular(8),
          color: isLocked ? theme.colorScheme.surfaceContainerLow : null,
        ),
        child: Row(
          children: [
            StaffCircleAvatar(
              height: 32,
              color: theme.colorScheme.primary,
              isHighlighted: false,
              initials: clientName.isNotEmpty
                  ? initialsFromName(clientName, maxChars: 2)
                  : '?',
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
                clientName,
                style: TextStyle(
                  fontWeight: FontWeight.w500,
                  color: isLocked ? theme.colorScheme.onSurfaceVariant : null,
                ),
              ),
            ),
            if (onRemove != null)
              IconButton(
                icon: Icon(
                  Icons.close,
                  size: 20,
                  color: theme.colorScheme.error,
                ),
                onPressed: onRemove,
                tooltip: context.l10n.removeClient,
                padding: EdgeInsets.zero,
                constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
              )
            else if (isLocked)
              Icon(
                Icons.lock_outline,
                size: 18,
                color: theme.colorScheme.onSurfaceVariant.withOpacity(0.6),
              ),
          ],
        ),
      ),
    );
  }
}

/// Bottom sheet per la selezione del cliente
class _ClientPickerSheet extends ConsumerStatefulWidget {
  const _ClientPickerSheet({required this.clients, this.selectedClientId});

  /// Initial clients list (not used anymore, kept for API compatibility)
  final List<Client> clients;
  final int? selectedClientId;

  @override
  ConsumerState<_ClientPickerSheet> createState() => _ClientPickerSheetState();
}

class _ClientPickerSheetState extends ConsumerState<_ClientPickerSheet> {
  final _searchController = TextEditingController();
  final _searchFocusNode = FocusNode();

  @override
  void initState() {
    super.initState();
    // Auto-focus sul campo di ricerca dopo il primo build
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        _searchFocusNode.requestFocus();
      }
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    _searchFocusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    // Watch the search state from provider
    final searchState = ref.watch(clientPickerSearchProvider);
    final clients = searchState.clients;
    final isLoading = searchState.isLoading;

    return SafeArea(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 16, 16, 12),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  l10n.selectClientTitle,
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: AppSpacing.formFirstRowSpacing),
                // Search field
                TextField(
                  controller: _searchController,
                  focusNode: _searchFocusNode,
                  decoration: InputDecoration(
                    hintText: l10n.searchClientPlaceholder,
                    prefixIcon: const Icon(Icons.search, size: 20),
                    suffixIcon: isLoading
                        ? const Padding(
                            padding: EdgeInsets.all(12),
                            child: SizedBox(
                              width: 16,
                              height: 16,
                              child: CircularProgressIndicator(strokeWidth: 2),
                            ),
                          )
                        : null,
                    border: const OutlineInputBorder(),
                    isDense: true,
                    contentPadding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 10,
                    ),
                  ),
                  onChanged: (value) {
                    ref
                        .read(clientPickerSearchProvider.notifier)
                        .setSearchQuery(value);
                  },
                ),
              ],
            ),
          ),
          const AppDivider(),
          // Quick actions: Create new client / No client
          ListTile(
            leading: StaffCircleAvatar(
              height: 32,
              color: theme.colorScheme.onSurfaceVariant,
              isHighlighted: false,
              initials: '',
              child: Icon(
                Icons.person_add_outlined,
                color: theme.colorScheme.onSurface,
                size: 18,
              ),
            ),
            title: Text(l10n.createNewClient),
            onTap: () {
              // Use special marker with id = -2 to indicate "create new client"
              // Pass search query in name field to pre-populate the form
              Navigator.of(
                context,
              ).pop(_ClientItem(-2, _searchController.text.trim()));
            },
          ),
          ListTile(
            leading: StaffCircleAvatar(
              height: 32,
              color: theme.colorScheme.onSurfaceVariant,
              isHighlighted: false,
              initials: '',
              child: Icon(
                Icons.person_off_outlined,
                color: theme.colorScheme.onSurface,
                size: 18,
              ),
            ),
            title: Text(l10n.noClientForAppointment),
            onTap: () {
              // Use special marker with id = -1 to indicate "no client"
              Navigator.of(context).pop(const _ClientItem(-1, ''));
            },
          ),
          const AppDivider(),
          // Client list
          Expanded(
            child: isLoading && clients.isEmpty
                ? const Center(child: CircularProgressIndicator())
                : clients.isEmpty
                ? Center(
                    child: Text(
                      l10n.clientsEmpty,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                  )
                : ListView.builder(
                    padding: const EdgeInsets.only(bottom: 8),
                    itemCount: clients.length,
                    itemBuilder: (context, index) {
                      final client = clients[index];
                      final isSelected = client.id == widget.selectedClientId;
                      return ListTile(
                        leading: StaffCircleAvatar(
                          height: 32,
                          color: theme.colorScheme.primary,
                          isHighlighted: isSelected,
                          initials: client.name.isNotEmpty
                              ? initialsFromName(client.name, maxChars: 2)
                              : '?',
                        ),
                        title: Text(client.name),
                        subtitle: client.phone != null
                            ? Text(
                                client.phone!,
                                style: theme.textTheme.bodySmall,
                              )
                            : null,
                        trailing: isSelected
                            ? Icon(
                                Icons.check_circle,
                                color: theme.colorScheme.primary,
                              )
                            : null,
                        onTap: () {
                          Navigator.of(
                            context,
                          ).pop(_ClientItem(client.id, client.name));
                        },
                      );
                    },
                  ),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/widgets/service_item_card.dart ---
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../core/l10n/date_time_formats.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/popular_service.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';
import '../../../../core/models/service_package.dart';
import '../../../../core/models/service_variant.dart';
import '../../../../core/models/staff.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../domain/config/layout_config.dart';
import '../../domain/service_item_data.dart';
import 'service_picker_field.dart';

String _formatExtraDuration(int minutes) {
  if (minutes < 60) {
    return '$minutes min';
  }
  final hours = minutes ~/ 60;
  final mins = minutes % 60;
  if (mins == 0) {
    return '$hours h';
  }
  return '$hours h $mins min';
}

/// Card per visualizzare e modificare un singolo servizio nella prenotazione.
class ServiceItemCard extends ConsumerStatefulWidget {
  const ServiceItemCard({
    super.key,
    required this.item,
    required this.index,
    required this.services,
    required this.categories,
    required this.variants,
    required this.eligibleStaff,
    required this.allStaff,
    required this.formFactor,
    required this.onChanged,
    required this.onRemove,
    required this.onStartTimeChanged,
    required this.onEndTimeChanged,
    required this.onDurationChanged,
    this.packages,
    this.popularServices,
    this.onPackageSelected,
    this.suggestedStartTime,
    this.canRemove = true,
    this.isServiceRequired = true,
    this.autoOpenServicePicker = false,
    this.onServicePickerAutoOpened,
    this.onServicePickerAutoCompleted,
    this.onAutoOpenStaffPickerCompleted,
    this.availabilityWarningMessage,
    this.staffEligibilityWarningMessage,
    this.preselectedStaffServiceIds,
    this.canSelectStaff = true,
  });

  final ServiceItemData item;
  final int index;
  final List<Service> services;
  final List<ServiceCategory> categories;
  final List<ServiceVariant> variants;
  final List<int> eligibleStaff; // Staff IDs abilitati per il servizio corrente
  final List<Staff> allStaff;
  final AppFormFactor formFactor;
  final ValueChanged<ServiceItemData> onChanged;
  final VoidCallback onRemove;
  final ValueChanged<TimeOfDay> onStartTimeChanged;
  final ValueChanged<TimeOfDay> onEndTimeChanged;
  final ValueChanged<int> onDurationChanged;

  /// Optional packages to show in the service picker.
  final List<ServicePackage>? packages;

  /// Servizi pi√π prenotati (top 5) per la location corrente.
  final PopularServicesResult? popularServices;

  /// Callback when a package is selected from the picker.
  final ValueChanged<ServicePackage>? onPackageSelected;

  final TimeOfDay? suggestedStartTime;
  final bool canRemove;

  /// Se true, la selezione del servizio √® obbligatoria (mostra errore di validazione).
  final bool isServiceRequired;
  final bool autoOpenServicePicker;
  final VoidCallback? onServicePickerAutoOpened;
  final VoidCallback? onServicePickerAutoCompleted;
  final VoidCallback? onAutoOpenStaffPickerCompleted;
  final String? availabilityWarningMessage;
  final String? staffEligibilityWarningMessage;

  /// IDs dei servizi abilitati per lo staff preselezionato.
  /// Se fornito, il picker mostrer√† di default solo questi servizi.
  final List<int>? preselectedStaffServiceIds;
  final bool canSelectStaff;

  @override
  ConsumerState<ServiceItemCard> createState() => _ServiceItemCardState();
}

class _ServiceItemCardState extends ConsumerState<ServiceItemCard> {
  static const int _startTimeStepMinutes = 5;

  bool _autoOpenStaffRequested = false;
  bool _shouldAutoOpenStaff = false;

  ServiceItemData get item => widget.item;
  int get index => widget.index;
  List<Service> get services => widget.services;
  List<ServiceCategory> get categories => widget.categories;
  List<ServiceVariant> get variants => widget.variants;
  List<int> get eligibleStaff => widget.eligibleStaff;
  List<Staff> get allStaff => widget.allStaff;
  AppFormFactor get formFactor => widget.formFactor;
  ValueChanged<ServiceItemData> get onChanged => widget.onChanged;
  VoidCallback get onRemove => widget.onRemove;
  ValueChanged<TimeOfDay> get onStartTimeChanged => widget.onStartTimeChanged;
  ValueChanged<TimeOfDay> get onEndTimeChanged => widget.onEndTimeChanged;
  ValueChanged<int> get onDurationChanged => widget.onDurationChanged;
  List<ServicePackage>? get packages => widget.packages;
  PopularServicesResult? get popularServices => widget.popularServices;
  ValueChanged<ServicePackage>? get onPackageSelected =>
      widget.onPackageSelected;
  TimeOfDay? get suggestedStartTime => widget.suggestedStartTime;
  bool get canRemove => widget.canRemove;
  bool get isServiceRequired => widget.isServiceRequired;
  bool get autoOpenServicePicker => widget.autoOpenServicePicker;
  VoidCallback? get onServicePickerAutoOpened =>
      widget.onServicePickerAutoOpened;
  VoidCallback? get onServicePickerAutoCompleted =>
      widget.onServicePickerAutoCompleted;
  VoidCallback? get onAutoOpenStaffPickerCompleted =>
      widget.onAutoOpenStaffPickerCompleted;
  String? get availabilityWarningMessage => widget.availabilityWarningMessage;
  String? get staffEligibilityWarningMessage =>
      widget.staffEligibilityWarningMessage;
  List<int>? get preselectedStaffServiceIds =>
      widget.preselectedStaffServiceIds;
  bool get canSelectStaff => widget.canSelectStaff;

  @override
  void didUpdateWidget(covariant ServiceItemCard oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.item.serviceId != widget.item.serviceId) {
      _autoOpenStaffRequested = false;
      _shouldAutoOpenStaff =
          widget.item.serviceId != null && widget.item.staffId == null;
    }
    if (widget.item.staffId != null) {
      _autoOpenStaffRequested = false;
      _shouldAutoOpenStaff = false;
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    final selectedService = item.serviceId != null
        ? services.where((s) => s.id == item.serviceId).firstOrNull
        : null;

    final selectedStaff = item.staffId != null
        ? allStaff.where((s) => s.id == item.staffId).firstOrNull
        : null;

    // Trova la variante corrente per mostrare il prezzo di default
    final selectedVariant = item.serviceId != null
        ? variants.where((v) => v.serviceId == item.serviceId).firstOrNull
        : null;

    // Staff disponibili per la selezione: sempre tutto lo staff della location
    // eligibleStaff serve solo per la selezione automatica, non per filtrare la lista
    final availableStaff = allStaff;

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: theme.colorScheme.outlineVariant),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Servizio
            _buildServiceSelector(context, l10n, selectedService),

            const SizedBox(height: 12),

            // Staff
            _buildStaffSelector(
              context,
              l10n,
              selectedStaff,
              availableStaff,
              theme,
            ),

            const SizedBox(height: 12),

            // Orario
            _buildTimeSelector(context, l10n, theme),

            // Prezzo (solo se servizio selezionato)
            if (item.serviceId != null) ...[
              const SizedBox(height: 12),
              _buildPriceSelector(context, l10n, theme, selectedVariant),
            ],

            if (availabilityWarningMessage != null) ...[
              const SizedBox(height: 12),
              _buildAvailabilityWarning(availabilityWarningMessage!),
            ],
            if (staffEligibilityWarningMessage != null) ...[
              const SizedBox(height: 12),
              _buildAvailabilityWarning(staffEligibilityWarningMessage!),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildServiceSelector(
    BuildContext context,
    dynamic l10n,
    Service? selectedService,
  ) {
    return ServicePickerField(
      services: services,
      categories: categories,
      packages: packages,
      popularServices: popularServices,
      formFactor: formFactor,
      value: item.serviceId,
      preselectedStaffServiceIds: preselectedStaffServiceIds,
      onChanged: (serviceId) {
        if (serviceId != null) {
          // Trova la variante di default per il servizio
          final variant = variants
              .where((v) => v.serviceId == serviceId)
              .firstOrNull;
          final duration = variant?.durationMinutes ?? 30;
          onChanged(
            item.copyWith(
              serviceId: serviceId,
              serviceVariantId: variant?.id,
              durationMinutes: duration,
              // Mantieni lo staff selezionato se presente
              staffId: item.staffId,
              blockedExtraMinutes: variant?.blockedTime ?? 0,
              processingExtraMinutes: variant?.processingTime ?? 0,
            ),
          );
        }
      },
      onPackageSelected: onPackageSelected,
      // Mostra icona rimuovi solo se canRemove e servizio selezionato
      onClear: canRemove && item.serviceId != null ? onRemove : null,
      validator: isServiceRequired
          ? (v) => v == null ? l10n.validationRequired : null
          : null,
      autoOpenPicker: autoOpenServicePicker,
      onAutoOpenPickerTriggered: onServicePickerAutoOpened,
      onAutoOpenPickerCompleted: onServicePickerAutoCompleted,
    );
  }

  Widget _buildAvailabilityWarning(String message) {
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.amber.withOpacity(0.18),
        borderRadius: BorderRadius.circular(8),
      ),
      padding: const EdgeInsets.all(12),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Icon(
            Icons.warning_amber_rounded,
            color: Colors.amber,
            size: 18,
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              message,
              style: const TextStyle(
                color: Color(0xFF8A4D00),
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStaffSelector(
    BuildContext context,
    dynamic l10n,
    Staff? selectedStaff,
    List<Staff> availableStaff,
    ThemeData theme,
  ) {
    // Staff √® obbligatorio se c'√® un servizio selezionato in questa card
    final isStaffRequired = item.serviceId != null;

    return FormField<int>(
      initialValue: item.staffId,
      validator: isStaffRequired
          ? (v) => v == null ? l10n.validationRequired : null
          : null,
      builder: (field) {
        if (canSelectStaff &&
            _shouldAutoOpenStaff &&
            !_autoOpenStaffRequested) {
          _autoOpenStaffRequested = true;
          _shouldAutoOpenStaff = false;
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (!mounted) return;
            _showStaffPicker(context, availableStaff, field).whenComplete(() {
              if (!mounted) return;
              onAutoOpenStaffPickerCompleted?.call();
            });
          });
        }

        final hasError = field.hasError;
        final borderColor = hasError
            ? theme.colorScheme.error
            : theme.colorScheme.outline;

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            InkWell(
              onTap: canSelectStaff
                  ? () => _showStaffPicker(context, availableStaff, field)
                  : null,
              borderRadius: BorderRadius.circular(4),
              child: InputDecorator(
                decoration: InputDecoration(
                  labelText: l10n.formStaff,
                  contentPadding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 12,
                  ),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(4),
                    borderSide: BorderSide(color: borderColor),
                  ),
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(4),
                    borderSide: BorderSide(color: borderColor),
                  ),
                  suffixIcon: canSelectStaff
                      ? const Icon(Icons.arrow_drop_down)
                      : const Icon(Icons.lock_outline, size: 18),
                  enabled: canSelectStaff,
                ),
                child: Row(
                  children: [
                    if (selectedStaff != null) ...[
                      StaffCircleAvatar(
                        height: 32,
                        color: selectedStaff.color,
                        isHighlighted: false,
                        initials: selectedStaff.initials,
                      ),
                      const SizedBox(width: 8),
                    ],
                    Expanded(
                      child: Text(
                        selectedStaff?.name ?? l10n.selectStaffTitle,
                        style: theme.textTheme.bodyLarge,
                      ),
                    ),
                  ],
                ),
              ),
            ),
            if (field.hasError && field.errorText != null)
              Padding(
                padding: const EdgeInsets.only(left: 12, top: 8),
                child: Text(
                  field.errorText!,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.error,
                  ),
                ),
              ),
          ],
        );
      },
    );
  }

  Widget _buildTimeSelector(
    BuildContext context,
    dynamic l10n,
    ThemeData theme,
  ) {
    final selectedService = item.serviceId != null
        ? services.where((s) => s.id == item.serviceId).firstOrNull
        : null;
    // Usa la durata dalla variante solo se item.durationMinutes non √® impostato
    final variant = item.serviceVariantId != null
        ? variants.where((v) => v.id == item.serviceVariantId).firstOrNull
        : (item.serviceId != null
              ? variants.where((v) => v.serviceId == item.serviceId).firstOrNull
              : null);
    // Priorit√†: item.durationMinutes > variant.durationMinutes > 30
    final baseDuration = item.durationMinutes > 0
        ? item.durationMinutes
        : (variant?.durationMinutes ?? 30);
    final endTime = item.getEndTime(baseDuration);

    // Costruiamo sempre tre colonne (Start, End, Duration) in modo che
    // l'elemento "Start" assuma sempre le dimensioni che avrebbe quando
    // End e Duration sono visibili. Quando il servizio non √® selezionato,
    // gli ultimi due vengono resi invisibili e non interattivi, ma mantengono
    // lo spazio.
    Widget buildInvisibleIfNoService(Widget w) {
      if (selectedService != null) return w;
      return IgnorePointer(child: Opacity(opacity: 0.0, child: w));
    }

    return Row(
      children: [
        // Start - sempre visibile
        Expanded(
          child: _TimeField(
            label: l10n.blockStartTime,
            time: item.startTime,
            onTap: () => _showStartTimePicker(context),
            theme: theme,
          ),
        ),
        const SizedBox(width: 8),

        // End - visibile solo se servizio selezionato (non modificabile, si calcola dalla durata)
        Expanded(
          child: buildInvisibleIfNoService(
            _TimeField(
              label: l10n.blockEndTime,
              time: endTime,
              onTap:
                  null, // Disabilitato: l'orario di fine si calcola da inizio + durata
              theme: theme,
            ),
          ),
        ),
        const SizedBox(width: 8),

        // Duration - visibile/interattivo solo se servizio selezionato
        Expanded(
          child: buildInvisibleIfNoService(
            _DurationField(
              label: l10n.fieldDurationRequiredLabel.replaceAll(' *', ''),
              durationMinutes: baseDuration,
              onTap: () => _showDurationPicker(context, baseDuration),
              theme: theme,
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildPriceSelector(
    BuildContext context,
    dynamic l10n,
    ThemeData theme,
    ServiceVariant? selectedVariant,
  ) {
    // Prezzo di default dalla variante
    final defaultPrice = selectedVariant?.isFree == true
        ? 0.0
        : (selectedVariant?.price ?? 0.0);
    // Prezzo corrente: personalizzato o default
    final currentPrice = item.price ?? defaultPrice;
    final hasCustomPrice = item.price != null;

    return InkWell(
      onTap: () => _showPriceEditor(context, l10n, currentPrice, defaultPrice),
      borderRadius: BorderRadius.circular(4),
      child: InputDecorator(
        decoration: InputDecoration(
          labelText: l10n.appointmentPriceLabel,
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(4)),
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 10,
            vertical: 10,
          ),
          isDense: true,
          suffixIcon: hasCustomPrice
              ? IconButton(
                  icon: const Icon(Icons.refresh, size: 18),
                  tooltip: l10n.appointmentPriceResetTooltip,
                  onPressed: () {
                    // Resetta al prezzo di default
                    onChanged(item.copyWithPriceCleared());
                  },
                )
              : null,
        ),
        child: Text(
          currentPrice == 0
              ? l10n.appointmentPriceFree
              : '‚Ç¨ ${currentPrice.toStringAsFixed(2)}',
          style: theme.textTheme.bodyMedium?.copyWith(
            color: hasCustomPrice ? theme.colorScheme.primary : null,
            fontWeight: hasCustomPrice ? FontWeight.w600 : FontWeight.normal,
          ),
        ),
      ),
    );
  }

  void _showPriceEditor(
    BuildContext context,
    dynamic l10n,
    double currentPrice,
    double defaultPrice,
  ) {
    final controller = TextEditingController(
      text: currentPrice == 0 ? '' : currentPrice.toStringAsFixed(2),
    );

    if (formFactor != AppFormFactor.desktop) {
      AppBottomSheet.show(
        context: context,
        padding: EdgeInsets.zero,
        builder: (ctx) => SafeArea(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  l10n.appointmentPriceLabel,
                  style: Theme.of(
                    ctx,
                  ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600),
                ),
                const SizedBox(height: 16),
                TextField(
                  controller: controller,
                  keyboardType: const TextInputType.numberWithOptions(
                    decimal: true,
                  ),
                  autofocus: true,
                  decoration: InputDecoration(
                    hintText: l10n.appointmentPriceHint,
                    prefixText: '‚Ç¨ ',
                    border: const OutlineInputBorder(),
                    helperText:
                        'Prezzo servizio: ‚Ç¨${defaultPrice.toStringAsFixed(2)}',
                  ),
                ),
                const SizedBox(height: 16),
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    TextButton(
                      onPressed: () => Navigator.of(ctx).pop(),
                      child: Text(l10n.actionCancel),
                    ),
                    const SizedBox(width: 8),
                    FilledButton(
                      onPressed: () {
                        final text = controller.text.trim().replaceAll(
                          ',',
                          '.',
                        );
                        final newPrice = text.isEmpty
                            ? 0.0
                            : (double.tryParse(text) ?? currentPrice);
                        Navigator.of(ctx).pop();
                        onChanged(item.copyWith(price: newPrice));
                      },
                      child: Text(l10n.actionConfirm),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      );
    } else {
      showDialog(
        context: context,
        builder: (ctx) => AlertDialog(
          title: Text(l10n.appointmentPriceLabel),
          content: SizedBox(
            width: 300,
            child: TextField(
              controller: controller,
              keyboardType: const TextInputType.numberWithOptions(
                decimal: true,
              ),
              autofocus: true,
              decoration: InputDecoration(
                hintText: l10n.appointmentPriceHint,
                prefixText: '‚Ç¨ ',
                border: const OutlineInputBorder(),
                helperText:
                    'Prezzo servizio: ‚Ç¨${defaultPrice.toStringAsFixed(2)}',
              ),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(ctx).pop(),
              child: Text(l10n.actionCancel),
            ),
            FilledButton(
              onPressed: () {
                final text = controller.text.trim().replaceAll(',', '.');
                final newPrice = text.isEmpty
                    ? 0.0
                    : (double.tryParse(text) ?? currentPrice);
                Navigator.of(ctx).pop();
                onChanged(item.copyWith(price: newPrice));
              },
              child: Text(l10n.actionConfirm),
            ),
          ],
        ),
      );
    }
  }

  void _showStartTimePicker(BuildContext context) async {
    final l10n = context.l10n;

    if (formFactor != AppFormFactor.desktop) {
      final picked = await AppBottomSheet.show<TimeOfDay>(
        context: context,
        padding: EdgeInsets.zero,
        heightFactor: AppBottomSheet.defaultHeightFactor,
        builder: (ctx) => _TimeGridPicker(
          initial: item.startTime,
          includeTime: suggestedStartTime,
          stepMinutes: _startTimeStepMinutes,
          title: l10n.blockStartTime,
        ),
      );

      if (picked != null) {
        onStartTimeChanged(picked);
      }
    } else {
      final picked = await showDialog<TimeOfDay>(
        context: context,
        builder: (ctx) => Dialog(
          insetPadding: const EdgeInsets.symmetric(
            horizontal: 32,
            vertical: 24,
          ),
          child: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: _TimeGridPicker(
                initial: item.startTime,
                includeTime: suggestedStartTime,
                stepMinutes: _startTimeStepMinutes,
                title: l10n.blockStartTime,
                useSafeArea: false,
              ),
            ),
          ),
        ),
      );

      if (picked != null) {
        onStartTimeChanged(picked);
      }
    }
  }

  void _showDurationPicker(BuildContext context, int currentDuration) {
    final l10n = context.l10n;

    // Calcola i minuti disponibili fino a mezzanotte (24:00)
    final startMinutes = item.startTime.hour * 60 + item.startTime.minute;
    final maxMinutesAvailable = (24 * 60) - startMinutes;

    // Durate selezionabili da 5 minuti a 6 ore con step fisso di 5 minuti.
    final allDurations = <int>[
      for (int m = 5; m <= 360; m += 5) m,
    ];
    final durations = allDurations
        .where((d) => d <= maxMinutesAvailable)
        .toList();

    // Se la durata corrente non √® nella lista ma √® valida, aggiungila
    if (currentDuration > 0 &&
        currentDuration <= maxMinutesAvailable &&
        !durations.contains(currentDuration)) {
      durations.add(currentDuration);
      durations.sort();
    }

    if (formFactor != AppFormFactor.desktop) {
      AppBottomSheet.show(
        context: context,
        padding: EdgeInsets.zero,
        builder: (ctx) => SafeArea(
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Padding(
                  padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                  child: Text(
                    l10n.fieldDurationRequiredLabel.replaceAll(' *', ''),
                    style: Theme.of(ctx).textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
                const Divider(height: 1),
                ...durations.map(
                  (d) => ListTile(
                    title: Text(_formatExtraDuration(d)),
                    trailing: d == currentDuration
                        ? Icon(
                            Icons.check,
                            color: Theme.of(ctx).colorScheme.primary,
                          )
                        : null,
                    onTap: () {
                      Navigator.of(ctx).pop();
                      onDurationChanged(d);
                    },
                  ),
                ),
                const SizedBox(height: 8),
              ],
            ),
          ),
        ),
      );
    } else {
      showDialog(
        context: context,
        builder: (ctx) => AlertDialog(
          title: Text(l10n.fieldDurationRequiredLabel.replaceAll(' *', '')),
          content: SizedBox(
            width: 300,
            child: ConstrainedBox(
              constraints: BoxConstraints(
                maxHeight: MediaQuery.of(ctx).size.height * 0.5,
              ),
              child: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: durations
                      .map(
                        (d) => ListTile(
                          title: Text(_formatDuration(d)),
                          trailing: d == currentDuration
                              ? Icon(
                                  Icons.check,
                                  color: Theme.of(ctx).colorScheme.primary,
                                )
                              : null,
                          onTap: () {
                            Navigator.of(ctx).pop();
                            onDurationChanged(d);
                          },
                        ),
                      )
                      .toList(),
                ),
              ),
            ),
          ),
        ),
      );
    }
  }

  String _formatDuration(int minutes) {
    if (minutes < 60) {
      return '$minutes min';
    }
    final hours = minutes ~/ 60;
    final mins = minutes % 60;
    if (mins == 0) {
      return '$hours h';
    }
    return '$hours h $mins min';
  }

  Future<void> _showStaffPicker(
    BuildContext context,
    List<Staff> availableStaff,
    FormFieldState<int> field,
  ) async {
    final l10n = context.l10n;

    if (formFactor != AppFormFactor.desktop) {
      await AppBottomSheet.show(
        context: context,
        padding: EdgeInsets.zero,
        builder: (ctx) => SafeArea(
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Padding(
                  padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                  child: Text(
                    l10n.selectStaffTitle,
                    style: Theme.of(ctx).textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
                const Divider(height: 1),
                _StaffPickerContent(
                  staff: availableStaff,
                  selectedId: item.staffId,
                  onSelected: (staffId) {
                    Navigator.of(ctx).pop();
                    field.didChange(staffId);
                    field.validate();
                    onChanged(item.copyWith(staffId: staffId));
                  },
                ),
                const SizedBox(height: 8),
              ],
            ),
          ),
        ),
      );
    } else {
      // Per desktop, usa un dialog semplice con scroll
      await showDialog(
        context: context,
        builder: (ctx) => AlertDialog(
          title: Text(l10n.selectStaffTitle),
          content: SizedBox(
            width: 300,
            child: ConstrainedBox(
              constraints: BoxConstraints(
                maxHeight: MediaQuery.of(ctx).size.height * 0.5,
              ),
              child: SingleChildScrollView(
                child: _StaffPickerContent(
                  staff: availableStaff,
                  selectedId: item.staffId,
                  onSelected: (staffId) {
                    Navigator.of(ctx).pop();
                    field.didChange(staffId);
                    field.validate();
                    onChanged(item.copyWith(staffId: staffId));
                  },
                ),
              ),
            ),
          ),
        ),
      );
    }
  }
}

/// Widget per mostrare un campo orario cliccabile
class _TimeField extends StatelessWidget {
  const _TimeField({
    required this.label,
    required this.time,
    required this.onTap,
    required this.theme,
  });

  final String label;
  final TimeOfDay time;
  final VoidCallback? onTap;
  final ThemeData theme;

  @override
  Widget build(BuildContext context) {
    final hour = time.hour.toString().padLeft(2, '0');
    final minute = time.minute.toString().padLeft(2, '0');
    final isDisabled = onTap == null;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(4),
      child: InputDecorator(
        decoration: InputDecoration(
          labelText: label,
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 10,
            vertical: 10,
          ),
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(4)),
          isDense: true,
          enabled: !isDisabled,
        ),
        child: Text(
          '$hour:$minute',
          style: theme.textTheme.bodyMedium?.copyWith(
            color: isDisabled
                ? theme.colorScheme.onSurface.withOpacity(0.5)
                : null,
          ),
        ),
      ),
    );
  }
}

class ExtraTimeCard extends StatefulWidget {
  const ExtraTimeCard({
    super.key,
    required this.title,
    required this.startTime,
    required this.durationMinutes,
    required this.onStartTimeChanged,
    required this.onDurationChanged,
    required this.onRemove,
    required this.formFactor,
  });

  final String title;
  final TimeOfDay startTime;
  final int durationMinutes;
  final ValueChanged<TimeOfDay> onStartTimeChanged;
  final ValueChanged<int> onDurationChanged;
  final VoidCallback onRemove;
  final AppFormFactor formFactor;

  @override
  State<ExtraTimeCard> createState() => _ExtraTimeCardState();
}

class _ExtraTimeCardState extends State<ExtraTimeCard> {
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final endTime = _addMinutes(widget.startTime, widget.durationMinutes);

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: theme.colorScheme.outlineVariant),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Expanded(
                  child: Text(
                    widget.title,
                    style: theme.textTheme.bodyMedium?.copyWith(
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                ),
                IconButton(
                  tooltip: l10n.actionClose,
                  icon: const Icon(Icons.close, size: 18),
                  onPressed: widget.onRemove,
                ),
              ],
            ),
            const SizedBox(height: 8),
            Row(
              children: [
                Expanded(
                  child: _TimeField(
                    label: l10n.blockStartTime,
                    time: widget.startTime,
                    onTap: null,
                    theme: theme,
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: _TimeField(
                    label: l10n.blockEndTime,
                    time: endTime,
                    onTap: null,
                    theme: theme,
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: _DurationField(
                    label: l10n.fieldDurationRequiredLabel.replaceAll(' *', ''),
                    durationMinutes: widget.durationMinutes,
                    onTap: () =>
                        _showDurationPicker(context, widget.durationMinutes),
                    theme: theme,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  TimeOfDay _addMinutes(TimeOfDay time, int minutes) {
    final totalMinutes = time.hour * 60 + time.minute + minutes;
    return TimeOfDay(
      hour: (totalMinutes ~/ 60) % 24,
      minute: totalMinutes % 60,
    );
  }

  void _showDurationPicker(BuildContext context, int currentDuration) {
    final l10n = context.l10n;

    // Calcola i minuti disponibili fino a mezzanotte (24:00)
    final startMinutes = widget.startTime.hour * 60 + widget.startTime.minute;
    final maxMinutesAvailable = (24 * 60) - startMinutes;

    // Durate selezionabili da 5 minuti a 6 ore con step fisso di 5 minuti.
    final allDurations = <int>[
      for (int m = 5; m <= 360; m += 5) m,
    ];
    final durations = allDurations
        .where((d) => d <= maxMinutesAvailable)
        .toList();

    if (currentDuration > 0 &&
        currentDuration <= maxMinutesAvailable &&
        !durations.contains(currentDuration)) {
      durations.add(currentDuration);
      durations.sort();
    }

    if (widget.formFactor != AppFormFactor.desktop) {
      AppBottomSheet.show(
        context: context,
        padding: EdgeInsets.zero,
        builder: (ctx) => SafeArea(
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Padding(
                  padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                  child: Text(
                    l10n.fieldDurationRequiredLabel.replaceAll(' *', ''),
                    style: Theme.of(ctx).textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
                const Divider(height: 1),
                ...durations.map(
                  (d) => ListTile(
                    title: Text(_formatExtraDuration(d)),
                    trailing: d == currentDuration
                        ? Icon(
                            Icons.check,
                            color: Theme.of(ctx).colorScheme.primary,
                          )
                        : null,
                    onTap: () {
                      Navigator.of(ctx).pop();
                      widget.onDurationChanged(d);
                    },
                  ),
                ),
              ],
            ),
          ),
        ),
      );
    } else {
      showDialog<void>(
        context: context,
        builder: (ctx) => AlertDialog(
          title: Text(l10n.fieldDurationRequiredLabel.replaceAll(' *', '')),
          content: SizedBox(
            width: 320,
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: durations.length,
              itemBuilder: (_, index) {
                final d = durations[index];
                return ListTile(
                  title: Text(_formatExtraDuration(d)),
                  trailing: d == currentDuration
                      ? Icon(
                          Icons.check,
                          color: Theme.of(ctx).colorScheme.primary,
                        )
                      : null,
                  onTap: () {
                    Navigator.of(ctx).pop();
                    widget.onDurationChanged(d);
                  },
                );
              },
            ),
          ),
        ),
      );
    }
  }
}

/// Widget per mostrare un campo durata cliccabile
class _DurationField extends StatelessWidget {
  const _DurationField({
    required this.label,
    required this.durationMinutes,
    required this.onTap,
    required this.theme,
  });

  final String label;
  final int durationMinutes;
  final VoidCallback? onTap;
  final ThemeData theme;

  @override
  Widget build(BuildContext context) {
    String formatted;
    if (durationMinutes < 60) {
      formatted = '$durationMinutes min';
    } else {
      final hours = durationMinutes ~/ 60;
      final mins = durationMinutes % 60;
      if (mins == 0) {
        formatted = '${hours}h';
      } else {
        formatted = '${hours}h ${mins}m';
      }
    }

    final isDisabled = onTap == null;
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(4),
      child: InputDecorator(
        decoration: InputDecoration(
          labelText: label,
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 10,
            vertical: 10,
          ),
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(4)),
          isDense: true,
          enabled: !isDisabled,
        ),
        child: Text(
          formatted,
          style: theme.textTheme.bodyMedium?.copyWith(
            color: isDisabled
                ? theme.colorScheme.onSurface.withOpacity(0.5)
                : null,
          ),
        ),
      ),
    );
  }
}

class _TimeGridPicker extends StatefulWidget {
  const _TimeGridPicker({
    required this.initial,
    this.includeTime,
    required this.stepMinutes,
    required this.title,
    this.useSafeArea = true,
  });

  final TimeOfDay initial;
  final TimeOfDay? includeTime;
  final int stepMinutes;
  final String title;
  final bool useSafeArea;

  @override
  State<_TimeGridPicker> createState() => _TimeGridPickerState();
}

class _TimeGridPickerState extends State<_TimeGridPicker> {
  late final ScrollController _scrollController;
  late final List<TimeOfDay?> _entries;
  late int _scrollToIndex;
  int? _selectedIndex; // Index dell'orario da evidenziare (null se nessuno)

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();

    _entries = <TimeOfDay?>[];
    for (int m = 0; m < LayoutConfig.hoursInDay * 60; m += widget.stepMinutes) {
      final h = m ~/ 60;
      final mm = m % 60;
      _entries.add(TimeOfDay(hour: h, minute: mm));
    }

    // Determina l'orario verso cui scrollare e se evidenziare
    final hasValidInitial =
        widget.initial.hour != 0 || widget.initial.minute != 0;
    final targetTime = _getTargetScrollTime();
    _scrollToIndex = _ensureTimeInEntries(targetTime);

    // Evidenzia solo se l'orario iniziale √® valido (non 00:00)
    _selectedIndex = hasValidInitial ? _scrollToIndex : null;

    if (widget.includeTime != null &&
        !_isSameTime(widget.includeTime!, targetTime)) {
      _ensureTimeInEntries(widget.includeTime!);
    }

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _scrollToSelected();
    });
  }

  /// Determina l'orario verso cui scrollare
  TimeOfDay _getTargetScrollTime() {
    // Se l'orario iniziale √® diverso da 00:00, usalo
    if (widget.initial.hour != 0 || widget.initial.minute != 0) {
      return widget.initial;
    }

    // Altrimenti usa l'orario attuale arrotondato al prossimo step
    final now = TimeOfDay.now();
    final totalMinutes = now.hour * 60 + now.minute;
    final roundedMinutes =
        ((totalMinutes + widget.stepMinutes - 1) ~/ widget.stepMinutes) *
        widget.stepMinutes;

    // Limita a 23:45 massimo (o ultimo step valido)
    final maxMinutes =
        (LayoutConfig.hoursInDay - 1) * 60 + (60 - widget.stepMinutes);
    final clampedMinutes = roundedMinutes.clamp(0, maxMinutes);

    return TimeOfDay(hour: clampedMinutes ~/ 60, minute: clampedMinutes % 60);
  }

  bool _isSameTime(TimeOfDay a, TimeOfDay b) =>
      a.hour == b.hour && a.minute == b.minute;

  int _ensureTimeInEntries(TimeOfDay time) {
    final existingIndex = _entries.indexWhere(
      (t) => t != null && _isSameTime(t, time),
    );
    if (existingIndex >= 0) {
      return existingIndex;
    }

    final columnsPerRow = 60 ~/ widget.stepMinutes;
    final targetColumn = time.minute ~/ widget.stepMinutes;
    final baseIndex = (time.hour + 1) * columnsPerRow;

    final newRow = List<TimeOfDay?>.filled(columnsPerRow, null);
    newRow[targetColumn] = time;

    final insertIndex = baseIndex.clamp(0, _entries.length);
    _entries.insertAll(insertIndex, newRow);
    return insertIndex + targetColumn;
  }

  void _scrollToSelected() {
    if (!_scrollController.hasClients) return;

    const crossAxisCount = 4;
    const mainAxisSpacing = 6.0;
    const childAspectRatio = 2.7;
    const padding = 12.0;

    final screenWidth = MediaQuery.of(context).size.width;
    final availableWidth = screenWidth - padding * 2;
    final itemWidth =
        (availableWidth - (crossAxisCount - 1) * 6) / crossAxisCount;
    final itemHeight = itemWidth / childAspectRatio;
    final rowHeight = itemHeight + mainAxisSpacing;

    final targetRow = _scrollToIndex ~/ crossAxisCount;

    final viewportHeight = _scrollController.position.viewportDimension;
    const headerOffset = 40.0;
    final targetOffset =
        (targetRow * rowHeight) -
        (viewportHeight / 2) +
        (rowHeight / 2) +
        headerOffset;

    final maxScroll = _scrollController.position.maxScrollExtent;
    final clampedOffset = targetOffset.clamp(0.0, maxScroll);

    _scrollController.animateTo(
      clampedOffset,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeOut,
    );
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final content = Padding(
      padding: const EdgeInsets.all(12),
      child: Column(
        mainAxisSize: MainAxisSize.max,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              const Icon(Icons.schedule, size: 18),
              const SizedBox(width: 8),
              Text(
                widget.title,
                style: const TextStyle(fontWeight: FontWeight.w700),
              ),
            ],
          ),
          const SizedBox(height: 10),
          Expanded(
            child: GridView.builder(
              controller: _scrollController,
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 4,
                mainAxisSpacing: 6,
                crossAxisSpacing: 6,
                childAspectRatio: 2.7,
              ),
              itemCount: _entries.length,
              itemBuilder: (context, index) {
                final t = _entries[index];
                if (t == null) {
                  return const SizedBox.shrink();
                }
                final isSelected =
                    _selectedIndex != null && index == _selectedIndex;
                return OutlinedButton(
                  style: OutlinedButton.styleFrom(
                    backgroundColor: isSelected
                        ? Theme.of(context).colorScheme.primary.withOpacity(0.1)
                        : null,
                    side: BorderSide(
                      color: isSelected
                          ? Theme.of(context).colorScheme.primary
                          : Theme.of(context).dividerColor,
                    ),
                    padding: const EdgeInsets.symmetric(horizontal: 8),
                  ),
                  onPressed: () => Navigator.pop(context, t),
                  child: Text(DtFmt.hm(context, t.hour, t.minute)),
                );
              },
            ),
          ),
        ],
      ),
    );

    if (!widget.useSafeArea) {
      return content;
    }
    return SafeArea(child: content);
  }
}

class _StaffPickerContent extends StatelessWidget {
  const _StaffPickerContent({
    required this.staff,
    required this.selectedId,
    required this.onSelected,
  });

  final List<Staff> staff;
  final int? selectedId;
  final ValueChanged<int> onSelected;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    if (staff.isEmpty) {
      return Padding(
        padding: const EdgeInsets.all(24),
        child: Center(
          child: Text(
            l10n.noStaffAvailable,
            style: theme.textTheme.bodyMedium?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
        ),
      );
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        for (final member in staff)
          ListTile(
            leading: StaffCircleAvatar(
              height: 36,
              color: member.color,
              isHighlighted: member.id == selectedId,
              initials: member.initials,
            ),
            title: Text('${member.name} ${member.surname}'.trim()),
            trailing: member.id == selectedId
                ? Icon(Icons.check, color: theme.colorScheme.primary)
                : null,
            selected: member.id == selectedId,
            onTap: () => onSelected(member.id),
          ),
      ],
    );
  }
}
--- FILE: lib/features/agenda/presentation/widgets/agenda_top_controls.dart ---
import 'package:agenda_backend/app/widgets/top_controls.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class AgendaTopControls extends ConsumerWidget {
  const AgendaTopControls({super.key, this.compact = false});

  final bool compact;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return TopControls.agenda(compact: compact);
  }
}
--- FILE: lib/features/agenda/presentation/widgets/booking_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:agenda_backend/core/l10n/date_time_formats.dart';
import 'package:agenda_backend/core/models/appointment.dart';
import 'package:agenda_backend/core/models/popular_service.dart';
import 'package:agenda_backend/core/widgets/labeled_form_field.dart';
import 'package:agenda_backend/core/widgets/no_scrollbar_behavior.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/booking.dart';
import '../../../../core/models/recurrence_rule.dart';
import '../../../../core/models/service_package.dart';
import '../../../../core/models/service_variant.dart';
import '../../../../core/network/api_client.dart';
import '../../../../core/utils/price_utils.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/feedback_dialog.dart';
import '../../../../core/widgets/local_loading_overlay.dart';
import '../../../auth/providers/current_business_user_provider.dart';
import '../../../clients/domain/clients.dart';
import '../../../clients/presentation/dialogs/client_edit_dialog.dart';
import '../../../clients/providers/clients_providers.dart';
import '../../../services/providers/popular_services_provider.dart';
import '../../../services/providers/service_categories_provider.dart';
import '../../../services/providers/service_packages_provider.dart';
import '../../../services/providers/service_packages_repository_provider.dart';
import '../../../services/providers/services_provider.dart';
import '../../data/bookings_api.dart';
import '../../domain/service_item_data.dart';
import '../../providers/agenda_scroll_request_provider.dart';
import '../../providers/appointment_providers.dart';
import '../../providers/bookings_provider.dart';
import '../../providers/bookings_repository_provider.dart';
import '../../providers/business_providers.dart';
import '../../providers/date_range_provider.dart';
import '../../providers/layout_config_provider.dart';
import '../../providers/location_providers.dart';
import '../../providers/staff_slot_availability_provider.dart';
import '../dialogs/recurrence_summary_dialog.dart';
import 'recurrence_picker.dart';
import 'recurrence_preview.dart';
import 'service_item_card.dart';
import 'service_package_picker_dialog.dart';

/// Show the Booking dialog for creating a new multi-service booking.
Future<void> showBookingDialog(
  BuildContext context,
  WidgetRef ref, {
  Booking? existing,
  DateTime? date,
  TimeOfDay? time,
  int? initialStaffId,
  bool autoOpenDatePicker = false,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final presentation = formFactor == AppFormFactor.desktop
      ? _BookingPresentation.dialog
      : _BookingPresentation.bottomSheet;

  final content = _BookingDialog(
    existing: existing,
    initialDate: date,
    initialTime: time,
    initialStaffId: initialStaffId,
    autoOpenDatePicker: autoOpenDatePicker,
    presentation: presentation,
  );

  if (presentation == _BookingPresentation.dialog) {
    await showDialog(
      context: context,
      builder: (_) => content,
      barrierDismissible: false,
    );
  } else {
    await AppBottomSheet.show(
      context: context,
      useRootNavigator: true,
      padding: const EdgeInsets.symmetric(horizontal: 0, vertical: 16),
      builder: (_) => content,
      heightFactor: AppBottomSheet.defaultHeightFactor,
    );
  }
}

enum _BookingPresentation { dialog, bottomSheet }

class _BookingDialog extends ConsumerStatefulWidget {
  const _BookingDialog({
    this.existing,
    this.initialDate,
    this.initialTime,
    this.initialStaffId,
    this.autoOpenDatePicker = false,
    required this.presentation,
  });

  final Booking? existing;
  final DateTime? initialDate;
  final TimeOfDay? initialTime;
  final int? initialStaffId;
  final bool autoOpenDatePicker;
  final _BookingPresentation presentation;

  @override
  ConsumerState<_BookingDialog> createState() => _BookingDialogState();
}

class _BookingDialogState extends ConsumerState<_BookingDialog> {
  final _formKey = GlobalKey<FormState>();
  final _notesController = TextEditingController();
  final ScrollController _scrollController = ScrollController();

  late DateTime _date;
  int? _clientId;

  bool _clientPickerAutoRequested = false;
  int? _autoOpenServicePickerIndex;
  bool _shouldAutoOpenServicePicker = false;
  bool _datePickerAutoRequested = false;

  /// Nome cliente personalizzato (usato solo per clienti nuovi non ancora salvati)
  String _customClientName = '';

  /// Lista di servizi nella prenotazione
  final List<ServiceItemData> _serviceItems = [];

  /// Contatore per generare chiavi univoche
  int _itemKeyCounter = 0;

  bool _warningDismissed = false;
  bool _midnightWarningVisible = false;
  bool _midnightWarningDismissed = false;
  bool _isSaving = false;
  bool _isAddingPackage = false;

  /// Configurazione ricorrenza (null = appuntamento singolo)
  RecurrenceConfig? _recurrenceConfig;
  late final String _currentBookingStatus;
  String? _selectedBookingStatus;

  @override
  void initState() {
    super.initState();
    final agendaDate = ref.read(agendaDateProvider);

    if (widget.existing != null) {
      // Editing existing booking
      _date = DateUtils.dateOnly(widget.initialDate ?? agendaDate);
      _notesController.text = widget.existing!.notes ?? '';
      _clientId = widget.existing!.clientId;
      _customClientName = widget.existing!.clientName ?? '';

      // Load existing appointments into _serviceItems
      final bookingAppointments = ref
          .read(appointmentsProvider.notifier)
          .getByBookingId(widget.existing!.id);

      for (final appointment in bookingAppointments) {
        final baseDuration = _baseDurationFromAppointment(appointment);
        final blockedExtraMinutes = appointment.blockedExtraMinutes;
        final processingExtraMinutes = appointment.processingExtraMinutes;
        _serviceItems.add(
          ServiceItemData(
            key: _nextItemKey(),
            startTime: TimeOfDay.fromDateTime(appointment.startTime),
            staffId: appointment.staffId,
            serviceId: appointment.serviceId,
            serviceVariantId: appointment.serviceVariantId,
            durationMinutes: baseDuration,
            blockedExtraMinutes: blockedExtraMinutes,
            processingExtraMinutes: processingExtraMinutes,
          ),
        );
      }

      // Se non ci sono appointments, aggiungi un item vuoto
      if (_serviceItems.isEmpty) {
        final initialTime =
            widget.initialTime ?? const TimeOfDay(hour: 10, minute: 0);
        _serviceItems.add(
          ServiceItemData(key: _nextItemKey(), startTime: initialTime),
        );
      }
    } else {
      _date = DateUtils.dateOnly(widget.initialDate ?? agendaDate);

      // Aggiungi un primo servizio vuoto
      final initialTime =
          widget.initialTime ?? const TimeOfDay(hour: 10, minute: 0);
      _serviceItems.add(
        ServiceItemData(
          key: _nextItemKey(),
          startTime: initialTime,
          staffId: widget.initialStaffId,
        ),
      );
    }
    _currentBookingStatus = widget.existing?.status ?? 'confirmed';
    _selectedBookingStatus =
        _availableStatusOptions().contains(_currentBookingStatus)
        ? _currentBookingStatus
        : null;

    if (widget.existing == null) {
      WidgetsBinding.instance.addPostFrameCallback((_) async {
        if (!mounted) return;
        if (widget.autoOpenDatePicker) {
          await _scheduleAutoDatePicker();
        }
        if (!mounted) return;
        _scheduleAutoClientPicker();
      });
    }
  }

  @override
  void dispose() {
    _notesController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  int _baseDurationFromAppointment(Appointment appointment) {
    final totalMinutes = appointment.endTime
        .difference(appointment.startTime)
        .inMinutes;
    final extraMinutes = appointment.blockedExtraMinutes;
    final base = totalMinutes - extraMinutes;
    return base > 0 ? base : 0;
  }

  String _nextItemKey() => 'item_${_itemKeyCounter++}';

  List<String> _availableStatusOptions() {
    return const <String>[
      'confirmed',
      'completed',
      'no_show',
    ];
  }

  String _statusLabel(BuildContext context, String status) {
    final l10n = context.l10n;
    switch (status) {
      case 'confirmed':
        return l10n.statusConfirmed;
      case 'cancelled':
        return l10n.statusCancelled;
      case 'pending':
        return l10n.bookingsListStatusPending;
      case 'completed':
        return l10n.statusCompleted;
      case 'no_show':
        return l10n.bookingsListStatusNoShow;
      default:
        return status;
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final isEdit = widget.existing != null;
    final isDialog = widget.presentation == _BookingPresentation.dialog;

    final formFactor = ref.watch(formFactorProvider);
    final services = ref.watch(servicesProvider).value ?? [];
    final serviceCategories = ref.watch(serviceCategoriesProvider);
    final variants = ref.watch(serviceVariantsProvider).value ?? [];
    final clients = ref.watch(clientsListProvider);
    final clientsById = ref.watch(clientsByIdProvider);
    final allStaff = ref.watch(staffForCurrentLocationProvider);
    final hasPackages =
        (ref.watch(servicePackagesProvider).value ?? []).isNotEmpty;
    final canManageBookings = ref.watch(currentUserCanManageBookingsProvider);
    final currentUserRole = ref.watch(currentUserRoleProvider);
    final currentUserStaffId = ref.watch(currentUserStaffIdProvider);
    final forcedStaffId =
        (currentUserRole == 'staff' &&
            currentUserStaffId != null &&
            currentUserStaffId > 0)
        ? currentUserStaffId
        : null;

    // Usa lo staffId del primo item per i servizi popolari
    final firstStaffId = _serviceItems.isNotEmpty
        ? _serviceItems.first.staffId
        : null;
    final validStaffIds = allStaff.map((s) => s.id).toSet();
    final effectiveStaffId =
        firstStaffId != null && validStaffIds.contains(firstStaffId)
        ? firstStaffId
        : null;
    final popularServices = effectiveStaffId != null
        ? ref.watch(popularServicesProvider(effectiveStaffId)).value
        : null;

    // Deriva il nome del cliente dal provider se _clientId √® impostato,
    // altrimenti usa il nome personalizzato (per clienti nuovi)
    final clientName = _clientId != null
        ? (clientsById[_clientId]?.name ?? _customClientName)
        : _customClientName;

    final title = isEdit
        ? l10n.appointmentDialogTitleEdit
        : l10n.appointmentDialogTitleNew;
    final statusOptions = _availableStatusOptions();

    final isDesktop = widget.presentation == _BookingPresentation.dialog;
    final conflictFlags = _serviceConflictFlags();
    final eligibleIndices = <int>[];
    for (int i = 0; i < _serviceItems.length; i++) {
      if (_isWarningEligible(_serviceItems[i])) {
        eligibleIndices.add(i);
      }
    }
    final allEligibleConflict =
        eligibleIndices.isNotEmpty &&
        eligibleIndices.every((i) => conflictFlags[i]);
    final showAppointmentWarning =
        eligibleIndices.length > 1 && allEligibleConflict;
    final showServiceWarnings = !showAppointmentWarning;
    final content = Form(
      key: _formKey,
      child: ConstrainedBox(
        // Su desktop, limita la larghezza del form. Su mobile, usa tutta la larghezza.
        constraints: BoxConstraints(
          maxWidth: isDesktop ? 340 : double.infinity,
        ),
        child: ScrollConfiguration(
          behavior: const NoScrollbarBehavior(),
          child: SingleChildScrollView(
            controller: _scrollController,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                const SizedBox(height: AppSpacing.formFirstRowSpacing),

                // Client selection
                _ClientSelectionField(
                  clientId: _clientId,
                  clientName: clientName,
                  clients: clients,
                  onClientSelected: (id, name) {
                    setState(() {
                      _clientId = id;
                      _customClientName = name;
                    });
                  },
                  onClientRemoved: () {
                    setState(() {
                      _clientId = null;
                      _customClientName = '';
                    });
                  },
                  onOpenPicker: _openClientPicker,
                ),
                const SizedBox(height: AppSpacing.formRowSpacing),

                // Date and Time selector (row)
                LabeledFormField(
                  label: l10n.formDate,
                  child: InkWell(
                    onTap: _pickDate,
                    borderRadius: BorderRadius.circular(8),
                    child: InputDecorator(
                      decoration: const InputDecoration(
                        border: OutlineInputBorder(),
                        isDense: true,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(DtFmt.shortDate(context, _date)),
                          const Icon(Icons.calendar_today, size: 16),
                        ],
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: AppSpacing.formRowSpacing),

                // Services section header
                // Services list
                ..._buildServiceItems(
                  services: services,
                  categories: serviceCategories,
                  variants: variants,
                  allStaff: allStaff,
                  forcedStaffId: forcedStaffId,
                  formFactor: formFactor,
                  conflictFlags: conflictFlags,
                  showServiceWarnings: showServiceWarnings,
                  serviceWarningMessage:
                      l10n.bookingUnavailableTimeWarningService,
                  popularServices: popularServices,
                  hasPackages: hasPackages,
                ),

                const SizedBox(height: AppSpacing.formRowSpacing),

                // Notes field
                LabeledFormField(
                  label: l10n.formNotes,
                  child: TextField(
                    controller: _notesController,
                    decoration: InputDecoration(
                      hintText: l10n.notesPlaceholder,
                      border: const OutlineInputBorder(),
                      isDense: true,
                    ),
                    maxLines: 2,
                    textCapitalization: TextCapitalization.sentences,
                  ),
                ),
                if (statusOptions.isNotEmpty && _recurrenceConfig == null) ...[
                  const SizedBox(height: AppSpacing.formRowSpacing),
                  LabeledFormField(
                    label: l10n.bookingsListFilterStatus,
                    child: DropdownButtonFormField<String>(
                      value: _selectedBookingStatus,
                      isExpanded: true,
                      decoration: const InputDecoration(
                        border: OutlineInputBorder(),
                        isDense: true,
                      ),
                      hint: Text(
                        _statusLabel(context, _currentBookingStatus),
                      ),
                      items: [
                        for (final status in statusOptions)
                          DropdownMenuItem<String>(
                            value: status,
                            child: Text(_statusLabel(context, status)),
                          ),
                      ],
                      onChanged: (value) {
                        setState(() => _selectedBookingStatus = value);
                      },
                    ),
                  ),
                ],

                // Ricorrenza (solo per nuovi appuntamenti)
                if (!isEdit) ...[
                  const SizedBox(height: AppSpacing.formRowSpacing),
                  RecurrencePicker(
                    startDate: _date,
                    initialConfig: _recurrenceConfig,
                    onChanged: (config) {
                      setState(() => _recurrenceConfig = config);
                    },
                  ),
                  if (_recurrenceConfig != null) ...[
                    const SizedBox(height: 12),
                    RecurrencePreview(
                      startDate: _date,
                      config: _recurrenceConfig!,
                    ),
                  ],
                ],

                const SizedBox(height: AppSpacing.formRowSpacing),
              ],
            ),
          ),
        ),
      ),
    );

    final actions = [
      AppOutlinedActionButton(
        onPressed: _isSaving ? null : () => Navigator.of(context).pop(),
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppAsyncFilledButton(
        onPressed: _isSaving || !canManageBookings ? null : _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        isLoading: _isSaving && canManageBookings,
        showSpinner: false,
        child: Text(l10n.actionSave),
      ),
    ];

    if (isDialog) {
      return CallbackShortcuts(
        bindings: {
          // Ctrl+Enter o Cmd+Enter per salvare
          const SingleActivator(LogicalKeyboardKey.enter, control: true): () {
            if (!_isSaving && canManageBookings) _onSave();
          },
          const SingleActivator(LogicalKeyboardKey.enter, meta: true): () {
            if (!_isSaving && canManageBookings) _onSave();
          },
        },
        child: Focus(
          autofocus: true,
          child: DismissibleDialog(
            child: Dialog(
              insetPadding: const EdgeInsets.symmetric(
                horizontal: 32,
                vertical: 24,
              ),
              child: ConstrainedBox(
                constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
                child: LocalLoadingOverlay(
                  isLoading: _isSaving,
                  child: Padding(
                    padding: const EdgeInsets.all(20),
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      crossAxisAlignment: CrossAxisAlignment.stretch,
                      children: [
                        Text(
                          title,
                          style: Theme.of(context).textTheme.headlineSmall,
                        ),
                        const SizedBox(height: 8),
                        Flexible(child: content),
                        const SizedBox(height: AppSpacing.formToActionsSpacing),
                        Padding(
                          padding: const EdgeInsets.only(
                            bottom: AppSpacing.formFirstRowSpacing,
                          ),
                          child: _warningBanner(
                            20,
                            showAppointmentWarning,
                            l10n.bookingUnavailableTimeWarningAppointment,
                          ),
                        ),
                        Row(
                          mainAxisAlignment: MainAxisAlignment.end,
                          children: [
                            for (int i = 0; i < actions.length; i++) ...[
                              if (i > 0) const SizedBox(width: 8),
                              SizedBox(
                                width: AppButtonStyles.dialogButtonWidth,
                                child: actions[i],
                              ),
                            ],
                          ],
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),
        ),
      );
    }

    // Bottom sheet layout
    const horizontalPadding = 20.0;
    final titlePadding = EdgeInsets.fromLTRB(
      horizontalPadding,
      0,
      horizontalPadding,
      12,
    );

    final isKeyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
    return SafeArea(
      top: false,
      child: LocalLoadingOverlay(
        isLoading: _isSaving,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          mainAxisSize: MainAxisSize.min,
          children: [
            Padding(
              padding: titlePadding,
              child: Text(title, style: Theme.of(context).textTheme.titleLarge),
            ),
            Expanded(
              child: Padding(
                padding: EdgeInsets.symmetric(horizontal: horizontalPadding),
                child: content,
              ),
            ),
            _warningBanner(
              horizontalPadding,
              showAppointmentWarning,
              l10n.bookingUnavailableTimeWarningAppointment,
            ),
            if (!isKeyboardOpen) ...[
              const AppDivider(),
              Padding(
                padding: EdgeInsets.fromLTRB(
                  horizontalPadding,
                  AppSpacing.formFirstRowSpacing,
                  horizontalPadding,
                  0,
                ),
                child: Row(
                  mainAxisAlignment: actions.length == 3
                      ? MainAxisAlignment.center
                      : MainAxisAlignment.end,
                  children: [
                    for (int i = 0; i < actions.length; i++) ...[
                      if (i > 0) const SizedBox(width: 8),
                      SizedBox(
                        width: AppButtonStyles.dialogButtonWidth,
                        child: actions[i],
                      ),
                    ],
                  ],
                ),
              ),
            ],
            SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
          ],
        ),
      ),
    );
  }

  List<Widget> _buildServiceItems({
    required List<dynamic> services,
    required List<dynamic> categories,
    required List<dynamic> variants,
    required List<dynamic> allStaff,
    required int? forcedStaffId,
    required AppFormFactor formFactor,
    required List<bool> conflictFlags,
    required bool showServiceWarnings,
    required String serviceWarningMessage,
    required PopularServicesResult? popularServices,
    required bool hasPackages,
  }) {
    final widgets = <Widget>[];

    // Conta servizi effettivamente selezionati
    final selectedCount = _serviceItems
        .where((s) => s.serviceId != null)
        .length;

    // Calcola i serviceIds dello staff preselezionato (se presente)
    List<int>? preselectedStaffServiceIds;
    if (widget.initialStaffId != null) {
      final initialStaff = allStaff.cast<dynamic>().firstWhere(
        (s) => s.id == widget.initialStaffId,
        orElse: () => null,
      );
      if (initialStaff != null) {
        preselectedStaffServiceIds = (initialStaff.serviceIds as List<int>);
      }
    }

    for (int i = 0; i < _serviceItems.length; i++) {
      final item = forcedStaffId != null
          ? _serviceItems[i].copyWith(staffId: forcedStaffId)
          : _serviceItems[i];
      final TimeOfDay? suggestedStartTime = i > 0
          ? _resolveServiceEndTime(_serviceItems[i - 1], variants.cast())
          : null;
      final variant = item.serviceId != null
          ? variants.cast<ServiceVariant?>().firstWhere(
              (v) => v?.serviceId == item.serviceId,
              orElse: () => null,
            )
          : null;
      final defaultProcessing = variant?.processingTime ?? 0;
      final defaultBlocked = variant?.blockedTime ?? 0;
      final defaultExtraType = defaultBlocked > 0
          ? ExtraMinutesType.blocked
          : (defaultProcessing > 0 ? ExtraMinutesType.processing : null);
      final hasBlockedExtra = item.blockedExtraMinutes > 0;
      final hasProcessingExtra = item.processingExtraMinutes > 0;
      final canAddDefaultExtra = defaultExtraType == ExtraMinutesType.blocked
          ? !hasBlockedExtra
          : (defaultExtraType == ExtraMinutesType.processing
                ? !hasProcessingExtra
                : false);
      final showWarning =
          showServiceWarnings &&
          _isWarningEligible(item) &&
          i < conflictFlags.length &&
          conflictFlags[i];

      // Get eligible staff for this service
      final eligibleStaffIds = item.serviceId != null
          ? ref.watch(eligibleStaffForServiceProvider(item.serviceId!))
          : <int>[];
      final isStaffIneligible =
          item.serviceId != null &&
          item.staffId != null &&
          !eligibleStaffIds.contains(item.staffId);

      final isFirst = i == 0;
      final isLast = i == _serviceItems.length - 1;
      widgets.add(
        Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            if (isFirst) ...[
              Row(
                children: [
                  Text(
                    selectedCount > 0
                        ? context.l10n.servicesSelectedCount(selectedCount)
                        : context.l10n.formServices,
                    style: const TextStyle(fontWeight: FontWeight.w600),
                  ),
                ],
              ),
              const SizedBox(height: 8),
            ],
            Padding(
              padding: const EdgeInsets.only(bottom: 12),
              child: ServiceItemCard(
                index: i,
                item: item,
                services: services.cast(),
                categories: categories.cast(),
                variants: variants.cast(),
                eligibleStaff: eligibleStaffIds,
                allStaff: allStaff.cast(),
                formFactor: formFactor,
                canRemove: _serviceItems.length > 1,
                // Obbligatorio solo se non ci sono altri servizi selezionati
                isServiceRequired: selectedCount == 0,
                packages: ref.read(servicePackagesProvider).value,
                popularServices: popularServices,
                onPackageSelected: (package) =>
                    _onPackageSelectedFromPicker(package, i),
                onChanged: (updated) => _updateServiceItem(
                  i,
                  updated,
                  forcedStaffId: forcedStaffId,
                ),
                onRemove: () => _removeServiceItem(i),
                onStartTimeChanged: (time) => _updateServiceStartTime(i, time),
                onEndTimeChanged: (time) => _updateServiceEndTime(i, time),
                onDurationChanged: (duration) =>
                    _updateServiceDuration(i, duration),
                suggestedStartTime: suggestedStartTime,
                autoOpenServicePicker:
                    (_shouldAutoOpenServicePicker && i == 0) ||
                    _autoOpenServicePickerIndex == i,
                onServicePickerAutoOpened:
                    (_shouldAutoOpenServicePicker && i == 0) ||
                        _autoOpenServicePickerIndex == i
                    ? () {
                        if (_shouldAutoOpenServicePicker && i == 0) {
                          _onServicePickerAutoOpened();
                        }
                        _onServicePickerAutoOpenedForIndex(i);
                      }
                    : null,
                onServicePickerAutoCompleted: _scrollFormToBottom,
                onAutoOpenStaffPickerCompleted: _scrollFormToBottom,
                availabilityWarningMessage: showWarning
                    ? serviceWarningMessage
                    : null,
                staffEligibilityWarningMessage: isStaffIneligible
                    ? context.l10n.bookingStaffNotEligibleWarning
                    : null,
                preselectedStaffServiceIds: preselectedStaffServiceIds,
                canSelectStaff: forcedStaffId == null,
              ),
            ),
            if (canAddDefaultExtra) ...[
              if (isLast && item.serviceId != null)
                Row(
                  children: [
                    AppOutlinedActionButton(
                      onPressed: () {
                        setState(() {
                          _serviceItems[i] =
                              defaultExtraType == ExtraMinutesType.blocked
                              ? _serviceItems[i].copyWith(
                                  blockedExtraMinutes: defaultBlocked,
                                )
                              : _serviceItems[i].copyWith(
                                  processingExtraMinutes: defaultProcessing,
                                );
                          _recalculateTimesFrom(i + 1, variants.cast());
                          _clearMidnightWarningIfResolved(variants.cast());
                        });
                      },
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.add, size: 18),
                          const SizedBox(width: 8),
                          Text(context.l10n.additionalTimeSwitch),
                        ],
                      ),
                    ),
                    const Spacer(),
                    AppOutlinedActionButton(
                      onPressed: _isAddingPackage ? null : _addService,
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.add, size: 18),
                          const SizedBox(width: 8),
                          Text(context.l10n.addService),
                        ],
                      ),
                    ),
                    if (hasPackages) ...[
                      const SizedBox(width: 8),
                      AppOutlinedActionButton(
                        onPressed: _isAddingPackage ? null : _addPackage,
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Icon(Icons.widgets_outlined, size: 18),
                            const SizedBox(width: 8),
                            Text(context.l10n.addPackage),
                          ],
                        ),
                      ),
                    ],
                  ],
                )
              else
                Align(
                  alignment: Alignment.centerRight,
                  child: AppOutlinedActionButton(
                    onPressed: () {
                      setState(() {
                        _serviceItems[i] =
                            defaultExtraType == ExtraMinutesType.blocked
                            ? _serviceItems[i].copyWith(
                                blockedExtraMinutes: defaultBlocked,
                              )
                            : _serviceItems[i].copyWith(
                                processingExtraMinutes: defaultProcessing,
                              );
                        _recalculateTimesFrom(i + 1, variants.cast());
                        _clearMidnightWarningIfResolved(variants.cast());
                      });
                    },
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const Icon(Icons.add, size: 18),
                        const SizedBox(width: 8),
                        Text(context.l10n.additionalTimeSwitch),
                      ],
                    ),
                  ),
                ),
              const SizedBox(height: 16),
              if (isLast &&
                  item.serviceId != null &&
                  _midnightWarningVisible &&
                  !_midnightWarningDismissed) ...[
                _midnightWarningBanner(),
                const SizedBox(height: 16),
              ],
            ],
            if (hasBlockedExtra) ...[
              ExtraTimeCard(
                title: context.l10n.fieldBlockedTimeLabel,
                startTime: _baseEndTime(item, variants.cast()),
                durationMinutes: item.blockedExtraMinutes,
                formFactor: formFactor,
                onStartTimeChanged: (_) {},
                onDurationChanged: (duration) {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      blockedExtraMinutes: duration,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                    _clearMidnightWarningIfResolved(variants.cast());
                  });
                },
                onRemove: () {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      blockedExtraMinutes: 0,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                    _clearMidnightWarningIfResolved(variants.cast());
                  });
                },
              ),
              const SizedBox(height: 8),
            ],
            if (hasProcessingExtra) ...[
              ExtraTimeCard(
                title: context.l10n.fieldProcessingTimeLabel,
                startTime: _addMinutes(
                  _baseEndTime(item, variants.cast()),
                  item.blockedExtraMinutes,
                ),
                durationMinutes: item.processingExtraMinutes,
                formFactor: formFactor,
                onStartTimeChanged: (_) {},
                onDurationChanged: (duration) {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      processingExtraMinutes: duration,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                    _clearMidnightWarningIfResolved(variants.cast());
                  });
                },
                onRemove: () {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      processingExtraMinutes: 0,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                    _clearMidnightWarningIfResolved(variants.cast());
                  });
                },
              ),
              const SizedBox(height: 8),
            ],
            if (isLast && item.serviceId != null && !canAddDefaultExtra) ...[
              Align(
                alignment: Alignment.centerRight,
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    AppOutlinedActionButton(
                      onPressed: _isAddingPackage ? null : _addService,
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.add, size: 18),
                          const SizedBox(width: 8),
                          Text(context.l10n.addService),
                        ],
                      ),
                    ),
                    if (hasPackages) ...[
                      const SizedBox(width: 8),
                      AppOutlinedActionButton(
                        onPressed: _isAddingPackage ? null : _addPackage,
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Icon(Icons.widgets_outlined, size: 18),
                            const SizedBox(width: 8),
                            Text(context.l10n.addPackage),
                          ],
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              const SizedBox(height: 8),
              if (_midnightWarningVisible && !_midnightWarningDismissed) ...[
                _midnightWarningBanner(),
                const SizedBox(height: 8),
              ],
            ],
          ],
        ),
      );
    }

    if (_serviceItems.isEmpty) {
      widgets.add(
        Container(
          padding: const EdgeInsets.all(24),
          decoration: BoxDecoration(
            border: Border.all(color: Theme.of(context).colorScheme.outline),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Center(
            child: Text(
              context.l10n.noServicesAdded,
              style: TextStyle(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ),
        ),
      );
    }

    // Riepilogo totali (solo se pi√π di un servizio)
    final selectedServices = _serviceItems
        .where((s) => s.serviceId != null)
        .toList();
    if (selectedServices.length > 1) {
      int totalDurationMinutes = 0;
      double totalPrice = 0;

      for (final item in selectedServices) {
        final variant = variants.cast<ServiceVariant?>().firstWhere(
          (v) => v?.serviceId == item.serviceId,
          orElse: () => null,
        );
        if (variant != null) {
          // Durata base + extra times
          final baseDuration = item.durationMinutes > 0
              ? item.durationMinutes
              : variant.durationMinutes;
          totalDurationMinutes +=
              baseDuration +
              item.blockedExtraMinutes +
              item.processingExtraMinutes;
          // Prezzo (usa price personalizzato o da variant)
          totalPrice += item.price ?? variant.price;
        }
      }

      final hours = totalDurationMinutes ~/ 60;
      final minutes = totalDurationMinutes % 60;
      final durationStr = hours > 0
          ? (minutes > 0 ? '${hours}h ${minutes}min' : '${hours}h')
          : '${minutes}min';

      widgets.add(
        Container(
          margin: const EdgeInsets.only(top: 16),
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          decoration: BoxDecoration(
            color: Theme.of(context).colorScheme.surfaceContainerHighest,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                context.l10n.bookingTotalDuration(durationStr),
                style: const TextStyle(fontWeight: FontWeight.w500),
              ),
              Text(
                context.l10n.bookingTotalPrice(
                  PriceFormatter.format(
                    context: context,
                    amount: totalPrice,
                    currencyCode: PriceFormatter.effectiveCurrency(ref),
                  ),
                ),
                style: const TextStyle(fontWeight: FontWeight.w600),
              ),
            ],
          ),
        ),
      );
    }

    return widgets;
  }

  Widget _warningBanner(
    double horizontalPadding,
    bool hasConflicts,
    String message,
  ) {
    if (!hasConflicts || _warningDismissed) return const SizedBox.shrink();
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.amber.withOpacity(0.18),
        borderRadius: BorderRadius.circular(8),
      ),
      padding: EdgeInsets.fromLTRB(
        horizontalPadding,
        12,
        horizontalPadding,
        12,
      ),
      child: Row(
        children: [
          const Icon(
            Icons.warning_amber_rounded,
            color: Colors.amber,
            size: 20,
          ),
          const SizedBox(width: 10),
          Expanded(
            child: Text(
              message,
              style: const TextStyle(
                color: Color(0xFF8A4D00),
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          IconButton(
            icon: const Icon(Icons.close, size: 18),
            color: const Color(0xFF8A4D00),
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints.tightFor(width: 32, height: 32),
            onPressed: () {
              setState(() => _warningDismissed = true);
            },
          ),
        ],
      ),
    );
  }

  Widget _midnightWarningBanner() {
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.amber.withOpacity(0.18),
        borderRadius: BorderRadius.circular(8),
      ),
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 12),
      child: Row(
        children: [
          const Icon(
            Icons.warning_amber_rounded,
            color: Colors.amber,
            size: 20,
          ),
          const SizedBox(width: 10),
          Expanded(
            child: Text(
              context.l10n.serviceStartsAfterMidnight,
              style: const TextStyle(
                color: Color(0xFF8A4D00),
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          IconButton(
            icon: const Icon(Icons.close, size: 18),
            color: const Color(0xFF8A4D00),
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints.tightFor(width: 32, height: 32),
            onPressed: () {
              setState(() => _midnightWarningDismissed = true);
            },
          ),
        ],
      ),
    );
  }

  void _showMidnightWarning() {
    setState(() {
      _midnightWarningVisible = true;
      _midnightWarningDismissed = false;
    });
  }

  void _clearMidnightWarningIfResolved(List<ServiceVariant> variants) {
    if (!_midnightWarningVisible) return;
    if (!_hasMidnightOverflow(variants)) {
      _midnightWarningVisible = false;
      _midnightWarningDismissed = false;
    }
  }

  bool _hasMidnightOverflow(List<ServiceVariant> variants) {
    for (final item in _serviceItems) {
      final startMinutes = item.startTime.hour * 60 + item.startTime.minute;
      final endTime = _resolveServiceEndTime(item, variants);
      final endMinutes = endTime.hour * 60 + endTime.minute;
      if (endMinutes < startMinutes) return true;
    }
    return false;
  }

  bool _isWarningEligible(ServiceItemData item) {
    return item.serviceId != null && item.staffId != null;
  }

  List<bool> _serviceConflictFlags() {
    final layout = ref.watch(layoutConfigProvider);
    final Map<int, Set<int>> cache = {};
    final flags = <bool>[];

    for (final item in _serviceItems) {
      final staffId = item.staffId;
      if (staffId == null || item.serviceId == null) {
        flags.add(false);
        continue;
      }

      final available = cache.putIfAbsent(
        staffId,
        () => ref.watch(staffSlotAvailabilityProvider(staffId)),
      );

      if (available.isEmpty) {
        flags.add(true);
        continue;
      }

      final startMinutes = item.startTime.hour * 60 + item.startTime.minute;
      final endMinutes = startMinutes + item.durationMinutes;
      final startSlot = startMinutes ~/ layout.minutesPerSlot;
      final endSlot = (endMinutes / layout.minutesPerSlot).ceil();

      var hasConflict = false;
      for (int slot = startSlot; slot < endSlot; slot++) {
        if (!available.contains(slot)) {
          hasConflict = true;
          break;
        }
      }
      flags.add(hasConflict);
    }
    return flags;
  }

  void _scheduleAutoClientPicker() {
    if (_clientPickerAutoRequested) return;
    _clientPickerAutoRequested = true;
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      _openClientPicker(triggerServiceAutoOpen: true);
    });
  }

  Future<void> _scheduleAutoDatePicker() async {
    if (_datePickerAutoRequested) return;
    _datePickerAutoRequested = true;
    await _pickDate();
  }

  Future<void> _openClientPicker({bool triggerServiceAutoOpen = false}) async {
    final formFactor = ref.read(formFactorProvider);
    final isDesktop = formFactor == AppFormFactor.desktop;
    bool dismissed = false;

    while (mounted) {
      if (!mounted) return;
      final clients = ref.read(clientsListProvider);
      _ClientItem? result;
      if (isDesktop) {
        result = await showDialog<_ClientItem?>(
          context: context,
          builder: (ctx) => Dialog(
            insetPadding: const EdgeInsets.symmetric(
              horizontal: 32,
              vertical: 24,
            ),
            child: ConstrainedBox(
              constraints: const BoxConstraints(
                minWidth: 600,
                maxWidth: 720,
                maxHeight: 600,
              ),
              child: _ClientPickerSheet(
                clients: clients,
                selectedClientId: _clientId,
              ),
            ),
          ),
        );
      } else {
        result = await AppBottomSheet.show<_ClientItem?>(
          context: context,
          useRootNavigator: true,
          padding: EdgeInsets.zero,
          heightFactor: AppBottomSheet.defaultHeightFactor,
          builder: (ctx) =>
              _ClientPickerSheet(clients: clients, selectedClientId: _clientId),
        );
      }

      if (result == null) {
        dismissed = true;
        break;
      }
      final selectedResult = result;
      if (selectedResult.id == -2) {
        if (!mounted) return;
        Client? initialClient;
        if (selectedResult.name.isNotEmpty) {
          final nameParts = Client.splitFullName(selectedResult.name);
          // NON passare businessId: lasciare che ClientForm usi currentBusinessProvider
          initialClient = Client(
            id: 0,
            businessId: ref.read(currentBusinessProvider).id,
            firstName: nameParts.firstName,
            lastName: nameParts.lastName,
            createdAt: DateTime.now(),
          );
        }
        final newClient = await showClientEditDialog(
          context,
          ref,
          client: initialClient,
        );
        if (newClient != null) {
          setState(() {
            _clientId = newClient.id;
            _customClientName = newClient.name;
          });
          break;
        }
        continue;
      } else if (selectedResult.id == -1) {
        setState(() {
          _clientId = null;
          _customClientName = '';
        });
        break;
      } else {
        setState(() {
          _clientId = selectedResult.id;
          _customClientName = selectedResult.name;
        });
        break;
      }
    }

    if (!mounted) return;
    if (triggerServiceAutoOpen && !dismissed) {
      setState(() {
        _shouldAutoOpenServicePicker = true;
      });
    }
  }

  void _onServicePickerAutoOpened() {
    if (!_shouldAutoOpenServicePicker) return;
    setState(() {
      _shouldAutoOpenServicePicker = false;
    });
  }

  void _onServicePickerAutoOpenedForIndex(int index) {
    if (_autoOpenServicePickerIndex != index) return;
    setState(() {
      _autoOpenServicePickerIndex = null;
    });
  }

  void _addService() {
    final variants = ref.read(serviceVariantsProvider).value ?? [];
    // Calcola l'orario di inizio per il nuovo servizio
    TimeOfDay nextStart;
    if (_serviceItems.isEmpty) {
      nextStart = widget.initialTime ?? const TimeOfDay(hour: 10, minute: 0);
    } else {
      // Prendi l'ultimo servizio e calcola il suo orario di fine
      final lastItem = _serviceItems.last;
      final lastStartMinutes =
          lastItem.startTime.hour * 60 + lastItem.startTime.minute;
      final lastEnd = _resolveServiceEndTime(lastItem, variants);
      final lastEndMinutes = lastEnd.hour * 60 + lastEnd.minute;

      // Blocca se il servizio precedente termina dopo la mezzanotte
      if (lastEndMinutes < lastStartMinutes) {
        _showMidnightWarning();
        return;
      }
      nextStart = lastEnd;
    }

    // Smart staff selection: usa lo staff dell'ultimo servizio se presente
    int? smartStaffId = _serviceItems.isNotEmpty
        ? _serviceItems.last.staffId
        : widget.initialStaffId;

    final newIndex = _serviceItems.length;
    setState(() {
      _clearMidnightWarningIfResolved(variants.cast());
      _serviceItems.add(
        ServiceItemData(
          key: _nextItemKey(),
          startTime: nextStart,
          staffId: smartStaffId,
        ),
      );
      _autoOpenServicePickerIndex = newIndex;
    });
  }

  Future<void> _addPackage() async {
    if (_isAddingPackage) return;

    final l10n = context.l10n;
    final packages = ref.read(servicePackagesProvider).value ?? [];
    if (packages.isEmpty) {
      if (!context.mounted) return;
      await FeedbackDialog.showError(
        context,
        title: l10n.errorTitle,
        message: l10n.servicePackagesEmptyState,
      );
      return;
    }

    setState(() => _isAddingPackage = true);
    final selected = await showServicePackagePickerDialog(
      context,
      packages: packages,
    );
    if (!context.mounted) return;
    if (selected == null) {
      setState(() => _isAddingPackage = false);
      return;
    }

    try {
      final locationId = ref.read(currentLocationProvider).id;
      final repository = ref.read(servicePackagesRepositoryProvider);
      final expansion = await repository.expandPackage(
        locationId: locationId,
        packageId: selected.id,
      );
      if (expansion.serviceIds.isEmpty) {
        if (!mounted) return;
        await FeedbackDialog.showError(
          context,
          title: l10n.errorTitle,
          message: l10n.servicePackageExpandError,
        );
      } else {
        _appendServicesFromPackage(expansion.serviceIds);
      }
    } catch (_) {
      if (!mounted) return;
      await FeedbackDialog.showError(
        context,
        title: l10n.errorTitle,
        message: l10n.servicePackageExpandError,
      );
    } finally {
      if (mounted) {
        setState(() => _isAddingPackage = false);
      }
    }
  }

  /// Called when a package is selected from the service picker.
  /// This expands the package and replaces the current empty service slot.
  Future<void> _onPackageSelectedFromPicker(
    ServicePackage package,
    int currentIndex,
  ) async {
    if (_isAddingPackage) return;

    final l10n = context.l10n;
    setState(() => _isAddingPackage = true);

    try {
      final locationId = ref.read(currentLocationProvider).id;
      final repository = ref.read(servicePackagesRepositoryProvider);
      final expansion = await repository.expandPackage(
        locationId: locationId,
        packageId: package.id,
      );
      if (expansion.serviceIds.isEmpty) {
        if (!mounted) return;
        await FeedbackDialog.showError(
          context,
          title: l10n.errorTitle,
          message: l10n.servicePackageExpandError,
        );
      } else {
        // Capture staff from current slot before removing it
        int? staffIdFromSlot;
        if (_serviceItems.isNotEmpty && currentIndex < _serviceItems.length) {
          staffIdFromSlot = _serviceItems[currentIndex].staffId;
        }
        // Check if we need to remove empty slot
        final shouldRemoveEmpty =
            _serviceItems.isNotEmpty &&
            currentIndex < _serviceItems.length &&
            _serviceItems[currentIndex].serviceId == null;
        // Pass the captured staff and removal index to do everything in one setState
        _appendServicesFromPackage(
          expansion.serviceIds,
          overrideStaffId: staffIdFromSlot,
          removeEmptyAtIndex: shouldRemoveEmpty ? currentIndex : null,
        );
      }
    } catch (_) {
      if (!mounted) return;
      await FeedbackDialog.showError(
        context,
        title: l10n.errorTitle,
        message: l10n.servicePackageExpandError,
      );
    } finally {
      if (mounted) {
        setState(() => _isAddingPackage = false);
      }
    }
  }

  /// Appends services from a package.
  /// If [overrideStaffId] is provided, it will be used for ALL services.
  /// Otherwise, uses smart staff selection (last item's staff or initial).
  /// If [removeEmptyAtIndex] is provided, removes the empty slot at that index
  /// before appending (all in one setState to avoid visual flash).
  void _appendServicesFromPackage(
    List<int> serviceIds, {
    int? overrideStaffId,
    int? removeEmptyAtIndex,
  }) {
    final variants = ref.read(serviceVariantsProvider).value ?? [];

    setState(() {
      // Remove empty slot first if requested (before calculating staff)
      if (removeEmptyAtIndex != null &&
          _serviceItems.isNotEmpty &&
          removeEmptyAtIndex < _serviceItems.length &&
          _serviceItems[removeEmptyAtIndex].serviceId == null) {
        _serviceItems.removeAt(removeEmptyAtIndex);
      }

      // Calculate staff ONCE before the loop to use the same for all services
      final staffIdForAll =
          overrideStaffId ??
          (_serviceItems.isNotEmpty
              ? _serviceItems.last.staffId
              : widget.initialStaffId);

      for (final serviceId in serviceIds) {
        TimeOfDay nextStart;
        if (_serviceItems.isEmpty) {
          nextStart =
              widget.initialTime ?? const TimeOfDay(hour: 10, minute: 0);
        } else {
          final lastItem = _serviceItems.last;
          final lastStartMinutes =
              lastItem.startTime.hour * 60 + lastItem.startTime.minute;
          final lastEnd = _resolveServiceEndTime(lastItem, variants);
          final lastEndMinutes = lastEnd.hour * 60 + lastEnd.minute;

          if (lastEndMinutes < lastStartMinutes) {
            _showMidnightWarning();
            break;
          }
          nextStart = lastEnd;
        }

        final variant = variants
            .where((v) => v.serviceId == serviceId)
            .firstOrNull;
        final duration = variant?.durationMinutes ?? 30;

        _serviceItems.add(
          ServiceItemData(
            key: _nextItemKey(),
            serviceId: serviceId,
            serviceVariantId: variant?.id,
            startTime: nextStart,
            durationMinutes: duration,
            staffId: staffIdForAll,
            blockedExtraMinutes: variant?.blockedTime ?? 0,
            processingExtraMinutes: variant?.processingTime ?? 0,
          ),
        );
      }

      _clearMidnightWarningIfResolved(variants.cast());
    });
  }

  void _removeServiceItem(int index) {
    if (_serviceItems.length <= 1) return;

    final variants = ref.read(serviceVariantsProvider).value ?? [];

    setState(() {
      _serviceItems.removeAt(index);

      // Ricalcola gli orari per i servizi successivi
      _recalculateTimesFrom(index, variants);
      _clearMidnightWarningIfResolved(variants.cast());
    });
  }

  void _updateServiceItem(
    int index,
    ServiceItemData updated, {
    int? forcedStaffId,
  }) {
    final variants = ref.read(serviceVariantsProvider).value ?? [];
    final oldItem = _serviceItems[index];
    final effectiveUpdated = forcedStaffId != null
        ? updated.copyWith(staffId: forcedStaffId)
        : updated;

    setState(() {
      _serviceItems[index] = effectiveUpdated;

      // Se cambia il servizio, potremmo dover aggiornare lo staff
      // e ricalcolare gli orari successivi
      _recalculateTimesFrom(index + 1, variants);

      // Se lo staff √® ancora null, seleziona automaticamente un eligible
      if (effectiveUpdated.serviceId != null &&
          effectiveUpdated.staffId == null) {
        final newStaffId = _findBestStaff(effectiveUpdated.serviceId!);
        _serviceItems[index] = effectiveUpdated.copyWith(staffId: newStaffId);
      }

      // Propagate staff to subsequent services that don't have a staff yet
      // This is useful when user selects staff on first service of a package
      if (effectiveUpdated.staffId != null &&
          oldItem.staffId != effectiveUpdated.staffId) {
        for (var i = index + 1; i < _serviceItems.length; i++) {
          if (forcedStaffId != null || _serviceItems[i].staffId == null) {
            _serviceItems[i] = _serviceItems[i].copyWith(
              staffId: effectiveUpdated.staffId,
            );
          }
        }
      }

      _clearMidnightWarningIfResolved(variants.cast());
    });
  }

  void _updateServiceStartTime(int index, TimeOfDay newTime) {
    final variants = ref.read(serviceVariantsProvider).value ?? [];
    if (index > 0) {
      final prev = _serviceItems[index - 1];
      final prevStartMinutes = prev.startTime.hour * 60 + prev.startTime.minute;
      final prevEnd = _resolveServiceEndTime(prev, variants);
      final prevEndMinutes = prevEnd.hour * 60 + prevEnd.minute;
      if (prevEndMinutes < prevStartMinutes) {
        _showMidnightWarning();
        return;
      }
    }

    setState(() {
      final updated = _serviceItems[index].copyWith(startTime: newTime);
      _serviceItems[index] = _applyAutoExtraStart(updated, variants);

      // Ricalcola gli orari per i servizi successivi
      _recalculateTimesFrom(index + 1, variants);
      _clearMidnightWarningIfResolved(variants.cast());
    });
  }

  void _updateServiceEndTime(int index, TimeOfDay newEndTime) {
    setState(() {
      final item = _serviceItems[index];

      // Calcola la nuova durata basata sulla differenza tra end e start
      final startMinutes = item.startTime.hour * 60 + item.startTime.minute;
      final endMinutes = newEndTime.hour * 60 + newEndTime.minute;
      var newDuration = endMinutes - startMinutes;

      // Se la durata √® negativa o zero, imposta un minimo di 15 minuti
      if (newDuration <= 0) {
        newDuration = 15;
      }

      _serviceItems[index] = item.copyWith(durationMinutes: newDuration);

      // Ricalcola gli orari per i servizi successivi
      final variants = ref.read(serviceVariantsProvider).value ?? [];
      _serviceItems[index] = _applyAutoExtraStart(
        _serviceItems[index],
        variants,
      );
      _recalculateTimesFrom(index + 1, variants);
      _clearMidnightWarningIfResolved(variants.cast());
    });
  }

  void _updateServiceDuration(int index, int newDuration) {
    setState(() {
      _serviceItems[index] = _serviceItems[index].copyWith(
        durationMinutes: newDuration,
      );

      // Ricalcola gli orari per i servizi successivi
      final variants = ref.read(serviceVariantsProvider).value ?? [];
      _serviceItems[index] = _applyAutoExtraStart(
        _serviceItems[index],
        variants,
      );
      _recalculateTimesFrom(index + 1, variants);
      _clearMidnightWarningIfResolved(variants.cast());
    });
  }

  void _recalculateTimesFrom(int fromIndex, List<ServiceVariant> variants) {
    if (fromIndex <= 0 || fromIndex >= _serviceItems.length) return;

    for (int i = fromIndex; i < _serviceItems.length; i++) {
      final prevItem = _serviceItems[i - 1];
      final prevEnd = _resolveServiceEndTime(prevItem, variants);
      final updated = _serviceItems[i].copyWith(startTime: prevEnd);
      _serviceItems[i] = _applyAutoExtraStart(updated, variants);
    }
  }

  TimeOfDay _resolveServiceEndTime(
    ServiceItemData item,
    List<ServiceVariant> variants,
  ) {
    final baseEnd = _baseEndTime(item, variants);
    final totalExtra = item.blockedExtraMinutes + item.processingExtraMinutes;
    if (totalExtra <= 0) {
      return baseEnd;
    }
    return _addMinutes(baseEnd, totalExtra);
  }

  ServiceItemData _applyAutoExtraStart(
    ServiceItemData item,
    List<ServiceVariant> variants,
  ) {
    return item;
  }

  TimeOfDay _baseEndTime(ServiceItemData item, List<ServiceVariant> variants) {
    final variant = _variantForItem(item, variants);
    final baseDuration = item.durationMinutes > 0
        ? item.durationMinutes
        : (variant?.durationMinutes ?? 30);
    return item.getEndTime(baseDuration);
  }

  ServiceVariant? _variantForItem(
    ServiceItemData item,
    List<ServiceVariant> variants,
  ) {
    if (item.serviceVariantId != null) {
      for (final v in variants) {
        if (v.id == item.serviceVariantId) return v;
      }
    }
    if (item.serviceId != null) {
      for (final v in variants) {
        if (v.serviceId == item.serviceId) return v;
      }
    }
    return null;
  }

  TimeOfDay _addMinutes(TimeOfDay time, int minutes) {
    final totalMinutes = time.hour * 60 + time.minute + minutes;
    return TimeOfDay(
      hour: (totalMinutes ~/ 60) % 24,
      minute: totalMinutes % 60,
    );
  }

  /// Trova lo staff migliore per un servizio:
  /// 1. Primo staff eligible disponibile
  /// 2. null per selezione manuale
  int? _findBestStaff(int serviceId) {
    final eligibleIds = ref.read(eligibleStaffForServiceProvider(serviceId));
    if (eligibleIds.isEmpty) return null;
    return eligibleIds.first;
  }

  Future<void> _pickDate() async {
    final picked = await showDialog<DateTime>(
      context: context,
      builder: (context) {
        return Dialog(
          child: CalendarDatePicker(
            initialDate: _date,
            firstDate: DateTime.now().subtract(const Duration(days: 365)),
            lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
            onDateChanged: (value) => Navigator.of(context).pop(value),
          ),
        );
      },
    );
    if (picked != null) {
      setState(() => _date = DateUtils.dateOnly(picked));
    }
  }

  void _scrollFormToBottom() {
    if (!_scrollController.hasClients) return;
    _scrollController.animateTo(
      _scrollController.position.maxScrollExtent,
      duration: const Duration(milliseconds: 250),
      curve: Curves.easeOut,
    );
  }

  int? _forcedStaffIdForCurrentUser() {
    final role = ref.read(currentUserRoleProvider);
    final staffId = ref.read(currentUserStaffIdProvider);
    if (role == 'staff' && staffId != null && staffId > 0) {
      return staffId;
    }
    return null;
  }

  Future<void> _onSave() async {
    if (!mounted) return;
    final canManageBookings = ref.read(currentUserCanManageBookingsProvider);
    if (!canManageBookings) return;

    final l10n = context.l10n;
    if (!_formKey.currentState!.validate()) return;

    final forcedStaffId = _forcedStaffIdForCurrentUser();

    // Verifica che ci sia almeno un servizio con dati completi
    final validItems = _serviceItems
        .where((item) => item.serviceId != null && item.staffId != null)
        .map(
          (item) => forcedStaffId != null
              ? item.copyWith(staffId: forcedStaffId)
              : item,
        )
        .toList();

    if (validItems.isEmpty) {
      await FeedbackDialog.showError(
        context,
        title: l10n.errorTitle,
        message: l10n.atLeastOneServiceRequired,
      );
      return;
    }

    // Per gli appuntamenti ricorrenti √® obbligatorio selezionare un cliente
    if (_recurrenceConfig != null && _clientId == null) {
      await FeedbackDialog.showError(
        context,
        title: l10n.errorTitle,
        message: l10n.recurrenceClientRequired,
      );
      return;
    }

    setState(() => _isSaving = true);

    final clientsById = ref.read(clientsByIdProvider);
    final bookingsNotifier = ref.read(bookingsProvider.notifier);
    final location = ref.read(currentLocationProvider);
    final repository = ref.read(bookingsRepositoryProvider);

    // Deriva il nome del cliente dal provider se _clientId √® impostato
    final clientName = _clientId != null
        ? (clientsById[_clientId]?.name ?? _customClientName)
        : _customClientName;

    try {
      // Se ricorrenza attiva, usa endpoint ricorrente
      if (_recurrenceConfig != null) {
        await _createRecurringBooking(
          location: location,
          validItems: validItems,
          clientName: clientName,
        );
      } else {
        await _createSingleBooking(
          location: location,
          validItems: validItems,
          clientName: clientName,
          desiredStatus: _selectedBookingStatus,
          bookingsNotifier: bookingsNotifier,
          repository: repository,
        );
      }
    } catch (error) {
      if (mounted) {
        final message = error is ApiException ? error.message : l10n.errorTitle;
        await FeedbackDialog.showError(
          context,
          title: l10n.errorTitle,
          message: message,
        );
      }
      return;
    } finally {
      if (mounted) setState(() => _isSaving = false);
    }

    if (!mounted) return;
    Navigator.of(context).pop();
  }

  Future<void> _createSingleBooking({
    required dynamic location,
    required List<ServiceItemData> validItems,
    required String clientName,
    required String? desiredStatus,
    required dynamic bookingsNotifier,
    required dynamic repository,
  }) async {
    // Costruisci items per l'API (ogni servizio con il suo staff, start_time e override)
    final items = validItems.map((item) {
      final start = DateTime(
        _date.year,
        _date.month,
        _date.day,
        item.startTime.hour,
        item.startTime.minute,
      );
      return BookingItemRequest(
        serviceId: item.serviceId!,
        staffId: item.staffId!,
        startTime: start.toIso8601String(),
        // Include override values from ServiceItemData
        serviceVariantId: item.serviceVariantId,
        durationMinutes: item.durationMinutes,
        blockedExtraMinutes: item.blockedExtraMinutes > 0
            ? item.blockedExtraMinutes
            : null,
        processingExtraMinutes: item.processingExtraMinutes > 0
            ? item.processingExtraMinutes
            : null,
        // Prezzo personalizzato (se impostato)
        price: item.price,
      );
    }).toList();

    // UNA singola chiamata API per creare UN booking con tutti i servizi
    final bookingResponse = await repository.createBookingWithItems(
      locationId: location.id,
      idempotencyKey: const Uuid().v4(),
      items: items,
      clientId: _clientId,
      notes: _notesController.text.isNotEmpty ? _notesController.text : null,
    );

    // Aggiorna booking metadata locale
    bookingsNotifier.ensureBooking(
      bookingId: bookingResponse.id,
      businessId: bookingResponse.businessId,
      locationId: bookingResponse.locationId,
      clientId: bookingResponse.clientId,
      clientName: bookingResponse.clientName ?? clientName,
      notes: bookingResponse.notes,
      status: bookingResponse.status,
      replacesBookingId: bookingResponse.replacesBookingId,
      replacedByBookingId: bookingResponse.replacedByBookingId,
    );

    if (desiredStatus != null && desiredStatus != bookingResponse.status) {
      await repository.updateBooking(
        locationId: location.id,
        bookingId: bookingResponse.id,
        status: desiredStatus,
      );
      bookingsNotifier.setStatus(bookingResponse.id, desiredStatus);
      ref
          .read(appointmentsProvider.notifier)
          .setBookingStatusForBooking(
            bookingId: bookingResponse.id,
            status: desiredStatus,
          );
    }

    // Refresh appointments per caricare i nuovi
    ref.invalidate(appointmentsProvider);
    await ref.read(appointmentsProvider.future);

    // Trova il primo appointment creato per lo scroll
    final currentList = ref.read(appointmentsProvider).value ?? [];
    final scrollTarget = currentList
        .where((a) => a.bookingId == bookingResponse.id)
        .firstOrNull;

    if (scrollTarget != null) {
      ref.read(agendaScrollRequestProvider.notifier).request(scrollTarget);
    }
  }

  Future<void> _createRecurringBooking({
    required dynamic location,
    required List<ServiceItemData> validItems,
    required String clientName,
  }) async {
    final bookingsApi = ref.read(bookingsApiProvider);

    // Costruisci start_time dalla data + primo orario item
    final firstItem = validItems.first;
    final startTime = DateTime(
      _date.year,
      _date.month,
      _date.day,
      firstItem.startTime.hour,
      firstItem.startTime.minute,
    );

    // Costruisci service_ids e staff_by_service
    final serviceIds = validItems.map((i) => i.serviceId!).toList();

    // Se tutti i servizi hanno lo stesso staff, usa staff_id singolo
    // altrimenti usa staff_by_service
    final allSameStaff = validItems.every(
      (i) => i.staffId == validItems.first.staffId,
    );

    int? singleStaffId;
    Map<String, int>? staffByService;

    if (allSameStaff) {
      singleStaffId = validItems.first.staffId;
    } else {
      staffByService = <String, int>{};
      for (final item in validItems) {
        staffByService[item.serviceId.toString()] = item.staffId!;
      }
    }

    final request = RecurringBookingRequest(
      serviceIds: serviceIds,
      staffId: singleStaffId,
      staffByService: staffByService,
      startTime: startTime.toIso8601String(),
      clientId: _clientId,
      notes: _notesController.text.isNotEmpty ? _notesController.text : null,
      frequency: _recurrenceConfig!.frequency.value,
      intervalValue: _recurrenceConfig!.intervalValue,
      maxOccurrences: _recurrenceConfig!.maxOccurrences,
      endDate: _recurrenceConfig!.endDate?.toIso8601String().split('T')[0],
      conflictStrategy: _recurrenceConfig!.conflictStrategy.value,
    );

    // Prima mostra anteprima per permettere esclusione date
    final preview = await bookingsApi.previewRecurringBooking(
      locationId: location.id,
      request: request,
    );

    if (!mounted) return;

    // Mostra dialog anteprima con possibilit√† di escludere date
    final excludedIndices = await RecurrencePreviewDialog.show(
      context,
      preview,
    );

    // Se utente ha annullato, esci
    if (excludedIndices == null || !mounted) return;

    // Crea la serie con le date escluse
    setState(() => _isSaving = true);

    try {
      final createRequest = RecurringBookingRequest(
        serviceIds: serviceIds,
        staffId: singleStaffId,
        staffByService: staffByService,
        startTime: startTime.toIso8601String(),
        clientId: _clientId,
        notes: _notesController.text.isNotEmpty ? _notesController.text : null,
        frequency: _recurrenceConfig!.frequency.value,
        intervalValue: _recurrenceConfig!.intervalValue,
        maxOccurrences: _recurrenceConfig!.maxOccurrences,
        endDate: _recurrenceConfig!.endDate?.toIso8601String().split('T')[0],
        conflictStrategy: _recurrenceConfig!.conflictStrategy.value,
        excludedIndices: excludedIndices,
      );

      await bookingsApi.createRecurringBooking(
        locationId: location.id,
        request: createRequest,
      );

      // Refresh appointments (il pop viene fatto da _saveBooking)
      ref.invalidate(appointmentsProvider);
    } catch (e) {
      if (mounted) {
        setState(() => _isSaving = false);
      }
      rethrow;
    }
  }
}

// ============================================================================
// Helper Widgets
// ============================================================================

class _ClientItem {
  final int id;
  final String name;
  const _ClientItem(this.id, this.name);
}

/// Widget per la selezione del cliente con link cliccabile e hint
class _ClientSelectionField extends ConsumerWidget {
  const _ClientSelectionField({
    required this.clientId,
    required this.clientName,
    required this.clients,
    required this.onClientSelected,
    required this.onClientRemoved,
    required this.onOpenPicker,
  });

  final int? clientId;
  final String clientName;
  final List<Client> clients;
  final void Function(int? id, String name) onClientSelected;
  final VoidCallback onClientRemoved;
  final Future<void> Function()? onOpenPicker;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final hasClient = clientId != null || clientName.isNotEmpty;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          l10n.formClient,
          style: const TextStyle(fontWeight: FontWeight.w600),
        ),
        const SizedBox(height: 6),
        if (hasClient)
          _SelectedClientTile(
            clientName: clientName,
            onTap: () => onOpenPicker?.call(),
            onRemove: onClientRemoved,
          )
        else
          InkWell(
            onTap: () => onOpenPicker?.call(),
            borderRadius: BorderRadius.circular(8),
            child: Container(
              width: double.infinity,
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 14),
              decoration: BoxDecoration(
                border: Border.all(color: theme.colorScheme.outline),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.person_add_outlined,
                    size: 20,
                    color: theme.colorScheme.primary,
                  ),
                  const SizedBox(width: 8),
                  Text(
                    l10n.addClientToAppointment,
                    style: TextStyle(
                      color: theme.colorScheme.primary,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            ),
          ),
        const SizedBox(height: 6),
        Text(
          l10n.clientOptionalHint,
          style: theme.textTheme.bodySmall?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
      ],
    );
  }
}

/// Tile che mostra il cliente selezionato con opzione per rimuoverlo
class _SelectedClientTile extends StatelessWidget {
  const _SelectedClientTile({
    required this.clientName,
    required this.onTap,
    required this.onRemove,
  });

  final String clientName;
  final VoidCallback onTap;
  final VoidCallback onRemove;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
        decoration: BoxDecoration(
          border: Border.all(color: theme.colorScheme.outline),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Row(
          children: [
            StaffCircleAvatar(
              height: 32,
              color: theme.colorScheme.primary,
              isHighlighted: false,
              initials: clientName.isNotEmpty
                  ? initialsFromName(clientName, maxChars: 2)
                  : '?',
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
                clientName,
                style: const TextStyle(fontWeight: FontWeight.w500),
              ),
            ),
            IconButton(
              icon: Icon(Icons.close, size: 20, color: theme.colorScheme.error),
              onPressed: onRemove,
              tooltip: context.l10n.removeClient,
              padding: EdgeInsets.zero,
              constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
            ),
          ],
        ),
      ),
    );
  }
}

/// Bottom sheet per la selezione del cliente
class _ClientPickerSheet extends ConsumerStatefulWidget {
  const _ClientPickerSheet({required this.clients, this.selectedClientId});

  /// Initial clients list (not used anymore, kept for API compatibility)
  final List<Client> clients;
  final int? selectedClientId;

  @override
  ConsumerState<_ClientPickerSheet> createState() => _ClientPickerSheetState();
}

class _ClientPickerSheetState extends ConsumerState<_ClientPickerSheet> {
  final _searchController = TextEditingController();
  final _searchFocusNode = FocusNode();

  @override
  void initState() {
    super.initState();
    // Auto-focus sul campo di ricerca dopo il primo build
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        _searchFocusNode.requestFocus();
      }
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    _searchFocusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    // Watch the search state from provider
    final searchState = ref.watch(clientPickerSearchProvider);
    final clients = searchState.clients;
    final isLoading = searchState.isLoading;

    final maxHeight = MediaQuery.of(context).size.height * 0.8;
    return SafeArea(
      child: ConstrainedBox(
        constraints: BoxConstraints(maxHeight: maxHeight),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 16, 16, 12),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    l10n.selectClientTitle,
                    style: theme.textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  const SizedBox(height: AppSpacing.formFirstRowSpacing),
                  TextField(
                    controller: _searchController,
                    focusNode: _searchFocusNode,
                    decoration: InputDecoration(
                      hintText: l10n.searchClientPlaceholder,
                      prefixIcon: const Icon(Icons.search, size: 20),
                      suffixIcon: isLoading
                          ? const Padding(
                              padding: EdgeInsets.all(12),
                              child: SizedBox(
                                width: 16,
                                height: 16,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                ),
                              ),
                            )
                          : null,
                      border: const OutlineInputBorder(),
                      isDense: true,
                      contentPadding: const EdgeInsets.symmetric(
                        horizontal: 12,
                        vertical: 10,
                      ),
                    ),
                    onChanged: (value) {
                      ref
                          .read(clientPickerSearchProvider.notifier)
                          .setSearchQuery(value);
                    },
                  ),
                ],
              ),
            ),
            const AppDivider(),
            // Quick actions
            ListTile(
              leading: StaffCircleAvatar(
                height: 32,
                color: theme.colorScheme.primary,
                isHighlighted: false,
                initials: '',
                child: Icon(
                  Icons.person_add_outlined,
                  color: theme.colorScheme.onSurface,
                  size: 18,
                ),
              ),
              title: Text(l10n.createNewClient),
              onTap: () {
                Navigator.of(
                  context,
                ).pop(_ClientItem(-2, _searchController.text.trim()));
              },
            ),
            ListTile(
              leading: StaffCircleAvatar(
                height: 32,
                color: theme.colorScheme.onSurfaceVariant,
                isHighlighted: false,
                initials: '',
                child: Icon(
                  Icons.person_off_outlined,
                  color: theme.colorScheme.onSurface,
                  size: 18,
                ),
              ),
              title: Text(l10n.noClientForAppointment),
              onTap: () {
                Navigator.of(context).pop(const _ClientItem(-1, ''));
              },
            ),
            const AppDivider(),
            // Client list
            Flexible(
              child: isLoading && clients.isEmpty
                  ? const Center(child: CircularProgressIndicator())
                  : clients.isEmpty
                  ? Center(
                      child: Text(
                        l10n.clientsEmpty,
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                      ),
                    )
                  : ListView.builder(
                      padding: const EdgeInsets.only(bottom: 8),
                      itemCount: clients.length,
                      itemBuilder: (context, index) {
                        final client = clients[index];
                        final isSelected = client.id == widget.selectedClientId;
                        return ListTile(
                          leading: StaffCircleAvatar(
                            height: 32,
                            color: isSelected
                                ? theme.colorScheme.primary
                                : theme.colorScheme.primary,
                            isHighlighted: isSelected,
                            initials: client.name.isNotEmpty
                                ? initialsFromName(client.name, maxChars: 2)
                                : '?',
                          ),
                          title: Text(client.name),
                          subtitle: client.phone != null
                              ? Text(
                                  client.phone!,
                                  style: theme.textTheme.bodySmall,
                                )
                              : null,
                          trailing: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              IconButton(
                                icon: Icon(
                                  Icons.edit_outlined,
                                  size: 20,
                                  color: theme.colorScheme.onSurfaceVariant,
                                ),
                                onPressed: () async {
                                  await showClientEditDialog(
                                    context,
                                    ref,
                                    client: client,
                                  );
                                  // Refresh search results after edit
                                  ref
                                      .read(clientPickerSearchProvider.notifier)
                                      .refresh();
                                },
                                tooltip: l10n.clientsEdit,
                              ),
                              if (isSelected)
                                Icon(
                                  Icons.check_circle,
                                  color: theme.colorScheme.primary,
                                ),
                            ],
                          ),
                          onTap: () {
                            Navigator.of(
                              context,
                            ).pop(_ClientItem(client.id, client.name));
                          },
                        );
                      },
                    ),
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/widgets/recurrence_picker.dart ---
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/recurrence_rule.dart';

/// Widget per selezionare la configurazione di ricorrenza
class RecurrencePicker extends StatefulWidget {
  const RecurrencePicker({
    super.key,
    required this.startDate,
    this.initialConfig,
    this.title,
    this.showConflictHandling = true,
    this.conflictSkipDescription,
    this.conflictForceDescription,
    required this.onChanged,
  });

  final DateTime startDate;
  final RecurrenceConfig? initialConfig;
  final String? title;
  final bool showConflictHandling;
  final String? conflictSkipDescription;
  final String? conflictForceDescription;
  final ValueChanged<RecurrenceConfig?> onChanged;

  @override
  State<RecurrencePicker> createState() => _RecurrencePickerState();
}

class _RecurrencePickerState extends State<RecurrencePicker> {
  bool _isEnabled = false;
  RecurrenceFrequency _frequency = RecurrenceFrequency.weekly;
  int _intervalValue = 1;
  _EndType _endType = _EndType.count;
  int _occurrenceCount = 6;
  DateTime? _endDate;
  ConflictStrategy _conflictStrategy = ConflictStrategy.skip;

  /// Restituisce le opzioni di occorrenze in base alla frequenza e intervallo
  List<int> _getOccurrenceOptions() {
    // Calcola il massimo di occorrenze per stare entro 1 anno
    final int maxOccurrences;
    switch (_frequency) {
      case RecurrenceFrequency.daily:
        // Giornaliero: 365 / intervallo
        maxOccurrences = (365 / _intervalValue).floor();
      case RecurrenceFrequency.weekly:
        // Settimanale: 52 / intervallo
        maxOccurrences = (52 / _intervalValue).floor();
      case RecurrenceFrequency.monthly:
        // Mensile: 12 / intervallo
        maxOccurrences = (12 / _intervalValue).floor();
      case RecurrenceFrequency.custom:
        maxOccurrences = (365 / _intervalValue).floor();
    }
    // Almeno 1 occorrenza
    final max = maxOccurrences < 1 ? 1 : maxOccurrences;
    return List.generate(max, (i) => i + 1);
  }

  /// Restituisce il valore di default per le occorrenze in base alla frequenza
  int _getDefaultOccurrenceCount() {
    switch (_frequency) {
      case RecurrenceFrequency.daily:
        return 30;
      case RecurrenceFrequency.weekly:
        return 12;
      case RecurrenceFrequency.monthly:
        return 6;
      case RecurrenceFrequency.custom:
        return 30;
    }
  }

  @override
  void initState() {
    super.initState();
    if (widget.initialConfig != null) {
      _isEnabled = true;
      _frequency = widget.initialConfig!.frequency;
      _intervalValue = widget.initialConfig!.intervalValue;
      if (widget.initialConfig!.maxOccurrences != null) {
        _endType = _EndType.count;
        _occurrenceCount = widget.initialConfig!.maxOccurrences!;
      } else if (widget.initialConfig!.endDate != null) {
        _endType = _EndType.date;
        _endDate = widget.initialConfig!.endDate;
      } else {
        _endType = _EndType.never;
      }
      _conflictStrategy = widget.initialConfig!.conflictStrategy;
    }
  }

  void _notifyChange() {
    if (!_isEnabled) {
      widget.onChanged(null);
      return;
    }
    final safeOccurrenceCount = _safeOccurrenceCount();

    widget.onChanged(
      RecurrenceConfig(
        frequency: _frequency,
        intervalValue: _intervalValue,
        maxOccurrences: _endType == _EndType.count ? safeOccurrenceCount : null,
        endDate: _endType == _EndType.date ? _endDate : null,
        conflictStrategy: _conflictStrategy,
      ),
    );
  }

  int _safeOccurrenceCount() {
    final options = _getOccurrenceOptions();
    if (options.isEmpty) return 1;
    if (options.contains(_occurrenceCount)) return _occurrenceCount;
    return options.last;
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Header con checkbox
        InkWell(
          onTap: () {
            setState(() {
              _isEnabled = !_isEnabled;
            });
            _notifyChange();
          },
          borderRadius: BorderRadius.circular(8),
          child: Padding(
            padding: const EdgeInsets.symmetric(vertical: 8),
            child: Row(
              children: [
                Checkbox(
                  value: _isEnabled,
                  onChanged: (value) {
                    setState(() {
                      _isEnabled = value ?? false;
                    });
                    _notifyChange();
                  },
                ),
                const SizedBox(width: 8),
                Icon(
                  Icons.repeat,
                  size: 20,
                  color: _isEnabled
                      ? theme.colorScheme.primary
                      : theme.colorScheme.onSurfaceVariant,
                ),
                const SizedBox(width: 8),
                Text(
                  widget.title ?? l10n.recurrenceRepeatBooking,
                  style: theme.textTheme.titleSmall?.copyWith(
                    color: _isEnabled
                        ? theme.colorScheme.onSurface
                        : theme.colorScheme.onSurfaceVariant,
                  ),
                ),
              ],
            ),
          ),
        ),

        // Contenuto espandibile
        if (_isEnabled) ...[
          const SizedBox(height: 8),
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: theme.colorScheme.surfaceContainerHighest.withOpacity(0.3),
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: theme.colorScheme.outlineVariant),
            ),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Frequenza
                _buildFrequencySelector(context),
                const SizedBox(height: 16),

                // Termine
                _buildEndSelector(context),

                if (widget.showConflictHandling) ...[
                  const SizedBox(height: 16),

                  // Gestione conflitti
                  _buildConflictSelector(context),
                ],
              ],
            ),
          ),
        ],
      ],
    );
  }

  Widget _buildFrequencySelector(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          l10n.recurrenceFrequency,
          style: theme.textTheme.labelMedium?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
        const SizedBox(height: 8),
        Row(
          children: [
            Text(l10n.recurrenceEvery, style: theme.textTheme.bodyMedium),
            const SizedBox(width: 8),
            SizedBox(
              width: 70,
              child: DropdownButtonFormField<int>(
                value: _intervalValue,
                isExpanded: true,
                decoration: const InputDecoration(
                  isDense: true,
                  contentPadding: EdgeInsets.symmetric(
                    horizontal: 8,
                    vertical: 8,
                  ),
                  border: OutlineInputBorder(),
                ),
                items: List.generate(12, (i) => i + 1)
                    .map((v) => DropdownMenuItem(value: v, child: Text('$v')))
                    .toList(),
                onChanged: (value) {
                  if (value != null) {
                    setState(() {
                      _intervalValue = value;
                      // Reset occurrence count se supera il nuovo massimo
                      final options = _getOccurrenceOptions();
                      if (!options.contains(_occurrenceCount)) {
                        _occurrenceCount = options.last;
                      }
                    });
                    _notifyChange();
                  }
                },
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: DropdownButtonFormField<RecurrenceFrequency>(
                value: _frequency,
                isExpanded: true,
                decoration: const InputDecoration(
                  isDense: true,
                  contentPadding: EdgeInsets.symmetric(
                    horizontal: 8,
                    vertical: 8,
                  ),
                  border: OutlineInputBorder(),
                ),
                items: [
                  DropdownMenuItem(
                    value: RecurrenceFrequency.daily,
                    child: Text(
                      _intervalValue == 1
                          ? l10n.recurrenceDay
                          : l10n.recurrenceDays,
                    ),
                  ),
                  DropdownMenuItem(
                    value: RecurrenceFrequency.weekly,
                    child: Text(
                      _intervalValue == 1
                          ? l10n.recurrenceWeek
                          : l10n.recurrenceWeeks,
                    ),
                  ),
                  DropdownMenuItem(
                    value: RecurrenceFrequency.monthly,
                    child: Text(
                      _intervalValue == 1
                          ? l10n.recurrenceMonth
                          : l10n.recurrenceMonths,
                    ),
                  ),
                ],
                onChanged: (value) {
                  if (value != null) {
                    setState(() {
                      _frequency = value;
                      // Reset occurrence count se non √® tra le opzioni valide
                      final options = _getOccurrenceOptions();
                      if (!options.contains(_occurrenceCount)) {
                        final defaultCount = _getDefaultOccurrenceCount();
                        _occurrenceCount = options.contains(defaultCount)
                            ? defaultCount
                            : options.last;
                      }
                    });
                    _notifyChange();
                  }
                },
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildEndSelector(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final occurrenceOptions = _getOccurrenceOptions();
    final selectedOccurrenceCount = _safeOccurrenceCount();

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          l10n.recurrenceEnds,
          style: theme.textTheme.labelMedium?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
        const SizedBox(height: 8),

        // Opzione: Mai
        RadioListTile<_EndType>(
          value: _EndType.never,
          groupValue: _endType,
          onChanged: (value) {
            setState(() => _endType = value!);
            _notifyChange();
          },
          title: Text(l10n.recurrenceNever),
          dense: true,
          contentPadding: EdgeInsets.zero,
          visualDensity: VisualDensity.compact,
        ),

        // Opzione: Dopo N occorrenze
        RadioListTile<_EndType>(
          value: _EndType.count,
          groupValue: _endType,
          onChanged: (value) {
            setState(() => _endType = value!);
            _notifyChange();
          },
          title: Row(
            children: [
              Text(l10n.recurrenceAfter),
              const SizedBox(width: 8),
              SizedBox(
                width: 70,
                child: DropdownButtonFormField<int>(
                  value: selectedOccurrenceCount,
                  isExpanded: true,
                  decoration: const InputDecoration(
                    isDense: true,
                    contentPadding: EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    border: OutlineInputBorder(),
                  ),
                  items: occurrenceOptions
                      .map((v) => DropdownMenuItem(value: v, child: Text('$v')))
                      .toList(),
                  onChanged: _endType == _EndType.count
                      ? (value) {
                          if (value != null) {
                            setState(() => _occurrenceCount = value);
                            _notifyChange();
                          }
                        }
                      : null,
                ),
              ),
              const SizedBox(width: 8),
              Flexible(child: Text(l10n.recurrenceOccurrences)),
            ],
          ),
          dense: true,
          contentPadding: EdgeInsets.zero,
          visualDensity: VisualDensity.compact,
        ),

        // Opzione: Data fine
        RadioListTile<_EndType>(
          value: _EndType.date,
          groupValue: _endType,
          onChanged: (value) {
            setState(() => _endType = value!);
            _notifyChange();
          },
          title: Row(
            children: [
              Text(l10n.recurrenceOnDate),
              const SizedBox(width: 8),
              Expanded(
                child: OutlinedButton(
                  onPressed: _endType == _EndType.date
                      ? () => _pickEndDate(context)
                      : null,
                  style: OutlinedButton.styleFrom(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 8,
                    ),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text(
                        _endDate != null
                            ? DateFormat('dd/MM/yyyy').format(_endDate!)
                            : l10n.recurrenceSelectDate,
                        style: theme.textTheme.bodyMedium,
                      ),
                      const SizedBox(width: 4),
                      const Icon(Icons.calendar_today, size: 16),
                    ],
                  ),
                ),
              ),
            ],
          ),
          dense: true,
          contentPadding: EdgeInsets.zero,
          visualDensity: VisualDensity.compact,
        ),
      ],
    );
  }

  Future<void> _pickEndDate(BuildContext context) async {
    final maxDate = widget.startDate.add(const Duration(days: 365));
    final picked = await showDatePicker(
      context: context,
      initialDate: _endDate ?? widget.startDate.add(const Duration(days: 90)),
      firstDate: widget.startDate,
      lastDate: maxDate,
    );
    if (picked != null) {
      setState(() => _endDate = picked);
      _notifyChange();
    }
  }

  Widget _buildConflictSelector(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          l10n.recurrenceConflictHandling,
          style: theme.textTheme.labelMedium?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
        const SizedBox(height: 8),
        RadioListTile<ConflictStrategy>(
          value: ConflictStrategy.skip,
          groupValue: _conflictStrategy,
          onChanged: (value) {
            setState(() => _conflictStrategy = value!);
            _notifyChange();
          },
          title: Text(l10n.recurrenceConflictSkip),
          subtitle: Text(
            widget.conflictSkipDescription ?? l10n.recurrenceConflictSkipDescription,
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
          dense: true,
          contentPadding: EdgeInsets.zero,
          visualDensity: VisualDensity.compact,
        ),
        RadioListTile<ConflictStrategy>(
          value: ConflictStrategy.force,
          groupValue: _conflictStrategy,
          onChanged: (value) {
            setState(() => _conflictStrategy = value!);
            _notifyChange();
          },
          title: Text(l10n.recurrenceConflictForce),
          subtitle: Text(
            widget.conflictForceDescription ?? l10n.recurrenceConflictForceDescription,
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
          dense: true,
          contentPadding: EdgeInsets.zero,
          visualDensity: VisualDensity.compact,
        ),
      ],
    );
  }
}

enum _EndType { never, count, date }
--- FILE: lib/features/agenda/agenda_feature.dart ---
/// Entry point modulare per la feature "Agenda"
/// Importa qui tutti i componenti pubblici dell'agenda.
/// Cos√¨ altrove potrai scrivere semplicemente:
///   import 'package:agenda/features/agenda/agenda_feature.dart';

library;

export 'domain/config/agenda_theme.dart'; // se aggiungi un tema centralizzato
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ÔøΩ Domain & Config
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
export 'domain/config/layout_config.dart';
// Schermata di agenda (entry screen)
export 'presentation/agenda_screen.dart';
export 'presentation/screens/day_view/components/hour_column.dart';
export 'presentation/screens/day_view/components/staff_header_row.dart';
// Vista principale (giornaliera multi-staff)
export 'presentation/screens/day_view/multi_staff_day_view.dart';
export 'presentation/screens/day_view/staff_column.dart';
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üé® Presentation layer
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Layout e componenti core
export 'presentation/screens/helper/responsive_layout.dart';
export 'presentation/screens/widgets/agenda_dividers.dart';
export 'presentation/screens/widgets/unavailable_slot_pattern.dart';
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ÔøΩ Application (providers, notifiers, stato)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
export 'providers/agenda_scroll_provider.dart';
export 'providers/pending_drop_provider.dart';
--- FILE: lib/features/staff/providers/staff_providers.dart ---
import 'package:agenda_backend/features/agenda/providers/business_providers.dart';
import 'package:agenda_backend/features/agenda/providers/location_providers.dart';
import 'package:agenda_backend/features/auth/providers/auth_provider.dart';
import 'package:agenda_backend/features/auth/providers/current_business_user_provider.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/staff.dart';
import 'staff_repository_provider.dart';

class StaffNotifier extends AsyncNotifier<List<Staff>> {
  @override
  Future<List<Staff>> build() async {
    // Verifica autenticazione
    final authState = ref.watch(authProvider);
    if (!authState.isAuthenticated) {
      return [];
    }

    final business = ref.watch(currentBusinessProvider);
    if (business.id <= 0) {
      return [];
    }

    final repository = ref.watch(staffRepositoryProvider);
    final allowedLocationIds = ref.watch(allowedLocationIdsProvider);

    try {
      final staff = await repository.getByBusiness(business.id);
      if (allowedLocationIds == null) {
        return staff;
      }

      return staff
          .where(
            (member) => member.locationIds.any(allowedLocationIds.contains),
          )
          .toList();
    } catch (e) {
      return [];
    }
  }

  /// Ricarica gli staff dall'API
  Future<void> refresh() async {
    final authState = ref.read(authProvider);
    if (!authState.isAuthenticated) {
      state = const AsyncData([]);
      return;
    }

    final business = ref.read(currentBusinessProvider);
    if (business.id <= 0) {
      state = const AsyncData([]);
      return;
    }

    state = const AsyncLoading();
    final allowedLocationIds = ref.read(allowedLocationIdsProvider);

    try {
      final repository = ref.read(staffRepositoryProvider);
      final staff = await repository.getByBusiness(business.id);
      if (allowedLocationIds == null) {
        state = AsyncData(staff);
        return;
      }

      state = AsyncData(
        staff
            .where(
              (member) => member.locationIds.any(allowedLocationIds.contains),
            )
            .toList(),
      );
    } catch (e, st) {
      state = AsyncError(e, st);
    }
  }

  /// Crea un nuovo staff tramite API
  Future<Staff> createStaff({
    required String name,
    String? surname,
    String? colorHex,
    String? avatarUrl,
    bool? isBookableOnline,
    List<int>? locationIds,
    List<int>? serviceIds,
  }) async {
    final repository = ref.read(staffRepositoryProvider);
    final business = ref.read(currentBusinessProvider);

    final staff = await repository.create(
      businessId: business.id,
      name: name,
      surname: surname,
      colorHex: colorHex,
      avatarUrl: avatarUrl,
      isBookableOnline: isBookableOnline,
      locationIds: locationIds,
      serviceIds: serviceIds,
    );

    final current = state.value ?? [];
    state = AsyncData([...current, staff]);
    return staff;
  }

  /// Aggiorna uno staff esistente tramite API
  Future<Staff> updateStaffApi({
    required int staffId,
    String? name,
    String? surname,
    String? colorHex,
    String? avatarUrl,
    bool? isBookableOnline,
    int? sortOrder,
    List<int>? locationIds,
    List<int>? serviceIds,
  }) async {
    final repository = ref.read(staffRepositoryProvider);

    final updated = await repository.update(
      staffId: staffId,
      name: name,
      surname: surname,
      colorHex: colorHex,
      avatarUrl: avatarUrl,
      isBookableOnline: isBookableOnline,
      sortOrder: sortOrder,
      locationIds: locationIds,
      serviceIds: serviceIds,
    );

    final current = state.value ?? [];
    state = AsyncData([
      for (final s in current)
        if (s.id == updated.id) updated else s,
    ]);
    return updated;
  }

  /// Elimina uno staff tramite API
  Future<void> deleteStaffApi(int id) async {
    final repository = ref.read(staffRepositoryProvider);
    await repository.delete(id);

    final current = state.value ?? [];
    state = AsyncData(current.where((s) => s.id != id).toList());
  }

  // === Metodi locali per UI (backward compatibility) ===

  void add(Staff staff) {
    final current = state.value ?? [];
    state = AsyncData([...current, staff]);
  }

  void updateStaff(Staff updated) {
    final current = state.value ?? [];
    state = AsyncData([
      for (final s in current)
        if (s.id == updated.id) updated else s,
    ]);
  }

  void delete(int id) {
    final current = state.value ?? [];
    state = AsyncData(current.where((s) => s.id != id).toList());
  }

  void duplicate(Staff original) {
    final current = state.value ?? [];
    final newId = _nextId(current);
    final existingNames = current.map((s) => s.displayName).toSet();
    var base = original.displayName;
    var candidate = '$base Copia';
    var i = 1;
    while (existingNames.contains(candidate)) {
      candidate = '$base Copia $i';
      i++;
    }
    final parts = candidate.split(' ');
    final name = parts.first;
    final surname = parts.length > 1
        ? parts.sublist(1).join(' ')
        : original.surname;
    add(original.copyWith(id: newId, name: name, surname: surname));
  }

  int nextId() => _nextId(state.value ?? []);

  int nextSortOrderForLocations(Iterable<int> locationIds) {
    final current = state.value ?? [];
    if (current.isEmpty) return 0;
    final ids = locationIds.toSet();
    final relevant = ids.isEmpty
        ? current
        : current.where((s) => s.locationIds.any(ids.contains));
    if (relevant.isEmpty) return 0;
    return relevant.map((s) => s.sortOrder).reduce((a, b) => a > b ? a : b) + 1;
  }

  Future<void> reorderForLocation(
    int locationId,
    int oldIndex,
    int newIndex,
  ) async {
    final current = state.value ?? [];
    final inLocation =
        current.where((s) => s.worksAtLocation(locationId)).toList()
          ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));

    if (newIndex > oldIndex) newIndex -= 1;
    final item = inLocation.removeAt(oldIndex);
    inLocation.insert(newIndex, item);

    final updated = <Staff>[];
    for (int i = 0; i < inLocation.length; i++) {
      updated.add(inLocation[i].copyWith(sortOrder: i));
    }

    final updatedAll = [
      for (final s in current)
        if (s.worksAtLocation(locationId))
          updated.firstWhere((u) => u.id == s.id)
        else
          s,
    ];

    state = AsyncData(updatedAll);

    // Persist to API
    await _persistStaffOrder(updated);
  }

  /// Persiste l'ordine dello staff via API
  Future<void> _persistStaffOrder(List<Staff> staffList) async {
    try {
      final repository = ref.read(staffRepositoryProvider);
      await repository.reorderStaff(
        staffList.map((s) => {'id': s.id, 'sort_order': s.sortOrder}).toList(),
      );
    } catch (_) {
      // Ignora errore - utente pu√≤ riprovare
    }
  }

  int _nextId(List<Staff> current) {
    if (current.isEmpty) return 1;
    final maxId = current.map((s) => s.id).reduce((a, b) => a > b ? a : b);
    return maxId + 1;
  }
}

final allStaffProvider = AsyncNotifierProvider<StaffNotifier, List<Staff>>(
  StaffNotifier.new,
);

List<Staff> _sortStaff(List<Staff> staff) {
  final list = [...staff];
  list.sort((a, b) {
    final so = a.sortOrder.compareTo(b.sortOrder);
    return so != 0 ? so : a.displayName.compareTo(b.displayName);
  });
  return list;
}

final sortedAllStaffProvider = Provider<List<Staff>>((ref) {
  final staffAsync = ref.watch(allStaffProvider);
  return _sortStaff(staffAsync.value ?? []);
});

final staffForCurrentLocationProvider = Provider<List<Staff>>((ref) {
  final location = ref.watch(currentLocationProvider);
  final staffAsync = ref.watch(allStaffProvider);
  final staff = staffAsync.value ?? [];
  return _sortStaff([
    for (final member in staff)
      if (member.worksAtLocation(location.id)) member,
  ]);
});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üè¢ Location provider separato per la sezione Staff
// null = "Tutte le sedi" (default)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class StaffSectionLocationNotifier extends Notifier<int?> {
  @override
  int? build() => null; // Default: tutte le sedi

  void set(int? locationId) => state = locationId;

  void setAll() => state = null;
}

final staffSectionLocationIdProvider =
    NotifierProvider<StaffSectionLocationNotifier, int?>(
      StaffSectionLocationNotifier.new,
    );

/// Staff filtrato per la location selezionata nella sezione Staff.
/// Se locationId √® null (tutte le sedi), restituisce tutti gli staff.
final staffForStaffSectionProvider = Provider<List<Staff>>((ref) {
  final locationId = ref.watch(staffSectionLocationIdProvider);
  final allowedLocationIds = ref.watch(allowedLocationIdsProvider);
  final currentUserRole = ref.watch(currentUserRoleProvider);
  final currentUserStaffId = ref.watch(currentUserStaffIdProvider);
  final staffAsync = ref.watch(allStaffProvider);
  final allStaff = staffAsync.value ?? [];
  final scopedStaff = allowedLocationIds == null
      ? allStaff
      : allStaff
            .where(
              (member) => member.locationIds.any(allowedLocationIds.contains),
            )
            .toList();
  final staff =
      currentUserRole == 'staff' &&
          currentUserStaffId != null &&
          currentUserStaffId > 0
      ? scopedStaff.where((s) => s.id == currentUserStaffId).toList()
      : scopedStaff;

  if (locationId == null) {
    // Tutte le sedi consentite
    return _sortStaff(staff);
  }

  // Se l'utente non ha accesso a questa location, lista vuota.
  if (allowedLocationIds != null && !allowedLocationIds.contains(locationId)) {
    return const [];
  }

  return _sortStaff([
    for (final member in staff)
      if (member.worksAtLocation(locationId)) member,
  ]);
});

/// Holds the staffId that should be pre-selected when navigating to
/// the single-staff availability edit screen. Cleared after consumption.
final initialStaffToEditProvider = Provider<ValueNotifier<int?>>((ref) {
  final vn = ValueNotifier<int?>(null);
  ref.onDispose(vn.dispose);
  return vn;
});
--- FILE: lib/features/staff/providers/staff_sorted_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/location.dart';
import '../../../core/models/staff.dart';
import '../../agenda/providers/location_providers.dart';
import 'staff_providers.dart';

final sortedLocationsProvider = Provider<List<Location>>((ref) {
  // usa l'ordine della lista nello stato
  return [...ref.watch(locationsProvider)];
});

final staffByLocationProvider = Provider.family<List<Staff>, int>((
  ref,
  locationId,
) {
  final staff = ref.watch(allStaffProvider).value ?? [];
  final list = [
    for (final s in staff)
      if (s.worksAtLocation(locationId)) s,
  ];
  list.sort((a, b) {
    final so = a.sortOrder.compareTo(b.sortOrder);
    return so != 0 ? so : a.displayName.compareTo(b.displayName);
  });
  return list;
});
--- FILE: lib/features/staff/providers/staff_repository_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'staff_repository_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(staffRepository)
const staffRepositoryProvider = StaffRepositoryProvider._();

final class StaffRepositoryProvider
    extends
        $FunctionalProvider<StaffRepository, StaffRepository, StaffRepository>
    with $Provider<StaffRepository> {
  const StaffRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'staffRepositoryProvider',
        isAutoDispose: false,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$staffRepositoryHash();

  @$internal
  @override
  $ProviderElement<StaffRepository> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  StaffRepository create(Ref ref) {
    return staffRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(StaffRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<StaffRepository>(value),
    );
  }
}

String _$staffRepositoryHash() => r'f2d32cabb396f95a9f8be7d15391f2dec04629c1';
--- FILE: lib/features/staff/providers/staff_planning_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/staff_planning.dart';
import '../../../core/network/network_providers.dart';
import '../../../core/services/staff_planning_selector.dart';
import '../../../core/validation/staff_planning_validator.dart';
import '../../agenda/providers/date_range_provider.dart';

/// Risultato di una operazione di add/update planning con planning incluso.
class StaffPlanningResult {
  final bool isValid;
  final List<String> errors;
  final StaffPlanning? planning;

  const StaffPlanningResult({
    required this.isValid,
    this.errors = const [],
    this.planning,
  });

  factory StaffPlanningResult.success(StaffPlanning planning) =>
      StaffPlanningResult(isValid: true, planning: planning);

  factory StaffPlanningResult.failure(List<String> errors) =>
      StaffPlanningResult(isValid: false, errors: errors);
}

/// Provider per il selettore di planning.
final staffPlanningSelectorProvider = Provider<StaffPlanningSelector>((ref) {
  return StaffPlanningSelector();
});

/// Provider per il validatore di planning.
final staffPlanningValidatorProvider = Provider<StaffPlanningValidator>((ref) {
  return StaffPlanningValidator();
});

/// State per i planning degli staff.
/// Mappa: staffId ‚Üí `List<StaffPlanning>`
typedef StaffPlanningsState = Map<int, List<StaffPlanning>>;

/// Provider per la gestione dei planning degli staff.
///
/// Gestisce:
/// - Caricamento planning da API
/// - Selezione planning per data (biweekly A/B incluso)
/// - Validazione create/update
/// - Cache locale dei planning
class StaffPlanningsNotifier extends Notifier<StaffPlanningsState> {
  @override
  StaffPlanningsState build() {
    return {};
  }

  StaffPlanningValidator get _validator =>
      ref.read(staffPlanningValidatorProvider);

  /// Lista flat di tutti i planning (per validazione).
  List<StaffPlanning> get _allPlannings {
    return state.values.expand((list) => list).toList();
  }

  /// Carica i planning per uno staff specifico dall'API.
  Future<void> loadPlanningsForStaff(int staffId) async {
    try {
      final api = ref.read(apiClientProvider);
      final planningsJson = await api.getStaffPlannings(staffId);

      final plannings = planningsJson
          .map((json) => StaffPlanning.fromJson(json))
          .toList();

      state = {...state, staffId: plannings};
    } catch (e, st) {
      // ignore: avoid_print
      print('DEBUG loadPlanningsForStaff ERROR: $e');
      // ignore: avoid_print
      print('DEBUG stackTrace: $st');
    }
  }

  /// Aggiunge un planning con validazione.
  ///
  /// Ritorna [StaffPlanningResult] con esito e planning creato (con ID dal server).
  Future<StaffPlanningResult> addPlanning(StaffPlanning planning) async {
    final validation = _validator.validateForCreate(planning, _allPlannings);

    if (!validation.isValid) {
      return StaffPlanningResult.failure(validation.errors);
    }

    try {
      final api = ref.read(apiClientProvider);
      // DEBUG: stampa payload
      final payload = {
        'staffId': planning.staffId,
        'type': planning.type.name,
        'validFrom': _dateToIso(planning.validFrom),
        'validTo': planning.validTo != null
            ? _dateToIso(planning.validTo!)
            : null,
        'templates': planning.templates.map((t) => t.toJson()).toList(),
      };
      // ignore: avoid_print
      print('DEBUG createStaffPlanning payload: $payload');

      final response = await api.createStaffPlanning(
        staffId: planning.staffId,
        type: planning.type.name,
        validFrom: _dateToIso(planning.validFrom),
        validTo: planning.validTo != null
            ? _dateToIso(planning.validTo!)
            : null,
        templates: planning.templates.map((t) => t.toJson()).toList(),
      );

      // ignore: avoid_print
      print('DEBUG createStaffPlanning response: $response');

      // Usa il planning ritornato dal server (con ID generato)
      final createdPlanning = StaffPlanning.fromJson(response);
      final staffPlannings = List<StaffPlanning>.from(
        state[planning.staffId] ?? [],
      );
      staffPlannings.add(createdPlanning);

      state = {...state, planning.staffId: staffPlannings};

      return StaffPlanningResult.success(createdPlanning);
    } catch (e, stackTrace) {
      // ignore: avoid_print
      print('DEBUG createStaffPlanning ERROR: $e');
      // ignore: avoid_print
      print('DEBUG stackTrace: $stackTrace');
      return StaffPlanningResult.failure(['api_error: ${e.toString()}']);
    }
  }

  /// Aggiorna un planning esistente con validazione.
  Future<StaffPlanningValidationResult> updatePlanning(
    StaffPlanning planning,
    StaffPlanning original,
  ) async {
    final result = _validator.validateForUpdate(
      planning,
      _allPlannings,
      original,
    );

    if (!result.isValid) {
      return result;
    }

    try {
      final api = ref.read(apiClientProvider);
      final response = await api.updateStaffPlanning(
        staffId: planning.staffId,
        planningId: planning.id,
        type: planning.type.name,
        validFrom: _dateToIso(planning.validFrom),
        validTo: planning.validTo != null
            ? _dateToIso(planning.validTo!)
            : null,
        setValidToNull: planning.validTo == null,
        templates: planning.templates.map((t) => t.toJson()).toList(),
      );

      final updatedPlanning = StaffPlanning.fromJson(response);
      final staffPlannings = List<StaffPlanning>.from(
        state[planning.staffId] ?? [],
      );

      final index = staffPlannings.indexWhere((p) => p.id == planning.id);
      if (index != -1) {
        staffPlannings[index] = updatedPlanning;
      }

      state = {...state, planning.staffId: staffPlannings};
    } catch (e) {
      return StaffPlanningValidationResult(
        isValid: false,
        errors: ['api_error: ${e.toString()}'],
      );
    }

    return result;
  }

  /// Elimina un planning.
  Future<void> deletePlanning(int staffId, int planningId) async {
    try {
      final api = ref.read(apiClientProvider);
      await api.deleteStaffPlanning(staffId, planningId);

      final staffPlannings = List<StaffPlanning>.from(state[staffId] ?? []);
      staffPlannings.removeWhere((p) => p.id == planningId);

      state = {...state, staffId: staffPlannings};
    } catch (e) {
      // In caso di errore, non modifica lo stato
      rethrow;
    }
  }

  /// Imposta i planning per uno staff (es. dopo caricamento da API).
  void setPlanningsForStaff(int staffId, List<StaffPlanning> plannings) {
    state = {...state, staffId: plannings};
  }

  /// Formatta DateTime in stringa ISO date.
  String _dateToIso(DateTime date) {
    return '${date.year.toString().padLeft(4, '0')}-'
        '${date.month.toString().padLeft(2, '0')}-'
        '${date.day.toString().padLeft(2, '0')}';
  }
}

/// Provider principale per i planning.
final staffPlanningsProvider =
    NotifierProvider<StaffPlanningsNotifier, StaffPlanningsState>(
      StaffPlanningsNotifier.new,
    );

/// Provider per ottenere il planning valido per uno staff in una data.
///
/// Ritorna [PlanningLookupResult]:
/// - [NoPlanningFound] se nessun planning valido
/// - [PlanningFound] con planning e week label (A/B)
/// - [MultiplePlanningsFound] se errore dati
final planningForStaffOnDateProvider =
    Provider.family<PlanningLookupResult, ({int staffId, DateTime date})>((
      ref,
      params,
    ) {
      final plannings = ref.watch(staffPlanningsProvider);
      final selector = ref.watch(staffPlanningSelectorProvider);

      return selector.findPlanningForDate(
        staffId: params.staffId,
        date: params.date,
        allPlannings: plannings.values.expand((list) => list).toList(),
      );
    });

/// Provider per gli slot disponibili di uno staff in una data.
///
/// Ritorna [Set<int>] degli slot index disponibili.
/// Set vuoto se nessun planning o giorno non lavorativo.
/// null se errore di consistenza (planning multipli).
final planningSlotsForDateProvider =
    Provider.family<Set<int>?, ({int staffId, DateTime date})>((ref, params) {
      final result = ref.watch(planningForStaffOnDateProvider(params));

      return switch (result) {
        NoPlanningFound() => {},
        PlanningFound(template: final t) => t.getSlotsForDay(
          params.date.weekday,
        ),
        MultiplePlanningsFound() => null,
      };
    });

/// Provider per verificare se uno staff √® disponibile in una data.
final isStaffAvailableOnDateProvider =
    Provider.family<bool, ({int staffId, DateTime date})>((ref, params) {
      final slots = ref.watch(planningSlotsForDateProvider(params));
      return slots != null && slots.isNotEmpty;
    });

/// Provider per la week label (A/B) di una data per uno staff con biweekly.
///
/// Ritorna null se:
/// - Nessun planning valido
/// - Planning √® weekly (non biweekly)
final weekLabelForDateProvider =
    Provider.family<WeekLabel?, ({int staffId, DateTime date})>((ref, params) {
      final result = ref.watch(planningForStaffOnDateProvider(params));

      if (result is PlanningFound) {
        final planning = result.planning;
        if (planning.type == StaffPlanningType.biweekly) {
          return result.weekLabel;
        }
      }

      return null;
    });

/// Provider per gli slot disponibili dello staff nella data corrente dell'agenda.
///
/// Combina:
/// 1. Planning base (template settimanale con supporto biweekly)
/// 2. Eccezioni (da availabilityExceptionsProvider)
///
/// Usa la data da [agendaDateProvider].
final staffPlanningBaseSlotsProvider = Provider.family<Set<int>, int>((
  ref,
  staffId,
) {
  final agendaDate = ref.watch(agendaDateProvider);
  final slots = ref.watch(
    planningSlotsForDateProvider((staffId: staffId, date: agendaDate)),
  );

  return slots ?? {};
});

/// Provider per verificare se una data √® in settimana A o B.
///
/// Per planning weekly, ritorna sempre 'A'.
/// Per planning biweekly, calcola in base a validFrom.
/// Ritorna null se nessun planning.
final currentWeekLabelProvider = Provider.family<WeekLabel?, int>((
  ref,
  staffId,
) {
  final agendaDate = ref.watch(agendaDateProvider);
  return ref.watch(
    weekLabelForDateProvider((staffId: staffId, date: agendaDate)),
  );
});

/// Provider per i planning di uno staff specifico.
final planningsForStaffProvider = Provider.family<List<StaffPlanning>, int>((
  ref,
  staffId,
) {
  final plannings = ref.watch(staffPlanningsProvider);
  return plannings[staffId] ?? [];
});

/// Provider derivato per il planning attivo di uno staff nella data corrente.
final currentPlanningForStaffProvider = Provider.family<StaffPlanning?, int>((
  ref,
  staffId,
) {
  final agendaDate = ref.watch(agendaDateProvider);
  final result = ref.watch(
    planningForStaffOnDateProvider((staffId: staffId, date: agendaDate)),
  );

  if (result is PlanningFound) {
    return result.planning;
  }
  return null;
});

/// Provider che carica automaticamente i planning per uno staff.
///
/// Usa questo provider nell'agenda per assicurarsi che i planning
/// siano caricati prima di calcolare la disponibilit√†.
final ensureStaffPlanningLoadedProvider = FutureProvider.family<void, int>((
  ref,
  staffId,
) async {
  final plannings = ref.watch(staffPlanningsProvider);

  // Se i planning per questo staff sono gi√† caricati, non fare nulla
  if (plannings.containsKey(staffId)) {
    return;
  }

  // Altrimenti carica i planning
  await ref
      .read(staffPlanningsProvider.notifier)
      .loadPlanningsForStaff(staffId);
});
--- FILE: lib/features/staff/providers/staff_repository_provider.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../core/network/network_providers.dart';
import '../data/staff_repository.dart';

part 'staff_repository_provider.g.dart';

@Riverpod(keepAlive: true)
StaffRepository staffRepository(Ref ref) {
  final apiClient = ref.watch(apiClientProvider);
  return StaffRepository(apiClient: apiClient);
}
--- FILE: lib/features/staff/providers/staff_reorder_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../agenda/providers/location_providers.dart';
import 'staff_providers.dart';

class TeamReorderNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  void toggle() => state = !state;

  void setReordering(bool value) => state = value;

  Future<void> reorderLocations(int oldIndex, int newIndex) async {
    await ref.read(locationsProvider.notifier).reorder(oldIndex, newIndex);
  }

  Future<void> reorderStaffForLocation(
    int locationId,
    int oldIndex,
    int newIndex,
  ) async {
    await ref
        .read(allStaffProvider.notifier)
        .reorderForLocation(locationId, oldIndex, newIndex);
  }
}

final teamReorderProvider = NotifierProvider<TeamReorderNotifier, bool>(
  TeamReorderNotifier.new,
);

class TeamReorderPanelNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  void toggle() => state = !state;

  void setVisible(bool value) => state = value;
}

final teamReorderPanelProvider =
    NotifierProvider<TeamReorderPanelNotifier, bool>(
      TeamReorderPanelNotifier.new,
    );
--- FILE: lib/features/staff/providers/weekly_availability_provider.dart ---

--- FILE: lib/features/staff/providers/availability_exceptions_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/availability_exception.dart';
import '../../../core/network/network_providers.dart';
import '../../agenda/providers/business_providers.dart';
import '../data/api_availability_exceptions_repository.dart';
import '../data/availability_exceptions_repository.dart';

/// Provider per il repository delle eccezioni.
/// Usa l'implementazione API reale.
/// ‚ö†Ô∏è Usa ref.read per evitare rebuild continui quando currentBusinessProvider cambia
final availabilityExceptionsRepositoryProvider =
    Provider<AvailabilityExceptionsRepository>((ref) {
      final apiClient = ref.read(apiClientProvider);
      final business = ref.read(currentBusinessProvider);
      return ApiAvailabilityExceptionsRepository(
        apiClient: apiClient,
        businessId: business.id,
      );
    });

/// Provider per la gestione dello stato delle eccezioni.
///
/// Stato: `Map<staffId, List<AvailabilityException>>`
/// Carica le eccezioni on-demand quando richieste per uno staff specifico.
class AvailabilityExceptionsNotifier
    extends AsyncNotifier<Map<int, List<AvailabilityException>>> {
  @override
  Future<Map<int, List<AvailabilityException>>> build() async {
    // Inizialmente vuoto, le eccezioni vengono caricate on-demand
    return {};
  }

  AvailabilityExceptionsRepository get _repository =>
      ref.read(availabilityExceptionsRepositoryProvider);

  /// Carica le eccezioni per uno staff specifico in un range di date.
  /// Se [fromDate] e [toDate] non sono specificati, carica tutte le eccezioni.
  Future<void> loadExceptionsForStaff(
    int staffId, {
    DateTime? fromDate,
    DateTime? toDate,
  }) async {
    final exceptions = await _repository.getExceptionsForStaff(
      staffId,
      fromDate: fromDate,
      toDate: toDate,
    );

    final current = state.value ?? {};
    state = AsyncData({...current, staffId: exceptions});
  }

  /// Aggiunge una nuova eccezione.
  Future<AvailabilityException> addException({
    required int staffId,
    required DateTime date,
    TimeOfDay? startTime,
    TimeOfDay? endTime,
    required AvailabilityExceptionType type,
    String? reason,
  }) async {
    final exception = startTime != null && endTime != null
        ? AvailabilityException.timeRange(
            id: 0, // Il repository assegner√† l'ID reale
            staffId: staffId,
            date: date,
            startTime: startTime,
            endTime: endTime,
            type: type,
            reason: reason,
          )
        : AvailabilityException.allDay(
            id: 0,
            staffId: staffId,
            date: date,
            type: type,
            reason: reason,
          );

    final saved = await _repository.addException(exception);

    // Aggiorna lo stato locale
    final current = state.value ?? {};
    final staffExceptions = List<AvailabilityException>.from(
      current[staffId] ?? [],
    );
    staffExceptions.add(saved);

    state = AsyncData({...current, staffId: staffExceptions});

    return saved;
  }

  /// Aggiunge eccezioni per un periodo (batch).
  /// Crea un'eccezione per ogni giorno nel range [startDate, endDate].
  Future<List<AvailabilityException>> addExceptionsForPeriod({
    required int staffId,
    required DateTime startDate,
    required DateTime endDate,
    TimeOfDay? startTime,
    TimeOfDay? endTime,
    required AvailabilityExceptionType type,
    String? reason,
  }) async {
    final List<AvailabilityException> created = [];

    // Normalizza le date
    var currentDate = DateUtils.dateOnly(startDate);
    final lastDate = DateUtils.dateOnly(endDate);

    // Crea un'eccezione per ogni giorno
    while (!currentDate.isAfter(lastDate)) {
      final exception = startTime != null && endTime != null
          ? AvailabilityException.timeRange(
              id: 0,
              staffId: staffId,
              date: currentDate,
              startTime: startTime,
              endTime: endTime,
              type: type,
              reason: reason,
            )
          : AvailabilityException.allDay(
              id: 0,
              staffId: staffId,
              date: currentDate,
              type: type,
              reason: reason,
            );

      final saved = await _repository.addException(exception);
      created.add(saved);

      currentDate = currentDate.add(const Duration(days: 1));
    }

    // Aggiorna lo stato locale con tutte le eccezioni create
    final current = state.value ?? {};
    final staffExceptions = List<AvailabilityException>.from(
      current[staffId] ?? [],
    );
    staffExceptions.addAll(created);

    state = AsyncData({...current, staffId: staffExceptions});

    return created;
  }

  /// Aggiorna un'eccezione esistente.
  Future<AvailabilityException> updateException(
    AvailabilityException exception,
  ) async {
    final updated = await _repository.updateException(exception);

    // Aggiorna lo stato locale
    final current = state.value ?? {};
    final staffExceptions = List<AvailabilityException>.from(
      current[exception.staffId] ?? [],
    );
    final index = staffExceptions.indexWhere((e) => e.id == exception.id);
    if (index != -1) {
      staffExceptions[index] = updated;
    }

    state = AsyncData({...current, exception.staffId: staffExceptions});

    return updated;
  }

  /// Elimina un'eccezione.
  Future<void> deleteException(int staffId, int exceptionId) async {
    await _repository.deleteException(exceptionId);

    // Aggiorna lo stato locale
    final current = state.value ?? {};
    final staffExceptions = List<AvailabilityException>.from(
      current[staffId] ?? [],
    );
    staffExceptions.removeWhere((e) => e.id == exceptionId);

    state = AsyncData({...current, staffId: staffExceptions});
  }

  /// Ottiene le eccezioni per uno staff in una data specifica (sincronamente dallo stato).
  List<AvailabilityException> getExceptionsForStaffOnDate(
    int staffId,
    DateTime date,
  ) {
    final current = state.value ?? {};
    final staffExceptions = current[staffId] ?? [];
    return staffExceptions.where((e) => e.isOnDate(date)).toList();
  }
}

final availabilityExceptionsProvider =
    AsyncNotifierProvider<
      AvailabilityExceptionsNotifier,
      Map<int, List<AvailabilityException>>
    >(AvailabilityExceptionsNotifier.new);

/// Provider derivato: eccezioni per uno staff specifico in una data specifica.
/// Utile per query puntuali nella UI.
final exceptionsForStaffOnDateProvider =
    Provider.family<
      List<AvailabilityException>,
      ({int staffId, DateTime date})
    >((ref, params) {
      final allExceptions = ref.watch(availabilityExceptionsProvider);

      return allExceptions.maybeWhen(
        data: (data) {
          final staffExceptions = data[params.staffId] ?? [];
          return staffExceptions.where((e) => e.isOnDate(params.date)).toList();
        },
        orElse: () => [],
      );
    });

/// Provider derivato: verifica se ci sono eccezioni per uno staff in una data.
final hasExceptionsForStaffOnDateProvider =
    Provider.family<bool, ({int staffId, DateTime date})>((ref, params) {
      final exceptions = ref.watch(exceptionsForStaffOnDateProvider(params));
      return exceptions.isNotEmpty;
    });

/// Provider derivato: tutte le eccezioni per uno staff (lista flat).
final allExceptionsForStaffProvider =
    Provider.family<List<AvailabilityException>, int>((ref, staffId) {
      final allExceptions = ref.watch(availabilityExceptionsProvider);

      return allExceptions.maybeWhen(
        data: (data) => data[staffId] ?? [],
        orElse: () => [],
      );
    });
--- FILE: lib/features/staff/providers/staff_weekly_availability_provider.dart ---
import 'dart:async';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/staff_planning.dart';
import '../../../core/services/staff_planning_selector.dart' show PlanningFound;
import '../../agenda/providers/date_range_provider.dart';
import 'staff_planning_provider.dart';
import 'staff_providers.dart';

/// Disponibilit√† settimanale derivata dal planning:
/// staffId -> weekday(1..7) -> slot indices.
class StaffAvailabilityByStaffNotifier
    extends AsyncNotifier<Map<int, Map<int, Set<int>>>> {
  @override
  FutureOr<Map<int, Map<int, Set<int>>>> build() async {
    final staffList = ref.watch(sortedAllStaffProvider);
    final allPlanningsState = ref.watch(staffPlanningsProvider);
    final selector = ref.watch(staffPlanningSelectorProvider);
    final weekDate = ref.watch(agendaDateProvider);
    final monday = _mondayOfWeek(weekDate);

    final allPlannings = allPlanningsState.values.expand((list) => list).toList();
    final result = <int, Map<int, Set<int>>>{};

    for (final staff in staffList) {
      final staffWeek = <int, Set<int>>{};
      for (int weekday = 1; weekday <= 7; weekday++) {
        final date = monday.add(Duration(days: weekday - 1));
        final lookup = selector.findPlanningForDate(
          staffId: staff.id,
          date: date,
          allPlannings: allPlannings,
        );
        final daySlots = switch (lookup) {
          PlanningFound(template: final template) => template.getSlotsForDay(
            weekday,
          ),
          _ => <int>{},
        };
        staffWeek[weekday] = Set<int>.from(daySlots);
      }
      result[staff.id] = staffWeek;
    }

    return result;
  }

  DateTime _mondayOfWeek(DateTime d) {
    final onlyDate = DateTime(d.year, d.month, d.day);
    return onlyDate.subtract(Duration(days: onlyDate.weekday - 1));
  }

  Future<void> saveForStaff(int staffId, Map<int, Set<int>> weeklySlots) async {
    final previousState = state;
    state = const AsyncLoading();

    try {
      final planningNotifier = ref.read(staffPlanningsProvider.notifier);
      var plannings = List<StaffPlanning>.from(
        ref.read(planningsForStaffProvider(staffId)),
      );
      if (plannings.isEmpty) {
        await planningNotifier.loadPlanningsForStaff(staffId);
        plannings = List<StaffPlanning>.from(
          ref.read(planningsForStaffProvider(staffId)),
        );
      }

      if (plannings.isEmpty) {
        state = previousState;
        return;
      }

      final selector = ref.read(staffPlanningSelectorProvider);
      final weekDate = ref.read(agendaDateProvider);
      final monday = _mondayOfWeek(weekDate);
      final originalsById = {for (final p in plannings) p.id: p};
      final updatedById = <int, StaffPlanning>{};

      for (int weekday = 1; weekday <= 7; weekday++) {
        final date = monday.add(Duration(days: weekday - 1));
        final lookup = selector.findPlanningForDate(
          staffId: staffId,
          date: date,
          allPlannings: plannings,
        );
        if (lookup is! PlanningFound) continue;

        final original = originalsById[lookup.planning.id];
        if (original == null) continue;
        final currentPlanning = updatedById[original.id] ?? original;
        final template = lookup.weekLabel == WeekLabel.a
            ? currentPlanning.templateA
            : currentPlanning.templateB;
        if (template == null) continue;

        final updatedDaySlots = Map<int, Set<int>>.from(template.daySlots);
        updatedDaySlots[weekday] = Set<int>.from(weeklySlots[weekday] ?? {});
        final updatedTemplate = template.copyWith(daySlots: updatedDaySlots);

        final updatedTemplates = currentPlanning.templates
            .map(
              (t) => t.weekLabel == updatedTemplate.weekLabel
                  ? updatedTemplate
                  : t,
            )
            .toList();
        updatedById[original.id] = currentPlanning.copyWith(
          templates: updatedTemplates,
        );
      }

      for (final entry in updatedById.entries) {
        final original = originalsById[entry.key];
        if (original == null) continue;
        final result = await planningNotifier.updatePlanning(
          entry.value,
          original,
        );
        if (!result.isValid) {
          throw Exception(result.errors.join('\n'));
        }
      }

      ref.invalidateSelf();
      state = AsyncData(await future);
    } catch (e) {
      state = previousState;
      rethrow;
    }
  }

  Future<void> refresh() async {
    ref.invalidateSelf();
  }
}

final staffAvailabilityByStaffProvider = AsyncNotifierProvider<
  StaffAvailabilityByStaffNotifier,
  Map<int, Map<int, Set<int>>>
>(StaffAvailabilityByStaffNotifier.new);
--- FILE: lib/features/staff/utils/staff_formatters.dart ---
// Placeholder per futuri formatter relativi allo staff.
--- FILE: lib/features/staff/utils/staff_validators.dart ---
// Placeholder per futuri validator relativi allo staff.
--- FILE: lib/features/staff/data/weekly_availability_repository.dart ---

--- FILE: lib/features/staff/data/staff_api.dart ---
import '../../../core/models/staff.dart';
import '../../../core/network/api_client.dart';

/// API layer per Staff - chiamate reali a agenda_core
class StaffApi {
  final ApiClient _apiClient;

  StaffApi({required ApiClient apiClient}) : _apiClient = apiClient;

  /// GET /v1/staff?location_id=X
  Future<List<Staff>> fetchStaff(int locationId) async {
    final data = await _apiClient.getStaff(locationId);
    final List<dynamic> items = data['staff'] ?? [];
    return items
        .map((json) => Staff.fromJson(json as Map<String, dynamic>))
        .toList();
  }
}
--- FILE: lib/features/staff/data/api_availability_exceptions_repository.dart ---
import 'package:flutter/material.dart';

import '../../../core/models/availability_exception.dart';
import '../../../core/network/api_client.dart';
import 'availability_exceptions_repository.dart';

/// Implementazione del repository per le eccezioni che usa l'API reale.
class ApiAvailabilityExceptionsRepository
    implements AvailabilityExceptionsRepository {
  final ApiClient _apiClient;
  final int _businessId;

  // Cache locale per evitare chiamate API ripetute
  final Map<int, List<AvailabilityException>> _cache = {};
  DateTime? _cacheValidUntil;

  ApiAvailabilityExceptionsRepository({
    required ApiClient apiClient,
    required int businessId,
  }) : _apiClient = apiClient,
       _businessId = businessId;

  bool get _isCacheValid =>
      _cacheValidUntil != null && DateTime.now().isBefore(_cacheValidUntil!);

  void _invalidateCache() {
    _cache.clear();
    _cacheValidUntil = null;
  }

  /// Carica tutte le eccezioni per il business e popola la cache.
  Future<void> _loadAllExceptions({String? fromDate, String? toDate}) async {
    final result = await _apiClient.getStaffAvailabilityExceptionsAll(
      _businessId,
      fromDate: fromDate,
      toDate: toDate,
    );

    _cache.clear();
    for (final entry in result.entries) {
      _cache[entry.key] = entry.value.map(_parseException).toList();
    }
    // Cache valida per 5 minuti
    _cacheValidUntil = DateTime.now().add(const Duration(minutes: 5));
  }

  AvailabilityException _parseException(Map<String, dynamic> json) {
    final type = json['type'] == 'available'
        ? AvailabilityExceptionType.available
        : AvailabilityExceptionType.unavailable;

    final date = DateTime.parse(json['date'] as String);

    TimeOfDay? startTime;
    TimeOfDay? endTime;

    if (json['start_time'] != null) {
      final parts = (json['start_time'] as String).split(':');
      startTime = TimeOfDay(
        hour: int.parse(parts[0]),
        minute: int.parse(parts[1]),
      );
    }

    if (json['end_time'] != null) {
      final parts = (json['end_time'] as String).split(':');
      endTime = TimeOfDay(
        hour: int.parse(parts[0]),
        minute: int.parse(parts[1]),
      );
    }

    if (startTime != null && endTime != null) {
      return AvailabilityException.timeRange(
        id: json['id'] as int,
        staffId: json['staff_id'] as int,
        date: date,
        startTime: startTime,
        endTime: endTime,
        type: type,
        reasonCode: json['reason_code'] as String?,
        reason: json['reason'] as String?,
      );
    } else {
      return AvailabilityException.allDay(
        id: json['id'] as int,
        staffId: json['staff_id'] as int,
        date: date,
        type: type,
        reasonCode: json['reason_code'] as String?,
        reason: json['reason'] as String?,
      );
    }
  }

  String _formatTime(TimeOfDay time) {
    return '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';
  }

  String _formatDate(DateTime date) {
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
  }

  @override
  Future<List<AvailabilityException>> getExceptionsForStaff(
    int staffId, {
    DateTime? fromDate,
    DateTime? toDate,
  }) async {
    // Se la cache √® valida, usa quella
    if (_isCacheValid && _cache.containsKey(staffId)) {
      var exceptions = _cache[staffId]!;
      if (fromDate != null) {
        exceptions = exceptions
            .where((e) => !e.date.isBefore(fromDate))
            .toList();
      }
      if (toDate != null) {
        exceptions = exceptions.where((e) => !e.date.isAfter(toDate)).toList();
      }
      return exceptions;
    }

    // Carica da API
    final result = await _apiClient.getStaffAvailabilityExceptions(
      staffId,
      fromDate: fromDate != null ? _formatDate(fromDate) : null,
      toDate: toDate != null ? _formatDate(toDate) : null,
    );

    final exceptions = result.map(_parseException).toList();
    _cache[staffId] = exceptions;

    return exceptions;
  }

  @override
  Future<List<AvailabilityException>> getExceptionsForDate(
    DateTime date,
  ) async {
    // Carica tutte le eccezioni se cache non valida
    if (!_isCacheValid) {
      await _loadAllExceptions();
    }

    final targetDate = DateUtils.dateOnly(date);
    final result = <AvailabilityException>[];

    for (final exceptions in _cache.values) {
      for (final e in exceptions) {
        if (e.isOnDate(targetDate)) {
          result.add(e);
        }
      }
    }

    return result;
  }

  @override
  Future<AvailabilityException?> getException(int id) async {
    // Cerca prima nella cache
    for (final exceptions in _cache.values) {
      for (final e in exceptions) {
        if (e.id == id) return e;
      }
    }

    // Non trovato in cache - in futuro potremmo aggiungere endpoint GET /v1/staff/availability-exceptions/{id}
    return null;
  }

  @override
  Future<AvailabilityException> addException(
    AvailabilityException exception,
  ) async {
    final result = await _apiClient.createStaffAvailabilityException(
      staffId: exception.staffId,
      date: _formatDate(exception.date),
      startTime: exception.startTime != null
          ? _formatTime(exception.startTime!)
          : null,
      endTime: exception.endTime != null
          ? _formatTime(exception.endTime!)
          : null,
      type: exception.type == AvailabilityExceptionType.available
          ? 'available'
          : 'unavailable',
      reasonCode: exception.reasonCode,
      reason: exception.reason,
    );

    final created = _parseException(result);

    // Aggiorna cache
    _cache.putIfAbsent(created.staffId, () => []);
    _cache[created.staffId]!.add(created);

    return created;
  }

  @override
  Future<AvailabilityException> updateException(
    AvailabilityException exception,
  ) async {
    final result = await _apiClient.updateStaffAvailabilityException(
      exceptionId: exception.id,
      date: _formatDate(exception.date),
      startTime: exception.startTime != null
          ? _formatTime(exception.startTime!)
          : null,
      endTime: exception.endTime != null
          ? _formatTime(exception.endTime!)
          : null,
      type: exception.type == AvailabilityExceptionType.available
          ? 'available'
          : 'unavailable',
      reasonCode: exception.reasonCode,
      reason: exception.reason,
    );

    final updated = _parseException(result);

    // Aggiorna cache
    if (_cache.containsKey(updated.staffId)) {
      final index = _cache[updated.staffId]!.indexWhere(
        (e) => e.id == updated.id,
      );
      if (index != -1) {
        _cache[updated.staffId]![index] = updated;
      }
    }

    return updated;
  }

  @override
  Future<void> deleteException(int id) async {
    await _apiClient.deleteStaffAvailabilityException(id);

    // Rimuovi dalla cache
    for (final exceptions in _cache.values) {
      exceptions.removeWhere((e) => e.id == id);
    }
  }

  /// Forza il refresh della cache.
  void refresh() {
    _invalidateCache();
  }
}
--- FILE: lib/features/staff/data/availability_exceptions_repository.dart ---
import '../../../core/models/availability_exception.dart';

/// Repository per la gestione delle eccezioni alla disponibilit√†.
///
/// Implementazione API in `api_availability_exceptions_repository.dart`.
abstract class AvailabilityExceptionsRepository {
  /// Carica tutte le eccezioni per uno staff in un range di date.
  Future<List<AvailabilityException>> getExceptionsForStaff(
    int staffId, {
    DateTime? fromDate,
    DateTime? toDate,
  });

  /// Carica tutte le eccezioni per una data specifica (tutti gli staff).
  Future<List<AvailabilityException>> getExceptionsForDate(DateTime date);

  /// Carica un'eccezione per ID.
  Future<AvailabilityException?> getException(int id);

  /// Aggiunge una nuova eccezione.
  Future<AvailabilityException> addException(AvailabilityException exception);

  /// Aggiorna un'eccezione esistente.
  Future<AvailabilityException> updateException(
    AvailabilityException exception,
  );

  /// Elimina un'eccezione.
  Future<void> deleteException(int id);
}
--- FILE: lib/features/staff/data/staff_repository.dart ---
import '../../../core/models/staff.dart';
import '../../../core/network/api_client.dart';
import 'staff_api.dart';

class StaffRepository {
  StaffRepository({required ApiClient apiClient})
    : _apiClient = apiClient,
      _api = StaffApi(apiClient: apiClient);

  final ApiClient _apiClient;
  final StaffApi _api;

  Future<List<Staff>> getByLocation(int locationId) =>
      _api.fetchStaff(locationId);

  Future<List<Staff>> getByBusiness(int businessId) async {
    final data = await _apiClient.getStaffByBusiness(businessId);
    return data.map((json) => Staff.fromJson(json)).toList();
  }

  Future<Staff> create({
    required int businessId,
    required String name,
    String? surname,
    String? colorHex,
    String? avatarUrl,
    bool? isBookableOnline,
    List<int>? locationIds,
    List<int>? serviceIds,
  }) async {
    final data = await _apiClient.createStaff(
      businessId: businessId,
      name: name,
      surname: surname,
      colorHex: colorHex,
      avatarUrl: avatarUrl,
      isBookableOnline: isBookableOnline,
      locationIds: locationIds,
      serviceIds: serviceIds,
    );
    return Staff.fromJson(data);
  }

  Future<Staff> update({
    required int staffId,
    String? name,
    String? surname,
    String? colorHex,
    String? avatarUrl,
    bool? isBookableOnline,
    int? sortOrder,
    List<int>? locationIds,
    List<int>? serviceIds,
  }) async {
    final data = await _apiClient.updateStaff(
      staffId: staffId,
      name: name,
      surname: surname,
      colorHex: colorHex,
      avatarUrl: avatarUrl,
      isBookableOnline: isBookableOnline,
      sortOrder: sortOrder,
      locationIds: locationIds,
      serviceIds: serviceIds,
    );
    return Staff.fromJson(data);
  }

  Future<void> delete(int staffId) async {
    await _apiClient.deleteStaff(staffId);
  }

  /// Batch update sort_order for multiple staff members
  Future<void> reorderStaff(List<Map<String, dynamic>> staffList) async {
    await _apiClient.reorderStaff(staff: staffList);
  }
}
--- FILE: lib/features/staff/presentation/staff_screen.dart ---
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/l10_extension.dart';
import 'widgets/staff_hub_card.dart';

class StaffScreen extends StatelessWidget {
  const StaffScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    return Scaffold(
      body: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              l10n.staffScreenPlaceholder,
              style: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 24),
            Wrap(
              spacing: 16,
              runSpacing: 16,
              children: [
                StaffHubCard(
                  icon: Icons.schedule,
                  title: l10n.staffHubAvailabilityTitle,
                  subtitle: l10n.staffHubAvailabilitySubtitle,
                  onTap: () => context.go('/staff/availability'),
                ),
                StaffHubCard(
                  icon: Icons.group,
                  title: l10n.staffHubTeamTitle,
                  subtitle: l10n.staffHubTeamSubtitle,
                  onTap: () {},
                  disabled: true,
                ),
                StaffHubCard(
                  icon: Icons.insights,
                  title: l10n.staffHubStatsTitle,
                  subtitle: l10n.staffHubStatsSubtitle,
                  onTap: () {},
                  disabled: true,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/screens/resources_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/location.dart';
import '../../../../core/models/resource.dart';
import '../../../../core/network/network_providers.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../agenda/providers/resource_providers.dart';
import '../dialogs/resource_dialog.dart';

/// Provider che carica il conteggio servizi per ogni risorsa della location
final resourceServiceCountsProvider = FutureProvider.family<Map<int, int>, int>(
  (ref, locationId) async {
    final apiClient = ref.watch(apiClientProvider);
    final resources = ref.watch(locationResourcesProvider(locationId));

    final counts = <int, int>{};
    for (final resource in resources) {
      try {
        final response = await apiClient.getResourceServices(resource.id);
        final services = response['services'] as List? ?? [];
        counts[resource.id] = services.length;
      } catch (_) {
        counts[resource.id] = 0;
      }
    }
    return counts;
  },
);

class ResourcesScreen extends ConsumerWidget {
  const ResourcesScreen({super.key, required this.location});

  final Location location;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final resources = ref.watch(locationResourcesProvider(location.id));
    final serviceCountsAsync = ref.watch(
      resourceServiceCountsProvider(location.id),
    );
    final serviceCounts = serviceCountsAsync.value ?? {};

    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.resourcesTitle),
        centerTitle: false,
        actions: [
          Padding(
            padding: const EdgeInsets.only(right: 12),
            child: FilledButton.icon(
              onPressed: () =>
                  showResourceDialog(context, ref, locationId: location.id),
              icon: const Icon(Icons.add, size: 18),
              label: Text(l10n.agendaAdd),
            ),
          ),
        ],
      ),
      body: resources.isEmpty
          ? _EmptyState(locationId: location.id)
          : ListView.separated(
              padding: const EdgeInsets.all(16),
              itemCount: resources.length,
              separatorBuilder: (_, __) => const SizedBox(height: 12),
              itemBuilder: (context, index) {
                final resource = resources[index];
                final serviceCount = serviceCounts[resource.id] ?? 0;
                return _ResourceCard(
                  resource: resource,
                  serviceCount: serviceCount,
                  onEdit: () => showResourceDialog(
                    context,
                    ref,
                    locationId: location.id,
                    resource: resource,
                  ),
                  onDelete: () => _confirmDelete(context, ref, resource),
                );
              },
            ),
    );
  }

  Future<void> _confirmDelete(
    BuildContext context,
    WidgetRef ref,
    Resource resource,
  ) async {
    final l10n = context.l10n;

    await showAppConfirmDialog(
      context,
      title: Text(l10n.resourceDeleteConfirm),
      content: Text(l10n.resourceDeleteWarning),
      confirmLabel: l10n.actionDelete,
      cancelLabel: l10n.actionCancel,
      danger: true,
      onConfirm: () async {
        await ref.read(resourcesProvider.notifier).deleteResource(resource.id);
      },
    );
  }
}

class _EmptyState extends ConsumerWidget {
  const _EmptyState({required this.locationId});

  final int locationId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.inventory_2_outlined,
              size: 64,
              color: colorScheme.outline,
            ),
            const SizedBox(height: 16),
            Text(
              l10n.resourcesEmpty,
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              l10n.resourcesEmptyHint,
              style: Theme.of(
                context,
              ).textTheme.bodyMedium?.copyWith(color: colorScheme.outline),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 24),
            AppFilledButton(
              onPressed: () =>
                  showResourceDialog(context, ref, locationId: locationId),
              child: Text(l10n.agendaAdd),
            ),
          ],
        ),
      ),
    );
  }
}

class _ResourceCard extends StatelessWidget {
  const _ResourceCard({
    required this.resource,
    required this.serviceCount,
    required this.onEdit,
    required this.onDelete,
  });

  final Resource resource;
  final int serviceCount;
  final VoidCallback onEdit;
  final VoidCallback onDelete;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: colorScheme.outlineVariant.withOpacity(0.5)),
      ),
      child: InkWell(
        onTap: onEdit,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              Container(
                width: 48,
                height: 48,
                decoration: BoxDecoration(
                  color: colorScheme.primaryContainer,
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Center(
                  child: Text(
                    '${resource.quantity}',
                    style: textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: colorScheme.onPrimaryContainer,
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      resource.name,
                      style: textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    if (resource.type != null && resource.type!.isNotEmpty)
                      Padding(
                        padding: const EdgeInsets.only(top: 2),
                        child: Text(
                          resource.type!,
                          style: textTheme.bodySmall?.copyWith(
                            color: colorScheme.outline,
                          ),
                        ),
                      ),
                    if (resource.note != null && resource.note!.isNotEmpty)
                      Padding(
                        padding: const EdgeInsets.only(top: 4),
                        child: Text(
                          resource.note!,
                          style: textTheme.bodySmall?.copyWith(
                            color: colorScheme.onSurfaceVariant,
                          ),
                          maxLines: 2,
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                    // Conteggio servizi associati
                    Padding(
                      padding: const EdgeInsets.only(top: 6),
                      child: Row(
                        children: [
                          Icon(
                            Icons.category_outlined,
                            size: 14,
                            color: colorScheme.outline,
                          ),
                          const SizedBox(width: 4),
                          Text(
                            serviceCount == 1
                                ? context.l10n.resourceServiceCountSingular
                                : context.l10n.resourceServiceCountPlural(
                                    serviceCount,
                                  ),
                            style: textTheme.bodySmall?.copyWith(
                              color: colorScheme.outline,
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
              PopupMenuButton<String>(
                icon: Icon(
                  Icons.more_vert,
                  color: colorScheme.onSurfaceVariant,
                ),
                onSelected: (value) {
                  switch (value) {
                    case 'edit':
                      onEdit();
                      break;
                    case 'delete':
                      onDelete();
                      break;
                  }
                },
                itemBuilder: (context) => [
                  PopupMenuItem(
                    value: 'edit',
                    child: Row(
                      children: [
                        const Icon(Icons.edit_outlined, size: 20),
                        const SizedBox(width: 12),
                        Text(context.l10n.actionEdit),
                      ],
                    ),
                  ),
                  const PopupMenuDivider(),
                  PopupMenuItem(
                    value: 'delete',
                    child: Row(
                      children: [
                        Icon(
                          Icons.delete_outline,
                          size: 20,
                          color: colorScheme.error,
                        ),
                        const SizedBox(width: 12),
                        Text(
                          context.l10n.actionDelete,
                          style: TextStyle(color: colorScheme.error),
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/team_screen.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/location.dart';
import 'package:agenda_backend/core/models/staff.dart';
import 'package:agenda_backend/core/widgets/app_dialogs.dart';
import 'package:agenda_backend/core/widgets/reorder_toggle_button.dart';
import 'package:agenda_backend/core/widgets/reorder_toggle_panel.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../agenda/providers/location_providers.dart';
import '../../auth/providers/current_business_user_provider.dart';
import '../providers/staff_providers.dart';
import '../providers/staff_reorder_provider.dart';
import '../providers/staff_sorted_providers.dart';
import 'dialogs/location_dialog.dart';
import 'dialogs/staff_dialog.dart';
import 'screens/resources_screen.dart';
import 'widgets/location_item.dart';

class TeamScreen extends ConsumerStatefulWidget {
  const TeamScreen({super.key});

  @override
  ConsumerState<TeamScreen> createState() => _TeamScreenState();
}

class _TeamScreenState extends ConsumerState<TeamScreen> {
  final ScrollController _scrollController = ScrollController();
  bool isReorderLocations = false;
  bool isReorderStaff = false;

  // NOTE: Non serve initState con refresh() perch√©:
  // 1. I provider AsyncNotifier caricano i dati automaticamente nel build()
  // 2. Il refresh al cambio tab avviene in _refreshProvidersForTab()

  void _toggleLocationReorder() {
    setState(() {
      isReorderLocations = !isReorderLocations;
      if (isReorderLocations) isReorderStaff = false;
    });
    if (!isReorderLocations) {
      ref.read(teamReorderPanelProvider.notifier).setVisible(false);
    }
  }

  void _toggleStaffReorder() {
    setState(() {
      isReorderStaff = !isReorderStaff;
      if (isReorderStaff) isReorderLocations = false;
    });
    if (!isReorderStaff) {
      ref.read(teamReorderPanelProvider.notifier).setVisible(false);
    }
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final locations = ref.watch(sortedLocationsProvider);
    final staffAsync = ref.watch(allStaffProvider);
    final isWide = ref.watch(formFactorProvider) != AppFormFactor.mobile;
    final showReorderPanel = ref.watch(teamReorderPanelProvider);

    ref.listen<bool>(teamReorderPanelProvider, (previous, next) {
      if (!next && (isReorderLocations || isReorderStaff)) {
        setState(() {
          isReorderLocations = false;
          isReorderStaff = false;
        });
      }
      // Se apro il pannello e c'√® solo 1 location, attiva subito riordino staff
      if (next && previous == false && locations.length < 2) {
        setState(() {
          isReorderStaff = true;
          isReorderLocations = false;
        });
      }
    });

    // Mostra loading mentre carica staff
    if (staffAsync.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (locations.isEmpty) {
      return const SizedBox.shrink();
    }

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: () {},
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (showReorderPanel) ...[
            Builder(
              builder: (context) {
                // Conta lo staff totale
                final totalStaffCount = staffAsync.value?.length ?? 0;
                final showLocationReorder = locations.length >= 2;
                final showStaffReorder = totalStaffCount >= 2;

                return Padding(
                  padding: const EdgeInsets.all(16),
                  child: Center(
                    child: Column(
                      children: [
                        Text(
                          context.l10n.reorderTitle,
                          style: Theme.of(context).textTheme.titleSmall
                              ?.copyWith(fontWeight: FontWeight.w600),
                        ),
                        Padding(
                          padding: const EdgeInsets.fromLTRB(0, 4, 0, 8),
                          child: Text(
                            context.l10n.teamReorderHelpDescription,
                            style: Theme.of(context).textTheme.bodySmall
                                ?.copyWith(
                                  color: Theme.of(
                                    context,
                                  ).colorScheme.onSurfaceVariant,
                                ),
                          ),
                        ),
                        ReorderTogglePanel(
                          isWide: isWide,
                          children: [
                            if (showLocationReorder)
                              ReorderToggleButton(
                                isActive: isReorderLocations,
                                onPressed: _toggleLocationReorder,
                                activeLabel: context.l10n.teamLocationsLabel,
                                inactiveLabel: context.l10n.teamLocationsLabel,
                                activeIcon: Icons.check,
                                inactiveIcon: Icons.drag_indicator,
                              ),
                            if (showStaffReorder)
                              ReorderToggleButton(
                                isActive: isReorderStaff,
                                onPressed: _toggleStaffReorder,
                                activeLabel: context.l10n.teamStaffLabel,
                                inactiveLabel: context.l10n.teamStaffLabel,
                                activeIcon: Icons.check,
                                inactiveIcon: Icons.drag_indicator,
                              ),
                          ],
                        ),
                      ],
                    ),
                  ),
                );
              },
            ),
          ],
          Expanded(
            child: isReorderLocations
                ? _buildReorderLocations(context, ref, locations)
                : isReorderStaff
                ? _buildReorderStaff(context, ref, locations)
                : _buildNormalList(context, ref, locations, isWide),
          ),
        ],
      ),
    );
  }

  Widget _buildReorderLocations(
    BuildContext context,
    WidgetRef ref,
    List<Location> locations,
  ) {
    final notifier = ref.read(teamReorderProvider.notifier);
    final colorScheme = Theme.of(context).colorScheme;
    return ReorderableListView.builder(
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 100),
      buildDefaultDragHandles: false,
      proxyDecorator: (child, index, animation) => child,
      itemCount: locations.length,
      onReorder: (oldIndex, newIndex) =>
          notifier.reorderLocations(oldIndex, newIndex),
      itemBuilder: (context, index) {
        final loc = locations[index];
        return Container(
          key: ValueKey('loc-${loc.id}'),
          margin: const EdgeInsets.only(bottom: 16),
          decoration: BoxDecoration(
            color: colorScheme.surface,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: colorScheme.outlineVariant.withOpacity(0.4),
            ),
          ),
          child: ListTile(
            leading: ReorderableDragStartListener(
              index: index,
              child: const Icon(Icons.drag_indicator),
            ),
            title: Text(loc.name),
          ),
        );
      },
    );
  }

  Widget _buildReorderStaff(
    BuildContext context,
    WidgetRef ref,
    List<Location> locations,
  ) {
    final notifier = ref.read(teamReorderProvider.notifier);
    final colorScheme = Theme.of(context).colorScheme;

    final staffByLocation = <int, List<Staff>>{
      for (final loc in locations)
        loc.id: ref.watch(staffByLocationProvider(loc.id)),
    };

    final rows = <({bool isHeader, int locationId, Staff? staff})>[];
    for (final loc in locations) {
      rows.add((isHeader: true, locationId: loc.id, staff: null));
      for (final member in staffByLocation[loc.id] ?? const <Staff>[]) {
        rows.add((isHeader: false, locationId: loc.id, staff: member));
      }
    }

    int indexInLocation(int rowIndex) {
      final locationId = rows[rowIndex].locationId;
      int count = 0;
      for (int i = 0; i < rowIndex; i++) {
        final row = rows[i];
        if (!row.isHeader && row.locationId == locationId) count++;
      }
      return count;
    }

    return ReorderableListView.builder(
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 100),
      buildDefaultDragHandles: false,
      proxyDecorator: (child, index, animation) => child,
      itemCount: rows.length,
      onReorder: (oldIndex, newIndex) {
        if (newIndex > oldIndex) newIndex -= 1;
        if (newIndex >= rows.length) newIndex = rows.length - 1;
        final moving = rows[oldIndex];
        if (moving.isHeader) return;
        if (rows[newIndex].isHeader) {
          if (rows[newIndex].locationId == moving.locationId) {
            newIndex = (newIndex + 1).clamp(0, rows.length - 1);
          } else {
            return;
          }
        }
        final target = rows[newIndex];
        if (target.locationId != moving.locationId) return;
        notifier.reorderStaffForLocation(
          moving.locationId,
          indexInLocation(oldIndex),
          indexInLocation(newIndex),
        );
      },
      itemBuilder: (context, index) {
        final row = rows[index];
        if (row.isHeader) {
          final loc = locations.firstWhere((l) => l.id == row.locationId);
          return Container(
            key: ValueKey('header-${loc.id}'),
            width: double.infinity,
            margin: const EdgeInsets.only(top: 16, bottom: 6),
            decoration: BoxDecoration(
              color: colorScheme.primaryContainer,
              borderRadius: const BorderRadius.vertical(
                top: Radius.circular(16),
              ),
            ),
            padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),
            child: Text(
              loc.name,
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
                color: colorScheme.onPrimaryContainer,
              ),
            ),
          );
        }

        final member = row.staff!;
        return Container(
          key: ValueKey('staff-${row.locationId}-${member.id}'),
          margin: const EdgeInsets.only(bottom: 6),
          decoration: BoxDecoration(
            color: colorScheme.surface,
            borderRadius: BorderRadius.circular(10),
            border: Border.all(
              color: colorScheme.outlineVariant.withOpacity(0.7),
            ),
          ),
          child: ListTile(
            leading: ReorderableDragStartListener(
              index: index,
              child: const Icon(Icons.drag_indicator),
            ),
            title: Text(member.displayName),
            dense: true,
            contentPadding: const EdgeInsets.symmetric(
              horizontal: 12,
              vertical: 4,
            ),
          ),
        );
      },
    );
  }

  Widget _buildNormalList(
    BuildContext context,
    WidgetRef ref,
    List<Location> locations,
    bool isWide,
  ) {
    final canManageStaff = ref.watch(currentUserCanManageStaffProvider);
    final canManageSettings = ref.watch(canManageBusinessSettingsProvider);
    final currentUserRole = ref.watch(currentUserRoleProvider);
    final currentUserStaffId = ref.watch(currentUserStaffIdProvider);
    final isManagerRole = currentUserRole == 'manager';
    final isStaffRole =
        currentUserRole == 'staff' &&
        currentUserStaffId != null &&
        currentUserStaffId > 0;
    final visibleLocations = isStaffRole
        ? locations.where((loc) {
            final staffInLocation = ref.watch(staffByLocationProvider(loc.id));
            return staffInLocation.any((s) => s.id == currentUserStaffId);
          }).toList()
        : locations;

    return ListView.builder(
      controller: _scrollController,
      padding: const EdgeInsets.fromLTRB(16, 0, 16, 24),
      itemCount: visibleLocations.length,
      itemBuilder: (context, index) {
        final loc = visibleLocations[index];
        final allStaffInLocation = ref.watch(staffByLocationProvider(loc.id));
        final staff = isStaffRole
            ? allStaffInLocation
                  .where((s) => s.id == currentUserStaffId)
                  .toList()
            : allStaffInLocation;
        return LocationItem(
          location: loc,
          staff: staff,
          isWide: isWide,
          readOnly: !canManageStaff,
          onAddStaff: canManageStaff
              ? () => showStaffDialog(context, ref, initialLocationId: loc.id)
              : () {},
          onManageResources: canManageSettings
              ? () => Navigator.of(context, rootNavigator: true).push(
                  MaterialPageRoute(
                    builder: (_) => ResourcesScreen(location: loc),
                  ),
                )
              : null,
          onEditLocation: canManageSettings
              ? () => showLocationDialog(context, ref, initial: loc)
              : () {},
          onDeleteLocation: () async {
            if (!canManageSettings) return;
            if (staff.isNotEmpty) {
              await showAppInfoDialog(
                context,
                title: Text(context.l10n.teamDeleteLocationBlockedTitle),
                content: Text(context.l10n.teamDeleteLocationBlockedMessage),
              );
              return;
            }
            final confirmed = await showConfirmDialog(
              context,
              title: Text(context.l10n.teamDeleteLocationTitle),
              content: Text(context.l10n.teamDeleteLocationMessage),
              confirmLabel: context.l10n.actionConfirm,
              cancelLabel: context.l10n.actionCancel,
            );
            if (confirmed == true) {
              final currentId = ref.read(currentLocationIdProvider);
              await ref
                  .read(locationsProvider.notifier)
                  .deleteLocation(loc.id, currentLocationId: currentId);
            }
          },
          onEditStaff: (staff) {
            final isOwnStaff =
                currentUserStaffId != null && staff.id == currentUserStaffId;
            final canEditThisStaff =
                canManageStaff || isManagerRole || (isStaffRole && isOwnStaff);
            showStaffDialog(
              context,
              ref,
              initial: staff,
              readOnly: !canEditThisStaff,
            );
          },
          onDuplicateStaff: canManageStaff
              ? (staff) => showStaffDialog(
                  context,
                  ref,
                  initial: staff,
                  duplicateFrom: true,
                )
              : (_) {},
          onDeleteStaff: (staff) async {
            final isOwnStaff =
                currentUserStaffId != null && staff.id == currentUserStaffId;
            if (isOwnStaff) return;
            if (!canManageStaff) return;
            final confirmed = await showConfirmDialog(
              context,
              title: Text(context.l10n.teamDeleteStaffTitle),
              content: Text(context.l10n.teamDeleteStaffMessage),
              confirmLabel: context.l10n.actionConfirm,
              cancelLabel: context.l10n.actionCancel,
            );
            if (confirmed == true) {
              await ref
                  .read(allStaffProvider.notifier)
                  .deleteStaffApi(staff.id);
            }
          },
        );
      },
    );
  }
}
--- FILE: lib/features/staff/presentation/dialogs/add_exception_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:agenda_backend/core/widgets/app_bottom_sheet.dart';
import 'package:agenda_backend/core/widgets/labeled_form_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/availability_exception.dart';
import '../../../../core/models/staff_planning.dart' show StaffPlanning;
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/feedback_dialog.dart';
import '../../../../core/widgets/local_loading_overlay.dart';
import '../../../../core/services/staff_planning_selector.dart' show PlanningFound;
import '../../providers/availability_exceptions_provider.dart';
import '../../providers/staff_planning_provider.dart';
import '../../providers/staff_weekly_availability_provider.dart';

/// Mostra il dialog per creare o modificare un'eccezione alla disponibilit√†.
Future<void> showAddExceptionDialog(
  BuildContext context,
  WidgetRef ref, {
  AvailabilityException? initial,
  DateTime? date,
  TimeOfDay? time,
  required int staffId,
}) async {
  // Le eccezioni devono usare sempre lo stesso passo del planning staff.
  // Se il planning non √® disponibile, non apriamo il dialog.
  var plannings = ref.read(planningsForStaffProvider(staffId));
  if (plannings.isEmpty) {
    await ref.read(staffPlanningsProvider.notifier).loadPlanningsForStaff(staffId);
    if (!context.mounted) return;
    plannings = ref.read(planningsForStaffProvider(staffId));
  }
  if (plannings.isEmpty) {
    await FeedbackDialog.showError(
      context,
      title: context.l10n.planningListTitle,
      message: context.l10n.planningListEmpty,
    );
    return;
  }

  final formFactor = ref.read(formFactorProvider);
  final isDesktop = formFactor == AppFormFactor.desktop;

  final dialog = _AddExceptionDialog(
    initial: initial,
    initialDate: date,
    initialTime: time,
    staffId: staffId,
    presentation: isDesktop
        ? _ExceptionDialogPresentation.dialog
        : _ExceptionDialogPresentation.bottomSheet,
  );

  if (isDesktop) {
    await showDialog(context: context, builder: (_) => dialog);
  } else {
    await AppBottomSheet.show(
      context: context,
      useRootNavigator: true,
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 20),
      builder: (_) => dialog,
    );
  }
}

enum _ExceptionDialogPresentation { dialog, bottomSheet }

/// Modalit√† di selezione del periodo
enum _PeriodMode { single, range, duration }

class _AddExceptionDialog extends ConsumerStatefulWidget {
  const _AddExceptionDialog({
    this.initial,
    this.initialDate,
    this.initialTime,
    required this.staffId,
    required this.presentation,
  });

  final AvailabilityException? initial;
  final DateTime? initialDate;
  final TimeOfDay? initialTime;
  final int staffId;
  final _ExceptionDialogPresentation presentation;

  @override
  ConsumerState<_AddExceptionDialog> createState() =>
      _AddExceptionDialogState();
}

class _AddExceptionDialogState extends ConsumerState<_AddExceptionDialog> {
  // Modalit√† periodo (solo per nuove eccezioni)
  _PeriodMode _periodMode = _PeriodMode.single;

  // Date
  late DateTime _date; // Per singolo giorno
  late DateTime _startDate; // Per range/durata
  late DateTime _endDate; // Per range
  int _durationDays = 7; // Per durata

  // Orari
  late TimeOfDay _startTime;
  late TimeOfDay _endTime;
  late AvailabilityExceptionType _type;
  final _reasonController = TextEditingController();
  String? _timeError;
  String? _validationError;
  bool _isSaving = false;
  Map<DateTime, String> _lastSkippedReasons = {};

  @override
  void initState() {
    super.initState();

    if (widget.initial != null) {
      final exc = widget.initial!;
      _date = DateTime(exc.date.year, exc.date.month, exc.date.day);
      _startDate = _date;
      _endDate = _date;
      if (exc.isAllDay) {
        _startTime = const TimeOfDay(hour: 0, minute: 0);
        _endTime = const TimeOfDay(hour: 24, minute: 0);
      } else {
        _startTime = exc.startTime ?? const TimeOfDay(hour: 9, minute: 0);
        _endTime = exc.endTime ?? const TimeOfDay(hour: 18, minute: 0);
      }
      _type = exc.type;
      _reasonController.text = exc.reason ?? '';
    } else {
      _date = DateUtils.dateOnly(widget.initialDate ?? DateTime.now());
      _startDate = _date;
      _endDate = _date.add(const Duration(days: 6)); // Default 1 settimana
      _startTime = widget.initialTime ?? const TimeOfDay(hour: 9, minute: 0);
      _endTime = TimeOfDay(
        hour: _startTime.hour + 1,
        minute: _startTime.minute,
      );
      _type = AvailabilityExceptionType.unavailable;
    }
  }

  @override
  void dispose() {
    _reasonController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final isEdit = widget.initial != null;
    final isDialog = widget.presentation == _ExceptionDialogPresentation.dialog;

    final title = isEdit
        ? l10n.exceptionDialogTitleEdit
        : l10n.exceptionDialogTitleNew;

    final content = Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Tipo eccezione
        LabeledFormField(
          label: l10n.exceptionType,
          child: SegmentedButton<AvailabilityExceptionType>(
            segments: [
              ButtonSegment(
                value: AvailabilityExceptionType.unavailable,
                label: Text(l10n.exceptionTypeUnavailable),
                icon: const Icon(Icons.block, size: 18),
              ),
              ButtonSegment(
                value: AvailabilityExceptionType.available,
                label: Text(l10n.exceptionTypeAvailable),
                icon: const Icon(Icons.check_circle_outline, size: 18),
              ),
            ],
            selected: {_type},
            onSelectionChanged: (selected) {
              setState(() {
                _type = selected.first;
                _validationError = null;
              });
            },
          ),
        ),
        const SizedBox(height: 16),

        // Modalit√† periodo (solo per nuove eccezioni)
        if (!isEdit) ...[
          LabeledFormField(
            label: l10n.exceptionPeriodMode,
            child: SegmentedButton<_PeriodMode>(
              segments: [
                ButtonSegment(
                  value: _PeriodMode.single,
                  label: Text(l10n.exceptionPeriodSingle),
                ),
                ButtonSegment(
                  value: _PeriodMode.range,
                  label: Text(l10n.exceptionPeriodRange),
                ),
                ButtonSegment(
                  value: _PeriodMode.duration,
                  label: Text(l10n.exceptionPeriodDuration),
                ),
              ],
              selected: {_periodMode},
              onSelectionChanged: (selected) {
                setState(() {
                  _periodMode = selected.first;
                  _validationError = null;
                });
              },
            ),
          ),
          const SizedBox(height: 16),
        ],

        // Sezione date in base alla modalit√†
        if (isEdit || _periodMode == _PeriodMode.single) ...[
          // Data singola
          LabeledFormField(
            label: l10n.formDate,
            child: InkWell(
              onTap: () => _pickSingleDate(),
              child: InputDecorator(
                decoration: const InputDecoration(
                  border: OutlineInputBorder(),
                  isDense: true,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(_formatDate(_date)),
                    const Icon(Icons.calendar_today, size: 16),
                  ],
                ),
              ),
            ),
          ),
        ] else if (_periodMode == _PeriodMode.range) ...[
          // Range date: Da - A
          Row(
            children: [
              Expanded(
                child: LabeledFormField(
                  label: l10n.exceptionDateFrom,
                  child: InkWell(
                    onTap: () => _pickStartDate(),
                    child: InputDecorator(
                      decoration: const InputDecoration(
                        border: OutlineInputBorder(),
                        isDense: true,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_formatDate(_startDate)),
                          const Icon(Icons.calendar_today, size: 16),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: LabeledFormField(
                  label: l10n.exceptionDateTo,
                  child: InkWell(
                    onTap: () => _pickEndDate(),
                    child: InputDecorator(
                      decoration: const InputDecoration(
                        border: OutlineInputBorder(),
                        isDense: true,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_formatDate(_endDate)),
                          const Icon(Icons.calendar_today, size: 16),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
          // Info giorni totali
          Padding(
            padding: const EdgeInsets.only(top: 8),
            child: Text(
              l10n.exceptionDurationDays(_calculateDays()),
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.primary,
              ),
            ),
          ),
        ] else if (_periodMode == _PeriodMode.duration) ...[
          // Durata: Data inizio + numero giorni
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                flex: 2,
                child: LabeledFormField(
                  label: l10n.exceptionDateFrom,
                  child: InkWell(
                    onTap: () => _pickStartDate(),
                    child: InputDecorator(
                      decoration: const InputDecoration(
                        border: OutlineInputBorder(),
                        isDense: true,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_formatDate(_startDate)),
                          const Icon(Icons.calendar_today, size: 16),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: LabeledFormField(
                  label: l10n.exceptionDuration,
                  child: _DurationDropdown(
                    value: _durationDays,
                    onChanged: (v) => setState(() {
                      _durationDays = v;
                      _validationError = null;
                    }),
                  ),
                ),
              ),
            ],
          ),
          // Info data fine calcolata
          Padding(
            padding: const EdgeInsets.only(top: 8),
            child: Text(
              '‚Üí ${_formatDate(_startDate.add(Duration(days: _durationDays - 1)))}',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.primary,
              ),
            ),
          ),
        ],
        const SizedBox(height: 12),

        // Orari
        Row(
          children: [
            Expanded(
              child: LabeledFormField(
                label: l10n.exceptionStartTime,
                child: InkWell(
                  onTap: () => _pickTime(isStart: true),
                  child: InputDecorator(
                    decoration: InputDecoration(
                      border: const OutlineInputBorder(),
                      isDense: true,
                      enabledBorder: _timeError != null
                          ? OutlineInputBorder(
                              borderSide: BorderSide(
                                color: Theme.of(context).colorScheme.error,
                              ),
                            )
                          : null,
                    ),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Text(_formatTime(_startTime)),
                        const Icon(Icons.schedule, size: 16),
                      ],
                    ),
                  ),
                ),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: LabeledFormField(
                label: l10n.exceptionEndTime,
                child: InkWell(
                  onTap: () => _pickTime(isStart: false),
                  child: InputDecorator(
                    decoration: InputDecoration(
                      border: const OutlineInputBorder(),
                      isDense: true,
                      enabledBorder: _timeError != null
                          ? OutlineInputBorder(
                              borderSide: BorderSide(
                                color: Theme.of(context).colorScheme.error,
                              ),
                            )
                          : null,
                    ),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Text(_formatTime(_endTime)),
                        const Icon(Icons.schedule, size: 16),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
        if (_timeError != null)
          Padding(
            padding: const EdgeInsets.only(top: 6, left: 12),
            child: Text(
              _timeError!,
              style: TextStyle(
                color: Theme.of(context).colorScheme.error,
                fontSize: 12,
              ),
            ),
          ),
        if (_validationError != null)
          Padding(
            padding: const EdgeInsets.only(top: 6, left: 12),
            child: Text(
              _validationError!,
              style: TextStyle(
                color: Theme.of(context).colorScheme.error,
                fontSize: 12,
              ),
            ),
          ),
        const SizedBox(height: 12),

        // Motivo opzionale
        LabeledFormField(
          label: l10n.exceptionReason,
          child: TextField(
            controller: _reasonController,
            decoration: InputDecoration(
              hintText: l10n.exceptionReasonHint,
              border: const OutlineInputBorder(),
              isDense: true,
            ),
          ),
        ),
      ],
    );

    final actions = [
      if (isEdit)
        AppDangerButton(
          onPressed: _isSaving ? null : _onDelete,
          padding: AppButtonStyles.dialogButtonPadding,
          child: Text(l10n.actionDelete),
        ),
      AppOutlinedActionButton(
        onPressed: _isSaving ? null : () => Navigator.of(context).pop(),
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppFilledButton(
        onPressed: _isSaving ? null : _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionSave),
      ),
    ];

    final bottomActions = actions
        .map(
          (a) => SizedBox(width: AppButtonStyles.dialogButtonWidth, child: a),
        )
        .toList();

    if (isDialog) {
      return DismissibleDialog(
        child: Dialog(
          insetPadding: const EdgeInsets.symmetric(
            horizontal: 32,
            vertical: 24,
          ),
          child: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 500, maxWidth: 600),
            child: LocalLoadingOverlay(
              isLoading: _isSaving,
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Text(
                      title,
                      style: Theme.of(context).textTheme.headlineSmall,
                    ),
                    const SizedBox(height: 16),
                    Flexible(child: SingleChildScrollView(child: content)),
                    const SizedBox(height: 24),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        if (isEdit) ...[
                          bottomActions.first,
                          const Spacer(),
                          bottomActions[1],
                        ] else
                          bottomActions[0],
                        const SizedBox(width: 8),
                        bottomActions.last,
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      );
    }

    return SafeArea(
      top: false,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final isKeyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
          return LocalLoadingOverlay(
            isLoading: _isSaving,
            child: SizedBox(
              height: constraints.maxHeight,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Expanded(
                    child: SingleChildScrollView(
                      padding: EdgeInsets.zero,
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Padding(
                            padding: const EdgeInsets.only(bottom: 12),
                            child: Text(
                              title,
                              style: Theme.of(context).textTheme.titleLarge,
                            ),
                          ),
                          content,
                          const SizedBox(height: 24),
                          const SizedBox(height: AppSpacing.formRowSpacing),
                        ],
                      ),
                    ),
                  ),
                  if (!isKeyboardOpen) ...[
                    const AppDivider(),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(0, 12, 0, 0),
                      child: Align(
                        alignment: bottomActions.length == 3
                            ? Alignment.center
                            : Alignment.centerRight,
                        child: Wrap(
                          alignment: bottomActions.length == 3
                              ? WrapAlignment.center
                              : WrapAlignment.end,
                          spacing: 8,
                          runSpacing: 8,
                          children: bottomActions,
                        ),
                      ),
                    ),
                  ],
                  SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  String _formatTime(TimeOfDay time) {
    return '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';
  }

  String _formatDate(DateTime date) {
    return '${date.day.toString().padLeft(2, '0')}/${date.month.toString().padLeft(2, '0')}/${date.year}';
  }

  int _calculateDays() {
    return _endDate.difference(_startDate).inDays + 1;
  }

  int _planningSlotMinutesForDate(DateTime date) {
    final allPlannings = ref.read(planningsForStaffProvider(widget.staffId));
    if (allPlannings.isEmpty) {
      return StaffPlanning.defaultPlanningSlotMinutes;
    }
    final selector = ref.read(staffPlanningSelectorProvider);
    final lookup = selector.findPlanningForDate(
      staffId: widget.staffId,
      date: date,
      allPlannings: allPlannings,
    );
    if (lookup is PlanningFound) {
      final minutes = lookup.planning.planningSlotMinutes;
      return minutes > 0 ? minutes : StaffPlanning.defaultPlanningSlotMinutes;
    }
    return StaffPlanning.defaultPlanningSlotMinutes;
  }

  Future<void> _pickSingleDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _date,
      firstDate: DateTime.now().subtract(const Duration(days: 30)),
      lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
    );
    if (picked != null) {
      setState(() {
        _date = DateUtils.dateOnly(picked);
        _validationError = null;
      });
    }
  }

  Future<void> _pickStartDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _startDate,
      firstDate: DateTime.now().subtract(const Duration(days: 30)),
      lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
    );
    if (picked != null) {
      setState(() {
        _startDate = DateUtils.dateOnly(picked);
        _validationError = null;
        // Se la data di fine √® prima della data di inizio, aggiornala
        if (_endDate.isBefore(_startDate)) {
          _endDate = _startDate.add(Duration(days: _durationDays - 1));
        }
      });
    }
  }

  Future<void> _pickEndDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _endDate.isBefore(_startDate) ? _startDate : _endDate,
      firstDate: _startDate,
      lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
    );
    if (picked != null) {
      setState(() {
        _endDate = DateUtils.dateOnly(picked);
        _validationError = null;
      });
    }
  }

  Future<void> _pickTime({required bool isStart}) async {
    final referenceDate = widget.initial != null || _periodMode == _PeriodMode.single
        ? _date
        : _startDate;
    final step = _planningSlotMinutesForDate(referenceDate);
    final selected = await AppBottomSheet.show<TimeOfDay>(
      context: context,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      builder: (ctx) {
        final height = MediaQuery.of(ctx).size.height * 0.7;
        return SizedBox(
          height: height,
          child: _TimeGridPicker(
            initial: isStart ? _startTime : _endTime,
            stepMinutes: step,
          ),
        );
      },
    );
    if (selected != null) {
      setState(() {
        _timeError = null;
        _validationError = null;
        if (isStart) {
          _startTime = selected;
          // Se l'orario di fine √® prima dell'inizio, aggiustalo
          final startMinutes = _startTime.hour * 60 + _startTime.minute;
          final endMinutes = _endTime.hour * 60 + _endTime.minute;
          if (endMinutes <= startMinutes) {
            _endTime = TimeOfDay(
              hour: (_startTime.hour + 1).clamp(0, 23),
              minute: _startTime.minute,
            );
          }
        } else {
          _endTime = selected;
        }
      });
    }
  }

  List<DateTime>? _validatedDates() {
    final l10n = context.l10n;
    setState(() {
      _validationError = null;
      _timeError = null;
    });

    final startMinutes = _startTime.hour * 60 + _startTime.minute;
    final endMinutes = _endTime.hour * 60 + _endTime.minute;
    if (endMinutes <= startMinutes) {
      setState(() => _timeError = l10n.exceptionTimeError);
      return null;
    }

    final availabilityByStaff = ref
        .read(staffAvailabilityByStaffProvider)
        .value;
    if (availabilityByStaff == null) {
      if (widget.initial != null || _periodMode == _PeriodMode.single) {
        return <DateTime>[_date];
      }
      final DateTime startDate;
      final DateTime endDate;
      if (_periodMode == _PeriodMode.range) {
        startDate = _startDate;
        endDate = _endDate;
      } else {
        startDate = _startDate;
        endDate = _startDate.add(Duration(days: _durationDays - 1));
      }
      final dates = <DateTime>[];
      for (
        var d = startDate;
        !d.isAfter(endDate);
        d = d.add(const Duration(days: 1))
      ) {
        dates.add(d);
      }
      return dates;
    }

    Set<int> exceptionSlots(int minutesPerSlot) {
      final startMinutes = _startTime.hour * 60 + _startTime.minute;
      final endMinutes = _endTime.hour * 60 + _endTime.minute;
      final startSlot = startMinutes ~/ minutesPerSlot;
      final endSlot = endMinutes ~/ minutesPerSlot;
      return {for (int i = startSlot; i < endSlot; i++) i};
    }

    String? validateDate(DateTime date) {
      final minutesPerSlot = _planningSlotMinutesForDate(date);
      final baseSlots =
          availabilityByStaff[widget.staffId]?[date.weekday] ?? <int>{};
      final excSlots = exceptionSlots(minutesPerSlot);
      if (_type == AvailabilityExceptionType.unavailable) {
        if (baseSlots.isEmpty) {
          return l10n.exceptionUnavailableNoBase;
        }
        if (baseSlots.intersection(excSlots).isEmpty) {
          return l10n.exceptionUnavailableNoOverlap;
        }
      } else {
        if (excSlots.difference(baseSlots).isEmpty) {
          return l10n.exceptionAvailableNoEffect;
        }
      }
      return null;
    }

    if (widget.initial != null || _periodMode == _PeriodMode.single) {
      final error = validateDate(_date);
      if (error != null) {
        setState(() => _validationError = error);
        return null;
      }
      return <DateTime>[_date];
    }

    final DateTime startDate;
    final DateTime endDate;
    if (_periodMode == _PeriodMode.range) {
      startDate = _startDate;
      endDate = _endDate;
    } else {
      startDate = _startDate;
      endDate = _startDate.add(Duration(days: _durationDays - 1));
    }

    final validDates = <DateTime>[];
    final skippedReasons = <DateTime, String>{};
    String? firstError;
    for (
      var d = startDate;
      !d.isAfter(endDate);
      d = d.add(const Duration(days: 1))
    ) {
      final error = validateDate(d);
      if (error == null) {
        validDates.add(d);
      } else {
        firstError ??= error;
        skippedReasons[d] = error;
      }
    }

    if (validDates.isEmpty) {
      setState(() => _validationError = firstError);
      return null;
    }

    _lastSkippedReasons = {
      for (final entry in skippedReasons.entries)
        DateUtils.dateOnly(entry.key): entry.value,
    };
    return validDates;
  }

  Future<void> _onSave() async {
    final validDates = _validatedDates();
    if (validDates == null || validDates.isEmpty) return;

    setState(() => _isSaving = true);

    try {
      final notifier = ref.read(availabilityExceptionsProvider.notifier);
      final reason = _reasonController.text.trim();

      if (widget.initial != null) {
        // Modifica eccezione esistente (solo singolo giorno)
        final updated = widget.initial!.copyWith(
          date: validDates.first,
          startTime: _startTime,
          endTime: _endTime,
          type: _type,
          reason: reason.isEmpty ? null : reason,
          clearReason: reason.isEmpty,
        );
        await notifier.updateException(updated);
      } else {
        // Nuova eccezione - gestisci in base alla modalit√†
        if (_periodMode == _PeriodMode.single) {
          // Singolo giorno
          await notifier.addException(
            staffId: widget.staffId,
            date: validDates.first,
            startTime: _startTime,
            endTime: _endTime,
            type: _type,
            reason: reason.isEmpty ? null : reason,
          );
        } else {
          // Periodo (range o durata) - salva solo le date congruenti
          final DateTime startDate;
          final DateTime endDate;
          if (_periodMode == _PeriodMode.range) {
            startDate = _startDate;
            endDate = _endDate;
          } else {
            startDate = _startDate;
            endDate = _startDate.add(Duration(days: _durationDays - 1));
          }
          var totalDays = 0;
          final skippedDates = <DateTime>[];
          final skippedDetails = <String>[];
          for (
            var d = startDate;
            !d.isAfter(endDate);
            d = d.add(const Duration(days: 1))
          ) {
            totalDays++;
          }
          for (final d in validDates) {
            await notifier.addException(
              staffId: widget.staffId,
              date: d,
              startTime: _startTime,
              endTime: _endTime,
              type: _type,
              reason: reason.isEmpty ? null : reason,
            );
          }
          if (validDates.length < totalDays) {
            for (
              var d = startDate;
              !d.isAfter(endDate);
              d = d.add(const Duration(days: 1))
            ) {
              final isValid = validDates.any((v) => DateUtils.isSameDay(v, d));
              if (!isValid) {
                skippedDates.add(d);
              }
            }
          }
          if (mounted && skippedDates.isNotEmpty) {
            final locale = Localizations.localeOf(context).toLanguageTag();
            final formatter = DateFormat('d MMM', locale);
            for (final d in skippedDates) {
              final reason = _lastSkippedReasons[DateUtils.dateOnly(d)] ?? '';
              final dateLabel = formatter.format(d);
              if (reason.isEmpty) {
                skippedDetails.add(dateLabel);
              } else {
                skippedDetails.add('$dateLabel ‚Äî $reason');
              }
            }
            await showDialog<void>(
              context: context,
              builder: (ctx) => AlertDialog(
                title: Text(ctx.l10n.exceptionPartialSaveTitle),
                content: SizedBox(
                  width: 420,
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(ctx.l10n.exceptionPartialSaveMessage),
                      const SizedBox(height: 12),
                      ConstrainedBox(
                        constraints: const BoxConstraints(maxHeight: 240),
                        child: ListView.separated(
                          shrinkWrap: true,
                          itemCount: skippedDetails.length,
                          separatorBuilder: (_, __) =>
                              const SizedBox(height: 6),
                          itemBuilder: (context, index) => Text(
                            '‚Ä¢ ${skippedDetails[index]}',
                            style: Theme.of(context).textTheme.bodySmall,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
                actions: [
                  TextButton(
                    onPressed: () => Navigator.of(ctx).pop(),
                    child: Text(ctx.l10n.actionConfirm),
                  ),
                ],
              ),
            );
          }
        }
      }

      if (mounted) {
        Navigator.of(context).pop();
      }
    } finally {
      if (mounted) {
        setState(() => _isSaving = false);
      }
    }
  }

  Future<void> _onDelete() async {
    if (widget.initial == null) return;

    final l10n = context.l10n;
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.exceptionDeleteTitle),
        content: Text(l10n.exceptionDeleteMessage),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(false),
            child: Text(l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () => Navigator.of(ctx).pop(true),
            style: FilledButton.styleFrom(
              backgroundColor: Theme.of(ctx).colorScheme.error,
            ),
            child: Text(l10n.actionDelete),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await ref
          .read(availabilityExceptionsProvider.notifier)
          .deleteException(widget.staffId, widget.initial!.id);

      if (mounted) {
        Navigator.of(context).pop();
      }
    }
  }
}

/// Semplice picker griglia per selezionare un orario.
class _TimeGridPicker extends StatefulWidget {
  const _TimeGridPicker({required this.initial, required this.stepMinutes});

  final TimeOfDay initial;
  final int stepMinutes;

  @override
  State<_TimeGridPicker> createState() => _TimeGridPickerState();
}

class _TimeGridPickerState extends State<_TimeGridPicker> {
  late TimeOfDay _selected;
  late final ScrollController _scrollController;
  late final List<TimeOfDay?> _times;
  late final int _scrollToIndex;

  @override
  void initState() {
    super.initState();
    _selected = widget.initial;
    _scrollController = ScrollController();

    // Genera tutte le opzioni di orario con 4 colonne per riga
    _times = <TimeOfDay?>[];
    for (int h = 0; h < 24; h++) {
      for (int m = 0; m < 60; m += widget.stepMinutes) {
        _times.add(TimeOfDay(hour: h, minute: m));
      }
    }
    // Aggiungi 24:00 come opzione finale
    _times.add(const TimeOfDay(hour: 24, minute: 0));

    // Verifica se l'orario iniziale √® gi√† nella lista
    int exactIndex = _times.indexWhere(
      (t) =>
          t != null &&
          t.hour == widget.initial.hour &&
          t.minute == widget.initial.minute,
    );

    if (exactIndex >= 0) {
      // L'orario √® gi√† presente
      _scrollToIndex = exactIndex;
    } else {
      // L'orario non √® presente: inserisci una NUOVA RIGA con l'orario
      // nella colonna corretta e le altre colonne vuote
      final columnsPerRow = 60 ~/ widget.stepMinutes;
      final targetColumn = widget.initial.minute ~/ widget.stepMinutes;
      final baseIndex = (widget.initial.hour + 1) * columnsPerRow;

      // Crea la nuova riga con 4 elementi (solo uno valorizzato)
      final newRow = List<TimeOfDay?>.filled(columnsPerRow, null);
      newRow[targetColumn] = widget.initial;

      // Inserisci la nuova riga
      final insertIndex = baseIndex.clamp(0, _times.length);
      _times.insertAll(insertIndex, newRow);

      // L'indice dell'orario selezionato √® la posizione nella nuova riga
      _scrollToIndex = insertIndex + targetColumn;
    }

    // Scroll all'orario dopo il primo frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _scrollToSelected();
    });
  }

  void _scrollToSelected() {
    if (!_scrollController.hasClients) return;

    const crossAxisCount = 4;
    const mainAxisSpacing = 8.0;
    const childAspectRatio = 2.5;
    const padding = 8.0;

    // Usa la larghezza effettiva del context
    final screenWidth = MediaQuery.of(context).size.width;
    final availableWidth = screenWidth - padding * 2;
    final itemWidth =
        (availableWidth - (crossAxisCount - 1) * 8) / crossAxisCount;
    final itemHeight = itemWidth / childAspectRatio;
    final rowHeight = itemHeight + mainAxisSpacing;

    final targetRow = _scrollToIndex ~/ crossAxisCount;

    final viewportHeight = _scrollController.position.viewportDimension;
    // Offset aggiuntivo per centrare meglio (compensa header visivo)
    const headerOffset = 40.0;
    final targetOffset =
        (targetRow * rowHeight) -
        (viewportHeight / 2) +
        (rowHeight / 2) +
        headerOffset;

    final maxScroll = _scrollController.position.maxScrollExtent;
    final clampedOffset = targetOffset.clamp(0.0, maxScroll);

    _scrollController.animateTo(
      clampedOffset,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeOut,
    );
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                context.l10n.exceptionSelectTime,
                style: theme.textTheme.titleMedium,
              ),
              const SizedBox.shrink(),
            ],
          ),
        ),
        const AppDivider(),
        Expanded(
          child: GridView.builder(
            controller: _scrollController,
            padding: const EdgeInsets.all(8),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 4,
              childAspectRatio: 2.5,
              crossAxisSpacing: 8,
              mainAxisSpacing: 8,
            ),
            itemCount: _times.length,
            itemBuilder: (context, index) {
              final time = _times[index];
              // Se la cella √® vuota, mostra uno spazio vuoto
              if (time == null) {
                return const SizedBox.shrink();
              }
              final isSelected =
                  time.hour == _selected.hour &&
                  time.minute == _selected.minute;
              final label = time.hour == 24
                  ? '24:00'
                  : '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';

              return Material(
                color: isSelected
                    ? colorScheme.primaryContainer
                    : colorScheme.surfaceContainerHighest,
                borderRadius: BorderRadius.circular(8),
                child: InkWell(
                  onTap: () => Navigator.of(context).pop(time),
                  borderRadius: BorderRadius.circular(8),
                  child: Center(
                    child: Text(
                      label,
                      style: TextStyle(
                        fontWeight: isSelected
                            ? FontWeight.bold
                            : FontWeight.normal,
                        color: isSelected
                            ? colorScheme.onPrimaryContainer
                            : colorScheme.onSurface,
                      ),
                    ),
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }
}

/// Widget dropdown per selezionare la durata in giorni.
class _DurationDropdown extends StatelessWidget {
  const _DurationDropdown({required this.value, required this.onChanged});

  final int value;
  final ValueChanged<int> onChanged;

  static const List<int> _options = [
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    10,
    14,
    21,
    30,
    60,
    90,
  ];

  @override
  Widget build(BuildContext context) {
    return DropdownButtonFormField<int>(
      value: _options.contains(value) ? value : 7,
      decoration: const InputDecoration(
        border: OutlineInputBorder(),
        isDense: true,
        contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 12),
      ),
      items: _options.map((days) {
        return DropdownMenuItem(value: days, child: Text('$days'));
      }).toList(),
      onChanged: (v) {
        if (v != null) onChanged(v);
      },
    );
  }
}
--- FILE: lib/features/staff/presentation/dialogs/location_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../app/theme/app_spacing.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/location.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/labeled_form_field.dart';
import '../../../../core/widgets/local_loading_overlay.dart';
import '../../../agenda/providers/business_providers.dart';
import '../../../agenda/providers/location_providers.dart';

Future<void> showLocationDialog(
  BuildContext context,
  WidgetRef ref, {
  Location? initial,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final isDesktop = formFactor == AppFormFactor.desktop;

  final dialog = _LocationDialog(initial: initial);

  if (isDesktop) {
    await showDialog(context: context, builder: (_) => dialog);
  } else {
    await AppBottomSheet.show(
      context: context,
      builder: (_) => dialog,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      heightFactor: AppBottomSheet.defaultHeightFactor,
    );
  }
}

class _LocationDialog extends ConsumerStatefulWidget {
  const _LocationDialog({this.initial});

  final Location? initial;

  bool get isEditing => initial != null;

  @override
  ConsumerState<_LocationDialog> createState() => _LocationDialogState();
}

class _LocationDialogState extends ConsumerState<_LocationDialog> {
  static const int _neverCancellationHours = 100000;
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _addressController = TextEditingController();
  final _emailController = TextEditingController();
  bool _isActive = true;
  int _minBookingNoticeHours = 1;
  int _maxBookingAdvanceDays = 90;
  int? _cancellationHours;
  bool _allowCustomerChooseStaff = true;

  // Smart Slot Display Settings
  int _onlineBookingSlotIntervalMinutes = 15;
  String _slotDisplayMode = 'all';
  int _minGapMinutes = 30;

  // Opzioni disponibili per i dropdown
  static const _noticeHoursOptions = [1, 2, 4, 6, 12, 24, 48];
  static const _advanceDaysOptions = [7, 14, 30, 60, 90, 180, 365];
  static const List<int?> _cancellationHoursOptions = [
    null,
    0,
    1,
    2,
    4,
    8,
    12,
    24,
    48,
    72,
    96,
    120,
    168,
    _neverCancellationHours,
  ];

  String _formatCancellationPolicyValue(BuildContext context, int hours) {
    final l10n = context.l10n;
    if (hours == 0) {
      return l10n.teamLocationCancellationHoursAlways;
    }
    if (hours == _neverCancellationHours) {
      return l10n.teamLocationCancellationHoursNever;
    }
    if (hours >= 24 && hours % 24 == 0) {
      return l10n.teamLocationDays(hours ~/ 24);
    }
    return l10n.teamLocationHours(hours);
  }

  Widget _buildComboText(String text, {bool selected = false}) {
    return Tooltip(
      message: text,
      child: Text(
        text,
        maxLines: selected ? 1 : 2,
        overflow: TextOverflow.ellipsis,
      ),
    );
  }
  static final List<int> _onlineBookingSlotIntervalOptions = [
    for (int minutes = 5; minutes <= 120; minutes += 5) minutes,
  ];
  static final List<int> _minGapOptions = [
    for (int minutes = 5; minutes <= 120; minutes += 5) minutes,
  ];

  @override
  void initState() {
    super.initState();
    if (widget.initial != null) {
      _nameController.text = widget.initial!.name;
      _addressController.text = widget.initial!.address ?? '';
      _emailController.text = widget.initial!.email ?? '';
      _isActive = widget.initial!.isActive;
      _minBookingNoticeHours = widget.initial!.minBookingNoticeHours;
      _maxBookingAdvanceDays = widget.initial!.maxBookingAdvanceDays;
      _cancellationHours = widget.initial!.cancellationHours;
      _allowCustomerChooseStaff = widget.initial!.allowCustomerChooseStaff;
      _onlineBookingSlotIntervalMinutes =
          widget.initial!.onlineBookingSlotIntervalMinutes;
      _slotDisplayMode = widget.initial!.slotDisplayMode;
      _minGapMinutes = widget.initial!.minGapMinutes;
    } else {
      // Pre-popola con il nome del business per nuove sedi
      final businessName = ref.read(currentBusinessProvider).name;
      _nameController.text = businessName;
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _addressController.dispose();
    _emailController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final title = widget.isEditing
        ? l10n.teamEditLocationTitle
        : l10n.teamNewLocationTitle;

    final actions = [
      AppOutlinedActionButton(
        onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppFilledButton(
        onPressed: _isLoading ? null : _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionSave),
      ),
    ];

    final bottomActions = actions
        .map(
          (a) => SizedBox(width: AppButtonStyles.dialogButtonWidth, child: a),
        )
        .toList();

    final nameField = LabeledFormField(
      label: l10n.teamLocationNameLabel,
      child: TextFormField(
        controller: _nameController,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        validator: (v) =>
            v == null || v.trim().isEmpty ? l10n.validationRequired : null,
      ),
    );

    final addressField = LabeledFormField(
      label: l10n.teamLocationAddressLabel,
      child: TextFormField(
        controller: _addressController,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
      ),
    );

    final emailField = LabeledFormField(
      label: l10n.teamLocationEmailLabel,
      child: TextFormField(
        controller: _emailController,
        keyboardType: TextInputType.emailAddress,
        decoration: InputDecoration(
          border: const OutlineInputBorder(),
          isDense: true,
          hintText: l10n.teamLocationEmailHint,
        ),
        validator: (v) {
          if (v == null || v.trim().isEmpty) return null; // Optional
          final emailRegex = RegExp(r'^[^@]+@[^@]+\.[^@]+');
          if (!emailRegex.hasMatch(v.trim())) {
            return l10n.validationInvalidEmail;
          }
          return null;
        },
      ),
    );

    final content = Form(
      key: _formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        mainAxisSize: MainAxisSize.min,
        children: [
          nameField,
          const SizedBox(height: AppSpacing.formRowSpacing),
          addressField,
          const SizedBox(height: AppSpacing.formRowSpacing),
          emailField,
          const SizedBox(height: AppSpacing.formRowSpacing),
          SwitchListTile(
            title: Text(l10n.teamLocationIsActiveLabel),
            subtitle: Text(
              l10n.teamLocationIsActiveHint,
              style: Theme.of(context).textTheme.bodySmall,
            ),
            value: _isActive,
            onChanged: (v) => setState(() => _isActive = v),
            contentPadding: EdgeInsets.zero,
          ),
          const SizedBox(height: AppSpacing.formRowSpacing),
          // Sezione Limiti Prenotazione Online
          Text(
            l10n.teamLocationBookingLimitsSection,
            style: Theme.of(
              context,
            ).textTheme.titleSmall?.copyWith(fontWeight: FontWeight.w600),
          ),
          const SizedBox(height: 12),
          SwitchListTile(
            title: Text(l10n.teamLocationAllowCustomerChooseStaffLabel),
            subtitle: Text(
              l10n.teamLocationAllowCustomerChooseStaffHint,
              style: Theme.of(context).textTheme.bodySmall,
            ),
            value: _allowCustomerChooseStaff,
            onChanged: (v) => setState(() => _allowCustomerChooseStaff = v),
            contentPadding: EdgeInsets.zero,
          ),
          const SizedBox(height: AppSpacing.formRowSpacing),
          // Preavviso minimo
          LabeledFormField(
            label: l10n.teamLocationMinBookingNoticeLabel,
            child: DropdownButtonFormField<int>(
              value: _minBookingNoticeHours,
              decoration: InputDecoration(
                border: const OutlineInputBorder(),
                isDense: true,
                helperText: l10n.teamLocationMinBookingNoticeHint,
              ),
              items: _noticeHoursOptions.map((hours) {
                return DropdownMenuItem(
                  value: hours,
                  child: Text(l10n.teamLocationHours(hours)),
                );
              }).toList(),
              onChanged: (v) {
                if (v != null) setState(() => _minBookingNoticeHours = v);
              },
            ),
          ),
          const SizedBox(height: AppSpacing.formRowSpacing),
          // Anticipo massimo
          LabeledFormField(
            label: l10n.teamLocationMaxBookingAdvanceLabel,
            child: DropdownButtonFormField<int>(
              value: _maxBookingAdvanceDays,
              decoration: InputDecoration(
                border: const OutlineInputBorder(),
                isDense: true,
                helperText: l10n.teamLocationMaxBookingAdvanceHint,
              ),
              items: _advanceDaysOptions.map((days) {
                return DropdownMenuItem(
                  value: days,
                  child: Text(l10n.teamLocationDays(days)),
                );
              }).toList(),
              onChanged: (v) {
                if (v != null) setState(() => _maxBookingAdvanceDays = v);
              },
            ),
          ),
          const SizedBox(height: AppSpacing.formRowSpacing),
          LabeledFormField(
            label: l10n.teamLocationCancellationHoursLabel,
            child: DropdownButtonFormField<int?>(
              value: _cancellationHours,
              isExpanded: true,
              decoration: InputDecoration(
                border: const OutlineInputBorder(),
                isDense: true,
                helperText: l10n.teamLocationCancellationHoursHint,
              ),
              items: _cancellationHoursOptions.map((hours) {
                String label;
                if (hours == null) {
                  final businessCancellationHours = ref
                      .read(currentBusinessProvider)
                      .cancellationHours;
                  if (businessCancellationHours != null) {
                    final businessPolicy = _formatCancellationPolicyValue(
                      context,
                      businessCancellationHours,
                    );
                    label = l10n.teamLocationCancellationHoursUseBusinessWithValue(
                      businessPolicy,
                    );
                  } else {
                    label = l10n.teamLocationCancellationHoursUseBusiness;
                  }
                } else if (hours == 0) {
                  label = l10n.teamLocationCancellationHoursAlways;
                } else if (hours == _neverCancellationHours) {
                  label = l10n.teamLocationCancellationHoursNever;
                } else if (hours >= 24 && hours % 24 == 0) {
                  label = l10n.teamLocationDays(hours ~/ 24);
                } else {
                  label = l10n.teamLocationHours(hours);
                }
                return DropdownMenuItem<int?>(
                  value: hours,
                  child: _buildComboText(label),
                );
              }).toList(),
              selectedItemBuilder: (context) {
                return _cancellationHoursOptions.map((hours) {
                  String label;
                  if (hours == null) {
                    final businessCancellationHours = ref
                        .read(currentBusinessProvider)
                        .cancellationHours;
                    if (businessCancellationHours != null) {
                      final businessPolicy = _formatCancellationPolicyValue(
                        context,
                        businessCancellationHours,
                      );
                      label = l10n
                          .teamLocationCancellationHoursUseBusinessWithValue(
                            businessPolicy,
                          );
                    } else {
                      label = l10n.teamLocationCancellationHoursUseBusiness;
                    }
                  } else if (hours == 0) {
                    label = l10n.teamLocationCancellationHoursAlways;
                  } else if (hours == _neverCancellationHours) {
                    label = l10n.teamLocationCancellationHoursNever;
                  } else if (hours >= 24 && hours % 24 == 0) {
                    label = l10n.teamLocationDays(hours ~/ 24);
                  } else {
                    label = l10n.teamLocationHours(hours);
                  }
                  return Align(
                    alignment: Alignment.centerLeft,
                    child: _buildComboText(label, selected: true),
                  );
                }).toList();
              },
              onChanged: (v) {
                setState(() => _cancellationHours = v);
              },
            ),
          ),
          const SizedBox(height: AppSpacing.formRowSpacing * 2),
          // Sezione Smart Slot Display
          Text(
            l10n.teamLocationSmartSlotSection,
            style: Theme.of(
              context,
            ).textTheme.titleSmall?.copyWith(fontWeight: FontWeight.w600),
          ),
          const SizedBox(height: 8),
          Text(
            l10n.teamLocationSmartSlotDescription,
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: Theme.of(
                context,
              ).colorScheme.onSurface.withValues(alpha: 0.7),
            ),
          ),
          const SizedBox(height: 12),
          // Intervallo slot
          LabeledFormField(
            label: l10n.teamLocationSlotIntervalLabel,
            child: DropdownButtonFormField<int>(
              value: _onlineBookingSlotIntervalMinutes,
              decoration: InputDecoration(
                border: const OutlineInputBorder(),
                isDense: true,
                helperText: l10n.teamLocationSlotIntervalHint,
              ),
              items: _onlineBookingSlotIntervalOptions.map((minutes) {
                return DropdownMenuItem(
                  value: minutes,
                  child: Text(l10n.teamLocationMinutes(minutes)),
                );
              }).toList(),
              onChanged: (v) {
                if (v != null) {
                  setState(() => _onlineBookingSlotIntervalMinutes = v);
                }
              },
            ),
          ),
          const SizedBox(height: AppSpacing.formRowSpacing),
          // Modalit√† visualizzazione slot
          LabeledFormField(
            label: l10n.teamLocationSlotDisplayModeLabel,
            child: DropdownButtonFormField<String>(
              value: _slotDisplayMode,
              decoration: InputDecoration(
                border: const OutlineInputBorder(),
                isDense: true,
                helperText: _slotDisplayMode == 'all'
                    ? l10n.teamLocationSlotDisplayModeAllHint
                    : l10n.teamLocationSlotDisplayModeMinGapHint,
              ),
              items: [
                DropdownMenuItem(
                  value: 'all',
                  child: Text(l10n.teamLocationSlotDisplayModeAll),
                ),
                DropdownMenuItem(
                  value: 'min_gap',
                  child: Text(l10n.teamLocationSlotDisplayModeMinGap),
                ),
              ],
              onChanged: (v) {
                if (v != null) setState(() => _slotDisplayMode = v);
              },
            ),
          ),
          // Gap minimo (visibile solo se min_gap mode)
          if (_slotDisplayMode == 'min_gap') ...[
            const SizedBox(height: AppSpacing.formRowSpacing),
            LabeledFormField(
              label: l10n.teamLocationMinGapLabel,
              child: DropdownButtonFormField<int>(
                value: _minGapMinutes,
                decoration: InputDecoration(
                  border: const OutlineInputBorder(),
                  isDense: true,
                  helperText: l10n.teamLocationMinGapHint,
                ),
                items: _minGapOptions.map((minutes) {
                  return DropdownMenuItem(
                    value: minutes,
                    child: Text(l10n.teamLocationMinutes(minutes)),
                  );
                }).toList(),
                onChanged: (v) {
                  if (v != null) setState(() => _minGapMinutes = v);
                },
              ),
            ),
          ],
          if (_error != null) ...[
            const SizedBox(height: AppSpacing.formRowSpacing),
            Text(
              _error!,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.error,
              ),
            ),
          ],
        ],
      ),
    );

    if (ref.read(formFactorProvider) == AppFormFactor.desktop) {
      return Dialog(
        insetPadding: const EdgeInsets.symmetric(horizontal: 32, vertical: 24),
        child: ConstrainedBox(
          constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
          child: LocalLoadingOverlay(
            isLoading: _isLoading,
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text(title, style: Theme.of(context).textTheme.headlineSmall),
                  const SizedBox(height: 16),
                  Flexible(child: SingleChildScrollView(child: content)),
                  const SizedBox(height: 24),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      for (int i = 0; i < bottomActions.length; i++) ...[
                        if (i > 0) const SizedBox(width: 8),
                        bottomActions[i],
                      ],
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      );
    }

    return SafeArea(
      top: false,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final isKeyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
          return LocalLoadingOverlay(
            isLoading: _isLoading,
            child: SizedBox(
              height: constraints.maxHeight,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Expanded(
                    child: SingleChildScrollView(
                      child: Padding(
                        padding: EdgeInsets.only(
                          left: 16,
                          right: 16,
                          top: 12,
                          bottom: 0,
                        ),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Padding(
                              padding: const EdgeInsets.only(bottom: 12),
                              child: Text(
                                title,
                                style: Theme.of(context).textTheme.titleLarge,
                              ),
                            ),
                            content,
                            const SizedBox(height: 24),
                          ],
                        ),
                      ),
                    ),
                  ),
                  if (!isKeyboardOpen) ...[
                    const AppDivider(),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                      child: Align(
                        alignment: bottomActions.length == 3
                            ? Alignment.center
                            : Alignment.centerRight,
                        child: Wrap(
                          alignment: bottomActions.length == 3
                              ? WrapAlignment.center
                              : WrapAlignment.end,
                          spacing: 8,
                          runSpacing: 8,
                          children: bottomActions,
                        ),
                      ),
                    ),
                  ],
                  SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  bool _isLoading = false;
  String? _error;

  Future<void> _onSave() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _error = null;
    });

    final notifier = ref.read(locationsProvider.notifier);
    final name = _nameController.text.trim();
    final address = _addressController.text.trim();
    final email = _emailController.text.trim();

    try {
      if (widget.initial != null) {
        // Aggiorna location esistente
        await notifier.updateLocation(
          locationId: widget.initial!.id,
          name: name,
          address: address.isEmpty ? null : address,
          email: email.isEmpty ? null : email,
          isActive: _isActive,
          minBookingNoticeHours: _minBookingNoticeHours,
          maxBookingAdvanceDays: _maxBookingAdvanceDays,
          cancellationHours: _cancellationHours,
          allowCustomerChooseStaff: _allowCustomerChooseStaff,
          onlineBookingSlotIntervalMinutes:
              _onlineBookingSlotIntervalMinutes,
          slotDisplayMode: _slotDisplayMode,
          minGapMinutes: _minGapMinutes,
        );
      } else {
        // Crea nuova location
        await notifier.create(
          name: name,
          address: address.isEmpty ? null : address,
          email: email.isEmpty ? null : email,
          isActive: _isActive,
          minBookingNoticeHours: _minBookingNoticeHours,
          maxBookingAdvanceDays: _maxBookingAdvanceDays,
          cancellationHours: _cancellationHours,
          allowCustomerChooseStaff: _allowCustomerChooseStaff,
        );
      }
      if (mounted) Navigator.of(context).pop();
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }
}
--- FILE: lib/features/staff/presentation/dialogs/planning_editor_dialog.dart ---
/*
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üéØ Planning Editor Dialog
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Dialog COMPLETO per creare/modificare un planning:
- Tipo (settimanale/bisettimanale)
- Date validit√† (da/a)
- Griglia orari settimanali
- Per biweekly: tab A e B

*/

import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/staff_planning.dart';
import 'package:agenda_backend/core/widgets/app_bottom_sheet.dart';
import 'package:agenda_backend/core/widgets/app_buttons.dart';
import 'package:agenda_backend/core/widgets/local_loading_overlay.dart';
import 'package:agenda_backend/features/staff/presentation/widgets/weekly_schedule_editor.dart';
import 'package:agenda_backend/features/staff/providers/staff_planning_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

/// Mostra il dialog editor planning.
/// Ritorna true se salvato, false/null se annullato.
/// [existingPlannings] serve per calcolare la data inizio di un nuovo planning.
Future<bool?> showPlanningEditorDialog(
  BuildContext context,
  WidgetRef ref, {
  required int staffId,
  StaffPlanning? planning,
  List<StaffPlanning> existingPlannings = const [],
}) async {
  final formFactor = ref.read(formFactorProvider);
  final isDesktop = formFactor == AppFormFactor.desktop;

  final content = _PlanningEditorContent(
    staffId: staffId,
    planning: planning,
    isDesktop: isDesktop,
    existingPlannings: existingPlannings,
  );

  if (isDesktop) {
    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => content,
    );
  } else {
    return AppBottomSheet.show<bool>(
      context: context,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      builder: (_) => content,
      heightFactor: AppBottomSheet.defaultHeightFactor,
    );
  }
}

class _PlanningEditorContent extends ConsumerStatefulWidget {
  const _PlanningEditorContent({
    required this.staffId,
    this.planning,
    required this.isDesktop,
    this.existingPlannings = const [],
  });

  final int staffId;
  final StaffPlanning? planning;
  final bool isDesktop;
  final List<StaffPlanning> existingPlannings;

  bool get isEditing => planning != null;

  @override
  ConsumerState<_PlanningEditorContent> createState() =>
      _PlanningEditorContentState();
}

class _PlanningEditorContentState extends ConsumerState<_PlanningEditorContent>
    with SingleTickerProviderStateMixin {
  late StaffPlanningType _type;
  late DateTime _validFrom;
  DateTime? _validTo;
  bool _isOpenEnded = true;
  bool _isSaving = false;
  bool _isDeleting = false;
  String? _error;

  /// Passo di visualizzazione per il picker orari (solo UI, non persiste).
  int _displayStepMinutes = 15;

  // Orari per template A e B
  late Map<int, Set<int>> _slotsA;
  late Map<int, Set<int>> _slotsB;

  // Tab controller per biweekly
  TabController? _tabController;
  WeekLabel _currentTab = WeekLabel.a;

  @override
  void initState() {
    super.initState();

    // Inizializza valori da planning esistente o default
    if (widget.planning != null) {
      final p = widget.planning!;
      _type = p.type;
      _validFrom = p.validFrom;
      _validTo = p.validTo;
      _isOpenEnded = p.validTo == null;

      // Carica slot dai template
      _slotsA = _loadSlotsFromTemplate(p.templateA);
      _slotsB = _loadSlotsFromTemplate(p.templateB);
    } else {
      _type = StaffPlanningType.weekly;
      // Data inizio = data fine planning attivo + 1 giorno, altrimenti oggi
      _validFrom = _calculateDefaultStartDate();
      _validTo = null;
      _isOpenEnded = true;
      _slotsA = {for (int d = 1; d <= 7; d++) d: <int>{}};
      _slotsB = {for (int d = 1; d <= 7; d++) d: <int>{}};
    }

    _setupTabController();
  }

  /// Calcola la data inizio default per un nuovo planning:
  /// - Se esiste un planning attivo con validTo ‚Üí validTo + 1 giorno
  /// - Altrimenti ‚Üí data attuale
  DateTime _calculateDefaultStartDate() {
    final today = DateTime.now();

    // Cerca il planning attivo (che include oggi) con validTo definita
    for (final p in widget.existingPlannings) {
      if (p.isValidForDate(today) && p.validTo != null) {
        return p.validTo!.add(const Duration(days: 1));
      }
    }

    // Se non c'√® planning attivo con fine definita, cerca quello pi√π recente
    DateTime? latestEnd;
    for (final p in widget.existingPlannings) {
      if (p.validTo != null &&
          (latestEnd == null || p.validTo!.isAfter(latestEnd))) {
        latestEnd = p.validTo;
      }
    }

    if (latestEnd != null && latestEnd.isAfter(today)) {
      return latestEnd.add(const Duration(days: 1));
    }

    return today;
  }

  void _setupTabController() {
    _tabController?.dispose();
    if (_type == StaffPlanningType.biweekly) {
      _tabController = TabController(length: 2, vsync: this);
      _tabController!.addListener(() {
        if (!_tabController!.indexIsChanging) {
          setState(() {
            _currentTab = _tabController!.index == 0
                ? WeekLabel.a
                : WeekLabel.b;
          });
        }
      });
    } else {
      _tabController = null;
    }
  }

  Map<int, Set<int>> _loadSlotsFromTemplate(
    StaffPlanningWeekTemplate? template,
  ) {
    if (template == null) {
      return {for (int d = 1; d <= 7; d++) d: <int>{}};
    }
    return {
      for (int d = 1; d <= 7; d++) d: Set<int>.from(template.daySlots[d] ?? {}),
    };
  }

  @override
  void dispose() {
    _tabController?.dispose();
    super.dispose();
  }

  void _onTypeChanged(StaffPlanningType? newType) {
    if (newType == null || newType == _type) return;
    setState(() {
      _type = newType;
      _setupTabController();
    });
  }

  Future<void> _pickDate({required bool isStart}) async {
    final initial = isStart ? _validFrom : (_validTo ?? DateTime.now());
    final first = isStart ? DateTime(2020) : _validFrom;
    final last = DateTime(2030);

    final picked = await showDialog<DateTime>(
      context: context,
      builder: (context) {
        return Dialog(
          child: CalendarDatePicker(
            initialDate: initial,
            firstDate: first,
            lastDate: last,
            onDateChanged: (value) => Navigator.of(context).pop(value),
          ),
        );
      },
    );

    if (picked != null) {
      setState(() {
        if (isStart) {
          _validFrom = picked;
          // Se fine √® prima di inizio, aggiustala
          if (_validTo != null && _validTo!.isBefore(_validFrom)) {
            _validTo = _validFrom;
          }
        } else {
          _validTo = picked;
        }
      });
    }
  }

  void _onSlotsChanged(Map<int, Set<int>> newSlots) {
    setState(() {
      if (_type == StaffPlanningType.weekly || _currentTab == WeekLabel.a) {
        _slotsA = newSlots;
      } else {
        _slotsB = newSlots;
      }
    });
  }

  Future<void> _save() async {
    setState(() {
      _isSaving = true;
      _error = null;
    });

    try {
      final notifier = ref.read(staffPlanningsProvider.notifier);
      final minutesPerSlot = StaffPlanning.planningStepMinutes;

      // Unifica slot contigui
      final mergedSlotsA = _mergeSlots(_slotsA, minutesPerSlot);
      final mergedSlotsB = _mergeSlots(_slotsB, minutesPerSlot);

      // Crea template
      final templates = <StaffPlanningWeekTemplate>[
        StaffPlanningWeekTemplate(
          id: widget.planning?.templateA?.id ?? 0,
          staffPlanningId: widget.planning?.id ?? 0,
          weekLabel: WeekLabel.a,
          daySlots: {
            for (final e in mergedSlotsA.entries) e.key: Set<int>.from(e.value),
          },
        ),
        if (_type == StaffPlanningType.biweekly)
          StaffPlanningWeekTemplate(
            id: widget.planning?.templateB?.id ?? 0,
            staffPlanningId: widget.planning?.id ?? 0,
            weekLabel: WeekLabel.b,
            daySlots: {
              for (final e in mergedSlotsB.entries)
                e.key: Set<int>.from(e.value),
            },
          ),
      ];

      final planning = StaffPlanning(
        id: widget.planning?.id ?? 0,
        staffId: widget.staffId,
        type: _type,
        validFrom: _validFrom,
        validTo: _isOpenEnded ? null : _validTo,
        templates: templates,
        createdAt: widget.planning?.createdAt ?? DateTime.now(),
      );

      if (widget.isEditing) {
        final result = await notifier.updatePlanning(
          planning,
          widget.planning!,
        );
        if (!result.isValid) {
          setState(() => _error = _translateError(result.errors.join('\n')));
          return;
        }
      } else {
        final result = await notifier.addPlanning(planning);
        if (!result.isValid) {
          setState(() => _error = _translateError(result.errors.join('\n')));
          return;
        }
      }

      if (mounted) {
        Navigator.of(context).pop(true);
      }
    } catch (e) {
      setState(() => _error = e.toString());
    } finally {
      if (mounted) {
        setState(() => _isSaving = false);
      }
    }
  }

  Map<int, Set<int>> _mergeSlots(Map<int, Set<int>> slots, int minutesPerSlot) {
    final schedule = WeeklySchedule.fromSlots(
      slots,
      minutesPerSlot: minutesPerSlot,
    );
    final merged = schedule.mergeContiguousShifts();
    return merged.toSlots(minutesPerSlot: minutesPerSlot);
  }

  String _translateError(String error) {
    if (error.contains('overlap_error') || error.contains('Sovrapposizione')) {
      return 'Esiste gi√† un planning attivo per questo periodo. '
          'Modifica o elimina il planning esistente prima di crearne uno nuovo.';
    }
    if (error.contains('api_error')) {
      return 'Errore di comunicazione con il server. Riprova.';
    }
    return error;
  }

  Future<void> _delete() async {
    if (widget.planning == null) return;

    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(context.l10n.planningDeleteTitle),
        content: Text(context.l10n.planningDeleteConfirm),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx, false),
            child: Text(context.l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () => Navigator.pop(ctx, true),
            style: FilledButton.styleFrom(
              backgroundColor: Theme.of(context).colorScheme.error,
            ),
            child: Text(context.l10n.actionDelete),
          ),
        ],
      ),
    );

    if (confirmed != true) return;

    setState(() {
      _isDeleting = true;
      _error = null;
    });

    try {
      await ref
          .read(staffPlanningsProvider.notifier)
          .deletePlanning(widget.staffId, widget.planning!.id);

      if (mounted) {
        Navigator.of(context).pop(true);
      }
    } catch (e) {
      setState(() => _error = e.toString());
    } finally {
      if (mounted) {
        setState(() => _isDeleting = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final dateFormat = DateFormat('d MMM yyyy', 'it');
    final isBusy = _isSaving || _isDeleting;

    final currentSlots = _currentTab == WeekLabel.a ? _slotsA : _slotsB;
    final title = widget.isEditing
        ? l10n.planningEditTitle
        : l10n.planningCreateTitle;

    final horizontalPadding = widget.isDesktop ? 24.0 : 16.0;

    // Azioni footer
    final actions = <Widget>[
      // Elimina (solo in modifica)
      if (widget.isEditing)
        TextButton(
          onPressed: _isDeleting || _isSaving ? null : _delete,
          style: TextButton.styleFrom(foregroundColor: theme.colorScheme.error),
          child: Text(l10n.actionDelete),
        ),
      // Annulla
      TextButton(
        onPressed: _isSaving || _isDeleting
            ? null
            : () => Navigator.of(context).pop(false),
        child: Text(l10n.actionCancel),
      ),
      // Salva (senza icona)
      AppFilledButton(
        onPressed: _isSaving || _isDeleting ? null : _save,
        child: Text(l10n.actionSave),
      ),
    ];

    final content = Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // ‚îÄ‚îÄ Errore ‚îÄ‚îÄ
        if (_error != null)
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(12),
            color: theme.colorScheme.errorContainer,
            child: Row(
              children: [
                Icon(
                  Icons.error_outline,
                  color: theme.colorScheme.onErrorContainer,
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    _error!,
                    style: TextStyle(color: theme.colorScheme.onErrorContainer),
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.close),
                  onPressed: () => setState(() => _error = null),
                  color: theme.colorScheme.onErrorContainer,
                  iconSize: 18,
                ),
              ],
            ),
          ),

        Expanded(
          child: SingleChildScrollView(
            padding: EdgeInsets.symmetric(horizontal: horizontalPadding),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const SizedBox(height: AppSpacing.formFirstRowSpacing),

                // ‚îÄ‚îÄ Tipo Planning ‚îÄ‚îÄ
                Text(
                  l10n.planningType,
                  style: theme.textTheme.titleSmall?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 8),
                SegmentedButton<StaffPlanningType>(
                  segments: [
                    ButtonSegment(
                      value: StaffPlanningType.weekly,
                      label: Text(l10n.planningTypeWeekly),
                      icon: const Icon(Icons.view_week_outlined),
                    ),
                    ButtonSegment(
                      value: StaffPlanningType.biweekly,
                      label: Text(l10n.planningTypeBiweekly),
                      icon: const Icon(Icons.date_range_outlined),
                    ),
                  ],
                  selected: {_type},
                  onSelectionChanged: (set) => _onTypeChanged(set.first),
                ),

                const SizedBox(height: AppSpacing.formRowSpacing),

                // ‚îÄ‚îÄ Date Validit√† ‚îÄ‚îÄ
                Text(
                  l10n.planningValidFrom,
                  style: theme.textTheme.titleSmall?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 8),
                // Data inizio
                InkWell(
                  onTap: () => _pickDate(isStart: true),
                  borderRadius: BorderRadius.circular(8),
                  child: InputDecorator(
                    decoration: const InputDecoration(
                      border: OutlineInputBorder(),
                      isDense: true,
                      contentPadding: EdgeInsets.symmetric(
                        horizontal: 12,
                        vertical: 12,
                      ),
                    ),
                    child: Row(
                      children: [
                        const Icon(Icons.calendar_today, size: 18),
                        const SizedBox(width: 8),
                        Text(dateFormat.format(_validFrom)),
                      ],
                    ),
                  ),
                ),

                const SizedBox(height: AppSpacing.formRowSpacing),

                // Data fine
                Text(
                  l10n.planningValidTo,
                  style: theme.textTheme.titleSmall?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 8),
                Row(
                  children: [
                    Expanded(
                      child: _isOpenEnded
                          ? InputDecorator(
                              decoration: InputDecoration(
                                border: const OutlineInputBorder(),
                                isDense: true,
                                contentPadding: const EdgeInsets.symmetric(
                                  horizontal: 12,
                                  vertical: 12,
                                ),
                                fillColor:
                                    theme.colorScheme.surfaceContainerHighest,
                                filled: true,
                              ),
                              child: Row(
                                children: [
                                  Icon(
                                    Icons.all_inclusive,
                                    size: 18,
                                    color: theme.colorScheme.onSurfaceVariant,
                                  ),
                                  const SizedBox(width: 8),
                                  Text(
                                    l10n.planningOpenEnded,
                                    style: TextStyle(
                                      color: theme.colorScheme.onSurfaceVariant,
                                    ),
                                  ),
                                ],
                              ),
                            )
                          : InkWell(
                              onTap: () => _pickDate(isStart: false),
                              borderRadius: BorderRadius.circular(8),
                              child: InputDecorator(
                                decoration: const InputDecoration(
                                  border: OutlineInputBorder(),
                                  isDense: true,
                                  contentPadding: EdgeInsets.symmetric(
                                    horizontal: 12,
                                    vertical: 12,
                                  ),
                                ),
                                child: Row(
                                  children: [
                                    const Icon(Icons.calendar_today, size: 18),
                                    const SizedBox(width: 8),
                                    Text(dateFormat.format(_validTo!)),
                                  ],
                                ),
                              ),
                            ),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                // Pulsante senza scadenza a destra
                Align(
                  alignment: Alignment.centerRight,
                  child: AppOutlinedActionButton(
                    onPressed: () {
                      setState(() {
                        if (_isOpenEnded) {
                          _isOpenEnded = false;
                          _validTo = _validFrom.add(const Duration(days: 30));
                        } else {
                          _isOpenEnded = true;
                          _validTo = null;
                        }
                      });
                    },
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(
                          _isOpenEnded ? Icons.event : Icons.all_inclusive,
                          size: 18,
                        ),
                        const SizedBox(width: 8),
                        Text(
                          _isOpenEnded
                              ? l10n.planningSetEndDate
                              : l10n.planningOpenEnded,
                        ),
                      ],
                    ),
                  ),
                ),

                // ‚îÄ‚îÄ Tab per biweekly ‚îÄ‚îÄ
                if (_type == StaffPlanningType.biweekly) ...[
                  const SizedBox(height: AppSpacing.formRowSpacing),
                  Text(
                    'Settimana',
                    style: theme.textTheme.titleSmall?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  const SizedBox(height: 8),
                  TabBar(
                    controller: _tabController,
                    tabs: [
                      Tab(text: l10n.planningWeekA),
                      Tab(text: l10n.planningWeekB),
                    ],
                  ),
                ],

                const SizedBox(height: AppSpacing.formRowSpacing),

                // ‚îÄ‚îÄ Griglia Orari ‚îÄ‚îÄ
                WeeklyScheduleEditor(
                  initialSchedule: WeeklySchedule.fromSlots(
                    currentSlots,
                    minutesPerSlot: StaffPlanning.planningStepMinutes,
                  ),
                  onChanged: (schedule) {
                    final newSlots = schedule.toSlots(
                      minutesPerSlot: StaffPlanning.planningStepMinutes,
                    );
                    _onSlotsChanged(newSlots);
                  },
                  showHeader: true,
                  displayStepMinutes: _displayStepMinutes,
                  onDisplayStepChanged: (step) =>
                      setState(() => _displayStepMinutes = step),
                ),

                const SizedBox(height: 16),
              ],
            ),
          ),
        ),

        // ‚îÄ‚îÄ Footer con azioni ‚îÄ‚îÄ
        Container(
          padding: EdgeInsets.fromLTRB(
            horizontalPadding,
            AppSpacing.formFirstRowSpacing,
            horizontalPadding,
            0,
          ),
          child: Row(
            mainAxisAlignment: actions.length == 3
                ? MainAxisAlignment.spaceBetween
                : MainAxisAlignment.end,
            children: [
              if (widget.isEditing) actions[0],
              Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  actions[widget.isEditing ? 1 : 0],
                  const SizedBox(width: 8),
                  SizedBox(
                    width: AppButtonStyles.dialogButtonWidth,
                    child: actions[widget.isEditing ? 2 : 1],
                  ),
                ],
              ),
            ],
          ),
        ),
        SizedBox(height: MediaQuery.of(context).viewPadding.bottom + 16),
      ],
    );
    if (widget.isDesktop) {
      return Dialog(
        insetPadding: const EdgeInsets.symmetric(horizontal: 32, vertical: 24),
        clipBehavior: Clip.antiAlias,
        child: LocalLoadingOverlay(
          isLoading: isBusy,
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 540, maxHeight: 720),
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  // Titolo
                  Text(title, style: theme.textTheme.headlineSmall),
                  const SizedBox(height: 16),
                  // Contenuto scrollabile
                  Flexible(child: content),
                ],
              ),
            ),
          ),
        ),
      );
    }

    // BottomSheet mode
    return SafeArea(
      child: LocalLoadingOverlay(
        isLoading: isBusy,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Header con titolo
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 16, 8, 8),
              child: Row(
                children: [
                  Expanded(
                    child: Text(
                      title,
                      style: theme.textTheme.titleLarge?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
                  IconButton(
                    icon: const Icon(Icons.close),
                    onPressed: () => Navigator.of(context).pop(false),
                  ),
                ],
              ),
            ),
            const Divider(height: 1),
            Expanded(child: content),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/dialogs/staff_planning_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/staff_planning.dart';
import 'package:agenda_backend/core/widgets/app_bottom_sheet.dart';
import 'package:agenda_backend/core/widgets/app_buttons.dart';
import 'package:agenda_backend/core/widgets/app_dialogs.dart';
import 'package:agenda_backend/core/widgets/local_loading_overlay.dart';
import 'package:agenda_backend/core/widgets/labeled_form_field.dart';
import 'package:agenda_backend/features/staff/providers/staff_planning_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

/// Mostra il dialog per creare o modificare un planning.
Future<StaffPlanning?> showStaffPlanningDialog(
  BuildContext context,
  WidgetRef ref, {
  required int staffId,
  StaffPlanning? initial,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final isDesktop = formFactor == AppFormFactor.desktop;

  final dialog = _StaffPlanningDialog(
    staffId: staffId,
    initial: initial,
    isDesktop: isDesktop,
  );

  if (isDesktop) {
    return showDialog<StaffPlanning>(context: context, builder: (_) => dialog);
  } else {
    return AppBottomSheet.show<StaffPlanning>(
      context: context,
      useRootNavigator: true,
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 20),
      builder: (_) => dialog,
    );
  }
}

class _StaffPlanningDialog extends ConsumerStatefulWidget {
  const _StaffPlanningDialog({
    required this.staffId,
    this.initial,
    required this.isDesktop,
  });

  final int staffId;
  final StaffPlanning? initial;
  final bool isDesktop;

  bool get isEditing => initial != null;

  @override
  ConsumerState<_StaffPlanningDialog> createState() =>
      _StaffPlanningDialogState();
}

class _StaffPlanningDialogState extends ConsumerState<_StaffPlanningDialog> {
  late StaffPlanningType _type;
  late DateTime _validFrom;
  DateTime? _validTo;
  bool _isOpenEnded = true;
  bool _isSaving = false;
  String? _error;

  String _translateError(String error) {
    if (error.contains('overlap_error') || error.contains('Sovrapposizione')) {
      return 'Esiste gi√† un planning attivo per questo periodo. '
          'Modifica o elimina il planning esistente prima di crearne uno nuovo.';
    }
    if (error.contains('api_error:')) {
      return error.replaceFirst('api_error: ', '');
    }
    return error;
  }

  @override
  void initState() {
    super.initState();
    if (widget.initial != null) {
      _type = widget.initial!.type;
      _validFrom = widget.initial!.validFrom;
      _validTo = widget.initial!.validTo;
      _isOpenEnded = widget.initial!.validTo == null;
    } else {
      _type = StaffPlanningType.weekly;
      _validFrom = DateTime.now();
      _validTo = null;
      _isOpenEnded = true;
    }
  }

  Future<void> _pickValidFrom() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _validFrom,
      firstDate: DateTime(2020),
      lastDate: DateTime(2100),
    );
    if (picked != null) {
      setState(() {
        _validFrom = picked;
        // Se validTo √® prima di validFrom, aggiorna
        if (_validTo != null && _validTo!.isBefore(_validFrom)) {
          _validTo = _validFrom;
        }
      });
    }
  }

  Future<void> _pickValidTo() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _validTo ?? _validFrom,
      firstDate: _validFrom,
      lastDate: DateTime(2100),
    );
    if (picked != null) {
      setState(() => _validTo = picked);
    }
  }

  Future<void> _onSave() async {
    setState(() {
      _isSaving = true;
      _error = null;
    });

    try {
      final notifier = ref.read(staffPlanningsProvider.notifier);

      // Prepara i template (vuoti per ora, verranno popolati dall'editor)
      final templates = <StaffPlanningWeekTemplate>[
        StaffPlanningWeekTemplate(
          id: widget.initial?.templateA?.id ?? 0,
          staffPlanningId: widget.initial?.id ?? 0,
          weekLabel: WeekLabel.a,
          daySlots: widget.initial?.templateA?.daySlots ?? {},
        ),
        if (_type == StaffPlanningType.biweekly)
          StaffPlanningWeekTemplate(
            id: widget.initial?.templateB?.id ?? 0,
            staffPlanningId: widget.initial?.id ?? 0,
            weekLabel: WeekLabel.b,
            daySlots: widget.initial?.templateB?.daySlots ?? {},
          ),
      ];

      final planning = StaffPlanning(
        id: widget.initial?.id ?? 0,
        staffId: widget.staffId,
        type: _type,
        validFrom: _validFrom,
        validTo: _isOpenEnded ? null : _validTo,
        templates: templates,
        createdAt: widget.initial?.createdAt ?? DateTime.now(),
      );

      if (widget.isEditing) {
        final result = await notifier.updatePlanning(planning, widget.initial!);
        if (!result.isValid) {
          setState(() => _error = _translateError(result.errors.join('\n')));
          return;
        }
        // Per update, usa il planning locale (l'ID non cambia)
        if (mounted) {
          Navigator.of(context).pop(planning);
        }
      } else {
        final result = await notifier.addPlanning(planning);
        if (!result.isValid) {
          setState(() => _error = _translateError(result.errors.join('\n')));
          return;
        }
        // Per create, usa il planning dal server (con ID corretto)
        if (mounted) {
          Navigator.of(context).pop(result.planning);
        }
      }
    } catch (e) {
      setState(() => _error = e.toString());
    } finally {
      if (mounted) {
        setState(() => _isSaving = false);
      }
    }
  }

  Future<void> _onDelete() async {
    if (widget.initial == null) return;

    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(context.l10n.planningDeleteTitle),
        content: Text(context.l10n.planningDeleteConfirm),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(ctx, false),
            child: Text(context.l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () => Navigator.pop(ctx, true),
            style: FilledButton.styleFrom(
              backgroundColor: Theme.of(ctx).colorScheme.error,
            ),
            child: Text(context.l10n.actionDelete),
          ),
        ],
      ),
    );

    if (confirmed != true) return;

    setState(() => _isSaving = true);

    try {
      await ref
          .read(staffPlanningsProvider.notifier)
          .deletePlanning(widget.staffId, widget.initial!.id);
      if (mounted) {
        Navigator.of(context).pop();
      }
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isSaving = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final dateFormat = DateFormat.yMMMd(Intl.getCurrentLocale());

    final content = Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Tipo planning
        LabeledFormField(
          label: l10n.planningType,
          child: SegmentedButton<StaffPlanningType>(
            segments: [
              ButtonSegment(
                value: StaffPlanningType.weekly,
                label: Text(l10n.planningTypeWeekly),
                icon: const Icon(Icons.view_week_outlined),
              ),
              ButtonSegment(
                value: StaffPlanningType.biweekly,
                label: Text(l10n.planningTypeBiweekly),
                icon: const Icon(Icons.date_range_outlined),
              ),
            ],
            selected: {_type},
            onSelectionChanged: (selection) {
              setState(() => _type = selection.first);
            },
          ),
        ),
        const SizedBox(height: 16),

        // Data inizio
        LabeledFormField(
          label: l10n.planningValidFrom,
          child: InkWell(
            onTap: _pickValidFrom,
            borderRadius: BorderRadius.circular(8),
            child: InputDecorator(
              decoration: const InputDecoration(
                border: OutlineInputBorder(),
                isDense: true,
                suffixIcon: Icon(Icons.calendar_today),
              ),
              child: Text(dateFormat.format(_validFrom)),
            ),
          ),
        ),
        const SizedBox(height: 16),

        // Data fine (opzionale)
        LabeledFormField(
          label: l10n.planningValidTo,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Checkbox(
                    value: _isOpenEnded,
                    onChanged: (v) {
                      setState(() {
                        _isOpenEnded = v ?? true;
                        if (!_isOpenEnded && _validTo == null) {
                          _validTo = _validFrom.add(const Duration(days: 365));
                        }
                      });
                    },
                  ),
                  Text(l10n.planningOpenEnded),
                ],
              ),
              if (!_isOpenEnded)
                InkWell(
                  onTap: _pickValidTo,
                  borderRadius: BorderRadius.circular(8),
                  child: InputDecorator(
                    decoration: const InputDecoration(
                      border: OutlineInputBorder(),
                      isDense: true,
                      suffixIcon: Icon(Icons.calendar_today),
                    ),
                    child: Text(
                      _validTo != null
                          ? dateFormat.format(_validTo!)
                          : l10n.planningSelectDate,
                    ),
                  ),
                ),
            ],
          ),
        ),

        // Errore
        if (_error != null) ...[
          const SizedBox(height: 16),
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: theme.colorScheme.errorContainer,
              borderRadius: BorderRadius.circular(8),
            ),
            child: Row(
              children: [
                Icon(
                  Icons.error_outline,
                  color: theme.colorScheme.error,
                  size: 20,
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    _error!,
                    style: TextStyle(color: theme.colorScheme.error),
                  ),
                ),
              ],
            ),
          ),
        ],
      ],
    );

    final actions = [
      if (widget.isEditing)
        AppDangerButton(
          onPressed: _isSaving ? null : _onDelete,
          child: Text(l10n.actionDelete),
        ),
      AppOutlinedActionButton(
        onPressed: _isSaving ? null : () => Navigator.of(context).pop(),
        child: Text(l10n.actionCancel),
      ),
      AppFilledButton(
        onPressed: _isSaving ? null : _onSave,
        child: Text(l10n.actionSave),
      ),
    ];

    final loadingContent = LocalLoadingOverlay(
      isLoading: _isSaving,
      child: content,
    );

    if (widget.isDesktop) {
      return AppFormDialog(
        title: Text(
          widget.isEditing ? l10n.planningEditTitle : l10n.planningCreateTitle,
        ),
        content: loadingContent,
        actions: actions,
      );
    }

    // Bottom sheet layout
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        Text(
          widget.isEditing ? l10n.planningEditTitle : l10n.planningCreateTitle,
          style: theme.textTheme.titleLarge,
        ),
        const SizedBox(height: 16),
        loadingContent,
        const SizedBox(height: 24),
        Wrap(
          spacing: 12,
          runSpacing: 12,
          alignment: WrapAlignment.end,
          children: actions,
        ),
      ],
    );
  }
}
--- FILE: lib/features/staff/presentation/dialogs/staff_dialog.dart ---
import 'package:flutter/foundation.dart' show setEquals;
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/app_constants.dart';
import '../../../../app/providers/form_factor_provider.dart';
import '../../../../app/theme/app_spacing.dart';
import '../../../../app/widgets/staff_circle_avatar.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/staff.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/app_switch.dart';
import '../../../../core/widgets/labeled_form_field.dart';
import '../../../../core/widgets/local_loading_overlay.dart';
import '../../../agenda/providers/location_providers.dart';
import '../../../auth/providers/current_business_user_provider.dart';
import '../../../services/presentation/widgets/service_eligibility_selector.dart';
import '../../../services/providers/services_provider.dart';
import '../../providers/staff_providers.dart';

bool _canManagerEditStaffInScope(
  String currentUserRole,
  Staff? targetStaff,
  List<int>? allowedLocationIds,
) {
  if (currentUserRole != 'manager' || targetStaff == null) return false;
  if (allowedLocationIds == null) return true;
  return targetStaff.locationIds.any(allowedLocationIds.contains);
}

Future<void> showStaffDialog(
  BuildContext context,
  WidgetRef ref, {
  Staff? initial,
  int? initialLocationId,
  bool duplicateFrom = false,
  bool readOnly = false,
}) async {
  final canManageStaff = ref.read(currentUserCanManageStaffProvider);
  final currentUserRole = ref.read(currentUserRoleProvider);
  final currentUserStaffId = ref.read(currentUserStaffIdProvider);
  final allowedLocationIds = ref.read(allowedLocationIdsProvider);
  final isOwnStaff =
      initial != null &&
      currentUserStaffId != null &&
      currentUserStaffId > 0 &&
      initial.id == currentUserStaffId;
  final canEditOwnStaffProfile = currentUserRole == 'staff' && isOwnStaff;
  final canEditManagerScopedStaff = _canManagerEditStaffInScope(
    currentUserRole,
    initial,
    allowedLocationIds,
  );

  if (!readOnly &&
      !canManageStaff &&
      !canEditOwnStaffProfile &&
      !canEditManagerScopedStaff) {
    return;
  }
  final formFactor = ref.read(formFactorProvider);
  final isDesktop = formFactor == AppFormFactor.desktop;

  final dialog = _StaffDialog(
    initial: initial,
    initialLocationId: initialLocationId,
    isDuplicating: duplicateFrom,
    readOnly: readOnly,
  );

  if (isDesktop) {
    await showDialog(context: context, builder: (_) => dialog);
  } else {
    await AppBottomSheet.show(
      context: context,
      builder: (_) => dialog,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      heightFactor: AppBottomSheet.defaultHeightFactor,
    );
  }
}

class _StaffDialog extends ConsumerStatefulWidget {
  const _StaffDialog({
    this.initial,
    this.initialLocationId,
    this.isDuplicating = false,
    this.readOnly = false,
  });

  final Staff? initial;
  final int? initialLocationId;
  final bool isDuplicating;
  final bool readOnly;

  bool get isEditing => initial != null && !isDuplicating;

  @override
  ConsumerState<_StaffDialog> createState() => _StaffDialogState();
}

class _StaffDialogState extends ConsumerState<_StaffDialog> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _surnameController = TextEditingController();

  late Color _selectedColor;
  final ScrollController _colorScrollController = ScrollController();
  final Set<int> _selectedLocationIds = {};
  final Set<int> _selectedServiceIds = {};
  String? _locationsError;
  bool _isSelectingServices = false;
  bool _isSelectingLocations = false;
  bool _isBookableOnline = true;
  bool _didAutoScrollColor = false;
  bool _didFilterServiceIds = false;

  static const List<Color> _palette = [
    // Gialli / Amber (alto contrasto)
    Color(0xFFFFC400),
    Color(0xFFFFA000),
    // Arancioni
    Color(0xFFFF6D00),
    Color(0xFFFF3D00),
    // Rossi
    Color(0xFFD50000),
    Color(0xFFB71C1C),
    // Magenta / Rosa
    Color(0xFFF50057),
    Color(0xFFC51162),
    // Viola
    Color(0xFFAA00FF),
    Color(0xFF6200EA),
    // Indaco
    Color(0xFF304FFE),
    Color(0xFF1A237E),
    // Blu
    Color(0xFF2962FF),
    Color(0xFF1565C0),
    // Azzurro
    Color(0xFF0091EA),
    Color(0xFF00B0FF),
    // Ciano
    Color(0xFF00B8D4),
    Color(0xFF00838F),
    // Teal / Turchese
    Color(0xFF00BFA5),
    Color(0xFF00796B),
    // Verdi
    Color(0xFF00C853),
    Color(0xFF2E7D32),
    // Lime / Verde acido
    Color(0xFF76FF03),
    Color(0xFFAEEA00),
    // Extra diversit√†
    Color(0xFFFF9100),
    Color(0xFFE65100),
    Color(0xFFAD1457),
    Color(0xFF7B1FA2),
    Color(0xFF3949AB),
    Color(0xFF00897B),
    Color(0xFF43A047),
    Color(0xFF558B2F),
    Color(0xFF01579B),
    Color(0xFF006064),
    Color(0xFF4E342E),
    Color(0xFF37474F),
  ];

  @override
  void initState() {
    super.initState();
    final initial = widget.initial;
    _selectedColor = initial?.color ?? _palette.first;
    if (initial != null) {
      if (widget.isDuplicating) {
        _nameController.clear();
        _surnameController.clear();
      } else {
        _nameController.text = initial.name;
        _surnameController.text = initial.surname;
      }
      if (kAllowStaffMultiLocationSelection) {
        _selectedLocationIds.addAll(initial.locationIds);
      } else if (initial.locationIds.isNotEmpty) {
        _selectedLocationIds.add(initial.locationIds.first);
      }
      _isBookableOnline = initial.isBookableOnline;
      // Legge serviceIds direttamente dal modello Staff (gi√† caricato da API)
      _selectedServiceIds.addAll(initial.serviceIds);
    } else if (widget.initialLocationId != null) {
      _selectedLocationIds.add(widget.initialLocationId!);
    }
    _nameController.addListener(_handleNameChange);
    _surnameController.addListener(_handleNameChange);
  }

  @override
  void dispose() {
    _nameController.removeListener(_handleNameChange);
    _surnameController.removeListener(_handleNameChange);
    _nameController.dispose();
    _surnameController.dispose();
    _colorScrollController.dispose();
    super.dispose();
  }

  void _handleNameChange() {
    if (!mounted) return;
    setState(() {});
  }

  String _buildInitials() {
    final name = _nameController.text.trim();
    final surname = _surnameController.text.trim();
    final fullName = [name, surname].where((p) => p.isNotEmpty).join(' ');
    return initialsFromName(fullName, maxChars: 3);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final title = widget.isEditing
        ? l10n.teamEditStaffTitle
        : l10n.teamNewStaffTitle;
    final formFactor = ref.read(formFactorProvider);
    final canManageStaff = ref.watch(currentUserCanManageStaffProvider);
    final currentUserRole = ref.watch(currentUserRoleProvider);
    final currentUserStaffId = ref.watch(currentUserStaffIdProvider);
    final allowedLocationIds = ref.watch(allowedLocationIdsProvider);
    final isEditingOwnStaff =
        widget.initial != null &&
        currentUserRole == 'staff' &&
        currentUserStaffId != null &&
        currentUserStaffId > 0 &&
        widget.initial!.id == currentUserStaffId;
    final canEditOwnStaffProfile = !canManageStaff && isEditingOwnStaff;
    final canEditManagerScopedStaff = _canManagerEditStaffInScope(
      currentUserRole,
      widget.initial,
      allowedLocationIds,
    );
    final canEditScopedProfile =
        canEditOwnStaffProfile || canEditManagerScopedStaff;
    final isReadOnly =
        widget.readOnly || (!canManageStaff && !canEditScopedProfile);
    final canEditLocationAndServices = canManageStaff;
    final canEditServices = canManageStaff || canEditScopedProfile;
    final isSingleColumn = formFactor != AppFormFactor.desktop;
    final locations = ref.watch(locationsProvider);
    // Carica servizi solo per le location selezionate
    final locationIdsKey = locationIdsToKey(_selectedLocationIds);
    final servicesForLocationsAsync = ref.watch(
      servicesForLocationsProvider(locationIdsKey),
    );
    final servicesData = servicesForLocationsAsync.value;
    final totalServicesCount = servicesData?.services.length ?? 0;

    // Filtra i serviceIds selezionati per includere solo quelli disponibili
    // nelle location dello staff (una sola volta al primo caricamento)
    if (!_didFilterServiceIds && servicesData != null) {
      final validServiceIds = servicesData.services.map((s) => s.id).toSet();
      final invalidIds = _selectedServiceIds
          .where((id) => !validServiceIds.contains(id))
          .toList();
      if (invalidIds.isNotEmpty) {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (mounted) {
            setState(() {
              _selectedServiceIds.removeAll(invalidIds);
            });
          }
        });
      }
      _didFilterServiceIds = true;
    }
    final totalLocationsCount = locations.length;
    final selectedLocationName =
        !kAllowStaffMultiLocationSelection && _selectedLocationIds.isNotEmpty
        ? locations
              .firstWhere(
                (loc) => loc.id == _selectedLocationIds.first,
                orElse: () => locations.first,
              )
              .name
        : null;
    if (!_didAutoScrollColor) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (!_colorScrollController.hasClients) return;
        final index = _palette.indexWhere(
          (c) => c.value == _selectedColor.value,
        );
        if (index < 0) return;
        const double colorItemSize = 36;
        const double colorItemSpacing = 10;
        const double colorListPadding = 4;
        final viewport = _colorScrollController.position.viewportDimension;
        final target =
            index * (colorItemSize + colorItemSpacing) -
            (viewport - colorItemSize) / 2 -
            colorListPadding;
        final max = _colorScrollController.position.maxScrollExtent;
        _colorScrollController.jumpTo(target.clamp(0.0, max));
      });
      _didAutoScrollColor = true;
    }

    final editAvatar = widget.isEditing
        ? Center(
            child: StaffCircleAvatar(
              height: 64,
              color: _selectedColor,
              isHighlighted: false,
              initials: _buildInitials(),
            ),
          )
        : null;

    final actions = isReadOnly
        ? <Widget>[
            AppOutlinedActionButton(
              onPressed: _isSaving ? null : () => Navigator.of(context).pop(),
              padding: AppButtonStyles.dialogButtonPadding,
              child: Text(l10n.actionClose),
            ),
          ]
        : <Widget>[
            AppOutlinedActionButton(
              onPressed: _isSaving ? null : () => Navigator.of(context).pop(),
              padding: AppButtonStyles.dialogButtonPadding,
              child: Text(l10n.actionCancel),
            ),
            AppFilledButton(
              onPressed: _isSaving ? null : _onSave,
              padding: AppButtonStyles.dialogButtonPadding,
              child: Text(l10n.actionSave),
            ),
          ];

    final bottomActions = actions
        .map(
          (a) => SizedBox(width: AppButtonStyles.dialogButtonWidth, child: a),
        )
        .toList();

    final nameField = LabeledFormField(
      label: l10n.teamStaffNameLabel,
      child: TextFormField(
        controller: _nameController,
        enabled: !isReadOnly,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        textInputAction: TextInputAction.next,
        textCapitalization: TextCapitalization.words,
        validator: (v) =>
            v == null || v.trim().isEmpty ? l10n.validationRequired : null,
      ),
    );

    final surnameField = LabeledFormField(
      label: l10n.teamStaffSurnameLabel,
      child: TextFormField(
        controller: _surnameController,
        enabled: !isReadOnly,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        textInputAction: TextInputAction.next,
        textCapitalization: TextCapitalization.words,
      ),
    );

    final content = Form(
      key: _formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        mainAxisSize: MainAxisSize.min,
        children: [
          if (isSingleColumn) ...[
            nameField,
            const SizedBox(height: AppSpacing.formRowSpacing),
            surnameField,
          ] else ...[
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(child: nameField),
                const SizedBox(width: AppSpacing.formFieldSpacing),
                Expanded(child: surnameField),
              ],
            ),
          ],
          const SizedBox(height: AppSpacing.formRowSpacing),
          Text(
            l10n.teamStaffColorLabel,
            style: Theme.of(context).textTheme.titleSmall,
          ),
          const SizedBox(height: 8),
          SizedBox(
            height: 44,
            child: Row(
              children: [
                Expanded(
                  child: ShaderMask(
                    shaderCallback: (rect) {
                      return const LinearGradient(
                        begin: Alignment.centerLeft,
                        end: Alignment.centerRight,
                        colors: [
                          Colors.transparent,
                          Colors.black,
                          Colors.black,
                          Colors.transparent,
                        ],
                        stops: [0.0, 0.01, 0.99, 1.0],
                      ).createShader(rect);
                    },
                    blendMode: BlendMode.dstIn,
                    child: ScrollConfiguration(
                      behavior: const ScrollBehavior().copyWith(
                        dragDevices: {
                          PointerDeviceKind.touch,
                          PointerDeviceKind.mouse,
                          PointerDeviceKind.trackpad,
                        },
                      ),
                      child: ListView.separated(
                        controller: _colorScrollController,
                        padding: const EdgeInsets.symmetric(horizontal: 4),
                        scrollDirection: Axis.horizontal,
                        physics: const BouncingScrollPhysics(),
                        itemCount: _palette.length,
                        separatorBuilder: (_, __) => const SizedBox(width: 10),
                        itemBuilder: (context, index) {
                          final color = _palette[index];
                          final initials = _buildInitials();
                          return GestureDetector(
                            onTap: isReadOnly
                                ? null
                                : () => setState(() => _selectedColor = color),
                            child: AnimatedContainer(
                              duration: const Duration(milliseconds: 150),
                              child: StaffCircleAvatar(
                                height: 36,
                                color: color,
                                isHighlighted: _selectedColor == color,
                                initials: initials,
                              ),
                            ),
                          );
                        },
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: AppSpacing.formRowSpacing),
          if (!kAllowStaffMultiLocationSelection) ...[
            Text(
              l10n.teamLocationLabel,
              style: Theme.of(context).textTheme.titleSmall,
            ),
            const SizedBox(height: 8),
          ],
          SizedBox(
            height: 48,
            child: AppOutlinedActionButton(
              onPressed: canEditLocationAndServices
                  ? _openLocationsSelector
                  : null,
              expand: true,
              padding: AppButtonStyles.defaultPadding,
              child: Row(
                children: [
                  Expanded(
                    child: Align(
                      alignment: Alignment.centerLeft,
                      child: Text(
                        kAllowStaffMultiLocationSelection
                            ? l10n.teamChooseLocationsButton
                            : (selectedLocationName ??
                                  l10n.teamChooseLocationSingleButton),
                      ),
                    ),
                  ),
                  if (kAllowStaffMultiLocationSelection)
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 10,
                        vertical: 4,
                      ),
                      decoration: BoxDecoration(
                        color: Theme.of(
                          context,
                        ).colorScheme.primary.withOpacity(0.12),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        '${_selectedLocationIds.length}/$totalLocationsCount',
                        style: Theme.of(context).textTheme.labelSmall?.copyWith(
                          color: Theme.of(context).colorScheme.primary,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                ],
              ),
            ),
          ),
          if (_locationsError != null)
            Padding(
              padding: const EdgeInsets.only(top: 4),
              child: Text(
                _locationsError!,
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.error,
                ),
              ),
            ),
          const SizedBox(height: AppSpacing.formRowSpacing),
          Text(
            l10n.teamServicesLabel,
            style: Theme.of(context).textTheme.titleSmall,
          ),
          const SizedBox(height: 8),
          SizedBox(
            height: 48,
            child: AppOutlinedActionButton(
              onPressed: () =>
                  _openServicesSelector(readOnly: !canEditServices),
              expand: true,
              padding: AppButtonStyles.defaultPadding,
              child: Align(
                alignment: Alignment.centerLeft,
                child: Wrap(
                  crossAxisAlignment: WrapCrossAlignment.center,
                  spacing: 8,
                  runSpacing: 6,
                  children: [
                    Text(l10n.teamSelectedServicesButton),
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 10,
                        vertical: 4,
                      ),
                      decoration: BoxDecoration(
                        color: Theme.of(
                          context,
                        ).colorScheme.primary.withOpacity(0.12),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        l10n.teamSelectedServicesCount(
                          _selectedServiceIds.length,
                          totalServicesCount,
                        ),
                        style: Theme.of(context).textTheme.labelSmall?.copyWith(
                          color: Theme.of(context).colorScheme.primary,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
          const SizedBox(height: AppSpacing.formRowSpacing),
          _SwitchTile(
            title: l10n.teamStaffBookableOnlineLabel,
            value: _isBookableOnline,
            onChanged: canEditLocationAndServices
                ? (v) => setState(() => _isBookableOnline = v)
                : null,
          ),
          if (_saveError != null) ...[
            const SizedBox(height: AppSpacing.formRowSpacing),
            Text(
              _saveError!,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.error,
              ),
            ),
          ],
          const SizedBox(height: AppSpacing.formRowSpacing),
          if (kAllowStaffMultiLocationSelection)
            Text(
              l10n.teamStaffMultiLocationWarning,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
        ],
      ),
    );

    if (ref.read(formFactorProvider) == AppFormFactor.desktop) {
      return Dialog(
        insetPadding: const EdgeInsets.symmetric(horizontal: 32, vertical: 24),
        child: ConstrainedBox(
          constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
          child: LocalLoadingOverlay(
            isLoading: _isSaving,
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text(title, style: Theme.of(context).textTheme.headlineSmall),
                  if (editAvatar != null) ...[
                    const SizedBox(height: 12),
                    editAvatar,
                  ],
                  const SizedBox(height: 16),
                  Flexible(child: SingleChildScrollView(child: content)),
                  const SizedBox(height: 24),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      for (int i = 0; i < bottomActions.length; i++) ...[
                        if (i > 0) const SizedBox(width: 8),
                        bottomActions[i],
                      ],
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      );
    }

    return SafeArea(
      top: false,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final isKeyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
          return LocalLoadingOverlay(
            isLoading: _isSaving,
            child: SizedBox(
              height: constraints.maxHeight,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Expanded(
                    child: SingleChildScrollView(
                      padding: EdgeInsets.zero,
                      child: Padding(
                        padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Padding(
                              padding: const EdgeInsets.only(bottom: 12),
                              child: Text(
                                title,
                                style: Theme.of(context).textTheme.titleLarge,
                              ),
                            ),
                            if (editAvatar != null) ...[
                              editAvatar,
                              const SizedBox(height: 12),
                            ],
                            content,
                            const SizedBox(height: 24),
                            const SizedBox(height: AppSpacing.formRowSpacing),
                          ],
                        ),
                      ),
                    ),
                  ),
                  if (!isKeyboardOpen) ...[
                    const AppDivider(),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                      child: Align(
                        alignment: bottomActions.length == 3
                            ? Alignment.center
                            : Alignment.centerRight,
                        child: Wrap(
                          alignment: bottomActions.length == 3
                              ? WrapAlignment.center
                              : WrapAlignment.end,
                          spacing: 8,
                          runSpacing: 8,
                          children: bottomActions,
                        ),
                      ),
                    ),
                  ],
                  SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  bool _isSaving = false;
  String? _saveError;

  Future<void> _onSave() async {
    final canManageStaff = ref.read(currentUserCanManageStaffProvider);
    final currentUserRole = ref.read(currentUserRoleProvider);
    final currentUserStaffId = ref.read(currentUserStaffIdProvider);
    final allowedLocationIds = ref.read(allowedLocationIdsProvider);
    final isEditingOwnStaff =
        widget.initial != null &&
        currentUserRole == 'staff' &&
        currentUserStaffId != null &&
        currentUserStaffId > 0 &&
        widget.initial!.id == currentUserStaffId;
    final canEditOwnStaffProfile = !canManageStaff && isEditingOwnStaff;
    final canEditManagerScopedStaff = _canManagerEditStaffInScope(
      currentUserRole,
      widget.initial,
      allowedLocationIds,
    );
    final canEditScopedProfile =
        canEditOwnStaffProfile || canEditManagerScopedStaff;

    if (!canManageStaff && !canEditScopedProfile) return;
    if (!_formKey.currentState!.validate()) return;
    if (canManageStaff && _selectedLocationIds.isEmpty) {
      setState(() => _locationsError = context.l10n.validationRequired);
      return;
    }
    if (canManageStaff &&
        !kAllowStaffMultiLocationSelection &&
        _selectedLocationIds.length > 1) {
      final firstId = _selectedLocationIds.first;
      _selectedLocationIds
        ..clear()
        ..add(firstId);
    }

    setState(() {
      _isSaving = true;
      _saveError = null;
    });

    final notifier = ref.read(allStaffProvider.notifier);
    final name = _nameController.text.trim();
    final surname = _surnameController.text.trim();
    final isEditing = widget.isEditing;

    try {
      if (isEditing) {
        // Aggiorna staff esistente tramite API (include service_ids)
        await notifier.updateStaffApi(
          staffId: widget.initial!.id,
          name: name,
          surname: surname,
          colorHex:
              '#${_selectedColor.value.toRadixString(16).substring(2).toUpperCase()}',
          isBookableOnline: canManageStaff ? _isBookableOnline : null,
          locationIds: canManageStaff ? _selectedLocationIds.toList() : null,
          serviceIds: (canManageStaff || canEditScopedProfile)
              ? _selectedServiceIds.toList()
              : null,
        );
      } else {
        if (!canManageStaff) return;
        // Crea nuovo staff tramite API (include service_ids)
        await notifier.createStaff(
          name: name,
          surname: surname,
          colorHex:
              '#${_selectedColor.value.toRadixString(16).substring(2).toUpperCase()}',
          isBookableOnline: _isBookableOnline,
          locationIds: _selectedLocationIds.toList(),
          serviceIds: _selectedServiceIds.toList(),
        );
      }

      if (mounted) Navigator.of(context).pop();
    } catch (e) {
      setState(() {
        _saveError = e.toString();
        _isSaving = false;
      });
    }
  }

  Future<void> _openServicesSelector({bool readOnly = false}) async {
    if (_isSelectingServices) return;
    setState(() => _isSelectingServices = true);
    final l10n = context.l10n;
    // Carica servizi solo per le location selezionate
    final servicesResult = await ref.read(
      servicesForLocationsProvider(
        locationIdsToKey(_selectedLocationIds),
      ).future,
    );
    final services = servicesResult.services;
    final categories = servicesResult.categories;
    final formFactor = ref.read(formFactorProvider);
    Set<int> current = {..._selectedServiceIds};

    Future<void> openDialog(BuildContext ctx) async {
      await showDialog<void>(
        context: ctx,
        builder: (dialogCtx) => StatefulBuilder(
          builder: (context, setStateLocal) {
            return Dialog(
              insetPadding: const EdgeInsets.symmetric(
                horizontal: 32,
                vertical: 24,
              ),
              child: ConstrainedBox(
                constraints: const BoxConstraints(
                  minWidth: 600,
                  maxWidth: 720,
                  maxHeight: 560,
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Padding(
                      padding: const EdgeInsets.fromLTRB(20, 16, 20, 8),
                      child: Text(
                        l10n.teamEligibleServicesLabel,
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                    ),
                    const AppDivider(),
                    Expanded(
                      child: SingleChildScrollView(
                        child: Padding(
                          padding: const EdgeInsets.fromLTRB(0, 12, 0, 16),
                          child: ServiceEligibilitySelector(
                            services: services,
                            categories: categories,
                            selectedServiceIds: current,
                            readOnly: readOnly,
                            onChanged: (value) => setStateLocal(() {
                              current = {...value};
                            }),
                          ),
                        ),
                      ),
                    ),
                    const AppDivider(),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                      child: Align(
                        alignment: Alignment.centerRight,
                        child: AppFilledButton(
                          onPressed: () => Navigator.of(dialogCtx).pop(),
                          padding: AppButtonStyles.dialogButtonPadding,
                          child: Text(
                            readOnly ? l10n.actionClose : l10n.actionConfirm,
                          ),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        ),
      );
    }

    Future<void> openSheet(BuildContext ctx) async {
      await AppBottomSheet.show<void>(
        context: ctx,
        heightFactor: AppBottomSheet.defaultHeightFactor,
        padding: EdgeInsets.zero,
        builder: (sheetCtx) => StatefulBuilder(
          builder: (context, setStateLocal) {
            return SafeArea(
              top: false,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
                    child: Text(
                      l10n.teamEligibleServicesLabel,
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                  ),
                  const AppDivider(),
                  Expanded(
                    child: SingleChildScrollView(
                      child: Padding(
                        padding: const EdgeInsets.fromLTRB(0, 12, 0, 16),
                        child: ServiceEligibilitySelector(
                          services: services,
                          categories: categories,
                          selectedServiceIds: current,
                          readOnly: readOnly,
                          onChanged: (value) => setStateLocal(() {
                            current = {...value};
                          }),
                        ),
                      ),
                    ),
                  ),
                  const AppDivider(),
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                    child: Align(
                      alignment: Alignment.centerRight,
                      child: AppFilledButton(
                        onPressed: () => Navigator.of(sheetCtx).pop(),
                        padding: AppButtonStyles.dialogButtonPadding,
                        child: Text(
                          readOnly ? l10n.actionClose : l10n.actionConfirm,
                        ),
                      ),
                    ),
                  ),
                  SizedBox(height: MediaQuery.of(ctx).viewPadding.bottom),
                ],
              ),
            );
          },
        ),
      );
    }

    if (!mounted) return;

    if (formFactor == AppFormFactor.desktop) {
      await openDialog(context);
    } else {
      await openSheet(context);
    }

    if (!mounted) return;

    if (!readOnly) {
      setState(() {
        _selectedServiceIds
          ..clear()
          ..addAll(current);
        _isSelectingServices = false;
      });
      return;
    }

    setState(() => _isSelectingServices = false);
  }

  Future<void> _openLocationsSelector() async {
    if (_isSelectingLocations) return;
    setState(() => _isSelectingLocations = true);
    final l10n = context.l10n;
    final locations = ref.read(locationsProvider);
    final formFactor = ref.read(formFactorProvider);
    Set<int> current = {..._selectedLocationIds};

    Widget buildLocationRows(void Function(VoidCallback) setStateLocal) {
      final allIds = [for (final l in locations) l.id];
      final allSelected = allIds.isNotEmpty && allIds.every(current.contains);
      return Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          if (kAllowStaffMultiLocationSelection) ...[
            _SelectableRow(
              label: l10n.teamSelectAllLocations,
              selected: allSelected,
              onTap: () {
                if (allSelected) {
                  current.clear();
                } else {
                  current
                    ..clear()
                    ..addAll(allIds);
                }
                setStateLocal(() {});
              },
            ),
            const AppDivider(),
          ],
          for (final loc in locations)
            _SelectableRow(
              label: loc.name,
              selected: current.contains(loc.id),
              onTap: () {
                if (kAllowStaffMultiLocationSelection) {
                  if (current.contains(loc.id)) {
                    current.remove(loc.id);
                  } else {
                    current.add(loc.id);
                  }
                } else {
                  current
                    ..clear()
                    ..add(loc.id);
                }
                setStateLocal(() {});
                if (!kAllowStaffMultiLocationSelection) {
                  Navigator.of(context).pop();
                }
              },
            ),
        ],
      );
    }

    Future<void> openDialog(BuildContext ctx) async {
      await showDialog<void>(
        context: ctx,
        builder: (dialogCtx) => StatefulBuilder(
          builder: (context, setStateLocal) {
            return Dialog(
              insetPadding: const EdgeInsets.symmetric(
                horizontal: 32,
                vertical: 24,
              ),
              child: ConstrainedBox(
                constraints: const BoxConstraints(
                  minWidth: 600,
                  maxWidth: 720,
                  maxHeight: 560,
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Padding(
                      padding: const EdgeInsets.fromLTRB(20, 16, 20, 8),
                      child: Text(
                        kAllowStaffMultiLocationSelection
                            ? l10n.teamChooseLocationsButton
                            : l10n.teamChooseLocationSingleButton,
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                    ),
                    const AppDivider(),
                    Expanded(
                      child: SingleChildScrollView(
                        child: Padding(
                          padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                          child: buildLocationRows(setStateLocal),
                        ),
                      ),
                    ),
                    if (kAllowStaffMultiLocationSelection) ...[
                      const AppDivider(),
                      Padding(
                        padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                        child: Align(
                          alignment: Alignment.centerRight,
                          child: AppFilledButton(
                            onPressed: () => Navigator.of(dialogCtx).pop(),
                            padding: AppButtonStyles.dialogButtonPadding,
                            child: Text(l10n.actionConfirm),
                          ),
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            );
          },
        ),
      );
    }

    Future<void> openSheet(BuildContext ctx) async {
      await AppBottomSheet.show<void>(
        context: ctx,
        heightFactor: AppBottomSheet.defaultHeightFactor,
        padding: EdgeInsets.zero,
        builder: (sheetCtx) => StatefulBuilder(
          builder: (context, setStateLocal) {
            return SafeArea(
              top: false,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
                    child: Text(
                      kAllowStaffMultiLocationSelection
                          ? l10n.teamChooseLocationsButton
                          : l10n.teamChooseLocationSingleButton,
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                  ),
                  const AppDivider(),
                  Expanded(
                    child: SingleChildScrollView(
                      child: Padding(
                        padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                        child: buildLocationRows(setStateLocal),
                      ),
                    ),
                  ),
                  if (kAllowStaffMultiLocationSelection) ...[
                    const AppDivider(),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                      child: Align(
                        alignment: Alignment.centerRight,
                        child: AppFilledButton(
                          onPressed: () => Navigator.of(sheetCtx).pop(),
                          padding: AppButtonStyles.dialogButtonPadding,
                          child: Text(l10n.actionConfirm),
                        ),
                      ),
                    ),
                    SizedBox(height: MediaQuery.of(ctx).viewPadding.bottom),
                  ],
                ],
              ),
            );
          },
        ),
      );
    }

    if (formFactor == AppFormFactor.desktop) {
      await openDialog(context);
    } else {
      await openSheet(context);
    }

    // Aggiorna le location selezionate
    final newLocationIds = current.toSet();

    // Se le location sono cambiate, rimuovi i servizi che non appartengono pi√π
    if (!setEquals(_selectedLocationIds, newLocationIds)) {
      // Carica i servizi per le nuove location
      final servicesResult = await ref.read(
        servicesForLocationsProvider(locationIdsToKey(newLocationIds)).future,
      );
      final validServiceIds = servicesResult.services.map((s) => s.id).toSet();

      // Rimuovi i servizi che non sono pi√π validi
      _selectedServiceIds.removeWhere((id) => !validServiceIds.contains(id));
    }

    setState(() {
      _selectedLocationIds
        ..clear()
        ..addAll(current);
      _locationsError = null;
      _isSelectingLocations = false;
    });
  }
}

class _SwitchTile extends StatelessWidget {
  const _SwitchTile({
    required this.title,
    required this.value,
    required this.onChanged,
  });

  final String title;
  final bool value;
  final ValueChanged<bool>? onChanged;

  @override
  Widget build(BuildContext context) {
    final titleStyle = Theme.of(context).textTheme.titleSmall;
    final borderRadius = AppButtonStyles.defaultBorderRadius;
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 5),
      decoration: BoxDecoration(
        border: Border.all(
          color: Theme.of(context).colorScheme.primary,
          width: 1.4,
        ),
        borderRadius: borderRadius,
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: onChanged == null ? null : () => onChanged!(!value),
          splashColor: Colors.transparent,
          hoverColor: Colors.transparent,
          highlightColor: Colors.transparent,
          child: Row(
            children: [
              Expanded(child: Text(title, style: titleStyle)),
              AppSwitch(value: value, onChanged: onChanged),
            ],
          ),
        ),
      ),
    );
  }
}

class _SelectableRow extends StatelessWidget {
  const _SelectableRow({
    required this.label,
    required this.selected,
    required this.onTap,
  });

  final String label;
  final bool selected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          child: Row(
            children: [
              Expanded(child: Text(label)),
              if (selected)
                Icon(
                  Icons.check,
                  color: Theme.of(context).colorScheme.primary,
                  size: 20,
                ),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/dialogs/resource_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../app/theme/app_spacing.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/resource.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';
import '../../../../core/network/network_providers.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/labeled_form_field.dart';
import '../../../agenda/providers/resource_providers.dart';
import '../../../services/providers/service_categories_provider.dart';
import '../../../services/providers/services_provider.dart';
import '../widgets/resource_service_picker.dart';

Future<void> showResourceDialog(
  BuildContext context,
  WidgetRef ref, {
  required int locationId,
  Resource? resource,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final isDesktop = formFactor == AppFormFactor.desktop;

  final dialog = _ResourceDialog(locationId: locationId, resource: resource);

  if (isDesktop) {
    await showDialog(context: context, builder: (_) => dialog);
  } else {
    await AppBottomSheet.show(
      context: context,
      builder: (_) => dialog,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      heightFactor: AppBottomSheet.defaultHeightFactor,
    );
  }
}

class _ResourceDialog extends ConsumerStatefulWidget {
  const _ResourceDialog({required this.locationId, this.resource});

  final int locationId;
  final Resource? resource;

  bool get isEditing => resource != null;

  @override
  ConsumerState<_ResourceDialog> createState() => _ResourceDialogState();
}

class _ResourceDialogState extends ConsumerState<_ResourceDialog> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _typeController = TextEditingController();
  final _noteController = TextEditingController();
  int _quantity = 1;
  bool _isSaving = false;

  // Servizi associati
  Set<int> _selectedServiceVariantIds = {};
  Set<int> _originalServiceVariantIds = {};
  bool _isLoadingServices = false;

  @override
  void initState() {
    super.initState();
    if (widget.resource != null) {
      _nameController.text = widget.resource!.name;
      _typeController.text = widget.resource!.type ?? '';
      _noteController.text = widget.resource!.note ?? '';
      _quantity = widget.resource!.quantity;
      _loadAssociatedServices();
    }
  }

  Future<void> _loadAssociatedServices() async {
    if (!widget.isEditing) return;

    setState(() => _isLoadingServices = true);
    try {
      final apiClient = ref.read(apiClientProvider);
      final response = await apiClient.getResourceServices(widget.resource!.id);
      final services = response['services'] as List? ?? [];
      final variantIds = <int>{};
      for (final s in services) {
        variantIds.add(s['service_variant_id'] as int);
      }
      setState(() {
        _selectedServiceVariantIds = variantIds;
        _originalServiceVariantIds = {...variantIds};
      });
    } catch (e) {
      // Ignora errori di caricamento
    } finally {
      if (mounted) {
        setState(() => _isLoadingServices = false);
      }
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _typeController.dispose();
    _noteController.dispose();
    super.dispose();
  }

  Future<void> _handleSave() async {
    if (!_formKey.currentState!.validate()) return;
    if (_isSaving) return;

    setState(() => _isSaving = true);

    try {
      final notifier = ref.read(resourcesProvider.notifier);
      int resourceId;

      if (widget.isEditing) {
        resourceId = widget.resource!.id;
        await notifier.updateResource(
          resourceId: resourceId,
          name: _nameController.text.trim(),
          type: _typeController.text.trim().isEmpty
              ? null
              : _typeController.text.trim(),
          quantity: _quantity,
          note: _noteController.text.trim().isEmpty
              ? null
              : _noteController.text.trim(),
        );
      } else {
        final newResource = await notifier.addResource(
          locationId: widget.locationId,
          name: _nameController.text.trim(),
          type: _typeController.text.trim().isEmpty
              ? null
              : _typeController.text.trim(),
          quantity: _quantity,
          note: _noteController.text.trim().isEmpty
              ? null
              : _noteController.text.trim(),
        );
        resourceId = newResource.id;
      }

      // Salva associazione servizi se modificata
      final servicesChanged = !_setEquals(
        _selectedServiceVariantIds,
        _originalServiceVariantIds,
      );
      if (servicesChanged) {
        final apiClient = ref.read(apiClientProvider);
        final servicesList = [
          for (final variantId in _selectedServiceVariantIds)
            {'service_variant_id': variantId, 'quantity': 1},
        ];
        await apiClient.setResourceServices(
          resourceId: resourceId,
          services: servicesList,
        );
      }

      if (mounted) {
        Navigator.of(context, rootNavigator: true).pop();
      }
    } finally {
      if (mounted) {
        setState(() => _isSaving = false);
      }
    }
  }

  bool _setEquals(Set<int> a, Set<int> b) {
    if (a.length != b.length) return false;
    for (final e in a) {
      if (!b.contains(e)) return false;
    }
    return true;
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final formFactor = ref.watch(formFactorProvider);
    final isDesktop = formFactor == AppFormFactor.desktop;
    final servicesAsync = ref.watch(servicesProvider);
    final services = servicesAsync.value ?? [];
    final categories = ref.watch(serviceCategoriesProvider);

    final title = widget.isEditing ? l10n.resourceEdit : l10n.resourceNew;

    final body = Form(
      key: _formKey,
      child: SingleChildScrollView(
        padding: const EdgeInsets.all(AppSpacing.large),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            LabeledFormField(
              label: l10n.resourceNameLabel,
              child: TextFormField(
                controller: _nameController,
                decoration: const InputDecoration(
                  border: OutlineInputBorder(),
                  isDense: true,
                ),
                validator: (v) => (v == null || v.trim().isEmpty)
                    ? l10n.validationRequired
                    : null,
                textCapitalization: TextCapitalization.sentences,
              ),
            ),
            const SizedBox(height: AppSpacing.formRowSpacing),
            LabeledFormField(
              label: l10n.resourceQuantityLabel,
              child: DropdownButtonFormField<int>(
                value: _quantity,
                decoration: const InputDecoration(
                  border: OutlineInputBorder(),
                  isDense: true,
                ),
                items: [
                  for (int i = 1; i <= 10; i++)
                    DropdownMenuItem(value: i, child: Text('$i')),
                ],
                onChanged: (v) => setState(() => _quantity = v ?? 1),
              ),
            ),
            const SizedBox(height: AppSpacing.formRowSpacing),
            LabeledFormField(
              label: l10n.resourceTypeLabel,
              child: TextFormField(
                controller: _typeController,
                decoration: const InputDecoration(
                  border: OutlineInputBorder(),
                  isDense: true,
                ),
                textCapitalization: TextCapitalization.sentences,
              ),
            ),
            const SizedBox(height: AppSpacing.formRowSpacing),
            LabeledFormField(
              label: l10n.resourceNoteLabel,
              child: TextFormField(
                controller: _noteController,
                maxLines: 3,
                decoration: const InputDecoration(
                  border: OutlineInputBorder(),
                  isDense: true,
                ),
                textCapitalization: TextCapitalization.sentences,
              ),
            ),
            // Sezione servizi associati
            if (services.isNotEmpty && categories.isNotEmpty) ...[
              const SizedBox(height: AppSpacing.large),
              const Divider(height: 1),
              const SizedBox(height: AppSpacing.medium),
              _buildServicesSection(context, services, categories, formFactor),
            ],
          ],
        ),
      ),
    );

    final actions = Row(
      mainAxisAlignment: MainAxisAlignment.end,
      children: [
        SizedBox(
          width: AppButtonStyles.dialogButtonWidth,
          child: AppOutlinedActionButton(
            onPressed: _isSaving
                ? null
                : () => Navigator.of(context, rootNavigator: true).pop(),
            padding: AppButtonStyles.dialogButtonPadding,
            child: Text(l10n.actionCancel),
          ),
        ),
        const SizedBox(width: 12),
        SizedBox(
          width: AppButtonStyles.dialogButtonWidth,
          child: AppAsyncFilledButton(
            onPressed: _isSaving ? null : _handleSave,
            isLoading: _isSaving,
            padding: AppButtonStyles.dialogButtonPadding,
            child: Text(l10n.actionSave),
          ),
        ),
      ],
    );

    if (isDesktop) {
      return Dialog(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 480, maxHeight: 600),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Padding(
                padding: const EdgeInsets.fromLTRB(24, 20, 24, 0),
                child: Text(
                  title,
                  style: Theme.of(context).textTheme.titleLarge,
                ),
              ),
              Flexible(child: body),
              Padding(
                padding: const EdgeInsets.fromLTRB(24, 0, 24, 20),
                child: actions,
              ),
            ],
          ),
        ),
      );
    }

    // Mobile bottom sheet
    return SafeArea(
      top: false,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(20, 16, 20, 0),
            child: Text(title, style: Theme.of(context).textTheme.titleLarge),
          ),
          Expanded(child: body),
          Padding(
            padding: const EdgeInsets.fromLTRB(20, 0, 20, 16),
            child: actions,
          ),
        ],
      ),
    );
  }

  Widget _buildServicesSection(
    BuildContext context,
    List<Service> services,
    List<ServiceCategory> categories,
    AppFormFactor formFactor,
  ) {
    final l10n = context.l10n;

    if (_isLoadingServices) {
      return const Center(
        child: Padding(
          padding: EdgeInsets.all(16),
          child: CircularProgressIndicator(),
        ),
      );
    }

    return LabeledFormField(
      label: l10n.resourceServicesLabel,
      child: ResourceServicePicker(
        services: services,
        categories: categories,
        selectedServiceVariantIds: _selectedServiceVariantIds,
        onSelectionChanged: (newSelection) {
          setState(() {
            _selectedServiceVariantIds = newSelection;
          });
        },
        formFactor: formFactor,
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/staff_planning_screen.dart ---
/*
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üéØ Staff Planning Screen - Gestione Planning Disponibilit√†
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

FLUSSO:
1. Seleziona staff dal dropdown
2. Vedi LISTA planning (evidenziato quello attivo oggi)
3. Click su planning ‚Üí Editor completo (tipo, date, orari)
4. "+" per aggiungere nuovo planning

*/

import 'package:agenda_backend/app/theme/extensions.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/staff.dart';
import 'package:agenda_backend/core/models/staff_planning.dart';
import 'package:agenda_backend/core/widgets/adaptive_dropdown.dart';
import 'package:agenda_backend/core/widgets/staff_picker_sheet.dart';
import 'package:agenda_backend/features/staff/presentation/dialogs/planning_editor_dialog.dart';
import 'package:agenda_backend/features/staff/providers/staff_planning_provider.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

class StaffPlanningScreen extends ConsumerStatefulWidget {
  const StaffPlanningScreen({super.key, this.initialStaffId});

  final int? initialStaffId;

  @override
  ConsumerState<StaffPlanningScreen> createState() =>
      _StaffPlanningScreenState();
}

class _StaffPlanningScreenState extends ConsumerState<StaffPlanningScreen> {
  int? _selectedStaffId;
  bool _initialSelectionDone = false;
  int? _selectedYear;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    if (widget.initialStaffId != null) {
      _selectedStaffId = widget.initialStaffId;
      _loadPlannings(widget.initialStaffId!);
    }
  }

  Future<void> _loadPlannings(int staffId) async {
    setState(() => _isLoading = true);
    await ref
        .read(staffPlanningsProvider.notifier)
        .loadPlanningsForStaff(staffId);
    if (mounted) {
      setState(() => _isLoading = false);
    }
  }

  void _onStaffSelected(int staffId) {
    setState(() => _selectedStaffId = staffId);
    _loadPlannings(staffId);
  }

  Future<void> _addPlanning() async {
    if (_selectedStaffId == null) return;

    // Passa i plannings esistenti per calcolare la data inizio
    final planningsMap = ref.read(staffPlanningsProvider);
    final existingPlannings =
        planningsMap[_selectedStaffId] ?? <StaffPlanning>[];

    final result = await showPlanningEditorDialog(
      context,
      ref,
      staffId: _selectedStaffId!,
      existingPlannings: existingPlannings,
    );

    if (result == true) {
      // Ricarica la lista
      _loadPlannings(_selectedStaffId!);
    }
  }

  Future<void> _editPlanning(StaffPlanning planning) async {
    final result = await showPlanningEditorDialog(
      context,
      ref,
      staffId: planning.staffId,
      planning: planning,
    );

    if (result == true) {
      // Ricarica la lista
      _loadPlannings(planning.staffId);
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final staffList = ref.watch(staffForStaffSectionProvider);
    final planningsMap = ref.watch(staffPlanningsProvider);

    // Auto-select first staff if none selected
    if (!_initialSelectionDone &&
        _selectedStaffId == null &&
        staffList.isNotEmpty) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _onStaffSelected(staffList.first.id);
        _initialSelectionDone = true;
      });
    }

    final selectedStaff = staffList
        .where((s) => s.id == _selectedStaffId)
        .firstOrNull;
    final allPlannings = _selectedStaffId != null
        ? (planningsMap[_selectedStaffId] ?? <StaffPlanning>[])
        : <StaffPlanning>[];

    // Calcola anni coperti dai planning
    final currentYear = DateTime.now().year;
    final yearsSet = <int>{currentYear}; // Includi sempre anno corrente
    for (final p in allPlannings) {
      yearsSet.add(p.validFrom.year);
      if (p.validTo != null) {
        yearsSet.add(p.validTo!.year);
      }
    }
    final availableYears = yearsSet.toList()
      ..sort((a, b) => b.compareTo(a)); // Decrescente

    // Imposta anno corrente di default se non selezionato
    final effectiveYear = _selectedYear ?? currentYear;

    // Filtra planning per anno selezionato
    // Un planning "cade dentro un anno" se:
    // validFrom.year <= anno E (validTo == null OR validTo.year >= anno)
    bool planningInYear(StaffPlanning p, int year) {
      if (p.validFrom.year > year) return false;
      if (p.validTo == null) return true;
      return p.validTo!.year >= year;
    }

    final filteredPlannings = allPlannings
        .where((p) => planningInYear(p, effectiveYear))
        .toList();

    // Ordina per data inizio, poi data fine
    int comparePlannings(StaffPlanning a, StaffPlanning b) {
      final cmp = a.validFrom.compareTo(b.validFrom);
      if (cmp != 0) return cmp;
      // Se validTo √® null, va dopo
      if (a.validTo == null && b.validTo == null) return 0;
      if (a.validTo == null) return 1;
      if (b.validTo == null) return -1;
      return a.validTo!.compareTo(b.validTo!);
    }

    filteredPlannings.sort(comparePlannings);

    return Scaffold(
      appBar: AppBar(
        actions: [
          if (_selectedStaffId != null)
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 8),
              child: Material(
                elevation: 0,
                color: theme.colorScheme.secondaryContainer,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
                clipBehavior: Clip.antiAlias,
                child: InkWell(
                  onTap: _addPlanning,
                  child: Padding(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 8,
                    ),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(
                          Icons.add,
                          size: 22,
                          color: theme.colorScheme.onSecondaryContainer,
                        ),
                        const SizedBox(width: 8),
                        Text(
                          l10n.planningListAdd,
                          style: TextStyle(
                            color: theme.colorScheme.onSecondaryContainer,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
        ],
      ),
      body: Column(
        children: [
          // ‚îÄ‚îÄ Staff Selector ‚îÄ‚îÄ
          _StaffSelector(
            staffList: staffList,
            selectedStaff: selectedStaff,
            onSelected: _onStaffSelected,
          ),

          const Divider(height: 1),

          // ‚îÄ‚îÄ Planning List ‚îÄ‚îÄ
          Expanded(
            child: _selectedStaffId == null
                ? Center(
                    child: Text(
                      l10n.selectStaffTitle,
                      style: theme.textTheme.bodyLarge?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                  )
                : _isLoading
                ? const Center(child: CircularProgressIndicator())
                : filteredPlannings.isEmpty && allPlannings.isEmpty
                ? _EmptyState(onAdd: _addPlanning)
                : _PlanningList(
                    plannings: filteredPlannings,
                    availableYears: availableYears,
                    selectedYear: effectiveYear,
                    onYearChanged: (year) =>
                        setState(() => _selectedYear = year),
                    onEdit: _editPlanning,
                    onAdd: _addPlanning,
                  ),
          ),
        ],
      ),
    );
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Staff Selector Widget
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class _StaffSelector extends ConsumerWidget {
  const _StaffSelector({
    required this.staffList,
    required this.selectedStaff,
    required this.onSelected,
  });

  final List<Staff> staffList;
  final Staff? selectedStaff;
  final ValueChanged<int> onSelected;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    return Material(
      color: theme.colorScheme.surfaceContainerLow,
      child: InkWell(
        onTap: () async {
          final selectedId = await showStaffPickerSheet(
            context: context,
            ref: ref,
            staff: staffList,
            selectedId: selectedStaff?.id,
          );
          if (selectedId != null) {
            onSelected(selectedId);
          }
        },
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          child: Row(
            children: [
              if (selectedStaff != null) ...[
                StaffCircleAvatar(
                  height: 36,
                  color: selectedStaff!.color,
                  isHighlighted: false,
                  initials: selectedStaff!.initials,
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        selectedStaff!.displayName,
                        style: theme.textTheme.titleMedium,
                      ),
                      Text(
                        l10n.selectStaffTitle,
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ],
                  ),
                ),
              ] else ...[
                Icon(
                  Icons.person_outline,
                  color: theme.colorScheme.onSurfaceVariant,
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                    l10n.selectStaffTitle,
                    style: theme.textTheme.bodyLarge?.copyWith(
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
                ),
              ],
              Icon(
                Icons.chevron_right,
                color: theme.colorScheme.onSurfaceVariant,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Empty State Widget
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class _EmptyState extends StatelessWidget {
  const _EmptyState({required this.onAdd});

  final VoidCallback onAdd;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.calendar_month_outlined,
              size: 64,
              color: theme.colorScheme.onSurfaceVariant.withOpacity(0.5),
            ),
            const SizedBox(height: 16),
            Text(
              l10n.planningListEmpty,
              style: theme.textTheme.titleMedium?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Aggiungi un planning per definire gli orari di lavoro',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 24),
            FilledButton.icon(
              onPressed: onAdd,
              icon: const Icon(Icons.add),
              label: Text(l10n.planningListAdd),
            ),
          ],
        ),
      ),
    );
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Planning List Widget
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class _PlanningList extends ConsumerStatefulWidget {
  const _PlanningList({
    required this.plannings,
    required this.availableYears,
    required this.selectedYear,
    required this.onYearChanged,
    required this.onEdit,
    required this.onAdd,
  });

  final List<StaffPlanning> plannings;
  final List<int> availableYears;
  final int selectedYear;
  final ValueChanged<int> onYearChanged;
  final ValueChanged<StaffPlanning> onEdit;
  final VoidCallback onAdd;

  @override
  ConsumerState<_PlanningList> createState() => _PlanningListState();
}

class _PlanningListState extends ConsumerState<_PlanningList> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final interactions = theme.extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = _isHovered
        ? Color.alphaBlend(hoverFill, colorScheme.surface)
        : colorScheme.surface;

    return Column(
      children: [
        // Filtro anno
        if (widget.availableYears.length > 1)
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
            child: Row(
              children: [
                AdaptiveDropdown<int>(
                  items: widget.availableYears.map((year) {
                    return AdaptiveDropdownItem(
                      value: year,
                      child: Text(year.toString()),
                    );
                  }).toList(),
                  selectedValue: widget.selectedYear,
                  onSelected: widget.onYearChanged,
                  modalTitle: 'Anno',
                  useRootNavigator: true,
                  onOpened: () => setState(() => _isHovered = true),
                  onClosed: () => setState(() => _isHovered = false),
                  popupWidth: 100,
                  child: MouseRegion(
                    onEnter: (_) {
                      if (!_isHovered) setState(() => _isHovered = true);
                    },
                    onExit: (_) {
                      if (_isHovered) setState(() => _isHovered = false);
                    },
                    child: Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 12,
                        vertical: 8,
                      ),
                      decoration: BoxDecoration(
                        color: backgroundColor,
                        borderRadius: BorderRadius.circular(8),
                        border: Border.all(
                          color: colorScheme.outline.withOpacity(0.2),
                        ),
                      ),
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(
                            Icons.calendar_today,
                            size: 18,
                            color: colorScheme.onSurfaceVariant,
                          ),
                          const SizedBox(width: 8),
                          Text(
                            widget.selectedYear.toString(),
                            style: theme.textTheme.bodyMedium?.copyWith(
                              color: colorScheme.onSurface,
                            ),
                          ),
                          const SizedBox(width: 8),
                          Icon(
                            Icons.keyboard_arrow_down,
                            size: 20,
                            color: colorScheme.onSurfaceVariant,
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
                const Spacer(),
              ],
            ),
          ),

        // Lista planning
        Expanded(
          child: widget.plannings.isEmpty
              ? Center(
                  child: Text(
                    'Nessun planning per ${widget.selectedYear}',
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
                )
              : ListView.builder(
                  padding: const EdgeInsets.all(16),
                  itemCount: widget.plannings.length,
                  itemBuilder: (context, index) {
                    final planning = widget.plannings[index];
                    return _PlanningCard(
                      planning: planning,
                      onTap: () => widget.onEdit(planning),
                    );
                  },
                ),
        ),
      ],
    );
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Planning Card Widget
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class _PlanningCard extends StatelessWidget {
  const _PlanningCard({required this.planning, required this.onTap});

  final StaffPlanning planning;
  final VoidCallback onTap;

  /// Calcola minuti settimanali da un template.
  int _calculateWeeklyMinutes(
    StaffPlanningWeekTemplate? template, {
    int minutesPerSlot = 15,
  }) {
    if (template == null) return 0;
    int totalMinutes = 0;
    for (final daySlots in template.daySlots.values) {
      totalMinutes += daySlots.length * minutesPerSlot;
    }
    return totalMinutes;
  }

  String _formatDuration(BuildContext context, int totalMinutes) {
    final h = totalMinutes ~/ 60;
    final m = totalMinutes % 60;
    if (m == 0) return context.l10n.hoursHoursOnly(h);
    return context.l10n.hoursMinutesCompact(h, m);
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final today = DateTime.now();
    final isActive = planning.isValidForDate(today);
    final isExpired =
        planning.validTo != null && planning.validTo!.isBefore(today);
    final isFuture = planning.validFrom.isAfter(today);
    final dateFormat = DateFormat('d MMM yyyy', 'it');

    // Calcola stato
    String status;
    Color statusColor;
    if (isActive) {
      status = 'Attivo';
      statusColor = theme.colorScheme.primary;
    } else if (isFuture) {
      status = 'Futuro';
      statusColor = theme.colorScheme.tertiary;
    } else {
      status = 'Scaduto';
      statusColor = theme.colorScheme.onSurfaceVariant;
    }

    // Calcola ore settimanali (serve prima per determinare il tipo label)
    final minutesA = _calculateWeeklyMinutes(
      planning.templateA,
      minutesPerSlot: planning.planningSlotMinutes,
    );
    final minutesB = _calculateWeeklyMinutes(
      planning.templateB,
      minutesPerSlot: planning.planningSlotMinutes,
    );
    final totalMinutes = minutesA + minutesB;

    // Tipo planning: se 0 ore mostra "Non disponibile"
    final String typeLabel;
    final IconData typeIcon;
    if (totalMinutes == 0) {
      typeLabel = l10n.planningTypeUnavailable;
      typeIcon = Icons.event_busy_outlined;
    } else if (planning.type == StaffPlanningType.weekly) {
      typeLabel = l10n.planningTypeWeekly;
      typeIcon = Icons.view_week_outlined;
    } else {
      typeLabel = l10n.planningTypeBiweekly;
      typeIcon = Icons.date_range_outlined;
    }

    // Periodo validit√†
    final validFromStr = dateFormat.format(planning.validFrom);
    final validityText = planning.validTo != null
        ? l10n.planningValidFromTo(
            validFromStr,
            dateFormat.format(planning.validTo!),
          )
        : l10n.planningValidFromOnly(validFromStr);

    String hoursText;
    if (planning.type == StaffPlanningType.weekly) {
      hoursText = l10n.planningWeeklyDuration(
        _formatDuration(context, minutesA),
      );
    } else {
      hoursText = l10n.planningBiweeklyDuration(
        _formatDuration(context, minutesA),
        _formatDuration(context, minutesB),
        _formatDuration(context, totalMinutes),
      );
    }

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      clipBehavior: Clip.antiAlias,
      elevation: isActive ? 2 : 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: isActive
            ? BorderSide(color: theme.colorScheme.primary, width: 2)
            : BorderSide(color: theme.colorScheme.outlineVariant),
      ),
      child: InkWell(
        onTap: onTap,
        child: Opacity(
          opacity: isExpired ? 0.6 : 1.0,
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Header: tipo + stato
                Row(
                  children: [
                    Icon(
                      typeIcon,
                      size: 20,
                      color: isActive
                          ? theme.colorScheme.primary
                          : theme.colorScheme.onSurfaceVariant,
                    ),
                    const SizedBox(width: 8),
                    Text(
                      typeLabel,
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w600,
                        color: isActive ? theme.colorScheme.primary : null,
                      ),
                    ),
                    const Spacer(),
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 8,
                        vertical: 4,
                      ),
                      decoration: BoxDecoration(
                        color: statusColor.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(4),
                      ),
                      child: Text(
                        status,
                        style: theme.textTheme.labelSmall?.copyWith(
                          color: statusColor,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                  ],
                ),

                const SizedBox(height: 12),

                // Periodo validit√† - "Valida dal ... al ..."
                Row(
                  children: [
                    Icon(
                      Icons.calendar_today_outlined,
                      size: 16,
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: planning.validTo != null
                          ? Text(
                              validityText,
                              style: theme.textTheme.bodyMedium,
                            )
                          : Row(
                              children: [
                                Text(
                                  validityText,
                                  style: theme.textTheme.bodyMedium,
                                ),
                                const SizedBox(width: 8),
                                Icon(
                                  Icons.all_inclusive,
                                  size: 16,
                                  color: theme.colorScheme.onSurfaceVariant,
                                ),
                                const SizedBox(width: 4),
                                Text(
                                  l10n.planningOpenEnded,
                                  style: theme.textTheme.bodyMedium?.copyWith(
                                    color: theme.colorScheme.onSurfaceVariant,
                                  ),
                                ),
                              ],
                            ),
                    ),
                  ],
                ),

                const SizedBox(height: 8),

                // Ore settimanali
                Row(
                  children: [
                    Icon(
                      Icons.schedule_outlined,
                      size: 16,
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        hoursText,
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ),
                    Icon(
                      Icons.edit_outlined,
                      size: 18,
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/staff_week_overview_screen.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:agenda_backend/core/l10n/date_time_formats.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/availability_exception.dart';
import 'package:agenda_backend/core/models/staff_planning.dart' hide DateUtils;
import 'package:agenda_backend/core/services/staff_planning_selector.dart';
import 'package:agenda_backend/core/widgets/app_bottom_sheet.dart';
import 'package:agenda_backend/core/widgets/app_buttons.dart';
import 'package:agenda_backend/core/widgets/app_dialogs.dart';
import 'package:agenda_backend/core/widgets/no_scrollbar_behavior.dart';
import 'package:agenda_backend/features/agenda/domain/config/agenda_theme.dart';
import 'package:agenda_backend/features/agenda/providers/date_range_provider.dart';
import 'package:agenda_backend/features/agenda/providers/location_providers.dart';
import 'package:agenda_backend/features/staff/presentation/dialogs/add_exception_dialog.dart';
import 'package:agenda_backend/features/staff/presentation/staff_planning_screen.dart';
import 'package:agenda_backend/features/staff/providers/availability_exceptions_provider.dart';
import 'package:agenda_backend/features/staff/providers/staff_planning_provider.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:agenda_backend/features/staff/providers/staff_weekly_availability_provider.dart';
import 'package:agenda_backend/features/staff/widgets/staff_top_controls.dart';
import 'package:agenda_backend/features/auth/providers/current_business_user_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

const int _weeklyOverviewDefaultMinutesPerSlot = 15;

int _planningSlotMinutesFromLookup(PlanningLookupResult lookup) {
  if (lookup is PlanningFound) {
    final minutes = lookup.planning.planningSlotMinutes;
    if (minutes > 0) return minutes;
  }
  return _weeklyOverviewDefaultMinutesPerSlot;
}

// Lightweight range used only for the overview chips
class HourRange {
  final int startHour;
  final int startMinute;
  final int endHour;
  final int endMinute;
  const HourRange(
    this.startHour,
    this.startMinute,
    this.endHour,
    this.endMinute,
  );

  int get minutes =>
      (endHour * 60 + endMinute) - (startHour * 60 + startMinute);
  String label(BuildContext context) =>
      '${DtFmt.hm(context, startHour, startMinute)} - ${DtFmt.hm(context, endHour, endMinute)}';
}

class _DisplayRange {
  _DisplayRange({
    required this.startMinutes,
    required this.endMinutes,
    required this.label,
    required this.isException,
    this.exceptionType,
    this.hourRange,
  });

  final int startMinutes;
  final int endMinutes;
  final String label;
  final bool isException;
  final AvailabilityExceptionType? exceptionType;
  final HourRange? hourRange;
}

class _DashedRoundedRectPainter extends CustomPainter {
  _DashedRoundedRectPainter({required this.color, required this.radius});

  final Color color;
  final double radius;

  @override
  void paint(Canvas canvas, Size size) {
    const strokeWidth = 0.6;
    const dashLength = 4.0;
    const gapLength = 3.0;
    final rect = Offset.zero & size;
    final rrect = RRect.fromRectAndRadius(rect, Radius.circular(radius));
    final path = Path()..addRRect(rrect);
    final paint = Paint()
      ..color = color
      ..strokeWidth = strokeWidth
      ..style = PaintingStyle.stroke;

    for (final metric in path.computeMetrics()) {
      var distance = 0.0;
      while (distance < metric.length) {
        final next = (distance + dashLength).clamp(0.0, metric.length);
        canvas.drawPath(metric.extractPath(distance, next), paint);
        distance += dashLength + gapLength;
      }
    }
  }

  @override
  bool shouldRepaint(covariant _DashedRoundedRectPainter oldDelegate) {
    return oldDelegate.color != color || oldDelegate.radius != radius;
  }
}

List<_DisplayRange> _mergeRangesForDisplay(
  List<HourRange> baseRanges,
  List<AvailabilityException> exceptions,
  BuildContext context, {
  bool applyUnavailableSplit = true,
  bool subtractAvailableFromBase = false,
}) {
  final items = <_DisplayRange>[];

  final availableToSubtract = subtractAvailableFromBase
      ? exceptions
            .where(
              (e) =>
                  e.type == AvailabilityExceptionType.available &&
                  e.startTime != null &&
                  e.endTime != null,
            )
            .map<({int start, int end})>(
              (e) => (
                start: e.startTime!.hour * 60 + e.startTime!.minute,
                end: e.endTime!.hour * 60 + e.endTime!.minute,
              ),
            )
            .toList()
      : const <({int start, int end})>[];

  final unavailable = applyUnavailableSplit
      ? exceptions
            .where(
              (e) =>
                  e.type == AvailabilityExceptionType.unavailable &&
                  e.startTime != null &&
                  e.endTime != null,
            )
            .map<({int start, int end})>(
              (e) => (
                start: e.startTime!.hour * 60 + e.startTime!.minute,
                end: e.endTime!.hour * 60 + e.endTime!.minute,
              ),
            )
            .toList()
      : const <({int start, int end})>[];

  for (final r in baseRanges) {
    final baseStart = r.startHour * 60 + r.startMinute;
    final baseEnd = r.endHour * 60 + r.endMinute;
    var segments = <({int start, int end})>[(start: baseStart, end: baseEnd)];

    if (availableToSubtract.isNotEmpty) {
      for (final a in availableToSubtract) {
        final next = <({int start, int end})>[];
        for (final seg in segments) {
          if (a.end <= seg.start || a.start >= seg.end) {
            next.add(seg);
            continue;
          }
          if (a.start > seg.start) {
            final leftEnd = a.start < seg.end ? a.start : seg.end;
            if (leftEnd > seg.start) {
              next.add((start: seg.start, end: leftEnd));
            }
          }
          if (a.end < seg.end) {
            final rightStart = a.end > seg.start ? a.end : seg.start;
            if (seg.end > rightStart) {
              next.add((start: rightStart, end: seg.end));
            }
          }
        }
        segments = next;
        if (segments.isEmpty) break;
      }
    }

    if (unavailable.isNotEmpty) {
      for (final u in unavailable) {
        final next = <({int start, int end})>[];
        for (final seg in segments) {
          if (u.end <= seg.start || u.start >= seg.end) {
            next.add(seg);
            continue;
          }
          if (u.start > seg.start) {
            final leftEnd = u.start < seg.end ? u.start : seg.end;
            if (leftEnd > seg.start) {
              next.add((start: seg.start, end: leftEnd));
            }
          }
          if (u.end < seg.end) {
            final rightStart = u.end > seg.start ? u.end : seg.start;
            if (seg.end > rightStart) {
              next.add((start: rightStart, end: seg.end));
            }
          }
        }
        segments = next;
        if (segments.isEmpty) break;
      }
    }

    for (final seg in segments) {
      final isAllDay = seg.start == 0 && seg.end == 24 * 60;
      final label = isAllDay
          ? context.l10n.exceptionAllDay
          : '${DtFmt.hm(context, seg.start ~/ 60, seg.start % 60)} - ${DtFmt.hm(context, seg.end ~/ 60, seg.end % 60)}';
      items.add(
        _DisplayRange(
          startMinutes: seg.start,
          endMinutes: seg.end,
          label: label,
          isException: false,
          exceptionType: null,
          hourRange: HourRange(
            seg.start ~/ 60,
            seg.start % 60,
            seg.end ~/ 60,
            seg.end % 60,
          ),
        ),
      );
    }
  }

  final allDayExceptions = exceptions.where(
    (e) => e.startTime == null && e.endTime == null,
  );
  for (final e in allDayExceptions) {
    items.add(
      _DisplayRange(
        startMinutes: 0,
        endMinutes: 24 * 60,
        label: context.l10n.exceptionAllDay,
        isException: true,
        exceptionType: e.type,
        hourRange: const HourRange(0, 0, 24, 0),
      ),
    );
  }

  for (final e in exceptions) {
    if (e.startTime == null || e.endTime == null) continue;
    final label =
        '${DtFmt.hm(context, e.startTime!.hour, e.startTime!.minute)} - ${DtFmt.hm(context, e.endTime!.hour, e.endTime!.minute)}';
    items.add(
      _DisplayRange(
        startMinutes: e.startTime!.hour * 60 + e.startTime!.minute,
        endMinutes: e.endTime!.hour * 60 + e.endTime!.minute,
        label: label,
        isException: true,
        exceptionType: e.type,
        hourRange: HourRange(
          e.startTime!.hour,
          e.startTime!.minute,
          e.endTime!.hour,
          e.endTime!.minute,
        ),
      ),
    );
  }

  // De-duplicate exact same ranges, prefer exception styling if present.
  final Map<String, _DisplayRange> unique = {};
  for (final item in items) {
    final key = '${item.startMinutes}-${item.endMinutes}';
    final existing = unique[key];
    if (existing == null) {
      unique[key] = item;
      continue;
    }
    if (!existing.isException && item.isException) {
      unique[key] = item;
    }
  }

  final result = unique.values.toList()
    ..sort((a, b) => a.startMinutes.compareTo(b.startMinutes));
  return result;
}

int _countSegmentsForDay(
  BuildContext context,
  List<HourRange> ranges,
  List<AvailabilityException> exceptions,
) {
  final displayRanges = _mergeRangesForDisplay(
    ranges,
    exceptions,
    context,
    applyUnavailableSplit: false,
    subtractAvailableFromBase: true,
  );
  return displayRanges.length;
}

/// Real data bridge: maps the editor's weekly availability (per day) to
/// the overview shape, including exceptions for the specific week being displayed.
///
/// La disponibilit√† finale per ogni giorno √® calcolata come:
/// 1. Base: template settimanale (es. Lun-Ven 09:00-18:00)
/// 2. + Eccezioni "available": aggiungono slot disponibili
/// 3. - Eccezioni "unavailable": rimuovono slot disponibili
class WeeklyExceptionsLoadKeyNotifier extends Notifier<String?> {
  @override
  String? build() => null;

  void setKey(String? value) => state = value;
}

final weeklyExceptionsLoadKeyProvider =
    NotifierProvider<WeeklyExceptionsLoadKeyNotifier, String?>(
      WeeklyExceptionsLoadKeyNotifier.new,
    );

final weeklyStaffAvailabilityFromEditorProvider =
    Provider<Map<int, Map<int, List<HourRange>>>>((ref) {
      final staffList = ref.watch(staffForStaffSectionProvider);

      // Ottieni la data corrente dell'agenda per calcolare la settimana mostrata
      final agendaDate = ref.watch(agendaDateProvider);
      final monday = _mondayOfWeek(agendaDate);

      List<HourRange> slotsToHourRanges(Set<int> slots, int minutesPerSlot) {
        if (slots.isEmpty) return const [];
        final sorted = slots.toList()..sort();
        final List<List<int>> clusters = [];
        var current = <int>[sorted.first];
        for (int i = 1; i < sorted.length; i++) {
          if (sorted[i] == sorted[i - 1] + 1) {
            current.add(sorted[i]);
          } else {
            clusters.add(current);
            current = <int>[sorted[i]];
          }
        }
        clusters.add(current);

        final List<HourRange> ranges = [];
        for (final c in clusters) {
          final startMin = c.first * minutesPerSlot;
          // La fine √® l'inizio dell'ultimo slot + la durata di uno slot
          final endMin = (c.last + 1) * minutesPerSlot;
          final sh = startMin ~/ 60;
          final sm = startMin % 60;
          final eh = endMin ~/ 60;
          final em = endMin % 60;
          ranges.add(HourRange(sh, sm, eh, em));
        }
        return ranges;
      }

      // Build per-staff availability with exceptions applied for each specific date
      final Map<int, Map<int, List<HourRange>>> result = {};

      for (final s in staffList) {
        // Triggera il caricamento automatico dei planning se non gi√† caricati
        ref.watch(ensureStaffPlanningLoadedProvider(s.id));

        final Map<int, List<HourRange>> staffWeek = {};

        for (int d = 1; d <= 7; d++) {
          // Calcola la data specifica per questo giorno della settimana
          final specificDate = monday.add(Duration(days: d - 1));

          final planningLookup = ref.watch(
            planningForStaffOnDateProvider((staffId: s.id, date: specificDate)),
          );
          final minutesPerSlot = _planningSlotMinutesFromLookup(planningLookup);
          final totalSlots = (24 * 60) ~/ minutesPerSlot;

          // 1Ô∏è‚É£ BASE: Planning per la data specifica (supporta biweekly e validit√† temporale)
          final Set<int> baseSlots = switch (planningLookup) {
            NoPlanningFound() => <int>{},
            PlanningFound(template: final template) => template.getSlotsForDay(
              specificDate.weekday,
            ),
            MultiplePlanningsFound() => <int>{},
          };

          // 2Ô∏è‚É£ ECCEZIONI: Applica modifiche per la data specifica
          final exceptions = ref.watch(
            exceptionsForStaffOnDateProvider((
              staffId: s.id,
              date: specificDate,
            )),
          );

          if (exceptions.isEmpty) {
            staffWeek[d] = slotsToHourRanges(baseSlots, minutesPerSlot);
          } else {
            // Applica le eccezioni in ordine
            Set<int> finalSlots = Set<int>.from(baseSlots);

            for (final exception in exceptions) {
              final exceptionSlots = exception.toSlotIndices(
                minutesPerSlot: minutesPerSlot,
                totalSlotsPerDay: totalSlots,
              );

              if (exception.type == AvailabilityExceptionType.available) {
                // AGGIUNGE disponibilit√† (es. turno extra)
                finalSlots = finalSlots.union(exceptionSlots);
              } else {
                // RIMUOVE disponibilit√† (es. ferie, malattia)
                finalSlots = finalSlots.difference(exceptionSlots);
              }
            }

            staffWeek[d] = slotsToHourRanges(finalSlots, minutesPerSlot);
          }
        }

        result[s.id] = staffWeek;
      }

      return result;
    });

/// Provider che fornisce la disponibilit√† BASE (dal planning) senza eccezioni.
/// Usato per confrontare con la disponibilit√† effettiva e identificare i turni modificati.
final weeklyStaffBaseAvailabilityProvider =
    Provider<Map<int, Map<int, List<HourRange>>>>((ref) {
      final staffList = ref.watch(staffForStaffSectionProvider);
      final agendaDate = ref.watch(agendaDateProvider);
      final monday = _mondayOfWeek(agendaDate);

      List<HourRange> slotsToHourRanges(Set<int> slots, int minutesPerSlot) {
        if (slots.isEmpty) return const [];
        final sorted = slots.toList()..sort();
        final List<List<int>> clusters = [];
        var current = <int>[sorted.first];
        for (int i = 1; i < sorted.length; i++) {
          if (sorted[i] == sorted[i - 1] + 1) {
            current.add(sorted[i]);
          } else {
            clusters.add(current);
            current = <int>[sorted[i]];
          }
        }
        clusters.add(current);

        final List<HourRange> ranges = [];
        for (final c in clusters) {
          final startMin = c.first * minutesPerSlot;
          final endMin = (c.last + 1) * minutesPerSlot;
          final sh = startMin ~/ 60;
          final sm = startMin % 60;
          final eh = endMin ~/ 60;
          final em = endMin % 60;
          ranges.add(HourRange(sh, sm, eh, em));
        }
        return ranges;
      }

      final Map<int, Map<int, List<HourRange>>> result = {};

      for (final s in staffList) {
        // Triggera il caricamento automatico dei planning se non gi√† caricati
        ref.watch(ensureStaffPlanningLoadedProvider(s.id));

        final Map<int, List<HourRange>> staffWeek = {};

        for (int d = 1; d <= 7; d++) {
          final specificDate = monday.add(Duration(days: d - 1));
          final planningLookup = ref.watch(
            planningForStaffOnDateProvider((staffId: s.id, date: specificDate)),
          );
          final minutesPerSlot = _planningSlotMinutesFromLookup(planningLookup);
          final Set<int> baseSlots = switch (planningLookup) {
            NoPlanningFound() => <int>{},
            PlanningFound(template: final template) => template.getSlotsForDay(
              specificDate.weekday,
            ),
            MultiplePlanningsFound() => <int>{},
          };
          staffWeek[d] = slotsToHourRanges(baseSlots, minutesPerSlot);
        }

        result[s.id] = staffWeek;
      }

      return result;
    });

/// Provider che traccia quali giorni della settimana hanno eccezioni per ogni staff.
/// Ritorna: `Map<staffId, Set<weekday>>` dove weekday = 1..7
final weeklyExceptionDaysProvider = Provider<Map<int, Set<int>>>((ref) {
  final staffList = ref.watch(staffForStaffSectionProvider);
  final agendaDate = ref.watch(agendaDateProvider);
  // ‚ö†Ô∏è RIMOSSO: Il caricamento delle eccezioni causa loop infinito
  // Le eccezioni vengono caricate on-demand in ExceptionCalendarView
  // _ensureExceptionsLoadedForWeekWithKey(...)
  final monday = _mondayOfWeek(agendaDate);

  final Map<int, Set<int>> result = {};

  for (final s in staffList) {
    final Set<int> daysWithExceptions = {};

    for (int d = 1; d <= 7; d++) {
      final specificDate = monday.add(Duration(days: d - 1));
      final exceptions = ref.watch(
        exceptionsForStaffOnDateProvider((staffId: s.id, date: specificDate)),
      );

      if (exceptions.isNotEmpty) {
        daysWithExceptions.add(d);
      }
    }

    result[s.id] = daysWithExceptions;
  }

  return result;
});

DateTime _mondayOfWeek(DateTime date) {
  final d = DateTime(date.year, date.month, date.day);
  return d.subtract(Duration(days: d.weekday - DateTime.monday));
}

String _dayHeaderLabel(BuildContext context, DateTime day) {
  final locale = Intl.getCurrentLocale();
  return DateFormat('EEE, d MMM', locale).format(day);
}

int _totalMinutesForDay(Iterable<List<HourRange>> rangesPerStaff) {
  int total = 0;
  for (final list in rangesPerStaff) {
    for (final r in list) {
      total += r.minutes;
    }
  }
  return total;
}

int _totalMinutesForStaff(Map<int, List<HourRange>> byDay) {
  int total = 0;
  for (final list in byDay.values) {
    for (final r in list) {
      total += r.minutes;
    }
  }
  return total;
}

String _formatTotalHM(BuildContext context, int minutes) {
  if (minutes == 0) return '';
  final h = minutes ~/ 60;
  final m = minutes % 60;
  if (m == 0) return context.l10n.hoursHoursOnly(h);
  return context.l10n.hoursMinutesCompact(h, m);
}

class StaffWeekOverviewScreen extends ConsumerStatefulWidget {
  const StaffWeekOverviewScreen({super.key});

  @override
  ConsumerState<StaffWeekOverviewScreen> createState() =>
      _StaffWeekOverviewScreenState();
}

class _StaffWeekOverviewScreenState
    extends ConsumerState<StaffWeekOverviewScreen> {
  // Inizializzazione immediata per evitare LateInitializationError
  final ScrollController _headerHController = ScrollController();
  final ScrollController _bodyHController = ScrollController();
  final ScrollController _vScrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      final selectedStaffSectionLocation = ref.read(
        staffSectionLocationIdProvider,
      );
      // Se l'utente ha gi√† una selezione (incluso "Tutte le sedi"), non forzare.
      if (selectedStaffSectionLocation != null) return;

      final currentLocationId = ref.read(currentLocationIdProvider);
      if (currentLocationId <= 0) return;

      final locations = ref.read(locationsProvider);
      final exists = locations.any((location) => location.id == currentLocationId);
      if (!exists) return; // fallback implicito: "Tutte le sedi" (null)

      ref.read(staffSectionLocationIdProvider.notifier).set(currentLocationId);
    });

    // Sync header position from body only (unidirectional) per evitare conflitti di inerzia.
    _bodyHController.addListener(() {
      if (!_bodyHController.hasClients) return;
      final off = _bodyHController.offset;
      if (_headerHController.hasClients && _headerHController.offset != off) {
        // jumpTo √® immediato: per una transizione pi√π fluida si potrebbe usare animateTo con durata breve.
        _headerHController.jumpTo(off);
      }
    });
  }

  @override
  void dispose() {
    _headerHController.dispose();
    _bodyHController.dispose();
    _vScrollController.dispose();
    super.dispose();
  }

  // Caricamento eccezioni gestito dai provider

  @override
  Widget build(BuildContext context) {
    // Data sources
    final selectedDate = ref.watch(agendaDateProvider);
    final canManageStaff = ref.watch(currentUserCanManageStaffProvider);
    final currentUserRole = ref.watch(currentUserRoleProvider);
    final currentUserStaffId = ref.watch(currentUserStaffIdProvider);
    final canEditAvailability =
        canManageStaff ||
        currentUserRole == 'manager' ||
        (currentUserRole == 'staff' &&
            currentUserStaffId != null &&
            currentUserStaffId > 0);
    // Current location could influence future filtering (kept for clarity)
    // final location = ref.watch(currentLocationProvider); // not used yet
    final staffList = ref.watch(staffForStaffSectionProvider);
    // Use real availability coming from the editor provider, mapped to overview ranges
    final availability = ref.watch(weeklyStaffAvailabilityFromEditorProvider);
    // Track which staff/day combinations have exceptions applied
    final exceptionDays = ref.watch(weeklyExceptionDaysProvider);
    final formFactor = ref.watch(formFactorProvider);
    // ‚ö†Ô∏è RIMOSSO: Il caricamento delle eccezioni causa loop infinito
    // Le eccezioni vengono caricate on-demand in ExceptionCalendarView
    // _ensureExceptionsLoadedForWeekWithKey(...)

    // Week days (Mon..Sun)
    final weekStart = _mondayOfWeek(selectedDate);
    final days = [for (int i = 0; i < 7; i++) weekStart.add(Duration(days: i))];

    // Week label builder: include year on boundaries
    String buildWeekRangeLabel() {
      final weekEnd = weekStart.add(const Duration(days: 6));
      final locale = Intl.getCurrentLocale();
      final sameMonth =
          weekStart.month == weekEnd.month && weekStart.year == weekEnd.year;
      final sameYear = weekStart.year == weekEnd.year;

      if (sameMonth) {
        final startDay = DateFormat('d', locale).format(weekStart);
        final endDay = DateFormat('d', locale).format(weekEnd);
        final endMonthShort = DateFormat('MMM', locale).format(weekEnd);
        return '$startDay‚Äì$endDay $endMonthShort';
      }
      if (sameYear) {
        final startDay = DateFormat('d', locale).format(weekStart);
        final endDay = DateFormat('d', locale).format(weekEnd);
        final startMonthShort = DateFormat('MMM', locale).format(weekStart);
        final endMonthShort = DateFormat('MMM', locale).format(weekEnd);
        return '$startDay $startMonthShort ‚Äì $endDay $endMonthShort';
      }
      final startFull = DateFormat('d MMM y', locale).format(weekStart);
      final endFull = DateFormat('d MMM y', locale).format(weekEnd);
      return '$startFull ‚Äì $endFull';
    }

    final weekLabel = buildWeekRangeLabel();
    final weekEnd = weekStart.add(const Duration(days: 6));
    final todayDate = DateUtils.dateOnly(DateTime.now());
    //final isTodayInWeek =
    !todayDate.isBefore(weekStart) && !todayDate.isAfter(weekEnd);
    //final effectivePickerDate = isTodayInWeek ? todayDate : weekEnd;

    // Layout constants - responsive per mobile
    final isMobileLayout = formFactor == AppFormFactor.mobile;
    final staffColWidth = isMobileLayout ? 120.0 : 200.0;
    final headerHeight = 60.0;
    const chipColor = Color(0xFFECEBFF);
    const chipColorWithException = Color(
      0xFFFFE4B5,
    ); // Moccasin - colore arancione chiaro per eccezioni
    const chipColorWithAvailableException = Color(0xFFDFF5D8);
    const chipTextColorWithAvailableException = Color(0xFF0F6A36);
    const chipDisabledTextColor = Color(0xFF6B6B6B);
    const double chipHeight = 40.0;
    const double chipVGap = 3.0;
    const double chipTopPadding = 4.0;
    const double baseRowHeight = chipHeight * 2 + (chipVGap * 3) + 36.0;
    const double staffRowGap = 24.0;
    const double dayColumnWidth = 100.0;
    const double rightPadding = 5.0;
    final dividerColor = Colors.transparent; // vertical separators
    final divider = Container(height: 0.5, color: dividerColor);
    // Controller gi√† inizializzati in state

    Widget buildDayHeaderCell(DateTime day) {
      final dayIndex = day.weekday; // 1..7
      final totalMin = _totalMinutesForDay(
        availability.values.map((byDay) {
          return byDay[dayIndex] ?? const <HourRange>[];
        }),
      );
      final hasAny = totalMin > 0;
      // Center widget per centrare l'header nella colonna
      return Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(minWidth: dayColumnWidth),
          child: Container(
            height: headerHeight,
            padding: const EdgeInsets.symmetric(horizontal: 10),
            decoration: BoxDecoration(
              color: AgendaTheme.staffHeaderBackground(
                hasAny ? Colors.teal : Colors.blueGrey,
              ),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  _dayHeaderLabel(context, day),
                  style: AgendaTheme.staffHeaderTextStyle,
                  textAlign: TextAlign.center,
                ),
                if (hasAny)
                  Padding(
                    padding: const EdgeInsets.only(top: 2),
                    child: Text(
                      _formatTotalHM(context, totalMin),
                      style: Theme.of(context).textTheme.labelSmall?.copyWith(
                        color: Colors.black87,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
              ],
            ),
          ),
        ),
      );
    }

    double rowHeightForStaff(int staffId) {
      int maxRanges = 0;
      for (final d in days) {
        final exceptions = ref.watch(
          exceptionsForStaffOnDateProvider((staffId: staffId, date: d)),
        );
        final dayRanges =
            availability[staffId]?[d.weekday] ?? const <HourRange>[];
        var count = _countSegmentsForDay(context, dayRanges, exceptions);
        if (count == 0) count = 1;
        if (count > maxRanges) maxRanges = count;
      }
      if (maxRanges <= 1) return baseRowHeight; // 0 o 1 chip: altezza base
      final required =
          chipTopPadding + maxRanges * chipHeight + (maxRanges - 1) * chipVGap;
      return required > baseRowHeight ? required : baseRowHeight;
    }

    Widget buildStaffHeaderCell(int staffId) {
      final staff = staffList.firstWhere(
        (s) => s.id == staffId,
        orElse: () => staffList.first,
      );
      final minutes = _totalMinutesForStaff(availability[staffId] ?? const {});
      final isMobile = formFactor == AppFormFactor.mobile;
      void openStaffAvailability() {
        if (!canEditAvailability) return;
        if (currentUserRole == 'staff' &&
            currentUserStaffId != null &&
            staffId != currentUserStaffId) {
          return;
        }
        Navigator.of(context).push(
          MaterialPageRoute(
            builder: (_) => StaffPlanningScreen(initialStaffId: staffId),
          ),
        );
      }

      // Cerca planning biweekly attivo per mostrare badge A/B
      Widget? weekLabelBadge;
      final plannings = ref.watch(planningsForStaffProvider(staffId));
      final activePlanning = plannings
          .where((p) => p.isValidForDate(weekStart))
          .where((p) => p.type == StaffPlanningType.biweekly)
          .toList();
      if (activePlanning.isNotEmpty) {
        final planning = activePlanning.first;
        final label = planning.computeWeekLabel(weekStart);
        final labelText = label == WeekLabel.a
            ? context.l10n.planningWeekA
            : context.l10n.planningWeekB;
        weekLabelBadge = Container(
          padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
          decoration: BoxDecoration(
            color: label == WeekLabel.a
                ? const Color(0xFFE3F2FD) // light blue
                : const Color(0xFFFCE4EC), // light pink
            borderRadius: BorderRadius.circular(8),
            border: Border.all(
              color: label == WeekLabel.a
                  ? const Color(0xFF1976D2).withValues(alpha: 0.3)
                  : const Color(0xFFC2185B).withValues(alpha: 0.3),
            ),
          ),
          child: Text(
            labelText,
            style: Theme.of(context).textTheme.labelSmall?.copyWith(
              color: label == WeekLabel.a
                  ? const Color(0xFF1976D2)
                  : const Color(0xFFC2185B),
              fontWeight: FontWeight.w600,
              fontSize: 10,
            ),
          ),
        );
      }

      if (isMobile) {
        // Mobile: avatar, nome e totale ore raggruppati al centro
        return GestureDetector(
          onTap: canEditAvailability ? openStaffAvailability : null,
          child: Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Stack(
                  children: [
                    StaffCircleAvatar(
                      height: 40,
                      color: staff.color,
                      isHighlighted: false,
                      initials: staff.initials,
                    ),
                    if (canEditAvailability)
                      Positioned(
                        right: -4,
                        bottom: -4,
                        child: Container(
                          padding: const EdgeInsets.all(2),
                          decoration: BoxDecoration(
                            color: Theme.of(context).colorScheme.surface,
                            shape: BoxShape.circle,
                            boxShadow: [
                              BoxShadow(
                                color: Colors.black.withValues(alpha: 0.1),
                                blurRadius: 2,
                              ),
                            ],
                          ),
                          child: Icon(
                            Icons.edit_outlined,
                            size: 14,
                            color: Theme.of(context).colorScheme.primary,
                          ),
                        ),
                      ),
                  ],
                ),
                const SizedBox(height: 6),
                Text(
                  staff.displayName,
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                  style: Theme.of(context).textTheme.bodySmall,
                  textAlign: TextAlign.center,
                ),
                if (minutes > 0)
                  Text(
                    _formatTotalHM(context, minutes),
                    style: Theme.of(
                      context,
                    ).textTheme.labelSmall?.copyWith(color: Colors.black54),
                  ),
                if (weekLabelBadge != null) ...[
                  const SizedBox(height: 4),
                  weekLabelBadge,
                ],
              ],
            ),
          ),
        );
      }

      // Desktop/Tablet: layout orizzontale
      return GestureDetector(
        onTap: canEditAvailability ? openStaffAvailability : null,
        child: Row(
          children: [
            StaffCircleAvatar(
              height: 42,
              color: staff.color,
              isHighlighted: false,
              initials: staff.initials,
            ),
            const SizedBox(width: 8),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Row(
                    children: [
                      Flexible(
                        child: Text(
                          staff.displayName,
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                      if (weekLabelBadge != null) ...[
                        const SizedBox(width: 8),
                        weekLabelBadge,
                      ],
                    ],
                  ),
                  if (minutes > 0)
                    Text(
                      _formatTotalHM(context, minutes),
                      style: Theme.of(
                        context,
                      ).textTheme.labelSmall?.copyWith(color: Colors.black54),
                    ),
                ],
              ),
            ),
            if (canEditAvailability)
              IconButton(
                tooltip: context.l10n.staffEditHours,
                iconSize: 20,
                padding: const EdgeInsets.all(4),
                onPressed: openStaffAvailability,
                icon: const Icon(Icons.edit_outlined),
              ),
          ],
        ),
      );
    }

    // Helper: converte slots in HourRange list
    List<HourRange> slotsToRanges(Set<int> slots, int minutesPerSlot) {
      if (slots.isEmpty) return const [];
      final sorted = slots.toList()..sort();
      final List<List<int>> clusters = [];
      var current = <int>[sorted.first];
      for (int i = 1; i < sorted.length; i++) {
        if (sorted[i] == sorted[i - 1] + 1) {
          current.add(sorted[i]);
        } else {
          clusters.add(current);
          current = <int>[sorted[i]];
        }
      }
      clusters.add(current);

      final List<HourRange> ranges = [];
      for (final c in clusters) {
        final startMin = c.first * minutesPerSlot;
        final endMin = (c.last + 1) * minutesPerSlot;
        final sh = startMin ~/ 60;
        final sm = startMin % 60;
        final eh = endMin ~/ 60;
        final em = endMin % 60;
        ranges.add(HourRange(sh, sm, eh, em));
      }
      return ranges;
    }

    // Helper: elimina una fascia oraria
    Future<void> deleteShift(int staffId, int weekday, int shiftIndex) async {
      final asyncByStaff = ref.read(staffAvailabilityByStaffProvider);
      final allData = asyncByStaff.value;
      if (allData == null) return;

      final staffData = allData[staffId];
      if (staffData == null) return;

      final daySlots = staffData[weekday];
      if (daySlots == null || daySlots.isEmpty) return;

      final monday = _mondayOfWeek(ref.read(agendaDateProvider));
      final date = monday.add(Duration(days: weekday - 1));

      final planningLookup = ref.read(
        planningForStaffOnDateProvider((staffId: staffId, date: date)),
      );
      final minutesPerSlot = _planningSlotMinutesFromLookup(planningLookup);

      // Converti slots in ranges per identificare quale eliminare
      final ranges = slotsToRanges(daySlots, minutesPerSlot);
      if (shiftIndex >= ranges.length) return;

      final rangeToDelete = ranges[shiftIndex];

      // Rimuovi gli slot corrispondenti a questa fascia
      final newSlots = Set<int>.from(daySlots);
      final startSlot =
          (rangeToDelete.startHour * 60 + rangeToDelete.startMinute) ~/
          minutesPerSlot;
      final endSlot =
          (rangeToDelete.endHour * 60 + rangeToDelete.endMinute) ~/
          minutesPerSlot;
      for (int slot = startSlot; slot < endSlot; slot++) {
        newSlots.remove(slot);
      }

      // Aggiorna il provider
      final newStaffData = Map<int, Set<int>>.from(staffData);
      newStaffData[weekday] = newSlots;

      await ref
          .read(staffAvailabilityByStaffProvider.notifier)
          .saveForStaff(staffId, newStaffData);
    }

    // Helper: mostra menu per eccezione "tutto il giorno"
    void showAllDayExceptionMenu(int staffId, int weekday, DateTime date) {
      if (!canEditAvailability) return;
      final l10n = context.l10n;
      final isMobile = formFactor == AppFormFactor.mobile;
      final locale = Intl.getCurrentLocale();
      final dateLabel = DateFormat('EEEE d MMMM', locale).format(date);
      final staff = staffList.firstWhere(
        (s) => s.id == staffId,
        orElse: () => staffList.first,
      );
      final staffName = staff.displayName;

      // Trova tutte le eccezioni per questa data
      AvailabilityException? findAllDayException() {
        final exceptions = ref.read(
          exceptionsForStaffOnDateProvider((staffId: staffId, date: date)),
        );
        for (final exc in exceptions) {
          if (exc.isAllDay) return exc;
        }
        return null;
      }

      Future<void> deleteAllDayException() async {
        final exceptions = ref.read(
          exceptionsForStaffOnDateProvider((staffId: staffId, date: date)),
        );
        // Elimina tutte le eccezioni per questa data
        for (final exc in exceptions) {
          await ref
              .read(availabilityExceptionsProvider.notifier)
              .deleteException(staffId, exc.id);
        }
      }

      Widget buildContent(BuildContext ctx) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            ListTile(
              leading: const Icon(Icons.edit_calendar_outlined),
              title: Text(l10n.exceptionEditShift),
              subtitle: Text(
                l10n.exceptionEditShiftDesc,
                style: Theme.of(ctx).textTheme.bodySmall,
              ),
              onTap: () async {
                final exc = findAllDayException();
                if (exc == null) return;
                Navigator.pop(ctx);
                await showAddExceptionDialog(
                  context,
                  ref,
                  staffId: staffId,
                  initial: exc,
                );
              },
            ),
            const Divider(height: 1),
            ListTile(
              leading: Icon(
                Icons.restore_outlined,
                color: Theme.of(ctx).colorScheme.error,
              ),
              title: Text(
                l10n.exceptionDeleteShift,
                style: TextStyle(color: Theme.of(ctx).colorScheme.error),
              ),
              subtitle: Text(
                l10n.exceptionDeleteShiftDesc,
                style: Theme.of(ctx).textTheme.bodySmall,
              ),
              onTap: () async {
                Navigator.pop(ctx);
                await deleteAllDayException();
              },
            ),
          ],
        );
      }

      if (isMobile) {
        AppBottomSheet.show(
          context: context,
          heightFactor: null,
          builder: (ctx) => Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Center(
                child: Column(
                  children: [
                    StaffCircleAvatar(
                      height: 48,
                      color: staff.color,
                      isHighlighted: false,
                      initials: staff.initials,
                    ),
                    const SizedBox(height: 8),
                    Text(
                      staffName,
                      style: Theme.of(ctx).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                      textAlign: TextAlign.center,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 4),
              Text(
                dateLabel,
                style: Theme.of(ctx).textTheme.bodySmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              buildContent(ctx),
            ],
          ),
        );
      } else {
        showDialog(
          context: context,
          builder: (ctx) => AppFormDialog(
            title: Center(
              child: Column(
                children: [
                  StaffCircleAvatar(
                    height: 48,
                    color: staff.color,
                    isHighlighted: false,
                    initials: staff.initials,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    staffName,
                    style: Theme.of(ctx).textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                    textAlign: TextAlign.center,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 4),
                  Text(
                    dateLabel,
                    style: Theme.of(ctx).textTheme.bodySmall,
                    textAlign: TextAlign.center,
                  ),
                ],
              ),
            ),
            content: buildContent(ctx),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(ctx),
                child: Text(l10n.actionCancel),
              ),
            ],
          ),
        );
      }
    }

    // Helper: mostra menu opzioni per una fascia oraria
    void showShiftOptionsMenu(
      int staffId,
      int weekday,
      int shiftIndex,
      HourRange range,
      DateTime date, {
      bool isException = false,
    }) {
      if (!canEditAvailability) return;
      final l10n = context.l10n;
      final isMobile = formFactor == AppFormFactor.mobile;
      final locale = Intl.getCurrentLocale();
      // Data in formato completo: "luned√¨ 1 dicembre"
      final dateLabel = DateFormat('EEEE d MMMM', locale).format(date);
      final dayName = DateFormat(
        'EEEE',
        locale,
      ).format(date); // Nome giorno completo
      // Nome completo dello staff
      final staff = staffList.firstWhere(
        (s) => s.id == staffId,
        orElse: () => staffList.first,
      );
      final staffName = staff.displayName;
      final planningLookup = ref.read(
        planningForStaffOnDateProvider((staffId: staffId, date: date)),
      );
      final stepMinutes = _planningSlotMinutesFromLookup(planningLookup);

      // Helper per eliminare solo questo turno (crea eccezione)
      Future<void> deleteThisOnly() async {
        await ref
            .read(availabilityExceptionsProvider.notifier)
            .addException(
              staffId: staffId,
              date: date,
              startTime: TimeOfDay(
                hour: range.startHour,
                minute: range.startMinute,
              ),
              endTime: TimeOfDay(hour: range.endHour, minute: range.endMinute),
              type: AvailabilityExceptionType.unavailable,
              reason: null,
            );
      }

      // Helper per eliminare tutti i turni (dalla disponibilit√† settimanale)
      Future<void> deleteAll() async {
        await deleteShift(staffId, weekday, shiftIndex);
      }

      // Helper per modificare solo questo turno (apre dialog per eccezione)
      Future<void> editThisOnly() async {
        final result = await _showEditShiftDialog(
          context: context,
          ref: ref,
          range: range,
          dateLabel: dateLabel,
          formFactor: formFactor,
          stepMinutes: stepMinutes,
        );
        if (result != null) {
          Future<void> addDeltaException(
            int startMinutes,
            int endMinutes,
            AvailabilityExceptionType type,
          ) async {
            if (endMinutes <= startMinutes) return;
            await ref
                .read(availabilityExceptionsProvider.notifier)
                .addException(
                  staffId: staffId,
                  date: date,
                  startTime: TimeOfDay(
                    hour: startMinutes ~/ 60,
                    minute: startMinutes % 60,
                  ),
                  endTime: TimeOfDay(
                    hour: endMinutes ~/ 60,
                    minute: endMinutes % 60,
                  ),
                  type: type,
                  reason: null,
                );
          }

          final baseStartMinutes = range.startHour * 60 + range.startMinute;
          final baseEndMinutes = range.endHour * 60 + range.endMinute;
          final newStartMinutes =
              result.startTime.hour * 60 + result.startTime.minute;
          final newEndMinutes =
              result.endTime.hour * 60 + result.endTime.minute;

          // Rimuovi le ore tolte rispetto al turno base
          if (newStartMinutes > baseStartMinutes) {
            await addDeltaException(
              baseStartMinutes,
              newStartMinutes,
              AvailabilityExceptionType.unavailable,
            );
          }
          if (newEndMinutes < baseEndMinutes) {
            await addDeltaException(
              newEndMinutes,
              baseEndMinutes,
              AvailabilityExceptionType.unavailable,
            );
          }

          // Aggiungi eventuali estensioni rispetto al turno base
          if (newStartMinutes < baseStartMinutes) {
            await addDeltaException(
              newStartMinutes,
              baseStartMinutes,
              AvailabilityExceptionType.available,
            );
          }
          if (newEndMinutes > baseEndMinutes) {
            await addDeltaException(
              baseEndMinutes,
              newEndMinutes,
              AvailabilityExceptionType.available,
            );
          }
        }
      }

      // Helper per modificare tutti i turni (naviga all'editor settimanale)
      void editAll() {
        Navigator.of(context).push(
          MaterialPageRoute(
            builder: (_) => StaffPlanningScreen(initialStaffId: staffId),
          ),
        );
      }

      // Helper per trovare l'eccezione corrispondente a questo range
      AvailabilityException? findMatchingException() {
        final monday = _mondayOfWeek(ref.read(agendaDateProvider));
        final specificDate = monday.add(Duration(days: weekday - 1));
        final exceptions = ref.read(
          exceptionsForStaffOnDateProvider((
            staffId: staffId,
            date: specificDate,
          )),
        );
        final isAllDayRange =
            range.startHour == 0 &&
            range.startMinute == 0 &&
            range.endHour == 24 &&
            range.endMinute == 0;
        // Cerca l'eccezione che corrisponde a questo range orario
        for (final exc in exceptions) {
          if (isAllDayRange && exc.isAllDay) return exc;
          if (exc.startTime != null &&
              exc.endTime != null &&
              exc.startTime!.hour == range.startHour &&
              exc.startTime!.minute == range.startMinute &&
              exc.endTime!.hour == range.endHour &&
              exc.endTime!.minute == range.endMinute) {
            return exc;
          }
        }
        return null;
      }

      // Helper per eliminare un'eccezione
      Future<void> deleteException() async {
        final exc = findMatchingException();
        if (exc != null) {
          await ref
              .read(availabilityExceptionsProvider.notifier)
              .deleteException(staffId, exc.id);
        }
      }

      // Helper per modificare un'eccezione
      Future<void> editException() async {
        final exc = findMatchingException();
        if (exc == null) return;

        if (exc.isAllDay) {
          await showAddExceptionDialog(
            context,
            ref,
            staffId: staffId,
            initial: exc,
          );
          return;
        }

        final result = await _showEditShiftDialog(
          context: context,
          ref: ref,
          range: range,
          dateLabel: dateLabel,
          formFactor: formFactor,
          stepMinutes: stepMinutes,
        );
        if (result != null) {
          // Aggiorna l'eccezione esistente con i nuovi orari
          final updatedExc = exc.copyWith(
            startTime: result.startTime,
            endTime: result.endTime,
          );
          await ref
              .read(availabilityExceptionsProvider.notifier)
              .updateException(updatedExc);
        }
      }

      // Lista opzioni
      Widget buildOptionsList(BuildContext ctx) {
        // Se √® un'eccezione, mostra solo modifica/elimina eccezione
        if (isException) {
          return Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Modifica eccezione
              ListTile(
                leading: const Icon(Icons.edit_calendar_outlined),
                title: Text(l10n.exceptionEditShift),
                subtitle: Text(
                  l10n.exceptionEditShiftDesc,
                  style: Theme.of(ctx).textTheme.bodySmall,
                ),
                onTap: () async {
                  Navigator.pop(ctx);
                  await editException();
                },
              ),
              const Divider(height: 1),
              // Elimina eccezione
              ListTile(
                leading: Icon(
                  Icons.restore_outlined,
                  color: Theme.of(ctx).colorScheme.error,
                ),
                title: Text(
                  l10n.exceptionDeleteShift,
                  style: TextStyle(color: Theme.of(ctx).colorScheme.error),
                ),
                subtitle: Text(
                  l10n.exceptionDeleteShiftDesc,
                  style: Theme.of(ctx).textTheme.bodySmall,
                ),
                onTap: () async {
                  Navigator.pop(ctx);
                  await deleteException();
                },
              ),
              const Divider(height: 1),
              // Aggiungi eccezione
              ListTile(
                leading: const Icon(Icons.add_circle_outline),
                title: Text(l10n.exceptionsAdd),
                onTap: () {
                  Navigator.pop(ctx);
                  showAddExceptionDialog(
                    context,
                    ref,
                    staffId: staffId,
                    date: date,
                  );
                },
              ),
            ],
          );
        }

        // Menu standard per turni base
        return Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Modifica solo questo turno
            ListTile(
              leading: const Icon(Icons.edit_calendar_outlined),
              title: Text(l10n.shiftEditThisOnly),
              subtitle: Text(
                l10n.shiftEditThisOnlyDesc(dateLabel),
                style: Theme.of(ctx).textTheme.bodySmall,
              ),
              onTap: () async {
                Navigator.pop(ctx);
                await editThisOnly();
              },
            ),
            // Modifica tutti questi turni
            ListTile(
              leading: const Icon(Icons.edit_outlined),
              title: Text(l10n.shiftEditAll),
              subtitle: Text(
                l10n.shiftEditAllDesc(dayName),
                style: Theme.of(ctx).textTheme.bodySmall,
              ),
              onTap: () {
                Navigator.pop(ctx);
                editAll();
              },
            ),
            const Divider(height: 1),
            // Aggiungi eccezione
            ListTile(
              leading: const Icon(Icons.add_circle_outline),
              title: Text(l10n.exceptionsAdd),
              onTap: () {
                Navigator.pop(ctx);
                showAddExceptionDialog(
                  context,
                  ref,
                  staffId: staffId,
                  date: date,
                );
              },
            ),
            const Divider(height: 1),
            // Elimina solo questo turno
            ListTile(
              leading: Icon(
                Icons.event_busy_outlined,
                color: Theme.of(ctx).colorScheme.error,
              ),
              title: Text(
                l10n.shiftDeleteThisOnly,
                style: TextStyle(color: Theme.of(ctx).colorScheme.error),
              ),
              subtitle: Text(
                l10n.shiftDeleteThisOnlyDesc(dateLabel),
                style: Theme.of(ctx).textTheme.bodySmall,
              ),
              onTap: () async {
                Navigator.pop(ctx);
                await deleteThisOnly();
              },
            ),
            // Elimina tutti questi turni
            ListTile(
              leading: Icon(
                Icons.delete_outline,
                color: Theme.of(ctx).colorScheme.error,
              ),
              title: Text(
                l10n.shiftDeleteAll,
                style: TextStyle(color: Theme.of(ctx).colorScheme.error),
              ),
              subtitle: Text(
                l10n.shiftDeleteAllDesc(dayName),
                style: Theme.of(ctx).textTheme.bodySmall,
              ),
              onTap: () async {
                Navigator.pop(ctx);
                await deleteAll();
              },
            ),
          ],
        );
      }

      if (isMobile) {
        // Mobile: AppBottomSheet con avatar e nome
        AppBottomSheet.show(
          context: context,
          heightFactor: null, // Auto-size
          builder: (ctx) => Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Avatar con nome sotto
              Center(
                child: Column(
                  children: [
                    StaffCircleAvatar(
                      height: 48,
                      color: staff.color,
                      isHighlighted: false,
                      initials: staff.initials,
                    ),
                    const SizedBox(height: 8),
                    Text(
                      staffName,
                      style: Theme.of(ctx).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                      textAlign: TextAlign.center,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 4),
              Text(
                '${range.label(ctx)} ‚Ä¢ $dateLabel',
                style: Theme.of(ctx).textTheme.bodySmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              buildOptionsList(ctx),
            ],
          ),
        );
      } else {
        // Desktop/Tablet: AppFormDialog con avatar centrato
        showDialog(
          context: context,
          builder: (ctx) => AppFormDialog(
            title: Center(
              child: Column(
                children: [
                  StaffCircleAvatar(
                    height: 48,
                    color: staff.color,
                    isHighlighted: false,
                    initials: staff.initials,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    staffName,
                    style: Theme.of(ctx).textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                    textAlign: TextAlign.center,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 4),
                  Text(
                    '${range.label(ctx)} ‚Ä¢ $dateLabel',
                    style: Theme.of(ctx).textTheme.bodySmall,
                    textAlign: TextAlign.center,
                  ),
                ],
              ),
            ),
            content: buildOptionsList(ctx),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(ctx),
                child: Text(l10n.actionCancel),
              ),
            ],
          ),
        );
      }
    }

    // _DisplayRange √® definita a livello di file per poter essere usata nel sort.

    Widget buildDayCell(
      List<HourRange> ranges,
      List<AvailabilityException> exceptions,
      int staffId,
      int weekday,
      DateTime date, {
      bool hasException = false,
    }) {
      final displayRanges = _mergeRangesForDisplay(
        ranges,
        exceptions,
        context,
        applyUnavailableSplit: false,
        subtractAvailableFromBase: true,
      );
      final hasAllDayAvailable = exceptions.any(
        (e) =>
            e.type == AvailabilityExceptionType.available &&
            e.startTime == null &&
            e.endTime == null,
      );

      Widget buildAllDayChip() {
        final bgColor = hasAllDayAvailable
            ? chipColorWithAvailableException
            : chipColorWithException.withOpacity(0.45);
        final textColor = hasAllDayAvailable
            ? chipTextColorWithAvailableException
            : chipDisabledTextColor.withOpacity(0.7);
        final borderRadius = BorderRadius.circular(6);
        final borderColor = AgendaTheme.appointmentBorder.withOpacity(0.4);
        return Material(
          color: Colors.transparent,
          child: InkWell(
            borderRadius: BorderRadius.circular(6),
            onTap: canEditAvailability
                ? () {
                    // Mostra menu per eccezione "tutto il giorno"
                    showAllDayExceptionMenu(staffId, weekday, date);
                  }
                : null,
            child: CustomPaint(
              painter: hasAllDayAvailable
                  ? null
                  : _DashedRoundedRectPainter(color: borderColor, radius: 6),
              child: Container(
                height: chipHeight,
                padding: const EdgeInsets.symmetric(horizontal: 8),
                alignment: Alignment.center,
                decoration: BoxDecoration(
                  color: bgColor,
                  borderRadius: borderRadius,
                  border: hasAllDayAvailable
                      ? Border.all(
                          color: AgendaTheme.appointmentBorder,
                          width: 0.6,
                        )
                      : null,
                ),
                child: Text(
                  context.l10n.exceptionAllDay,
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.w600,
                    color: textColor,
                  ),
                ),
              ),
            ),
          ),
        );
      }

      Widget buildChipForRange(_DisplayRange range) {
        final isAvailableException =
            range.exceptionType == AvailabilityExceptionType.available;
        final isUnavailableException =
            range.exceptionType == AvailabilityExceptionType.unavailable;
        final bgColor = range.isException
            ? (isAvailableException
                  ? chipColorWithAvailableException
                  : chipColorWithException.withOpacity(0.45))
            : chipColor;
        final textColor = range.isException
            ? (isAvailableException
                  ? chipTextColorWithAvailableException
                  : chipDisabledTextColor.withOpacity(0.7))
            : Colors.black87;
        final borderRadius = BorderRadius.circular(6);
        final borderColor = AgendaTheme.appointmentBorder.withOpacity(0.4);
        return Material(
          color: Colors.transparent,
          child: InkWell(
            borderRadius: BorderRadius.circular(6),
            onTap: canEditAvailability
                ? () {
                    if (range.hourRange != null) {
                      final isAllDayRange =
                          range.hourRange!.startHour == 0 &&
                          range.hourRange!.startMinute == 0 &&
                          range.hourRange!.endHour == 24 &&
                          range.hourRange!.endMinute == 0;
                      if (range.isException && isAllDayRange) {
                        AvailabilityException? exc;
                        for (final e in exceptions) {
                          if (e.isAllDay) {
                            exc = e;
                            break;
                          }
                        }
                        if (exc != null) {
                          showAddExceptionDialog(
                            context,
                            ref,
                            staffId: staffId,
                            initial: exc,
                          );
                          return;
                        }
                      }
                      if (range.isException && !isAllDayRange) {
                        AvailabilityException? exc;
                        for (final e in exceptions) {
                          if (e.startTime == null || e.endTime == null) {
                            continue;
                          }
                          if (e.startTime!.hour == range.hourRange!.startHour &&
                              e.startTime!.minute ==
                                  range.hourRange!.startMinute &&
                              e.endTime!.hour == range.hourRange!.endHour &&
                              e.endTime!.minute == range.hourRange!.endMinute) {
                            exc = e;
                            break;
                          }
                        }
                        if (exc != null) {
                          showAddExceptionDialog(
                            context,
                            ref,
                            staffId: staffId,
                            initial: exc,
                          );
                          return;
                        }
                      }
                      showShiftOptionsMenu(
                        staffId,
                        weekday,
                        0,
                        range.hourRange!,
                        date,
                        isException: range.isException,
                      );
                    }
                  }
                : null,
            child: CustomPaint(
              painter: isUnavailableException
                  ? _DashedRoundedRectPainter(color: borderColor, radius: 6)
                  : null,
              child: Container(
                height: chipHeight,
                padding: const EdgeInsets.symmetric(horizontal: 8),
                alignment: Alignment.center,
                decoration: BoxDecoration(
                  color: bgColor,
                  borderRadius: borderRadius,
                  border: isUnavailableException
                      ? null
                      : Border.all(
                          color: AgendaTheme.appointmentBorder,
                          width: 0.6,
                        ),
                ),
                child: Text(
                  range.label,
                  maxLines: 1,
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.w600,
                    color: textColor,
                  ),
                ),
              ),
            ),
          ),
        );
      }

      return Column(
        crossAxisAlignment: CrossAxisAlignment.center,
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const SizedBox(height: chipTopPadding),
          if (displayRanges.isEmpty && hasException) ...[
            buildAllDayChip(),
          ],
          for (int i = 0; i < displayRanges.length; i++) ...[
            buildChipForRange(displayRanges[i]),
            if (i < displayRanges.length - 1) SizedBox(height: chipVGap),
          ],
        ],
      );
    }

    return Scaffold(
      appBar: AppBar(
        centerTitle: formFactor != AppFormFactor.mobile,
        leading: const BackButton(),
        titleSpacing: formFactor == AppFormFactor.mobile ? 0 : null,
        title: StaffTopControls(
          todayLabel: context.l10n.currentWeek,
          labelOverride: weekLabel,
          compact: formFactor != AppFormFactor.desktop,
        ),
      ),
      body: ScrollConfiguration(
        behavior: const NoScrollbarBehavior(),
        child: Column(
          children: [
            const SizedBox(height: 24),
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(width: staffColWidth),
                const SizedBox(width: 8),
                Expanded(
                  child: SingleChildScrollView(
                    controller: _headerHController,
                    physics: const NeverScrollableScrollPhysics(),
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      children: [
                        for (final d in days) ...[
                          SizedBox(
                            width: dayColumnWidth,
                            child: buildDayHeaderCell(d),
                          ),
                          if (d != days.last) const SizedBox(width: 8),
                        ],
                        const SizedBox(width: rightPadding),
                      ],
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            // Body
            Expanded(
              child: SingleChildScrollView(
                controller: _vScrollController,
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Staff column
                    SizedBox(
                      width: staffColWidth,
                      child: Column(
                        children: [
                          for (int i = 0; i < staffList.length; i++) ...[
                            Container(
                              height: rowHeightForStaff(staffList[i].id),
                              padding: const EdgeInsets.symmetric(
                                horizontal: 8,
                              ),
                              alignment: Alignment.centerLeft,
                              child: buildStaffHeaderCell(staffList[i].id),
                            ),
                            divider,
                            if (i < staffList.length - 1)
                              const SizedBox(height: staffRowGap),
                          ],
                        ],
                      ),
                    ),
                    // Gap column with matching row dividers
                    SizedBox(
                      width: 8,
                      child: Column(
                        children: [
                          for (int i = 0; i < staffList.length; i++) ...[
                            SizedBox(
                              height: rowHeightForStaff(staffList[i].id),
                            ),
                            divider,
                            if (i < staffList.length - 1)
                              const SizedBox(height: staffRowGap),
                          ],
                        ],
                      ),
                    ),
                    // Days grid (with vertical separators between columns)
                    Expanded(
                      child: SingleChildScrollView(
                        controller: _bodyHController,
                        physics: const ClampingScrollPhysics(),
                        scrollDirection: Axis.horizontal,
                        child: Column(
                          children: [
                            for (int i = 0; i < staffList.length; i++) ...[
                              // Row of day cells + vertical gaps
                              Row(
                                children: [
                                  for (final d in days) ...[
                                    SizedBox(
                                      width: dayColumnWidth,
                                      height: rowHeightForStaff(
                                        staffList[i].id,
                                      ),
                                      child: buildDayCell(
                                        (availability[staffList[i].id]?[d
                                                .weekday]) ??
                                            const <HourRange>[],
                                        ref.watch(
                                          exceptionsForStaffOnDateProvider((
                                            staffId: staffList[i].id,
                                            date: d,
                                          )),
                                        ),
                                        staffList[i].id,
                                        d.weekday,
                                        d,
                                        hasException:
                                            exceptionDays[staffList[i].id]
                                                ?.contains(d.weekday) ??
                                            false,
                                      ),
                                    ),
                                    if (d != days.last)
                                      SizedBox(
                                        width: 8,
                                        height: rowHeightForStaff(
                                          staffList[i].id,
                                        ),
                                      ),
                                  ],
                                  SizedBox(
                                    width: rightPadding,
                                    height: rowHeightForStaff(staffList[i].id),
                                  ),
                                ],
                              ),
                              // Single full-width horizontal divider spanning day cells + gaps
                              Builder(
                                builder: (context) {
                                  final daysRowWidth =
                                      days.length * dayColumnWidth +
                                      (days.length - 1) * 8 +
                                      rightPadding;
                                  return SizedBox(
                                    width: daysRowWidth,
                                    child: divider,
                                  );
                                },
                              ),
                              if (i < staffList.length - 1)
                                const SizedBox(height: staffRowGap),
                            ],
                          ],
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
      /*bottomNavigationBar: formFactor != AppFormFactor.mobile
          ? null
          : SafeArea(
              top: false,
              bottom: true,
              minimum: const EdgeInsets.only(bottom: 15),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const AgendaHorizontalDivider(),
                  Padding(
                    padding: EdgeInsetsDirectional.only(
                      start: formFactor == AppFormFactor.mobile
                          ? 0
                          : staffColWidth + 8,
                      top: 15,
                      bottom: 1,
                    ),
                    child: AgendaDateSwitcher(
                      label: weekLabel,
                      selectedDate: effectivePickerDate,
                      onPreviousWeek: ref
                          .read(agendaDateProvider.notifier)
                          .previousWeek,
                      onNextWeek: ref
                          .read(agendaDateProvider.notifier)
                          .nextWeek,
                      onSelectDate: (date) {
                        ref
                            .read(agendaDateProvider.notifier)
                            .set(DateUtils.dateOnly(date));
                      },
                      useWeekRangePicker: true,
                      isCompact: true,
                    ),
                  ),
                ],
              ),
            ),*/
    );
  }
}

/// Risultato della modifica di un turno.
class _EditShiftResult {
  final TimeOfDay startTime;
  final TimeOfDay endTime;

  const _EditShiftResult({required this.startTime, required this.endTime});
}

/// Mostra il dialog per modificare un turno (solo gli orari).
Future<_EditShiftResult?> _showEditShiftDialog({
  required BuildContext context,
  required WidgetRef ref,
  required HourRange range,
  required String dateLabel,
  required AppFormFactor formFactor,
  required int stepMinutes,
}) async {
  final isMobile = formFactor == AppFormFactor.mobile;

  if (isMobile) {
    return AppBottomSheet.show<_EditShiftResult>(
      context: context,
      heightFactor: null,
      builder: (ctx) => _EditShiftContent(
        range: range,
        dateLabel: dateLabel,
        stepMinutes: stepMinutes,
      ),
    );
  } else {
    return showDialog<_EditShiftResult>(
      context: context,
      builder: (ctx) => Dialog(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 400),
          child: _EditShiftContent(
            range: range,
            dateLabel: dateLabel,
            stepMinutes: stepMinutes,
            isDialog: true,
          ),
        ),
      ),
    );
  }
}

/// Widget per il contenuto del dialog di modifica turno.
class _EditShiftContent extends ConsumerStatefulWidget {
  const _EditShiftContent({
    required this.range,
    required this.dateLabel,
    required this.stepMinutes,
    this.isDialog = false,
  });

  final HourRange range;
  final String dateLabel;
  final int stepMinutes;
  final bool isDialog;

  @override
  ConsumerState<_EditShiftContent> createState() => _EditShiftContentState();
}

class _EditShiftContentState extends ConsumerState<_EditShiftContent> {
  late TimeOfDay _startTime;
  late TimeOfDay _endTime;
  String? _timeError;

  @override
  void initState() {
    super.initState();
    _startTime = TimeOfDay(
      hour: widget.range.startHour,
      minute: widget.range.startMinute,
    );
    _endTime = TimeOfDay(
      hour: widget.range.endHour,
      minute: widget.range.endMinute,
    );
  }

  String _formatTime(TimeOfDay time) {
    return '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';
  }

  Future<void> _pickTime({required bool isStart}) async {
    final step = widget.stepMinutes;
    final selected = await AppBottomSheet.show<TimeOfDay>(
      context: context,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      builder: (ctx) {
        final height = MediaQuery.of(ctx).size.height * 0.7;
        return SizedBox(
          height: height,
          child: _TimeGridPicker(
            initial: isStart ? _startTime : _endTime,
            stepMinutes: step,
          ),
        );
      },
    );
    if (selected != null) {
      setState(() {
        _timeError = null;
        if (isStart) {
          _startTime = selected;
          // Se l'orario di fine √® prima dell'inizio, aggiustalo
          final startMinutes = _startTime.hour * 60 + _startTime.minute;
          final endMinutes = _endTime.hour * 60 + _endTime.minute;
          if (endMinutes <= startMinutes) {
            _endTime = TimeOfDay(
              hour: (_startTime.hour + 1).clamp(0, 23),
              minute: _startTime.minute,
            );
          }
        } else {
          _endTime = selected;
        }
      });
    }
  }

  bool _validate() {
    final l10n = context.l10n;
    final startMinutes = _startTime.hour * 60 + _startTime.minute;
    final endMinutes = _endTime.hour * 60 + _endTime.minute;
    if (endMinutes <= startMinutes) {
      setState(() => _timeError = l10n.exceptionTimeError);
      return false;
    }
    return true;
  }

  void _onSave() {
    if (!_validate()) return;
    Navigator.of(
      context,
    ).pop(_EditShiftResult(startTime: _startTime, endTime: _endTime));
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;

    final content = Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Riga orari
        Row(
          children: [
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    l10n.shiftStartTime,
                    style: Theme.of(context).textTheme.labelMedium,
                  ),
                  const SizedBox(height: 4),
                  InkWell(
                    onTap: () => _pickTime(isStart: true),
                    child: InputDecorator(
                      decoration: InputDecoration(
                        border: const OutlineInputBorder(),
                        isDense: true,
                        enabledBorder: _timeError != null
                            ? OutlineInputBorder(
                                borderSide: BorderSide(
                                  color: colorScheme.error,
                                ),
                              )
                            : null,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_formatTime(_startTime)),
                          const Icon(Icons.access_time, size: 16),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    l10n.shiftEndTime,
                    style: Theme.of(context).textTheme.labelMedium,
                  ),
                  const SizedBox(height: 4),
                  InkWell(
                    onTap: () => _pickTime(isStart: false),
                    child: InputDecorator(
                      decoration: InputDecoration(
                        border: const OutlineInputBorder(),
                        isDense: true,
                        enabledBorder: _timeError != null
                            ? OutlineInputBorder(
                                borderSide: BorderSide(
                                  color: colorScheme.error,
                                ),
                              )
                            : null,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_formatTime(_endTime)),
                          const Icon(Icons.access_time, size: 16),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
        if (_timeError != null) ...[
          const SizedBox(height: 8),
          Text(
            _timeError!,
            style: TextStyle(color: colorScheme.error, fontSize: 12),
          ),
        ],
        const SizedBox(height: 24),
        // Bottoni
        Row(
          mainAxisAlignment: MainAxisAlignment.end,
          children: [
            AppOutlinedActionButton(
              onPressed: () => Navigator.of(context).pop(),
              padding: AppButtonStyles.dialogButtonPadding,
              child: Text(l10n.actionCancel),
            ),
            const SizedBox(width: 8),
            AppFilledButton(
              onPressed: _onSave,
              padding: AppButtonStyles.dialogButtonPadding,
              child: Text(l10n.actionSave),
            ),
          ],
        ),
      ],
    );

    if (widget.isDialog) {
      return Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              l10n.shiftEditTitle,
              style: Theme.of(context).textTheme.titleLarge,
            ),
            Text(
              widget.dateLabel,
              style: Theme.of(context).textTheme.bodySmall,
            ),
            const SizedBox(height: 16),
            content,
          ],
        ),
      );
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          l10n.shiftEditTitle,
          style: Theme.of(
            context,
          ).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
          textAlign: TextAlign.center,
        ),
        Text(widget.dateLabel, style: Theme.of(context).textTheme.bodySmall),
        const SizedBox(height: 16),
        content,
      ],
    );
  }
}

/// Widget per la selezione dell'orario con griglia.
class _TimeGridPicker extends StatefulWidget {
  const _TimeGridPicker({required this.initial, required this.stepMinutes});

  final TimeOfDay initial;
  final int stepMinutes;

  @override
  State<_TimeGridPicker> createState() => _TimeGridPickerState();
}

class _TimeGridPickerState extends State<_TimeGridPicker> {
  final ScrollController _scrollController = ScrollController();
  late final List<TimeOfDay?> _times;
  late final int _scrollToIndex;

  @override
  void initState() {
    super.initState();

    // Genera lista di orari con step specificato (da 00:00 a 24:00)
    _times = <TimeOfDay?>[];
    for (int m = 0; m <= 24 * 60; m += widget.stepMinutes) {
      final h = m ~/ 60;
      final min = m % 60;
      _times.add(TimeOfDay(hour: h, minute: min));
    }

    // Verifica se l'orario iniziale √® gi√† nella lista
    int exactIndex = _times.indexWhere(
      (t) =>
          t != null &&
          t.hour == widget.initial.hour &&
          t.minute == widget.initial.minute,
    );

    if (exactIndex >= 0) {
      // L'orario √® gi√† presente
      _scrollToIndex = exactIndex;
    } else {
      // L'orario non √® presente: inserisci una NUOVA RIGA con l'orario
      // nella colonna corretta e le altre colonne vuote
      final columnsPerRow = 60 ~/ widget.stepMinutes;
      final targetColumn = widget.initial.minute ~/ widget.stepMinutes;
      final baseIndex = (widget.initial.hour + 1) * columnsPerRow;

      // Crea la nuova riga con 4 elementi (solo uno valorizzato)
      final newRow = List<TimeOfDay?>.filled(columnsPerRow, null);
      newRow[targetColumn] = widget.initial;

      // Inserisci la nuova riga
      final insertIndex = baseIndex.clamp(0, _times.length);
      _times.insertAll(insertIndex, newRow);

      // L'indice dell'orario selezionato √® la posizione nella nuova riga
      _scrollToIndex = insertIndex + targetColumn;
    }

    // Scrolla all'orario preimpostato dopo il primo frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _scrollToSelected();
    });
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  void _scrollToSelected() {
    const crossAxisCount = 4;
    const mainAxisSpacing = 8.0;
    const crossAxisSpacing = 8.0;
    const padding = 8.0;

    // Calcola la riga in cui si trova l'elemento selezionato
    final row = _scrollToIndex ~/ crossAxisCount;

    // Stima l'altezza di ogni cella basandosi su una larghezza ragionevole
    if (_scrollController.hasClients) {
      final viewportWidth = _scrollController.position.viewportDimension > 0
          ? MediaQuery.of(context).size.width - padding * 2
          : 300.0;
      final cellWidth =
          (viewportWidth - crossAxisSpacing * (crossAxisCount - 1)) /
          crossAxisCount;
      final cellHeight = cellWidth / 2.5; // childAspectRatio = 2.5
      final rowHeight = cellHeight + mainAxisSpacing;

      // Calcola l'offset per centrare l'elemento selezionato
      final targetOffset = row * rowHeight;
      final maxScroll = _scrollController.position.maxScrollExtent;
      final scrollTo = targetOffset.clamp(0.0, maxScroll);

      _scrollController.animateTo(
        scrollTo,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;

    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.all(16),
          child: Text(
            l10n.exceptionSelectTime,
            style: Theme.of(context).textTheme.titleMedium,
          ),
        ),
        Expanded(
          child: GridView.builder(
            controller: _scrollController,
            padding: const EdgeInsets.all(8),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 4,
              childAspectRatio: 2.5,
              crossAxisSpacing: 8,
              mainAxisSpacing: 8,
            ),
            itemCount: _times.length,
            itemBuilder: (context, index) {
              final time = _times[index];
              // Se la cella √® vuota, mostra uno spazio vuoto
              if (time == null) {
                return const SizedBox.shrink();
              }
              final isSelected = index == _scrollToIndex;
              final label = time.hour == 24
                  ? '24:00'
                  : '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';

              return Material(
                color: isSelected
                    ? colorScheme.primaryContainer
                    : colorScheme.surfaceContainerHighest,
                borderRadius: BorderRadius.circular(8),
                child: InkWell(
                  onTap: () {
                    // Chiudi immediatamente con il valore selezionato
                    Navigator.of(context).pop(time);
                  },
                  borderRadius: BorderRadius.circular(8),
                  child: Center(
                    child: Text(
                      label,
                      style: TextStyle(
                        fontWeight: isSelected
                            ? FontWeight.bold
                            : FontWeight.normal,
                        color: isSelected
                            ? colorScheme.onPrimaryContainer
                            : colorScheme.onSurface,
                      ),
                    ),
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }
}
--- FILE: lib/features/staff/presentation/widgets/weekly_schedule_editor.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/extensions.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/features/agenda/domain/config/layout_config.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

String _formatHoursMinutesLabel(BuildContext context, int totalMinutes) {
  final h = totalMinutes ~/ 60;
  final m = totalMinutes % 60;
  if (m == 0) return context.l10n.hoursHoursOnly(h);
  return context.l10n.hoursMinutesCompact(h, m);
}

/// Rappresenta un singolo turno di lavoro (orario inizio - orario fine).
class WorkShift {
  final TimeOfDay startTime;
  final TimeOfDay endTime;

  const WorkShift({required this.startTime, required this.endTime});

  WorkShift copyWith({TimeOfDay? startTime, TimeOfDay? endTime}) {
    return WorkShift(
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
    );
  }

  /// Durata in minuti del turno.
  int get durationMinutes {
    final startMinutes = startTime.hour * 60 + startTime.minute;
    final endMinutes = endTime.hour * 60 + endTime.minute;
    return endMinutes - startMinutes;
  }

  /// Durata in ore (arrotondata).
  double get durationHours => durationMinutes / 60.0;
}

/// Rappresenta la disponibilit√† di un singolo giorno.
class DaySchedule {
  final bool isEnabled;
  final List<WorkShift> shifts;

  const DaySchedule({this.isEnabled = false, this.shifts = const []});

  DaySchedule copyWith({bool? isEnabled, List<WorkShift>? shifts}) {
    return DaySchedule(
      isEnabled: isEnabled ?? this.isEnabled,
      shifts: shifts ?? this.shifts,
    );
  }

  /// Totale minuti lavorati nel giorno.
  int get totalMinutes {
    if (!isEnabled || shifts.isEmpty) return 0;
    return shifts.fold<int>(
      0,
      (sum, shift) => sum + shift.durationMinutes,
    );
  }

  /// Totale ore lavorate nel giorno (solo parte intera).
  int get totalHours {
    return totalMinutes ~/ 60;
  }
}

/// Rappresenta la pianificazione settimanale completa.
class WeeklySchedule {
  /// Mappa giorno (1=luned√¨, 7=domenica) -> DaySchedule
  final Map<int, DaySchedule> days;

  const WeeklySchedule({required this.days});

  factory WeeklySchedule.empty() {
    return WeeklySchedule(
      days: {for (int i = 1; i <= 7; i++) i: const DaySchedule()},
    );
  }

  /// Crea una pianificazione con valori di default (lun-sab 09:00-18:00).
  factory WeeklySchedule.defaultSchedule() {
    return WeeklySchedule(
      days: {
        for (int i = 1; i <= 6; i++)
          i: DaySchedule(
            isEnabled: true,
            shifts: [
              const WorkShift(
                startTime: TimeOfDay(hour: 9, minute: 0),
                endTime: TimeOfDay(hour: 18, minute: 0),
              ),
            ],
          ),
        7: const DaySchedule(isEnabled: false, shifts: []),
      },
    );
  }

  WeeklySchedule copyWith({Map<int, DaySchedule>? days}) {
    return WeeklySchedule(days: days ?? this.days);
  }

  /// Totale ore settimanali.
  int get totalHours {
    return days.values.fold<int>(0, (sum, day) => sum + day.totalHours);
  }

  /// Totale minuti settimanali.
  int get totalMinutes {
    return days.values.fold<int>(0, (sum, day) => sum + day.totalMinutes);
  }

  /// Unifica le fasce orarie contigue (dove la fine di una coincide con l'inizio della successiva).
  /// Ritorna una nuova WeeklySchedule con le fasce unificate.
  WeeklySchedule mergeContiguousShifts() {
    final Map<int, DaySchedule> mergedDays = {};

    for (final entry in days.entries) {
      final day = entry.key;
      final schedule = entry.value;

      if (!schedule.isEnabled || schedule.shifts.length <= 1) {
        // Nessuna unificazione necessaria
        mergedDays[day] = schedule;
        continue;
      }

      // Ordina le fasce per orario di inizio
      final sortedShifts = List<WorkShift>.from(schedule.shifts)
        ..sort((a, b) {
          final aMinutes = a.startTime.hour * 60 + a.startTime.minute;
          final bMinutes = b.startTime.hour * 60 + b.startTime.minute;
          return aMinutes.compareTo(bMinutes);
        });

      // Unifica fasce contigue
      final List<WorkShift> mergedShifts = [];
      WorkShift? current;

      for (final shift in sortedShifts) {
        if (current == null) {
          current = shift;
        } else {
          // Controlla se la fine di current coincide con l'inizio di shift
          final currentEndMinutes =
              current.endTime.hour * 60 + current.endTime.minute;
          final shiftStartMinutes =
              shift.startTime.hour * 60 + shift.startTime.minute;

          if (currentEndMinutes == shiftStartMinutes) {
            // Fasce contigue: unisci
            current = WorkShift(
              startTime: current.startTime,
              endTime: shift.endTime,
            );
          } else {
            // Non contigue: salva current e inizia nuovo
            mergedShifts.add(current);
            current = shift;
          }
        }
      }

      // Aggiungi l'ultima fascia
      if (current != null) {
        mergedShifts.add(current);
      }

      mergedDays[day] = DaySchedule(
        isEnabled: schedule.isEnabled,
        shifts: mergedShifts,
      );
    }

    return WeeklySchedule(days: mergedDays);
  }

  /// Converte da formato slot a WeeklySchedule.
  /// [minutesPerSlot] dipende dalla sorgente:
  /// per i planning staff usare `StaffPlanning.planningStepMinutes` (5).
  factory WeeklySchedule.fromSlots(
    Map<int, Set<int>> slots, {
    int minutesPerSlot = 15,
  }) {
    final Map<int, DaySchedule> days = {};

    for (int day = 1; day <= 7; day++) {
      final daySlots = slots[day] ?? <int>{};
      if (daySlots.isEmpty) {
        days[day] = const DaySchedule(isEnabled: false, shifts: []);
        continue;
      }

      // Ordina e raggruppa slot consecutivi in turni
      final sortedSlots = daySlots.toList()..sort();
      final List<WorkShift> shifts = [];

      int? rangeStart;
      int? rangePrev;

      for (final slot in sortedSlots) {
        if (rangeStart == null) {
          rangeStart = slot;
          rangePrev = slot;
        } else if (slot == rangePrev! + 1) {
          // Slot consecutivo
          rangePrev = slot;
        } else {
          // Gap trovato, chiudi range precedente
          shifts.add(_slotsToShift(rangeStart, rangePrev, minutesPerSlot));
          rangeStart = slot;
          rangePrev = slot;
        }
      }

      // Aggiungi ultimo range
      if (rangeStart != null && rangePrev != null) {
        shifts.add(_slotsToShift(rangeStart, rangePrev, minutesPerSlot));
      }

      days[day] = DaySchedule(isEnabled: shifts.isNotEmpty, shifts: shifts);
    }

    return WeeklySchedule(days: days);
  }

  static WorkShift _slotsToShift(
    int startSlot,
    int endSlot,
    int minutesPerSlot,
  ) {
    final startMinutes = startSlot * minutesPerSlot;
    final endMinutes =
        (endSlot + 1) * minutesPerSlot; // +1 perch√© endSlot √® incluso
    return WorkShift(
      startTime: TimeOfDay(hour: startMinutes ~/ 60, minute: startMinutes % 60),
      endTime: TimeOfDay(hour: endMinutes ~/ 60, minute: endMinutes % 60),
    );
  }

  /// Converte WeeklySchedule a formato slot.
  Map<int, Set<int>> toSlots({int minutesPerSlot = 15}) {
    final Map<int, Set<int>> result = {};

    for (final entry in days.entries) {
      final day = entry.key;
      final schedule = entry.value;

      if (!schedule.isEnabled || schedule.shifts.isEmpty) {
        result[day] = <int>{};
        continue;
      }

      final Set<int> daySlots = {};
      for (final shift in schedule.shifts) {
        final startMinutes = shift.startTime.hour * 60 + shift.startTime.minute;
        final endMinutes = shift.endTime.hour * 60 + shift.endTime.minute;

        // Converti range di minuti a slot
        for (int m = startMinutes; m < endMinutes; m += minutesPerSlot) {
          daySlots.add(m ~/ minutesPerSlot);
        }
      }
      result[day] = daySlots;
    }

    return result;
  }
}

/// Widget per la modifica della pianificazione settimanale.
class WeeklyScheduleEditor extends StatefulWidget {
  final WeeklySchedule initialSchedule;
  final ValueChanged<WeeklySchedule>? onChanged;
  final bool showHeader;
  final bool readOnly;

  /// Passo di visualizzazione orari nel picker (es. 5, 10, 15, 30, 60).
  /// Non influenza il salvataggio (sempre a 5 min), solo le opzioni visibili.
  final int displayStepMinutes;

  /// Callback invocato quando l'utente cambia il passo tramite lo stepper.
  /// Se null lo stepper non viene mostrato.
  final ValueChanged<int>? onDisplayStepChanged;

  const WeeklyScheduleEditor({
    super.key,
    required this.initialSchedule,
    this.onChanged,
    this.showHeader = true,
    this.readOnly = false,
    this.displayStepMinutes = LayoutConfig.minutesPerSlotConst,
    this.onDisplayStepChanged,
  });

  @override
  State<WeeklyScheduleEditor> createState() => _WeeklyScheduleEditorState();
}

class _WeeklyScheduleEditorState extends State<WeeklyScheduleEditor> {
  late WeeklySchedule _schedule;

  @override
  void initState() {
    super.initState();
    _schedule = widget.initialSchedule;
  }

  @override
  void didUpdateWidget(WeeklyScheduleEditor oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.initialSchedule != oldWidget.initialSchedule) {
      _schedule = widget.initialSchedule;
    }
  }

  void _updateSchedule(WeeklySchedule newSchedule) {
    setState(() => _schedule = newSchedule);
    widget.onChanged?.call(newSchedule);
  }

  void _toggleDay(int day) {
    final currentDay = _schedule.days[day]!;
    final newDay = currentDay.copyWith(
      isEnabled: !currentDay.isEnabled,
      shifts: !currentDay.isEnabled && currentDay.shifts.isEmpty
          ? [
              const WorkShift(
                startTime: TimeOfDay(hour: 9, minute: 0),
                endTime: TimeOfDay(hour: 18, minute: 0),
              ),
            ]
          : currentDay.shifts,
    );
    _updateSchedule(_schedule.copyWith(days: {..._schedule.days, day: newDay}));
  }

  void _updateShift(int day, int shiftIndex, WorkShift newShift) {
    final currentDay = _schedule.days[day]!;
    final newShifts = List<WorkShift>.from(currentDay.shifts);
    newShifts[shiftIndex] = newShift;
    _updateSchedule(
      _schedule.copyWith(
        days: {
          ..._schedule.days,
          day: currentDay.copyWith(shifts: newShifts),
        },
      ),
    );
  }

  void _addShift(int day) {
    final currentDay = _schedule.days[day]!;
    final lastShift = currentDay.shifts.isNotEmpty
        ? currentDay.shifts.last
        : null;
    final newStartHour = lastShift != null ? lastShift.endTime.hour + 1 : 9;
    final newShift = WorkShift(
      startTime: TimeOfDay(hour: newStartHour.clamp(0, 22), minute: 0),
      endTime: TimeOfDay(hour: (newStartHour + 1).clamp(1, 23), minute: 0),
    );
    _updateSchedule(
      _schedule.copyWith(
        days: {
          ..._schedule.days,
          day: currentDay.copyWith(shifts: [...currentDay.shifts, newShift]),
        },
      ),
    );
  }

  void _removeShift(int day, int shiftIndex) {
    final currentDay = _schedule.days[day]!;
    final newShifts = List<WorkShift>.from(currentDay.shifts)
      ..removeAt(shiftIndex);
    // Se non ci sono pi√π turni, disabilita il giorno
    final isEnabled = newShifts.isNotEmpty;
    _updateSchedule(
      _schedule.copyWith(
        days: {
          ..._schedule.days,
          day: currentDay.copyWith(shifts: newShifts, isEnabled: isEnabled),
        },
      ),
    );
  }

  List<String> _getDayNames(BuildContext context) {
    final l10n = context.l10n;
    return [
      l10n.dayMondayFull,
      l10n.dayTuesdayFull,
      l10n.dayWednesdayFull,
      l10n.dayThursdayFull,
      l10n.dayFridayFull,
      l10n.daySaturdayFull,
      l10n.daySundayFull,
    ];
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final dayNames = _getDayNames(context);

    return IgnorePointer(
      ignoring: widget.readOnly,
      child: Opacity(
        opacity: widget.readOnly ? 0.92 : 1,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min,
          children: [
        // Header con titolo e ore totali (opzionale)
        if (widget.showHeader)
          Padding(
            padding: const EdgeInsets.only(bottom: 16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  l10n.weeklyScheduleTitle,
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  _formatHoursMinutesLabel(context, _schedule.totalMinutes),
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                ),
                if (widget.onDisplayStepChanged != null) ...[
                  const SizedBox(height: 12),
                  Center(
                    child: _StepSelector(
                      value: widget.displayStepMinutes,
                      onChanged: widget.onDisplayStepChanged!,
                    ),
                  ),
                ],
              ],
            ),
          ),

        // Lista dei giorni - sfondo a tutta larghezza, contenuto centrato
        Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: List.generate(7, (index) {
            final day = index + 1;
            final daySchedule = _schedule.days[day]!;
            final dayName = dayNames[index];

            return _DayRow(
              day: day,
              dayName: dayName,
              allDayNames: dayNames,
              schedule: daySchedule,
              onToggle: () => _toggleDay(day),
              onShiftChanged: (shiftIndex, shift) =>
                  _updateShift(day, shiftIndex, shift),
              onAddShift: () => _addShift(day),
              onRemoveShift: (shiftIndex) => _removeShift(day, shiftIndex),
              isFirst: index == 0,
              displayStepMinutes: widget.displayStepMinutes,
            );
          }),
        ),
          ],
        ),
      ),
    );
  }
}

/// Riga per un singolo giorno.
class _DayRow extends ConsumerWidget {
  final int day;
  final String dayName;
  final List<String> allDayNames;
  final DaySchedule schedule;
  final VoidCallback onToggle;
  final void Function(int shiftIndex, WorkShift shift) onShiftChanged;
  final VoidCallback onAddShift;
  final void Function(int shiftIndex) onRemoveShift;
  final bool isFirst;
  final int displayStepMinutes;

  const _DayRow({
    required this.day,
    required this.dayName,
    required this.allDayNames,
    required this.schedule,
    required this.onToggle,
    required this.onShiftChanged,
    required this.onAddShift,
    required this.onRemoveShift,
    this.isFirst = false,
    this.displayStepMinutes = LayoutConfig.minutesPerSlotConst,
  });

  /// Calcola la larghezza massima tra tutti i nomi dei giorni
  double _getMaxDayNameWidth(BuildContext context, TextStyle? style) {
    double maxWidth = 0;
    final textPainter = TextPainter(textDirection: TextDirection.ltr);
    for (final name in allDayNames) {
      textPainter.text = TextSpan(text: name, style: style);
      textPainter.layout();
      if (textPainter.width > maxWidth) {
        maxWidth = textPainter.width;
      }
    }
    return maxWidth;
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final formFactor = ref.watch(formFactorProvider);
    final isMobile = formFactor == AppFormFactor.mobile;

    if (isMobile) {
      return _buildMobileLayout(context, l10n, theme);
    }
    return _buildDesktopLayout(context, l10n, theme);
  }

  /// Layout mobile: verticale (header sopra, turni sotto)
  Widget _buildMobileLayout(
    BuildContext context,
    dynamic l10n,
    ThemeData theme,
  ) {
    // Sfondo alternato: trasparente per dispari, colorato per pari
    final interactionColors = theme.extension<AppInteractionColors>();
    final backgroundColor = day.isEven
        ? interactionColors?.alternatingRowFill
        : null;

    final dayNameStyle = theme.textTheme.bodyLarge?.copyWith(
      fontWeight: FontWeight.w500,
    );
    final maxDayNameWidth = _getMaxDayNameWidth(context, dayNameStyle);

    return Material(
      color: Colors.transparent,
      child: Ink(
        color: backgroundColor,
        child: InkWell(
          onTap: onToggle,
          child: Padding(
            padding: EdgeInsets.only(top: isFirst ? 16 : 8, bottom: 8),
            child: Center(
              child: Padding(
                padding: const EdgeInsets.symmetric(horizontal: 16),
                child: IntrinsicWidth(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                // Header: checkbox + nome giorno + ore + icone
                Row(
                  mainAxisAlignment: MainAxisAlignment.start,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    // Checkbox inline con il nome
                    Transform.scale(
                      scale: 1.1,
                      child: Checkbox(
                        value: schedule.isEnabled,
                        onChanged: (_) => onToggle(),
                        activeColor: theme.colorScheme.primary,
                        visualDensity: VisualDensity.compact,
                        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                      ),
                    ),

                    // Nome giorno con larghezza fissa (calcolata dinamicamente)
                    SizedBox(
                      width: maxDayNameWidth,
                      child: Text(dayName, style: dayNameStyle),
                    ),
                    if (schedule.isEnabled && schedule.totalMinutes > 0) ...[
                      const SizedBox(width: 8),
                      Text(
                        _formatHoursMinutesLabel(
                          context,
                          schedule.totalMinutes,
                        ),
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ],

                    // Icone azioni (solo se abilitato)
                    if (schedule.isEnabled) ...[
                      const SizedBox(width: 8),
                      IconButton(
                        onPressed: onAddShift,
                        icon: Icon(
                          Icons.add_circle_outline,
                          color: theme.colorScheme.primary,
                        ),
                        tooltip: l10n.weeklyScheduleAddShift,
                        constraints: const BoxConstraints(
                          minWidth: 36,
                          minHeight: 36,
                        ),
                        padding: EdgeInsets.zero,
                        iconSize: 22,
                      ),
                    ],
                  ],
                ),

                // Contenuto turni o "Non lavora"
                if (schedule.isEnabled)
                  Padding(
                    padding: const EdgeInsets.only(top: 8),
                    child: Column(
                      children: [
                        for (int i = 0; i < schedule.shifts.length; i++)
                          Padding(
                            padding: EdgeInsets.only(
                              bottom: i < schedule.shifts.length - 1 ? 8 : 0,
                            ),
                            child: _ShiftRowMobile(
                              shift: schedule.shifts[i],
                              onChanged: (shift) => onShiftChanged(i, shift),
                              onRemove: () => onRemoveShift(i),
                              previousShiftEndTime: i > 0
                                  ? schedule.shifts[i - 1].endTime
                                  : null,
                              displayStepMinutes: displayStepMinutes,
                            ),
                          ),
                      ],
                    ),
                  )
                else
                  Padding(
                    padding: const EdgeInsets.only(top: 4),
                    child: Text(
                      l10n.weeklyScheduleNotWorking,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  /// Layout desktop/tablet: orizzontale
  Widget _buildDesktopLayout(
    BuildContext context,
    dynamic l10n,
    ThemeData theme,
  ) {
    // Sfondo alternato: trasparente per dispari, colorato per pari
    final interactionColors = theme.extension<AppInteractionColors>();
    final backgroundColor = day.isEven
        ? interactionColors?.alternatingRowFill
        : null;

    final dayNameStyle = theme.textTheme.bodyLarge?.copyWith(
      fontWeight: FontWeight.w500,
    );
    final maxDayNameWidth = _getMaxDayNameWidth(context, dayNameStyle);

    return Material(
      color: Colors.transparent,
      child: Ink(
        color: backgroundColor,
        child: InkWell(
          onTap: onToggle,
          child: Padding(
            padding: EdgeInsets.only(top: isFirst ? 16 : 8, bottom: 8),
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.start,
                crossAxisAlignment: CrossAxisAlignment.center,
                children: [
            // Checkbox
            Checkbox(
              value: schedule.isEnabled,
              onChanged: (_) => onToggle(),
              activeColor: theme.colorScheme.primary,
            ),
            const SizedBox(width: 8),

            // Nome giorno e ore con larghezza fissa (calcolata dinamicamente)
            SizedBox(
              width: maxDayNameWidth,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.center,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(dayName, style: dayNameStyle),
                  if (schedule.isEnabled && schedule.totalMinutes > 0)
                    Text(
                      _formatHoursMinutesLabel(context, schedule.totalMinutes),
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                ],
              ),
            ),
            const SizedBox(width: 8),

            // Contenuto turni o "Non lavora" - wrap per adattarsi
            Expanded(
              child: schedule.isEnabled
                  ? Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        for (int i = 0; i < schedule.shifts.length; i++)
                          Padding(
                            padding: EdgeInsets.only(
                              bottom: i < schedule.shifts.length - 1 ? 8 : 0,
                            ),
                            child: _ShiftRow(
                              shift: schedule.shifts[i],
                              onChanged: (shift) => onShiftChanged(i, shift),
                              onAdd: onAddShift,
                              onRemove: () => onRemoveShift(i),
                              showAddButton: i == schedule.shifts.length - 1,
                              previousShiftEndTime: i > 0
                                  ? schedule.shifts[i - 1].endTime
                                  : null,
                              displayStepMinutes: displayStepMinutes,
                            ),
                          ),
                      ],
                    )
                  : Text(
                      l10n.weeklyScheduleNotWorking,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
            ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

/// Riga turno per layout mobile (senza icona add, con delete)
class _ShiftRowMobile extends StatelessWidget {
  final WorkShift shift;
  final ValueChanged<WorkShift> onChanged;
  final VoidCallback onRemove;

  /// Orario di fine della fascia precedente (se esiste).
  /// Usato per impostare il minimo dell'orario di inizio.
  final TimeOfDay? previousShiftEndTime;
  final int displayStepMinutes;

  const _ShiftRowMobile({
    required this.shift,
    required this.onChanged,
    required this.onRemove,
    this.previousShiftEndTime,
    this.displayStepMinutes = LayoutConfig.minutesPerSlotConst,
  });

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        // Orario inizio - minimo = fine fascia precedente (se esiste)
        _TimeDropdown(
          value: shift.startTime,
          minTime: previousShiftEndTime,
          onChanged: (time) => onChanged(shift.copyWith(startTime: time)),
          displayStepMinutes: displayStepMinutes,
        ),
        const SizedBox(width: 8),

        // "per"
        Text(
          l10n.weeklyScheduleFor,
          style: theme.textTheme.bodyMedium?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
        const SizedBox(width: 8),

        // Orario fine - minimo = orario inizio corrente
        _TimeDropdown(
          value: shift.endTime,
          minTime: shift.startTime,
          onChanged: (time) => onChanged(shift.copyWith(endTime: time)),
          displayStepMinutes: displayStepMinutes,
        ),
        const SizedBox(width: 8),

        // Pulsante rimuovi
        IconButton(
          onPressed: onRemove,
          icon: Icon(
            Icons.delete_outline,
            color: theme.colorScheme.error,
            size: 20,
          ),
          tooltip: l10n.weeklyScheduleRemoveShift,
          constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
          padding: EdgeInsets.zero,
        ),
      ],
    );
  }
}

/// Riga per un singolo turno con dropdown orari.
class _ShiftRow extends StatelessWidget {
  static const double _actionButtonWidth = 32;

  final WorkShift shift;
  final ValueChanged<WorkShift> onChanged;
  final VoidCallback onAdd;
  final VoidCallback onRemove;
  final bool showAddButton;

  /// Orario di fine della fascia precedente (se esiste).
  /// Usato per impostare il minimo dell'orario di inizio.
  final TimeOfDay? previousShiftEndTime;
  final int displayStepMinutes;

  const _ShiftRow({
    required this.shift,
    required this.onChanged,
    required this.onAdd,
    required this.onRemove,
    this.showAddButton = false,
    this.previousShiftEndTime,
    this.displayStepMinutes = LayoutConfig.minutesPerSlotConst,
  });

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        // Orario inizio - minimo = fine fascia precedente (se esiste)
        Flexible(
          child: _TimeDropdown(
            value: shift.startTime,
            minTime: previousShiftEndTime,
            onChanged: (time) => onChanged(shift.copyWith(startTime: time)),
            displayStepMinutes: displayStepMinutes,
          ),
        ),
        const SizedBox(width: 8),

        // "per"
        Text(
          l10n.weeklyScheduleFor,
          style: theme.textTheme.bodyMedium?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
        const SizedBox(width: 8),

        // Orario fine - minimo = orario inizio corrente
        Flexible(
          child: _TimeDropdown(
            value: shift.endTime,
            minTime: shift.startTime,
            onChanged: (time) => onChanged(shift.copyWith(endTime: time)),
            displayStepMinutes: displayStepMinutes,
          ),
        ),
        const SizedBox(width: 4),

        // Pulsante aggiungi (solo sull'ultimo turno)
        SizedBox(
          width: _actionButtonWidth,
          child: showAddButton
              ? IconButton(
                  onPressed: onAdd,
                  icon: Icon(
                    Icons.add_circle_outline,
                    color: theme.colorScheme.primary,
                    size: 20,
                  ),
                  tooltip: l10n.weeklyScheduleAddShift,
                  constraints: const BoxConstraints(
                    minWidth: _actionButtonWidth,
                    minHeight: _actionButtonWidth,
                  ),
                  padding: EdgeInsets.zero,
                  visualDensity: VisualDensity.compact,
                )
              : null,
        ),

        // Pulsante rimuovi
        SizedBox(
          width: _actionButtonWidth,
          child: IconButton(
            onPressed: onRemove,
            icon: Icon(
              Icons.delete_outline,
              color: theme.colorScheme.error,
              size: 20,
            ),
            tooltip: l10n.weeklyScheduleRemoveShift,
            constraints: const BoxConstraints(
              minWidth: _actionButtonWidth,
              minHeight: _actionButtonWidth,
            ),
            padding: EdgeInsets.zero,
            visualDensity: VisualDensity.compact,
          ),
        ),
      ],
    );
  }
}

/// Dropdown per la selezione dell'orario.
class _TimeDropdown extends StatelessWidget {
  final TimeOfDay value;
  final ValueChanged<TimeOfDay> onChanged;

  /// Orario minimo selezionabile (incluso). Se null, parte da 00:00.
  final TimeOfDay? minTime;

  /// Passo in minuti per generare le opzioni del picker.
  final int displayStepMinutes;

  /// Larghezza del dropdown (formato HH:MM + padding + icona)
  static const double dropdownWidth = 100.0;

  const _TimeDropdown({
    required this.value,
    required this.onChanged,
    this.minTime,
    this.displayStepMinutes = LayoutConfig.minutesPerSlotConst,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    // Genera opzioni con incremento pari a displayStepMinutes
    final allOptions = <TimeOfDay>[];
    for (int hour = 0; hour < 24; hour++) {
      for (int minute = 0; minute < 60; minute += displayStepMinutes) {
        allOptions.add(TimeOfDay(hour: hour, minute: minute));
      }
    }

    // Preserva il valore corrente anche se fuori passo (es. 09:30 con step 60)
    final valueMinutes = value.hour * 60 + value.minute;
    final alreadyPresent = allOptions.any(
      (t) => t.hour * 60 + t.minute == valueMinutes,
    );
    if (!alreadyPresent) {
      allOptions.add(value);
      allOptions.sort((a, b) =>
          (a.hour * 60 + a.minute).compareTo(b.hour * 60 + b.minute));
    }

    // Filtra le opzioni in base a minTime
    final options = allOptions.where((time) {
      final timeMinutes = time.hour * 60 + time.minute;
      if (minTime != null) {
        final minMinutes = minTime!.hour * 60 + minTime!.minute;
        if (timeMinutes < minMinutes) return false;
      }
      return true;
    }).toList();

    // Se non ci sono opzioni valide, usa tutte le opzioni
    final effectiveOptions = options.isEmpty ? allOptions : options;
    final currentValue = _findClosestOption(value, effectiveOptions);

    return SizedBox(
      width: dropdownWidth,
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          borderRadius: BorderRadius.circular(8),
          onTap: () => _openPicker(context, effectiveOptions, currentValue),
          child: Container(
            decoration: BoxDecoration(
              border: Border.all(color: theme.colorScheme.outline.withOpacity(0.5)),
              borderRadius: BorderRadius.circular(8),
            ),
            padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 10),
            child: Center(
              child: Text(
                _formatTime(currentValue),
                textAlign: TextAlign.center,
              ),
            ),
          ),
        ),
      ),
    );
  }

  void _openPicker(
    BuildContext context,
    List<TimeOfDay> options,
    TimeOfDay selected,
  ) {
    final isMobile = MediaQuery.sizeOf(context).width < 600;
    final future = isMobile
        ? showModalBottomSheet<TimeOfDay>(
            context: context,
            showDragHandle: true,
            builder: (_) => _TimeOptionsList(options: options, selected: selected),
          )
        : showDialog<TimeOfDay>(
            context: context,
            builder: (_) => Dialog(
              child: SizedBox(
                width: 320,
                height: 420,
                child: _TimeOptionsList(options: options, selected: selected),
              ),
            ),
          );
    future.then((picked) {
      if (picked != null) onChanged(picked);
    });
  }

  TimeOfDay _findClosestOption(TimeOfDay value, List<TimeOfDay> options) {
    // Trova l'opzione pi√π vicina al valore attuale
    TimeOfDay closest = options.first;
    int minDiff = _timeDiff(value, closest).abs();

    for (final option in options) {
      final diff = _timeDiff(value, option).abs();
      if (diff < minDiff) {
        minDiff = diff;
        closest = option;
      }
    }
    return closest;
  }

  int _timeDiff(TimeOfDay a, TimeOfDay b) {
    return (a.hour * 60 + a.minute) - (b.hour * 60 + b.minute);
  }

  String _formatTime(TimeOfDay time) {
    final hour = time.hour.toString().padLeft(2, '0');
    final minute = time.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }
}

class _TimeOptionsList extends StatefulWidget {
  const _TimeOptionsList({required this.options, required this.selected});

  final List<TimeOfDay> options;
  final TimeOfDay selected;

  @override
  State<_TimeOptionsList> createState() => _TimeOptionsListState();
}

class _TimeOptionsListState extends State<_TimeOptionsList> {
  static const double _checkSlotWidth = 28;
  static const double _itemExtent = 40;
  late final ScrollController _scrollController;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted || !_scrollController.hasClients) return;
      final selectedIndex = widget.options.indexWhere(
        (option) =>
            option.hour == widget.selected.hour &&
            option.minute == widget.selected.minute,
      );
      if (selectedIndex < 0) return;
      final selectedOffset = selectedIndex * _itemExtent;
      final targetOffset = (selectedOffset - (_itemExtent * 2)).clamp(
        0.0,
        _scrollController.position.maxScrollExtent,
      );
      _scrollController.jumpTo(targetOffset);
    });
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      controller: _scrollController,
      itemCount: widget.options.length,
      itemBuilder: (context, index) {
        final option = widget.options[index];
        final isSelected =
            option.hour == widget.selected.hour &&
            option.minute == widget.selected.minute;
        final label =
            '${option.hour.toString().padLeft(2, '0')}:${option.minute.toString().padLeft(2, '0')}';
        return InkWell(
          onTap: () => Navigator.of(context).pop(option),
          child: SizedBox(
            height: _itemExtent,
            child: Row(
              children: [
                const SizedBox(width: _checkSlotWidth),
                Expanded(child: Text(label, textAlign: TextAlign.center)),
                SizedBox(
                  width: _checkSlotWidth,
                  child: Padding(
                    padding: const EdgeInsets.only(right: 8),
                    child: isSelected
                        ? const Align(
                            alignment: Alignment.centerRight,
                            child: Icon(Icons.check, size: 18),
                          )
                        : const SizedBox.shrink(),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}

/// Stepper per il passo di visualizzazione orari (solo UI, non persiste).
/// Valori disponibili: 5, 10, 15, 20, 30, 60 minuti.
class _StepSelector extends StatelessWidget {
  static const _steps = [5, 10, 15, 20, 30, 60];

  final int value;
  final ValueChanged<int> onChanged;

  const _StepSelector({required this.value, required this.onChanged});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final idx = _steps.indexOf(value).clamp(0, _steps.length - 1);
    final canDecrease = idx > 0;
    final canIncrease = idx < _steps.length - 1;

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(
          'Intervallo:',
          style: theme.textTheme.bodyMedium?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
        const SizedBox(width: 8),
        IconButton(
          onPressed: canDecrease ? () => onChanged(_steps[idx - 1]) : null,
          icon: const Icon(Icons.remove),
          iconSize: 18,
          visualDensity: VisualDensity.compact,
          padding: EdgeInsets.zero,
          constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
          style: ButtonStyle(
            backgroundColor: WidgetStateProperty.all(Colors.transparent),
            shape: WidgetStateProperty.all(const CircleBorder()),
            side: WidgetStateProperty.resolveWith((states) {
              final alpha =
                  states.contains(WidgetState.disabled) ? 0.2 : 0.4;
              return BorderSide(
                color: theme.colorScheme.outline.withValues(alpha: alpha),
                width: 1,
              );
            }),
          ),
        ),
        SizedBox(
          width: 52,
          child: Text(
            '${value}min',
            textAlign: TextAlign.center,
            style: theme.textTheme.bodyMedium?.copyWith(
              fontWeight: FontWeight.w600,
            ),
          ),
        ),
        IconButton(
          onPressed: canIncrease ? () => onChanged(_steps[idx + 1]) : null,
          icon: const Icon(Icons.add),
          iconSize: 18,
          visualDensity: VisualDensity.compact,
          padding: EdgeInsets.zero,
          constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
          style: ButtonStyle(
            backgroundColor: WidgetStateProperty.all(Colors.transparent),
            shape: WidgetStateProperty.all(const CircleBorder()),
            side: WidgetStateProperty.resolveWith((states) {
              final alpha =
                  states.contains(WidgetState.disabled) ? 0.2 : 0.4;
              return BorderSide(
                color: theme.colorScheme.outline.withValues(alpha: alpha),
                width: 1,
              );
            }),
          ),
        ),
      ],
    );
  }
}
--- FILE: lib/features/staff/presentation/widgets/staff_item.dart ---
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/theme/extensions.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/staff.dart';
import '../../../services/providers/services_provider.dart';

class StaffItem extends ConsumerStatefulWidget {
  const StaffItem({
    super.key,
    required this.staff,
    required this.isLast,
    required this.isEvenRow,
    required this.isWide,
    required this.onEdit,
    required this.onDuplicate,
    required this.onDelete,
    this.trailingOverride,
    this.readOnly = false,
  });

  final Staff staff;
  final bool isLast;
  final bool isEvenRow;
  final bool isWide;
  final VoidCallback onEdit;
  final VoidCallback onDuplicate;
  final VoidCallback onDelete;
  final Widget? trailingOverride;
  final bool readOnly;

  @override
  ConsumerState<StaffItem> createState() => _StaffItemState();
}

class _StaffItemState extends ConsumerState<StaffItem> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final interactionColors = Theme.of(
      context,
    ).extension<AppInteractionColors>();
    final colorScheme = Theme.of(context).colorScheme;
    final baseColor = widget.isEvenRow
        ? (interactionColors?.alternatingRowFill ??
              colorScheme.onSurface.withOpacity(0.04))
        : Colors.transparent;
    final hoverFill =
        interactionColors?.hoverFill ??
        colorScheme.primaryContainer.withOpacity(0.1);
    final bgColor = _isHovered ? hoverFill : baseColor;

    final eligibleServices = ref.watch(
      eligibleServicesForStaffProvider(widget.staff.id),
    );
    final eligibleServicesCount = eligibleServices.length;

    return MouseRegion(
      cursor: SystemMouseCursors.click,
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: Container(
        decoration: BoxDecoration(
          color: bgColor,
          borderRadius: BorderRadius.only(
            bottomLeft: widget.isLast ? const Radius.circular(16) : Radius.zero,
            bottomRight: widget.isLast
                ? const Radius.circular(16)
                : Radius.zero,
          ),
        ),
        child: ListTile(
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 10,
          ),
          minVerticalPadding: 0,
          leading: StaffCircleAvatar(
            height: 36,
            color: widget.staff.color,
            isHighlighted: false,
            initials: widget.staff.initials,
          ),
          title: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Expanded(
                    child: Text(
                      widget.staff.displayName,
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                  const SizedBox(width: 8),
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 6,
                      vertical: 2,
                    ),
                    decoration: BoxDecoration(
                      color: colorScheme.surfaceContainerHighest,
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      'ID: ${widget.staff.id}',
                      style: Theme.of(context).textTheme.labelSmall?.copyWith(
                        color: colorScheme.onSurfaceVariant,
                        fontFamily: 'monospace',
                      ),
                    ),
                  ),
                ],
              ),
              if (eligibleServicesCount == 0) ...[
                const SizedBox(height: 2),
                Text(
                  context.l10n.teamEligibleServicesNone,
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.error,
                    fontStyle: FontStyle.italic,
                  ),
                ),
              ],
              if (!widget.staff.isBookableOnline) ...[
                const SizedBox(height: 2),
                Text(
                  context.l10n.staffNotBookableOnlineTooltip,
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.error,
                    fontStyle: FontStyle.italic,
                  ),
                ),
              ],
            ],
          ),
          onTap: widget.onEdit,
          mouseCursor: SystemMouseCursors.click,
          trailing:
              widget.trailingOverride ??
              (widget.readOnly
                  ? null
                  : widget.isWide
                  ? Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        IconButton(
                          tooltip: context.l10n.actionEdit,
                          icon: const Icon(Icons.edit_outlined),
                          onPressed: widget.onEdit,
                        ),
                        IconButton(
                          tooltip: context.l10n.duplicateAction,
                          icon: const Icon(Icons.copy_outlined),
                          onPressed: widget.onDuplicate,
                        ),
                        IconButton(
                          tooltip: context.l10n.actionDelete,
                          icon: const Icon(Icons.delete_outline),
                          onPressed: widget.onDelete,
                        ),
                      ],
                    )
                  : PopupMenuButton<String>(
                      onSelected: (value) {
                        if (value == 'edit') widget.onEdit();
                        if (value == 'duplicate') widget.onDuplicate();
                        if (value == 'delete') widget.onDelete();
                      },
                      itemBuilder: (context) => [
                        PopupMenuItem(
                          value: 'edit',
                          child: Text(context.l10n.actionEdit),
                        ),
                        PopupMenuItem(
                          value: 'duplicate',
                          child: Text(context.l10n.duplicateAction),
                        ),
                        PopupMenuItem(
                          value: 'delete',
                          child: Text(context.l10n.actionDelete),
                        ),
                      ],
                    )),
        ),
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/widgets/staff_hub_card.dart ---
import 'package:flutter/material.dart';

import '../../../../core/l10n/l10_extension.dart';

class StaffHubCard extends StatelessWidget {
  const StaffHubCard({
    super.key,
    required this.icon,
    required this.title,
    required this.subtitle,
    required this.onTap,
    this.disabled = false,
  });

  final IconData icon;
  final String title;
  final String subtitle;
  final VoidCallback onTap;
  final bool disabled;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final baseColor = disabled
        ? colorScheme.surfaceVariant
        : colorScheme.secondaryContainer;
    final fgColor = disabled
        ? colorScheme.onSurfaceVariant.withOpacity(0.6)
        : colorScheme.onSecondaryContainer;

    return InkWell(
      onTap: disabled ? null : onTap,
      borderRadius: BorderRadius.circular(12),
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 180),
        padding: const EdgeInsets.all(18),
        width: 260,
        decoration: BoxDecoration(
          color: baseColor,
          borderRadius: BorderRadius.circular(12),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.08),
              blurRadius: 6,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Icon(icon, size: 32, color: fgColor),
            const SizedBox(height: 12),
            Text(
              title,
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.w600,
                color: fgColor,
              ),
            ),
            const SizedBox(height: 6),
            Text(
              subtitle,
              style: TextStyle(fontSize: 14, color: fgColor.withOpacity(0.85)),
            ),
            if (disabled)
              Padding(
                padding: const EdgeInsets.only(top: 8.0),
                child: Text(
                  context.l10n.staffHubNotYetAvailable,
                  style: const TextStyle(
                    fontSize: 12,
                    fontStyle: FontStyle.italic,
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/widgets/location_item.dart ---
import 'package:flutter/material.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/location.dart';
import '../../../../core/models/staff.dart';
import '../../../services/presentation/widgets/empty_state.dart';
import 'staff_item.dart';

class LocationItem extends StatelessWidget {
  const LocationItem({
    super.key,
    required this.location,
    required this.staff,
    required this.isWide,
    required this.onAddStaff,
    required this.onEditLocation,
    required this.onDeleteLocation,
    required this.onEditStaff,
    required this.onDuplicateStaff,
    required this.onDeleteStaff,
    this.onManageResources,
    this.headerTrailing,
    this.staffListOverride,
    this.showDefaultActions = true,
    this.readOnly = false,
  });

  final Location location;
  final List<Staff> staff;
  final bool isWide;
  final VoidCallback onAddStaff;
  final VoidCallback onEditLocation;
  final VoidCallback onDeleteLocation;
  final ValueChanged<Staff> onEditStaff;
  final ValueChanged<Staff> onDuplicateStaff;
  final ValueChanged<Staff> onDeleteStaff;
  final VoidCallback? onManageResources;
  final Widget? headerTrailing;
  final Widget? staffListOverride;
  final bool showDefaultActions;
  final bool readOnly;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final isEmptyLocation = staff.isEmpty;

    return Container(
      margin: const EdgeInsets.only(bottom: 24),
      decoration: BoxDecoration(
        color: colorScheme.surface,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 6,
            offset: const Offset(0, 3),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            width: double.infinity,
            decoration: BoxDecoration(
              color: colorScheme.primaryContainer,
              borderRadius: const BorderRadius.vertical(
                top: Radius.circular(16),
              ),
            ),
            padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),
            child: Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Expanded(
                            child: Text(
                              location.name,
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                              style: Theme.of(context).textTheme.titleMedium
                                  ?.copyWith(
                                    fontWeight: FontWeight.w600,
                                    color: colorScheme.onPrimaryContainer,
                                  ),
                            ),
                          ),
                          const SizedBox(width: 8),
                          Container(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 6,
                              vertical: 2,
                            ),
                            decoration: BoxDecoration(
                              color: colorScheme.onPrimaryContainer.withOpacity(
                                0.15,
                              ),
                              borderRadius: BorderRadius.circular(4),
                            ),
                            child: Text(
                              'ID: ${location.id}',
                              style: Theme.of(context).textTheme.labelSmall
                                  ?.copyWith(
                                    color: colorScheme.onPrimaryContainer,
                                    fontFamily: 'monospace',
                                  ),
                            ),
                          ),
                        ],
                      ),
                      if (location.address != null &&
                          location.address!.isNotEmpty)
                        Padding(
                          padding: const EdgeInsets.only(top: 4),
                          child: Text(
                            location.address!,
                            maxLines: 2,
                            overflow: TextOverflow.ellipsis,
                            style: Theme.of(context).textTheme.bodySmall
                                ?.copyWith(
                                  color: colorScheme.onPrimaryContainer
                                      .withOpacity(0.8),
                                ),
                          ),
                        ),
                    ],
                  ),
                ),
                const SizedBox(width: 12),
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    if (showDefaultActions && !readOnly) ...[
                      IconButton(
                        tooltip: context.l10n.teamAddStaff,
                        icon: Icon(
                          Icons.person_add_alt_1,
                          color: colorScheme.onPrimaryContainer,
                        ),
                        onPressed: onAddStaff,
                      ),
                      if (onManageResources != null)
                        IconButton(
                          tooltip: context.l10n.resourcesTitle,
                          icon: Icon(
                            Icons.inventory_2_outlined,
                            color: colorScheme.onPrimaryContainer,
                          ),
                          onPressed: onManageResources,
                        ),
                      IconButton(
                        tooltip: context.l10n.actionEdit,
                        icon: Icon(
                          Icons.edit_outlined,
                          color: colorScheme.onPrimaryContainer,
                        ),
                        onPressed: onEditLocation,
                      ),
                      if (isEmptyLocation)
                        IconButton(
                          tooltip: context.l10n.actionDelete,
                          icon: const Icon(Icons.delete_outline),
                          color: colorScheme.onPrimaryContainer,
                          onPressed: onDeleteLocation,
                        ),
                    ],
                    if (headerTrailing != null) headerTrailing!,
                  ],
                ),
              ],
            ),
          ),
          ClipRRect(
            borderRadius: const BorderRadius.vertical(
              bottom: Radius.circular(16),
            ),
            child:
                staffListOverride ??
                (isEmptyLocation
                    ? ServicesEmptyState(
                        message: context.l10n.teamNoStaffInLocation,
                      )
                    : Column(
                        children: [
                          for (int i = 0; i < staff.length; i++)
                            StaffItem(
                              staff: staff[i],
                              isLast: i == staff.length - 1,
                              isEvenRow: i.isEven,
                              isWide: isWide,
                              readOnly: readOnly,
                              onEdit: () => onEditStaff(staff[i]),
                              onDuplicate: () => onDuplicateStaff(staff[i]),
                              onDelete: () => onDeleteStaff(staff[i]),
                            ),
                        ],
                      )),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/widgets/staff_planning_selector.dart ---
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/staff_planning.dart';
import 'package:agenda_backend/features/staff/presentation/dialogs/staff_planning_dialog.dart';
import 'package:agenda_backend/features/staff/providers/staff_planning_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

/// Widget che mostra la lista dei planning per uno staff e permette di
/// selezionarne uno, crearne uno nuovo o modificare quello esistente.
class StaffPlanningSelector extends ConsumerWidget {
  const StaffPlanningSelector({
    super.key,
    required this.staffId,
    required this.selectedPlanningId,
    required this.onPlanningSelected,
    this.onTemplateChanged,
    this.readOnly = false,
  });

  final int staffId;
  final int? selectedPlanningId;
  final ValueChanged<StaffPlanning?> onPlanningSelected;
  final bool readOnly;

  /// Callback quando viene cambiato il template (A/B) per biweekly
  final ValueChanged<WeekLabel>? onTemplateChanged;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final plannings = ref.watch(planningsForStaffProvider(staffId));
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final dateFormat = DateFormat.yMd(Intl.getCurrentLocale());

    // Trova il planning selezionato
    final selectedPlanning = selectedPlanningId != null
        ? plannings.where((p) => p.id == selectedPlanningId).firstOrNull
        : null;

    // Determina lo stato del planning (attivo, futuro, passato)
    String getPlanningStatus(StaffPlanning p) {
      final today = DateTime.now();
      if (p.isValidForDate(today)) return l10n.planningActive;
      if (p.validFrom.isAfter(today)) return l10n.planningFuture;
      return l10n.planningPast;
    }

    // Label per il planning
    String getPlanningLabel(StaffPlanning p) {
      final type = p.type == StaffPlanningType.weekly
          ? l10n.planningTypeWeekly
          : l10n.planningTypeBiweekly;
      final from = dateFormat.format(p.validFrom);
      final validity = p.validTo != null
          ? l10n.planningValidityRange(from, dateFormat.format(p.validTo!))
          : l10n.planningValidityFrom(from);
      return '$type ‚Ä¢ $validity';
    }

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        // Dropdown per selezionare planning
        if (plannings.isEmpty)
          OutlinedButton.icon(
            onPressed: readOnly ? null : () => _createPlanning(context, ref),
            icon: const Icon(Icons.add, size: 18),
            label: Text(l10n.planningListAdd),
          )
        else
          PopupMenuButton<int?>(
            tooltip: l10n.planningListTitle,
            onSelected: (id) {
              if (id == -1) {
                _createPlanning(context, ref);
              } else {
                final planning = plannings.where((p) => p.id == id).firstOrNull;
                onPlanningSelected(planning);
              }
            },
            itemBuilder: (context) => [
              // Header
              PopupMenuItem<int?>(
                enabled: false,
                child: Text(
                  l10n.planningListTitle,
                  style: theme.textTheme.titleSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              const PopupMenuDivider(),
              // Lista planning
              ...plannings.map(
                (p) => PopupMenuItem<int?>(
                  value: p.id,
                  child: Row(
                    children: [
                      if (p.id == selectedPlanningId)
                        Icon(
                          Icons.check,
                          size: 18,
                          color: theme.colorScheme.primary,
                        )
                      else
                        const SizedBox(width: 18),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Text(
                              getPlanningLabel(p),
                              style: theme.textTheme.bodyMedium,
                            ),
                            Text(
                              getPlanningStatus(p),
                              style: theme.textTheme.bodySmall?.copyWith(
                                color: p.isValidForDate(DateTime.now())
                                    ? theme.colorScheme.primary
                                    : theme.colorScheme.outline,
                              ),
                            ),
                          ],
                        ),
                      ),
                      // Edit button
                      if (!readOnly)
                        IconButton(
                          icon: const Icon(Icons.edit_outlined, size: 18),
                          onPressed: () {
                            Navigator.pop(context);
                            _editPlanning(context, ref, p);
                          },
                          tooltip: l10n.actionEdit,
                          padding: EdgeInsets.zero,
                          constraints: const BoxConstraints(
                            minWidth: 32,
                            minHeight: 32,
                          ),
                        ),
                    ],
                  ),
                ),
              ),
              if (!readOnly) ...[
                const PopupMenuDivider(),
                // Aggiungi nuovo
                PopupMenuItem<int?>(
                  value: -1,
                  child: Row(
                    children: [
                      Icon(Icons.add, size: 18, color: theme.colorScheme.primary),
                      const SizedBox(width: 8),
                      Text(
                        l10n.planningListAdd,
                        style: TextStyle(color: theme.colorScheme.primary),
                      ),
                    ],
                  ),
                ),
              ],
            ],
            child: Chip(
              avatar: Icon(
                selectedPlanning?.type == StaffPlanningType.biweekly
                    ? Icons.date_range_outlined
                    : Icons.view_week_outlined,
                size: 18,
              ),
              label: Text(
                selectedPlanning != null
                    ? getPlanningLabel(selectedPlanning)
                    : l10n.planningListEmpty,
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
              deleteIcon: const Icon(Icons.arrow_drop_down, size: 18),
              onDeleted: () {}, // Handled by PopupMenuButton
            ),
          ),

        // Toggle A/B per biweekly
        if (selectedPlanning?.type == StaffPlanningType.biweekly &&
            onTemplateChanged != null) ...[
          const SizedBox(width: 12),
          _WeekLabelToggle(
            planning: selectedPlanning!,
            onChanged: onTemplateChanged!,
          ),
        ],
      ],
    );
  }

  Future<void> _createPlanning(BuildContext context, WidgetRef ref) async {
    final result = await showStaffPlanningDialog(
      context,
      ref,
      staffId: staffId,
    );
    if (result != null) {
      onPlanningSelected(result);
    }
  }

  Future<void> _editPlanning(
    BuildContext context,
    WidgetRef ref,
    StaffPlanning planning,
  ) async {
    final result = await showStaffPlanningDialog(
      context,
      ref,
      staffId: staffId,
      initial: planning,
    );
    if (result != null) {
      onPlanningSelected(result);
    }
  }
}

/// Toggle per selezionare settimana A o B in un planning biweekly
class _WeekLabelToggle extends StatefulWidget {
  const _WeekLabelToggle({required this.planning, required this.onChanged});

  final StaffPlanning planning;
  final ValueChanged<WeekLabel> onChanged;

  @override
  State<_WeekLabelToggle> createState() => _WeekLabelToggleState();
}

class _WeekLabelToggleState extends State<_WeekLabelToggle> {
  late WeekLabel _currentLabel;

  @override
  void initState() {
    super.initState();
    // Calcola la settimana corrente
    _currentLabel = widget.planning.computeWeekLabel(DateTime.now());
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          l10n.planningCurrentWeek(_currentLabel == WeekLabel.a ? 'A' : 'B'),
          style: theme.textTheme.labelSmall?.copyWith(
            color: theme.colorScheme.outline,
          ),
        ),
        const SizedBox(height: 4),
        SegmentedButton<WeekLabel>(
          segments: [
            ButtonSegment(value: WeekLabel.a, label: Text(l10n.planningWeekA)),
            ButtonSegment(value: WeekLabel.b, label: Text(l10n.planningWeekB)),
          ],
          selected: {_currentLabel},
          onSelectionChanged: (selection) {
            setState(() => _currentLabel = selection.first);
            widget.onChanged(selection.first);
          },
        ),
      ],
    );
  }
}
--- FILE: lib/features/staff/presentation/widgets/exception_calendar_view.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/availability_exception.dart';
import '../../providers/availability_exceptions_provider.dart';
import '../dialogs/add_exception_dialog.dart';

/// Widget per visualizzare e gestire le eccezioni alla disponibilit√†
/// in una vista calendario mensile.
class ExceptionCalendarView extends ConsumerStatefulWidget {
  const ExceptionCalendarView({
    super.key,
    required this.staffId,
    this.readOnly = false,
  });

  final int staffId;
  final bool readOnly;

  @override
  ConsumerState<ExceptionCalendarView> createState() =>
      _ExceptionCalendarViewState();
}

String? _localizedReasonCode(String? code, BuildContext context) {
  if (code == null || code.isEmpty) return null;
  final l10n = context.l10n;
  switch (code) {
    case 'vacation':
      return l10n.exceptionReasonVacation;
    case 'extra_shift':
      return l10n.exceptionReasonExtraShift;
    case 'medical_visit':
      return l10n.exceptionReasonMedicalVisit;
  }
  return null;
}

class _ExceptionCalendarViewState extends ConsumerState<ExceptionCalendarView> {
  late DateTime _currentMonth;
  bool _isLoading = false;
  int? _loadedStaffId;

  @override
  void initState() {
    super.initState();
    _currentMonth = DateTime.now();
    _loadExceptions();
  }

  @override
  void didUpdateWidget(covariant ExceptionCalendarView oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Se lo staff √® cambiato, ricarica le eccezioni
    if (oldWidget.staffId != widget.staffId) {
      _loadedStaffId = null;
      _loadExceptions();
    }
  }

  Future<void> _loadExceptions() async {
    // Evita chiamate multiple per lo stesso staff
    if (_isLoading || _loadedStaffId == widget.staffId) return;

    _isLoading = true;
    try {
      // Carica eccezioni per un range di 3 mesi (mese corrente ¬± 1)
      final from = DateTime(_currentMonth.year, _currentMonth.month - 1, 1);
      final to = DateTime(_currentMonth.year, _currentMonth.month + 2, 0);
      await ref
          .read(availabilityExceptionsProvider.notifier)
          .loadExceptionsForStaff(widget.staffId, fromDate: from, toDate: to);
      _loadedStaffId = widget.staffId;
    } finally {
      _isLoading = false;
    }
  }

  void _previousMonth() {
    setState(() {
      _currentMonth = DateTime(_currentMonth.year, _currentMonth.month - 1, 1);
    });
    _loadedStaffId = null; // Forza ricaricamento per nuovo range
    _loadExceptions();
  }

  void _nextMonth() {
    setState(() {
      _currentMonth = DateTime(_currentMonth.year, _currentMonth.month + 1, 1);
    });
    _loadedStaffId = null; // Forza ricaricamento per nuovo range
    _loadExceptions();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final exceptions = ref.watch(allExceptionsForStaffProvider(widget.staffId));

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Header con titolo e navigazione mese
        Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              Expanded(
                child: Text(
                  l10n.exceptionsTitle,
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              FilledButton.icon(
                onPressed: widget.readOnly
                    ? null
                    : () => showAddExceptionDialog(
                        context,
                        ref,
                        staffId: widget.staffId,
                      ),
                icon: const Icon(Icons.add, size: 18),
                label: Text(l10n.exceptionsAdd),
              ),
            ],
          ),
        ),

        // Navigazione mese
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              IconButton(
                onPressed: _previousMonth,
                icon: const Icon(Icons.chevron_left),
              ),
              Text(
                _formatMonth(_currentMonth),
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
              ),
              IconButton(
                onPressed: _nextMonth,
                icon: const Icon(Icons.chevron_right),
              ),
            ],
          ),
        ),

        const SizedBox(height: 8),

        // Griglia calendario
        _CalendarGrid(
          month: _currentMonth,
          exceptions: exceptions,
          staffId: widget.staffId,
          onDayTap: (date) => _onDayTap(date, exceptions),
        ),

        const SizedBox(height: 16),

        // Lista eccezioni del mese
        _ExceptionsList(
          exceptions: _filterExceptionsForMonth(exceptions),
          staffId: widget.staffId,
          readOnly: widget.readOnly,
        ),
      ],
    );
  }

  String _formatMonth(DateTime date) {
    final locale = Localizations.localeOf(context).toLanguageTag();
    return DateFormat('MMMM y', locale).format(date);
  }

  List<AvailabilityException> _filterExceptionsForMonth(
    List<AvailabilityException> exceptions,
  ) {
    return exceptions.where((e) {
      return e.date.year == _currentMonth.year &&
          e.date.month == _currentMonth.month;
    }).toList()..sort((a, b) => a.date.compareTo(b.date));
  }

  void _onDayTap(DateTime date, List<AvailabilityException> exceptions) {
    if (widget.readOnly) return;
    final dayExceptions = exceptions.where((e) => e.isOnDate(date)).toList();

    if (dayExceptions.isEmpty) {
      // Nessuna eccezione: apri dialog per crearne una nuova
      showAddExceptionDialog(context, ref, staffId: widget.staffId, date: date);
    } else if (dayExceptions.length == 1) {
      // Una sola eccezione: apri dialog per modificarla
      showAddExceptionDialog(
        context,
        ref,
        staffId: widget.staffId,
        initial: dayExceptions.first,
      );
    } else {
      // Pi√π eccezioni: mostra bottom sheet con lista
      _showExceptionsForDay(date, dayExceptions);
    }
  }

  void _showExceptionsForDay(
    DateTime date,
    List<AvailabilityException> exceptions,
  ) {
    showModalBottomSheet(
      context: context,
      builder: (ctx) => SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Padding(
              padding: const EdgeInsets.all(16),
              child: Text(
                '${date.day}/${date.month}/${date.year}',
                style: Theme.of(ctx).textTheme.titleMedium,
              ),
            ),
            ...exceptions.map(
              (e) => ListTile(
                leading: Icon(
                  e.type == AvailabilityExceptionType.available
                      ? Icons.check_circle
                      : Icons.block,
                  color: e.type == AvailabilityExceptionType.available
                      ? Colors.green
                      : Theme.of(ctx).colorScheme.error,
                ),
                title: Text(
                  e.reason ??
                      _localizedReasonCode(e.reasonCode, context) ??
                      _getDefaultReason(e.type, context),
                ),
                subtitle: Text(
                  e.isAllDay
                      ? context.l10n.exceptionAllDay
                      : _formatTimeRange(e, context),
                ),
                onTap: () {
                  Navigator.pop(ctx);
                  showAddExceptionDialog(
                    context,
                    ref,
                    staffId: widget.staffId,
                    initial: e,
                  );
                },
              ),
            ),
            const SizedBox(height: 16),
          ],
        ),
      ),
    );
  }

  String _getDefaultReason(
    AvailabilityExceptionType type,
    BuildContext context,
  ) {
    return type == AvailabilityExceptionType.available
        ? context.l10n.exceptionTypeAvailable
        : context.l10n.exceptionTypeUnavailable;
  }

  String _formatTimeRange(AvailabilityException e, BuildContext context) {
    if (e.isAllDay) return context.l10n.exceptionAllDay;
    final start =
        '${e.startTime!.hour.toString().padLeft(2, '0')}:${e.startTime!.minute.toString().padLeft(2, '0')}';
    final end =
        '${e.endTime!.hour.toString().padLeft(2, '0')}:${e.endTime!.minute.toString().padLeft(2, '0')}';
    return '$start - $end';
  }
}

/// Griglia calendario mensile.
class _CalendarGrid extends ConsumerWidget {
  const _CalendarGrid({
    required this.month,
    required this.exceptions,
    required this.staffId,
    required this.onDayTap,
  });

  final DateTime month;
  final List<AvailabilityException> exceptions;
  final int staffId;
  final ValueChanged<DateTime> onDayTap;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    // Calcola primo e ultimo giorno del mese
    final firstDay = DateTime(month.year, month.month, 1);
    final lastDay = DateTime(month.year, month.month + 1, 0);
    final daysInMonth = lastDay.day;

    // Giorno della settimana del primo giorno (1=lun, 7=dom)
    final firstWeekday = firstDay.weekday;

    // Celle vuote iniziali + giorni del mese
    final totalCells = ((firstWeekday - 1) + daysInMonth);
    final rows = (totalCells / 7).ceil();

    final today = DateTime.now();

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      child: Column(
        children: [
          // Header giorni settimana
          Row(
            children: ['L', 'M', 'M', 'G', 'V', 'S', 'D']
                .map(
                  (d) => Expanded(
                    child: Center(
                      child: Text(
                        d,
                        style: theme.textTheme.bodySmall?.copyWith(
                          fontWeight: FontWeight.bold,
                          color: colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ),
                  ),
                )
                .toList(),
          ),
          const SizedBox(height: 8),
          // Griglia giorni
          ...List.generate(rows, (rowIndex) {
            return Row(
              children: List.generate(7, (colIndex) {
                final cellIndex = rowIndex * 7 + colIndex;
                final dayNumber = cellIndex - (firstWeekday - 1) + 1;

                if (dayNumber < 1 || dayNumber > daysInMonth) {
                  return const Expanded(child: SizedBox(height: 44));
                }

                final date = DateTime(month.year, month.month, dayNumber);
                final isToday =
                    date.year == today.year &&
                    date.month == today.month &&
                    date.day == today.day;

                // Trova eccezioni per questo giorno
                final dayExceptions = exceptions
                    .where((e) => e.isOnDate(date))
                    .toList();

                return Expanded(
                  child: GestureDetector(
                    onTap: () => onDayTap(date),
                    child: Container(
                      height: 44,
                      margin: const EdgeInsets.all(2),
                      decoration: BoxDecoration(
                        color: isToday
                            ? colorScheme.primaryContainer.withOpacity(0.5)
                            : null,
                        borderRadius: BorderRadius.circular(8),
                        border: isToday
                            ? Border.all(color: colorScheme.primary, width: 2)
                            : null,
                      ),
                      child: Stack(
                        alignment: Alignment.center,
                        children: [
                          Text(
                            dayNumber.toString(),
                            style: theme.textTheme.bodyMedium?.copyWith(
                              fontWeight: isToday
                                  ? FontWeight.bold
                                  : FontWeight.normal,
                            ),
                          ),
                          // Indicatori eccezioni
                          if (dayExceptions.isNotEmpty)
                            Positioned(
                              bottom: 4,
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: dayExceptions.take(3).map((e) {
                                  return Container(
                                    width: 6,
                                    height: 6,
                                    margin: const EdgeInsets.symmetric(
                                      horizontal: 1,
                                    ),
                                    decoration: BoxDecoration(
                                      shape: BoxShape.circle,
                                      color:
                                          e.type ==
                                              AvailabilityExceptionType
                                                  .available
                                          ? Colors.green
                                          : colorScheme.error,
                                    ),
                                  );
                                }).toList(),
                              ),
                            ),
                        ],
                      ),
                    ),
                  ),
                );
              }),
            );
          }),
        ],
      ),
    );
  }
}

/// Lista delle eccezioni del mese.
class _ExceptionsList extends ConsumerWidget {
  const _ExceptionsList({
    required this.exceptions,
    required this.staffId,
    required this.readOnly,
  });

  final List<AvailabilityException> exceptions;
  final int staffId;
  final bool readOnly;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final colorScheme = theme.colorScheme;

    if (exceptions.isEmpty) {
      return Padding(
        padding: const EdgeInsets.all(16),
        child: Center(
          child: Text(
            l10n.exceptionsEmpty,
            style: theme.textTheme.bodyMedium?.copyWith(
              color: colorScheme.onSurfaceVariant,
            ),
          ),
        ),
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Divider(),
        ...exceptions.map(
          (e) => _ExceptionTile(
            exception: e,
            staffId: staffId,
            readOnly: readOnly,
          ),
        ),
      ],
    );
  }
}

/// Tile per singola eccezione.
class _ExceptionTile extends ConsumerWidget {
  const _ExceptionTile({
    required this.exception,
    required this.staffId,
    required this.readOnly,
  });

  final AvailabilityException exception;
  final int staffId;
  final bool readOnly;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    final isAvailable = exception.type == AvailabilityExceptionType.available;
    final color = isAvailable ? Colors.green : colorScheme.error;

    return ListTile(
      leading: Container(
        width: 40,
        height: 40,
        decoration: BoxDecoration(
          color: color.withOpacity(0.1),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Icon(
          isAvailable ? Icons.check_circle_outline : Icons.block_outlined,
          color: color,
        ),
      ),
      title: Text(
        exception.reason ??
            _localizedReasonCode(exception.reasonCode, context) ??
            (isAvailable
                ? context.l10n.exceptionTypeAvailable
                : context.l10n.exceptionTypeUnavailable),
        style: theme.textTheme.bodyLarge,
      ),
      subtitle: Text(
        '${_formatDate(context, exception.date)} ‚Ä¢ ${_formatTimeRange(exception, context)}',
        style: theme.textTheme.bodySmall?.copyWith(
          color: colorScheme.onSurfaceVariant,
        ),
      ),
      trailing: IconButton(
        icon: const Icon(Icons.edit_outlined),
        onPressed: readOnly
            ? null
            : () => showAddExceptionDialog(
                context,
                ref,
                staffId: staffId,
                initial: exception,
              ),
      ),
      onTap: readOnly
          ? null
          : () => showAddExceptionDialog(
              context,
              ref,
              staffId: staffId,
              initial: exception,
            ),
    );
  }

  String _formatDate(BuildContext context, DateTime date) {
    final locale = Localizations.localeOf(context).toLanguageTag();
    final weekday = DateFormat('EEE', locale).format(date);
    return '$weekday ${date.day}/${date.month}';
  }

  String _formatTimeRange(AvailabilityException e, BuildContext context) {
    if (e.isAllDay) return context.l10n.exceptionAllDay;
    final start =
        '${e.startTime!.hour.toString().padLeft(2, '0')}:${e.startTime!.minute.toString().padLeft(2, '0')}';
    final end =
        '${e.endTime!.hour.toString().padLeft(2, '0')}:${e.endTime!.minute.toString().padLeft(2, '0')}';
    return '$start - $end';
  }
}
--- FILE: lib/features/staff/presentation/widgets/resource_service_picker.dart ---
import 'package:flutter/material.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_dividers.dart';

/// Picker per selezionare servizi multipli da associare a una risorsa.
/// Simile al ServicePickerField ma:
/// - Permette selezione multipla
/// - Non ha il checkbox "visualizza tutti"
/// - Non ha la sezione pacchetti
/// - Non ha la sezione servizi popolari
class ResourceServicePicker extends StatelessWidget {
  const ResourceServicePicker({
    super.key,
    required this.services,
    required this.categories,
    required this.selectedServiceVariantIds,
    required this.onSelectionChanged,
    required this.formFactor,
  });

  final List<Service> services;
  final List<ServiceCategory> categories;
  final Set<int> selectedServiceVariantIds;
  final ValueChanged<Set<int>> onSelectionChanged;
  final AppFormFactor formFactor;

  Future<void> _openPicker(BuildContext context) async {
    final result = await _showPickerSheet(context);
    if (result != null) {
      onSelectionChanged(result);
    }
  }

  Future<Set<int>?> _showPickerSheet(BuildContext context) async {
    final isDesktop = formFactor == AppFormFactor.desktop;

    if (!isDesktop) {
      return AppBottomSheet.show<Set<int>>(
        context: context,
        heightFactor: 0.85,
        builder: (ctx) => _ResourceServicePickerContent(
          services: services,
          categories: categories,
          selectedIds: selectedServiceVariantIds,
        ),
      );
    }

    // Desktop: dialog
    return showDialog<Set<int>>(
      context: context,
      builder: (ctx) => Dialog(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 480, maxHeight: 600),
          child: _ResourceServicePickerContent(
            services: services,
            categories: categories,
            selectedIds: selectedServiceVariantIds,
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    // Ottieni i nomi dei servizi selezionati
    final selectedServices = <Service>[];
    for (final service in services) {
      final variantId = service.serviceVariantId;
      if (variantId != null && selectedServiceVariantIds.contains(variantId)) {
        selectedServices.add(service);
      }
    }

    return InkWell(
      onTap: () => _openPicker(context),
      borderRadius: BorderRadius.circular(4),
      child: InputDecorator(
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
          contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 12),
        ),
        child: Row(
          children: [
            Expanded(
              child: selectedServices.isEmpty
                  ? Text(
                      l10n.resourceNoServicesSelected,
                      style: TextStyle(color: colorScheme.outline),
                    )
                  : Wrap(
                      spacing: 4,
                      runSpacing: 4,
                      children: [
                        for (final service in selectedServices)
                          Chip(
                            label: Text(
                              service.name,
                              style: const TextStyle(fontSize: 12),
                            ),
                            visualDensity: VisualDensity.compact,
                            materialTapTargetSize:
                                MaterialTapTargetSize.shrinkWrap,
                            padding: EdgeInsets.zero,
                            labelPadding: const EdgeInsets.symmetric(
                              horizontal: 8,
                            ),
                          ),
                      ],
                    ),
            ),
            Text(
              '${selectedServiceVariantIds.length}/${services.length}',
              style: TextStyle(color: colorScheme.outline, fontSize: 12),
            ),
            const SizedBox(width: 8),
            Icon(Icons.arrow_drop_down, color: colorScheme.outline),
          ],
        ),
      ),
    );
  }
}

/// Contenuto del picker per servizi multipli.
class _ResourceServicePickerContent extends StatefulWidget {
  const _ResourceServicePickerContent({
    required this.services,
    required this.categories,
    required this.selectedIds,
  });

  final List<Service> services;
  final List<ServiceCategory> categories;
  final Set<int> selectedIds;

  @override
  State<_ResourceServicePickerContent> createState() =>
      _ResourceServicePickerContentState();
}

class _ResourceServicePickerContentState
    extends State<_ResourceServicePickerContent> {
  final _searchController = TextEditingController();
  final _searchFocusNode = FocusNode();
  final _scrollController = ScrollController();
  String _searchQuery = '';
  late Set<int> _selectedIds;

  @override
  void initState() {
    super.initState();
    _selectedIds = {...widget.selectedIds};

    // Auto-focus sul campo di ricerca dopo il primo build
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        _searchFocusNode.requestFocus();
      }
    });
  }

  @override
  void dispose() {
    _searchController.dispose();
    _searchFocusNode.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  List<Service> get _filteredServices {
    var services = widget.services;

    // Filtra per query di ricerca
    if (_searchQuery.isNotEmpty) {
      final query = _searchQuery.toLowerCase();
      services = services
          .where((s) => s.name.toLowerCase().contains(query))
          .toList();
    }

    return services;
  }

  void _toggleService(int variantId) {
    setState(() {
      if (_selectedIds.contains(variantId)) {
        _selectedIds.remove(variantId);
      } else {
        _selectedIds.add(variantId);
      }
    });
  }

  void _selectAll() {
    setState(() {
      for (final service in _filteredServices) {
        final variantId = service.serviceVariantId;
        if (variantId != null) {
          _selectedIds.add(variantId);
        }
      }
    });
  }

  void _deselectAll() {
    setState(() {
      for (final service in _filteredServices) {
        final variantId = service.serviceVariantId;
        if (variantId != null) {
          _selectedIds.remove(variantId);
        }
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final colorScheme = theme.colorScheme;

    final filteredServices = _filteredServices;

    final servicesByCategory = <int, List<Service>>{};
    for (final service in filteredServices) {
      (servicesByCategory[service.categoryId] ??= []).add(service);
    }

    final hasServicesMap = <int, bool>{
      for (final category in widget.categories)
        category.id: (servicesByCategory[category.id]?.isNotEmpty ?? false),
    };

    // Sort categories: non-empty before empty, then sortOrder, then name
    final sortedCategories = [...widget.categories]
      ..sort((a, b) {
        final aEmpty = !(hasServicesMap[a.id] ?? false);
        final bEmpty = !(hasServicesMap[b.id] ?? false);
        if (aEmpty != bEmpty) return aEmpty ? 1 : -1;
        final so = a.sortOrder.compareTo(b.sortOrder);
        return so != 0
            ? so
            : a.name.toLowerCase().compareTo(b.name.toLowerCase());
      });

    final showSearchField =
        widget.services.length > 10 || _searchQuery.isNotEmpty;

    // Calcola se tutti i servizi filtrati sono selezionati
    final allFilteredSelected = filteredServices.every((s) {
      final variantId = s.serviceVariantId;
      return variantId != null && _selectedIds.contains(variantId);
    });

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Header con pulsanti azioni
        Padding(
          padding: const EdgeInsets.fromLTRB(16, 12, 8, 8),
          child: Row(
            children: [
              Expanded(
                child: Text(
                  l10n.resourceSelectServices,
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
              // Pulsante seleziona/deseleziona tutti
              TextButton(
                onPressed: allFilteredSelected ? _deselectAll : _selectAll,
                child: Text(
                  allFilteredSelected
                      ? l10n.actionDeselectAll
                      : l10n.actionSelectAll,
                ),
              ),
            ],
          ),
        ),
        // Campo di ricerca (solo se > 10 servizi)
        if (showSearchField)
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: TextField(
              controller: _searchController,
              focusNode: _searchFocusNode,
              decoration: InputDecoration(
                hintText: l10n.searchServices,
                prefixIcon: const Icon(Icons.search, size: 20),
                suffixIcon: _searchQuery.isNotEmpty
                    ? IconButton(
                        icon: const Icon(Icons.clear, size: 20),
                        onPressed: () {
                          setState(() {
                            _searchController.clear();
                            _searchQuery = '';
                          });
                        },
                      )
                    : null,
                isDense: true,
                contentPadding: const EdgeInsets.symmetric(
                  horizontal: 12,
                  vertical: 10,
                ),
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
              ),
              onChanged: (value) {
                setState(() {
                  _searchQuery = value;
                });
              },
            ),
          ),
        const SizedBox(height: 8),
        const AppDivider(),
        // Lista servizi
        Expanded(
          child: filteredServices.isEmpty
              ? Center(
                  child: Text(
                    l10n.noServicesFound,
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: colorScheme.onSurfaceVariant,
                    ),
                  ),
                )
              : ListView(
                  controller: _scrollController,
                  children: [
                    for (final category in sortedCategories)
                      Builder(
                        builder: (ctx) {
                          final categoryServices =
                              (servicesByCategory[category.id] ?? []).toList()
                                ..sort((a, b) {
                                  final so = a.sortOrder.compareTo(b.sortOrder);
                                  return so != 0
                                      ? so
                                      : a.name.toLowerCase().compareTo(
                                          b.name.toLowerCase(),
                                        );
                                });

                          if (categoryServices.isEmpty) {
                            return const SizedBox.shrink();
                          }

                          return _CategorySection(
                            category: category,
                            services: categoryServices,
                            selectedIds: _selectedIds,
                            onToggle: _toggleService,
                          );
                        },
                      ),
                  ],
                ),
        ),
        const AppDivider(),
        // Footer con pulsanti conferma/annulla
        Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(),
                child: Text(l10n.actionCancel),
              ),
              const SizedBox(width: 12),
              FilledButton(
                onPressed: () => Navigator.of(context).pop(_selectedIds),
                child: Text(l10n.actionConfirm),
              ),
            ],
          ),
        ),
      ],
    );
  }
}

/// Sezione categoria con checkbox per selezione multipla.
class _CategorySection extends StatelessWidget {
  const _CategorySection({
    required this.category,
    required this.services,
    required this.selectedIds,
    required this.onToggle,
  });

  final ServiceCategory category;
  final List<Service> services;
  final Set<int> selectedIds;
  final ValueChanged<int> onToggle;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Category header
        Padding(
          padding: const EdgeInsets.fromLTRB(16, 12, 16, 4),
          child: Text(
            category.name,
            style: theme.textTheme.titleSmall?.copyWith(
              fontWeight: FontWeight.w600,
              color: colorScheme.primary,
            ),
          ),
        ),
        // Services
        for (final service in services)
          Builder(
            builder: (context) {
              final variantId = service.serviceVariantId;
              if (variantId == null) return const SizedBox.shrink();

              final isSelected = selectedIds.contains(variantId);

              return CheckboxListTile(
                value: isSelected,
                onChanged: (_) => onToggle(variantId),
                title: Text(service.name, style: theme.textTheme.bodyMedium),
                dense: true,
                controlAffinity: ListTileControlAffinity.leading,
                contentPadding: const EdgeInsets.symmetric(horizontal: 8),
              );
            },
          ),
      ],
    );
  }
}
--- FILE: lib/features/staff/widgets/staff_top_controls.dart ---
import 'package:agenda_backend/app/widgets/top_controls.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class StaffTopControls extends ConsumerWidget {
  const StaffTopControls({
    super.key,
    this.todayLabel,
    this.labelOverride,
    this.compact = false,
  });

  final String? todayLabel;
  final String? labelOverride;
  final bool compact;
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return TopControls.staff(
      todayLabel: todayLabel,
      labelOverride: labelOverride,
      compact: compact,
    );
  }
}
--- FILE: lib/features/services/services_feature.dart ---
--- FILE: lib/features/services/providers/service_packages_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/service_package.dart';
import '../../agenda/providers/location_providers.dart';
import '../../auth/providers/auth_provider.dart';
import 'service_packages_repository_provider.dart';

class ServicePackagesNotifier extends AsyncNotifier<List<ServicePackage>> {
  @override
  Future<List<ServicePackage>> build() async {
    final authState = ref.watch(authProvider);
    if (!authState.isAuthenticated) {
      return [];
    }

    final location = ref.watch(currentLocationProvider);
    if (location.id <= 0) {
      return [];
    }

    final repository = ref.watch(servicePackagesRepositoryProvider);
    return repository.getPackages(locationId: location.id);
  }

  Future<void> refresh() async {
    final authState = ref.read(authProvider);
    if (!authState.isAuthenticated) {
      return;
    }

    final location = ref.read(currentLocationProvider);
    if (location.id <= 0) {
      return;
    }

    state = const AsyncLoading();
    try {
      final repository = ref.read(servicePackagesRepositoryProvider);
      final packages = await repository.getPackages(locationId: location.id);
      state = AsyncData(packages);
    } catch (e, st) {
      state = AsyncError(e, st);
    }
  }

  Future<ServicePackage?> createPackage({
    required String name,
    required int categoryId,
    required List<int> serviceIds,
    String? description,
    double? overridePrice,
    int? overrideDurationMinutes,
    bool isActive = true,
  }) async {
    final location = ref.read(currentLocationProvider);
    if (location.id <= 0) return null;

    try {
      final repository = ref.read(servicePackagesRepositoryProvider);
      var created = await repository.createPackage(
        locationId: location.id,
        name: name,
        categoryId: categoryId,
        serviceIds: serviceIds,
        description: description,
        overridePrice: overridePrice,
        overrideDurationMinutes: overrideDurationMinutes,
        isActive: isActive,
      );
      if (created.categoryId == 0 && categoryId > 0) {
        created = created.copyWith(categoryId: categoryId);
      }

      final current = state.value ?? [];
      state = AsyncData([...current, created]);
      return created;
    } catch (e, st) {
      state = AsyncError(e, st);
      return null;
    }
  }

  Future<ServicePackage?> updatePackage({
    required int packageId,
    String? name,
    int? categoryId,
    String? description,
    double? overridePrice,
    int? overrideDurationMinutes,
    bool setOverridePriceNull = false,
    bool setOverrideDurationNull = false,
    bool? isActive,
    List<int>? serviceIds,
  }) async {
    final location = ref.read(currentLocationProvider);
    if (location.id <= 0) return null;

    try {
      final repository = ref.read(servicePackagesRepositoryProvider);
      var updated = await repository.updatePackage(
        locationId: location.id,
        packageId: packageId,
        name: name,
        categoryId: categoryId,
        description: description,
        overridePrice: overridePrice,
        overrideDurationMinutes: overrideDurationMinutes,
        setOverridePriceNull: setOverridePriceNull,
        setOverrideDurationNull: setOverrideDurationNull,
        isActive: isActive,
        serviceIds: serviceIds,
      );
      if (updated.categoryId == 0 && categoryId != null && categoryId > 0) {
        updated = updated.copyWith(categoryId: categoryId);
      }

      final current = state.value ?? [];
      final index = current.indexWhere((p) => p.id == packageId);
      if (index >= 0) {
        final updatedList = [...current];
        updatedList[index] = updated;
        state = AsyncData(updatedList);
      } else {
        state = AsyncData([...current, updated]);
      }

      return updated;
    } catch (e, st) {
      state = AsyncError(e, st);
      return null;
    }
  }

  Future<void> deletePackage(int packageId) async {
    final location = ref.read(currentLocationProvider);
    if (location.id <= 0) return;

    final current = state.value ?? [];
    state = AsyncData(current.where((p) => p.id != packageId).toList());

    try {
      final repository = ref.read(servicePackagesRepositoryProvider);
      await repository.deletePackage(
        locationId: location.id,
        packageId: packageId,
      );
    } catch (e, st) {
      state = AsyncError(e, st);
    }
  }

  void setPackages(List<ServicePackage> packages) {
    state = AsyncData(packages);
  }
}

final servicePackagesProvider =
    AsyncNotifierProvider<ServicePackagesNotifier, List<ServicePackage>>(
      ServicePackagesNotifier.new,
    );
--- FILE: lib/features/services/providers/services_sorted_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/models/service_package.dart';
import 'service_categories_provider.dart';
import 'service_packages_provider.dart';
import 'services_provider.dart';

class ServiceCategoryEntry {
  final Service? service;
  final ServicePackage? package;

  const ServiceCategoryEntry._({this.service, this.package});

  const ServiceCategoryEntry.service(Service service)
    : this._(service: service);

  const ServiceCategoryEntry.package(ServicePackage package)
    : this._(package: package);

  bool get isService => service != null;

  int get id => service?.id ?? package!.id;

  int get categoryId => service?.categoryId ?? package!.categoryId;

  int get sortOrder => service?.sortOrder ?? package!.sortOrder;

  String get name => service?.name ?? package!.name;

  String get key => isService ? 'service-$id' : 'package-$id';
}

/// Liste ordinate con queste priorit√†:
/// 1) Categorie con servizi prima, categorie vuote in coda
/// 2) sortOrder crescente
/// 3) nome come tie-breaker
final sortedCategoriesProvider = Provider<List<ServiceCategory>>((ref) {
  final cats = ref.watch(serviceCategoriesProvider);

  // Pre-calcolo: per ogni categoria verifichiamo se ha servizi.
  final hasServicesMap = <int, bool>{
    for (final c in cats)
      c.id: ref.watch(servicesByCategoryProvider(c.id)).isNotEmpty ||
          ref.watch(servicePackagesByCategoryProvider(c.id)).isNotEmpty,
  };

  final copy = [...cats];
  copy.sort((a, b) {
    final aEmpty = !(hasServicesMap[a.id] ?? false);
    final bEmpty = !(hasServicesMap[b.id] ?? false);

    // Vuote in coda: una categoria vuota deve venire dopo una non vuota.
    if (aEmpty != bEmpty) return aEmpty ? 1 : -1;

    final so = a.sortOrder.compareTo(b.sortOrder);
    return so != 0 ? so : a.name.toLowerCase().compareTo(b.name.toLowerCase());
  });
  return copy;
});

final sortedServicesByCategoryProvider = Provider.family<List<Service>, int>((
  ref,
  categoryId,
) {
  final services = ref.watch(servicesByCategoryProvider(categoryId));
  final copy = [...services];
  copy.sort((a, b) {
    final so = a.sortOrder.compareTo(b.sortOrder);
    return so != 0 ? so : a.name.toLowerCase().compareTo(b.name.toLowerCase());
  });
  return copy;
});

final servicePackagesByCategoryProvider =
    Provider.family<List<ServicePackage>, int>((ref, categoryId) {
      final packages = ref.watch(servicePackagesProvider).value ?? [];
      final services = ref.watch(servicesProvider).value ?? const [];
      final serviceById = {for (final s in services) s.id: s};
      return packages
          .map((p) {
            if (p.categoryId != 0) return p;
            final effectiveCategoryId = p.items.isNotEmpty
                ? serviceById[p.items.first.serviceId]?.categoryId
                : null;
            if (effectiveCategoryId == null || effectiveCategoryId == 0) {
              return p;
            }
            return p.copyWith(categoryId: effectiveCategoryId);
          })
          .where((p) => p.categoryId == categoryId)
          .toList();
    });

final sortedServicePackagesByCategoryProvider =
    Provider.family<List<ServicePackage>, int>((ref, categoryId) {
      final packages = ref.watch(servicePackagesByCategoryProvider(categoryId));
      final copy = [...packages];
      copy.sort((a, b) {
        final so = a.sortOrder.compareTo(b.sortOrder);
        return so != 0
            ? so
            : a.name.toLowerCase().compareTo(b.name.toLowerCase());
      });
      return copy;
    });

final sortedCategoryEntriesProvider =
    Provider.family<List<ServiceCategoryEntry>, int>((ref, categoryId) {
      final services = ref.watch(sortedServicesByCategoryProvider(categoryId));
      final packages = ref.watch(
        sortedServicePackagesByCategoryProvider(categoryId),
      );
      final entries = <ServiceCategoryEntry>[
        for (final service in services)
          ServiceCategoryEntry.service(service),
        for (final package in packages)
          ServiceCategoryEntry.package(package),
      ];
      entries.sort((a, b) {
        final so = a.sortOrder.compareTo(b.sortOrder);
        return so != 0
            ? so
            : a.name.toLowerCase().compareTo(b.name.toLowerCase());
      });
      return entries;
    });
--- FILE: lib/features/services/providers/services_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/models/service_staff_eligibility.dart';
import '../../../core/models/service_variant.dart';
import '../../agenda/providers/business_providers.dart';
import '../../agenda/providers/location_providers.dart';
import '../../auth/providers/auth_provider.dart';
import '../../auth/providers/current_business_user_provider.dart';
import '../../staff/providers/staff_providers.dart';
import '../utils/service_seed_texts.dart';
import 'service_categories_provider.dart';
import 'services_repository_provider.dart';

// Le categorie sono ora gestite in providers/service_categories_provider.dart

///
/// SERVICES PER LOCATION IDS (per staff dialog)
///
/// Carica servizi da multiple location. Usato nel dialog staff per mostrare
/// solo i servizi delle location assegnate allo staff.
///
class ServicesForLocationsResult {
  final List<Service> services;
  final List<ServiceCategory> categories;

  const ServicesForLocationsResult({
    required this.services,
    required this.categories,
  });
}

/// Provider che carica servizi per una lista di location.
/// La chiave √® una stringa con gli ID separati da virgola (es. "2,7").
/// Usare `locationIdsToKey` per convertire un `Set<int>` in chiave.
String locationIdsToKey(Set<int> locationIds) {
  final sorted = locationIds.toList()..sort();
  return sorted.join(',');
}

Set<int> keyToLocationIds(String key) {
  if (key.isEmpty) return {};
  return key.split(',').map(int.parse).toSet();
}

/// Trigger per forzare il refresh di servicesForLocationsProvider
/// Incrementato quando i servizi vengono creati/modificati/eliminati
class ServicesForLocationsRefreshNotifier extends Notifier<int> {
  @override
  int build() => 0;

  void trigger() => state++;
}

final servicesForLocationsRefreshProvider =
    NotifierProvider<ServicesForLocationsRefreshNotifier, int>(
      ServicesForLocationsRefreshNotifier.new,
    );

final servicesForLocationsProvider =
    FutureProvider.family<ServicesForLocationsResult, String>((
      ref,
      locationIdsKey,
    ) async {
      // Watch del refresh trigger per invalidare la cache
      ref.watch(servicesForLocationsRefreshProvider);
      final locationIds = keyToLocationIds(locationIdsKey);

      if (locationIds.isEmpty) {
        return const ServicesForLocationsResult(services: [], categories: []);
      }

      final repository = ref.watch(servicesRepositoryProvider);
      final allServices = <Service>[];
      final categoryMap = <int, ServiceCategory>{};

      // Carica servizi da tutte le location
      for (final locationId in locationIds) {
        final result = await repository.getServicesWithCategories(
          locationId: locationId,
        );
        allServices.addAll(result.services);
        for (final cat in result.categories) {
          categoryMap[cat.id] = cat;
        }
      }

      // Ordina per nome
      allServices.sort((a, b) => a.name.compareTo(b.name));

      return ServicesForLocationsResult(
        services: allServices,
        categories: categoryMap.values.toList(),
      );
    });

///
/// SERVICES NOTIFIER (CRUD via API)
///
class ServicesNotifier extends AsyncNotifier<List<Service>> {
  @override
  Future<List<Service>> build() async {
    // Verifica autenticazione
    final authState = ref.watch(authProvider);
    if (!authState.isAuthenticated) {
      return [];
    }
    final canManageServices = ref.watch(currentUserCanManageServicesProvider);

    final location = ref.watch(currentLocationProvider);
    if (location.id <= 0) {
      return [];
    }

    final businessId = ref.watch(currentBusinessIdProvider);
    if (businessId <= 0) {
      return [];
    }

    final repository = ref.watch(servicesRepositoryProvider);

    // Carica servizi E categorie dall'API
    final result = await repository.getServicesWithCategories(
      locationId: location.id,
    );

    // Per ruoli read-only (viewer) usiamo le categorie incluse in GET /services.
    // Per ruoli con manage_services usiamo la fonte gestionale dedicata.
    if (canManageServices) {
      final categories = await repository.getCategories(businessId);
      ref.read(serviceCategoriesProvider.notifier).setCategories(categories);
    } else {
      ref
          .read(serviceCategoriesProvider.notifier)
          .setCategories(result.categories);
    }

    return result.services;
  }

  /// Ricarica servizi e categorie dall'API
  Future<void> refresh() async {
    // Verifica autenticazione
    final authState = ref.read(authProvider);
    if (!authState.isAuthenticated) {
      return;
    }
    final canManageServices = ref.read(currentUserCanManageServicesProvider);

    final location = ref.read(currentLocationProvider);
    if (location.id <= 0) {
      return;
    }

    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId <= 0) {
      return;
    }

    state = const AsyncLoading();

    try {
      final repository = ref.read(servicesRepositoryProvider);
      final result = await repository.getServicesWithCategories(
        locationId: location.id,
      );

      // Per ruoli read-only (viewer) usiamo le categorie incluse in GET /services.
      // Per ruoli con manage_services usiamo la fonte gestionale dedicata.
      if (canManageServices) {
        final categories = await repository.getCategories(businessId);
        ref.read(serviceCategoriesProvider.notifier).setCategories(categories);
      } else {
        ref
            .read(serviceCategoriesProvider.notifier)
            .setCategories(result.categories);
      }

      state = AsyncData(result.services);
    } catch (e, st) {
      state = AsyncError(e, st);
    }
  }

  void setServices(List<Service> services) {
    state = AsyncData(services);
  }

  // ===== API METHODS =====

  /// Creates a new service with variants for multiple locations via API
  Future<Service?> createServiceMultiLocationApi({
    required List<int> locationIds,
    required String name,
    int? categoryId,
    String? description,
    int durationMinutes = 30,
    double price = 0,
    String? colorHex,
    bool isBookableOnline = true,
    bool isPriceStartingFrom = false,
    int? processingTime,
    int? blockedTime,
  }) async {
    final repository = ref.read(servicesRepositoryProvider);
    final businessId = ref.read(currentBusinessIdProvider);

    if (businessId <= 0 || locationIds.isEmpty) return null;

    try {
      final newService = await repository.createServiceMultiLocation(
        businessId: businessId,
        locationIds: locationIds,
        name: name,
        categoryId: categoryId,
        description: description,
        durationMinutes: durationMinutes,
        price: price,
        colorHex: colorHex,
        isBookableOnline: isBookableOnline,
        isPriceStartingFrom: isPriceStartingFrom,
        processingTime: processingTime,
        blockedTime: blockedTime,
      );

      // Add to local state only if current location is in the list
      final currentLocation = ref.read(currentLocationProvider);
      if (locationIds.contains(currentLocation.id)) {
        final current = state.value ?? [];
        state = AsyncData([...current, newService]);

        ref
            .read(serviceCategoriesProvider.notifier)
            .bumpEmptyCategoriesToEnd(servicesOverride: state.value);
      }

      return newService;
    } catch (e) {
      // Keep old state on error
      return null;
    }
  }

  /// Creates a new service via API and updates local state (legacy, single location)
  Future<Service?> createServiceApi({
    required String name,
    int? categoryId,
    String? description,
    int durationMinutes = 30,
    double price = 0,
    String? colorHex,
    bool isBookableOnline = true,
    bool isPriceStartingFrom = false,
    int? processingTime,
    int? blockedTime,
  }) async {
    final repository = ref.read(servicesRepositoryProvider);
    final location = ref.read(currentLocationProvider);

    if (location.id <= 0) return null;

    try {
      final newService = await repository.createService(
        locationId: location.id,
        name: name,
        categoryId: categoryId,
        description: description,
        durationMinutes: durationMinutes,
        price: price,
        colorHex: colorHex,
        isBookableOnline: isBookableOnline,
        isPriceStartingFrom: isPriceStartingFrom,
        processingTime: processingTime,
        blockedTime: blockedTime,
      );

      // Add to local state
      final current = state.value ?? [];
      state = AsyncData([...current, newService]);

      // Trigger refresh of servicesForLocationsProvider
      // so staff dialog will see the new service
      ref.read(servicesForLocationsRefreshProvider.notifier).trigger();

      ref
          .read(serviceCategoriesProvider.notifier)
          .bumpEmptyCategoriesToEnd(servicesOverride: state.value);

      return newService;
    } catch (e) {
      // Keep old state on error
      return null;
    }
  }

  /// Updates a service via API and updates local state
  Future<Service?> updateServiceApi({
    required int serviceId,
    String? name,
    int? categoryId,
    bool setCategoryIdNull = false,
    String? description,
    bool setDescriptionNull = false,
    int? durationMinutes,
    double? price,
    String? colorHex,
    bool? isBookableOnline,
    bool? isPriceStartingFrom,
    int? sortOrder,
    int? processingTime,
    int? blockedTime,
  }) async {
    final repository = ref.read(servicesRepositoryProvider);
    final location = ref.read(currentLocationProvider);

    if (location.id <= 0) return null;

    try {
      final updatedService = await repository.updateService(
        serviceId: serviceId,
        locationId: location.id,
        name: name,
        categoryId: categoryId,
        setCategoryIdNull: setCategoryIdNull,
        description: description,
        setDescriptionNull: setDescriptionNull,
        durationMinutes: durationMinutes,
        price: price,
        colorHex: colorHex,
        isBookableOnline: isBookableOnline,
        isPriceStartingFrom: isPriceStartingFrom,
        sortOrder: sortOrder,
        processingTime: processingTime,
        blockedTime: blockedTime,
      );

      // Update local state
      final current = state.value ?? [];
      state = AsyncData([
        for (final s in current)
          if (s.id == updatedService.id) updatedService else s,
      ]);

      // Trigger refresh of servicesForLocationsProvider
      ref.read(servicesForLocationsRefreshProvider.notifier).trigger();

      ref
          .read(serviceCategoriesProvider.notifier)
          .bumpEmptyCategoriesToEnd(servicesOverride: state.value);

      return updatedService;
    } catch (e) {
      return null;
    }
  }

  /// Deletes a service via API and updates local state
  Future<bool> deleteServiceApi(int serviceId) async {
    final repository = ref.read(servicesRepositoryProvider);

    try {
      await repository.deleteService(serviceId);

      // Remove from local state
      final current = state.value ?? [];
      final newList = current.where((s) => s.id != serviceId).toList();
      state = AsyncData(newList);

      ref.read(serviceVariantsProvider.notifier).removeByServiceId(serviceId);

      // Trigger refresh of servicesForLocationsProvider
      ref.read(servicesForLocationsRefreshProvider.notifier).trigger();

      ref
          .read(serviceCategoriesProvider.notifier)
          .bumpEmptyCategoriesToEnd(servicesOverride: newList);

      return true;
    } catch (e) {
      return false;
    }
  }

  /// Gets the location IDs where a service has active variants
  Future<List<int>> getServiceLocationsApi(int serviceId) async {
    final repository = ref.read(servicesRepositoryProvider);
    return repository.getServiceLocations(serviceId);
  }

  /// Updates the locations associated with a service
  /// Returns true on success, false on failure
  Future<bool> updateServiceLocationsApi({
    required int serviceId,
    required List<int> locationIds,
  }) async {
    final repository = ref.read(servicesRepositoryProvider);
    try {
      await repository.updateServiceLocations(
        serviceId: serviceId,
        locationIds: locationIds,
      );
      return true;
    } catch (e) {
      return false;
    }
  }

  /// Duplicates a service via API (creates new with modified name)
  Future<Service?> duplicateServiceApi(Service original) async {
    final current = state.value ?? [];
    final existingNames = current.map((s) => s.name).toSet();
    final duplicateName = _makeDuplicateName(original.name, existingNames);

    return createServiceApi(
      name: duplicateName,
      categoryId: original.categoryId,
      description: original.description,
      durationMinutes: original.durationMinutes ?? 30,
      price: original.price ?? 0,
      colorHex: original.color,
      isPriceStartingFrom: original.isPriceStartingFrom,
    );
  }

  // ===== LOCAL METHODS (legacy, for backward compatibility) =====

  @Deprecated('Use createServiceApi instead for persistence')
  void add(Service service) {
    final current = state.value ?? [];
    state = AsyncData([...current, service]);
    ref
        .read(serviceCategoriesProvider.notifier)
        .bumpEmptyCategoriesToEnd(servicesOverride: state.value);
  }

  @Deprecated('Use updateServiceApi instead for persistence')
  void updateService(Service updated) {
    final current = state.value ?? [];
    state = AsyncData([
      for (final s in current)
        if (s.id == updated.id) updated else s,
    ]);
    ref
        .read(serviceCategoriesProvider.notifier)
        .bumpEmptyCategoriesToEnd(servicesOverride: state.value);
  }

  @Deprecated('Use deleteServiceApi instead for persistence')
  void delete(int id) {
    final current = state.value ?? [];
    final newList = current.where((s) => s.id != id).toList();
    state = AsyncData(newList);
    ref.read(serviceVariantsProvider.notifier).removeByServiceId(id);
    ref
        .read(serviceCategoriesProvider.notifier)
        .bumpEmptyCategoriesToEnd(servicesOverride: newList);
  }

  @Deprecated('Use duplicateServiceApi instead for persistence')
  void duplicate(Service original) {
    final current = state.value ?? [];
    final newId = _nextId(current);
    final existingNames = current.map((s) => s.name).toSet();

    final copy = Service(
      id: newId,
      businessId: original.businessId,
      categoryId: original.categoryId,
      name: _makeDuplicateName(original.name, existingNames),
      description: original.description,
    );
    add(copy);

    ref
        .read(serviceCategoriesProvider.notifier)
        .bumpEmptyCategoriesToEnd(servicesOverride: state.value);
  }

  // ===== HELPER METHODS =====

  String _makeDuplicateName(String originalName, Set<String> existingNames) {
    final copyWord = ServiceSeedTexts.duplicateCopyWord;
    final copyWordEscaped = RegExp.escape(copyWord);
    String base = originalName;
    int? startFrom;

    final reNew = RegExp(
      '^(.*?)(?:\\s$copyWordEscaped(?:\\s(\\d+))?)\$',
      caseSensitive: false,
    );
    final reOld = RegExp(
      '^(.*?)(?:\\s\\((?:$copyWordEscaped)(?:\\s(\\d+))?\\))\$',
      caseSensitive: false,
    );

    RegExpMatch? m =
        reNew.firstMatch(originalName) ?? reOld.firstMatch(originalName);
    if (m != null) {
      base = (m.group(1) ?? '').trim();
      final n = m.group(2);
      if (n != null) {
        final parsed = int.tryParse(n);
        if (parsed != null) startFrom = parsed + 1;
      } else {
        startFrom = 1;
      }
    }

    String candidate = '$base $copyWord';
    if (!existingNames.contains(candidate)) return candidate;

    int i = startFrom ?? 1;
    while (true) {
      candidate = '$base $copyWord $i';
      if (!existingNames.contains(candidate)) return candidate;
      i++;
      if (i > 9999) break;
    }
    return '$base $copyWord';
  }

  int _nextId(List<Service> current) {
    if (current.isEmpty) return 1;
    final maxId = current.map((s) => s.id).reduce((a, b) => a > b ? a : b);
    return maxId + 1;
  }
}

final servicesProvider = AsyncNotifierProvider<ServicesNotifier, List<Service>>(
  ServicesNotifier.new,
);

///
/// VARIANTI SERVIZI (da API, filtrate per location)
///
class ServiceVariantsNotifier extends AsyncNotifier<List<ServiceVariant>> {
  @override
  Future<List<ServiceVariant>> build() async {
    final services = await ref.watch(servicesProvider.future);
    final location = ref.watch(currentLocationProvider);
    final currency = ref.watch(effectiveCurrencyProvider);

    // Map services to variants usando ID reale da API
    return services
        .map(
          (s) => ServiceVariant(
            // Usa serviceVariantId da API se disponibile, altrimenti fallback
            id: s.serviceVariantId ?? s.id,
            serviceId: s.id,
            locationId: location.id,
            durationMinutes: s.durationMinutes ?? 30,
            price: s.price ?? 0.0,
            colorHex: s.color ?? '#CCCCCC',
            currency: currency,
            isBookableOnline: s.isBookableOnline,
            isFree: (s.price ?? 0) == 0,
            isPriceStartingFrom: s.isPriceStartingFrom,
            resourceRequirements: s.resourceRequirements,
            processingTime: s.processingTime ?? 0,
            blockedTime: s.blockedTime ?? 0,
          ),
        )
        .toList();
  }

  void upsert(ServiceVariant variant) {
    final current = state.value ?? [];
    state = AsyncData([
      for (final v in current)
        if (v.id == variant.id) variant else v,
      if (!current.any((v) => v.id == variant.id)) variant,
    ]);
  }

  void removeByServiceId(int serviceId) {
    final current = state.value ?? [];
    state = AsyncData(current.where((v) => v.serviceId != serviceId).toList());
  }
}

final serviceVariantsProvider =
    AsyncNotifierProvider<ServiceVariantsNotifier, List<ServiceVariant>>(
      ServiceVariantsNotifier.new,
    );

///
/// SERVICE VARIANT BY ID
///
final serviceVariantByIdProvider = Provider.family<ServiceVariant?, int>((
  ref,
  variantId,
) {
  final variantsAsync = ref.watch(serviceVariantsProvider);
  final variants = variantsAsync.value ?? [];
  for (final variant in variants) {
    if (variant.id == variantId) return variant;
  }
  return null;
});

final serviceVariantByServiceIdProvider = Provider.family<ServiceVariant?, int>(
  (ref, serviceId) {
    final location = ref.watch(currentLocationProvider);
    final variantsAsync = ref.watch(serviceVariantsProvider);
    final variants = variantsAsync.value ?? [];
    for (final variant in variants) {
      if (variant.serviceId == serviceId && variant.locationId == location.id) {
        return variant;
      }
    }
    return null;
  },
);

///
/// ELIGIBILITY STAFF
///
/// Questo provider ora legge i service_ids direttamente dal modello Staff
/// che √® stato caricato dall'API. Non usa pi√π dati mock.
///
class ServiceStaffEligibilityNotifier
    extends Notifier<List<ServiceStaffEligibility>> {
  @override
  List<ServiceStaffEligibility> build() {
    // Legge da allStaffProvider per costruire l'eligibilit√†
    final staffAsync = ref.watch(allStaffProvider);
    final staffList = staffAsync.value ?? [];

    final List<ServiceStaffEligibility> eligibilities = [];
    for (final staff in staffList) {
      for (final serviceId in staff.serviceIds) {
        // Per ogni location dello staff, crea un'eligibilit√†
        if (staff.locationIds.isEmpty) {
          // Staff disponibile in tutte le location
          eligibilities.add(
            ServiceStaffEligibility(serviceId: serviceId, staffId: staff.id),
          );
        } else {
          for (final locationId in staff.locationIds) {
            eligibilities.add(
              ServiceStaffEligibility(
                serviceId: serviceId,
                staffId: staff.id,
                locationId: locationId,
              ),
            );
          }
        }
      }
    }
    return eligibilities;
  }

  /// Metodo per aggiornare lo stato locale (solo UI)
  /// L'effettivo salvataggio avviene tramite StaffNotifier.updateStaffApi
  void setEligibleStaffForService({
    required int serviceId,
    required int locationId,
    required Iterable<int> staffIds,
  }) {
    final retained = [
      for (final entry in state)
        if (!(entry.serviceId == serviceId &&
            (entry.locationId == null || entry.locationId == locationId)))
          entry,
    ];
    final updated = [
      for (final staffId in staffIds)
        ServiceStaffEligibility(
          serviceId: serviceId,
          staffId: staffId,
          locationId: locationId,
        ),
    ];
    state = [...retained, ...updated];
  }

  /// Metodo per aggiornare lo stato locale (solo UI)
  /// L'effettivo salvataggio avviene tramite StaffNotifier.updateStaffApi
  void setEligibleServicesForStaff({
    required int staffId,
    required int locationId,
    required Iterable<int> serviceIds,
  }) {
    final retained = [
      for (final entry in state)
        if (!(entry.staffId == staffId &&
            (entry.locationId == null || entry.locationId == locationId)))
          entry,
    ];
    final updated = [
      for (final serviceId in serviceIds)
        ServiceStaffEligibility(
          serviceId: serviceId,
          staffId: staffId,
          locationId: locationId,
        ),
    ];
    state = [...retained, ...updated];
  }
}

final serviceStaffEligibilityProvider =
    NotifierProvider<
      ServiceStaffEligibilityNotifier,
      List<ServiceStaffEligibility>
    >(ServiceStaffEligibilityNotifier.new);

final eligibleStaffForServiceProvider = Provider.family<List<int>, int>((
  ref,
  serviceId,
) {
  final location = ref.watch(currentLocationProvider);
  final elegibility = ref.watch(serviceStaffEligibilityProvider);

  return [
    for (final entry in elegibility)
      if (entry.serviceId == serviceId &&
          (entry.locationId == null || entry.locationId == location.id))
        entry.staffId,
  ];
});

final eligibleServicesForStaffProvider = Provider.family<List<int>, int>((
  ref,
  staffId,
) {
  // Legge direttamente dal modello Staff invece di usare serviceStaffEligibilityProvider
  final staffAsync = ref.watch(allStaffProvider);
  final staffList = staffAsync.value ?? [];
  final staff = staffList.where((s) => s.id == staffId).firstOrNull;
  return staff?.serviceIds ?? [];
});

///
/// SERVICES PER CATEGORIA
///
final servicesByCategoryProvider = Provider.family<List<Service>, int>((
  ref,
  categoryId,
) {
  final servicesAsync = ref.watch(servicesProvider);
  final services = servicesAsync.value ?? [];
  return [
    for (final service in services)
      if (service.categoryId == categoryId) service,
  ];
});
--- FILE: lib/features/services/providers/services_reorder_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/l10n/l10n.dart';
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/models/service_package.dart';
import '../../../core/network/network_providers.dart';
import 'service_categories_provider.dart';
import 'service_packages_provider.dart';
import 'services_provider.dart';
import 'services_sorted_providers.dart';

/// Gestisce la modalit√† riordino e applica gli ordinamenti aggiornando sortOrder
class ServicesReorderNotifier extends Notifier<bool> {
  @override
  bool build() => false; // false = non in riordino

  void toggle() => state = !state;

  void setReordering(bool value) => state = value;

  /// Riordina le categorie a livello top
  Future<void> reorderCategories(int oldIndex, int newIndex) async {
    final notifier = ref.read(serviceCategoriesProvider.notifier);
    final list = [...ref.read(serviceCategoriesProvider)];

    if (newIndex > oldIndex) newIndex -= 1;

    final item = list.removeAt(oldIndex);
    list.insert(newIndex, item);

    final reordered = <ServiceCategory>[];
    for (int i = 0; i < list.length; i++) {
      reordered.add(list[i].copyWith(sortOrder: i));
    }

    notifier.state = reordered;

    // Persist to API
    await _persistCategoriesOrder(reordered);
  }

  /// Riordina solo le categorie NON vuote, mantenendo le vuote in coda e non spostabili.
  Future<void> reorderNonEmptyCategories(int oldIndex, int newIndex) async {
    final catsNotifier = ref.read(serviceCategoriesProvider.notifier);
    final allCats = [...ref.read(serviceCategoriesProvider)];
    final services = ref.read(servicesProvider).value ?? [];

    final nonEmpty = <ServiceCategory>[];
    final empty = <ServiceCategory>[];
    for (final c in allCats) {
      final hasServices = services.any((s) => s.categoryId == c.id);
      final hasPackages =
          ref.read(servicePackagesByCategoryProvider(c.id)).isNotEmpty;
      if (hasServices || hasPackages) {
        nonEmpty.add(c);
      } else {
        empty.add(c);
      }
    }

    final item = nonEmpty.removeAt(oldIndex);
    final insertIndex = newIndex.clamp(0, nonEmpty.length);
    nonEmpty.insert(insertIndex, item);

    final merged = [...nonEmpty, ...empty];
    final reordered = <ServiceCategory>[];
    for (int i = 0; i < merged.length; i++) {
      reordered.add(merged[i].copyWith(sortOrder: i));
    }

    catsNotifier.state = reordered;

    // Persist to API
    await _persistCategoriesOrder(reordered);
  }

  /// Riordina i servizi all'interno della stessa categoria
  Future<void> reorderServices(
    int categoryId,
    int oldIndex,
    int newIndex,
  ) async {
    final servicesNotifier = ref.read(servicesProvider.notifier);
    final all = [...(ref.read(servicesProvider).value ?? [])];

    final byCat = all.where((s) => s.categoryId == categoryId).toList();
    final item = byCat.removeAt(oldIndex);
    byCat.insert(newIndex, item);

    final updatedByCat = <Service>[];
    for (int i = 0; i < byCat.length; i++) {
      updatedByCat.add(byCat[i].copyWith(sortOrder: i));
    }

    final updatedAll = <Service>[
      for (final s in all)
        if (s.categoryId == categoryId)
          updatedByCat.firstWhere((x) => x.id == s.id)
        else
          s,
    ];

    servicesNotifier.setServices(updatedAll);

    // Persist to API - only services in this category
    await _persistServicesOrder(updatedByCat);
  }

  Future<void> reorderCategoryItems({
    required int categoryId,
    required List<ServiceCategoryEntry> items,
  }) async {
    await applyCategoryItemsOrder({categoryId: items});
  }

  Future<void> moveCategoryItemBetweenCategories({
    required int oldCategoryId,
    required int newCategoryId,
    required List<ServiceCategoryEntry> oldItems,
    required List<ServiceCategoryEntry> newItems,
  }) async {
    await applyCategoryItemsOrder({
      oldCategoryId: oldItems,
      newCategoryId: newItems,
    });
  }

  Future<void> applyCategoryItemsOrder(
    Map<int, List<ServiceCategoryEntry>> updatedByCategory,
  ) async {
    final servicesNotifier = ref.read(servicesProvider.notifier);
    final packagesNotifier = ref.read(servicePackagesProvider.notifier);
    final currentServices =
        [...(ref.read(servicesProvider).value ?? const <Service>[])];
    final currentPackages = [
      ...(ref.read(servicePackagesProvider).value ??
          const <ServicePackage>[]),
    ];

    final updatedServicesById = <int, Service>{};
    final updatedPackagesById = <int, ServicePackage>{};

    updatedByCategory.forEach((categoryId, items) {
      for (int i = 0; i < items.length; i++) {
        final entry = items[i];
        if (entry.isService) {
          final service = entry.service!;
          updatedServicesById[service.id] = service.copyWith(
            categoryId: categoryId,
            sortOrder: i,
          );
        } else {
          final package = entry.package!;
          updatedPackagesById[package.id] = package.copyWith(
            categoryId: categoryId,
            sortOrder: i,
          );
        }
      }
    });

    final updatedServices = [
      for (final s in currentServices)
        updatedServicesById[s.id] ?? s,
    ];
    final updatedPackages = [
      for (final p in currentPackages)
        updatedPackagesById[p.id] ?? p,
    ];

    servicesNotifier.setServices(updatedServices);
    packagesNotifier.setPackages(updatedPackages);
    ref.read(serviceCategoriesProvider.notifier).bumpEmptyCategoriesToEnd();

    await _persistServicesOrder(updatedServicesById.values.toList());
    await _persistPackagesOrder(updatedPackagesById.values.toList());
  }

  /// üîÑ Sposta un servizio da una categoria all'altra (drag cross-categoria)
  Future<void> moveServiceBetweenCategories(
    int oldCategoryId,
    int newCategoryId,
    int serviceId,
    int newIndex,
  ) async {
    final servicesNotifier = ref.read(servicesProvider.notifier);
    final all = [...(ref.read(servicesProvider).value ?? [])];

    // servizio selezionato
    final movedService = all.firstWhere(
      (s) => s.id == serviceId,
      orElse: () => throw Exception(L10n.current.errorServiceNotFound),
    );

    // rimuovi da categoria precedente
    final remainingOldCat = all
        .where((s) => s.categoryId == oldCategoryId && s.id != serviceId)
        .toList();

    // aggiungi nella nuova categoria
    final targetCat = all.where((s) => s.categoryId == newCategoryId).toList();
    if (newIndex > targetCat.length) newIndex = targetCat.length;
    targetCat.insert(
      newIndex,
      movedService.copyWith(categoryId: newCategoryId),
    );

    // ricalcola sortOrder in entrambe le categorie
    final updatedOldCat = <Service>[
      for (int i = 0; i < remainingOldCat.length; i++)
        remainingOldCat[i].copyWith(sortOrder: i),
    ];
    final updatedNewCat = <Service>[
      for (int i = 0; i < targetCat.length; i++)
        targetCat[i].copyWith(sortOrder: i),
    ];

    final updated = <Service>[
      ...all.where(
        (s) => s.categoryId != oldCategoryId && s.categoryId != newCategoryId,
      ),
      ...updatedOldCat,
      ...updatedNewCat,
    ];

    servicesNotifier.setServices(updated);
    // Aggiorna posizionamento categorie vuote vs piene
    ref.read(serviceCategoriesProvider.notifier).bumpEmptyCategoriesToEnd();

    // Persist to API - both categories affected
    await _persistServicesOrder([...updatedOldCat, ...updatedNewCat]);
  }

  /// Persiste l'ordine dei servizi via API
  Future<void> _persistServicesOrder(List<Service> services) async {
    if (services.isEmpty) return;
    try {
      final apiClient = ref.read(apiClientProvider);
      await apiClient.reorderServices(
        services: services
            .map(
              (s) => {
                'id': s.id,
                'category_id': s.categoryId,
                'sort_order': s.sortOrder,
              },
            )
            .toList(),
      );
    } catch (e) {
      // Log error but don't revert UI - user can retry
      // ignore: avoid_print
      print('Error persisting services order: $e');
    }
  }

  /// Persiste l'ordine delle categorie via API
  Future<void> _persistCategoriesOrder(List<ServiceCategory> categories) async {
    try {
      final apiClient = ref.read(apiClientProvider);
      await apiClient.reorderCategories(
        categories: categories
            .map((c) => {'id': c.id, 'sort_order': c.sortOrder})
            .toList(),
      );
    } catch (e) {
      // Log error but don't revert UI - user can retry
      // ignore: avoid_print
      print('Error persisting categories order: $e');
    }
  }

  Future<void> _persistPackagesOrder(List<ServicePackage> packages) async {
    if (packages.isEmpty) return;
    try {
      final apiClient = ref.read(apiClientProvider);
      await apiClient.reorderServicePackages(
        packages: packages
            .map(
              (p) => {
                'id': p.id,
                'category_id': p.categoryId,
                'sort_order': p.sortOrder,
              },
            )
            .toList(),
      );
    } catch (e) {
      // Log error but don't revert UI - user can retry
      // ignore: avoid_print
      print('Error persisting packages order: $e');
    }
  }
}

final servicesReorderProvider = NotifierProvider<ServicesReorderNotifier, bool>(
  ServicesReorderNotifier.new,
);

class ServicesReorderPanelNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  void toggle() => state = !state;

  void setVisible(bool value) => state = value;
}

final servicesReorderPanelProvider =
    NotifierProvider<ServicesReorderPanelNotifier, bool>(
      ServicesReorderPanelNotifier.new,
    );
--- FILE: lib/features/services/providers/services_repository_provider.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../core/network/network_providers.dart';
import '../data/services_repository.dart';

part 'services_repository_provider.g.dart';

@Riverpod(keepAlive: true)
ServicesRepository servicesRepository(Ref ref) {
  final apiClient = ref.watch(apiClientProvider);
  return ServicesRepository(apiClient: apiClient);
}
--- FILE: lib/features/services/providers/service_packages_repository_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/network/network_providers.dart';
import '../data/service_packages_repository.dart';

final servicePackagesRepositoryProvider =
    Provider<ServicePackagesRepository>((ref) {
      final apiClient = ref.watch(apiClientProvider);
      return ServicePackagesRepository(apiClient: apiClient);
    });
--- FILE: lib/features/services/providers/services_repository_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'services_repository_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(servicesRepository)
const servicesRepositoryProvider = ServicesRepositoryProvider._();

final class ServicesRepositoryProvider
    extends
        $FunctionalProvider<
          ServicesRepository,
          ServicesRepository,
          ServicesRepository
        >
    with $Provider<ServicesRepository> {
  const ServicesRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'servicesRepositoryProvider',
        isAutoDispose: false,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$servicesRepositoryHash();

  @$internal
  @override
  $ProviderElement<ServicesRepository> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  ServicesRepository create(Ref ref) {
    return servicesRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(ServicesRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<ServicesRepository>(value),
    );
  }
}

String _$servicesRepositoryHash() =>
    r'3fccf62359ce924f6088b2d25be6f0e1266860a8';
--- FILE: lib/features/services/providers/service_categories_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/models/service_package.dart';
import '../../agenda/providers/business_providers.dart';
import 'service_packages_provider.dart';
import 'services_provider.dart';
import 'services_repository_provider.dart';

/// Notifier per la gestione delle categorie di servizi (CRUD via API)
/// Le categorie vengono inizializzate vuote e popolate dal ServicesNotifier
/// quando i dati vengono caricati dall'API.
class ServiceCategoriesNotifier extends Notifier<List<ServiceCategory>> {
  @override
  List<ServiceCategory> build() {
    // Inizia vuoto - le categorie vengono caricate dall'API insieme ai servizi
    return [];
  }

  /// Imposta le categorie caricate dall'API
  void setCategories(List<ServiceCategory> categories) {
    state = _sorted(categories);
  }

  List<ServiceCategory> _sorted(List<ServiceCategory> list) {
    final copy = [...list];
    copy.sort((a, b) => a.sortOrder.compareTo(b.sortOrder));
    return copy;
  }

  // ===== API METHODS =====

  /// Creates a new category via API and updates local state
  Future<ServiceCategory?> createCategoryApi({
    required String name,
    String? description,
  }) async {
    final repository = ref.read(servicesRepositoryProvider);
    final businessId = ref.read(currentBusinessIdProvider);

    if (businessId <= 0) return null;

    try {
      final newCategory = await repository.createCategory(
        businessId: businessId,
        name: name,
        description: description,
      );

      // Add to local state with high sort order (will be bumped if empty)
      final nextSort = state.isEmpty
          ? 0
          : (state.map((c) => c.sortOrder).reduce((a, b) => a > b ? a : b) + 1);
      final withOrder = newCategory.copyWith(sortOrder: nextSort);
      state = _sorted([...state, withOrder]);

      bumpEmptyCategoriesToEnd();

      return newCategory;
    } catch (e) {
      return null;
    }
  }

  /// Updates a category via API and updates local state
  Future<ServiceCategory?> updateCategoryApi({
    required int categoryId,
    String? name,
    String? description,
    int? sortOrder,
  }) async {
    final repository = ref.read(servicesRepositoryProvider);

    try {
      final updatedCategory = await repository.updateCategory(
        categoryId: categoryId,
        name: name,
        description: description,
        sortOrder: sortOrder,
      );

      // Update local state
      state = _sorted([
        for (final c in state)
          if (c.id == updatedCategory.id) updatedCategory else c,
      ]);

      return updatedCategory;
    } catch (e) {
      return null;
    }
  }

  /// Deletes a category via API and updates local state
  Future<bool> deleteCategoryApi(int categoryId) async {
    final repository = ref.read(servicesRepositoryProvider);

    try {
      await repository.deleteCategory(categoryId);

      // Remove from local state
      state = _sorted(state.where((c) => c.id != categoryId).toList());

      return true;
    } catch (e) {
      return false;
    }
  }

  // ===== LOCAL METHODS (legacy, for backward compatibility) =====

  @Deprecated('Use createCategoryApi instead for persistence')
  void addCategory(ServiceCategory newCategory) {
    final nextSort = state.isEmpty
        ? 0
        : (state.map((c) => c.sortOrder).reduce((a, b) => a > b ? a : b) + 1);
    final withOrder = newCategory.copyWith(sortOrder: nextSort);
    state = _sorted([...state, withOrder]);
    bumpEmptyCategoriesToEnd();
  }

  @Deprecated('Use updateCategoryApi instead for persistence')
  void updateCategory(ServiceCategory updatedCategory) {
    state = _sorted([
      for (final c in state)
        if (c.id == updatedCategory.id) updatedCategory else c,
    ]);
  }

  @Deprecated('Use deleteCategoryApi instead for persistence')
  void deleteCategory(int id) {
    state = _sorted(state.where((c) => c.id != id).toList());
  }

  /// Imposta un sortOrder elevato per le categorie senza servizi,
  /// in modo che siano naturalmente in coda all'ordinamento.
  ///
  /// Per evitare dipendenze circolari quando chiamata da ServicesNotifier,
  /// si pu√≤ passare la lista servizi gi√† aggiornata tramite [servicesOverride].
  void bumpEmptyCategoriesToEnd({
    List<Service>? servicesOverride,
    List<ServicePackage>? packagesOverride,
  }) {
    final List<Service> services =
        servicesOverride ?? (ref.read(servicesProvider).value ?? []);
    final List<ServicePackage> packages =
        packagesOverride ?? (ref.read(servicePackagesProvider).value ?? []);
    final serviceById = {for (final s in services) s.id: s};
    final nonEmptyCatIds = <int>{for (final s in services) s.categoryId};
    for (final p in packages) {
      var categoryId = p.categoryId;
      if (categoryId == 0 && p.items.isNotEmpty) {
        categoryId = serviceById[p.items.first.serviceId]?.categoryId ?? 0;
      }
      if (categoryId != 0) {
        nonEmptyCatIds.add(categoryId);
      }
    }

    int maxNonEmptySort = -1;
    for (final c in state) {
      if (nonEmptyCatIds.contains(c.id)) {
        if (c.sortOrder > maxNonEmptySort) maxNonEmptySort = c.sortOrder;
      }
    }

    // Base alta per evitare collisioni con futuri riordini
    final base = (maxNonEmptySort < 0 ? 0 : maxNonEmptySort + 1) + 1000;
    int offset = 0;

    final updated = [
      for (final c in state)
        if (nonEmptyCatIds.contains(c.id))
          c
        else
          c.copyWith(sortOrder: base + offset++),
    ];

    state = _sorted(updated);
  }
}

final serviceCategoriesProvider =
    NotifierProvider<ServiceCategoriesNotifier, List<ServiceCategory>>(
      ServiceCategoriesNotifier.new,
    );
--- FILE: lib/features/services/providers/popular_services_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/popular_service.dart';
import '../../../core/network/network_providers.dart';
import '../../auth/providers/auth_provider.dart';

/// Provider famiglia per i servizi popolari (top 5 pi√π prenotati) per uno staff.
/// Ritorna [PopularServicesResult.empty] se:
/// - L'utente non √® autenticato
/// - La location dello staff ha meno di 25 servizi
/// - Non ci sono dati disponibili
final popularServicesProvider = FutureProvider.autoDispose
    .family<PopularServicesResult, int>((ref, staffId) async {
      // Verifica autenticazione
      final authState = ref.watch(authProvider);
      if (!authState.isAuthenticated) {
        return PopularServicesResult.empty;
      }

      if (staffId <= 0) {
        return PopularServicesResult.empty;
      }

      try {
        final apiClient = ref.read(apiClientProvider);
        final data = await apiClient.getPopularServices(staffId);

        return PopularServicesResult.fromJson(data);
      } catch (e) {
        // In caso di errore, ritorna risultato vuoto (non mostra la sezione)
        return PopularServicesResult.empty;
      }
    });
--- FILE: lib/features/services/utils/service_validators.dart ---
import 'package:agenda_backend/core/models/service.dart';
import 'package:agenda_backend/core/models/service_category.dart';

class ServiceValidators {
  const ServiceValidators._();

  static bool isNonEmpty(String value) => value.trim().isNotEmpty;

  static bool isDuplicateCategoryName(
    List<ServiceCategory> categories,
    String normalizedName, {
    int? excludeId,
  }) {
    final needle = normalizedName.toLowerCase();
    return categories.any(
      (c) => c.id != excludeId && c.name.toLowerCase() == needle,
    );
  }

  static bool isDuplicateServiceName(
    List<Service> services,
    String normalizedName, {
    int? excludeId,
  }) {
    final needle = normalizedName.toLowerCase();
    return services.any(
      (s) => s.id != excludeId && s.name.toLowerCase() == needle,
    );
  }
}
--- FILE: lib/features/services/utils/service_seed_texts.dart ---
import 'package:intl/intl.dart';

/// Localization helpers per le stringhe di seed e duplicazione usate dalla feature Services.
class ServiceSeedTexts {
  const ServiceSeedTexts._();

  static String get categoryBodyName => Intl.message(
        'Trattamenti Corpo',
        name: 'serviceSeedCategoryBodyName',
        desc: 'Nome della categoria di default dedicata ai trattamenti corpo.',
      );

  static String get categoryBodyDescription => Intl.message(
        'Servizi dedicati al benessere del corpo',
        name: 'serviceSeedCategoryBodyDescription',
        desc: 'Descrizione della categoria di default dedicata ai trattamenti corpo.',
      );

  static String get categorySportsName => Intl.message(
        'Trattamenti Sportivi',
        name: 'serviceSeedCategorySportsName',
        desc: 'Nome della categoria di default dedicata ai trattamenti sportivi.',
      );

  static String get categorySportsDescription => Intl.message(
        'Percorsi pensati per atleti e persone attive',
        name: 'serviceSeedCategorySportsDescription',
        desc: 'Descrizione della categoria di default dedicata ai trattamenti sportivi.',
      );

  static String get categoryFaceName => Intl.message(
        'Trattamenti Viso',
        name: 'serviceSeedCategoryFaceName',
        desc: 'Nome della categoria di default dedicata ai trattamenti viso.',
      );

  static String get categoryFaceDescription => Intl.message(
        'Cura estetica e rigenerante per il viso',
        name: 'serviceSeedCategoryFaceDescription',
        desc: 'Descrizione della categoria di default dedicata ai trattamenti viso.',
      );

  static String get serviceRelaxName => Intl.message(
        'Massaggio Relax',
        name: 'serviceSeedServiceRelaxName',
        desc: 'Nome del servizio di massaggio relax iniziale.',
      );

  static String get serviceRelaxDescription => Intl.message(
        'Trattamento rilassante da 30 minuti',
        name: 'serviceSeedServiceRelaxDescription',
        desc: 'Descrizione del servizio di massaggio relax iniziale.',
      );

  static String get serviceSportName => Intl.message(
        'Massaggio Sportivo',
        name: 'serviceSeedServiceSportName',
        desc: 'Nome del servizio di massaggio sportivo iniziale.',
      );

  static String get serviceSportDescription => Intl.message(
        'Trattamento decontratturante intensivo',
        name: 'serviceSeedServiceSportDescription',
        desc: 'Descrizione del servizio di massaggio sportivo iniziale.',
      );

  static String get serviceFaceName => Intl.message(
        'Trattamento Viso',
        name: 'serviceSeedServiceFaceName',
        desc: 'Nome del servizio per il viso iniziale.',
      );

  static String get serviceFaceDescription => Intl.message(
        'Pulizia e trattamento illuminante',
        name: 'serviceSeedServiceFaceDescription',
        desc: 'Descrizione del servizio per il viso iniziale.',
      );

  static String get duplicateCopyWord => Intl.message(
        'Copia',
        name: 'serviceDuplicateCopyWord',
        desc:
            'Parola usata per nominare servizi duplicati (es. "Servizio Copia" o "Servizio Copia 2").',
      );
}
--- FILE: lib/features/services/controllers/services_reorder_controller.dart ---
import 'package:flutter/foundation.dart';

/// Skeleton: controller per reorder servizi ‚Äì API da collegare 1:1
class ServicesReorderController {
  const ServicesReorderController();

  // Esempio di firma che potr√† essere implementata 1:1 durante l'estrazione
  void onReorder({required int oldIndex, required int newIndex}) {
    // Implementazione reale verr√† estratta da services_screen.dart
    if (kDebugMode) {
      // ignore: avoid_print
      print('Services reorder: $oldIndex -> $newIndex (skeleton)');
    }
  }
}
--- FILE: lib/features/services/controllers/categories_reorder_controller.dart ---
import 'package:flutter/foundation.dart';

/// Skeleton: controller per reorder categorie ‚Äì API da collegare 1:1
class CategoriesReorderController {
  const CategoriesReorderController();

  // Esempio di firma che potr√† essere implementata 1:1 durante l'estrazione
  void onReorder({required int oldIndex, required int newIndex}) {
    // Implementazione reale verr√† estratta da services_screen.dart
    if (kDebugMode) {
      // ignore: avoid_print
      print('Categories reorder: $oldIndex -> $newIndex (skeleton)');
    }
  }
}
--- FILE: lib/features/services/data/service_packages_api.dart ---
import '../../../core/models/service_package.dart';
import '../../../core/network/api_client.dart';

class ServicePackagesApi {
  final ApiClient _apiClient;

  ServicePackagesApi({required ApiClient apiClient}) : _apiClient = apiClient;

  Future<List<ServicePackage>> fetchPackages(int locationId) async {
    final data = await _apiClient.getServicePackages(locationId);
    final items = data['packages'] as List<dynamic>? ?? const [];
    return items
        .map((json) => ServicePackage.fromJson(json as Map<String, dynamic>))
        .toList();
  }

  Future<ServicePackage> createPackage({
    required int locationId,
    required String name,
    required int categoryId,
    required List<int> serviceIds,
    String? description,
    double? overridePrice,
    int? overrideDurationMinutes,
    bool isActive = true,
  }) async {
    final data = await _apiClient.createServicePackage(
      locationId: locationId,
      name: name,
      categoryId: categoryId,
      serviceIds: serviceIds,
      description: description,
      overridePrice: overridePrice,
      overrideDurationMinutes: overrideDurationMinutes,
      isActive: isActive,
    );
    return ServicePackage.fromJson(data['package'] as Map<String, dynamic>);
  }

  Future<ServicePackage> updatePackage({
    required int locationId,
    required int packageId,
    String? name,
    int? categoryId,
    String? description,
    double? overridePrice,
    int? overrideDurationMinutes,
    bool setOverridePriceNull = false,
    bool setOverrideDurationNull = false,
    bool? isActive,
    List<int>? serviceIds,
  }) async {
    final data = await _apiClient.updateServicePackage(
      locationId: locationId,
      packageId: packageId,
      name: name,
      categoryId: categoryId,
      description: description,
      overridePrice: overridePrice,
      overrideDurationMinutes: overrideDurationMinutes,
      setOverridePriceNull: setOverridePriceNull,
      setOverrideDurationNull: setOverrideDurationNull,
      isActive: isActive,
      serviceIds: serviceIds,
    );
    return ServicePackage.fromJson(data['package'] as Map<String, dynamic>);
  }

  Future<void> deletePackage({
    required int locationId,
    required int packageId,
  }) async {
    await _apiClient.deleteServicePackage(
      locationId: locationId,
      packageId: packageId,
    );
  }

  Future<void> reorderPackages({
    required List<Map<String, dynamic>> packages,
  }) async {
    await _apiClient.reorderServicePackages(packages: packages);
  }

  Future<ServicePackageExpansion> expandPackage({
    required int locationId,
    required int packageId,
  }) async {
    final data = await _apiClient.expandServicePackage(
      locationId: locationId,
      packageId: packageId,
    );
    return ServicePackageExpansion.fromJson(data);
  }
}
--- FILE: lib/features/services/data/services_api.dart ---
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/network/api_client.dart';

/// Risultato della chiamata API servizi (include categorie)
class ServicesApiResult {
  final List<Service> services;
  final List<ServiceCategory> categories;

  ServicesApiResult({required this.services, required this.categories});
}

/// API layer per Services - chiamate reali a agenda_core
class ServicesApi {
  final ApiClient _apiClient;

  ServicesApi({required ApiClient apiClient}) : _apiClient = apiClient;

  /// GET /v1/services?location_id=X
  /// Ritorna sia servizi che categorie dalla risposta API
  Future<ServicesApiResult> fetchServicesWithCategories(int locationId) async {
    final data = await _apiClient.getServices(locationId);

    // Parse services
    final List<dynamic> serviceItems = data['services'] ?? [];
    final services = serviceItems
        .map((json) => Service.fromJson(json as Map<String, dynamic>))
        .toList();

    // Parse categories dalla risposta API
    final List<dynamic> categoryItems = data['categories'] ?? [];
    final categories = <ServiceCategory>[];
    int sortOrder = 0;

    for (final catJson in categoryItems) {
      final catMap = catJson as Map<String, dynamic>;
      // L'API ritorna id e name per ogni categoria
      if (catMap['id'] != null) {
        categories.add(
          ServiceCategory(
            id: catMap['id'] as int,
            businessId: 0, // Non usato nel frontend
            name: catMap['name'] as String? ?? '',
            sortOrder: sortOrder++,
          ),
        );
      }
    }

    return ServicesApiResult(services: services, categories: categories);
  }

  /// GET /v1/services?location_id=X (legacy - solo servizi)
  Future<List<Service>> fetchServices(int locationId) async {
    final result = await fetchServicesWithCategories(locationId);
    return result.services;
  }

  // ===== Services CRUD =====

  /// POST /v1/businesses/{business_id}/services
  /// Creates a new service with variants for multiple locations
  Future<Service> createServiceMultiLocation({
    required int businessId,
    required List<int> locationIds,
    required String name,
    int? categoryId,
    String? description,
    int durationMinutes = 30,
    double price = 0,
    String? colorHex,
    bool isBookableOnline = true,
    bool isPriceStartingFrom = false,
    int? processingTime,
    int? blockedTime,
  }) async {
    final data = await _apiClient.createServiceMultiLocation(
      businessId: businessId,
      locationIds: locationIds,
      name: name,
      categoryId: categoryId,
      description: description,
      durationMinutes: durationMinutes,
      price: price,
      colorHex: colorHex,
      isBookableOnline: isBookableOnline,
      isPriceStartingFrom: isPriceStartingFrom,
      processingTime: processingTime,
      blockedTime: blockedTime,
    );
    return Service.fromJson(data['service'] as Map<String, dynamic>);
  }

  /// POST /v1/locations/{location_id}/services
  /// Creates a new service (legacy, single location)
  Future<Service> createService({
    required int locationId,
    required String name,
    int? categoryId,
    String? description,
    int durationMinutes = 30,
    double price = 0,
    String? colorHex,
    bool isBookableOnline = true,
    bool isPriceStartingFrom = false,
    int? processingTime,
    int? blockedTime,
  }) async {
    final data = await _apiClient.createService(
      locationId: locationId,
      name: name,
      categoryId: categoryId,
      description: description,
      durationMinutes: durationMinutes,
      price: price,
      colorHex: colorHex,
      isBookableOnline: isBookableOnline,
      isPriceStartingFrom: isPriceStartingFrom,
      processingTime: processingTime,
      blockedTime: blockedTime,
    );
    return Service.fromJson(data['service'] as Map<String, dynamic>);
  }

  /// PUT /v1/services/{id}
  /// Updates an existing service
  Future<Service> updateService({
    required int serviceId,
    required int locationId,
    String? name,
    int? categoryId,
    bool setCategoryIdNull = false,
    String? description,
    bool setDescriptionNull = false,
    int? durationMinutes,
    double? price,
    String? colorHex,
    bool? isBookableOnline,
    bool? isPriceStartingFrom,
    int? sortOrder,
    int? processingTime,
    int? blockedTime,
  }) async {
    final data = await _apiClient.updateService(
      serviceId: serviceId,
      locationId: locationId,
      name: name,
      categoryId: categoryId,
      setCategoryIdNull: setCategoryIdNull,
      description: description,
      setDescriptionNull: setDescriptionNull,
      durationMinutes: durationMinutes,
      price: price,
      colorHex: colorHex,
      isBookableOnline: isBookableOnline,
      isPriceStartingFrom: isPriceStartingFrom,
      sortOrder: sortOrder,
      processingTime: processingTime,
      blockedTime: blockedTime,
    );
    return Service.fromJson(data['service'] as Map<String, dynamic>);
  }

  /// DELETE /v1/services/{id}
  /// Soft deletes a service
  Future<void> deleteService(int serviceId) async {
    await _apiClient.deleteService(serviceId);
  }

  /// GET /v1/services/{id}/locations
  /// Gets the location IDs where this service has an active variant
  Future<List<int>> getServiceLocations(int serviceId) async {
    return _apiClient.getServiceLocations(serviceId);
  }

  /// PUT /v1/services/{id}/locations
  /// Updates the locations associated with a service
  Future<List<int>> updateServiceLocations({
    required int serviceId,
    required List<int> locationIds,
  }) async {
    return _apiClient.updateServiceLocations(
      serviceId: serviceId,
      locationIds: locationIds,
    );
  }

  // ===== Categories CRUD =====

  /// GET /v1/businesses/{business_id}/categories
  /// Gets all service categories for a business
  Future<List<ServiceCategory>> fetchCategories(int businessId) async {
    final data = await _apiClient.getServiceCategories(businessId);
    final List<dynamic> items = data['categories'] ?? [];
    return items
        .map((json) => ServiceCategory.fromJson(json as Map<String, dynamic>))
        .toList();
  }

  /// POST /v1/businesses/{business_id}/categories
  /// Creates a new category
  Future<ServiceCategory> createCategory({
    required int businessId,
    required String name,
    String? description,
  }) async {
    final data = await _apiClient.createServiceCategory(
      businessId: businessId,
      name: name,
      description: description,
    );
    return ServiceCategory.fromJson(data['category'] as Map<String, dynamic>);
  }

  /// PUT /v1/categories/{id}
  /// Updates an existing category
  Future<ServiceCategory> updateCategory({
    required int categoryId,
    String? name,
    String? description,
    int? sortOrder,
  }) async {
    final data = await _apiClient.updateServiceCategory(
      categoryId: categoryId,
      name: name,
      description: description,
      sortOrder: sortOrder,
    );
    return ServiceCategory.fromJson(data['category'] as Map<String, dynamic>);
  }

  /// DELETE /v1/categories/{id}
  /// Deletes a category (services become uncategorized)
  Future<void> deleteCategory(int categoryId) async {
    await _apiClient.deleteServiceCategory(categoryId);
  }
}
--- FILE: lib/features/services/data/service_packages_repository.dart ---
import '../../../core/models/service_package.dart';
import '../../../core/network/api_client.dart';
import 'service_packages_api.dart';

class ServicePackagesRepository {
  ServicePackagesRepository({required ApiClient apiClient})
    : _api = ServicePackagesApi(apiClient: apiClient);

  final ServicePackagesApi _api;

  Future<List<ServicePackage>> getPackages({required int locationId}) =>
      _api.fetchPackages(locationId);

  Future<ServicePackage> createPackage({
    required int locationId,
    required String name,
    required int categoryId,
    required List<int> serviceIds,
    String? description,
    double? overridePrice,
    int? overrideDurationMinutes,
    bool isActive = true,
  }) => _api.createPackage(
    locationId: locationId,
    name: name,
    categoryId: categoryId,
    serviceIds: serviceIds,
    description: description,
    overridePrice: overridePrice,
    overrideDurationMinutes: overrideDurationMinutes,
    isActive: isActive,
  );

  Future<ServicePackage> updatePackage({
    required int locationId,
    required int packageId,
    String? name,
    int? categoryId,
    String? description,
    double? overridePrice,
    int? overrideDurationMinutes,
    bool setOverridePriceNull = false,
    bool setOverrideDurationNull = false,
    bool? isActive,
    List<int>? serviceIds,
  }) => _api.updatePackage(
    locationId: locationId,
    packageId: packageId,
    name: name,
    categoryId: categoryId,
    description: description,
    overridePrice: overridePrice,
    overrideDurationMinutes: overrideDurationMinutes,
    setOverridePriceNull: setOverridePriceNull,
    setOverrideDurationNull: setOverrideDurationNull,
    isActive: isActive,
    serviceIds: serviceIds,
  );

  Future<void> deletePackage({
    required int locationId,
    required int packageId,
  }) => _api.deletePackage(locationId: locationId, packageId: packageId);

  Future<void> reorderPackages({
    required List<Map<String, dynamic>> packages,
  }) => _api.reorderPackages(packages: packages);

  Future<ServicePackageExpansion> expandPackage({
    required int locationId,
    required int packageId,
  }) => _api.expandPackage(locationId: locationId, packageId: packageId);
}
--- FILE: lib/features/services/data/services_repository.dart ---
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/network/api_client.dart';
import 'services_api.dart';

class ServicesRepository {
  ServicesRepository({required ApiClient apiClient})
    : _api = ServicesApi(apiClient: apiClient);

  final ServicesApi _api;

  /// Carica servizi e categorie dall'API
  Future<ServicesApiResult> getServicesWithCategories({
    required int locationId,
  }) => _api.fetchServicesWithCategories(locationId);

  /// Carica solo i servizi (legacy)
  Future<List<Service>> getServices({required int locationId}) =>
      _api.fetchServices(locationId);

  // ===== Services CRUD =====

  /// Creates a new service with variants for multiple locations
  Future<Service> createServiceMultiLocation({
    required int businessId,
    required List<int> locationIds,
    required String name,
    int? categoryId,
    String? description,
    int durationMinutes = 30,
    double price = 0,
    String? colorHex,
    bool isBookableOnline = true,
    bool isPriceStartingFrom = false,
    int? processingTime,
    int? blockedTime,
  }) => _api.createServiceMultiLocation(
    businessId: businessId,
    locationIds: locationIds,
    name: name,
    categoryId: categoryId,
    description: description,
    durationMinutes: durationMinutes,
    price: price,
    colorHex: colorHex,
    isBookableOnline: isBookableOnline,
    isPriceStartingFrom: isPriceStartingFrom,
    processingTime: processingTime,
    blockedTime: blockedTime,
  );

  /// Creates a new service (legacy, single location)
  Future<Service> createService({
    required int locationId,
    required String name,
    int? categoryId,
    String? description,
    int durationMinutes = 30,
    double price = 0,
    String? colorHex,
    bool isBookableOnline = true,
    bool isPriceStartingFrom = false,
    int? processingTime,
    int? blockedTime,
  }) => _api.createService(
    locationId: locationId,
    name: name,
    categoryId: categoryId,
    description: description,
    durationMinutes: durationMinutes,
    price: price,
    colorHex: colorHex,
    isBookableOnline: isBookableOnline,
    isPriceStartingFrom: isPriceStartingFrom,
    processingTime: processingTime,
    blockedTime: blockedTime,
  );

  /// Updates an existing service
  Future<Service> updateService({
    required int serviceId,
    required int locationId,
    String? name,
    int? categoryId,
    bool setCategoryIdNull = false,
    String? description,
    bool setDescriptionNull = false,
    int? durationMinutes,
    double? price,
    String? colorHex,
    bool? isBookableOnline,
    bool? isPriceStartingFrom,
    int? sortOrder,
    int? processingTime,
    int? blockedTime,
  }) => _api.updateService(
    serviceId: serviceId,
    locationId: locationId,
    name: name,
    categoryId: categoryId,
    setCategoryIdNull: setCategoryIdNull,
    description: description,
    setDescriptionNull: setDescriptionNull,
    durationMinutes: durationMinutes,
    price: price,
    colorHex: colorHex,
    isBookableOnline: isBookableOnline,
    isPriceStartingFrom: isPriceStartingFrom,
    sortOrder: sortOrder,
    processingTime: processingTime,
    blockedTime: blockedTime,
  );

  /// Deletes a service
  Future<void> deleteService(int serviceId) => _api.deleteService(serviceId);

  /// Gets the location IDs where this service has an active variant
  Future<List<int>> getServiceLocations(int serviceId) =>
      _api.getServiceLocations(serviceId);

  /// Updates the locations associated with a service
  Future<List<int>> updateServiceLocations({
    required int serviceId,
    required List<int> locationIds,
  }) => _api.updateServiceLocations(
    serviceId: serviceId,
    locationIds: locationIds,
  );

  // ===== Categories CRUD =====

  /// Gets all categories for a business
  Future<List<ServiceCategory>> getCategories(int businessId) =>
      _api.fetchCategories(businessId);

  /// Creates a new category
  Future<ServiceCategory> createCategory({
    required int businessId,
    required String name,
    String? description,
  }) => _api.createCategory(
    businessId: businessId,
    name: name,
    description: description,
  );

  /// Updates an existing category
  Future<ServiceCategory> updateCategory({
    required int categoryId,
    String? name,
    String? description,
    int? sortOrder,
  }) => _api.updateCategory(
    categoryId: categoryId,
    name: name,
    description: description,
    sortOrder: sortOrder,
  );

  /// Deletes a category
  Future<void> deleteCategory(int categoryId) =>
      _api.deleteCategory(categoryId);
}
--- FILE: lib/features/services/domain/controllers/category_controller.dart ---
/// Placeholder per futura persistenza/sincronizzazione delle categorie
/// con un backend remoto (REST/Firebase, ecc.).
class CategoryController {
  // In futuro: metodi per fetch/save/sync
}
--- FILE: lib/features/services/domain/services.dart ---
--- FILE: lib/features/services/presentation/service_packages_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/l10n/l10_extension.dart';
import '../../../core/utils/price_utils.dart';
import '../../../core/widgets/app_buttons.dart';
import '../../../core/widgets/app_dialogs.dart';
import '../../../core/widgets/feedback_dialog.dart';
import '../providers/service_categories_provider.dart';
import '../providers/service_packages_provider.dart';
import '../providers/services_provider.dart';
import 'dialogs/service_package_dialog.dart';

class ServicePackagesScreen extends ConsumerWidget {
  const ServicePackagesScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final packagesAsync = ref.watch(servicePackagesProvider);
    final servicesAsync = ref.watch(servicesProvider);
    final categories = ref.watch(serviceCategoriesProvider);
    final l10n = context.l10n;

    if (packagesAsync.isLoading || servicesAsync.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    final packages = packagesAsync.value ?? [];
    final services = servicesAsync.value ?? [];

    if (packages.isEmpty) {
      return Center(
        child: Text(
          l10n.servicePackagesEmptyState,
          style: Theme.of(context).textTheme.bodyMedium,
        ),
      );
    }

    return ListView.separated(
      padding: const EdgeInsets.all(16),
      itemCount: packages.length,
      separatorBuilder: (_, __) => const SizedBox(height: 12),
      itemBuilder: (context, index) {
        final pkg = packages[index];
        final currency = PriceFormatter.effectiveCurrency(ref);
        final price = PriceFormatter.format(
          context: context,
          amount: pkg.effectivePrice,
          currencyCode: currency,
        );
        final duration = pkg.effectiveDurationMinutes;

        return Card(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  children: [
                    Expanded(
                      child: Text(
                        pkg.name,
                        style: Theme.of(context).textTheme.titleMedium,
                      ),
                    ),
                    if (!pkg.isActive)
                      _StatusBadge(
                        label: l10n.servicePackageInactiveLabel,
                        color: Theme.of(context).colorScheme.outline,
                      ),
                    if (pkg.isBroken)
                      _StatusBadge(
                        label: l10n.servicePackageBrokenLabel,
                        color: Theme.of(context).colorScheme.error,
                      ),
                    const SizedBox(width: 8),
                    IconButton(
                      icon: const Icon(Icons.edit_outlined),
                      tooltip: l10n.actionEdit,
                      onPressed: () => showServicePackageDialog(
                        context,
                        ref,
                        services: services,
                        categories: categories,
                        package: pkg,
                      ),
                    ),
                    IconButton(
                      icon: const Icon(Icons.delete_outline),
                      tooltip: l10n.actionDelete,
                      onPressed: () async {
                        await showAppConfirmDialog(
                          context,
                          title: Text(l10n.servicePackageDeleteTitle),
                          content: Text(l10n.servicePackageDeleteMessage),
                          confirmLabel: l10n.actionDelete,
                          danger: true,
                          onConfirm: () async {
                            try {
                              await ref
                                  .read(servicePackagesProvider.notifier)
                                  .deletePackage(pkg.id);
                              if (!context.mounted) return;
                              FeedbackDialog.showSuccess(
                                context,
                                title: l10n.servicePackageDeletedTitle,
                                message: l10n.servicePackageDeletedMessage,
                              );
                            } catch (e) {
                              if (!context.mounted) return;
                              FeedbackDialog.showError(
                                context,
                                title: l10n.errorTitle,
                                message: l10n.servicePackageDeleteError,
                              );
                            }
                          },
                        );
                      },
                    ),
                  ],
                ),
                const SizedBox(height: 4),
                Text(
                  '${pkg.serviceCount} ${l10n.servicesLabel} ¬∑ $duration ${l10n.minutesLabel} ¬∑ $price',
                  style: Theme.of(context).textTheme.bodySmall,
                ),
                if (pkg.description != null &&
                    pkg.description!.trim().isNotEmpty) ...[
                  const SizedBox(height: 6),
                  Text(
                    pkg.description!,
                    style: Theme.of(context).textTheme.bodySmall,
                  ),
                ],
                const SizedBox(height: 8),
                Wrap(
                  spacing: 8,
                  runSpacing: 4,
                  children: [
                    for (final item in pkg.items)
                      Chip(
                        label: Text(
                          item.name ?? '#${item.serviceId}',
                          overflow: TextOverflow.ellipsis,
                        ),
                      ),
                  ],
                ),
                const SizedBox(height: 8),
                Align(
                  alignment: Alignment.centerRight,
                  child: AppOutlinedActionButton(
                    onPressed: () => showServicePackageDialog(
                      context,
                      ref,
                      services: services,
                      categories: categories,
                      package: pkg,
                    ),
                    child: Text(l10n.actionEdit),
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}

class _StatusBadge extends StatelessWidget {
  const _StatusBadge({required this.label, required this.color});

  final String label;
  final Color color;

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(left: 8),
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withOpacity(0.12),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: color.withOpacity(0.4)),
      ),
      child: Text(
        label,
        style: Theme.of(context).textTheme.labelSmall?.copyWith(color: color),
      ),
    );
  }
}
--- FILE: lib/features/services/presentation/services_screen.dart ---
import 'dart:async';

import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/l10n/l10_extension.dart';
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/models/service_package.dart';
import '../../../core/models/service_variant.dart';
import '../../../core/utils/color_utils.dart';
import '../../../core/utils/price_utils.dart';
import '../../../core/widgets/app_dialogs.dart';
import '../../../core/widgets/feedback_dialog.dart';
import '../../../core/widgets/reorder_toggle_button.dart';
import '../../../core/widgets/reorder_toggle_panel.dart';
import '../../auth/providers/current_business_user_provider.dart';
import '../../agenda/providers/location_providers.dart';
import '../../agenda/providers/resource_providers.dart';
import '../providers/service_categories_provider.dart';
import '../providers/service_packages_provider.dart';
import '../providers/services_provider.dart';
import '../providers/services_reorder_provider.dart';
import '../providers/services_sorted_providers.dart';
// utils e validators spostati nei dialog
import 'dialogs/category_dialog.dart';
import 'dialogs/service_dialog.dart';
import 'dialogs/service_package_dialog.dart';
import 'widgets/categories_list.dart';

class ServicesScreen extends ConsumerStatefulWidget {
  const ServicesScreen({super.key});

  @override
  ConsumerState<ServicesScreen> createState() => _ServicesScreenState();
}

class _ServicesScreenState extends ConsumerState<ServicesScreen> {
  static final ValueNotifier<int?> _hoveredService = ValueNotifier<int?>(null);
  static final ValueNotifier<int?> _selectedService = ValueNotifier<int?>(null);

  final ScrollController _scrollController = ScrollController();
  Timer? _autoScrollTimer;

  /// Modalit√† di riordino (mutuamente esclusive)
  bool isReorderCategories = false;
  bool isReorderServices = false;

  // NOTE: Non serve initState con refresh() perch√©:
  // 1. I provider AsyncNotifier caricano i dati automaticamente nel build()
  // 2. Il refresh al cambio tab avviene in _refreshProvidersForTab()

  // ---------- Auto-scroll mentre si trascina ----------
  void _startAutoScroll(Offset pointerInGlobal) {
    const threshold = 100.0; // distanza dal bordo
    const speed = 14.0; // px per tick ~60fps

    _autoScrollTimer?.cancel();
    _autoScrollTimer = Timer.periodic(const Duration(milliseconds: 16), (_) {
      if (!_scrollController.hasClients) return;

      final renderBox = context.findRenderObject() as RenderBox?;
      if (renderBox == null) return;

      final local = renderBox.globalToLocal(pointerInGlobal);
      final dy = local.dy;

      final pos = _scrollController.offset;
      final max = _scrollController.position.maxScrollExtent;
      final viewH = _scrollController.position.viewportDimension;

      if (dy < threshold && pos > 0) {
        _scrollController.jumpTo((pos - speed).clamp(0, max));
      } else if (dy > viewH - threshold && pos < max) {
        _scrollController.jumpTo((pos + speed).clamp(0, max));
      }
    });
  }

  void _stopAutoScroll() => _autoScrollTimer?.cancel();

  void _toggleCategoryReorder() {
    setState(() {
      isReorderCategories = !isReorderCategories;
      if (isReorderCategories) isReorderServices = false;
    });
    if (!isReorderCategories) {
      ref.read(servicesReorderPanelProvider.notifier).setVisible(false);
    }
  }

  void _toggleServiceReorder() {
    setState(() {
      isReorderServices = !isReorderServices;
      if (isReorderServices) isReorderCategories = false;
    });
    if (!isReorderServices) {
      ref.read(servicesReorderPanelProvider.notifier).setVisible(false);
    }
  }

  @override
  void initState() {
    super.initState();
  }

  @override
  void dispose() {
    _autoScrollTimer?.cancel();
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final canManageServices = ref.watch(currentUserCanManageServicesProvider);
    final servicesAsync = ref.watch(servicesProvider);
    final allCategories = ref.watch(sortedCategoriesProvider);
    final packages = ref.watch(servicePackagesProvider).value ?? const <ServicePackage>[];
    final services = servicesAsync.value ?? const <Service>[];
    // Pre-carica le risorse solo per ruoli che possono modificare servizi.
    if (canManageServices) {
      ref.watch(resourcesProvider);
    }

    final localNonEmptyCategoryIds = <int>{
      for (final s in services)
        if (s.categoryId > 0) s.categoryId,
    };
    final serviceById = {for (final s in services) s.id: s};
    for (final package in packages) {
      var categoryId = package.categoryId;
      if (categoryId == 0 && package.items.isNotEmpty) {
        categoryId = serviceById[package.items.first.serviceId]?.categoryId ?? 0;
      }
      if (categoryId > 0) {
        localNonEmptyCategoryIds.add(categoryId);
      }
    }

    var categoriesWithServicesElsewhere = <int>{};
    final locations = ref.watch(locationsProvider);
    if (locations.length > 1) {
      final allLocationIds = locations.map((location) => location.id).toSet();
      final allLocationsServicesAsync = ref.watch(
        servicesForLocationsProvider(locationIdsToKey(allLocationIds)),
      );
      final allCategoriesWithServices = <int>{
        for (final s in allLocationsServicesAsync.value?.services ?? const <Service>[])
          if (s.categoryId > 0) s.categoryId,
      };
      categoriesWithServicesElsewhere = allCategoriesWithServices.difference(
        localNonEmptyCategoryIds,
      );
    }

    final categories = allCategories.where((category) {
      if (localNonEmptyCategoryIds.contains(category.id)) {
        return true;
      }
      return !categoriesWithServicesElsewhere.contains(category.id);
    }).toList();

    final colorScheme = Theme.of(context).colorScheme;
    final isWide = ref.watch(formFactorProvider) != AppFormFactor.mobile;
    final showReorderPanel = ref.watch(servicesReorderPanelProvider);

    ref.listen<bool>(servicesReorderPanelProvider, (previous, next) {
      if (!next && (isReorderCategories || isReorderServices)) {
        setState(() {
          isReorderCategories = false;
          isReorderServices = false;
        });
      }
      // Se apro il pannello e c'√® solo 1 categoria, attiva subito riordino servizi
      if (next && previous == false && categories.length < 2) {
        setState(() {
          isReorderServices = true;
          isReorderCategories = false;
        });
      }
    });

    return Column(
      children: [
        Expanded(
          child: _buildServicesTab(
            context,
            ref,
            servicesAsync: servicesAsync,
            categories: categories,
            showReorderPanel: showReorderPanel,
            isWide: isWide,
            colorScheme: colorScheme,
          ),
        ),
      ],
    );
  }

  Widget _buildServicesTab(
    BuildContext context,
    WidgetRef ref, {
    required AsyncValue<List<Service>> servicesAsync,
    required List<ServiceCategory> categories,
    required bool showReorderPanel,
    required bool isWide,
    required ColorScheme colorScheme,
  }) {
    if (servicesAsync.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }
    if (servicesAsync.hasError) {
      return Center(
        child: Text(
          context.l10n.errorTitle,
          style: Theme.of(context).textTheme.bodyMedium?.copyWith(
            color: Theme.of(context).colorScheme.onSurfaceVariant,
          ),
        ),
      );
    }

    if (categories.isEmpty) {
      return Center(
        child: Text(
          context.l10n.noServicesFound,
          style: Theme.of(context).textTheme.bodyMedium?.copyWith(
            color: Theme.of(context).colorScheme.onSurfaceVariant,
          ),
        ),
      );
    }

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: () => _selectedService.value = null,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (showReorderPanel) ...[
            Padding(
              padding: const EdgeInsets.all(16),
              child: Center(
                child: Column(
                  children: [
                    Text(
                      context.l10n.reorderTitle,
                      style: Theme.of(context).textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(0, 4, 0, 8),
                      child: Text(
                        context.l10n.reorderHelpDescription,
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          color: Theme.of(context).colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ),
                    ReorderTogglePanel(
                      isWide: isWide,
                      children: [
                        if (categories.length >= 2)
                          ReorderToggleButton(
                            isActive: isReorderCategories,
                            onPressed: _toggleCategoryReorder,
                            activeLabel: context.l10n.reorderCategoriesLabel,
                            inactiveLabel: context.l10n.reorderCategoriesLabel,
                            activeIcon: Icons.check,
                            inactiveIcon: Icons.drag_indicator,
                          ),
                        ReorderToggleButton(
                          isActive: isReorderServices,
                          onPressed: _toggleServiceReorder,
                          activeLabel: context.l10n.reorderServicesLabel,
                          inactiveLabel: context.l10n.reorderServicesLabel,
                          activeIcon: Icons.check,
                          inactiveIcon: Icons.drag_indicator,
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ],
          Expanded(
            child: isReorderCategories
                ? _buildReorderCategories(context, ref, categories)
                : isReorderServices
                ? _buildReorderServices(context, ref, categories)
                : _buildNormalList(
                    context,
                    ref,
                    categories,
                    isWide,
                    colorScheme,
                  ),
          ),
        ],
      ),
    );
  }

  // ============================
  //  RIORDINO CATEGORIE (solo categorie, servizi nascosti)
  // ============================
  Widget _buildReorderCategories(
    BuildContext context,
    WidgetRef ref,
    List<ServiceCategory> cats,
  ) {
    final colorScheme = Theme.of(context).colorScheme;

    // Partiziona categorie piene e vuote
    final services = ref.watch(servicesProvider).value ?? [];
    final packagesByCategory = <int, int>{
      for (final c in cats)
        c.id: ref.watch(servicePackagesByCategoryProvider(c.id)).length,
    };
    final isNonEmpty = <int, bool>{
      for (final c in cats) c.id: services.any((s) => s.categoryId == c.id),
    };
    for (final entry in packagesByCategory.entries) {
      if (entry.value > 0) {
        isNonEmpty[entry.key] = true;
      }
    }
    final fullCats = [
      for (final c in cats)
        if (isNonEmpty[c.id]!) c,
    ];
    final emptyCats = [
      for (final c in cats)
        if (!isNonEmpty[c.id]!) c,
    ];

    // Costruisci righe: piene, separatore, vuote (disabilitate)
    final rows = <({String type, ServiceCategory? cat})>[];
    for (final c in fullCats) {
      rows.add((type: 'full', cat: c));
    }
    if (emptyCats.isNotEmpty) {
      rows.add((type: 'separator', cat: null));
      for (final c in emptyCats) {
        rows.add((type: 'empty', cat: c));
      }
    }

    int fullIndexFromRow(int rowIndex) {
      int count = 0;
      for (int i = 0; i < rowIndex; i++) {
        if (rows[i].type == 'full') count++;
      }
      return count;
    }

    return Listener(
      onPointerMove: (e) => _startAutoScroll(e.position),
      onPointerUp: (_) => _stopAutoScroll(),
      child: ReorderableListView.builder(
        scrollController: _scrollController,
        padding: const EdgeInsets.fromLTRB(16, 12, 16, 100),
        buildDefaultDragHandles: false,
        // Evita l'effetto elevazione/ombra sull'item in drag:
        proxyDecorator: (child, index, animation) => child,
        itemCount: rows.length,
        onReorder: (oldIndex, newIndex) {
          final movingDown = newIndex > oldIndex;
          if (movingDown) newIndex -= 1;

          // Calcola gli indici nella sola lista delle piene
          final oldFullIndex = fullIndexFromRow(oldIndex);
          final newFullIndex = fullIndexFromRow(newIndex);

          ref
              .read(servicesReorderProvider.notifier)
              .reorderNonEmptyCategories(oldFullIndex, newFullIndex);
        },
        itemBuilder: (context, index) {
          final row = rows[index];
          if (row.type == 'separator') {
            return Container(
              key: const ValueKey('sep'),
              padding: const EdgeInsets.only(top: 64, bottom: 24),
              child: Text(
                context.l10n.emptyCategoriesNotReorderableNote,
                textAlign: TextAlign.center,
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
              ),
            );
          }
          final category = row.cat!;
          final isEmpty = row.type == 'empty';
          return Opacity(
            key: ValueKey('cat-${category.id}'),
            opacity: isEmpty ? 0.6 : 1.0,
            child: Container(
              margin: const EdgeInsets.only(bottom: 16),
              decoration: BoxDecoration(
                color: colorScheme.surface,
                borderRadius: BorderRadius.circular(12),
                border: Border.all(
                  color: colorScheme.outlineVariant.withOpacity(0.4),
                ),
              ),
              child: ListTile(
                leading: isEmpty
                    ? Icon(
                        Icons.drag_indicator,
                        color: colorScheme.onSurfaceVariant.withOpacity(0.3),
                      )
                    : ReorderableDragStartListener(
                        index: index,
                        child: const Icon(Icons.drag_indicator),
                      ),
                title: Text(category.name),
                enabled: !isEmpty,
              ),
            ),
          );
        },
      ),
    );
  }

  // ============================
  //  RIORDINO SERVIZI (CROSS-CATEGORIA)
  // ============================
  Widget _buildReorderServices(
    BuildContext context,
    WidgetRef ref,
    List<ServiceCategory> cats,
  ) {
    final colorScheme = Theme.of(context).colorScheme;
    final reorder = ref.read(servicesReorderProvider.notifier);

    // Flatten di servizi e pacchetti (solo delle categorie visualizzate)
    final allEntries = <ServiceCategoryEntry>[];
    final entriesByCategory = <int, List<ServiceCategoryEntry>>{};
    for (final c in cats) {
      final list = ref.watch(sortedCategoryEntriesProvider(c.id));
      entriesByCategory[c.id] = list;
      allEntries.addAll(list);
    }

    // Costruisce la lista visuale con header categoria "fissi" e righe elementi.
    // Gli header non hanno drag handle e non sono riordinabili; i servizi/pacchetti s√¨.
    final rows =
        <({bool isHeader, ServiceCategoryEntry? entry, ServiceCategory? c})>[];
    for (final c in cats) {
      final list = entriesByCategory[c.id] ?? const <ServiceCategoryEntry>[];
      // Sempre mostrare header, anche se vuota
      rows.add((isHeader: true, entry: null, c: c));
      for (final entry in list) {
        rows.add((isHeader: false, entry: entry, c: null));
      }
    }

    int entryFlatIndexFromRowsIndex(int rowsIndex, int oldIndex) {
      int count = 0;
      for (int i = 0; i < rowsIndex; i++) {
        if (i == oldIndex) continue;
        if (!rows[i].isHeader) count++;
      }
      return count;
    }

    // Funzione di supporto: data la posizione "globale" nella lista piatta,
    // ritorna la coppia (categoryId, indexNellaCategoria) dove verrebbe inserito
    (int catId, int indexInCat) targetForFlatIndex(
      int flatIndex, {
      required List<ServiceCategoryEntry> entries,
      required int fallbackCategoryId,
    }) {
      // Clamp e fallback
      if (entries.isEmpty) return (fallbackCategoryId, 0);
      final idx = flatIndex.clamp(0, entries.length);

      // Inserimento in coda assoluta
      if (idx == entries.length) {
        final last = entries.last;
        final inCat = entriesByCategory[last.categoryId] ?? [];
        return (last.categoryId, inCat.length);
      }

      // Pivot alla posizione globale idx
      final pivot = entries[idx];
      final pivotCatId = pivot.categoryId;

      // Quanti elementi di quella categoria compaiono prima dell'indice globale
      int countBeforeInPivotCat = 0;
      for (int i = 0; i < idx; i++) {
        final entry = entries[i];
        if (entry.categoryId == pivotCatId) {
          countBeforeInPivotCat++;
        }
      }

      return (pivotCatId, countBeforeInPivotCat);
    }

    return Listener(
      onPointerMove: (e) => _startAutoScroll(e.position),
      onPointerUp: (_) => _stopAutoScroll(),
      child: ReorderableListView.builder(
        scrollController: _scrollController,
        padding: const EdgeInsets.fromLTRB(16, 12, 16, 100),
        buildDefaultDragHandles: false,
        // Coerenza visiva: nessuna elevazione/ombra anche durante il drag servizi
        proxyDecorator: (child, index, animation) => child,
        itemCount: rows.length,
        onReorder: (oldIndex, newIndex) {
          // Usa newIndex raw: il mapping a flat index esclude gia' l'elemento trascinato.

          final entryOld = rows[oldIndex].entry;
          if (entryOld == null) return;
          final oldCatId = entryOld.categoryId;
          final entriesWithoutMoving = [
            for (final entry in allEntries)
              if (entry.key != entryOld.key) entry,
          ];

          final bool dropOnHeader =
              newIndex < rows.length && rows[newIndex].isHeader;
          int fallbackCategoryId = oldCatId;
          final fallbackStartIndex = dropOnHeader
              ? newIndex - 1
              : (newIndex >= rows.length ? rows.length - 1 : newIndex);
          for (int i = fallbackStartIndex; i >= 0; i--) {
            final row = rows[i];
            if (row.isHeader) {
              fallbackCategoryId = row.c!.id;
              break;
            }
          }

          // Traduci newIndex della lista visuale in indice sulla lista elementi (saltando header)
          final targetFlatIndex = entryFlatIndexFromRowsIndex(
            newIndex,
            oldIndex,
          );

          // Se si rilascia su un header, inserisci in coda alla categoria precedente
          final (targetCatId, indexInTargetCat) = dropOnHeader
              ? (
                  fallbackCategoryId,
                  (entriesByCategory[fallbackCategoryId] ?? [])
                      .where((e) => e.key != entryOld.key)
                      .length,
                )
              : targetForFlatIndex(
                  targetFlatIndex,
                  entries: entriesWithoutMoving,
                  fallbackCategoryId: fallbackCategoryId,
                );

          if (targetCatId == oldCatId) {
            // stesso gruppo -> semplice riordino interno
            final updated = [
              ...(entriesByCategory[oldCatId] ??
                  const <ServiceCategoryEntry>[]),
            ];
            final oldIndexInCat = updated.indexWhere(
              (e) => e.key == entryOld.key,
            );
            if (oldIndexInCat < 0) return;
            final item = updated.removeAt(oldIndexInCat);
            final targetIndex = indexInTargetCat.clamp(0, updated.length);
            updated.insert(targetIndex, item);
            reorder.reorderCategoryItems(categoryId: oldCatId, items: updated);
          } else {
            // Cross-categoria -> sposta
            final oldItems = [
              ...(entriesByCategory[oldCatId] ??
                  const <ServiceCategoryEntry>[]),
            ];
            final newItems = [
              ...(entriesByCategory[targetCatId] ??
                  const <ServiceCategoryEntry>[]),
            ];
            final oldIndexInCat = oldItems.indexWhere(
              (e) => e.key == entryOld.key,
            );
            if (oldIndexInCat < 0) return;
            final movingItem = oldItems.removeAt(oldIndexInCat);
            final targetIndex = indexInTargetCat.clamp(0, newItems.length);
            newItems.insert(targetIndex, movingItem);
            reorder.moveCategoryItemBetweenCategories(
              oldCategoryId: oldCatId,
              newCategoryId: targetCatId,
              oldItems: oldItems,
              newItems: newItems,
            );
          }
        },
        itemBuilder: (context, index) {
          final row = rows[index];
          if (row.isHeader) {
            final category = row.c!;
            return Container(
              key: ValueKey('header-${category.id}'),
              width: double.infinity,
              margin: const EdgeInsets.only(top: 16, bottom: 6),
              decoration: BoxDecoration(
                color: colorScheme.primaryContainer,
                borderRadius: const BorderRadius.vertical(
                  top: Radius.circular(16),
                ),
              ),
              padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),
              child: Text(
                category.name,
                style: Theme.of(context).textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                  color: colorScheme.onPrimaryContainer,
                ),
              ),
            );
          }

          final entry = row.entry!;
          if (!entry.isService) {
            final package = entry.package!;
            return Container(
              key: ValueKey('pkg-${package.id}'),
              margin: const EdgeInsets.only(bottom: 6),
              decoration: BoxDecoration(
                color: colorScheme.surface,
                borderRadius: BorderRadius.circular(10),
                border: Border.all(
                  color: colorScheme.outlineVariant.withOpacity(0.7),
                ),
              ),
              child: ListTile(
                leading: ReorderableDragStartListener(
                  index: index,
                  child: const Icon(Icons.drag_indicator),
                ),
                title: Text(package.name),
                dense: true,
                contentPadding: const EdgeInsets.symmetric(
                  horizontal: 12,
                  vertical: 4,
                ),
              ),
            );
          }

          final s = entry.service!;
          return Container(
            key: ValueKey('svc-${s.id}'),
            margin: const EdgeInsets.only(bottom: 6),
            decoration: BoxDecoration(
              color: colorScheme.surface,
              borderRadius: BorderRadius.circular(10),
              border: Border.all(
                color: colorScheme.outlineVariant.withOpacity(0.7),
              ),
            ),
            child: ListTile(
              leading: ReorderableDragStartListener(
                index: index,
                child: const Icon(Icons.drag_indicator),
              ),
              title: Text(s.name),
              dense: true,
              contentPadding: const EdgeInsets.symmetric(
                horizontal: 12,
                vertical: 4,
              ),
            ),
          );
        },
      ),
    );
  }

  // ============================
  //  VISTA NORMALE (pulsanti visibili, no drag)
  // ============================
  Widget _buildNormalList(
    BuildContext context,
    WidgetRef ref,
    List<ServiceCategory> cats,
    bool isWide,
    ColorScheme colorScheme,
  ) {
    final canManageServices = ref.watch(currentUserCanManageServicesProvider);
    final servicesNotifier = ref.read(servicesProvider.notifier);
    if (cats.isEmpty) {
      return Center(
        child: Text(
          context.l10n.noServicesFound,
          style: Theme.of(context).textTheme.bodyMedium?.copyWith(
            color: Theme.of(context).colorScheme.onSurfaceVariant,
          ),
        ),
      );
    }

    Color? mostUsedColorForCategory(ServiceCategory category) {
      final services = (ref.read(servicesProvider).value ?? [])
          .where((s) => s.categoryId == category.id)
          .toList();
      if (services.isEmpty) return null;
      final variants = ref.read(serviceVariantsProvider).value ?? [];
      final counts = <int, int>{};
      Color? topColor;
      int topCount = 0;
      for (final service in services) {
        ServiceVariant? variant;
        for (final v in variants) {
          if (v.serviceId == service.id) {
            variant = v;
            break;
          }
        }
        final colorHex = variant?.colorHex;
        if (colorHex == null) continue;
        final color = ColorUtils.fromHex(colorHex);
        final key = color.value;
        final nextCount = (counts[key] ?? 0) + 1;
        counts[key] = nextCount;
        if (nextCount > topCount) {
          topCount = nextCount;
          topColor = color;
        }
      }
      return topColor;
    }

    return CategoriesList(
      categories: cats,
      isWide: isWide,
      colorScheme: colorScheme,
      hoveredService: _hoveredService,
      selectedService: _selectedService,
      scrollController: _scrollController,
      onAddService: (category) => _openServiceDialog(
        context,
        ref,
        preselectedCategoryId: category.id,
        preselectedColor: mostUsedColorForCategory(category),
      ),
      onAddPackage: (category) =>
          _openPackageDialog(context, ref, preselectedCategoryId: category.id),
      onEditCategory: (category) =>
          showCategoryDialog(context, ref, category: category),
      onDeleteCategory: (categoryId) =>
          _confirmDeleteCategory(context, ref, categoryId),
      onDeleteCategoryBlocked: () => _showCannotDeleteCategoryDialog(context),
      onServiceOpen: (service) =>
          _openServiceDialog(context, ref, service: service),
      onServiceEdit: (service) =>
          _openServiceDialog(context, ref, service: service),
      onServiceDuplicate: (service) => _openServiceDialog(
        context,
        ref,
        service: service,
        duplicateFrom: true,
      ),
      onServiceDelete: (id) => _confirmDelete(
        context,
        ref,
        onConfirm: () async => servicesNotifier.deleteServiceApi(id),
      ),
      onPackageOpen: (package) =>
          _openPackageDialog(context, ref, package: package),
      onPackageEdit: (package) =>
          _openPackageDialog(context, ref, package: package),
      onPackageDelete: (id) => _confirmDeletePackage(context, ref, id),
      readOnly: !canManageServices,
    );
  }

  void _confirmDeleteCategory(
    BuildContext context,
    WidgetRef ref,
    int categoryId,
  ) {
    final canManageServices = ref.read(currentUserCanManageServicesProvider);
    if (!canManageServices) return;

    showAppConfirmDialog(
      context,
      title: Text(context.l10n.deleteConfirmationTitle),
      confirmLabel: context.l10n.actionDelete,
      cancelLabel: context.l10n.actionCancel,
      danger: true,
      onConfirm: () async {
        await ref
            .read(serviceCategoriesProvider.notifier)
            .deleteCategoryApi(categoryId);
      },
    );
  }

  void _showCannotDeleteCategoryDialog(BuildContext context) {
    showAppInfoDialog(
      context,
      title: Text(context.l10n.cannotDeleteTitle),
      content: Text(context.l10n.cannotDeleteCategoryContent),
      closeLabel: context.l10n.actionClose,
    );
  }

  Future<void> _openServiceDialog(
    BuildContext context,
    WidgetRef ref, {
    Service? service,
    int? preselectedCategoryId,
    Color? preselectedColor,
    bool duplicateFrom = false,
  }) {
    final canManageServices = ref.read(currentUserCanManageServicesProvider);
    if (!canManageServices) {
      if (service == null) return Future.value();
      return showServiceDialog(
        context,
        ref,
        service: service,
        readOnly: true,
      ).then((_) => _selectedService.value = null);
    }

    return showServiceDialog(
      context,
      ref,
      service: service,
      preselectedCategoryId: preselectedCategoryId,
      preselectedColor: preselectedColor,
      duplicateFrom: duplicateFrom,
    ).then((_) => _selectedService.value = null);
  }

  Future<void> _openPackageDialog(
    BuildContext context,
    WidgetRef ref, {
    ServicePackage? package,
    int? preselectedCategoryId,
  }) {
    final canManageServices = ref.read(currentUserCanManageServicesProvider);
    if (!canManageServices) {
      if (package != null) {
        _openPackageDetailsDialog(context, ref, package);
      }
      return Future.value();
    }

    final services = ref.read(servicesProvider).value ?? [];
    final categories = ref.read(serviceCategoriesProvider);
    return showServicePackageDialog(
      context,
      ref,
      services: services,
      categories: categories,
      package: package,
      preselectedCategoryId: preselectedCategoryId,
    ).then((_) => _selectedService.value = null);
  }

  void _confirmDeletePackage(
    BuildContext context,
    WidgetRef ref,
    int packageId,
  ) {
    final canManageServices = ref.read(currentUserCanManageServicesProvider);
    if (!canManageServices) return;

    showAppConfirmDialog(
      context,
      title: Text(context.l10n.servicePackageDeleteTitle),
      content: Text(context.l10n.servicePackageDeleteMessage),
      confirmLabel: context.l10n.actionDelete,
      danger: true,
      onConfirm: () async {
        try {
          await ref
              .read(servicePackagesProvider.notifier)
              .deletePackage(packageId);
          if (!context.mounted) return;
          FeedbackDialog.showSuccess(
            context,
            title: context.l10n.servicePackageDeletedTitle,
            message: context.l10n.servicePackageDeletedMessage,
          );
        } catch (_) {
          if (!context.mounted) return;
          FeedbackDialog.showError(
            context,
            title: context.l10n.errorTitle,
            message: context.l10n.servicePackageDeleteError,
          );
        }
      },
    );
  }

  void _confirmDelete(
    BuildContext context,
    WidgetRef ref, {
    required VoidCallback onConfirm,
  }) {
    final canManageServices = ref.read(currentUserCanManageServicesProvider);
    if (!canManageServices) return;

    showAppConfirmDialog(
      context,
      title: Text(context.l10n.deleteServiceQuestion),
      content: Text(context.l10n.cannotUndoWarning),
      confirmLabel: context.l10n.actionDelete,
      cancelLabel: context.l10n.actionCancel,
      danger: true,
      onConfirm: onConfirm,
    );
  }

  Future<void> _openPackageDetailsDialog(
    BuildContext context,
    WidgetRef ref,
    ServicePackage package,
  ) async {
    final isIt = Localizations.localeOf(context).languageCode == 'it';
    final durationLabelText = isIt ? 'Durata' : 'Duration';
    final priceLabelText = isIt ? 'Prezzo' : 'Price';
    final currencyCode = ref.read(effectiveCurrencyProvider);
    await showAppInfoDialog(
      context,
      title: Text(package.name),
      content: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            '$durationLabelText: ${context.localizedDurationLabel(package.effectiveDurationMinutes)}',
          ),
          const SizedBox(height: 6),
          Text(
            '$priceLabelText: ${PriceFormatter.format(context: context, amount: package.effectivePrice, currencyCode: currencyCode)}',
          ),
          if ((package.description ?? '').trim().isNotEmpty) ...[
            const SizedBox(height: 10),
            Text(package.description!.trim()),
          ],
        ],
      ),
      closeLabel: context.l10n.actionClose,
    );
  }
}

// Add menu locale rimosso: ora √® gestito dallo ScaffoldWithNavigation
--- FILE: lib/features/services/presentation/dialogs/category_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service_category.dart';
import '../../../../core/utils/string_utils.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/labeled_form_field.dart';
import '../../../../core/widgets/local_loading_overlay.dart';
import '../../providers/service_categories_provider.dart';
import '../../utils/service_validators.dart';

Future<void> showCategoryDialog(
  BuildContext context,
  WidgetRef ref, {
  ServiceCategory? category,
}) async {
  final notifier = ref.read(serviceCategoriesProvider.notifier);
  final allCategories = ref.read(serviceCategoriesProvider);
  final isDesktop = ref.read(formFactorProvider) == AppFormFactor.desktop;

  final nameController = TextEditingController(text: category?.name ?? '');
  final descController = TextEditingController(
    text: category?.description ?? '',
  );

  bool nameError = false;
  bool duplicateError = false;
  bool isSaving = false;

  Widget buildContent(void Function(VoidCallback) setState) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        LabeledFormField(
          label: context.l10n.fieldNameRequiredLabel,
          child: TextField(
            controller: nameController,
            decoration: InputDecoration(
              border: const OutlineInputBorder(),
              isDense: true,
              errorText: nameError
                  ? context.l10n.fieldNameRequiredError
                  : (duplicateError
                        ? context.l10n.categoryDuplicateError
                        : null),
            ),
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        LabeledFormField(
          label: context.l10n.fieldDescriptionLabel,
          child: TextField(
            controller: descController,
            maxLines: 3,
            decoration: const InputDecoration(
              border: OutlineInputBorder(),
              isDense: true,
            ),
          ),
        ),
      ],
    );
  }

  Future<bool> handleSave() async {
    final rawName = nameController.text.trim();
    if (rawName.isEmpty) {
      nameError = true;
      return false;
    }

    final formattedName = StringUtils.toTitleCase(rawName);

    if (ServiceValidators.isDuplicateCategoryName(
      allCategories,
      formattedName,
      excludeId: category?.id,
    )) {
      duplicateError = true;
      return false;
    }

    final description = descController.text.trim().isEmpty
        ? null
        : descController.text.trim();

    if (category == null) {
      // Create new category via API
      final result = await notifier.createCategoryApi(
        name: formattedName,
        description: description,
      );
      return result != null;
    } else {
      // Update existing category via API
      final result = await notifier.updateCategoryApi(
        categoryId: category.id,
        name: formattedName,
        description: description,
      );
      return result != null;
    }
  }

  final title = category == null
      ? context.l10n.newCategoryTitle
      : context.l10n.editCategoryTitle;

  final builder = StatefulBuilder(
    builder: (ctx, setState) {
      final content = buildContent(setState);

      final cancelButton = SizedBox(
        width: AppButtonStyles.dialogButtonWidth,
        child: AppOutlinedActionButton(
          onPressed: isSaving ? null : () => Navigator.pop(ctx),
          padding: AppButtonStyles.dialogButtonPadding,
          child: Text(context.l10n.actionCancel),
        ),
      );

      final saveButton = SizedBox(
        width: AppButtonStyles.dialogButtonWidth,
        child: AppAsyncFilledButton(
          onPressed: isSaving
              ? null
              : () async {
                  setState(() => isSaving = true);
                  try {
                    final closed = await handleSave();
                    if (!closed) {
                      setState(() => isSaving = false);
                    } else {
                      if (ctx.mounted) {
                        Navigator.of(ctx).pop();
                      }
                    }
                  } catch (e) {
                    setState(() => isSaving = false);
                  }
                },
          padding: AppButtonStyles.dialogButtonPadding,
          isLoading: isSaving,
          showSpinner: false,
          child: Text(context.l10n.actionSave),
        ),
      );

      if (isDesktop) {
        return DismissibleDialog(
          child: Dialog(
            insetPadding: const EdgeInsets.symmetric(
              horizontal: 32,
              vertical: 24,
            ),
            child: ConstrainedBox(
              constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
              child: LocalLoadingOverlay(
                isLoading: isSaving,
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      Text(title, style: Theme.of(ctx).textTheme.headlineSmall),
                      const SizedBox(height: 16),
                      content,
                      const SizedBox(height: 24),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.end,
                        children: [
                          cancelButton,
                          const SizedBox(width: 8),
                          saveButton,
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        );
      }

      return SafeArea(
        top: false,
        child: LayoutBuilder(
          builder: (ctx, constraints) {
            final isKeyboardOpen = MediaQuery.of(ctx).viewInsets.bottom > 0;
            return LocalLoadingOverlay(
              isLoading: isSaving,
              child: SizedBox(
                height: constraints.maxHeight,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Expanded(
                      child: SingleChildScrollView(
                        padding: EdgeInsets.only(bottom: 0),
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Padding(
                              padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  Padding(
                                    padding: const EdgeInsets.only(bottom: 12),
                                    child: Text(
                                      title,
                                      style: Theme.of(ctx).textTheme.titleLarge,
                                    ),
                                  ),
                                  content,
                                  const SizedBox(height: 24),
                                  const SizedBox(
                                    height: AppSpacing.formRowSpacing,
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                    if (!isKeyboardOpen) ...[
                      const AppDivider(),
                      Padding(
                        padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                        child: Align(
                          alignment: 2 == 3
                              ? Alignment.center
                              : Alignment.centerRight,
                          child: Wrap(
                            alignment: 2 == 3
                                ? WrapAlignment.center
                                : WrapAlignment.end,
                            spacing: 8,
                            runSpacing: 8,
                            children: [cancelButton, saveButton],
                          ),
                        ),
                      ),
                    ],
                    SizedBox(height: MediaQuery.of(ctx).viewPadding.bottom),
                  ],
                ),
              ),
            );
          },
        ),
      );
    },
  );

  if (isDesktop) {
    await showDialog(context: context, builder: (_) => builder);
  } else {
    await AppBottomSheet.show(
      context: context,
      builder: (_) => builder,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
    );
  }
}
--- FILE: lib/features/services/presentation/dialogs/service_package_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/core/utils/price_utils.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';
import '../../../../core/models/service_package.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/feedback_dialog.dart';
import '../../../../core/widgets/labeled_form_field.dart';
import '../../../../core/widgets/local_loading_overlay.dart';
import '../../providers/service_packages_provider.dart';
import '../widgets/service_eligibility_selector.dart';

Future<void> showServicePackageDialog(
  BuildContext context,
  WidgetRef ref, {
  required List<Service> services,
  required List<ServiceCategory> categories,
  ServicePackage? package,
  int? preselectedCategoryId,
}) async {
  final formFactor = ref.read(formFactorProvider);

  final dialog = _ServicePackageDialog(
    services: services,
    categories: categories,
    package: package,
    preselectedCategoryId: preselectedCategoryId,
  );

  if (formFactor == AppFormFactor.mobile) {
    await AppBottomSheet.show<void>(
      context: context,
      useRootNavigator: true,
      heightFactor: 0.94,
      padding: EdgeInsets.zero,
      builder: (_) => dialog,
    );
  } else {
    await showDialog<void>(
      context: context,
      builder: (_) => dialog,
    );
  }
}

class _ServicePackageDialog extends ConsumerStatefulWidget {
  const _ServicePackageDialog({
    required this.services,
    required this.categories,
    this.package,
    this.preselectedCategoryId,
  });

  final List<Service> services;
  final List<ServiceCategory> categories;
  final ServicePackage? package;
  final int? preselectedCategoryId;

  @override
  ConsumerState<_ServicePackageDialog> createState() =>
      _ServicePackageDialogState();
}

class _ServicePackageDialogState extends ConsumerState<_ServicePackageDialog> {
  final _formKey = GlobalKey<FormState>();
  late final TextEditingController _nameController;
  late final TextEditingController _descriptionController;
  late final TextEditingController _overridePriceController;
  late final TextEditingController _overrideDurationController;

  bool _isActive = true;
  bool _isSaving = false;
  int? _selectedCategoryId;
  String? _servicesError;
  List<int> _orderedServiceIds = [];

  Set<int> get _selectedServiceIds => _orderedServiceIds.toSet();

  @override
  void initState() {
    super.initState();
    final pkg = widget.package;
    _nameController = TextEditingController(text: pkg?.name ?? '');
    _descriptionController = TextEditingController(
      text: pkg?.description ?? '',
    );
    _overridePriceController = TextEditingController(
      text: pkg?.overridePrice?.toStringAsFixed(2) ?? '',
    );
    _overrideDurationController = TextEditingController(
      text: pkg?.overrideDurationMinutes?.toString() ?? '',
    );
    _isActive = pkg?.isActive ?? true;
    _selectedCategoryId =
        pkg?.categoryId ?? widget.preselectedCategoryId;
    if (_selectedCategoryId == null && widget.categories.length == 1) {
      _selectedCategoryId = widget.categories.first.id;
    }
    if (pkg != null) {
      final sortedItems = [...pkg.items]
        ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));
      _orderedServiceIds = sortedItems.map((item) => item.serviceId).toList();
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _descriptionController.dispose();
    _overridePriceController.dispose();
    _overrideDurationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final isEditing = widget.package != null;
    final filteredCategories = widget.categories;
    final filteredServices = widget.services;

    return LocalLoadingOverlay(
      isLoading: _isSaving,
      child: AppFormDialog(
        title: Text(
          isEditing ? l10n.servicePackageEditTitle : l10n.servicePackageNewTitle,
        ),
        contentPadding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
        content: Form(
          key: _formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              LabeledFormField(
                label: l10n.servicePackageNameLabel,
                child: TextFormField(
                  controller: _nameController,
                  textInputAction: TextInputAction.next,
                  decoration: const InputDecoration(
                    border: OutlineInputBorder(),
                  ),
                  validator: (value) =>
                      value == null || value.trim().isEmpty
                          ? l10n.validationRequired
                          : null,
                ),
              ),
              const SizedBox(height: 16),
              LabeledFormField(
                label: l10n.fieldCategoryRequiredLabel,
                child: DropdownButtonFormField<int>(
                  value: _selectedCategoryId,
                  decoration: const InputDecoration(
                    border: OutlineInputBorder(),
                  ),
                  items: [
                    for (final category in widget.categories)
                      DropdownMenuItem(
                        value: category.id,
                        child: Text(category.name),
                      ),
                  ],
                  onChanged: (value) {
                    setState(() {
                      _selectedCategoryId = value;
                      _servicesError = null;
                    });
                  },
                  validator: (value) =>
                      value == null ? l10n.validationRequired : null,
                ),
              ),
              const SizedBox(height: 16),
              LabeledFormField(
                label: l10n.servicePackageDescriptionLabel,
                child: TextFormField(
                  controller: _descriptionController,
                  maxLines: 3,
                  decoration: const InputDecoration(
                    border: OutlineInputBorder(),
                  ),
                ),
              ),
              const SizedBox(height: 16),
              Row(
                children: [
                  Expanded(
                    child: LabeledFormField(
                      label: l10n.servicePackageOverridePriceLabel,
                      child: TextFormField(
                        controller: _overridePriceController,
                        keyboardType: const TextInputType.numberWithOptions(
                          decimal: true,
                        ),
                        inputFormatters: [
                          FilteringTextInputFormatter.allow(
                            RegExp(r'[0-9.,]'),
                          ),
                        ],
                        decoration: const InputDecoration(
                          border: OutlineInputBorder(),
                        ),
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return null;
                          }
                          final parsed = PriceFormatter.parse(value);
                          if (parsed == null) {
                            return l10n.validationInvalidNumber;
                          }
                          return null;
                        },
                      ),
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: LabeledFormField(
                      label: l10n.servicePackageOverrideDurationLabel,
                      child: TextFormField(
                        controller: _overrideDurationController,
                        keyboardType: TextInputType.number,
                        inputFormatters: [
                          FilteringTextInputFormatter.digitsOnly,
                        ],
                        decoration: const InputDecoration(
                          border: OutlineInputBorder(),
                        ),
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return null;
                          }
                          final parsed = int.tryParse(value);
                          if (parsed == null) {
                            return l10n.validationInvalidNumber;
                          }
                          return null;
                        },
                      ),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              SwitchListTile(
                value: _isActive,
                onChanged: (value) => setState(() => _isActive = value),
                title: Text(l10n.servicePackageActiveLabel),
              ),
              const SizedBox(height: 12),
              Text(
                l10n.servicePackageServicesLabel,
                style: const TextStyle(fontWeight: FontWeight.w600),
              ),
              const SizedBox(height: 8),
              SizedBox(
                height: 240,
                child: DecoratedBox(
                  decoration: BoxDecoration(
                    border: Border.all(
                      color: Theme.of(context).dividerColor,
                    ),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: ClipRRect(
                    borderRadius: BorderRadius.circular(12),
                    child: SingleChildScrollView(
                      child: ServiceEligibilitySelector(
                        services: filteredServices,
                        categories: filteredCategories,
                        selectedServiceIds: _selectedServiceIds,
                        onChanged: _onServiceSelectionChanged,
                        showSelectAll: false,
                      ),
                    ),
                  ),
                ),
              ),
              if (_servicesError != null) ...[
                const SizedBox(height: 8),
                Text(
                  _servicesError!,
                  style: TextStyle(
                    color: Theme.of(context).colorScheme.error,
                  ),
                ),
              ],
              const SizedBox(height: 16),
              Text(
                l10n.servicePackageOrderLabel,
                style: const TextStyle(fontWeight: FontWeight.w600),
              ),
              const SizedBox(height: 8),
              _buildOrderList(context, widget.services),
              const SizedBox(height: 24),
            ],
          ),
        ),
        actions: [
          if (isEditing)
            SizedBox(
              width: AppButtonStyles.dialogButtonWidth,
              child: AppOutlinedActionButton(
                onPressed: _isSaving
                    ? null
                    : () => _confirmDelete(context, l10n),
                foregroundColor: Theme.of(context).colorScheme.error,
                child: Text(l10n.actionDelete),
              ),
            ),
          SizedBox(
            width: AppButtonStyles.dialogButtonWidth,
            child: AppOutlinedActionButton(
              onPressed: () => Navigator.of(context, rootNavigator: true).pop(),
              child: Text(l10n.actionCancel),
            ),
          ),
          SizedBox(
            width: AppButtonStyles.dialogButtonWidth,
            child: AppFilledButton(
              onPressed: _isSaving ? null : _onSave,
              child: Text(l10n.actionSave),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildOrderList(BuildContext context, List<Service> services) {
    if (_orderedServiceIds.isEmpty) {
      return Text(
        context.l10n.servicePackageNoServices,
        style: Theme.of(context).textTheme.bodySmall,
      );
    }

    final serviceMap = {for (final s in services) s.id: s};

    return SizedBox(
      height: 220,
      child: ReorderableListView.builder(
        physics: const ClampingScrollPhysics(),
        onReorder: (oldIndex, newIndex) {
          setState(() {
            if (newIndex > oldIndex) newIndex -= 1;
            final moved = _orderedServiceIds.removeAt(oldIndex);
            _orderedServiceIds.insert(newIndex, moved);
          });
        },
        itemCount: _orderedServiceIds.length,
        itemBuilder: (context, index) {
          final serviceId = _orderedServiceIds[index];
          final serviceName = serviceMap[serviceId]?.name ?? '#$serviceId';
          return ListTile(
            key: ValueKey('pkg-$serviceId'),
            title: Text(serviceName),
            leading: const Icon(Icons.drag_indicator),
          );
        },
      ),
    );
  }

  void _confirmDelete(BuildContext context, l10n) {
    final packageId = widget.package?.id;
    if (packageId == null) return;
    showAppConfirmDialog(
      context,
      title: Text(l10n.servicePackageDeleteTitle),
      content: Text(l10n.servicePackageDeleteMessage),
      confirmLabel: l10n.actionDelete,
      cancelLabel: l10n.actionCancel,
      danger: true,
      onConfirm: () async {
        try {
          if (mounted) {
            setState(() => _isSaving = true);
          }
          await ref.read(servicePackagesProvider.notifier).deletePackage(
                packageId,
              );
          if (!context.mounted) return;
          await FeedbackDialog.showSuccess(
            context,
            title: l10n.servicePackageDeletedTitle,
            message: l10n.servicePackageDeletedMessage,
          );
          if (context.mounted) {
            Navigator.of(context, rootNavigator: true).pop();
          }
        } catch (_) {
          if (!context.mounted) return;
          await FeedbackDialog.showError(
            context,
            title: l10n.errorTitle,
            message: l10n.servicePackageDeleteError,
          );
        } finally {
          if (mounted) {
            setState(() => _isSaving = false);
          }
        }
      },
    );
  }

  void _onServiceSelectionChanged(Set<int> selected) {
    setState(() {
      final nextOrder = <int>[];
      for (final id in _orderedServiceIds) {
        if (selected.contains(id)) {
          nextOrder.add(id);
        }
      }
      for (final id in selected) {
        if (!nextOrder.contains(id)) {
          nextOrder.add(id);
        }
      }
      _orderedServiceIds = nextOrder;
      _servicesError = null;
    });
  }

  Future<void> _onSave() async {
    final l10n = context.l10n;
    final formValid = _formKey.currentState?.validate() ?? false;

    if (!formValid) return;
    if (_selectedCategoryId == null) return;
    if (_orderedServiceIds.isEmpty) {
      setState(() {
        _servicesError = l10n.servicePackageServicesRequired;
      });
      return;
    }

    final overridePriceText = _overridePriceController.text.trim();
    final overrideDurationText = _overrideDurationController.text.trim();

    final overridePrice = overridePriceText.isEmpty
        ? null
        : PriceFormatter.parse(overridePriceText);
    final overrideDuration = overrideDurationText.isEmpty
        ? null
        : int.tryParse(overrideDurationText);

    setState(() => _isSaving = true);

    try {
      final notifier = ref.read(servicePackagesProvider.notifier);
      if (widget.package == null) {
        await notifier.createPackage(
          name: _nameController.text.trim(),
          categoryId: _selectedCategoryId!,
          description: _descriptionController.text.trim().isEmpty
              ? null
              : _descriptionController.text.trim(),
          serviceIds: _orderedServiceIds,
          overridePrice: overridePrice,
          overrideDurationMinutes: overrideDuration,
          isActive: _isActive,
        );
        if (mounted) {
          setState(() => _isSaving = false);
          await FeedbackDialog.showSuccess(
            context,
            title: l10n.servicePackageCreatedTitle,
            message: l10n.servicePackageCreatedMessage,
          );
        }
      } else {
        await notifier.updatePackage(
          packageId: widget.package!.id,
          name: _nameController.text.trim(),
          categoryId: _selectedCategoryId,
          description: _descriptionController.text.trim().isEmpty
              ? null
              : _descriptionController.text.trim(),
          serviceIds: _orderedServiceIds,
          overridePrice: overridePrice,
          overrideDurationMinutes: overrideDuration,
          setOverridePriceNull: overridePriceText.isEmpty,
          setOverrideDurationNull: overrideDurationText.isEmpty,
          isActive: _isActive,
        );
        if (mounted) {
          setState(() => _isSaving = false);
          await FeedbackDialog.showSuccess(
            context,
            title: l10n.servicePackageUpdatedTitle,
            message: l10n.servicePackageUpdatedMessage,
          );
        }
      }

      if (mounted) {
        Navigator.of(context, rootNavigator: true).pop();
      }
    } catch (_) {
      if (mounted) {
        setState(() => _isSaving = false);
        await FeedbackDialog.showError(
          context,
          title: l10n.errorTitle,
          message: l10n.servicePackageSaveError,
        );
      }
    }
  }
}
--- FILE: lib/features/services/presentation/dialogs/service_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:agenda_backend/features/agenda/providers/location_providers.dart';
import 'package:agenda_backend/features/agenda/providers/resource_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/resource.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_variant.dart';
import '../../../../core/network/network_providers.dart';
import '../../../../core/utils/color_utils.dart';
import '../../../../core/utils/price_utils.dart';
import '../../../../core/utils/string_utils.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/app_switch.dart';
import '../../../../core/widgets/labeled_form_field.dart';
import '../../../../core/widgets/local_loading_overlay.dart';
import '../../../agenda/providers/business_providers.dart';
import '../../../auth/providers/current_business_user_provider.dart';
import '../../../staff/providers/staff_providers.dart';
import '../../providers/service_categories_provider.dart';
import '../../providers/services_provider.dart';
import '../../utils/service_seed_texts.dart';
import '../../utils/service_validators.dart';

bool _mapEquals<K, V>(Map<K, V> a, Map<K, V> b) {
  if (a.length != b.length) return false;
  for (final key in a.keys) {
    if (!b.containsKey(key) || a[key] != b[key]) return false;
  }
  return true;
}

bool _setEquals<T>(Set<T> a, Set<T> b) {
  if (a.length != b.length) return false;
  return a.containsAll(b) && b.containsAll(a);
}

enum _AdditionalTimeSelection { none, processing, blocked }

// Palette originale mantenuta per utilizzo futuro.
const List<Color> serviceColorPaletteLegacy = [
  // Reds
  Color(0xFFFFCDD2),
  Color(0xFFFFC1C9),
  Color(0xFFFFB4BC),
  // Oranges
  Color(0xFFFFD6B3),
  Color(0xFFFFC9A3),
  Color(0xFFFFBD93),
  // Yellows
  Color(0xFFFFF0B3),
  Color(0xFFFFE6A3),
  Color(0xFFFFDC93),
  // Yellow-greens
  Color(0xFFEAF2B3),
  Color(0xFFDFEAA3),
  Color(0xFFD4E293),
  // Greens
  Color(0xFFCDECCF),
  Color(0xFFC1E4C4),
  Color(0xFFB6DCB9),
  // Teals
  Color(0xFFBFE8E0),
  Color(0xFFB1DFD6),
  Color(0xFFA3D6CB),
  // Cyans
  Color(0xFFBDEFF4),
  Color(0xFFB0E6EF),
  Color(0xFFA3DDEA),
  // Blues
  Color(0xFFBFD9FF),
  Color(0xFFB0CEFF),
  Color(0xFFA1C3FF),
  // Indigos
  Color(0xFFC7D0FF),
  Color(0xFFBAC4FF),
  Color(0xFFADB8FF),
  // Purples
  Color(0xFFDCC9FF),
  Color(0xFFD0BDFF),
  Color(0xFFC4B1FF),
  // Pinks
  Color(0xFFFFC7E3),
  Color(0xFFFFB7D9),
  Color(0xFFFFA8CF),
];

// Palette attiva leggermente pi√π scura per migliorare contrasto nelle card.
const List<Color> serviceColorPaletteEnhanced = [
  // Reds
  Color(0xFFFFB7BC),
  Color(0xFFFFADB5),
  Color(0xFFFFA2AA),
  // Oranges
  Color(0xFFFFC29D),
  Color(0xFFFFB58F),
  Color(0xFFFFAA81),
  // Yellows
  Color(0xFFFFDB9F),
  Color(0xFFFFD290),
  Color(0xFFFFC87F),
  // Yellow-greens
  Color(0xFFD3DA9F),
  Color(0xFFCBD690),
  Color(0xFFC2CE81),
  // Greens
  Color(0xFFB8D8BB),
  Color(0xFFAED0B1),
  Color(0xFFA0C8A6),
  // Teals
  Color(0xFFAAD3CC),
  Color(0xFF9DCCC2),
  Color(0xFF8FC0B5),
  // Cyans
  Color(0xFFA7D9DF),
  Color(0xFF9CD2DB),
  Color(0xFF8EC8D5),
  // Blues
  Color(0xFFAAC4EA),
  Color(0xFF9CB8EA),
  Color(0xFF8EAFE9),
  // Indigos
  Color(0xFFB2BBEA),
  Color(0xFFA6B0EA),
  Color(0xFF99A4E9),
  // Purples
  Color(0xFFC6B4EA),
  Color(0xFFBAA9EA),
  Color(0xFFAE9DE9),
  // Pinks
  Color(0xFFEAB2CE),
  Color(0xFFEAA4C5),
  Color(0xFFE994BB),
];

List<Color> _paletteForBusinessSetting(String setting) {
  switch (setting) {
    case 'enhanced':
      return serviceColorPaletteEnhanced;
    case 'legacy':
    default:
      return serviceColorPaletteLegacy;
  }
}

Color _contrastFor(Color color) {
  return color.computeLuminance() > 0.5 ? Colors.black : Colors.white;
}

class _SwitchTile extends StatelessWidget {
  const _SwitchTile({
    required this.title,
    this.subtitle,
    required this.value,
    required this.onChanged,
    this.enabled = true,
  });

  final String title;
  final String? subtitle;
  final bool value;
  final ValueChanged<bool>? onChanged;
  final bool enabled;

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final baseColor = textTheme.bodyLarge?.color;
    final titleStyle = enabled
        ? textTheme.bodyLarge
        : textTheme.bodyLarge?.copyWith(color: baseColor?.withOpacity(0.6));
    final subtitleStyle = enabled
        ? textTheme.bodyMedium
        : textTheme.bodyMedium?.copyWith(color: baseColor?.withOpacity(0.6));

    return MergeSemantics(
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: enabled && onChanged != null ? () => onChanged!(!value) : null,
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 8.0),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(title, style: titleStyle),
                    if (subtitle != null)
                      Padding(
                        padding: const EdgeInsets.only(top: 2.0),
                        child: Text(subtitle!, style: subtitleStyle),
                      ),
                  ],
                ),
              ),
              AppSwitch(value: value, onChanged: enabled ? onChanged : null),
            ],
          ),
        ),
      ),
    );
  }
}

class _SelectableRow extends StatelessWidget {
  const _SelectableRow({
    required this.label,
    required this.selected,
    required this.onTap,
  });

  final String label;
  final bool selected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          child: Row(
            children: [
              Expanded(child: Text(label)),
              if (selected)
                Icon(
                  Icons.check,
                  color: Theme.of(context).colorScheme.primary,
                  size: 20,
                ),
            ],
          ),
        ),
      ),
    );
  }
}

class _ResourceQuantityRow extends StatelessWidget {
  const _ResourceQuantityRow({
    required this.resource,
    required this.quantity,
    required this.onQuantityChanged,
    required this.colorScheme,
    required this.textTheme,
    required this.l10n,
  });

  final Resource resource;
  final int quantity;
  final ValueChanged<int> onQuantityChanged;
  final ColorScheme colorScheme;
  final TextTheme textTheme;
  final dynamic l10n;

  @override
  Widget build(BuildContext context) {
    final isSelected = quantity > 0;
    final maxQuantity = resource.quantity;

    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: () {
          // Toggle selezione: se non selezionato, imposta 1; se selezionato, rimuovi
          onQuantityChanged(isSelected ? 0 : 1);
        },
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
          child: Row(
            children: [
              // Checkbox visiva
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  color: isSelected ? colorScheme.primary : Colors.transparent,
                  border: Border.all(
                    color: isSelected
                        ? colorScheme.primary
                        : colorScheme.outline,
                    width: 2,
                  ),
                  borderRadius: BorderRadius.circular(4),
                ),
                child: isSelected
                    ? Icon(Icons.check, size: 16, color: colorScheme.onPrimary)
                    : null,
              ),
              const SizedBox(width: 12),
              // Nome risorsa e quantit√† disponibile
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(resource.name, style: textTheme.bodyLarge),
                    Text(
                      '${l10n.resourceQuantityLabel}: ${resource.quantity}',
                      style: textTheme.bodySmall?.copyWith(
                        color: colorScheme.outline,
                      ),
                    ),
                  ],
                ),
              ),
              // Selettore quantit√† (visibile solo se selezionato E la risorsa ha pi√π di 1 unit√†)
              if (isSelected && maxQuantity > 1) ...[
                const SizedBox(width: 8),
                GestureDetector(
                  // Impedisce la propagazione del tap all'InkWell esterno
                  onTap: () {},
                  child: Container(
                    decoration: BoxDecoration(
                      color: colorScheme.surfaceContainerHighest,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        // Pulsante -
                        IconButton(
                          onPressed: quantity > 1
                              ? () => onQuantityChanged(quantity - 1)
                              : null,
                          icon: const Icon(Icons.remove, size: 18),
                          padding: const EdgeInsets.all(4),
                          constraints: const BoxConstraints(
                            minWidth: 32,
                            minHeight: 32,
                          ),
                          color: colorScheme.primary,
                          disabledColor: colorScheme.outline.withOpacity(0.5),
                        ),
                        // Quantit√†
                        Container(
                          constraints: const BoxConstraints(minWidth: 32),
                          alignment: Alignment.center,
                          child: Text(
                            '$quantity',
                            style: textTheme.titleMedium?.copyWith(
                              fontWeight: FontWeight.bold,
                              color: colorScheme.primary,
                            ),
                          ),
                        ),
                        // Pulsante +
                        IconButton(
                          onPressed: quantity < maxQuantity
                              ? () => onQuantityChanged(quantity + 1)
                              : null,
                          icon: const Icon(Icons.add, size: 18),
                          padding: const EdgeInsets.all(4),
                          constraints: const BoxConstraints(
                            minWidth: 32,
                            minHeight: 32,
                          ),
                          color: colorScheme.primary,
                          disabledColor: colorScheme.outline.withOpacity(0.5),
                        ),
                      ],
                    ),
                  ),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }
}

Future<void> showServiceDialog(
  BuildContext context,
  WidgetRef ref, {
  Service? service,
  int? preselectedCategoryId,
  Color? preselectedColor,
  bool requireCategorySelection = false,
  bool duplicateFrom = false,
  bool readOnly = false,
}) async {
  if (!ref.read(currentUserCanManageServicesProvider) && !readOnly) return;
  final canEditDialog = !readOnly;
  final notifier = ref.read(servicesProvider.notifier);
  final allServices = ref.read(servicesProvider).value ?? [];
  final categories = ref.read(serviceCategoriesProvider);
  final isEditing = service != null && !duplicateFrom;
  final existingVariant = service != null
      ? ref.read(serviceVariantByServiceIdProvider(service.id))
      : null;
  final currencyCode = ref.read(effectiveCurrencyProvider);
  final currencySymbol = NumberFormat.currency(
    name: currencyCode,
  ).currencySymbol;
  final isDesktop = ref.read(formFactorProvider) == AppFormFactor.desktop;

  String makeDuplicateName(String originalName) {
    final copyWord = ServiceSeedTexts.duplicateCopyWord;
    final copyWordEscaped = RegExp.escape(copyWord);
    String base = originalName;
    int? startFrom;

    final reNew = RegExp(
      '^(.*?)(?:\\s$copyWordEscaped(?:\\s(\\d+))?)\$',
      caseSensitive: false,
    );
    final reOld = RegExp(
      '^(.*?)(?:\\s\\((?:$copyWordEscaped)(?:\\s(\\d+))?\\))\$',
      caseSensitive: false,
    );

    final match =
        reNew.firstMatch(originalName) ?? reOld.firstMatch(originalName);
    if (match != null) {
      base = (match.group(1) ?? '').trim();
      final n = match.group(2);
      if (n != null) {
        final parsed = int.tryParse(n);
        if (parsed != null) startFrom = parsed + 1;
      } else {
        startFrom = 1;
      }
    }

    final existingNames = allServices.map((s) => s.name).toSet();
    String candidate = '$base $copyWord';
    if (!existingNames.contains(candidate)) return candidate;

    int i = startFrom ?? 1;
    while (true) {
      candidate = '$base $copyWord $i';
      if (!existingNames.contains(candidate)) return candidate;
      i++;
      if (i > 9999) break;
    }
    return '$base $copyWord';
  }

  final nameController = TextEditingController(
    text: (duplicateFrom && service != null)
        ? makeDuplicateName(service.name)
        : (service?.name ?? ''),
  );
  final priceController = TextEditingController(
    text: (existingVariant != null && existingVariant.price > 0)
        ? PriceFormatter.format(
            context: context,
            amount: existingVariant.price,
            currencyCode: existingVariant.currency ?? currencyCode,
          )
        : '',
  );
  final descController = TextEditingController(
    text: service?.description ?? '',
  );
  final staffList = ref.read(staffForCurrentLocationProvider);
  final staffNotifier = ref.read(allStaffProvider.notifier);
  final eligibilityNotifier = ref.read(
    serviceStaffEligibilityProvider.notifier,
  );
  final locationId = ref.read(currentLocationProvider).id;
  final originalStaffIds = service != null
      ? ref.read(eligibleStaffForServiceProvider(service.id)).toSet()
      : <int>{};
  Set<int> selectedStaffIds = {...originalStaffIds};
  bool isSelectingStaff = false;

  // Location selection
  final allLocations = ref.read(locationsProvider);
  final hasMultipleLocations = allLocations.length > 1;
  // In creazione: seleziona location corrente di default
  // In modifica: carica le location dal server
  Set<int> selectedLocationIds = {locationId};
  Set<int> originalLocationIds = {locationId}; // Per confrontare le modifiche
  bool isSelectingLocations = false;
  bool isLoadingLocations = isEditing; // Se editing, mostra loading iniziale

  // Risorse richieste (Map: resourceId -> quantity)
  final locationResources = ref.read(locationResourcesProvider(locationId));
  final existingResourceRequirements =
      existingVariant?.resourceRequirements ?? const [];
  final originalResourceQuantities = <int, int>{
    for (final r in existingResourceRequirements) r.resourceId: r.unitsRequired,
  };
  Map<int, int> selectedResourceQuantities = {...originalResourceQuantities};
  bool isSelectingResources = false;

  int? selectedCategory = requireCategorySelection
      ? (service?.categoryId ?? preselectedCategoryId)
      : (service?.categoryId ?? preselectedCategoryId ?? categories.first.id);
  int? selectedDuration = existingVariant?.durationMinutes;
  int selectedProcessingTime = existingVariant?.processingTime ?? 0;
  int selectedBlockedTime = existingVariant?.blockedTime ?? 0;
  final businessPaletteSetting = ref
      .read(currentBusinessProvider)
      .serviceColorPalette;
  final palette = <Color>[
    ..._paletteForBusinessSetting(businessPaletteSetting),
  ];
  final seen = <int>{};
  final uniquePalette = <Color>[
    for (final c in palette)
      if (seen.add(c.value)) c,
  ];
  final serviceColor = existingVariant?.colorHex != null
      ? ColorUtils.fromHex(existingVariant!.colorHex!)
      : null;
  final hasPreselectedColor =
      preselectedColor != null &&
      uniquePalette.any((c) => c.value == preselectedColor.value);
  final hasServiceColor =
      serviceColor != null &&
      uniquePalette.any((c) => c.value == serviceColor.value);
  Color selectedColor = hasServiceColor
      ? serviceColor
      : (hasPreselectedColor ? preselectedColor : uniquePalette.first);

  if (selectedProcessingTime > 0 && selectedBlockedTime > 0) {
    selectedBlockedTime = 0;
  }

  _AdditionalTimeSelection additionalSelection = selectedProcessingTime > 0
      ? _AdditionalTimeSelection.processing
      : (selectedBlockedTime > 0
            ? _AdditionalTimeSelection.blocked
            : _AdditionalTimeSelection.none);
  int additionalMinutes = selectedProcessingTime > 0
      ? selectedProcessingTime
      : selectedBlockedTime;

  bool isBookableOnline = existingVariant?.isBookableOnline ?? true;
  bool isFree = existingVariant?.isFree ?? false;
  bool isPriceStartingFrom = existingVariant?.isPriceStartingFrom ?? false;

  bool nameError = false;
  bool durationError = false;
  bool categoryError = false;
  bool isSaving = false;

  Future<void> handleSave() async {
    if (!ref.read(currentUserCanManageServicesProvider)) return;
    final name = nameController.text.trim();
    if (name.isEmpty) {
      nameError = true;
      return;
    }
    final normalizedName = StringUtils.toTitleCase(name);
    final isDuplicate = ServiceValidators.isDuplicateServiceName(
      allServices,
      normalizedName,
      excludeId: isEditing ? service.id : null,
    );
    if (selectedDuration == null) {
      durationError = true;
      return;
    }
    if (selectedCategory == null) {
      categoryError = true;
      return;
    }

    final parsedPrice = PriceFormatter.parse(priceController.text);
    final effectiveIsFree = isFree;
    final double? finalPrice = effectiveIsFree ? null : parsedPrice;
    final bool finalIsPriceStartingFrom =
        (effectiveIsFree || finalPrice == null) ? false : isPriceStartingFrom;

    Future<void> doSave() async {
      int processingToSave = 0;
      int blockedToSave = 0;
      if (additionalSelection == _AdditionalTimeSelection.processing &&
          additionalMinutes > 0) {
        processingToSave = additionalMinutes;
      } else if (additionalSelection == _AdditionalTimeSelection.blocked &&
          additionalMinutes > 0) {
        blockedToSave = additionalMinutes;
      }

      Service? savedService;

      if (!isEditing) {
        // Create new service via API - use multi-location if multiple selected
        if (selectedLocationIds.length > 1) {
          savedService = await notifier.createServiceMultiLocationApi(
            locationIds: selectedLocationIds.toList(),
            name: normalizedName,
            categoryId: selectedCategory!,
            description: descController.text.trim().isEmpty
                ? null
                : descController.text.trim(),
            durationMinutes: selectedDuration!,
            price: finalPrice ?? 0,
            colorHex: ColorUtils.toHex(selectedColor),
            isBookableOnline: isBookableOnline,
            isPriceStartingFrom: finalIsPriceStartingFrom,
            processingTime: processingToSave > 0 ? processingToSave : null,
            blockedTime: blockedToSave > 0 ? blockedToSave : null,
          );
        } else {
          // Single location - use standard API
          savedService = await notifier.createServiceApi(
            name: normalizedName,
            categoryId: selectedCategory!,
            description: descController.text.trim().isEmpty
                ? null
                : descController.text.trim(),
            durationMinutes: selectedDuration!,
            price: finalPrice ?? 0,
            colorHex: ColorUtils.toHex(selectedColor),
            isBookableOnline: isBookableOnline,
            isPriceStartingFrom: finalIsPriceStartingFrom,
            processingTime: processingToSave > 0 ? processingToSave : null,
            blockedTime: blockedToSave > 0 ? blockedToSave : null,
          );
        }
      } else {
        // Update existing service via API
        final descriptionText = descController.text.trim();
        final hadDescription =
            service.description != null && service.description!.isNotEmpty;
        final hasDescription = descriptionText.isNotEmpty;

        savedService = await notifier.updateServiceApi(
          serviceId: service.id,
          name: normalizedName,
          categoryId: selectedCategory!,
          description: hasDescription ? descriptionText : null,
          setDescriptionNull: hadDescription && !hasDescription,
          durationMinutes: selectedDuration!,
          price: finalPrice ?? 0,
          colorHex: ColorUtils.toHex(selectedColor),
          isBookableOnline: isBookableOnline,
          isPriceStartingFrom: finalIsPriceStartingFrom,
          processingTime: processingToSave,
          blockedTime: blockedToSave,
        );
      }

      if (savedService == null) {
        // API call failed, don't close dialog
        return;
      }

      // Update local variant for immediate UI feedback (variant is derived from service)
      final newVariant = ServiceVariant(
        id: isEditing
            ? (existingVariant?.id ?? (900000 + savedService.id))
            : (900000 + savedService.id),
        serviceId: savedService.id,
        locationId: ref.read(currentLocationProvider).id,
        durationMinutes: selectedDuration!,
        processingTime: processingToSave,
        blockedTime: blockedToSave,
        price: finalPrice ?? 0,
        colorHex: ColorUtils.toHex(selectedColor),
        currency: currencyCode,
        isBookableOnline: isBookableOnline,
        isFree: effectiveIsFree,
        isPriceStartingFrom: finalIsPriceStartingFrom,
        resourceRequirements: existingVariant?.resourceRequirements ?? const [],
      );

      ref.read(serviceVariantsProvider.notifier).upsert(newVariant);

      // Aggiorna le associazioni staff-servizio nel database
      // Calcola quali staff sono stati aggiunti/rimossi
      final addedStaffIds = selectedStaffIds.difference(originalStaffIds);
      final removedStaffIds = originalStaffIds.difference(selectedStaffIds);

      // Aggiorna ogni staff modificato nel database
      final allStaff = ref.read(allStaffProvider).value ?? [];
      final serviceId = savedService.id;
      for (final staffId in addedStaffIds) {
        final staff = allStaff.firstWhere((s) => s.id == staffId);
        final newServiceIds = {...staff.serviceIds, serviceId}.toList();
        await staffNotifier.updateStaffApi(
          staffId: staffId,
          serviceIds: newServiceIds,
        );
      }
      for (final staffId in removedStaffIds) {
        final staff = allStaff.firstWhere((s) => s.id == staffId);
        final newServiceIds = staff.serviceIds
            .where((id) => id != serviceId)
            .toList();
        await staffNotifier.updateStaffApi(
          staffId: staffId,
          serviceIds: newServiceIds,
        );
      }

      // Aggiorna anche lo stato locale UI
      eligibilityNotifier.setEligibleStaffForService(
        serviceId: savedService.id,
        locationId: locationId,
        staffIds: selectedStaffIds,
      );

      // Aggiorna le risorse richieste per il service variant
      final variantId = savedService.serviceVariantId;
      final resourcesChanged = !_mapEquals(
        selectedResourceQuantities,
        originalResourceQuantities,
      );
      if (variantId != null && resourcesChanged) {
        final apiClient = ref.read(apiClientProvider);
        final resourcesList = [
          for (final entry in selectedResourceQuantities.entries)
            {'resource_id': entry.key, 'quantity': entry.value},
        ];
        await apiClient.setServiceVariantResources(
          serviceVariantId: variantId,
          resources: resourcesList,
        );
      }

      // Aggiorna le sedi associate al servizio (solo se modificate)
      if (isEditing && hasMultipleLocations) {
        final locationsChanged = !_setEquals(
          selectedLocationIds,
          originalLocationIds,
        );
        if (locationsChanged) {
          await notifier.updateServiceLocationsApi(
            serviceId: savedService.id,
            locationIds: selectedLocationIds.toList(),
          );
        }
      }

      if (context.mounted) {
        Navigator.of(context, rootNavigator: true).pop();
      }
    }

    if (isDuplicate) {
      await showAppConfirmDialog(
        context,
        title: Text(context.l10n.serviceDuplicateError),
        confirmLabel: context.l10n.actionConfirm,
        cancelLabel: context.l10n.actionCancel,
        danger: false,
        onConfirm: doSave,
      );
    } else {
      await doSave();
    }
  }

  Widget buildBody(BuildContext context, void Function(VoidCallback) setState) {
    Future<void> openStaffSelector() async {
      if (isSelectingStaff) return;
      setState(() => isSelectingStaff = true);
      final l10n = context.l10n;
      final formFactor = ref.read(formFactorProvider);
      Set<int> current = {...selectedStaffIds};

      Widget buildStaffRows(void Function(VoidCallback) setStateLocal) {
        final allIds = [for (final s in staffList) s.id];
        final allSelected = allIds.isNotEmpty && allIds.every(current.contains);
        return Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            _SelectableRow(
              label: l10n.teamSelectAllServices,
              selected: allSelected,
              onTap: canEditDialog
                  ? () {
                      if (allSelected) {
                        current.clear();
                      } else {
                        current
                          ..clear()
                          ..addAll(allIds);
                      }
                      setStateLocal(() {});
                    }
                  : () {},
            ),
            const Divider(height: 1),
            for (final member in staffList)
              _SelectableRow(
                label: member.displayName,
                selected: current.contains(member.id),
                onTap: canEditDialog
                    ? () {
                        if (current.contains(member.id)) {
                          current.remove(member.id);
                        } else {
                          current.add(member.id);
                        }
                        setStateLocal(() {});
                      }
                    : () {},
              ),
          ],
        );
      }

      Future<void> openDialog(BuildContext ctx) async {
        await showDialog<void>(
          context: ctx,
          builder: (dialogCtx) => StatefulBuilder(
            builder: (context, setStateLocal) {
              return Dialog(
                insetPadding: const EdgeInsets.symmetric(
                  horizontal: 32,
                  vertical: 24,
                ),
                child: ConstrainedBox(
                  constraints: const BoxConstraints(
                    minWidth: 520,
                    maxWidth: 680,
                    maxHeight: 520,
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      Padding(
                        padding: const EdgeInsets.fromLTRB(20, 16, 20, 8),
                        child: Text(
                          l10n.teamEligibleStaffLabel,
                          style: Theme.of(context).textTheme.titleLarge,
                        ),
                      ),
                      const Divider(height: 1),
                      Expanded(
                        child: SingleChildScrollView(
                          child: buildStaffRows(setStateLocal),
                        ),
                      ),
                      const Divider(height: 1),
                      Padding(
                        padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                        child: Align(
                          alignment: Alignment.centerRight,
                          child: AppFilledButton(
                            onPressed: () => Navigator.of(dialogCtx).pop(),
                            padding: AppButtonStyles.dialogButtonPadding,
                            child: Text(
                              canEditDialog
                                  ? l10n.actionConfirm
                                  : l10n.actionClose,
                            ),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        );
      }

      Future<void> openSheet(BuildContext ctx) async {
        await AppBottomSheet.show<void>(
          context: ctx,
          heightFactor: AppBottomSheet.defaultHeightFactor,
          padding: EdgeInsets.zero,
          builder: (sheetCtx) => StatefulBuilder(
            builder: (context, setStateLocal) {
              return SafeArea(
                top: false,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
                      child: Text(
                        l10n.teamEligibleStaffLabel,
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                    ),
                    const Divider(height: 1),
                    Expanded(
                      child: SingleChildScrollView(
                        child: buildStaffRows(setStateLocal),
                      ),
                    ),
                    const Divider(height: 1),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                      child: Align(
                        alignment: Alignment.centerRight,
                        child: AppFilledButton(
                          onPressed: () => Navigator.of(sheetCtx).pop(),
                          padding: AppButtonStyles.dialogButtonPadding,
                          child: Text(
                            canEditDialog
                                ? l10n.actionConfirm
                                : l10n.actionClose,
                          ),
                        ),
                      ),
                    ),
                    SizedBox(height: MediaQuery.of(ctx).viewPadding.bottom),
                  ],
                ),
              );
            },
          ),
        );
      }

      if (formFactor == AppFormFactor.desktop) {
        await openDialog(context);
      } else {
        await openSheet(context);
      }

      setState(() {
        if (canEditDialog) {
          selectedStaffIds = {...current};
        }
        isSelectingStaff = false;
      });
    }

    Future<void> openLocationSelector() async {
      if (isSelectingLocations) return;
      setState(() => isSelectingLocations = true);
      final l10n = context.l10n;
      final formFactor = ref.read(formFactorProvider);
      Set<int> current = {...selectedLocationIds};

      Widget buildLocationRows(void Function(VoidCallback) setStateLocal) {
        final allIds = [for (final loc in allLocations) loc.id];
        final allSelected = allIds.isNotEmpty && allIds.every(current.contains);
        return Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            _SelectableRow(
              label: l10n.teamSelectAllServices, // "Seleziona tutti"
              selected: allSelected,
              onTap: () {
                if (allSelected) {
                  // Deseleziona tutti tranne la location corrente
                  current.clear();
                  current.add(locationId);
                } else {
                  current
                    ..clear()
                    ..addAll(allIds);
                }
                setStateLocal(() {});
              },
            ),
            const Divider(height: 1),
            for (final loc in allLocations)
              _SelectableRow(
                label: loc.name,
                selected: current.contains(loc.id),
                onTap: () {
                  if (current.contains(loc.id)) {
                    // Non permettere di deselezionare tutte le location
                    if (current.length > 1) {
                      current.remove(loc.id);
                    }
                  } else {
                    current.add(loc.id);
                  }
                  setStateLocal(() {});
                },
              ),
          ],
        );
      }

      Future<void> openLocDialog(BuildContext ctx) async {
        await showDialog<void>(
          context: ctx,
          builder: (dialogCtx) => StatefulBuilder(
            builder: (context, setStateLocal) {
              return Dialog(
                insetPadding: const EdgeInsets.symmetric(
                  horizontal: 32,
                  vertical: 24,
                ),
                child: ConstrainedBox(
                  constraints: const BoxConstraints(
                    minWidth: 520,
                    maxWidth: 680,
                    maxHeight: 520,
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      Padding(
                        padding: const EdgeInsets.fromLTRB(20, 16, 20, 8),
                        child: Text(
                          l10n.serviceLocationsLabel,
                          style: Theme.of(context).textTheme.titleLarge,
                        ),
                      ),
                      const Divider(height: 1),
                      Expanded(
                        child: SingleChildScrollView(
                          child: buildLocationRows(setStateLocal),
                        ),
                      ),
                      const Divider(height: 1),
                      Padding(
                        padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                        child: Align(
                          alignment: Alignment.centerRight,
                          child: AppFilledButton(
                            onPressed: () => Navigator.of(dialogCtx).pop(),
                            padding: AppButtonStyles.dialogButtonPadding,
                            child: Text(l10n.actionConfirm),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        );
      }

      Future<void> openLocSheet(BuildContext ctx) async {
        await AppBottomSheet.show<void>(
          context: ctx,
          heightFactor: AppBottomSheet.defaultHeightFactor,
          padding: EdgeInsets.zero,
          builder: (sheetCtx) => StatefulBuilder(
            builder: (context, setStateLocal) {
              return SafeArea(
                top: false,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
                      child: Text(
                        l10n.serviceLocationsLabel,
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                    ),
                    const Divider(height: 1),
                    Expanded(
                      child: SingleChildScrollView(
                        child: buildLocationRows(setStateLocal),
                      ),
                    ),
                    const Divider(height: 1),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                      child: Align(
                        alignment: Alignment.centerRight,
                        child: AppFilledButton(
                          onPressed: () => Navigator.of(sheetCtx).pop(),
                          padding: AppButtonStyles.dialogButtonPadding,
                          child: Text(l10n.actionConfirm),
                        ),
                      ),
                    ),
                    SizedBox(height: MediaQuery.of(ctx).viewPadding.bottom),
                  ],
                ),
              );
            },
          ),
        );
      }

      if (formFactor == AppFormFactor.desktop) {
        await openLocDialog(context);
      } else {
        await openLocSheet(context);
      }

      setState(() {
        selectedLocationIds = {...current};
        isSelectingLocations = false;
      });
    }

    Future<void> openResourceSelector() async {
      if (isSelectingResources) return;
      setState(() => isSelectingResources = true);
      final l10n = context.l10n;
      final formFactor = ref.read(formFactorProvider);
      Map<int, int> current = {...selectedResourceQuantities};

      Widget buildResourceRows(void Function(VoidCallback) setStateLocal) {
        if (locationResources.isEmpty) {
          return Padding(
            padding: const EdgeInsets.all(24),
            child: Text(
              l10n.resourceNoneLabel,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).textTheme.bodySmall?.color,
              ),
            ),
          );
        }
        final colorScheme = Theme.of(context).colorScheme;
        final textTheme = Theme.of(context).textTheme;
        return Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            for (final resource in locationResources)
              _ResourceQuantityRow(
                resource: resource,
                quantity: current[resource.id] ?? 0,
                onQuantityChanged: (qty) {
                  if (qty == 0) {
                    current.remove(resource.id);
                  } else {
                    current[resource.id] = qty;
                  }
                  setStateLocal(() {});
                },
                colorScheme: colorScheme,
                textTheme: textTheme,
                l10n: l10n,
              ),
          ],
        );
      }

      Future<void> openResourceDialog(BuildContext ctx) async {
        await showDialog<void>(
          context: ctx,
          builder: (dialogCtx) => StatefulBuilder(
            builder: (context, setStateLocal) {
              return Dialog(
                insetPadding: const EdgeInsets.symmetric(
                  horizontal: 32,
                  vertical: 24,
                ),
                child: ConstrainedBox(
                  constraints: const BoxConstraints(
                    minWidth: 520,
                    maxWidth: 680,
                    maxHeight: 520,
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      Padding(
                        padding: const EdgeInsets.fromLTRB(20, 16, 20, 8),
                        child: Text(
                          l10n.serviceRequiredResourcesLabel,
                          style: Theme.of(context).textTheme.titleLarge,
                        ),
                      ),
                      const Divider(height: 1),
                      Expanded(
                        child: SingleChildScrollView(
                          child: buildResourceRows(setStateLocal),
                        ),
                      ),
                      const Divider(height: 1),
                      Padding(
                        padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.end,
                          children: [
                            AppOutlinedActionButton(
                              onPressed: () => Navigator.of(dialogCtx).pop(),
                              padding: AppButtonStyles.dialogButtonPadding,
                              child: Text(l10n.actionCancel),
                            ),
                            const SizedBox(width: 12),
                            AppFilledButton(
                              onPressed: () => Navigator.of(dialogCtx).pop(),
                              padding: AppButtonStyles.dialogButtonPadding,
                              child: Text(l10n.actionConfirm),
                            ),
                          ],
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        );
      }

      Future<void> openResourceSheet(BuildContext ctx) async {
        await AppBottomSheet.show<void>(
          context: ctx,
          heightFactor: AppBottomSheet.defaultHeightFactor,
          padding: EdgeInsets.zero,
          builder: (sheetCtx) => StatefulBuilder(
            builder: (context, setStateLocal) {
              return SafeArea(
                top: false,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
                      child: Text(
                        l10n.serviceRequiredResourcesLabel,
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                    ),
                    const Divider(height: 1),
                    Expanded(
                      child: SingleChildScrollView(
                        child: buildResourceRows(setStateLocal),
                      ),
                    ),
                    const Divider(height: 1),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.end,
                        children: [
                          AppOutlinedActionButton(
                            onPressed: () => Navigator.of(sheetCtx).pop(),
                            padding: AppButtonStyles.dialogButtonPadding,
                            child: Text(l10n.actionCancel),
                          ),
                          const SizedBox(width: 12),
                          AppFilledButton(
                            onPressed: () => Navigator.of(sheetCtx).pop(),
                            padding: AppButtonStyles.dialogButtonPadding,
                            child: Text(l10n.actionConfirm),
                          ),
                        ],
                      ),
                    ),
                    SizedBox(height: MediaQuery.of(ctx).viewPadding.bottom),
                  ],
                ),
              );
            },
          ),
        );
      }

      if (formFactor == AppFormFactor.desktop) {
        await openResourceDialog(context);
      } else {
        await openResourceSheet(context);
      }

      setState(() {
        selectedResourceQuantities = {...current};
        isSelectingResources = false;
      });
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        LabeledFormField(
          label: context.l10n.fieldCategoryRequiredLabel,
          child: DropdownButtonFormField<int>(
            value: selectedCategory,
            decoration: InputDecoration(
              border: const OutlineInputBorder(),
              isDense: true,
              errorText: categoryError ? context.l10n.validationRequired : null,
            ),
            items: [
              for (final c in categories)
                DropdownMenuItem(value: c.id, child: Text(c.name)),
            ],
            onChanged: canEditDialog
                ? (v) => setState(() {
                    selectedCategory = v;
                    categoryError = false;
                  })
                : null,
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        LabeledFormField(
          label: context.l10n.fieldNameRequiredLabel,
          child: TextField(
            controller: nameController,
            enabled: canEditDialog,
            decoration: InputDecoration(
              border: const OutlineInputBorder(),
              isDense: true,
              errorText: nameError ? context.l10n.fieldNameRequiredError : null,
            ),
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        LabeledFormField(
          label: context.l10n.fieldDescriptionLabel,
          child: TextField(
            controller: descController,
            maxLines: 3,
            enabled: canEditDialog,
            decoration: const InputDecoration(
              border: OutlineInputBorder(),
              isDense: true,
            ),
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        if (hasMultipleLocations) ...[
          AppOutlinedActionButton(
            onPressed: canEditDialog && !isLoadingLocations
                ? openLocationSelector
                : null,
            expand: true,
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
            child: Row(
              children: [
                Expanded(
                  child: Align(
                    alignment: Alignment.centerLeft,
                    child: Text(context.l10n.serviceLocationsLabel),
                  ),
                ),
                if (isLoadingLocations)
                  const SizedBox(
                    width: 16,
                    height: 16,
                    child: CircularProgressIndicator(strokeWidth: 2),
                  )
                else
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 10,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: Theme.of(
                        context,
                      ).colorScheme.primary.withOpacity(0.12),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Text(
                      context.l10n.serviceLocationsCount(
                        selectedLocationIds.length,
                        allLocations.length,
                      ),
                      style: Theme.of(context).textTheme.labelSmall?.copyWith(
                        color: Theme.of(context).colorScheme.primary,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
              ],
            ),
          ),
          const SizedBox(height: AppSpacing.formRowSpacing),
        ],
        AppOutlinedActionButton(
          onPressed: openStaffSelector,
          expand: true,
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
          child: Row(
            children: [
              Expanded(
                child: Align(
                  alignment: Alignment.centerLeft,
                  child: Text(context.l10n.teamEligibleStaffLabel),
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 10,
                  vertical: 4,
                ),
                decoration: BoxDecoration(
                  color: Theme.of(
                    context,
                  ).colorScheme.primary.withOpacity(0.12),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  '${selectedStaffIds.length}/${staffList.length}',
                  style: Theme.of(context).textTheme.labelSmall?.copyWith(
                    color: Theme.of(context).colorScheme.primary,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
            ],
          ),
        ),
        if (locationResources.isNotEmpty) ...[
          const SizedBox(height: AppSpacing.formRowSpacing),
          AppOutlinedActionButton(
            onPressed: openResourceSelector,
            expand: true,
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
            child: Row(
              children: [
                Expanded(
                  child: Align(
                    alignment: Alignment.centerLeft,
                    child: Text(context.l10n.serviceRequiredResourcesLabel),
                  ),
                ),
                Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 10,
                    vertical: 4,
                  ),
                  decoration: BoxDecoration(
                    color: Theme.of(
                      context,
                    ).colorScheme.primary.withOpacity(0.12),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Text(
                    '${selectedResourceQuantities.length}/${locationResources.length}',
                    style: Theme.of(context).textTheme.labelSmall?.copyWith(
                      color: Theme.of(context).colorScheme.primary,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
        const SizedBox(height: AppSpacing.formRowSpacing),
        LabeledFormField(
          label: context.l10n.serviceColorLabel,
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 4),
            child: Wrap(
              spacing: 10,
              runSpacing: 10,
              children: [
                for (final color in uniquePalette)
                  GestureDetector(
                    onTap: canEditDialog
                        ? () => setState(() {
                            selectedColor = color;
                          })
                        : null,
                    child: AnimatedContainer(
                      duration: const Duration(milliseconds: 150),
                      width: 36,
                      height: 36,
                      decoration: BoxDecoration(
                        color: color,
                        shape: BoxShape.circle,
                        border: Border.all(
                          color: selectedColor.value == color.value
                              ? Theme.of(context).colorScheme.onSurface
                              : Colors.black.withOpacity(0.08),
                          width: selectedColor.value == color.value ? 2 : 1,
                        ),
                        boxShadow: [
                          BoxShadow(
                            color: Colors.black.withOpacity(0.08),
                            blurRadius: 4,
                            offset: const Offset(0, 2),
                          ),
                        ],
                      ),
                      child: selectedColor.value == color.value
                          ? Icon(
                              Icons.check,
                              color: _contrastFor(color),
                              size: 18,
                            )
                          : null,
                    ),
                  ),
              ],
            ),
          ),
        ),
        const SizedBox(height: AppSpacing.medium),
        Align(
          alignment: Alignment.center,
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 300),
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
              decoration: BoxDecoration(
                color: selectedColor,
                borderRadius: BorderRadius.circular(10),
              ),
              child: DefaultTextStyle(
                style: const TextStyle(
                  color: Colors.black87,
                  fontWeight: FontWeight.w600,
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      '09:00 - 10:00  ${context.l10n.formClient}',
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 2),
                    Text(
                      nameController.text.trim().isEmpty
                          ? context.l10n.formService
                          : nameController.text.trim(),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: const TextStyle(
                        color: Colors.black54,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        LabeledFormField(
          label: context.l10n.fieldDurationRequiredLabel,
          child: DropdownButtonFormField<int>(
            value: selectedDuration,
            decoration: InputDecoration(
              border: const OutlineInputBorder(),
              isDense: true,
              errorText: durationError
                  ? context.l10n.fieldDurationRequiredError
                  : null,
            ),
            items: [
              for (final (minutes, label) in _durationOptions(context))
                DropdownMenuItem(value: minutes, child: Text(label)),
            ],
            onChanged: canEditDialog
                ? (v) => setState(() {
                    selectedDuration = v;
                    durationError = false;
                    if ((selectedDuration ?? 0) <= 0) {
                      additionalSelection = _AdditionalTimeSelection.none;
                      additionalMinutes = 0;
                    }
                  })
                : null,
          ),
        ),
        if ((selectedDuration ?? 0) > 0) ...[
          const SizedBox(height: AppSpacing.formRowSpacing),
          LabeledFormField(
            label: context.l10n.additionalTimeSwitch,
            child: DropdownButtonFormField<_AdditionalTimeSelection>(
              value: additionalSelection == _AdditionalTimeSelection.none
                  ? null
                  : additionalSelection,
              decoration: const InputDecoration(
                border: OutlineInputBorder(),
                isDense: true,
              ),
              hint: const Text(''),
              items: [
                DropdownMenuItem(
                  value: _AdditionalTimeSelection.none,
                  child: const Text(''),
                ),
                DropdownMenuItem(
                  value: _AdditionalTimeSelection.processing,
                  child: Text(context.l10n.additionalTimeOptionProcessing),
                ),
                DropdownMenuItem(
                  value: _AdditionalTimeSelection.blocked,
                  child: Text(context.l10n.additionalTimeOptionBlocked),
                ),
              ],
              onChanged: canEditDialog
                  ? (sel) => setState(() {
                      additionalSelection =
                          sel ?? _AdditionalTimeSelection.none;
                      if (additionalSelection ==
                          _AdditionalTimeSelection.none) {
                        additionalMinutes = 0;
                      }
                    })
                  : null,
            ),
          ),
          if (additionalSelection != _AdditionalTimeSelection.none) ...[
            const SizedBox(height: AppSpacing.formRowSpacing),
            LabeledFormField(
              label:
                  (additionalSelection == _AdditionalTimeSelection.processing)
                  ? context.l10n.fieldProcessingTimeLabel
                  : context.l10n.fieldBlockedTimeLabel,
              child: DropdownButtonFormField<int>(
                value: additionalMinutes,
                decoration: const InputDecoration(
                  border: OutlineInputBorder(),
                  isDense: true,
                ),
                items: [
                  for (final (minutes, label) in _bufferOptions(
                    context,
                    additionalMinutes,
                  ))
                    DropdownMenuItem(value: minutes, child: Text(label)),
                ],
                onChanged: canEditDialog
                    ? (v) => setState(() {
                        additionalMinutes = v ?? 0;
                      })
                    : null,
              ),
            ),
          ],
        ],
        const SizedBox(height: AppSpacing.formRowSpacing),
        LabeledFormField(
          label: context.l10n.fieldPriceLabel,
          child: TextField(
            controller: priceController,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            inputFormatters: [
              FilteringTextInputFormatter.allow(RegExp(r'[0-9.,\-]')),
            ],
            decoration: InputDecoration(
              border: const OutlineInputBorder(),
              isDense: true,
              prefixText: '$currencySymbol ',
            ),
            enabled: canEditDialog && !isFree,
            onChanged: canEditDialog
                ? (_) {
                    if (priceController.text.trim().isEmpty &&
                        isPriceStartingFrom) {
                      setState(() => isPriceStartingFrom = false);
                    }
                  }
                : null,
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        _SwitchTile(
          title: context.l10n.freeServiceSwitch,
          value: isFree,
          onChanged: canEditDialog
              ? (v) {
                  setState(() {
                    isFree = v;
                    if (isFree) {
                      priceController.clear();
                      isPriceStartingFrom = false;
                    }
                  });
                }
              : null,
        ),
        _SwitchTile(
          title: context.l10n.priceStartingFromSwitch,
          subtitle: (isFree || priceController.text.trim().isEmpty)
              ? context.l10n.setPriceToEnable
              : null,
          value: isPriceStartingFrom,
          onChanged:
              (canEditDialog &&
                  !isFree &&
                  priceController.text.trim().isNotEmpty)
              ? (v) => setState(() => isPriceStartingFrom = v)
              : null,
          enabled:
              canEditDialog &&
              (!isFree && priceController.text.trim().isNotEmpty),
        ),
        const SizedBox(height: 40),
        _SwitchTile(
          title: context.l10n.bookableOnlineSwitch,
          value: isBookableOnline,
          onChanged: canEditDialog
              ? (v) => setState(() => isBookableOnline = v)
              : null,
        ),
      ],
    );
  }

  final dialogTitle = !isEditing
      ? context.l10n.newServiceTitle
      : context.l10n.editServiceTitle;

  final builder = StatefulBuilder(
    builder: (context, setState) {
      final canManageServices = ref.watch(currentUserCanManageServicesProvider);
      final canEdit = canManageServices && !readOnly;

      // Load service locations on first build (for editing)
      if (isEditing && isLoadingLocations) {
        WidgetsBinding.instance.addPostFrameCallback((_) async {
          try {
            final notifier = ref.read(servicesProvider.notifier);
            final loadedIds = await notifier.getServiceLocationsApi(service.id);
            setState(() {
              selectedLocationIds = loadedIds.toSet();
              originalLocationIds = loadedIds.toSet();
              isLoadingLocations = false;
            });
          } catch (e) {
            // Fallback to current location on error
            setState(() {
              selectedLocationIds = {locationId};
              originalLocationIds = {locationId};
              isLoadingLocations = false;
            });
          }
        });
      }

      final body = buildBody(context, setState);

      final cancelButton = SizedBox(
        width: AppButtonStyles.dialogButtonWidth,
        child: AppOutlinedActionButton(
          onPressed: isSaving
              ? null
              : () => Navigator.of(context, rootNavigator: true).pop(),
          padding: AppButtonStyles.dialogButtonPadding,
          child: Text(context.l10n.actionCancel),
        ),
      );

      final saveButton = SizedBox(
        width: AppButtonStyles.dialogButtonWidth,
        child: AppAsyncFilledButton(
          onPressed: isSaving || !canEdit
              ? null
              : () async {
                  setState(() => isSaving = true);
                  try {
                    await handleSave();
                    setState(() {});
                  } finally {
                    setState(() => isSaving = false);
                  }
                },
          padding: AppButtonStyles.dialogButtonPadding,
          isLoading: isSaving,
          showSpinner: false,
          child: Text(context.l10n.actionSave),
        ),
      );
      final closeButton = SizedBox(
        width: AppButtonStyles.dialogButtonWidth,
        child: AppFilledButton(
          onPressed: isSaving
              ? null
              : () => Navigator.of(context, rootNavigator: true).pop(),
          padding: AppButtonStyles.dialogButtonPadding,
          child: Text(context.l10n.actionClose),
        ),
      );
      final bottomActions = readOnly
          ? <Widget>[closeButton]
          : <Widget>[cancelButton, saveButton];

      if (isDesktop) {
        return DismissibleDialog(
          child: Dialog(
            insetPadding: const EdgeInsets.symmetric(
              horizontal: 32,
              vertical: 24,
            ),
            child: ConstrainedBox(
              constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
              child: LocalLoadingOverlay(
                isLoading: isSaving,
                child: Padding(
                  padding: const EdgeInsets.all(20),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      Text(
                        dialogTitle,
                        style: Theme.of(context).textTheme.headlineSmall,
                      ),
                      const SizedBox(height: 16),
                      Flexible(child: SingleChildScrollView(child: body)),
                      const SizedBox(height: 24),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.end,
                        children: [
                          cancelButton,
                          const SizedBox(width: 8),
                          saveButton,
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        );
      }

      return SafeArea(
        top: false,
        child: LayoutBuilder(
          builder: (context, constraints) {
            final isKeyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
            return LocalLoadingOverlay(
              isLoading: isSaving,
              child: SizedBox(
                height: constraints.maxHeight,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Expanded(
                      child: SingleChildScrollView(
                        padding: EdgeInsets.zero,
                        child: Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Padding(
                              padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  Padding(
                                    padding: const EdgeInsets.only(bottom: 12),
                                    child: Text(
                                      dialogTitle,
                                      style: Theme.of(
                                        context,
                                      ).textTheme.titleLarge,
                                    ),
                                  ),
                                  body,
                                  const SizedBox(height: 24),
                                  const SizedBox(
                                    height: AppSpacing.formRowSpacing,
                                  ),
                                ],
                              ),
                            ),
                          ],
                        ),
                      ),
                    ),
                    if (!isKeyboardOpen) ...[
                      const AppDivider(),
                      Padding(
                        padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                        child: Align(
                          alignment: bottomActions.length == 3
                              ? Alignment.center
                              : Alignment.centerRight,
                          child: Wrap(
                            alignment: bottomActions.length == 3
                                ? WrapAlignment.center
                                : WrapAlignment.end,
                            spacing: 8,
                            runSpacing: 8,
                            children: bottomActions,
                          ),
                        ),
                      ),
                    ],
                    SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
                  ],
                ),
              ),
            );
          },
        ),
      );
    },
  );

  if (isDesktop) {
    await showDialog(
      context: context,
      barrierDismissible: true,
      builder: (_) => builder,
    );
  } else {
    await AppBottomSheet.show(
      context: context,
      builder: (_) => builder,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
    );
  }
}

List<(int, String)> _durationOptions(BuildContext context) {
  final List<(int, String)> options = [];
  for (int i = 5; i <= 420; i += 5) {
    options.add((i, context.localizedDurationLabel(i)));
  }
  return options;
}

List<(int, String)> _bufferOptions(BuildContext context, [int? currentValue]) {
  final List<(int, String)> options = [];
  final steps = <int>[0, 5, 10, 15, 20, 30, 45, 60, 90, 120];

  // Se il valore corrente non √® nella lista standard, aggiungilo
  if (currentValue != null &&
      currentValue > 0 &&
      !steps.contains(currentValue)) {
    steps.add(currentValue);
    steps.sort();
  }

  for (final m in steps) {
    options.add((m, context.localizedDurationLabel(m)));
  }
  return options;
}
--- FILE: lib/features/services/presentation/widgets/category_item.dart ---
import 'package:flutter/material.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service_category.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_package.dart';
import '../../providers/services_sorted_providers.dart';
import 'empty_state.dart';
import 'services_list.dart';

/// Item che rappresenta la card di una singola categoria (header + servizi).
class CategoryItem extends StatelessWidget {
  final ServiceCategory category;
  final List<ServiceCategoryEntry> entries;
  final bool isWide;
  final ColorScheme colorScheme;
  final ValueNotifier<int?> hoveredService;
  final ValueNotifier<int?> selectedService;
  final VoidCallback onAddService;
  final VoidCallback onAddPackage;
  final VoidCallback onEditCategory;
  final VoidCallback onDeleteCategory;
  final VoidCallback onDeleteBlocked;
  final ValueChanged<Service> onServiceOpen;
  final ValueChanged<Service> onServiceEdit;
  final ValueChanged<Service> onServiceDuplicate;
  final ValueChanged<int> onServiceDelete;
  final ValueChanged<ServicePackage> onPackageOpen;
  final ValueChanged<ServicePackage> onPackageEdit;
  final ValueChanged<int> onPackageDelete;
  final bool addTopSpacing;
  final bool readOnly;

  const CategoryItem({
    super.key,
    required this.category,
    required this.entries,
    required this.isWide,
    required this.colorScheme,
    required this.hoveredService,
    required this.selectedService,
    required this.onAddService,
    required this.onAddPackage,
    required this.onEditCategory,
    required this.onDeleteCategory,
    required this.onDeleteBlocked,
    required this.onServiceOpen,
    required this.onServiceEdit,
    required this.onServiceDuplicate,
    required this.onServiceDelete,
    required this.onPackageOpen,
    required this.onPackageEdit,
    required this.onPackageDelete,
    required this.addTopSpacing,
    this.readOnly = false,
  });

  @override
  Widget build(BuildContext context) {
    final isEmptyCategory = entries.isEmpty;
    return Container(
      margin: EdgeInsets.only(top: addTopSpacing ? 32 : 0, bottom: 24),
      decoration: BoxDecoration(
        color: colorScheme.surface,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 6,
            offset: const Offset(0, 3),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header categoria
          Container(
            width: double.infinity,
            decoration: BoxDecoration(
              color: colorScheme.primaryContainer,
              borderRadius: const BorderRadius.vertical(
                top: Radius.circular(16),
              ),
            ),
            padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),
            child: Row(
              children: [
                // Titolo + descrizione
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        category.name,
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                        style: Theme.of(context).textTheme.titleMedium
                            ?.copyWith(
                              fontWeight: FontWeight.w600,
                              color: colorScheme.onPrimaryContainer,
                            ),
                      ),
                      if (category.description != null)
                        Padding(
                          padding: const EdgeInsets.only(top: 4),
                          child: Text(
                            category.description!,
                            maxLines: 2,
                            overflow: TextOverflow.ellipsis,
                            style: Theme.of(context).textTheme.bodySmall
                                ?.copyWith(
                                  color: colorScheme.onPrimaryContainer
                                      .withOpacity(0.8),
                                ),
                          ),
                        ),
                    ],
                  ),
                ),
                const SizedBox(width: 12),

                // Pulsanti azione (solo in vista normale)
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    if (!readOnly) ...[
                      IconButton(
                        tooltip: context.l10n.addServiceTooltip,
                        icon: Icon(
                          Icons.add,
                          color: colorScheme.onPrimaryContainer,
                        ),
                        onPressed: onAddService,
                      ),
                      IconButton(
                        tooltip: context.l10n.servicePackageNewMenu,
                        icon: Icon(
                          Icons.widgets_outlined,
                          color: colorScheme.onPrimaryContainer,
                        ),
                        onPressed: onAddPackage,
                      ),
                      IconButton(
                        tooltip: context.l10n.actionEdit,
                        icon: Icon(
                          Icons.edit_outlined,
                          color: colorScheme.onPrimaryContainer,
                        ),
                        onPressed: onEditCategory,
                      ),
                      if (isEmptyCategory)
                        IconButton(
                          tooltip: context.l10n.actionDelete,
                          icon: const Icon(Icons.delete_outline),
                          color: colorScheme.onPrimaryContainer,
                          onPressed: onDeleteCategory,
                        ),
                    ],
                  ],
                ),
              ],
            ),
          ),

          // Body: lista servizi o stato vuoto
          ClipRRect(
            borderRadius: const BorderRadius.vertical(
              bottom: Radius.circular(16),
            ),
            child: isEmptyCategory
                ? ServicesEmptyState(message: context.l10n.noServicesInCategory)
                : ServicesList(
                    entries: entries,
                    isWide: isWide,
                    colorScheme: colorScheme,
                    hoveredService: hoveredService,
                    selectedService: selectedService,
                    onOpen: onServiceOpen,
                    onEdit: onServiceEdit,
                    onDuplicate: onServiceDuplicate,
                    onDelete: onServiceDelete,
                    onPackageOpen: onPackageOpen,
                    onPackageEdit: onPackageEdit,
                    onPackageDelete: onPackageDelete,
                    readOnly: readOnly,
                  ),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/service_item.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/theme/extensions.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/utils/color_utils.dart';
import '../../../../core/utils/price_utils.dart';
import '../../providers/services_provider.dart';

class ServiceItem extends ConsumerWidget {
  final Service service;
  final bool isLast;
  final bool isEvenRow;
  final bool isHovered;
  final bool isSelected;
  final bool isWide;
  final ColorScheme colorScheme;
  final VoidCallback onTap;
  final VoidCallback onEnter;
  final VoidCallback onExit;
  final VoidCallback onEdit;
  final VoidCallback onDuplicate;
  final VoidCallback onDelete;
  final bool readOnly;

  const ServiceItem({
    super.key,
    required this.service,
    required this.isLast,
    required this.isEvenRow,
    required this.isHovered,
    required this.isSelected,
    required this.isWide,
    required this.colorScheme,
    required this.onTap,
    required this.onEnter,
    required this.onExit,
    required this.onEdit,
    required this.onDuplicate,
    required this.onDelete,
    this.readOnly = false,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final interactionColors = Theme.of(
      context,
    ).extension<AppInteractionColors>();
    final variant = ref.watch(serviceVariantByServiceIdProvider(service.id));
    final eligibleStaffIds = ref.watch(
      eligibleStaffForServiceProvider(service.id),
    );
    final eligibleStaffCount = eligibleStaffIds.length;
    final baseColor = isEvenRow
        ? (interactionColors?.alternatingRowFill ??
              colorScheme.onSurface.withOpacity(0.04))
        : Colors.transparent;

    final hoverFill =
        interactionColors?.hoverFill ??
        colorScheme.primaryContainer.withOpacity(0.1);
    final bgColor = (isHovered || isSelected) ? hoverFill : baseColor;

    final durationMinutes = variant?.durationMinutes;
    final extraMinutes =
        (variant?.processingTime ?? 0) + (variant?.blockedTime ?? 0);
    final totalMinutes = (durationMinutes ?? 0) + extraMinutes;
    final durationLabel = durationMinutes != null
        ? context.localizedDurationLabel(
            extraMinutes > 0 ? totalMinutes : durationMinutes,
          )
        : null;

    return MouseRegion(
      cursor: SystemMouseCursors.click,
      onEnter: (_) => onEnter(),
      onExit: (_) => onExit(),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: onTap,
          borderRadius: BorderRadius.only(
            bottomLeft: isLast ? const Radius.circular(16) : Radius.zero,
            bottomRight: isLast ? const Radius.circular(16) : Radius.zero,
          ),
          child: Container(
            decoration: BoxDecoration(
              color: bgColor,
              borderRadius: BorderRadius.only(
                bottomLeft: isLast ? const Radius.circular(16) : Radius.zero,
                bottomRight: isLast ? const Radius.circular(16) : Radius.zero,
              ),
            ),
            child: IntrinsicHeight(
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Container(
                    width: 4,
                    decoration: BoxDecoration(
                      color: variant?.colorHex != null
                          ? ColorUtils.fromHex(variant!.colorHex!)
                          : colorScheme.primary,
                      borderRadius: BorderRadius.only(
                        bottomLeft: isLast
                            ? const Radius.circular(16)
                            : Radius.zero,
                      ),
                    ),
                  ),
                  Expanded(
                    child: ListTile(
                      contentPadding: const EdgeInsets.fromLTRB(16, 2, 16, 16),
                      mouseCursor: SystemMouseCursors.click,
                      title: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            service.name,
                            style: Theme.of(context).textTheme.titleMedium
                                ?.copyWith(fontWeight: FontWeight.w500),
                          ),
                          if (eligibleStaffCount == 0) ...[
                            const SizedBox(height: 2),
                            Text(
                              context.l10n.serviceEligibleStaffNone,
                              style: Theme.of(context).textTheme.bodySmall
                                  ?.copyWith(
                                    color: Theme.of(context).colorScheme.error,
                                    fontStyle: FontStyle.italic,
                                  ),
                            ),
                          ],
                          if (durationLabel != null ||
                              variant?.price != null ||
                              (variant?.isFree ?? false))
                            Padding(
                              padding: const EdgeInsets.only(top: 4),
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  if (durationLabel != null)
                                    Text(
                                      durationLabel,
                                      style: const TextStyle(
                                        fontSize: 11,
                                        color: Colors.black54,
                                        height: 1.1,
                                      ),
                                    ),
                                  if (durationLabel != null &&
                                      (variant?.price != null ||
                                          (variant?.isFree ?? false)))
                                    const SizedBox(width: 8),
                                  if (variant?.isFree ?? false)
                                    Text(
                                      context.l10n.freeLabel,
                                      style: const TextStyle(
                                        fontSize: 11,
                                        color: Colors.black54,
                                        height: 1.1,
                                      ),
                                    )
                                  else if (variant?.price != null)
                                    Text(
                                      service.isPriceStartingFrom
                                          ? '${context.l10n.priceStartingFromPrefix} ${PriceFormatter.formatVariant(context: context, ref: ref, variant: variant!)}'
                                          : PriceFormatter.formatVariant(
                                              context: context,
                                              ref: ref,
                                              variant: variant!,
                                            ),
                                      style: const TextStyle(
                                        fontSize: 11,
                                        color: Colors.black54,
                                        height: 1.1,
                                      ),
                                    ),
                                ],
                              ),
                            ),
                          if (!(variant?.isBookableOnline ?? true))
                            Padding(
                              padding: const EdgeInsets.only(top: 2),
                              child: Text(
                                context.l10n.notBookableOnline,
                                style: Theme.of(context).textTheme.bodySmall
                                    ?.copyWith(
                                      color: Colors.red[600],
                                      fontStyle: FontStyle.italic,
                                    ),
                              ),
                            ),
                        ],
                      ),
                      trailing: UnconstrainedBox(
                        alignment: Alignment.centerRight,
                        child: readOnly
                            ? null
                            : isWide
                            ? _buildActionIcons(context)
                            : _buildPopupMenu(),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildActionIcons(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        IconButton(
          tooltip: context.l10n.actionEdit,
          icon: const Icon(Icons.edit_outlined),
          onPressed: onEdit,
        ),
        IconButton(
          tooltip: context.l10n.duplicateAction,
          icon: const Icon(Icons.copy_outlined),
          onPressed: onDuplicate,
        ),
        IconButton(
          tooltip: context.l10n.actionDelete,
          icon: const Icon(Icons.delete_outline, color: Colors.red),
          onPressed: onDelete,
        ),
      ],
    );
  }

  Widget _buildPopupMenu() {
    return PopupMenuButton<String>(
      onSelected: (value) {
        switch (value) {
          case 'edit':
            onEdit();
            break;
          case 'duplicate':
            onDuplicate();
            break;
          case 'delete':
            onDelete();
            break;
        }
      },
      itemBuilder: (context) => [
        PopupMenuItem(value: 'edit', child: Text(context.l10n.actionEdit)),
        PopupMenuItem(
          value: 'duplicate',
          child: Text(context.l10n.duplicateAction),
        ),
        PopupMenuItem(value: 'delete', child: Text(context.l10n.actionDelete)),
      ],
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/service_eligibility_selector.dart ---
import 'package:flutter/material.dart';

import '../../../../app/theme/extensions.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';

class ServiceEligibilitySelector extends StatelessWidget {
  const ServiceEligibilitySelector({
    super.key,
    required this.services,
    required this.categories,
    required this.selectedServiceIds,
    required this.onChanged,
    this.showSelectAll = true,
    this.readOnly = false,
    this.onServiceTap,
  });

  final List<Service> services;
  final List<ServiceCategory> categories;
  final Set<int> selectedServiceIds;
  final ValueChanged<Set<int>> onChanged;
  final bool showSelectAll;
  final bool readOnly;
  final ValueChanged<Service>? onServiceTap;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    final servicesByCategory = <int, List<Service>>{};
    for (final service in services) {
      (servicesByCategory[service.categoryId] ??= []).add(service);
    }

    final hasServicesMap = <int, bool>{
      for (final category in categories)
        category.id: (servicesByCategory[category.id]?.isNotEmpty ?? false),
    };

    final sortedCategories = [...categories]
      ..sort((a, b) {
        final aEmpty = !(hasServicesMap[a.id] ?? false);
        final bEmpty = !(hasServicesMap[b.id] ?? false);
        if (aEmpty != bEmpty) return aEmpty ? 1 : -1;
        final so = a.sortOrder.compareTo(b.sortOrder);
        return so != 0
            ? so
            : a.name.toLowerCase().compareTo(b.name.toLowerCase());
      });

    final allServiceIds = [
      for (final service in services) service.id,
    ];
    final isAllSelected =
        allServiceIds.isNotEmpty &&
        allServiceIds.every(selectedServiceIds.contains);

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        if (showSelectAll)
          _SelectableRow(
            label: l10n.teamSelectAllServices,
            selected: isAllSelected,
            onTap: readOnly
                ? null
                : () {
              if (isAllSelected) {
                onChanged(<int>{});
              } else {
                onChanged(allServiceIds.toSet());
              }
            },
          ),
        if (showSelectAll) const Divider(height: 1),
        for (final category in sortedCategories)
          if ((servicesByCategory[category.id] ?? const <Service>[]).isNotEmpty)
            ...[
                _CategoryHeader(
                  category: category,
                  selectedIds: selectedServiceIds,
                  services: servicesByCategory[category.id]!,
                  onChanged: onChanged,
                  readOnly: readOnly,
                ),
              for (int i = 0; i < servicesByCategory[category.id]!.length; i++)
                _ServiceRow(
                  service: servicesByCategory[category.id]![i],
                  isEven: i.isEven,
                  selectedIds: selectedServiceIds,
                  onChanged: onChanged,
                  evenBackgroundColor: theme
                          .extension<AppInteractionColors>()
                          ?.alternatingRowFill ??
                      theme.colorScheme.onSurface.withOpacity(0.04),
                  readOnly: readOnly,
                  onServiceTap: onServiceTap,
                ),
            ],
      ],
    );
  }
}

class _SelectableRow extends StatelessWidget {
  const _SelectableRow({
    required this.label,
    required this.selected,
    this.onTap,
  });

  final String label;
  final bool selected;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          child: Row(
            children: [
              Expanded(child: Text(label)),
              if (selected)
                Icon(
                  Icons.check,
                  color: Theme.of(context).colorScheme.primary,
                  size: 20,
                ),
            ],
          ),
        ),
      ),
    );
  }
}

class _CategoryHeader extends StatelessWidget {
  const _CategoryHeader({
    required this.category,
    required this.services,
    required this.selectedIds,
    required this.onChanged,
    required this.readOnly,
  });

  final ServiceCategory category;
  final List<Service> services;
  final Set<int> selectedIds;
  final ValueChanged<Set<int>> onChanged;
  final bool readOnly;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final serviceIds = services.map((s) => s.id).toList();
    final isSelected =
        serviceIds.isNotEmpty && serviceIds.every(selectedIds.contains);

    return Material(
      color: theme.colorScheme.primary,
      child: InkWell(
        onTap: readOnly
            ? null
            : () {
          if (serviceIds.isEmpty) return;
          final updated = {...selectedIds};
          if (isSelected) {
            updated.removeWhere(serviceIds.contains);
          } else {
            updated.addAll(serviceIds);
          }
          onChanged(updated);
        },
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 20),
          child: Row(
            children: [
              Expanded(
                child: Text(
                  category.name.toUpperCase(),
                  style: theme.textTheme.labelMedium?.copyWith(
                    color: theme.colorScheme.onPrimary,
                    fontWeight: FontWeight.bold,
                    letterSpacing: 0.5,
                  ),
                ),
              ),
              if (serviceIds.isNotEmpty)
                Icon(
                  isSelected ? Icons.check_box : Icons.check_box_outline_blank,
                  color: theme.colorScheme.onPrimary,
                  size: 18,
                ),
            ],
          ),
        ),
      ),
    );
  }
}

class _ServiceRow extends StatelessWidget {
  const _ServiceRow({
    required this.service,
    required this.isEven,
    required this.selectedIds,
    required this.onChanged,
    required this.evenBackgroundColor,
    required this.readOnly,
    this.onServiceTap,
  });

  final Service service;
  final bool isEven;
  final Set<int> selectedIds;
  final ValueChanged<Set<int>> onChanged;
  final Color evenBackgroundColor;
  final bool readOnly;
  final ValueChanged<Service>? onServiceTap;

  @override
  Widget build(BuildContext context) {
    final isSelected = selectedIds.contains(service.id);
    return Material(
      color: isEven ? evenBackgroundColor : Colors.transparent,
      child: InkWell(
        onTap: () {
          if (readOnly) {
            onServiceTap?.call(service);
            return;
          }
          final updated = {...selectedIds};
          if (isSelected) {
            updated.remove(service.id);
          } else {
            updated.add(service.id);
          }
          onChanged(updated);
        },
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          child: Row(
            children: [
              Expanded(child: Text(service.name)),
              if (isSelected)
                Icon(
                  Icons.check,
                  color: Theme.of(context).colorScheme.primary,
                  size: 20,
                ),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/service_package_item.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service_package.dart';
import '../../../../core/utils/price_utils.dart';

class ServicePackageListItem extends ConsumerWidget {
  final ServicePackage package;
  final bool isLast;
  final bool isEvenRow;
  final bool isWide;
  final ColorScheme colorScheme;
  final VoidCallback onTap;
  final VoidCallback onEdit;
  final VoidCallback onDelete;
  final bool readOnly;

  const ServicePackageListItem({
    super.key,
    required this.package,
    required this.isLast,
    required this.isEvenRow,
    required this.isWide,
    required this.colorScheme,
    required this.onTap,
    required this.onEdit,
    required this.onDelete,
    this.readOnly = false,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final baseColor = isEvenRow
        ? colorScheme.onSurface.withOpacity(0.04)
        : Colors.transparent;
    final bgColor = baseColor;
    final currency = PriceFormatter.effectiveCurrency(ref);
    final price = PriceFormatter.format(
      context: context,
      amount: package.effectivePrice,
      currencyCode: currency,
    );
    final durationLabel = context.localizedDurationLabel(
      package.effectiveDurationMinutes,
    );

    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.only(
          bottomLeft: isLast ? const Radius.circular(16) : Radius.zero,
          bottomRight: isLast ? const Radius.circular(16) : Radius.zero,
        ),
        child: Container(
          decoration: BoxDecoration(
            color: bgColor,
            borderRadius: BorderRadius.only(
              bottomLeft: isLast ? const Radius.circular(16) : Radius.zero,
              bottomRight: isLast ? const Radius.circular(16) : Radius.zero,
            ),
          ),
          child: IntrinsicHeight(
            child: Row(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Container(
                  width: 4,
                  decoration: BoxDecoration(
                    color: colorScheme.secondary,
                    borderRadius: BorderRadius.only(
                      bottomLeft: isLast
                          ? const Radius.circular(16)
                          : Radius.zero,
                    ),
                  ),
                ),
                Expanded(
                  child: ListTile(
                    contentPadding: const EdgeInsets.fromLTRB(16, 2, 16, 16),
                    mouseCursor: SystemMouseCursors.click,
                    title: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          package.name,
                          style: Theme.of(context).textTheme.titleMedium
                              ?.copyWith(fontWeight: FontWeight.w500),
                        ),
                        Padding(
                          padding: const EdgeInsets.only(top: 4),
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Text(
                                durationLabel,
                                style: const TextStyle(
                                  fontSize: 11,
                                  color: Colors.black54,
                                  height: 1.1,
                                ),
                              ),
                              const SizedBox(width: 8),
                              Text(
                                price,
                                style: const TextStyle(
                                  fontSize: 11,
                                  color: Colors.black54,
                                  height: 1.1,
                                ),
                              ),
                            ],
                          ),
                        ),
                        if (!package.isActive || package.isBroken)
                          Padding(
                            padding: const EdgeInsets.only(top: 4),
                            child: Wrap(
                              spacing: 6,
                              runSpacing: 4,
                              children: [
                                if (!package.isActive)
                                  _StatusChip(
                                    label: context
                                        .l10n
                                        .servicePackageInactiveLabel,
                                    color: colorScheme.outline,
                                  ),
                                if (package.isBroken)
                                  _StatusChip(
                                    label:
                                        context.l10n.servicePackageBrokenLabel,
                                    color: colorScheme.error,
                                  ),
                              ],
                            ),
                          ),
                      ],
                    ),
                    trailing: UnconstrainedBox(
                      alignment: Alignment.centerRight,
                      child: readOnly
                          ? null
                          : isWide
                          ? _buildActionIcons(context)
                          : _buildPopupMenu(context),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildActionIcons(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        IconButton(
          tooltip: context.l10n.actionEdit,
          icon: const Icon(Icons.edit_outlined),
          onPressed: onEdit,
        ),
        IconButton(
          tooltip: context.l10n.actionDelete,
          icon: const Icon(Icons.delete_outline, color: Colors.red),
          onPressed: onDelete,
        ),
      ],
    );
  }

  Widget _buildPopupMenu(BuildContext context) {
    return PopupMenuButton<String>(
      onSelected: (value) {
        switch (value) {
          case 'edit':
            onEdit();
            break;
          case 'delete':
            onDelete();
            break;
        }
      },
      itemBuilder: (context) => [
        PopupMenuItem(value: 'edit', child: Text(context.l10n.actionEdit)),
        PopupMenuItem(value: 'delete', child: Text(context.l10n.actionDelete)),
      ],
    );
  }
}

class _StatusChip extends StatelessWidget {
  const _StatusChip({required this.label, required this.color});

  final String label;
  final Color color;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: color.withOpacity(0.12),
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: color.withOpacity(0.4)),
      ),
      child: Text(
        label,
        style: Theme.of(context).textTheme.labelSmall?.copyWith(color: color),
      ),
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/services_list.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/models/service.dart';
import '../../../../core/models/service_package.dart';
import '../../providers/services_sorted_providers.dart';
import 'service_item.dart';
import 'service_package_item.dart';

class ServicesList extends ConsumerWidget {
  final List<ServiceCategoryEntry> entries;
  final bool isWide;
  final ColorScheme colorScheme;
  final ValueNotifier<int?> hoveredService;
  final ValueNotifier<int?> selectedService;
  final void Function(Service) onOpen;
  final void Function(Service) onEdit;
  final void Function(Service) onDuplicate;
  final void Function(int id) onDelete;
  final void Function(ServicePackage) onPackageOpen;
  final void Function(ServicePackage) onPackageEdit;
  final void Function(int id) onPackageDelete;
  final bool readOnly;

  const ServicesList({
    super.key,
    required this.entries,
    required this.isWide,
    required this.colorScheme,
    required this.hoveredService,
    required this.selectedService,
    required this.onOpen,
    required this.onEdit,
    required this.onDuplicate,
    required this.onDelete,
    required this.onPackageOpen,
    required this.onPackageEdit,
    required this.onPackageDelete,
    this.readOnly = false,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ValueListenableBuilder<int?>(
      valueListenable: hoveredService,
      builder: (context, hoveredId, _) {
        return ValueListenableBuilder<int?>(
          valueListenable: selectedService,
          builder: (context, selectedId, __) {
            return Column(
              children: [
                for (int i = 0; i < entries.length; i++)
                  if (entries[i].isService)
                    ServiceItem(
                      service: entries[i].service!,
                      isLast: i == entries.length - 1,
                      isEvenRow: i.isEven,
                      isHovered: hoveredId == entries[i].service!.id,
                      isSelected: selectedId == entries[i].service!.id,
                      isWide: isWide,
                      colorScheme: colorScheme,
                      onTap: () {
                        selectedService.value = entries[i].service!.id;
                        onOpen(entries[i].service!);
                      },
                      onEnter: () =>
                          hoveredService.value = entries[i].service!.id,
                      onExit: () => hoveredService.value = null,
                      onEdit: () => onEdit(entries[i].service!),
                      onDuplicate: () => onDuplicate(entries[i].service!),
                      onDelete: () => onDelete(entries[i].service!.id),
                      readOnly: readOnly,
                    )
                  else
                    ServicePackageListItem(
                      package: entries[i].package!,
                      isLast: i == entries.length - 1,
                      isEvenRow: i.isEven,
                      isWide: isWide,
                      colorScheme: colorScheme,
                      onTap: () {
                        onPackageOpen(entries[i].package!);
                      },
                      onEdit: () => onPackageEdit(entries[i].package!),
                      onDelete: () => onPackageDelete(entries[i].package!.id),
                      readOnly: readOnly,
                    ),
                if (entries.isNotEmpty)
                  Divider(
                    color: Colors.grey.withOpacity(0.2),
                    height: 1,
                    thickness: 1,
                  ),
              ],
            );
          },
        );
      },
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/empty_state.dart ---
import 'package:flutter/material.dart';

/// Widget riutilizzabile per i casi in cui una categoria non contiene servizi.
class ServicesEmptyState extends StatelessWidget {
  final String message;

  const ServicesEmptyState({
    super.key,
    required this.message,
  });

  @override
  Widget build(BuildContext context) {
    final textStyle = Theme.of(context).textTheme.bodyMedium;

    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.inbox_outlined,
            color: Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
          ),
          const SizedBox(width: 8),
          Flexible(
            child: Text(
              message,
              textAlign: TextAlign.center,
              style: textStyle?.copyWith(
                color: textStyle.color?.withOpacity(0.7),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/categories_list.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';
import '../../../../core/models/service_package.dart';
import '../../providers/services_sorted_providers.dart';
import 'category_item.dart';

/// Lista dei pannelli categoria aggiornata per la vista normale.
class CategoriesList extends ConsumerWidget {
  final List<ServiceCategory> categories;
  final bool isWide;
  final ColorScheme colorScheme;
  final ValueNotifier<int?> hoveredService;
  final ValueNotifier<int?> selectedService;
  final ValueChanged<ServiceCategory> onAddService;
  final ValueChanged<ServiceCategory> onAddPackage;
  final ValueChanged<ServiceCategory> onEditCategory;
  final ValueChanged<int> onDeleteCategory;
  final VoidCallback onDeleteCategoryBlocked;
  final ValueChanged<Service> onServiceOpen;
  final ValueChanged<Service> onServiceEdit;
  final ValueChanged<Service> onServiceDuplicate;
  final ValueChanged<int> onServiceDelete;
  final ValueChanged<ServicePackage> onPackageOpen;
  final ValueChanged<ServicePackage> onPackageEdit;
  final ValueChanged<int> onPackageDelete;
  final ScrollController scrollController;
  final bool readOnly;

  const CategoriesList({
    super.key,
    required this.categories,
    required this.isWide,
    required this.colorScheme,
    required this.hoveredService,
    required this.selectedService,
    required this.onAddService,
    required this.onAddPackage,
    required this.onEditCategory,
    required this.onDeleteCategory,
    required this.onDeleteCategoryBlocked,
    required this.onServiceOpen,
    required this.onServiceEdit,
    required this.onServiceDuplicate,
    required this.onServiceDelete,
    required this.onPackageOpen,
    required this.onPackageEdit,
    required this.onPackageDelete,
    required this.scrollController,
    this.readOnly = false,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ListView.builder(
      controller: scrollController,
      padding: const EdgeInsets.fromLTRB(16, 0, 16, 100),
      itemCount: categories.length,
      itemBuilder: (context, index) {
        final category = categories[index];
        final entries = ref.watch(sortedCategoryEntriesProvider(category.id));
        final hasPrev = index > 0;
        final prevIsNonEmpty = hasPrev
            ? ref
                  .watch(
                    sortedCategoryEntriesProvider(categories[index - 1].id),
                  )
                  .isNotEmpty
            : false;
        final isFirstEmptyAfterNonEmpty =
            entries.isEmpty && (!hasPrev || prevIsNonEmpty);

        return AnimatedSwitcher(
          duration: const Duration(milliseconds: 300),
          switchInCurve: Curves.easeInOut,
          switchOutCurve: Curves.easeInOut,
          layoutBuilder: (currentChild, previousChildren) => Stack(
            alignment: Alignment.topCenter,
            children: [
              ...previousChildren,
              if (currentChild != null) currentChild,
            ],
          ),
          transitionBuilder: (child, animation) => FadeTransition(
            opacity: animation,
            child: SizeTransition(
              sizeFactor: animation,
              axisAlignment: -1.0,
              child: child,
            ),
          ),
          child: KeyedSubtree(
            key: ValueKey(
              'cat-${category.id}-${entries.isEmpty ? 'empty' : 'full'}',
            ),
            child: CategoryItem(
              category: category,
              entries: entries,
              isWide: isWide,
              colorScheme: colorScheme,
              hoveredService: hoveredService,
              selectedService: selectedService,
              onAddService: () => onAddService(category),
              onAddPackage: () => onAddPackage(category),
              onEditCategory: () => onEditCategory(category),
              onDeleteCategory: () => onDeleteCategory(category.id),
              onDeleteBlocked: onDeleteCategoryBlocked,
              onServiceOpen: onServiceOpen,
              onServiceEdit: onServiceEdit,
              onServiceDuplicate: onServiceDuplicate,
              onServiceDelete: onServiceDelete,
              onPackageOpen: onPackageOpen,
              onPackageEdit: onPackageEdit,
              onPackageDelete: onPackageDelete,
              addTopSpacing: isFirstEmptyAfterNonEmpty,
              readOnly: readOnly,
            ),
          ),
        );
      },
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/category_tile.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service_category.dart';
import '../../providers/service_categories_provider.dart';

class CategoryTile extends ConsumerWidget {
  const CategoryTile({super.key, required this.category, this.onEdit});

  final ServiceCategory category;
  final VoidCallback? onEdit;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    return InkWell(
      onTap: onEdit,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: theme.cardColor,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: theme.dividerColor.withOpacity(0.4)),
        ),
        child: Row(
          children: [
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(category.name, style: theme.textTheme.titleMedium),
                  if (category.description != null &&
                      category.description!.isNotEmpty)
                    Padding(
                      padding: const EdgeInsets.only(top: 4),
                      child: Text(
                        category.description!,
                        style: theme.textTheme.bodySmall,
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                ],
              ),
            ),
            IconButton(
              tooltip: context.l10n.actionEdit,
              icon: const Icon(Icons.edit_outlined),
              onPressed: onEdit,
            ),
            IconButton(
              tooltip: context.l10n.actionDelete,
              icon: const Icon(Icons.delete_outline, color: Colors.redAccent),
              onPressed: () => _confirmDelete(context, ref),
            ),
          ],
        ),
      ),
    );
  }

  void _confirmDelete(BuildContext context, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (_) => AlertDialog(
        title: Text(context.l10n.deleteConfirmationTitle),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text(context.l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () async {
              await ref
                  .read(serviceCategoriesProvider.notifier)
                  .deleteCategoryApi(category.id);
              if (context.mounted) Navigator.of(context).pop();
            },
            child: Text(context.l10n.actionDelete),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/reports/providers/reports_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../core/network/network_providers.dart';
import '../domain/report_models.dart';

/// Parameters for fetching a report.
class ReportParams {
  const ReportParams({
    required this.businessId,
    required this.startDate,
    required this.endDate,
    this.locationIds = const [],
    this.staffIds = const [],
    this.serviceIds = const [],
    this.statuses = const [
      'confirmed',
      'completed',
    ],
  });

  final int businessId;
  final DateTime startDate;
  final DateTime endDate;
  final List<int> locationIds;
  final List<int> staffIds;
  final List<int> serviceIds;
  final List<String> statuses;

  ReportParams copyWith({
    int? businessId,
    DateTime? startDate,
    DateTime? endDate,
    List<int>? locationIds,
    List<int>? staffIds,
    List<int>? serviceIds,
    List<String>? statuses,
  }) {
    return ReportParams(
      businessId: businessId ?? this.businessId,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      locationIds: locationIds ?? this.locationIds,
      staffIds: staffIds ?? this.staffIds,
      serviceIds: serviceIds ?? this.serviceIds,
      statuses: statuses ?? this.statuses,
    );
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ReportParams &&
          runtimeType == other.runtimeType &&
          businessId == other.businessId &&
          startDate == other.startDate &&
          endDate == other.endDate &&
          _listEquals(locationIds, other.locationIds) &&
          _listEquals(staffIds, other.staffIds) &&
          _listEquals(serviceIds, other.serviceIds) &&
          _listEquals(statuses, other.statuses);

  @override
  int get hashCode =>
      businessId.hashCode ^
      startDate.hashCode ^
      endDate.hashCode ^
      locationIds.hashCode ^
      staffIds.hashCode ^
      serviceIds.hashCode ^
      statuses.hashCode;

  bool _listEquals<T>(List<T> a, List<T> b) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }
}

/// State for the reports screen.
class ReportsState {
  const ReportsState({
    this.params,
    this.report,
    this.isLoading = false,
    this.error,
  });

  final ReportParams? params;
  final AppointmentsReport? report;
  final bool isLoading;
  final String? error;

  ReportsState copyWith({
    ReportParams? params,
    AppointmentsReport? report,
    bool? isLoading,
    String? error,
    bool clearError = false,
    bool clearReport = false,
  }) {
    return ReportsState(
      params: params ?? this.params,
      report: clearReport ? null : (report ?? this.report),
      isLoading: isLoading ?? this.isLoading,
      error: clearError ? null : (error ?? this.error),
    );
  }
}

/// Notifier for reports state.
class ReportsNotifier extends Notifier<ReportsState> {
  @override
  ReportsState build() {
    return const ReportsState();
  }

  /// Sets the filter parameters and fetches the report.
  Future<void> fetchReport(ReportParams params) async {
    state = state.copyWith(params: params, isLoading: true, clearError: true);

    try {
      final apiClient = ref.read(apiClientProvider);
      final dateFormat = DateFormat('yyyy-MM-dd');

      final queryParams = <String, dynamic>{
        'business_id': params.businessId.toString(),
        'start_date': dateFormat.format(params.startDate),
        'end_date': dateFormat.format(params.endDate),
        'status': params.statuses.join(','),
      };

      if (params.locationIds.isNotEmpty) {
        queryParams['location_ids[]'] = params.locationIds
            .map((e) => e.toString())
            .toList();
      }
      if (params.staffIds.isNotEmpty) {
        queryParams['staff_ids[]'] = params.staffIds
            .map((e) => e.toString())
            .toList();
      }
      if (params.serviceIds.isNotEmpty) {
        queryParams['service_ids[]'] = params.serviceIds
            .map((e) => e.toString())
            .toList();
      }

      final response = await apiClient.get(
        '/v1/reports/appointments',
        queryParameters: queryParams,
      );

      final report = AppointmentsReport.fromJson(response);
      state = state.copyWith(report: report, isLoading: false);
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }

  /// Refreshes the report using the last params.
  Future<void> refresh() async {
    final params = state.params;
    if (params != null) {
      await fetchReport(params);
    }
  }

  /// Clears the report.
  void clear() {
    state = const ReportsState();
  }
}

/// Provider for reports state.
final reportsProvider = NotifierProvider<ReportsNotifier, ReportsState>(
  ReportsNotifier.new,
);

// ============================================================================
// WORK HOURS REPORT
// ============================================================================

/// State for the work hours report.
class WorkHoursReportState {
  const WorkHoursReportState({
    this.params,
    this.report,
    this.isLoading = false,
    this.error,
  });

  final ReportParams? params;
  final WorkHoursReport? report;
  final bool isLoading;
  final String? error;

  WorkHoursReportState copyWith({
    ReportParams? params,
    WorkHoursReport? report,
    bool? isLoading,
    String? error,
    bool clearError = false,
    bool clearReport = false,
  }) {
    return WorkHoursReportState(
      params: params ?? this.params,
      report: clearReport ? null : (report ?? this.report),
      isLoading: isLoading ?? this.isLoading,
      error: clearError ? null : (error ?? this.error),
    );
  }
}

/// Notifier for work hours report state.
class WorkHoursReportNotifier extends Notifier<WorkHoursReportState> {
  @override
  WorkHoursReportState build() {
    return const WorkHoursReportState();
  }

  /// Fetches the work hours report.
  Future<void> fetchReport(ReportParams params) async {
    state = state.copyWith(params: params, isLoading: true, clearError: true);

    try {
      final apiClient = ref.read(apiClientProvider);
      final dateFormat = DateFormat('yyyy-MM-dd');

      final queryParams = <String, dynamic>{
        'business_id': params.businessId.toString(),
        'start_date': dateFormat.format(params.startDate),
        'end_date': dateFormat.format(params.endDate),
      };

      if (params.locationIds.isNotEmpty) {
        queryParams['location_ids[]'] = params.locationIds
            .map((e) => e.toString())
            .toList();
      }
      if (params.staffIds.isNotEmpty) {
        queryParams['staff_ids[]'] = params.staffIds
            .map((e) => e.toString())
            .toList();
      }

      final response = await apiClient.get(
        '/v1/reports/work-hours',
        queryParameters: queryParams,
      );

      final report = WorkHoursReport.fromJson(response);
      state = state.copyWith(report: report, isLoading: false);
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }

  /// Refreshes the report using the last params.
  Future<void> refresh() async {
    final params = state.params;
    if (params != null) {
      await fetchReport(params);
    }
  }

  /// Clears the report.
  void clear() {
    state = const WorkHoursReportState();
  }
}

/// Provider for work hours report state.
final workHoursReportProvider =
    NotifierProvider<WorkHoursReportNotifier, WorkHoursReportState>(
      WorkHoursReportNotifier.new,
    );
--- FILE: lib/features/reports/providers/reports_filter_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// State for Reports screen filters - shared between shell AppBar and ReportsScreen
class ReportsFilterState {
  const ReportsFilterState({
    required this.startDate,
    required this.endDate,
    this.selectedPreset = 'custom',
    this.useFullPeriod = false,
  });

  final DateTime startDate;
  final DateTime endDate;
  final String selectedPreset;
  final bool useFullPeriod;

  ReportsFilterState copyWith({
    DateTime? startDate,
    DateTime? endDate,
    String? selectedPreset,
    bool? useFullPeriod,
  }) {
    return ReportsFilterState(
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      selectedPreset: selectedPreset ?? this.selectedPreset,
      useFullPeriod: useFullPeriod ?? this.useFullPeriod,
    );
  }
}

class ReportsFilterNotifier extends Notifier<ReportsFilterState> {
  @override
  ReportsFilterState build() {
    final today = DateUtils.dateOnly(DateTime.now());
    return ReportsFilterState(
      startDate: today,
      endDate: today,
      selectedPreset: 'today',
      useFullPeriod: false,
    );
  }

  void setDateRange(DateTime start, DateTime end) {
    state = state.copyWith(
      startDate: start,
      endDate: end,
      selectedPreset: 'custom',
    );
  }

  void setPreset(String preset) {
    state = state.copyWith(selectedPreset: preset);
  }

  void setFullPeriod(bool value) {
    state = state.copyWith(useFullPeriod: value);
  }

  void applyPreset(String preset) {
    final now = DateTime.now();
    final today = DateUtils.dateOnly(now);
    final useFullPeriod = state.useFullPeriod;

    DateTime startDate;
    DateTime endDate;

    switch (preset) {
      case 'today':
        startDate = today;
        endDate = today;
        break;
      case 'month':
        startDate = DateTime(now.year, now.month, 1);
        endDate = useFullPeriod ? DateTime(now.year, now.month + 1, 0) : today;
        break;
      case 'quarter':
        final quarterStartMonth = ((now.month - 1) ~/ 3) * 3 + 1;
        startDate = DateTime(now.year, quarterStartMonth, 1);
        endDate = useFullPeriod
            ? DateTime(now.year, quarterStartMonth + 3, 0)
            : today;
        break;
      case 'semester':
        final semesterStartMonth = now.month <= 6 ? 1 : 7;
        startDate = DateTime(now.year, semesterStartMonth, 1);
        endDate = useFullPeriod
            ? DateTime(now.year, semesterStartMonth + 6, 0)
            : today;
        break;
      case 'year':
        startDate = DateTime(now.year, 1, 1);
        endDate = useFullPeriod ? DateTime(now.year, 12, 31) : today;
        break;
      case 'last_month':
        final lastMonth = DateTime(now.year, now.month - 1, 1);
        startDate = lastMonth;
        endDate = DateTime(now.year, now.month, 0);
        break;
      case 'last_3_months':
        startDate = DateTime(now.year, now.month - 3, 1);
        endDate = DateTime(now.year, now.month, 0);
        break;
      case 'last_6_months':
        startDate = DateTime(now.year, now.month - 6, 1);
        endDate = DateTime(now.year, now.month, 0);
        break;
      case 'last_year':
        startDate = DateTime(now.year - 1, 1, 1);
        endDate = DateTime(now.year - 1, 12, 31);
        break;
      default:
        // custom - keep current dates
        startDate = state.startDate;
        endDate = state.endDate;
    }

    state = ReportsFilterState(
      startDate: startDate,
      endDate: endDate,
      selectedPreset: preset,
      useFullPeriod: useFullPeriod,
    );
  }
}

final reportsFilterProvider =
    NotifierProvider<ReportsFilterNotifier, ReportsFilterState>(
      ReportsFilterNotifier.new,
    );
--- FILE: lib/features/reports/domain/report_models.dart ---
/// Report data models for appointment statistics.
library;

import 'package:flutter/foundation.dart';

/// Summary metrics for the report.
@immutable
class ReportSummary {
  const ReportSummary({
    required this.totalAppointments,
    required this.totalBookings,
    required this.totalRevenue,
    required this.totalDurationMinutes,
    required this.uniqueClients,
    required this.cancelledCount,
    required this.onlineCount,
    required this.manualCount,
    required this.availableMinutes,
    required this.occupancyPercentage,
  });

  final int totalAppointments;
  final int totalBookings;
  final double totalRevenue;
  final int totalDurationMinutes;
  final int uniqueClients;
  final int cancelledCount;
  final int onlineCount;
  final int manualCount;
  final int availableMinutes;
  final double occupancyPercentage;

  factory ReportSummary.fromJson(Map<String, dynamic> json) {
    return ReportSummary(
      totalAppointments: json['total_appointments'] as int? ?? 0,
      totalBookings: json['total_bookings'] as int? ?? 0,
      totalRevenue: (json['total_revenue'] as num?)?.toDouble() ?? 0.0,
      totalDurationMinutes: json['total_duration_minutes'] as int? ?? 0,
      uniqueClients: json['unique_clients'] as int? ?? 0,
      cancelledCount: json['cancelled_count'] as int? ?? 0,
      onlineCount: json['online_count'] as int? ?? 0,
      manualCount: json['manual_count'] as int? ?? 0,
      availableMinutes: json['available_minutes'] as int? ?? 0,
      occupancyPercentage:
          (json['occupancy_percentage'] as num?)?.toDouble() ?? 0.0,
    );
  }

  /// Returns total hours worked.
  double get totalHours => totalDurationMinutes / 60.0;

  /// Returns total available hours.
  double get availableHours => availableMinutes / 60.0;

  /// Returns average revenue per appointment.
  double get avgRevenuePerAppointment =>
      totalAppointments > 0 ? totalRevenue / totalAppointments : 0.0;
}

/// Staff breakdown row.
@immutable
class StaffReportRow {
  const StaffReportRow({
    required this.staffId,
    required this.staffName,
    this.staffColor,
    required this.appointments,
    required this.revenue,
    required this.durationMinutes,
  });

  final int staffId;
  final String staffName;
  final String? staffColor;
  final int appointments;
  final double revenue;
  final int durationMinutes;

  factory StaffReportRow.fromJson(Map<String, dynamic> json) {
    return StaffReportRow(
      staffId: json['staff_id'] as int,
      staffName: json['staff_name'] as String? ?? 'Unknown',
      staffColor: json['staff_color'] as String?,
      appointments: json['appointments'] as int? ?? 0,
      revenue: (json['revenue'] as num?)?.toDouble() ?? 0.0,
      durationMinutes: json['duration_minutes'] as int? ?? 0,
    );
  }

  double get hours => durationMinutes / 60.0;
  double get avgRevenue => appointments > 0 ? revenue / appointments : 0.0;
}

/// Location breakdown row.
@immutable
class LocationReportRow {
  const LocationReportRow({
    required this.locationId,
    required this.locationName,
    required this.appointments,
    required this.revenue,
    required this.durationMinutes,
  });

  final int locationId;
  final String locationName;
  final int appointments;
  final double revenue;
  final int durationMinutes;

  factory LocationReportRow.fromJson(Map<String, dynamic> json) {
    return LocationReportRow(
      locationId: json['location_id'] as int,
      locationName: json['location_name'] as String? ?? 'Unknown',
      appointments: json['appointments'] as int? ?? 0,
      revenue: (json['revenue'] as num?)?.toDouble() ?? 0.0,
      durationMinutes: json['duration_minutes'] as int? ?? 0,
    );
  }

  double get hours => durationMinutes / 60.0;
}

/// Service breakdown row.
@immutable
class ServiceReportRow {
  const ServiceReportRow({
    required this.serviceId,
    required this.serviceName,
    this.categoryName,
    required this.appointments,
    required this.revenue,
    required this.avgDurationMinutes,
  });

  final int serviceId;
  final String serviceName;
  final String? categoryName;
  final int appointments;
  final double revenue;
  final int avgDurationMinutes;

  factory ServiceReportRow.fromJson(Map<String, dynamic> json) {
    return ServiceReportRow(
      serviceId: json['service_id'] as int,
      serviceName: json['service_name'] as String? ?? 'Unknown',
      categoryName: json['category_name'] as String?,
      appointments: json['appointments'] as int? ?? 0,
      revenue: (json['revenue'] as num?)?.toDouble() ?? 0.0,
      avgDurationMinutes: json['avg_duration_minutes'] as int? ?? 0,
    );
  }
}

/// Day of week breakdown row.
@immutable
class DayOfWeekReportRow {
  const DayOfWeekReportRow({
    required this.dayOfWeek,
    required this.appointments,
    required this.revenue,
  });

  /// 1 = Sunday, 2 = Monday, ..., 7 = Saturday (MySQL DAYOFWEEK)
  final int dayOfWeek;
  final int appointments;
  final double revenue;

  factory DayOfWeekReportRow.fromJson(Map<String, dynamic> json) {
    return DayOfWeekReportRow(
      dayOfWeek: json['day_of_week'] as int,
      appointments: json['appointments'] as int? ?? 0,
      revenue: (json['revenue'] as num?)?.toDouble() ?? 0.0,
    );
  }

  /// Returns ISO weekday (1 = Monday, 7 = Sunday).
  int get isoWeekday {
    // MySQL: 1=Sun, 2=Mon, ..., 7=Sat
    // ISO: 1=Mon, ..., 7=Sun
    return dayOfWeek == 1 ? 7 : dayOfWeek - 1;
  }
}

/// Period breakdown row (daily/weekly/monthly).
@immutable
class PeriodReportRow {
  const PeriodReportRow({
    required this.periodStart,
    required this.appointments,
    required this.revenue,
    required this.durationMinutes,
  });

  final DateTime periodStart;
  final int appointments;
  final double revenue;
  final int durationMinutes;

  factory PeriodReportRow.fromJson(Map<String, dynamic> json) {
    return PeriodReportRow(
      periodStart: DateTime.parse(json['period_start'] as String),
      appointments: json['appointments'] as int? ?? 0,
      revenue: (json['revenue'] as num?)?.toDouble() ?? 0.0,
      durationMinutes: json['duration_minutes'] as int? ?? 0,
    );
  }

  double get hours => durationMinutes / 60.0;
}

/// Hour breakdown row.
@immutable
class HourReportRow {
  const HourReportRow({
    required this.hour,
    required this.appointments,
    required this.revenue,
  });

  final int hour;
  final int appointments;
  final double revenue;

  factory HourReportRow.fromJson(Map<String, dynamic> json) {
    return HourReportRow(
      hour: json['hour'] as int,
      appointments: json['appointments'] as int? ?? 0,
      revenue: (json['revenue'] as num?)?.toDouble() ?? 0.0,
    );
  }
}

/// Period breakdown with granularity info.
@immutable
class PeriodBreakdown {
  const PeriodBreakdown({required this.granularity, required this.data});

  /// 'day', 'week', or 'month'
  final String granularity;
  final List<PeriodReportRow> data;

  factory PeriodBreakdown.fromJson(Map<String, dynamic> json) {
    final dataList = json['data'] as List<dynamic>? ?? [];
    return PeriodBreakdown(
      granularity: json['granularity'] as String? ?? 'day',
      data: dataList
          .map((e) => PeriodReportRow.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }
}

/// Filter parameters used for the report.
@immutable
class ReportFilters {
  const ReportFilters({
    required this.startDate,
    required this.endDate,
    required this.locationIds,
    required this.staffIds,
    required this.serviceIds,
    required this.statuses,
  });

  final DateTime startDate;
  final DateTime endDate;
  final List<int> locationIds;
  final List<int> staffIds;
  final List<int> serviceIds;
  final List<String> statuses;

  factory ReportFilters.fromJson(Map<String, dynamic> json) {
    return ReportFilters(
      startDate: DateTime.parse(json['start_date'] as String),
      endDate: DateTime.parse(json['end_date'] as String),
      locationIds:
          (json['location_ids'] as List<dynamic>?)
              ?.map((e) => e as int)
              .toList() ??
          [],
      staffIds:
          (json['staff_ids'] as List<dynamic>?)
              ?.map((e) => e as int)
              .toList() ??
          [],
      serviceIds:
          (json['service_ids'] as List<dynamic>?)
              ?.map((e) => e as int)
              .toList() ??
          [],
      statuses:
          (json['statuses'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toList() ??
          [],
    );
  }
}

/// Complete report response.
@immutable
class AppointmentsReport {
  const AppointmentsReport({
    required this.summary,
    required this.byStaff,
    required this.byLocation,
    required this.byService,
    required this.byDayOfWeek,
    required this.byPeriod,
    required this.byHour,
    required this.filters,
  });

  final ReportSummary summary;
  final List<StaffReportRow> byStaff;
  final List<LocationReportRow> byLocation;
  final List<ServiceReportRow> byService;
  final List<DayOfWeekReportRow> byDayOfWeek;
  final PeriodBreakdown byPeriod;
  final List<HourReportRow> byHour;
  final ReportFilters filters;

  factory AppointmentsReport.fromJson(Map<String, dynamic> json) {
    return AppointmentsReport(
      summary: ReportSummary.fromJson(json['summary'] as Map<String, dynamic>),
      byStaff: (json['by_staff'] as List<dynamic>)
          .map((e) => StaffReportRow.fromJson(e as Map<String, dynamic>))
          .toList(),
      byLocation: (json['by_location'] as List<dynamic>)
          .map((e) => LocationReportRow.fromJson(e as Map<String, dynamic>))
          .toList(),
      byService: (json['by_service'] as List<dynamic>)
          .map((e) => ServiceReportRow.fromJson(e as Map<String, dynamic>))
          .toList(),
      byDayOfWeek: (json['by_day_of_week'] as List<dynamic>)
          .map((e) => DayOfWeekReportRow.fromJson(e as Map<String, dynamic>))
          .toList(),
      byPeriod: PeriodBreakdown.fromJson(
        json['by_period'] as Map<String, dynamic>,
      ),
      byHour: (json['by_hour'] as List<dynamic>)
          .map((e) => HourReportRow.fromJson(e as Map<String, dynamic>))
          .toList(),
      filters: ReportFilters.fromJson(json['filters'] as Map<String, dynamic>),
    );
  }
}

// ============================================================================
// WORK HOURS REPORT MODELS
// ============================================================================

/// Summary for work hours report.
@immutable
class WorkHoursSummary {
  const WorkHoursSummary({
    required this.totalScheduledMinutes,
    required this.totalWorkedMinutes,
    required this.totalBlockedMinutes,
    required this.totalExceptionOffMinutes,
    required this.totalAvailableMinutes,
    required this.overallUtilizationPercentage,
  });

  final int totalScheduledMinutes;
  final int totalWorkedMinutes;
  final int totalBlockedMinutes;
  final int totalExceptionOffMinutes;
  final int totalAvailableMinutes;
  final double overallUtilizationPercentage;

  factory WorkHoursSummary.fromJson(Map<String, dynamic> json) {
    return WorkHoursSummary(
      totalScheduledMinutes: json['total_scheduled_minutes'] as int? ?? 0,
      totalWorkedMinutes: json['total_worked_minutes'] as int? ?? 0,
      totalBlockedMinutes: json['total_blocked_minutes'] as int? ?? 0,
      totalExceptionOffMinutes:
          json['total_exception_off_minutes'] as int? ?? 0,
      totalAvailableMinutes: json['total_available_minutes'] as int? ?? 0,
      overallUtilizationPercentage:
          (json['overall_utilization_percentage'] as num?)?.toDouble() ?? 0.0,
    );
  }

  /// Returns total scheduled hours.
  double get totalScheduledHours => totalScheduledMinutes / 60.0;

  /// Returns total worked hours.
  double get totalWorkedHours => totalWorkedMinutes / 60.0;

  /// Returns total blocked hours.
  double get totalBlockedHours => totalBlockedMinutes / 60.0;

  /// Returns total exception off hours (ferie, malattia, ecc.).
  double get totalExceptionOffHours => totalExceptionOffMinutes / 60.0;

  /// Returns total available hours (scheduled - blocked).
  double get totalAvailableHours => totalAvailableMinutes / 60.0;
}

/// Staff row for work hours report.
@immutable
class StaffWorkHoursRow {
  const StaffWorkHoursRow({
    required this.staffId,
    required this.staffName,
    this.staffColor,
    required this.scheduledMinutes,
    required this.workedMinutes,
    required this.blockedMinutes,
    required this.exceptionOffMinutes,
    required this.availableMinutes,
    required this.utilizationPercentage,
  });

  final int staffId;
  final String staffName;
  final String? staffColor;
  final int scheduledMinutes;
  final int workedMinutes;
  final int blockedMinutes;
  final int exceptionOffMinutes;
  final int availableMinutes;
  final double utilizationPercentage;

  factory StaffWorkHoursRow.fromJson(Map<String, dynamic> json) {
    return StaffWorkHoursRow(
      staffId: json['staff_id'] as int,
      staffName: json['staff_name'] as String? ?? 'Unknown',
      staffColor: json['staff_color'] as String?,
      scheduledMinutes: json['scheduled_minutes'] as int? ?? 0,
      workedMinutes: json['worked_minutes'] as int? ?? 0,
      blockedMinutes: json['blocked_minutes'] as int? ?? 0,
      exceptionOffMinutes: json['exception_off_minutes'] as int? ?? 0,
      availableMinutes: json['available_minutes'] as int? ?? 0,
      utilizationPercentage:
          (json['utilization_percentage'] as num?)?.toDouble() ?? 0.0,
    );
  }

  double get scheduledHours => scheduledMinutes / 60.0;
  double get workedHours => workedMinutes / 60.0;
  double get blockedHours => blockedMinutes / 60.0;
  double get exceptionOffHours => exceptionOffMinutes / 60.0;
  double get availableHours => availableMinutes / 60.0;
}

/// Complete work hours report response.
@immutable
class WorkHoursReport {
  const WorkHoursReport({
    required this.summary,
    required this.byStaff,
    required this.filters,
  });

  final WorkHoursSummary summary;
  final List<StaffWorkHoursRow> byStaff;
  final ReportFilters filters;

  factory WorkHoursReport.fromJson(Map<String, dynamic> json) {
    return WorkHoursReport(
      summary: WorkHoursSummary.fromJson(
        json['summary'] as Map<String, dynamic>,
      ),
      byStaff: (json['by_staff'] as List<dynamic>)
          .map((e) => StaffWorkHoursRow.fromJson(e as Map<String, dynamic>))
          .toList(),
      filters: ReportFilters.fromJson(json['filters'] as Map<String, dynamic>),
    );
  }
}
--- FILE: lib/features/reports/presentation/reports_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../app/providers/form_factor_provider.dart';
import '../../../app/widgets/staff_circle_avatar.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/models/staff.dart';
import '../../../core/widgets/feedback_dialog.dart';
import '../../agenda/providers/location_providers.dart';
import '../../auth/providers/auth_provider.dart';
import '../../services/providers/service_categories_provider.dart';
import '../../services/providers/services_provider.dart';
import '../../staff/providers/staff_providers.dart';
import '../domain/report_models.dart';
import '../providers/reports_filter_provider.dart';
import '../providers/reports_provider.dart';
import '../widgets/reports_header.dart';

/// Screen for viewing appointment reports.
/// Only accessible to admin/owner users.
/// Note: This screen is displayed inside ScaffoldWithNavigation,
/// so it should NOT have its own Scaffold/AppBar.
class ReportsScreen extends ConsumerStatefulWidget {
  const ReportsScreen({super.key});

  @override
  ConsumerState<ReportsScreen> createState() => _ReportsScreenState();
}

class _ReportsScreenState extends ConsumerState<ReportsScreen>
    with SingleTickerProviderStateMixin {
  static const List<String> _allReportStatuses = <String>[
    'confirmed',
    'completed',
    'cancelled',
    'no_show',
  ];

  final Set<int> _selectedLocationIds = {};
  final Set<int> _selectedStaffIds = {};
  final Set<int> _selectedServiceIds = {};
  Set<String> _selectedStatuses = {'confirmed', 'completed'};

  late final TabController _tabController;

  /// 0 = Appointments report, 1 = Work Hours report
  int _currentTab = 0;

  List<Staff> _staffScopedByLocations({
    required List<Staff> staff,
    required Set<int> visibleLocationIds,
    Set<int>? selectedLocationIds,
  }) {
    final scopeLocationIds =
        (selectedLocationIds != null && selectedLocationIds.isNotEmpty)
        ? selectedLocationIds
        : visibleLocationIds;

    return staff.where((s) {
      if (s.locationIds.isEmpty) return true;
      return s.locationIds.any(scopeLocationIds.contains);
    }).toList();
  }

  List<Service> _servicesScopedByLocations({
    required List<Service> services,
    required Set<int> visibleLocationIds,
    Set<int>? selectedLocationIds,
  }) {
    final scopeLocationIds =
        (selectedLocationIds != null && selectedLocationIds.isNotEmpty)
        ? selectedLocationIds
        : visibleLocationIds;

    return services.where((s) {
      if (s.locationId == null) return true;
      return scopeLocationIds.contains(s.locationId);
    }).toList();
  }

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _tabController.addListener(_onTabChanged);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _fetchReport();
    });
  }

  @override
  void dispose() {
    _tabController.removeListener(_onTabChanged);
    _tabController.dispose();
    super.dispose();
  }

  void _onTabChanged() {
    if (_tabController.indexIsChanging) return;
    setState(() {
      _currentTab = _tabController.index;
    });
    // Fetch appropriate report for the new tab
    if (_currentTab == 0) {
      _fetchReport();
    } else {
      _fetchWorkHoursReport();
    }
  }

  void _fetchReport() {
    final user = ref.read(authProvider).user;
    if (user == null) return;

    // Get filter state from provider
    final filterState = ref.read(reportsFilterProvider);

    // Get current business ID
    final location = ref.read(currentLocationProvider);
    final businessId = location.businessId;

    final params = ReportParams(
      businessId: businessId,
      startDate: filterState.startDate,
      endDate: filterState.endDate,
      locationIds: _selectedLocationIds.toList(),
      staffIds: _selectedStaffIds.toList(),
      serviceIds: _selectedServiceIds.toList(),
      statuses: _selectedStatuses.toList(),
    );

    ref.read(reportsProvider.notifier).fetchReport(params);
  }

  void _fetchWorkHoursReport() {
    final user = ref.read(authProvider).user;
    if (user == null) return;

    // Get filter state from provider
    final filterState = ref.read(reportsFilterProvider);

    // Get current business ID
    final location = ref.read(currentLocationProvider);
    final businessId = location.businessId;

    final params = ReportParams(
      businessId: businessId,
      startDate: filterState.startDate,
      endDate: filterState.endDate,
      locationIds: _selectedLocationIds.toList(),
      staffIds: _selectedStaffIds.toList(),
      serviceIds: [],
      statuses: [],
    );

    ref.read(workHoursReportProvider.notifier).fetchReport(params);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final reportState = ref.watch(reportsProvider);
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    // Watch filter changes to refetch
    ref.listen(reportsFilterProvider, (prev, next) {
      if (prev != null &&
          (prev.startDate != next.startDate ||
              prev.endDate != next.endDate ||
              prev.selectedPreset != next.selectedPreset)) {
        // Fetch the appropriate report based on current tab
        if (_currentTab == 0) {
          _fetchReport();
        } else {
          _fetchWorkHoursReport();
        }
      }
    });

    // Listen for errors
    ref.listen<ReportsState>(reportsProvider, (prev, next) {
      if (next.error != null && prev?.error != next.error) {
        FeedbackDialog.showError(
          context,
          title: l10n.errorTitle,
          message: next.error!,
        );
      }
    });

    // Listen for work hours report errors
    ref.listen<WorkHoursReportState>(workHoursReportProvider, (prev, next) {
      if (next.error != null && prev?.error != next.error) {
        FeedbackDialog.showError(
          context,
          title: l10n.errorTitle,
          message: next.error!,
        );
      }
    });

    // No Scaffold here - shell provides it
    return Column(
      children: [
        // Header with period controls
        const ReportsHeader(),

        // TabBar
        _buildTabBar(context, colorScheme),

        // Filters section
        _buildFiltersSection(context, colorScheme),

        // Content
        Expanded(
          child: TabBarView(
            controller: _tabController,
            children: [
              // Tab 0: Appointments report
              _buildAppointmentsReportTab(
                context,
                reportState,
                theme,
                colorScheme,
              ),
              // Tab 1: Work Hours report
              _buildWorkHoursReportTab(context, theme, colorScheme),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildTabBar(BuildContext context, ColorScheme colorScheme) {
    final l10n = context.l10n;

    return Container(
      decoration: BoxDecoration(
        color: colorScheme.surface,
        border: Border(
          bottom: BorderSide(color: colorScheme.outline.withOpacity(0.2)),
        ),
      ),
      child: TabBar(
        controller: _tabController,
        labelColor: colorScheme.primary,
        unselectedLabelColor: colorScheme.onSurfaceVariant,
        indicatorColor: colorScheme.primary,
        tabs: [
          Tab(text: l10n.reportsTabAppointments),
          Tab(text: l10n.reportsTabStaff),
        ],
      ),
    );
  }

  Widget _buildAppointmentsReportTab(
    BuildContext context,
    ReportsState reportState,
    ThemeData theme,
    ColorScheme colorScheme,
  ) {
    final l10n = context.l10n;

    if (reportState.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (reportState.report == null) {
      return Center(
        child: Text(
          l10n.reportsNoData,
          style: theme.textTheme.bodyLarge?.copyWith(
            color: colorScheme.onSurfaceVariant,
          ),
        ),
      );
    }

    return _buildReportContent(context, reportState.report!);
  }

  Widget _buildWorkHoursReportTab(
    BuildContext context,
    ThemeData theme,
    ColorScheme colorScheme,
  ) {
    final l10n = context.l10n;
    final workHoursState = ref.watch(workHoursReportProvider);

    if (workHoursState.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (workHoursState.report == null) {
      return Center(
        child: Text(
          l10n.reportsNoData,
          style: theme.textTheme.bodyLarge?.copyWith(
            color: colorScheme.onSurfaceVariant,
          ),
        ),
      );
    }

    return _buildWorkHoursContent(context, workHoursState.report!);
  }

  Widget _buildFiltersSection(BuildContext context, ColorScheme colorScheme) {
    final l10n = context.l10n;
    final filterState = ref.watch(reportsFilterProvider);

    // Determine which filters to show based on current tab
    final isWorkHoursTab = _currentTab == 1;

    return Container(
      alignment: Alignment.centerLeft,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerLow,
        border: Border(
          bottom: BorderSide(color: colorScheme.outline.withOpacity(0.2)),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Filter chips - show only if relevant
          Builder(
            builder: (context) {
              final locations = ref.watch(locationsProvider);
              final staff = ref.watch(allStaffProvider).value ?? [];
              final services = ref.watch(servicesProvider).value ?? [];
              final visibleLocationIds = locations.map((l) => l.id).toSet();
              final filteredStaff = _staffScopedByLocations(
                staff: staff,
                visibleLocationIds: visibleLocationIds,
                selectedLocationIds: _selectedLocationIds,
              );
              final filteredServices = _servicesScopedByLocations(
                services: services,
                visibleLocationIds: visibleLocationIds,
                selectedLocationIds: _selectedLocationIds,
              );

              final hasMultipleLocations = locations.length > 1;
              final hasMultipleStaff = filteredStaff.length > 1;
              final hasMultipleServices = filteredServices.length > 1;

              return Wrap(
                alignment: WrapAlignment.start,
                spacing: 8,
                runSpacing: 8,
                children: [
                  if (hasMultipleLocations)
                    _buildFilterChip(
                      context,
                      label: _selectedLocationIds.isEmpty
                          ? l10n.reportsFilterLocations
                          : '${l10n.reportsFilterLocations} (${_selectedLocationIds.length})',
                      selected: _selectedLocationIds.isNotEmpty,
                      onTap: () => _showLocationFilter(context),
                    ),
                  if (hasMultipleStaff)
                    _buildFilterChip(
                      context,
                      label: _selectedStaffIds.isEmpty
                          ? l10n.reportsFilterStaff
                          : '${l10n.reportsFilterStaff} (${_selectedStaffIds.length})',
                      selected: _selectedStaffIds.isNotEmpty,
                      onTap: () => _showStaffFilter(context),
                    ),
                  // Service and status filters are only relevant for appointments report
                  if (!isWorkHoursTab && hasMultipleServices)
                    _buildFilterChip(
                      context,
                      label: _selectedServiceIds.isEmpty
                          ? l10n.reportsFilterServices
                          : '${l10n.reportsFilterServices} (${_selectedServiceIds.length})',
                      selected: _selectedServiceIds.isNotEmpty,
                      onTap: () => _showServiceFilter(context),
                    ),
                  if (!isWorkHoursTab)
                    _buildFilterChip(
                      context,
                      label: l10n.reportsFilterStatus,
                      selected:
                          _selectedStatuses.length < _allReportStatuses.length,
                      onTap: () => _showStatusFilter(context),
                    ),
                ],
              );
            },
          ),

          // Full period toggle - show only on mobile/tablet (on desktop it's in AppBar)
          Builder(
            builder: (context) {
              final formFactor = ref.watch(formFactorProvider);
              final supportsFullPeriod =
                  filterState.selectedPreset != 'custom' &&
                  filterState.selectedPreset != 'today' &&
                  filterState.selectedPreset != 'last_month' &&
                  filterState.selectedPreset != 'last_3_months' &&
                  filterState.selectedPreset != 'last_6_months' &&
                  filterState.selectedPreset != 'last_year';

              if (!supportsFullPeriod || formFactor == AppFormFactor.desktop) {
                return const SizedBox.shrink();
              }

              return Padding(
                padding: const EdgeInsets.only(top: 12),
                child: Row(
                  children: [
                    Switch(
                      value: filterState.useFullPeriod,
                      onChanged: (value) {
                        final notifier = ref.read(
                          reportsFilterProvider.notifier,
                        );
                        notifier.setFullPeriod(value);
                        notifier.applyPreset(filterState.selectedPreset);
                      },
                    ),
                    const SizedBox(width: 8),
                    Text(
                      l10n.reportsFullPeriodToggle,
                      style: Theme.of(context).textTheme.bodyMedium,
                    ),
                  ],
                ),
              );
            },
          ),
        ],
      ),
    );
  }

  Widget _buildFilterChip(
    BuildContext context, {
    required String label,
    required bool selected,
    required VoidCallback onTap,
  }) {
    final colorScheme = Theme.of(context).colorScheme;

    return FilterChip(
      label: Text(label),
      selected: selected,
      onSelected: (_) => onTap(),
      selectedColor: colorScheme.primaryContainer,
      checkmarkColor: colorScheme.onPrimaryContainer,
    );
  }

  void _showLocationFilter(BuildContext context) async {
    final locations = ref.read(locationsProvider);
    if (locations.isEmpty) return;

    final selected = await showDialog<Set<int>>(
      context: context,
      builder: (ctx) => _LocationFilterDialog(
        locations: locations,
        selected: _selectedLocationIds,
      ),
    );

    if (selected != null) {
      final visibleLocationIds = locations.map((l) => l.id).toSet();
      final staff = ref.read(allStaffProvider).value ?? [];
      final services = ref.read(servicesProvider).value ?? [];
      final filteredStaff = _staffScopedByLocations(
        staff: staff,
        visibleLocationIds: visibleLocationIds,
        selectedLocationIds: selected,
      );
      final filteredServices = _servicesScopedByLocations(
        services: services,
        visibleLocationIds: visibleLocationIds,
        selectedLocationIds: selected,
      );
      final allowedStaffIds = filteredStaff.map((s) => s.id).toSet();
      final allowedServiceIds = filteredServices.map((s) => s.id).toSet();

      setState(() {
        _selectedLocationIds
          ..clear()
          ..addAll(selected);
        _selectedStaffIds.removeWhere((id) => !allowedStaffIds.contains(id));
        _selectedServiceIds.removeWhere(
          (id) => !allowedServiceIds.contains(id),
        );
      });
      _fetchReport();
    }
  }

  void _showStaffFilter(BuildContext context) async {
    final staff = ref.read(allStaffProvider).value ?? [];
    final visibleLocationIds = ref
        .read(locationsProvider)
        .map((l) => l.id)
        .toSet();
    final filteredStaff = _staffScopedByLocations(
      staff: staff,
      visibleLocationIds: visibleLocationIds,
      selectedLocationIds: _selectedLocationIds,
    );
    if (filteredStaff.isEmpty) return;

    final selected = await showDialog<Set<int>>(
      context: context,
      builder: (ctx) =>
          _StaffFilterDialog(staff: filteredStaff, selected: _selectedStaffIds),
    );

    if (selected != null) {
      setState(
        () => _selectedStaffIds
          ..clear()
          ..addAll(selected),
      );
      _fetchReport();
    }
  }

  void _showServiceFilter(BuildContext context) async {
    final services = ref.read(servicesProvider).value ?? [];
    final visibleLocationIds = ref
        .read(locationsProvider)
        .map((l) => l.id)
        .toSet();
    final filteredServices = _servicesScopedByLocations(
      services: services,
      visibleLocationIds: visibleLocationIds,
      selectedLocationIds: _selectedLocationIds,
    );
    final categories = ref.read(serviceCategoriesProvider);
    if (filteredServices.isEmpty) return;

    final selected = await showDialog<Set<int>>(
      context: context,
      builder: (ctx) => _ServiceFilterDialog(
        services: filteredServices,
        categories: categories,
        selected: _selectedServiceIds,
      ),
    );

    if (selected != null) {
      setState(
        () => _selectedServiceIds
          ..clear()
          ..addAll(selected),
      );
      _fetchReport();
    }
  }

  void _showStatusFilter(BuildContext context) async {
    final l10n = context.l10n;
    final allStatuses = {
      'confirmed': l10n.statusConfirmed,
      'completed': l10n.statusCompleted,
      'cancelled': l10n.statusCancelled,
      'no_show': l10n.bookingsListStatusNoShow,
    };

    final selected = await showDialog<Set<String>>(
      context: context,
      builder: (ctx) => _MultiSelectDialog<String>(
        title: l10n.reportsFilterStatus,
        items: allStatuses,
        selected: _selectedStatuses,
      ),
    );

    if (selected != null && selected.isNotEmpty) {
      setState(() => _selectedStatuses = selected);
      _fetchReport();
    }
  }

  Widget _buildReportContent(BuildContext context, AppointmentsReport report) {
    final filterState = ref.watch(reportsFilterProvider);

    // Determina quali sezioni mostrare in base al periodo selezionato
    final isSingleDay =
        filterState.selectedPreset == 'today' ||
        (filterState.startDate.year == filterState.endDate.year &&
            filterState.startDate.month == filterState.endDate.month &&
            filterState.startDate.day == filterState.endDate.day);

    // "Per Giorno della Settimana" non ha senso per un singolo giorno
    final showDayOfWeek = !isSingleDay;

    // "Per Periodo" non ha senso per un singolo giorno o per "oggi"
    final showPeriod = !isSingleDay;

    // "Per Operatore" non ha senso se filtrato per un solo staff
    final showByStaff =
        _selectedStaffIds.isEmpty || _selectedStaffIds.length > 1;

    // "Per Servizio" non ha senso se filtrato per un solo servizio
    final showByService =
        _selectedServiceIds.isEmpty || _selectedServiceIds.length > 1;

    // "Per Fascia Oraria" sempre utile tranne per periodi molto lunghi senza filtri
    final showByHour = true;

    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Summary cards
          _buildSummaryCards(context, report.summary),
          const SizedBox(height: 24),

          // Breakdown sections
          if (showByStaff) ...[
            _buildBreakdownSection(
              context,
              title: context.l10n.reportsByStaff,
              child: _buildStaffTable(context, report.byStaff, report.summary),
            ),
            const SizedBox(height: 16),
          ],

          if (report.byLocation.length > 1) ...[
            _buildBreakdownSection(
              context,
              title: context.l10n.reportsByLocation,
              child: _buildLocationTable(
                context,
                report.byLocation,
                report.summary,
              ),
            ),
            const SizedBox(height: 16),
          ],

          if (showByService) ...[
            _buildBreakdownSection(
              context,
              title: context.l10n.reportsByService,
              child: _buildServiceTable(
                context,
                report.byService,
                report.summary,
              ),
            ),
            const SizedBox(height: 16),
          ],

          if (showDayOfWeek) ...[
            _buildBreakdownSection(
              context,
              title: context.l10n.reportsByDayOfWeek,
              child: _buildDayOfWeekTable(
                context,
                report.byDayOfWeek,
                report.summary,
              ),
            ),
            const SizedBox(height: 16),
          ],

          if (showPeriod) ...[
            _buildBreakdownSection(
              context,
              title: context.l10n.reportsByPeriod,
              child: _buildPeriodTable(
                context,
                report.byPeriod,
                report.summary,
              ),
            ),
            const SizedBox(height: 16),
          ],

          if (showByHour) ...[
            _buildBreakdownSection(
              context,
              title: context.l10n.reportsByHour,
              child: _buildHourTable(context, report.byHour, report.summary),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildSummaryCards(BuildContext context, ReportSummary summary) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final locale = Localizations.localeOf(context).toString();
    final currencyFormat = NumberFormat.currency(
      locale: locale,
      symbol: '‚Ç¨',
      decimalDigits: 2,
    );
    final numberFormat = NumberFormat.decimalPattern(locale);
    final percentFormat = NumberFormat.decimalPattern(locale);

    final cards = [
      _SummaryCardData(
        icon: Icons.event,
        label: l10n.reportsTotalAppointments,
        value: numberFormat.format(summary.totalAppointments),
        color: colorScheme.primary,
      ),
      _SummaryCardData(
        icon: Icons.euro,
        label: l10n.reportsTotalRevenue,
        value: currencyFormat.format(summary.totalRevenue),
        color: Colors.green,
      ),
      _SummaryCardData(
        icon: Icons.pie_chart,
        label: l10n.reportsOccupancyPercentage,
        value: '${percentFormat.format(summary.occupancyPercentage)}%',
        color: Colors.orange,
      ),
      _SummaryCardData(
        icon: Icons.people,
        label: l10n.reportsUniqueClients,
        value: numberFormat.format(summary.uniqueClients),
        color: Colors.purple,
      ),
    ];

    return LayoutBuilder(
      builder: (context, constraints) {
        final crossAxisCount = constraints.maxWidth > 800
            ? 4
            : constraints.maxWidth > 500
            ? 2
            : 2;

        return GridView.builder(
          shrinkWrap: true,
          physics: const NeverScrollableScrollPhysics(),
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: crossAxisCount,
            childAspectRatio: 2.5,
            crossAxisSpacing: 12,
            mainAxisSpacing: 12,
          ),
          itemCount: cards.length,
          itemBuilder: (context, index) {
            final card = cards[index];
            return _buildSummaryCard(context, card);
          },
        );
      },
    );
  }

  Widget _buildSummaryCard(BuildContext context, _SummaryCardData card) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Container(
      padding: const EdgeInsets.all(12),
      decoration: BoxDecoration(
        color: colorScheme.surfaceContainerLow,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: colorScheme.outline.withOpacity(0.2)),
      ),
      child: Row(
        children: [
          Container(
            padding: const EdgeInsets.all(8),
            decoration: BoxDecoration(
              color: card.color.withOpacity(0.1),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Icon(card.icon, color: card.color, size: 20),
          ),
          const SizedBox(width: 10),
          Expanded(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  card.value,
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
                Text(
                  card.label,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: colorScheme.onSurfaceVariant,
                  ),
                  overflow: TextOverflow.ellipsis,
                  maxLines: 1,
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildBreakdownSection(
    BuildContext context, {
    required String title,
    required Widget child,
  }) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Container(
      decoration: BoxDecoration(
        color: colorScheme.surface,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: colorScheme.outline.withOpacity(0.2)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.all(16),
            child: Text(
              title,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          Divider(height: 1, color: colorScheme.outline.withOpacity(0.2)),
          child,
        ],
      ),
    );
  }

  Widget _buildStaffTable(
    BuildContext context,
    List<StaffReportRow> data,
    ReportSummary summary,
  ) {
    final l10n = context.l10n;

    final colorScheme = Theme.of(context).colorScheme;

    if (data.isEmpty) {
      return Padding(
        padding: const EdgeInsets.all(16),
        child: Text(l10n.reportsNoData),
      );
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        return SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          child: ConstrainedBox(
            constraints: BoxConstraints(minWidth: constraints.maxWidth),
            child: Theme(
              data: Theme.of(
                context,
              ).copyWith(dividerColor: colorScheme.outline.withOpacity(0.2)),
              child: DataTable(
                dividerThickness: 0.2,
                horizontalMargin: 16,
                columns: [
                  DataColumn(label: Text(l10n.reportsColStaff)),
                  DataColumn(
                    label: Text(l10n.reportsColAppointments),
                    numeric: true,
                  ),
                  DataColumn(
                    label: Text(l10n.reportsColRevenue),
                    numeric: true,
                  ),
                  DataColumn(
                    label: Text(l10n.reportsColAvgRevenue),
                    numeric: true,
                  ),
                  DataColumn(
                    label: Text(l10n.reportsColPercentage),
                    numeric: true,
                  ),
                ],
                rows: data.map((row) {
                  final percentage = summary.totalRevenue > 0
                      ? (row.revenue / summary.totalRevenue * 100)
                      : 0.0;
                  return DataRow(
                    cells: [
                      DataCell(
                        Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            if (row.staffColor != null)
                              Container(
                                width: 12,
                                height: 12,
                                margin: const EdgeInsets.only(right: 8),
                                decoration: BoxDecoration(
                                  color: _parseColor(row.staffColor!),
                                  shape: BoxShape.circle,
                                ),
                              ),
                            Text(row.staffName),
                          ],
                        ),
                      ),
                      DataCell(Text(row.appointments.toString())),
                      DataCell(Text('‚Ç¨${row.revenue.toStringAsFixed(2)}')),
                      DataCell(Text('‚Ç¨${row.avgRevenue.toStringAsFixed(2)}')),
                      DataCell(_buildPercentageBar(context, percentage)),
                    ],
                  );
                }).toList(),
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildLocationTable(
    BuildContext context,
    List<LocationReportRow> data,
    ReportSummary summary,
  ) {
    final l10n = context.l10n;

    final colorScheme = Theme.of(context).colorScheme;

    if (data.isEmpty) {
      return Padding(
        padding: const EdgeInsets.all(16),
        child: Text(l10n.reportsNoData),
      );
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        return SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          child: ConstrainedBox(
            constraints: BoxConstraints(minWidth: constraints.maxWidth),
            child: Theme(
              data: Theme.of(
                context,
              ).copyWith(dividerColor: colorScheme.outline.withOpacity(0.2)),
              child: DataTable(
                dividerThickness: 0.2,
                horizontalMargin: 16,
                columns: [
                  DataColumn(label: Text(l10n.reportsColLocation)),
                  DataColumn(
                    label: Text(l10n.reportsColAppointments),
                    numeric: true,
                  ),
                  DataColumn(
                    label: Text(l10n.reportsColRevenue),
                    numeric: true,
                  ),
                  DataColumn(label: Text(l10n.reportsColHours), numeric: true),
                  DataColumn(
                    label: Text(l10n.reportsColPercentage),
                    numeric: true,
                  ),
                ],
                rows: data.map((row) {
                  final percentage = summary.totalRevenue > 0
                      ? (row.revenue / summary.totalRevenue * 100)
                      : 0.0;
                  return DataRow(
                    cells: [
                      DataCell(Text(row.locationName)),
                      DataCell(Text(row.appointments.toString())),
                      DataCell(Text('‚Ç¨${row.revenue.toStringAsFixed(2)}')),
                      DataCell(Text('${row.hours.toStringAsFixed(1)}h')),
                      DataCell(_buildPercentageBar(context, percentage)),
                    ],
                  );
                }).toList(),
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildServiceTable(
    BuildContext context,
    List<ServiceReportRow> data,
    ReportSummary summary,
  ) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;

    if (data.isEmpty) {
      return Padding(
        padding: const EdgeInsets.all(16),
        child: Text(l10n.reportsNoData),
      );
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        return SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          child: ConstrainedBox(
            constraints: BoxConstraints(minWidth: constraints.maxWidth),
            child: Theme(
              data: Theme.of(
                context,
              ).copyWith(dividerColor: colorScheme.outline.withOpacity(0.2)),
              child: DataTable(
                dividerThickness: 0.2,
                horizontalMargin: 16,
                columns: [
                  DataColumn(label: Text(l10n.reportsColService)),
                  DataColumn(label: Text(l10n.reportsColCategory)),
                  DataColumn(
                    label: Text(l10n.reportsColAppointments),
                    numeric: true,
                  ),
                  DataColumn(
                    label: Text(l10n.reportsColRevenue),
                    numeric: true,
                  ),
                  DataColumn(
                    label: Text(l10n.reportsColPercentage),
                    numeric: true,
                  ),
                ],
                rows: data.map((row) {
                  final percentage = summary.totalAppointments > 0
                      ? (row.appointments / summary.totalAppointments * 100)
                      : 0.0;
                  return DataRow(
                    cells: [
                      DataCell(Text(row.serviceName)),
                      DataCell(Text(row.categoryName ?? '-')),
                      DataCell(Text(row.appointments.toString())),
                      DataCell(Text('‚Ç¨${row.revenue.toStringAsFixed(2)}')),
                      DataCell(_buildPercentageBar(context, percentage)),
                    ],
                  );
                }).toList(),
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildDayOfWeekTable(
    BuildContext context,
    List<DayOfWeekReportRow> data,
    ReportSummary summary,
  ) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;

    if (data.isEmpty) {
      return Padding(
        padding: const EdgeInsets.all(16),
        child: Text(l10n.reportsNoData),
      );
    }

    final dayNames = [
      l10n.dayMonday,
      l10n.dayTuesday,
      l10n.dayWednesday,
      l10n.dayThursday,
      l10n.dayFriday,
      l10n.daySaturday,
      l10n.daySunday,
    ];

    // Sort by ISO weekday
    final sortedData = List<DayOfWeekReportRow>.from(data)
      ..sort((a, b) => a.isoWeekday.compareTo(b.isoWeekday));

    return LayoutBuilder(
      builder: (context, constraints) {
        return SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          child: ConstrainedBox(
            constraints: BoxConstraints(minWidth: constraints.maxWidth),
            child: Theme(
              data: Theme.of(
                context,
              ).copyWith(dividerColor: colorScheme.outline.withOpacity(0.2)),
              child: DataTable(
                dividerThickness: 0.2,
                horizontalMargin: 16,
                columns: [
                  DataColumn(label: Text(l10n.reportsColDay)),
                  DataColumn(
                    label: Text(l10n.reportsColAppointments),
                    numeric: true,
                  ),
                  DataColumn(
                    label: Text(l10n.reportsColRevenue),
                    numeric: true,
                  ),
                  DataColumn(
                    label: Text(l10n.reportsColPercentage),
                    numeric: true,
                  ),
                ],
                rows: sortedData.map((row) {
                  final dayName = dayNames[row.isoWeekday - 1];
                  final percentage = summary.totalAppointments > 0
                      ? (row.appointments / summary.totalAppointments * 100)
                      : 0.0;
                  return DataRow(
                    cells: [
                      DataCell(Text(dayName)),
                      DataCell(Text(row.appointments.toString())),
                      DataCell(Text('‚Ç¨${row.revenue.toStringAsFixed(2)}')),
                      DataCell(_buildPercentageBar(context, percentage)),
                    ],
                  );
                }).toList(),
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildPeriodTable(
    BuildContext context,
    PeriodBreakdown breakdown,
    ReportSummary summary,
  ) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;
    final data = breakdown.data;

    if (data.isEmpty) {
      return Padding(
        padding: const EdgeInsets.all(16),
        child: Text(l10n.reportsNoData),
      );
    }

    final dateFormat = switch (breakdown.granularity) {
      'day' => DateFormat('dd/MM'),
      'week' => DateFormat('dd/MM'),
      'month' => DateFormat('MMM yyyy'),
      _ => DateFormat('dd/MM/yyyy'),
    };

    return LayoutBuilder(
      builder: (context, constraints) {
        return SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          child: ConstrainedBox(
            constraints: BoxConstraints(minWidth: constraints.maxWidth),
            child: Theme(
              data: Theme.of(
                context,
              ).copyWith(dividerColor: colorScheme.outline.withOpacity(0.2)),
              child: DataTable(
                dividerThickness: 0.2,
                horizontalMargin: 16,
                columns: [
                  DataColumn(label: Text(l10n.reportsColPeriod)),
                  DataColumn(
                    label: Text(l10n.reportsColAppointments),
                    numeric: true,
                  ),
                  DataColumn(
                    label: Text(l10n.reportsColRevenue),
                    numeric: true,
                  ),
                  DataColumn(
                    label: Text(l10n.reportsColPercentage),
                    numeric: true,
                  ),
                ],
                rows: data.map((row) {
                  String periodLabel = dateFormat.format(row.periodStart);
                  if (breakdown.granularity == 'week') {
                    final endOfWeek = row.periodStart.add(
                      const Duration(days: 6),
                    );
                    periodLabel =
                        '${dateFormat.format(row.periodStart)} - ${dateFormat.format(endOfWeek)}';
                  }
                  final percentage = summary.totalAppointments > 0
                      ? (row.appointments / summary.totalAppointments * 100)
                      : 0.0;
                  return DataRow(
                    cells: [
                      DataCell(Text(periodLabel)),
                      DataCell(Text(row.appointments.toString())),
                      DataCell(Text('‚Ç¨${row.revenue.toStringAsFixed(2)}')),
                      DataCell(_buildPercentageBar(context, percentage)),
                    ],
                  );
                }).toList(),
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildHourTable(
    BuildContext context,
    List<HourReportRow> data,
    ReportSummary summary,
  ) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;

    if (data.isEmpty) {
      return Padding(
        padding: const EdgeInsets.all(16),
        child: Text(l10n.reportsNoData),
      );
    }

    // Sort by hour
    final sortedData = List<HourReportRow>.from(data)
      ..sort((a, b) => a.hour.compareTo(b.hour));

    return LayoutBuilder(
      builder: (context, constraints) {
        return SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          child: ConstrainedBox(
            constraints: BoxConstraints(minWidth: constraints.maxWidth),
            child: Theme(
              data: Theme.of(
                context,
              ).copyWith(dividerColor: colorScheme.outline.withOpacity(0.2)),
              child: DataTable(
                dividerThickness: 0.2,
                horizontalMargin: 16,
                columns: [
                  DataColumn(label: Text(l10n.reportsColHour)),
                  DataColumn(
                    label: Text(l10n.reportsColAppointments),
                    numeric: true,
                  ),
                  DataColumn(
                    label: Text(l10n.reportsColRevenue),
                    numeric: true,
                  ),
                  DataColumn(
                    label: Text(l10n.reportsColPercentage),
                    numeric: true,
                  ),
                ],
                rows: sortedData.map((row) {
                  final hourLabel = '${row.hour.toString().padLeft(2, '0')}:00';
                  final percentage = summary.totalAppointments > 0
                      ? (row.appointments / summary.totalAppointments * 100)
                      : 0.0;
                  return DataRow(
                    cells: [
                      DataCell(Text(hourLabel)),
                      DataCell(Text(row.appointments.toString())),
                      DataCell(Text('‚Ç¨${row.revenue.toStringAsFixed(2)}')),
                      DataCell(_buildPercentageBar(context, percentage)),
                    ],
                  );
                }).toList(),
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildPercentageBar(BuildContext context, double percentage) {
    final colorScheme = Theme.of(context).colorScheme;

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        SizedBox(
          width: 60,
          child: ClipRRect(
            borderRadius: BorderRadius.circular(4),
            child: LinearProgressIndicator(
              value: percentage / 100,
              minHeight: 8,
              backgroundColor: colorScheme.surfaceContainerHighest,
              valueColor: AlwaysStoppedAnimation(colorScheme.primary),
            ),
          ),
        ),
        const SizedBox(width: 8),
        Text('${percentage.toStringAsFixed(0)}%'),
      ],
    );
  }

  Color _parseColor(String hex) {
    try {
      return Color(int.parse(hex.replaceFirst('#', '0xFF')));
    } catch (_) {
      return Colors.grey;
    }
  }

  // ===========================================================================
  // WORK HOURS REPORT CONTENT
  // ===========================================================================

  Widget _buildWorkHoursContent(BuildContext context, WorkHoursReport report) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Summary cards
          _buildWorkHoursSummaryCards(context, report.summary),
          const SizedBox(height: 24),

          // Staff breakdown
          _buildBreakdownSection(
            context,
            title: context.l10n.reportsByStaff,
            child: _buildWorkHoursStaffTable(context, report.byStaff),
          ),
        ],
      ),
    );
  }

  Widget _buildWorkHoursSummaryCards(
    BuildContext context,
    WorkHoursSummary summary,
  ) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final locale = Localizations.localeOf(context).toString();
    final numberFormat = NumberFormat.decimalPattern(locale);

    // Helper to format hours with optional days + total in hours
    // Returns (primaryFormat, totalHoursFormat) - totalHoursFormat is null if < 24h
    (String, String?) formatHoursWithTotal(double hours) {
      final totalMinutes = (hours * 60).round();
      final totalH = totalMinutes ~/ 60;
      final totalM = totalMinutes % 60;
      final totalHoursStr = totalM == 0
          ? '${totalH}h'
          : '${totalH}h ${totalM}m';

      if (hours >= 24) {
        final days = totalMinutes ~/ (24 * 60);
        final remainingMinutes = totalMinutes % (24 * 60);
        final h = remainingMinutes ~/ 60;
        final m = remainingMinutes % 60;
        String primary;
        if (m == 0 && h == 0) {
          primary = '${days}g';
        } else if (m == 0) {
          primary = '${days}g ${h}h';
        } else if (h == 0) {
          primary = '${days}g ${m}m';
        } else {
          primary = '${days}g ${h}h ${m}m';
        }
        return (primary, totalHoursStr);
      }
      return (totalHoursStr, null);
    }

    Widget buildHoursValue(double hours, {Color? textColor}) {
      final (primary, totalHours) = formatHoursWithTotal(hours);
      if (totalHours == null) {
        return Text(
          primary,
          style: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.bold,
            color: textColor,
          ),
        );
      }
      return Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            primary,
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
              color: textColor,
            ),
          ),
          Text(
            '= $totalHours',
            style: TextStyle(
              fontSize: 11,
              color: (textColor ?? Theme.of(context).colorScheme.onSurface)
                  .withValues(alpha: 0.6),
            ),
          ),
        ],
      );
    }

    final cards = [
      _WorkHoursCardData(
        icon: Icons.schedule,
        label: l10n.reportsWorkHoursScheduled,
        hoursWidget: buildHoursValue(summary.totalScheduledHours),
        color: colorScheme.primary,
      ),
      _WorkHoursCardData(
        icon: Icons.work,
        label: l10n.reportsWorkHoursWorked,
        hoursWidget: buildHoursValue(summary.totalWorkedHours),
        color: Colors.green,
      ),
      _WorkHoursCardData(
        icon: Icons.block,
        label: l10n.reportsWorkHoursBlocked,
        hoursWidget: buildHoursValue(summary.totalBlockedHours),
        color: Colors.orange,
      ),
      _WorkHoursCardData(
        icon: Icons.beach_access,
        label: l10n.reportsWorkHoursOff,
        hoursWidget: buildHoursValue(summary.totalExceptionOffHours),
        color: Colors.red,
      ),
      _WorkHoursCardData(
        icon: Icons.event_available,
        label: l10n.reportsWorkHoursAvailable,
        hoursWidget: buildHoursValue(summary.totalAvailableHours),
        color: Colors.blue,
      ),
      _WorkHoursCardData(
        icon: Icons.pie_chart,
        label: l10n.reportsWorkHoursUtilization,
        percentageValue:
            '${numberFormat.format(summary.overallUtilizationPercentage)}%',
        color: Colors.purple,
      ),
    ];

    return LayoutBuilder(
      builder: (context, constraints) {
        final isDesktop = constraints.maxWidth > 900;
        final crossAxisCount = isDesktop
            ? 3
            : constraints.maxWidth > 500
            ? 2
            : 2;

        // Aspect ratio pi√π alto su desktop (card pi√π basse)
        final aspectRatio = isDesktop ? 2.8 : 2.5;

        // Su desktop limita la larghezza e centra
        final maxGridWidth = isDesktop ? 900.0 : constraints.maxWidth;

        return Center(
          child: ConstrainedBox(
            constraints: BoxConstraints(maxWidth: maxGridWidth),
            child: GridView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: crossAxisCount,
                childAspectRatio: aspectRatio,
                crossAxisSpacing: 12,
                mainAxisSpacing: 12,
              ),
              itemCount: cards.length,
              itemBuilder: (context, index) {
                final card = cards[index];
                return _buildWorkHoursSummaryCard(context, card);
              },
            ),
          ),
        );
      },
    );
  }

  Widget _buildWorkHoursSummaryCard(
    BuildContext context,
    _WorkHoursCardData card,
  ) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: colorScheme.outlineVariant),
      ),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
        child: Row(
          children: [
            Container(
              padding: const EdgeInsets.all(8),
              decoration: BoxDecoration(
                color: card.color.withValues(alpha: 0.1),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Icon(card.icon, color: card.color, size: 18),
            ),
            const SizedBox(width: 10),
            Expanded(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisSize: MainAxisSize.min,
                children: [
                  Text(
                    card.label,
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: colorScheme.onSurfaceVariant,
                    ),
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 2),
                  if (card.percentageValue != null)
                    Text(
                      card.percentageValue!,
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                        color: colorScheme.onSurface,
                      ),
                    )
                  else if (card.hoursWidget != null)
                    card.hoursWidget!,
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildWorkHoursStaffTable(
    BuildContext context,
    List<StaffWorkHoursRow> byStaff,
  ) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;

    // Helper to format hours with optional days + total in hours
    String formatHoursPrimary(double hours) {
      final totalMinutes = (hours * 60).round();
      final totalH = totalMinutes ~/ 60;
      final totalM = totalMinutes % 60;

      if (hours >= 24) {
        final days = totalMinutes ~/ (24 * 60);
        final remainingMinutes = totalMinutes % (24 * 60);
        final h = remainingMinutes ~/ 60;
        final m = remainingMinutes % 60;
        if (m == 0 && h == 0) return '${days}g';
        if (m == 0) return '${days}g ${h}h';
        if (h == 0) return '${days}g ${m}m';
        return '${days}g ${h}h ${m}m';
      }
      return totalM == 0 ? '${totalH}h' : '${totalH}h ${totalM}m';
    }

    String? formatHoursTotal(double hours) {
      if (hours < 24) return null;
      final totalMinutes = (hours * 60).round();
      final totalH = totalMinutes ~/ 60;
      final totalM = totalMinutes % 60;
      return totalM == 0 ? '${totalH}h' : '${totalH}h ${totalM}m';
    }

    Widget buildHoursCell(double hours, {TextStyle? style}) {
      final primary = formatHoursPrimary(hours);
      final totalHours = formatHoursTotal(hours);
      if (totalHours == null) {
        return Text(primary, style: style);
      }
      return Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.end,
        children: [
          Text(primary, style: style),
          Text(
            '= $totalHours',
            style: textTheme.bodySmall?.copyWith(
              color: colorScheme.onSurfaceVariant.withValues(alpha: 0.7),
              fontSize: 11,
            ),
          ),
        ],
      );
    }

    if (byStaff.isEmpty) {
      return Padding(
        padding: const EdgeInsets.all(16),
        child: Text(l10n.reportsNoData),
      );
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        return SingleChildScrollView(
          scrollDirection: Axis.horizontal,
          child: ConstrainedBox(
            constraints: BoxConstraints(minWidth: constraints.maxWidth),
            child: Theme(
              data: Theme.of(
                context,
              ).copyWith(dividerColor: colorScheme.outline.withOpacity(0.2)),
              child: DataTable(
                dividerThickness: 0.2,
                horizontalMargin: 16,
                columns: [
                  DataColumn(label: Text(l10n.reportsColStaff)),
                  DataColumn(
                    label: Text(l10n.reportsColScheduledHours),
                    numeric: true,
                  ),
                  DataColumn(
                    label: Text(l10n.reportsColWorkedHours),
                    numeric: true,
                  ),
                  DataColumn(
                    label: Text(l10n.reportsColBlockedHours),
                    numeric: true,
                  ),
                  DataColumn(
                    label: Text(l10n.reportsColOffHours),
                    numeric: true,
                  ),
                  DataColumn(
                    label: Text(l10n.reportsColAvailableHours),
                    numeric: true,
                  ),
                  DataColumn(
                    label: Text(l10n.reportsColUtilization),
                    numeric: true,
                  ),
                ],
                rows: byStaff.map((row) {
                  final staffColor = row.staffColor != null
                      ? _parseColor(row.staffColor!)
                      : colorScheme.primary;

                  return DataRow(
                    cells: [
                      DataCell(
                        Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Container(
                              width: 12,
                              height: 12,
                              margin: const EdgeInsets.only(right: 8),
                              decoration: BoxDecoration(
                                color: staffColor,
                                shape: BoxShape.circle,
                              ),
                            ),
                            Text(row.staffName),
                          ],
                        ),
                      ),
                      DataCell(buildHoursCell(row.scheduledHours)),
                      DataCell(
                        buildHoursCell(
                          row.workedHours,
                          style: TextStyle(
                            color: Colors.green.shade700,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                      DataCell(
                        buildHoursCell(
                          row.blockedHours,
                          style: TextStyle(color: Colors.orange.shade700),
                        ),
                      ),
                      DataCell(
                        buildHoursCell(
                          row.exceptionOffHours,
                          style: TextStyle(color: Colors.red.shade700),
                        ),
                      ),
                      DataCell(buildHoursCell(row.availableHours)),
                      DataCell(
                        _buildPercentageBar(context, row.utilizationPercentage),
                      ),
                    ],
                  );
                }).toList(),
              ),
            ),
          ),
        );
      },
    );
  }
}

class _SummaryCardData {
  const _SummaryCardData({
    required this.icon,
    required this.label,
    required this.value,
    required this.color,
  });

  final IconData icon;
  final String label;
  final String value;
  final Color color;
}

class _WorkHoursCardData {
  const _WorkHoursCardData({
    required this.icon,
    required this.label,
    required this.color,
    this.hoursWidget,
    this.percentageValue,
  });

  final IconData icon;
  final String label;
  final Color color;
  final Widget? hoursWidget;
  final String? percentageValue;
}

// ============================================================================
// LOCATION FILTER DIALOG
// ============================================================================

class _LocationFilterDialog extends StatefulWidget {
  const _LocationFilterDialog({
    required this.locations,
    required this.selected,
  });

  final List<dynamic> locations;
  final Set<int> selected;

  @override
  State<_LocationFilterDialog> createState() => _LocationFilterDialogState();
}

class _LocationFilterDialogState extends State<_LocationFilterDialog> {
  late Set<int> _selected;

  @override
  void initState() {
    super.initState();
    _selected = Set<int>.from(widget.selected);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;

    return AlertDialog(
      title: Text(l10n.reportsFilterLocations),
      content: SizedBox(
        width: 350,
        height: 400,
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                TextButton(
                  onPressed: () {
                    setState(() {
                      _selected = widget.locations
                          .map((l) => l.id as int)
                          .toSet();
                    });
                  },
                  child: Text(l10n.actionSelectAll),
                ),
                TextButton(
                  onPressed: () {
                    setState(() => _selected.clear());
                  },
                  child: Text(l10n.actionDeselectAll),
                ),
              ],
            ),
            const Divider(),
            Expanded(
              child: ListView.builder(
                itemCount: widget.locations.length,
                itemBuilder: (context, index) {
                  final location = widget.locations[index];
                  final isSelected = _selected.contains(location.id);

                  return ListTile(
                    leading: Container(
                      width: 40,
                      height: 40,
                      decoration: BoxDecoration(
                        color: colorScheme.primaryContainer,
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Icon(
                        Icons.location_on,
                        color: colorScheme.onPrimaryContainer,
                      ),
                    ),
                    title: Text(location.name),
                    subtitle: location.address != null
                        ? Text(
                            location.address,
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          )
                        : null,
                    trailing: Checkbox(
                      value: isSelected,
                      onChanged: (checked) {
                        setState(() {
                          if (checked == true) {
                            _selected.add(location.id);
                          } else {
                            _selected.remove(location.id);
                          }
                        });
                      },
                    ),
                    onTap: () {
                      setState(() {
                        if (isSelected) {
                          _selected.remove(location.id);
                        } else {
                          _selected.add(location.id);
                        }
                      });
                    },
                  );
                },
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: Text(l10n.actionCancel),
        ),
        FilledButton(
          onPressed: () => Navigator.of(context).pop(_selected),
          child: Text(l10n.actionApply),
        ),
      ],
    );
  }
}

// ============================================================================
// STAFF FILTER DIALOG - with avatar like in agenda
// ============================================================================

class _StaffFilterDialog extends StatefulWidget {
  const _StaffFilterDialog({required this.staff, required this.selected});

  final List<Staff> staff;
  final Set<int> selected;

  @override
  State<_StaffFilterDialog> createState() => _StaffFilterDialogState();
}

class _StaffFilterDialogState extends State<_StaffFilterDialog> {
  late Set<int> _selected;

  @override
  void initState() {
    super.initState();
    _selected = Set<int>.from(widget.selected);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;

    return AlertDialog(
      title: Text(l10n.reportsFilterStaff),
      content: SizedBox(
        width: 350,
        height: 400,
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                TextButton(
                  onPressed: () {
                    setState(() {
                      _selected = widget.staff.map((s) => s.id).toSet();
                    });
                  },
                  child: Text(l10n.actionSelectAll),
                ),
                TextButton(
                  onPressed: () {
                    setState(() => _selected.clear());
                  },
                  child: Text(l10n.actionDeselectAll),
                ),
              ],
            ),
            const Divider(),
            Expanded(
              child: ListView.builder(
                itemCount: widget.staff.length,
                itemBuilder: (context, index) {
                  final staff = widget.staff[index];
                  final isSelected = _selected.contains(staff.id);

                  return ListTile(
                    leading: StaffCircleAvatar(
                      height: 40,
                      color: staff.color,
                      isHighlighted: isSelected,
                      initials: staff.initials,
                    ),
                    title: Text(staff.displayName),
                    trailing: Checkbox(
                      value: isSelected,
                      onChanged: (checked) {
                        setState(() {
                          if (checked == true) {
                            _selected.add(staff.id);
                          } else {
                            _selected.remove(staff.id);
                          }
                        });
                      },
                    ),
                    onTap: () {
                      setState(() {
                        if (isSelected) {
                          _selected.remove(staff.id);
                        } else {
                          _selected.add(staff.id);
                        }
                      });
                    },
                  );
                },
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: Text(l10n.actionCancel),
        ),
        FilledButton(
          onPressed: () => Navigator.of(context).pop(_selected),
          child: Text(l10n.actionApply),
        ),
      ],
    );
  }
}

// ============================================================================
// SERVICE FILTER DIALOG - organized by categories
// ============================================================================

class _ServiceFilterDialog extends StatefulWidget {
  const _ServiceFilterDialog({
    required this.services,
    required this.categories,
    required this.selected,
  });

  final List<Service> services;
  final List<ServiceCategory> categories;
  final Set<int> selected;

  @override
  State<_ServiceFilterDialog> createState() => _ServiceFilterDialogState();
}

class _ServiceFilterDialogState extends State<_ServiceFilterDialog> {
  late Set<int> _selected;
  final Set<int> _expandedCategories = {};

  @override
  void initState() {
    super.initState();
    _selected = Set<int>.from(widget.selected);
    // Expand categories that have selected services
    for (final service in widget.services) {
      if (_selected.contains(service.id)) {
        _expandedCategories.add(service.categoryId);
      }
    }
  }

  Map<int, List<Service>> _groupServicesByCategory() {
    final grouped = <int, List<Service>>{};
    for (final service in widget.services) {
      grouped.putIfAbsent(service.categoryId, () => []).add(service);
    }
    return grouped;
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;
    final groupedServices = _groupServicesByCategory();

    // Sort categories by sort_order
    final sortedCategories = widget.categories.toList()
      ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));

    // Get category IDs that have services
    final categoryIdsWithServices = groupedServices.keys.toSet();

    // Build list of items to display
    final displayItems = <_CategoryDisplayItem>[];
    for (final cat in sortedCategories) {
      if (categoryIdsWithServices.contains(cat.id)) {
        displayItems.add(_CategoryDisplayItem(id: cat.id, name: cat.name));
      }
    }
    // Add "Altro" category (id=0) if it exists
    if (categoryIdsWithServices.contains(0)) {
      displayItems.add(const _CategoryDisplayItem(id: 0, name: 'Altro'));
    }

    return AlertDialog(
      title: Text(l10n.reportsFilterServices),
      content: SizedBox(
        width: 400,
        height: 500,
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                TextButton(
                  onPressed: () {
                    setState(() {
                      _selected = widget.services.map((s) => s.id).toSet();
                    });
                  },
                  child: Text(l10n.actionSelectAll),
                ),
                TextButton(
                  onPressed: () {
                    setState(() => _selected.clear());
                  },
                  child: Text(l10n.actionDeselectAll),
                ),
              ],
            ),
            const Divider(),
            Expanded(
              child: ListView.builder(
                itemCount: displayItems.length,
                itemBuilder: (context, index) {
                  final categoryItem = displayItems[index];
                  final categoryId = categoryItem.id;
                  final categoryName = categoryItem.name;
                  final services = groupedServices[categoryId] ?? [];

                  if (services.isEmpty) return const SizedBox.shrink();

                  final isExpanded = _expandedCategories.contains(categoryId);
                  final selectedInCategory = services
                      .where((s) => _selected.contains(s.id))
                      .length;
                  final allSelectedInCategory =
                      selectedInCategory == services.length;
                  final someSelectedInCategory =
                      selectedInCategory > 0 && !allSelectedInCategory;

                  return Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Category header
                      InkWell(
                        onTap: () {
                          setState(() {
                            if (isExpanded) {
                              _expandedCategories.remove(categoryId);
                            } else {
                              _expandedCategories.add(categoryId);
                            }
                          });
                        },
                        child: Container(
                          padding: const EdgeInsets.symmetric(
                            horizontal: 8,
                            vertical: 12,
                          ),
                          color: colorScheme.surfaceContainerHighest
                              .withOpacity(0.5),
                          child: Row(
                            children: [
                              Icon(
                                isExpanded
                                    ? Icons.expand_less
                                    : Icons.expand_more,
                                size: 20,
                              ),
                              const SizedBox(width: 8),
                              Expanded(
                                child: Text(
                                  categoryName,
                                  style: const TextStyle(
                                    fontWeight: FontWeight.w600,
                                  ),
                                ),
                              ),
                              Text(
                                '$selectedInCategory/${services.length}',
                                style: TextStyle(
                                  color: colorScheme.onSurfaceVariant,
                                  fontSize: 12,
                                ),
                              ),
                              const SizedBox(width: 8),
                              Checkbox(
                                value: allSelectedInCategory
                                    ? true
                                    : someSelectedInCategory
                                    ? null
                                    : false,
                                tristate: true,
                                onChanged: (checked) {
                                  setState(() {
                                    if (checked == true || checked == null) {
                                      // Select all in category
                                      for (final s in services) {
                                        _selected.add(s.id);
                                      }
                                    } else {
                                      // Deselect all in category
                                      for (final s in services) {
                                        _selected.remove(s.id);
                                      }
                                    }
                                  });
                                },
                              ),
                            ],
                          ),
                        ),
                      ),
                      // Services list (if expanded)
                      if (isExpanded)
                        ...services.map((service) {
                          final isSelected = _selected.contains(service.id);
                          return ListTile(
                            dense: true,
                            contentPadding: const EdgeInsets.only(
                              left: 40,
                              right: 16,
                            ),
                            title: Text(service.name),
                            subtitle: service.price != null
                                ? Text(
                                    '‚Ç¨${service.price!.toStringAsFixed(2)}',
                                    style: TextStyle(
                                      color: colorScheme.onSurfaceVariant,
                                      fontSize: 12,
                                    ),
                                  )
                                : null,
                            trailing: Checkbox(
                              value: isSelected,
                              onChanged: (checked) {
                                setState(() {
                                  if (checked == true) {
                                    _selected.add(service.id);
                                  } else {
                                    _selected.remove(service.id);
                                  }
                                });
                              },
                            ),
                            onTap: () {
                              setState(() {
                                if (isSelected) {
                                  _selected.remove(service.id);
                                } else {
                                  _selected.add(service.id);
                                }
                              });
                            },
                          );
                        }),
                    ],
                  );
                },
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: Text(l10n.actionCancel),
        ),
        FilledButton(
          onPressed: () => Navigator.of(context).pop(_selected),
          child: Text(l10n.actionApply),
        ),
      ],
    );
  }
}

class _CategoryDisplayItem {
  const _CategoryDisplayItem({required this.id, required this.name});
  final int id;
  final String name;
}

// ============================================================================
// GENERIC MULTI-SELECT DIALOG (for status filter)
// ============================================================================

/// Multi-select dialog for filters.
class _MultiSelectDialog<T> extends StatefulWidget {
  const _MultiSelectDialog({
    required this.title,
    required this.items,
    required this.selected,
  });

  final String title;
  final Map<T, String> items;
  final Set<T> selected;

  @override
  State<_MultiSelectDialog<T>> createState() => _MultiSelectDialogState<T>();
}

class _MultiSelectDialogState<T> extends State<_MultiSelectDialog<T>> {
  late Set<T> _selected;

  @override
  void initState() {
    super.initState();
    _selected = Set<T>.from(widget.selected);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;

    return AlertDialog(
      title: Text(widget.title),
      content: SizedBox(
        width: 300,
        height: 400,
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                TextButton(
                  onPressed: () {
                    setState(() {
                      _selected = widget.items.keys.toSet();
                    });
                  },
                  child: Text(l10n.actionSelectAll),
                ),
                TextButton(
                  onPressed: () {
                    setState(() {
                      _selected.clear();
                    });
                  },
                  child: Text(l10n.actionDeselectAll),
                ),
              ],
            ),
            const Divider(),
            Expanded(
              child: ListView(
                children: widget.items.entries.map((entry) {
                  return CheckboxListTile(
                    title: Text(entry.value),
                    value: _selected.contains(entry.key),
                    onChanged: (checked) {
                      setState(() {
                        if (checked == true) {
                          _selected.add(entry.key);
                        } else {
                          _selected.remove(entry.key);
                        }
                      });
                    },
                  );
                }).toList(),
              ),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: Text(l10n.actionCancel),
        ),
        FilledButton(
          onPressed: () => Navigator.of(context).pop(_selected),
          child: Text(l10n.actionApply),
        ),
      ],
    );
  }
}
--- FILE: lib/features/reports/widgets/reports_top_controls.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../providers/reports_filter_provider.dart';

/// Top controls for Reports screen, using shared provider state.
class ReportsTopControls extends ConsumerWidget {
  const ReportsTopControls({super.key, this.onDateRangeSelected});

  /// Optional callback when user wants to select custom date range.
  /// If null, uses a simple date range picker.
  final VoidCallback? onDateRangeSelected;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final formFactor = ref.watch(formFactorProvider);
    final isCompact = formFactor != AppFormFactor.desktop;
    final filterState = ref.watch(reportsFilterProvider);
    final filterNotifier = ref.read(reportsFilterProvider.notifier);

    return _ReportsTopControlsContent(
      selectedPreset: filterState.selectedPreset,
      startDate: filterState.startDate,
      endDate: filterState.endDate,
      useFullPeriod: filterState.useFullPeriod,
      isCompact: isCompact,
      onPresetChanged: (preset) {
        if (preset == 'custom') {
          if (onDateRangeSelected != null) {
            onDateRangeSelected!();
          } else {
            _showDateRangePicker(context, ref);
          }
        } else {
          filterNotifier.applyPreset(preset);
        }
      },
      onDateRangeSelected:
          onDateRangeSelected ?? () => _showDateRangePicker(context, ref),
      onFullPeriodChanged: (value) {
        filterNotifier.setFullPeriod(value);
        filterNotifier.applyPreset(filterState.selectedPreset);
      },
    );
  }

  Future<void> _showDateRangePicker(BuildContext context, WidgetRef ref) async {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final l10n = context.l10n;
    final filterState = ref.read(reportsFilterProvider);

    final picked = await showDateRangePicker(
      context: context,
      firstDate: DateTime(2020),
      lastDate: DateTime.now().add(const Duration(days: 365)),
      initialDateRange: DateTimeRange(
        start: filterState.startDate,
        end: filterState.endDate,
      ),
      saveText: l10n.actionApply,
      builder: (context, child) {
        return Theme(
          data: theme.copyWith(
            colorScheme: colorScheme.copyWith(
              onPrimary: colorScheme.onPrimary,
              onSurface: colorScheme.onSurface,
            ),
            datePickerTheme: DatePickerThemeData(
              rangeSelectionBackgroundColor: colorScheme.primary.withOpacity(
                0.2,
              ),
              dayForegroundColor: WidgetStateProperty.resolveWith((states) {
                if (states.contains(WidgetState.selected)) {
                  return colorScheme.onPrimary;
                }
                if (states.contains(WidgetState.disabled)) {
                  return colorScheme.onSurface.withOpacity(0.38);
                }
                return colorScheme.onSurface;
              }),
              dayBackgroundColor: WidgetStateProperty.resolveWith((states) {
                if (states.contains(WidgetState.selected)) {
                  return colorScheme.primary;
                }
                return null;
              }),
            ),
          ),
          child: child!,
        );
      },
    );

    if (picked != null) {
      ref
          .read(reportsFilterProvider.notifier)
          .setDateRange(picked.start, picked.end);
    }
  }
}

class _ReportsTopControlsContent extends StatelessWidget {
  const _ReportsTopControlsContent({
    required this.selectedPreset,
    required this.startDate,
    required this.endDate,
    required this.useFullPeriod,
    required this.isCompact,
    required this.onPresetChanged,
    required this.onDateRangeSelected,
    required this.onFullPeriodChanged,
  });

  final String selectedPreset;
  final DateTime startDate;
  final DateTime endDate;
  final bool useFullPeriod;
  final bool isCompact;
  final ValueChanged<String> onPresetChanged;
  final VoidCallback onDateRangeSelected;
  final ValueChanged<bool> onFullPeriodChanged;

  bool get _supportsFullPeriod =>
      selectedPreset != 'custom' &&
      selectedPreset != 'today' &&
      selectedPreset != 'last_month' &&
      selectedPreset != 'last_3_months' &&
      selectedPreset != 'last_6_months' &&
      selectedPreset != 'last_year';

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final l10n = context.l10n;
    final dateFormat = DateFormat('dd/MM/yy');

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        // Preset dropdown
        _PresetDropdown(value: selectedPreset, onChanged: onPresetChanged),

        // Date range display - only for custom preset
        if (selectedPreset == 'custom') ...[
          const SizedBox(width: 8),
          Material(
            color: Colors.transparent,
            child: InkWell(
              onTap: onDateRangeSelected,
              borderRadius: BorderRadius.circular(8),
              child: Container(
                height: 36,
                padding: const EdgeInsets.symmetric(horizontal: 12),
                decoration: BoxDecoration(
                  border: Border.all(color: colorScheme.outline),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      Icons.calendar_today,
                      size: 16,
                      color: colorScheme.primary,
                    ),
                    const SizedBox(width: 8),
                    Text(
                      '${dateFormat.format(startDate)} - ${dateFormat.format(endDate)}',
                      style: theme.textTheme.bodyMedium,
                    ),
                  ],
                ),
              ),
            ),
          ),
        ],

        // Full period toggle - inline on desktop
        if (_supportsFullPeriod && !isCompact) ...[
          const SizedBox(width: 16),
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              SizedBox(
                height: 24,
                child: Switch(
                  value: useFullPeriod,
                  onChanged: onFullPeriodChanged,
                ),
              ),
              const SizedBox(width: 4),
              Text(
                l10n.reportsFullPeriodToggle,
                style: theme.textTheme.bodySmall?.copyWith(
                  color: colorScheme.onSurfaceVariant,
                ),
              ),
            ],
          ),
        ],
      ],
    );
  }
}

class _PresetDropdown extends StatelessWidget {
  const _PresetDropdown({required this.value, required this.onChanged});

  final String value;
  final ValueChanged<String> onChanged;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final l10n = context.l10n;

    return Container(
      height: 36,
      padding: const EdgeInsets.symmetric(horizontal: 12),
      decoration: BoxDecoration(
        border: Border.all(color: colorScheme.outline),
        borderRadius: BorderRadius.circular(8),
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: value,
          isDense: true,
          icon: Icon(
            Icons.arrow_drop_down,
            color: colorScheme.onSurfaceVariant,
          ),
          style: theme.textTheme.bodyMedium,
          onChanged: (v) {
            if (v != null) onChanged(v);
          },
          items: [
            DropdownMenuItem(
              value: 'custom',
              child: Text(l10n.reportsPresetCustom),
            ),
            DropdownMenuItem(
              value: 'today',
              child: Text(l10n.reportsPresetToday),
            ),
            DropdownMenuItem(
              value: 'month',
              child: Text(l10n.reportsPresetMonth),
            ),
            DropdownMenuItem(
              value: 'quarter',
              child: Text(l10n.reportsPresetQuarter),
            ),
            DropdownMenuItem(
              value: 'semester',
              child: Text(l10n.reportsPresetSemester),
            ),
            DropdownMenuItem(
              value: 'year',
              child: Text(l10n.reportsPresetYear),
            ),
            DropdownMenuItem(
              value: 'last_month',
              child: Text(l10n.reportsPresetLastMonth),
            ),
            DropdownMenuItem(
              value: 'last_3_months',
              child: Text(l10n.reportsPresetLast3Months),
            ),
            DropdownMenuItem(
              value: 'last_6_months',
              child: Text(l10n.reportsPresetLast6Months),
            ),
            DropdownMenuItem(
              value: 'last_year',
              child: Text(l10n.reportsPresetLastYear),
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/reports/widgets/reports_header.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../app/providers/form_factor_provider.dart';
import '../../../app/widgets/agenda_control_components.dart';
import '../../../core/l10n/l10_extension.dart';
import '../providers/reports_filter_provider.dart';

/// Header widget for Reports screen with period controls only (title and refresh are in AppBar).
class ReportsHeader extends ConsumerWidget {
  const ReportsHeader({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final formFactor = ref.watch(formFactorProvider);
    final isCompact = formFactor != AppFormFactor.desktop;
    final filterState = ref.watch(reportsFilterProvider);
    final filterNotifier = ref.read(reportsFilterProvider.notifier);

    return Container(
      alignment: Alignment.centerLeft,
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      decoration: BoxDecoration(
        color: colorScheme.surface,
        border: Border(
          bottom: BorderSide(color: colorScheme.outline.withOpacity(0.2)),
        ),
      ),
      child: _ReportsControls(
        selectedPreset: filterState.selectedPreset,
        startDate: filterState.startDate,
        endDate: filterState.endDate,
        useFullPeriod: filterState.useFullPeriod,
        isCompact: isCompact,
        onPresetChanged: (preset) {
          if (preset == 'custom') {
            _showDateRangePicker(context, ref);
          } else {
            filterNotifier.applyPreset(preset);
          }
        },
        onDateRangeSelected: () => _showDateRangePicker(context, ref),
        onFullPeriodChanged: (value) {
          filterNotifier.setFullPeriod(value);
          filterNotifier.applyPreset(filterState.selectedPreset);
        },
      ),
    );
  }

  Future<void> _showDateRangePicker(BuildContext context, WidgetRef ref) async {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final l10n = context.l10n;
    final filterState = ref.read(reportsFilterProvider);

    final picked = await showDateRangePicker(
      context: context,
      firstDate: DateTime(2020),
      lastDate: DateTime.now().add(const Duration(days: 365)),
      initialDateRange: DateTimeRange(
        start: filterState.startDate,
        end: filterState.endDate,
      ),
      saveText: l10n.actionApply,
      builder: (context, child) {
        return Theme(
          data: theme.copyWith(
            colorScheme: colorScheme.copyWith(
              onPrimary: colorScheme.onPrimary,
              onSurface: colorScheme.onSurface,
            ),
            datePickerTheme: DatePickerThemeData(
              rangeSelectionBackgroundColor: colorScheme.primary.withOpacity(
                0.2,
              ),
              dayForegroundColor: WidgetStateProperty.resolveWith((states) {
                if (states.contains(WidgetState.selected)) {
                  return colorScheme.onPrimary;
                }
                if (states.contains(WidgetState.disabled)) {
                  return colorScheme.onSurface.withOpacity(0.38);
                }
                return colorScheme.onSurface;
              }),
              dayBackgroundColor: WidgetStateProperty.resolveWith((states) {
                if (states.contains(WidgetState.selected)) {
                  return colorScheme.primary;
                }
                return null;
              }),
            ),
          ),
          child: child!,
        );
      },
    );

    if (picked != null) {
      ref
          .read(reportsFilterProvider.notifier)
          .setDateRange(picked.start, picked.end);
    }
  }
}

class _ReportsControls extends StatelessWidget {
  const _ReportsControls({
    required this.selectedPreset,
    required this.startDate,
    required this.endDate,
    required this.useFullPeriod,
    required this.isCompact,
    required this.onPresetChanged,
    required this.onDateRangeSelected,
    required this.onFullPeriodChanged,
  });

  final String selectedPreset;
  final DateTime startDate;
  final DateTime endDate;
  final bool useFullPeriod;
  final bool isCompact;
  final ValueChanged<String> onPresetChanged;
  final VoidCallback onDateRangeSelected;
  final ValueChanged<bool> onFullPeriodChanged;

  bool get _supportsFullPeriod =>
      selectedPreset != 'custom' &&
      selectedPreset != 'today' &&
      selectedPreset != 'last_month' &&
      selectedPreset != 'last_3_months' &&
      selectedPreset != 'last_6_months' &&
      selectedPreset != 'last_year';

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final l10n = context.l10n;
    final dateFormat = DateFormat('dd/MM/yy');

    return Wrap(
      spacing: 12,
      runSpacing: 8,
      crossAxisAlignment: WrapCrossAlignment.center,
      children: [
        // Preset dropdown
        _PresetDropdown(value: selectedPreset, onChanged: onPresetChanged),

        // Date range display - always visible
        Material(
          color: Colors.transparent,
          child: InkWell(
            onTap: onDateRangeSelected,
            borderRadius: kAgendaPillRadius,
            child: Container(
              height: kAgendaControlHeight,
              padding: const EdgeInsets.symmetric(
                horizontal: kAgendaControlHorizontalPadding,
              ),
              decoration: BoxDecoration(
                border: Border.all(color: Colors.grey.withOpacity(0.35)),
                borderRadius: kAgendaPillRadius,
              ),
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(
                    Icons.calendar_today,
                    size: 16,
                    color: colorScheme.primary,
                  ),
                  const SizedBox(width: 8),
                  Text(
                    '${dateFormat.format(startDate)} - ${dateFormat.format(endDate)}',
                    style: theme.textTheme.bodyMedium,
                  ),
                ],
              ),
            ),
          ),
        ),

        // Full period toggle
        if (_supportsFullPeriod && !isCompact)
          Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              SizedBox(
                height: 24,
                child: Switch(
                  value: useFullPeriod,
                  onChanged: onFullPeriodChanged,
                ),
              ),
              const SizedBox(width: 4),
              Text(
                l10n.reportsFullPeriodToggle,
                style: theme.textTheme.bodySmall?.copyWith(
                  color: colorScheme.onSurfaceVariant,
                ),
              ),
            ],
          ),
      ],
    );
  }
}

class _PresetDropdown extends StatelessWidget {
  const _PresetDropdown({required this.value, required this.onChanged});

  final String value;
  final ValueChanged<String> onChanged;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    return Container(
      height: kAgendaControlHeight,
      padding: const EdgeInsets.symmetric(
        horizontal: kAgendaControlHorizontalPadding,
      ),
      decoration: BoxDecoration(
        border: Border.all(color: Colors.grey.withOpacity(0.35)),
        borderRadius: kAgendaPillRadius,
      ),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: value,
          isDense: true,
          icon: const Icon(Icons.arrow_drop_down),
          style: theme.textTheme.bodyMedium,
          onChanged: (v) {
            if (v != null) onChanged(v);
          },
          items: [
            DropdownMenuItem(
              value: 'custom',
              child: Text(l10n.reportsPresetCustom),
            ),
            DropdownMenuItem(
              value: 'today',
              child: Text(l10n.reportsPresetToday),
            ),
            DropdownMenuItem(
              value: 'month',
              child: Text(l10n.reportsPresetMonth),
            ),
            DropdownMenuItem(
              value: 'quarter',
              child: Text(l10n.reportsPresetQuarter),
            ),
            DropdownMenuItem(
              value: 'semester',
              child: Text(l10n.reportsPresetSemester),
            ),
            DropdownMenuItem(
              value: 'year',
              child: Text(l10n.reportsPresetYear),
            ),
            DropdownMenuItem(
              value: 'last_month',
              child: Text(l10n.reportsPresetLastMonth),
            ),
            DropdownMenuItem(
              value: 'last_3_months',
              child: Text(l10n.reportsPresetLast3Months),
            ),
            DropdownMenuItem(
              value: 'last_6_months',
              child: Text(l10n.reportsPresetLast6Months),
            ),
            DropdownMenuItem(
              value: 'last_year',
              child: Text(l10n.reportsPresetLastYear),
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/main.dart ---
import 'package:agenda_backend/app/app.dart';
import 'package:agenda_backend/core/services/preferences_service.dart';
import 'package:agenda_backend/core/services/version_checker.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_web_plugins/url_strategy.dart';
import 'package:shared_preferences/shared_preferences.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  usePathUrlStrategy(); // Usa URL path-based (senza #)

  // Avvia il controllo periodico della versione (solo web).
  // Se rileva una nuova versione, forza il reload automatico.
  VersionChecker.instance.startPeriodicCheck();

  // Inizializza SharedPreferences
  final prefs = await SharedPreferences.getInstance();

  runApp(
    ProviderScope(
      overrides: [sharedPreferencesProvider.overrideWithValue(prefs)],
      child: const MyApp(),
    ),
  );
}
--- FILE: pubspec.yaml ---
name: agenda_backend
description: "A new Flutter project."
publish_to: 'none'
version: 1.0.0+1

environment:
  sdk: ^3.10.4

dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter
  flutter_web_plugins:
    sdk: flutter
  
  intl: ^0.20.2    
  characters: ^1.4.0
  flutter_riverpod: ^3.0.3
  riverpod_annotation: ^3.0.3
  go_router: ^16.2.4
  url_launcher: ^6.3.1
  dio: ^5.8.0+1
  uuid: ^4.5.1
  flutter_secure_storage: ^9.2.4
  shared_preferences: ^2.3.5
  http: ^1.6.0
dev_dependencies:
  build_runner: ^2.7.1
  riverpod_generator: ^3.0.3
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0
  intl_utils: ^2.8.11

flutter:
  uses-material-design: true
  
  fonts:
    - family: Roboto
      fonts:
        - asset: fonts/Roboto-Regular.ttf


flutter_intl:
  enabled: true
  class_name: L10n
  main_locale: it
  arb_dir: lib/core/l10n
  output_dir: lib/core/l10n
