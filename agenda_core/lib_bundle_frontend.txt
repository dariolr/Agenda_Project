--- FILE: lib/core/l10n/l10_extension.dart ---
import 'package:flutter/widgets.dart';

import 'l10n.dart';

/// üî§ Estensione per accedere facilmente alle stringhe localizzate.
///
/// Permette di scrivere:
/// ```dart
/// Text(context.l10n.welcomeMessage)
/// ```
/// invece di:
/// ```dart
/// Text(L10n.of(context).welcomeMessage)
/// ```
///
/// ‚úÖ Compatibile con aggiornamenti runtime della lingua.
/// ‚úÖ Evita dipendenze da `L10n.current` statico.
/// ‚úÖ Standard consigliato per progetti Flutter internazionalizzati.
extension L10nX on BuildContext {
  /// Restituisce l'istanza corrente di [L10n] per questo [BuildContext].
  L10n get l10n => L10n.of(this);
}

extension DurationLocalization on BuildContext {
  String localizedDurationLabel(int minutes) {
    final hours = minutes ~/ 60;
    final mins = minutes % 60;
    final l10n = this.l10n;

    if (hours > 0 && mins > 0) {
      return l10n.durationHourMinute(hours, mins);
    } else if (hours > 0) {
      return l10n.durationHour(hours);
    } else {
      return l10n.durationMinute(mins);
    }
  }
}
--- FILE: lib/core/l10n/intl/messages_all.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that looks up messages for specific locales by
// delegating to the appropriate library.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:implementation_imports, file_names, unnecessary_new
// ignore_for_file:unnecessary_brace_in_string_interps, directives_ordering
// ignore_for_file:argument_type_not_assignable, invalid_assignment
// ignore_for_file:prefer_single_quotes, prefer_generic_function_type_aliases
// ignore_for_file:comment_references

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';
import 'package:intl/src/intl_helpers.dart';

import 'messages_en.dart' as messages_en;
import 'messages_it.dart' as messages_it;

typedef Future<dynamic> LibraryLoader();
Map<String, LibraryLoader> _deferredLibraries = {
  'en': () => new SynchronousFuture(null),
  'it': () => new SynchronousFuture(null),
};

MessageLookupByLibrary? _findExact(String localeName) {
  switch (localeName) {
    case 'en':
      return messages_en.messages;
    case 'it':
      return messages_it.messages;
    default:
      return null;
  }
}

/// User programs should call this before using [localeName] for messages.
Future<bool> initializeMessages(String localeName) {
  var availableLocale = Intl.verifiedLocale(
    localeName,
    (locale) => _deferredLibraries[locale] != null,
    onFailure: (_) => null,
  );
  if (availableLocale == null) {
    return new SynchronousFuture(false);
  }
  var lib = _deferredLibraries[availableLocale];
  lib == null ? new SynchronousFuture(false) : lib();
  initializeInternalMessageLookup(() => new CompositeMessageLookup());
  messageLookup.addLocale(availableLocale, _findGeneratedMessagesFor);
  return new SynchronousFuture(true);
}

bool _messagesExistFor(String locale) {
  try {
    return _findExact(locale) != null;
  } catch (e) {
    return false;
  }
}

MessageLookupByLibrary? _findGeneratedMessagesFor(String locale) {
  var actualLocale = Intl.verifiedLocale(
    locale,
    _messagesExistFor,
    onFailure: (_) => null,
  );
  if (actualLocale == null) return null;
  return _findExact(actualLocale);
}
--- FILE: lib/core/l10n/intl/messages_it.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that provides messages for a it locale. All the
// messages from the main program should be duplicated here with the same
// function name.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:unnecessary_brace_in_string_interps, unnecessary_new
// ignore_for_file:prefer_single_quotes,comment_references, directives_ordering
// ignore_for_file:annotate_overrides,prefer_generic_function_type_aliases
// ignore_for_file:unused_import, file_names, avoid_escaping_inner_quotes
// ignore_for_file:unnecessary_string_interpolations, unnecessary_string_escapes

import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = new MessageLookup();

typedef String MessageIfAbsent(String messageStr, List<dynamic> args);

class MessageLookup extends MessageLookupByLibrary {
  String get localeName => 'it';

  static String m0(message) => "Errore di validazione: ${message}";

  static String m1(fields) => "Campi modificati: ${fields}";

  static String m2(type) => "Inviata email di tipo: ${type}";

  static String m3(email) => "Destinatario: ${email}";

  static String m4(dateTime) => "Data invio: ${dateTime}";

  static String m5(id) => "Codice prenotazione: ${id}";

  static String m6(date) => "Prima disponibilit√†: ${date}";

  static String m7(hours) => "${hours} ora";

  static String m8(hours, minutes) => "${hours} ora ${minutes} min";

  static String m9(minutes) => "${minutes} min";

  static String m10(minutes) => "${minutes} min";

  static String m11(path) => "Pagina non trovata: ${path}";

  static String m12(dateTime) => "Modificabile fino al ${dateTime}";

  static String m13(days) =>
      "${Intl.plural(days, one: 'Modificabile fino a domani', other: 'Modificabile fino a ${days} giorni')}";

  static String m14(hours) =>
      "${Intl.plural(hours, one: 'Modificabile fino a 1 ora', other: 'Modificabile fino a ${hours} ore')}";

  static String m15(minutes) =>
      "${Intl.plural(minutes, one: 'Modificabile fino a 1 minuto', other: 'Modificabile fino a ${minutes} minuti')}";

  static String m16(price) => "‚Ç¨${price}";

  static String m17(id) => "Categoria ${id}";

  static String m18(duration) => "${duration} min";

  static String m19(price) => "da ${price}";

  static String m20(count) =>
      "${Intl.plural(count, zero: 'Nessun servizio selezionato', one: '1 servizio selezionato', other: '${count} servizi selezionati')}";

  static String m21(total) => "Totale: ${total}";

  static String m22(days) => "Fino a ${days} giorni prima";

  static String m23(hours) => "Fino a ${hours} ore prima";

  static String m24(businessName) =>
      "Per prenotare su ${businessName}, devi accedere con un account registrato qui.";

  final messages = _notInlinedMessages(_notInlinedMessages);
  static Map<String, Function> _notInlinedMessages(_) => <String, Function>{
    "actionBack": MessageLookupByLibrary.simpleMessage("Indietro"),
    "actionCancel": MessageLookupByLibrary.simpleMessage("Annulla"),
    "actionCancelBooking": MessageLookupByLibrary.simpleMessage("Annulla"),
    "actionClose": MessageLookupByLibrary.simpleMessage("Chiudi"),
    "actionConfirm": MessageLookupByLibrary.simpleMessage("Conferma"),
    "actionDelete": MessageLookupByLibrary.simpleMessage("Elimina"),
    "actionLogin": MessageLookupByLibrary.simpleMessage("Accedi"),
    "actionLogout": MessageLookupByLibrary.simpleMessage("Esci"),
    "actionNext": MessageLookupByLibrary.simpleMessage("Avanti"),
    "actionRegister": MessageLookupByLibrary.simpleMessage("Registrati"),
    "actionRetry": MessageLookupByLibrary.simpleMessage("Riprova"),
    "appTitle": MessageLookupByLibrary.simpleMessage("Prenota Online"),
    "authBusinessNotFound": MessageLookupByLibrary.simpleMessage(
      "Impossibile caricare le informazioni del business. Riprova.",
    ),
    "authChangePassword": MessageLookupByLibrary.simpleMessage(
      "Cambia password",
    ),
    "authChangePasswordError": MessageLookupByLibrary.simpleMessage(
      "Password attuale non corretta",
    ),
    "authChangePasswordSuccess": MessageLookupByLibrary.simpleMessage(
      "Password modificata con successo",
    ),
    "authChangePasswordTitle": MessageLookupByLibrary.simpleMessage(
      "Cambia password",
    ),
    "authConfirmPassword": MessageLookupByLibrary.simpleMessage(
      "Conferma password",
    ),
    "authCurrentPassword": MessageLookupByLibrary.simpleMessage(
      "Password attuale",
    ),
    "authEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "authEmailAlreadyRegistered": MessageLookupByLibrary.simpleMessage(
      "Questa email √® gi√† registrata. Prova ad accedere.",
    ),
    "authErrorAccountDisabled": MessageLookupByLibrary.simpleMessage(
      "Il tuo account √® disabilitato",
    ),
    "authErrorEmailAlreadyExists": MessageLookupByLibrary.simpleMessage(
      "Questa email √® gi√† registrata. Prova ad accedere.",
    ),
    "authErrorInvalidCredentials": MessageLookupByLibrary.simpleMessage(
      "Email o password non valide",
    ),
    "authErrorInvalidResetToken": MessageLookupByLibrary.simpleMessage(
      "Token di reset password non valido",
    ),
    "authErrorResetTokenExpired": MessageLookupByLibrary.simpleMessage(
      "Token di reset password scaduto",
    ),
    "authErrorSessionRevoked": MessageLookupByLibrary.simpleMessage(
      "Sessione revocata. Effettua di nuovo il login.",
    ),
    "authErrorTokenExpired": MessageLookupByLibrary.simpleMessage(
      "Sessione scaduta. Effettua di nuovo il login.",
    ),
    "authErrorTokenInvalid": MessageLookupByLibrary.simpleMessage(
      "Sessione non valida. Effettua di nuovo il login.",
    ),
    "authErrorWeakPassword": MessageLookupByLibrary.simpleMessage(
      "Password troppo debole. Scegline una pi√π sicura.",
    ),
    "authFirstName": MessageLookupByLibrary.simpleMessage("Nome"),
    "authForgotPassword": MessageLookupByLibrary.simpleMessage(
      "Password dimenticata?",
    ),
    "authHaveAccount": MessageLookupByLibrary.simpleMessage(
      "Hai gi√† un account?",
    ),
    "authInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Email non valida",
    ),
    "authInvalidPassword": MessageLookupByLibrary.simpleMessage(
      "La password deve contenere almeno 8 caratteri, una maiuscola, una minuscola e un numero",
    ),
    "authInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Numero di telefono non valido",
    ),
    "authLastName": MessageLookupByLibrary.simpleMessage("Cognome"),
    "authLoginFailed": MessageLookupByLibrary.simpleMessage(
      "Credenziali non valide",
    ),
    "authLoginSuccess": MessageLookupByLibrary.simpleMessage(
      "Accesso effettuato",
    ),
    "authLoginTitle": MessageLookupByLibrary.simpleMessage(
      "Accedi al tuo account",
    ),
    "authNewPassword": MessageLookupByLibrary.simpleMessage("Nuova password"),
    "authNoAccount": MessageLookupByLibrary.simpleMessage(
      "Non hai un account?",
    ),
    "authPassword": MessageLookupByLibrary.simpleMessage("Password"),
    "authPasswordMismatch": MessageLookupByLibrary.simpleMessage(
      "Le password non coincidono",
    ),
    "authPasswordRequirements": MessageLookupByLibrary.simpleMessage(
      "La password deve contenere: maiuscola, minuscola, numero",
    ),
    "authPasswordTooShort": MessageLookupByLibrary.simpleMessage(
      "Password troppo corta (min. 8 caratteri)",
    ),
    "authPasswordValidationError": m0,
    "authPhone": MessageLookupByLibrary.simpleMessage("Telefono"),
    "authRedirectFromBooking": MessageLookupByLibrary.simpleMessage(
      "Per prenotare un appuntamento, accedi con il tuo account o registrati se non ne hai ancora uno.",
    ),
    "authRedirectFromMyBookings": MessageLookupByLibrary.simpleMessage(
      "Per visualizzare i tuoi appuntamenti, accedi con il tuo account o registrati se non ne hai ancora uno.",
    ),
    "authRegisterFailed": MessageLookupByLibrary.simpleMessage(
      "Registrazione fallita",
    ),
    "authRegisterSuccess": MessageLookupByLibrary.simpleMessage(
      "Registrazione completata",
    ),
    "authRegisterTitle": MessageLookupByLibrary.simpleMessage(
      "Crea un nuovo account",
    ),
    "authRememberMe": MessageLookupByLibrary.simpleMessage("Ricordami"),
    "authRequiredField": MessageLookupByLibrary.simpleMessage(
      "Campo obbligatorio",
    ),
    "authResetPasswordConfirmError": MessageLookupByLibrary.simpleMessage(
      "Token non valido o scaduto",
    ),
    "authResetPasswordConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "Inserisci la nuova password",
    ),
    "authResetPasswordConfirmSuccess": MessageLookupByLibrary.simpleMessage(
      "Password reimpostata con successo!",
    ),
    "authResetPasswordConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Reimposta password",
    ),
    "authResetPasswordEmailNotFound": MessageLookupByLibrary.simpleMessage(
      "Email non trovata nel sistema. Verifica l\'indirizzo o registrati.",
    ),
    "authResetPasswordError": MessageLookupByLibrary.simpleMessage(
      "Errore durante l\'invio. Riprova.",
    ),
    "authResetPasswordMessage": MessageLookupByLibrary.simpleMessage(
      "Inserisci la tua email e ti invieremo le istruzioni per reimpostare la password.",
    ),
    "authResetPasswordSend": MessageLookupByLibrary.simpleMessage("Invia"),
    "authResetPasswordSuccess": MessageLookupByLibrary.simpleMessage(
      "Email inviata! Controlla la tua casella di posta.",
    ),
    "authResetPasswordTitle": MessageLookupByLibrary.simpleMessage(
      "Recupera password",
    ),
    "authWelcome": MessageLookupByLibrary.simpleMessage("Benvenuto"),
    "bookingCancelFailed": MessageLookupByLibrary.simpleMessage(
      "Errore durante l\'annullamento della prenotazione. Riprova.",
    ),
    "bookingCancelled": MessageLookupByLibrary.simpleMessage(
      "Prenotazione annullata con successo",
    ),
    "bookingErrorInvalidClient": MessageLookupByLibrary.simpleMessage(
      "Il cliente selezionato non √® valido",
    ),
    "bookingErrorInvalidLocation": MessageLookupByLibrary.simpleMessage(
      "La sede selezionata non √® disponibile",
    ),
    "bookingErrorInvalidService": MessageLookupByLibrary.simpleMessage(
      "Uno o pi√π servizi selezionati non sono disponibili",
    ),
    "bookingErrorInvalidStaff": MessageLookupByLibrary.simpleMessage(
      "L\'operatore selezionato non √® disponibile per questi servizi",
    ),
    "bookingErrorInvalidTime": MessageLookupByLibrary.simpleMessage(
      "L\'orario selezionato non √® valido",
    ),
    "bookingErrorNotFound": MessageLookupByLibrary.simpleMessage(
      "Prenotazione non trovata",
    ),
    "bookingErrorNotModifiable": MessageLookupByLibrary.simpleMessage(
      "Questa prenotazione non pu√≤ essere modificata",
    ),
    "bookingErrorOutsideWorkingHours": MessageLookupByLibrary.simpleMessage(
      "L\'orario selezionato √® fuori dall\'orario di lavoro",
    ),
    "bookingErrorServer": MessageLookupByLibrary.simpleMessage(
      "Si √® verificato un errore. Riprova pi√π tardi",
    ),
    "bookingErrorSlotConflict": MessageLookupByLibrary.simpleMessage(
      "L\'orario selezionato non √® pi√π disponibile",
    ),
    "bookingErrorStaffUnavailable": MessageLookupByLibrary.simpleMessage(
      "L\'operatore selezionato non √® disponibile in questo orario",
    ),
    "bookingErrorUnauthorized": MessageLookupByLibrary.simpleMessage(
      "Non sei autorizzato a completare questa azione",
    ),
    "bookingErrorValidation": MessageLookupByLibrary.simpleMessage(
      "Controlla i dati inseriti",
    ),
    "bookingHistoryActorCustomer": MessageLookupByLibrary.simpleMessage(
      "Cliente",
    ),
    "bookingHistoryActorStaff": MessageLookupByLibrary.simpleMessage("Staff"),
    "bookingHistoryActorSystem": MessageLookupByLibrary.simpleMessage(
      "Sistema",
    ),
    "bookingHistoryChangedFields": m1,
    "bookingHistoryEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessun evento registrato",
    ),
    "bookingHistoryError": MessageLookupByLibrary.simpleMessage(
      "Errore nel caricamento dello storico",
    ),
    "bookingHistoryEventAppointmentUpdated":
        MessageLookupByLibrary.simpleMessage("Appuntamento modificato"),
    "bookingHistoryEventCancelled": MessageLookupByLibrary.simpleMessage(
      "Prenotazione annullata",
    ),
    "bookingHistoryEventCreated": MessageLookupByLibrary.simpleMessage(
      "Prenotazione creata",
    ),
    "bookingHistoryEventDurationChanged": MessageLookupByLibrary.simpleMessage(
      "Durata modificata",
    ),
    "bookingHistoryEventItemAdded": MessageLookupByLibrary.simpleMessage(
      "Servizio aggiunto",
    ),
    "bookingHistoryEventItemDeleted": MessageLookupByLibrary.simpleMessage(
      "Servizio rimosso",
    ),
    "bookingHistoryEventNotificationSentTitle": m2,
    "bookingHistoryEventPriceChanged": MessageLookupByLibrary.simpleMessage(
      "Prezzo modificato",
    ),
    "bookingHistoryEventReplaced": MessageLookupByLibrary.simpleMessage(
      "Prenotazione sostituita",
    ),
    "bookingHistoryEventStaffChanged": MessageLookupByLibrary.simpleMessage(
      "Operatore cambiato",
    ),
    "bookingHistoryEventTimeChanged": MessageLookupByLibrary.simpleMessage(
      "Orario modificato",
    ),
    "bookingHistoryEventUpdated": MessageLookupByLibrary.simpleMessage(
      "Prenotazione modificata",
    ),
    "bookingHistoryLoading": MessageLookupByLibrary.simpleMessage(
      "Caricamento storico...",
    ),
    "bookingHistoryNotificationChannelCancelled":
        MessageLookupByLibrary.simpleMessage("Cancellazione prenotazione"),
    "bookingHistoryNotificationChannelConfirmed":
        MessageLookupByLibrary.simpleMessage("Conferma prenotazione"),
    "bookingHistoryNotificationChannelReminder":
        MessageLookupByLibrary.simpleMessage("Promemoria prenotazione"),
    "bookingHistoryNotificationChannelRescheduled":
        MessageLookupByLibrary.simpleMessage("Riprogrammazione prenotazione"),
    "bookingHistoryNotificationRecipient": m3,
    "bookingHistoryNotificationSentAt": m4,
    "bookingHistoryTitle": MessageLookupByLibrary.simpleMessage(
      "Storico prenotazione",
    ),
    "bookingRescheduled": MessageLookupByLibrary.simpleMessage(
      "Prenotazione modificata con successo",
    ),
    "bookingStepDateTime": MessageLookupByLibrary.simpleMessage("Data e ora"),
    "bookingStepLocation": MessageLookupByLibrary.simpleMessage("Sede"),
    "bookingStepServices": MessageLookupByLibrary.simpleMessage("Servizi"),
    "bookingStepStaff": MessageLookupByLibrary.simpleMessage("Operatore"),
    "bookingStepSummary": MessageLookupByLibrary.simpleMessage("Riepilogo"),
    "bookingTitle": MessageLookupByLibrary.simpleMessage(
      "Prenota appuntamento",
    ),
    "bookingUpdatedTitle": MessageLookupByLibrary.simpleMessage(
      "Prenotazione aggiornata",
    ),
    "businessNotFound": MessageLookupByLibrary.simpleMessage(
      "Attivit√† non trovata",
    ),
    "businessNotFoundHint": MessageLookupByLibrary.simpleMessage(
      "Verifica l\'indirizzo o contatta direttamente l\'attivit√†.",
    ),
    "cancel": MessageLookupByLibrary.simpleMessage("Annulla"),
    "cancelBookingConfirm": MessageLookupByLibrary.simpleMessage(
      "Sei sicuro di voler annullare questa prenotazione?",
    ),
    "cancelBookingTitle": MessageLookupByLibrary.simpleMessage(
      "Annulla prenotazione",
    ),
    "cancelledBadge": MessageLookupByLibrary.simpleMessage("ANNULLATA"),
    "cancelledBookings": MessageLookupByLibrary.simpleMessage("Annullate"),
    "confirmReschedule": MessageLookupByLibrary.simpleMessage(
      "Conferma modifica",
    ),
    "confirmationBookingId": m5,
    "confirmationGoHome": MessageLookupByLibrary.simpleMessage(
      "Torna alla home",
    ),
    "confirmationNewBooking": MessageLookupByLibrary.simpleMessage(
      "Nuova prenotazione",
    ),
    "confirmationSubtitle": MessageLookupByLibrary.simpleMessage(
      "Ti abbiamo inviato un\'email di conferma",
    ),
    "confirmationTitle": MessageLookupByLibrary.simpleMessage(
      "Prenotazione confermata!",
    ),
    "currentBooking": MessageLookupByLibrary.simpleMessage(
      "Prenotazione attuale",
    ),
    "dateTimeAfternoon": MessageLookupByLibrary.simpleMessage("Pomeriggio"),
    "dateTimeEvening": MessageLookupByLibrary.simpleMessage("Sera"),
    "dateTimeFirstAvailable": m6,
    "dateTimeGoToFirst": MessageLookupByLibrary.simpleMessage(
      "Vai alla prima data disponibile",
    ),
    "dateTimeGoToNext": MessageLookupByLibrary.simpleMessage(
      "Vai alla prossima data disponibile",
    ),
    "dateTimeMorning": MessageLookupByLibrary.simpleMessage("Mattina"),
    "dateTimeNoSlots": MessageLookupByLibrary.simpleMessage(
      "Nessun orario disponibile per questa data",
    ),
    "dateTimeSelectDate": MessageLookupByLibrary.simpleMessage(
      "Seleziona una data",
    ),
    "dateTimeSubtitle": MessageLookupByLibrary.simpleMessage(
      "Seleziona quando desideri prenotare",
    ),
    "dateTimeTitle": MessageLookupByLibrary.simpleMessage("Scegli data e ora"),
    "durationHour": m7,
    "durationHourMinute": m8,
    "durationMinute": m9,
    "durationMinutes": m10,
    "errorBusinessNotActive": MessageLookupByLibrary.simpleMessage(
      "Attivit√† non attiva",
    ),
    "errorBusinessNotActiveSubtitle": MessageLookupByLibrary.simpleMessage(
      "Questa attivit√† non √® ancora configurata per le prenotazioni online. Contatta direttamente l\'attivit√†.",
    ),
    "errorBusinessNotFound": MessageLookupByLibrary.simpleMessage(
      "Attivit√† non trovata",
    ),
    "errorBusinessNotFoundSubtitle": MessageLookupByLibrary.simpleMessage(
      "L\'attivit√† richiesta non esiste. Verifica l\'indirizzo o contatta direttamente l\'attivit√†.",
    ),
    "errorConnectionTimeout": MessageLookupByLibrary.simpleMessage(
      "La connessione sta impiegando troppo tempo. Riprova.",
    ),
    "errorGeneric": MessageLookupByLibrary.simpleMessage(
      "Si √® verificato un errore",
    ),
    "errorLoadingAvailability": MessageLookupByLibrary.simpleMessage(
      "Impossibile caricare le disponibilit√†. Verifica la connessione e riprova.",
    ),
    "errorLoadingBookings": MessageLookupByLibrary.simpleMessage(
      "Errore nel caricamento delle prenotazioni",
    ),
    "errorLoadingServices": MessageLookupByLibrary.simpleMessage(
      "Impossibile caricare i servizi. Verifica la connessione e riprova.",
    ),
    "errorLoadingStaff": MessageLookupByLibrary.simpleMessage(
      "Impossibile caricare gli operatori. Verifica la connessione e riprova.",
    ),
    "errorLocationNotFound": MessageLookupByLibrary.simpleMessage(
      "Sede non disponibile",
    ),
    "errorLocationNotFoundSubtitle": MessageLookupByLibrary.simpleMessage(
      "La sede selezionata non √® attiva. Contatta l\'attivit√† per maggiori informazioni.",
    ),
    "errorNoAvailability": MessageLookupByLibrary.simpleMessage(
      "Nessuna disponibilit√† per la data selezionata",
    ),
    "errorNotFound": m11,
    "errorServiceUnavailable": MessageLookupByLibrary.simpleMessage(
      "Servizio temporaneamente non disponibile",
    ),
    "errorServiceUnavailableSubtitle": MessageLookupByLibrary.simpleMessage(
      "Stiamo lavorando per risolvere il problema. Riprova tra qualche minuto.",
    ),
    "errorTitle": MessageLookupByLibrary.simpleMessage("Errore"),
    "loadingAvailability": MessageLookupByLibrary.simpleMessage(
      "Caricamento disponibilit√†...",
    ),
    "loadingGeneric": MessageLookupByLibrary.simpleMessage("Caricamento..."),
    "locationEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessuna sede disponibile",
    ),
    "locationSubtitle": MessageLookupByLibrary.simpleMessage(
      "Seleziona dove vuoi effettuare la prenotazione",
    ),
    "locationTitle": MessageLookupByLibrary.simpleMessage("Scegli la sede"),
    "modifiable": MessageLookupByLibrary.simpleMessage("Modificabile"),
    "modifiableUntilDateTime": m12,
    "modifiableUntilDays": m13,
    "modifiableUntilHours": m14,
    "modifiableUntilMinutes": m15,
    "modify": MessageLookupByLibrary.simpleMessage("Riprogramma"),
    "modifyNotImplemented": MessageLookupByLibrary.simpleMessage(
      "Funzione di modifica in sviluppo",
    ),
    "monthApril": MessageLookupByLibrary.simpleMessage("Aprile"),
    "monthAugust": MessageLookupByLibrary.simpleMessage("Agosto"),
    "monthDecember": MessageLookupByLibrary.simpleMessage("Dicembre"),
    "monthFebruary": MessageLookupByLibrary.simpleMessage("Febbraio"),
    "monthJanuary": MessageLookupByLibrary.simpleMessage("Gennaio"),
    "monthJuly": MessageLookupByLibrary.simpleMessage("Luglio"),
    "monthJune": MessageLookupByLibrary.simpleMessage("Giugno"),
    "monthMarch": MessageLookupByLibrary.simpleMessage("Marzo"),
    "monthMay": MessageLookupByLibrary.simpleMessage("Maggio"),
    "monthNovember": MessageLookupByLibrary.simpleMessage("Novembre"),
    "monthOctober": MessageLookupByLibrary.simpleMessage("Ottobre"),
    "monthSeptember": MessageLookupByLibrary.simpleMessage("Settembre"),
    "myBookings": MessageLookupByLibrary.simpleMessage("Le mie prenotazioni"),
    "no": MessageLookupByLibrary.simpleMessage("No"),
    "noCancelledBookings": MessageLookupByLibrary.simpleMessage(
      "Non hai prenotazioni annullate",
    ),
    "noPastBookings": MessageLookupByLibrary.simpleMessage(
      "Non hai prenotazioni passate",
    ),
    "noStaffForAllServices": MessageLookupByLibrary.simpleMessage(
      "Nessun operatore pu√≤ eseguire tutti i servizi selezionati. Prova a selezionare meno servizi o servizi diversi.",
    ),
    "noUpcomingBookings": MessageLookupByLibrary.simpleMessage(
      "Non hai prenotazioni in programma",
    ),
    "notModifiable": MessageLookupByLibrary.simpleMessage("Non modificabile"),
    "pastBookings": MessageLookupByLibrary.simpleMessage("Passate"),
    "priceFormat": m16,
    "profileTitle": MessageLookupByLibrary.simpleMessage("Profilo"),
    "rescheduleBookingTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica prenotazione",
    ),
    "selectDate": MessageLookupByLibrary.simpleMessage("Seleziona data"),
    "selectNewDate": MessageLookupByLibrary.simpleMessage(
      "Seleziona nuova data",
    ),
    "selectNewTime": MessageLookupByLibrary.simpleMessage(
      "Seleziona nuovo orario",
    ),
    "servicePackageExpandError": MessageLookupByLibrary.simpleMessage(
      "Impossibile espandere il pacchetto selezionato.",
    ),
    "servicePackageLabel": MessageLookupByLibrary.simpleMessage("Pacchetto"),
    "servicePackagesLoadError": MessageLookupByLibrary.simpleMessage(
      "Impossibile caricare i pacchetti.",
    ),
    "servicePackagesLoading": MessageLookupByLibrary.simpleMessage(
      "Caricamento pacchetti...",
    ),
    "servicePackagesSubtitle": MessageLookupByLibrary.simpleMessage(
      "Oppure scegli un pacchetto pronto",
    ),
    "servicePackagesTitle": MessageLookupByLibrary.simpleMessage("Pacchetti"),
    "servicesCategoryFallbackName": m17,
    "servicesDuration": m18,
    "servicesEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessun servizio disponibile al momento",
    ),
    "servicesEmptySubtitle": MessageLookupByLibrary.simpleMessage(
      "Non ci sono servizi prenotabili online per questa attivit√†",
    ),
    "servicesFree": MessageLookupByLibrary.simpleMessage("Gratis"),
    "servicesPriceFrom": m19,
    "servicesSelected": m20,
    "servicesSubtitle": MessageLookupByLibrary.simpleMessage(
      "Puoi selezionare uno o pi√π servizi",
    ),
    "servicesTitle": MessageLookupByLibrary.simpleMessage("Scegli i servizi"),
    "servicesTotal": m21,
    "sessionExpired": MessageLookupByLibrary.simpleMessage(
      "Sessione scaduta. Effettua nuovamente l\'accesso.",
    ),
    "slotNoLongerAvailable": MessageLookupByLibrary.simpleMessage(
      "Lo slot non √® pi√π disponibile. La prenotazione originale √® rimasta invariata.",
    ),
    "staffAnyOperator": MessageLookupByLibrary.simpleMessage(
      "Qualsiasi operatore disponibile",
    ),
    "staffAnyOperatorSubtitle": MessageLookupByLibrary.simpleMessage(
      "Ti assegneremo il primo operatore libero",
    ),
    "staffEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessun operatore disponibile al momento",
    ),
    "staffSubtitle": MessageLookupByLibrary.simpleMessage(
      "Seleziona con chi desideri essere servito",
    ),
    "staffTitle": MessageLookupByLibrary.simpleMessage("Scegli l\'operatore"),
    "summaryCancellationPolicyAcceptLabel":
        MessageLookupByLibrary.simpleMessage(
          "Accetto la policy di modifica/cancellazione",
        ),
    "summaryCancellationPolicyAcceptRequiredError":
        MessageLookupByLibrary.simpleMessage(
          "Per confermare devi accettare la policy di modifica/cancellazione.",
        ),
    "summaryCancellationPolicyAlways": MessageLookupByLibrary.simpleMessage(
      "Sempre",
    ),
    "summaryCancellationPolicyDays": m22,
    "summaryCancellationPolicyHours": m23,
    "summaryCancellationPolicyNever": MessageLookupByLibrary.simpleMessage(
      "Mai (non consentita dopo la prenotazione)",
    ),
    "summaryCancellationPolicyTitle": MessageLookupByLibrary.simpleMessage(
      "Policy modifica/cancellazione",
    ),
    "summaryDateTime": MessageLookupByLibrary.simpleMessage("Data e ora"),
    "summaryDuration": MessageLookupByLibrary.simpleMessage("Durata totale"),
    "summaryNotes": MessageLookupByLibrary.simpleMessage("Note (opzionale)"),
    "summaryNotesHint": MessageLookupByLibrary.simpleMessage(
      "Aggiungi eventuali note per l\'appuntamento...",
    ),
    "summaryOperator": MessageLookupByLibrary.simpleMessage("Operatore"),
    "summaryPrice": MessageLookupByLibrary.simpleMessage("Prezzo totale"),
    "summaryServices": MessageLookupByLibrary.simpleMessage(
      "Servizi selezionati",
    ),
    "summarySubtitle": MessageLookupByLibrary.simpleMessage(
      "Controlla i dettagli prima di confermare",
    ),
    "summaryTitle": MessageLookupByLibrary.simpleMessage(
      "Riepilogo prenotazione",
    ),
    "upcomingBookings": MessageLookupByLibrary.simpleMessage("Prossime"),
    "validationInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Email non valida",
    ),
    "validationInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Telefono non valido",
    ),
    "validationRequired": MessageLookupByLibrary.simpleMessage(
      "Campo obbligatorio",
    ),
    "weekdayFri": MessageLookupByLibrary.simpleMessage("Ven"),
    "weekdayMon": MessageLookupByLibrary.simpleMessage("Lun"),
    "weekdaySat": MessageLookupByLibrary.simpleMessage("Sab"),
    "weekdaySun": MessageLookupByLibrary.simpleMessage("Dom"),
    "weekdayThu": MessageLookupByLibrary.simpleMessage("Gio"),
    "weekdayTue": MessageLookupByLibrary.simpleMessage("Mar"),
    "weekdayWed": MessageLookupByLibrary.simpleMessage("Mer"),
    "wrongBusinessAuthAction": MessageLookupByLibrary.simpleMessage(
      "Esci e accedi qui",
    ),
    "wrongBusinessAuthMessage": m24,
    "wrongBusinessAuthTitle": MessageLookupByLibrary.simpleMessage(
      "Account associato ad un\'altra attivit√†",
    ),
    "yes": MessageLookupByLibrary.simpleMessage("S√¨"),
  };
}
--- FILE: lib/core/l10n/intl/messages_en.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that provides messages for a en locale. All the
// messages from the main program should be duplicated here with the same
// function name.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:unnecessary_brace_in_string_interps, unnecessary_new
// ignore_for_file:prefer_single_quotes,comment_references, directives_ordering
// ignore_for_file:annotate_overrides,prefer_generic_function_type_aliases
// ignore_for_file:unused_import, file_names, avoid_escaping_inner_quotes
// ignore_for_file:unnecessary_string_interpolations, unnecessary_string_escapes

import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = new MessageLookup();

typedef String MessageIfAbsent(String messageStr, List<dynamic> args);

class MessageLookup extends MessageLookupByLibrary {
  String get localeName => 'en';

  static String m0(message) => "Validation error: ${message}";

  static String m1(fields) => "Changed fields: ${fields}";

  static String m2(type) => "Email sent of type: ${type}";

  static String m3(email) => "Recipient: ${email}";

  static String m4(dateTime) => "Sent at: ${dateTime}";

  static String m5(id) => "Booking code: ${id}";

  static String m6(date) => "First available: ${date}";

  static String m7(hours) => "${hours} hour";

  static String m8(hours, minutes) => "${hours} hour ${minutes} min";

  static String m9(minutes) => "${minutes} min";

  static String m10(minutes) => "${minutes} min";

  static String m11(path) => "Page not found: ${path}";

  static String m12(dateTime) => "Modifiable until ${dateTime}";

  static String m13(days) =>
      "${Intl.plural(days, one: 'Modifiable until tomorrow', other: 'Modifiable for ${days} days')}";

  static String m14(hours) =>
      "${Intl.plural(hours, one: 'Modifiable for 1 hour', other: 'Modifiable for ${hours} hours')}";

  static String m15(minutes) =>
      "${Intl.plural(minutes, one: 'Modifiable for 1 minute', other: 'Modifiable for ${minutes} minutes')}";

  static String m16(price) => "‚Ç¨${price}";

  static String m17(id) => "Category ${id}";

  static String m18(duration) => "${duration} min";

  static String m19(price) => "from ${price}";

  static String m20(count) =>
      "${Intl.plural(count, zero: 'No service selected', one: '1 service selected', other: '${count} services selected')}";

  static String m21(total) => "Total: ${total}";

  static String m22(days) => "Up to ${days} days before";

  static String m23(hours) => "Up to ${hours} hours before";

  static String m24(businessName) =>
      "To book at ${businessName}, you need to log in with an account registered here.";

  final messages = _notInlinedMessages(_notInlinedMessages);
  static Map<String, Function> _notInlinedMessages(_) => <String, Function>{
    "actionBack": MessageLookupByLibrary.simpleMessage("Back"),
    "actionCancel": MessageLookupByLibrary.simpleMessage("Cancel"),
    "actionCancelBooking": MessageLookupByLibrary.simpleMessage("Cancel"),
    "actionClose": MessageLookupByLibrary.simpleMessage("Close"),
    "actionConfirm": MessageLookupByLibrary.simpleMessage("Confirm"),
    "actionDelete": MessageLookupByLibrary.simpleMessage("Delete"),
    "actionLogin": MessageLookupByLibrary.simpleMessage("Login"),
    "actionLogout": MessageLookupByLibrary.simpleMessage("Logout"),
    "actionNext": MessageLookupByLibrary.simpleMessage("Next"),
    "actionRegister": MessageLookupByLibrary.simpleMessage("Register"),
    "actionRetry": MessageLookupByLibrary.simpleMessage("Retry"),
    "appTitle": MessageLookupByLibrary.simpleMessage("Book Online"),
    "authBusinessNotFound": MessageLookupByLibrary.simpleMessage(
      "Unable to load business information. Please try again.",
    ),
    "authChangePassword": MessageLookupByLibrary.simpleMessage(
      "Change password",
    ),
    "authChangePasswordError": MessageLookupByLibrary.simpleMessage(
      "Current password is incorrect",
    ),
    "authChangePasswordSuccess": MessageLookupByLibrary.simpleMessage(
      "Password changed successfully",
    ),
    "authChangePasswordTitle": MessageLookupByLibrary.simpleMessage(
      "Change password",
    ),
    "authConfirmPassword": MessageLookupByLibrary.simpleMessage(
      "Confirm password",
    ),
    "authCurrentPassword": MessageLookupByLibrary.simpleMessage(
      "Current password",
    ),
    "authEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "authEmailAlreadyRegistered": MessageLookupByLibrary.simpleMessage(
      "This email is already registered. Try logging in.",
    ),
    "authErrorAccountDisabled": MessageLookupByLibrary.simpleMessage(
      "Your account is disabled",
    ),
    "authErrorEmailAlreadyExists": MessageLookupByLibrary.simpleMessage(
      "This email is already registered. Try logging in.",
    ),
    "authErrorInvalidCredentials": MessageLookupByLibrary.simpleMessage(
      "Invalid email or password",
    ),
    "authErrorInvalidResetToken": MessageLookupByLibrary.simpleMessage(
      "Invalid password reset token",
    ),
    "authErrorResetTokenExpired": MessageLookupByLibrary.simpleMessage(
      "Password reset token has expired",
    ),
    "authErrorSessionRevoked": MessageLookupByLibrary.simpleMessage(
      "Your session has been revoked. Please log in again.",
    ),
    "authErrorTokenExpired": MessageLookupByLibrary.simpleMessage(
      "Your session has expired. Please log in again.",
    ),
    "authErrorTokenInvalid": MessageLookupByLibrary.simpleMessage(
      "Your session is not valid. Please log in again.",
    ),
    "authErrorWeakPassword": MessageLookupByLibrary.simpleMessage(
      "Password too weak. Please choose a stronger password.",
    ),
    "authFirstName": MessageLookupByLibrary.simpleMessage("First name"),
    "authForgotPassword": MessageLookupByLibrary.simpleMessage(
      "Forgot password?",
    ),
    "authHaveAccount": MessageLookupByLibrary.simpleMessage(
      "Already have an account?",
    ),
    "authInvalidEmail": MessageLookupByLibrary.simpleMessage("Invalid email"),
    "authInvalidPassword": MessageLookupByLibrary.simpleMessage(
      "Password must contain at least 8 characters, one uppercase, one lowercase and one number",
    ),
    "authInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Invalid phone number",
    ),
    "authLastName": MessageLookupByLibrary.simpleMessage("Last name"),
    "authLoginFailed": MessageLookupByLibrary.simpleMessage(
      "Invalid credentials",
    ),
    "authLoginSuccess": MessageLookupByLibrary.simpleMessage(
      "Login successful",
    ),
    "authLoginTitle": MessageLookupByLibrary.simpleMessage(
      "Login to your account",
    ),
    "authNewPassword": MessageLookupByLibrary.simpleMessage("New password"),
    "authNoAccount": MessageLookupByLibrary.simpleMessage(
      "Don\'t have an account?",
    ),
    "authPassword": MessageLookupByLibrary.simpleMessage("Password"),
    "authPasswordMismatch": MessageLookupByLibrary.simpleMessage(
      "Passwords don\'t match",
    ),
    "authPasswordRequirements": MessageLookupByLibrary.simpleMessage(
      "Password must contain: uppercase, lowercase, number",
    ),
    "authPasswordTooShort": MessageLookupByLibrary.simpleMessage(
      "Password too short (min. 8 characters)",
    ),
    "authPasswordValidationError": m0,
    "authPhone": MessageLookupByLibrary.simpleMessage("Phone"),
    "authRedirectFromBooking": MessageLookupByLibrary.simpleMessage(
      "To book an appointment, log in with your account or register if you don\'t have one yet.",
    ),
    "authRedirectFromMyBookings": MessageLookupByLibrary.simpleMessage(
      "To view your appointments, log in with your account or register if you don\'t have one yet.",
    ),
    "authRegisterFailed": MessageLookupByLibrary.simpleMessage(
      "Registration failed",
    ),
    "authRegisterSuccess": MessageLookupByLibrary.simpleMessage(
      "Registration completed",
    ),
    "authRegisterTitle": MessageLookupByLibrary.simpleMessage(
      "Create a new account",
    ),
    "authRememberMe": MessageLookupByLibrary.simpleMessage("Remember me"),
    "authRequiredField": MessageLookupByLibrary.simpleMessage("Required field"),
    "authResetPasswordConfirmError": MessageLookupByLibrary.simpleMessage(
      "Invalid or expired token",
    ),
    "authResetPasswordConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "Enter your new password",
    ),
    "authResetPasswordConfirmSuccess": MessageLookupByLibrary.simpleMessage(
      "Password reset successful!",
    ),
    "authResetPasswordConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Reset password",
    ),
    "authResetPasswordEmailNotFound": MessageLookupByLibrary.simpleMessage(
      "Email not found in our system. Please check the address or register.",
    ),
    "authResetPasswordError": MessageLookupByLibrary.simpleMessage(
      "Error sending email. Please try again.",
    ),
    "authResetPasswordMessage": MessageLookupByLibrary.simpleMessage(
      "Enter your email and we\'ll send you instructions to reset your password.",
    ),
    "authResetPasswordSend": MessageLookupByLibrary.simpleMessage("Send"),
    "authResetPasswordSuccess": MessageLookupByLibrary.simpleMessage(
      "Email sent! Check your inbox.",
    ),
    "authResetPasswordTitle": MessageLookupByLibrary.simpleMessage(
      "Reset password",
    ),
    "authWelcome": MessageLookupByLibrary.simpleMessage("Welcome"),
    "bookingCancelFailed": MessageLookupByLibrary.simpleMessage(
      "Error cancelling booking",
    ),
    "bookingCancelled": MessageLookupByLibrary.simpleMessage(
      "Booking cancelled successfully",
    ),
    "bookingErrorInvalidClient": MessageLookupByLibrary.simpleMessage(
      "The selected client is not valid",
    ),
    "bookingErrorInvalidLocation": MessageLookupByLibrary.simpleMessage(
      "The selected location is not available",
    ),
    "bookingErrorInvalidService": MessageLookupByLibrary.simpleMessage(
      "One or more selected services are not available",
    ),
    "bookingErrorInvalidStaff": MessageLookupByLibrary.simpleMessage(
      "The selected staff member is not available for these services",
    ),
    "bookingErrorInvalidTime": MessageLookupByLibrary.simpleMessage(
      "The selected time is not valid",
    ),
    "bookingErrorNotFound": MessageLookupByLibrary.simpleMessage(
      "Booking not found",
    ),
    "bookingErrorNotModifiable": MessageLookupByLibrary.simpleMessage(
      "This booking cannot be modified",
    ),
    "bookingErrorOutsideWorkingHours": MessageLookupByLibrary.simpleMessage(
      "The selected time is outside working hours",
    ),
    "bookingErrorServer": MessageLookupByLibrary.simpleMessage(
      "Something went wrong. Please try again",
    ),
    "bookingErrorSlotConflict": MessageLookupByLibrary.simpleMessage(
      "The selected time slot is no longer available",
    ),
    "bookingErrorStaffUnavailable": MessageLookupByLibrary.simpleMessage(
      "The selected staff member is not available at this time",
    ),
    "bookingErrorUnauthorized": MessageLookupByLibrary.simpleMessage(
      "You are not authorized to complete this action",
    ),
    "bookingErrorValidation": MessageLookupByLibrary.simpleMessage(
      "Please check the entered data",
    ),
    "bookingHistoryActorCustomer": MessageLookupByLibrary.simpleMessage(
      "Customer",
    ),
    "bookingHistoryActorStaff": MessageLookupByLibrary.simpleMessage("Staff"),
    "bookingHistoryActorSystem": MessageLookupByLibrary.simpleMessage("System"),
    "bookingHistoryChangedFields": m1,
    "bookingHistoryEmpty": MessageLookupByLibrary.simpleMessage(
      "No events recorded",
    ),
    "bookingHistoryError": MessageLookupByLibrary.simpleMessage(
      "Error loading history",
    ),
    "bookingHistoryEventAppointmentUpdated":
        MessageLookupByLibrary.simpleMessage("Appointment updated"),
    "bookingHistoryEventCancelled": MessageLookupByLibrary.simpleMessage(
      "Booking cancelled",
    ),
    "bookingHistoryEventCreated": MessageLookupByLibrary.simpleMessage(
      "Booking created",
    ),
    "bookingHistoryEventDurationChanged": MessageLookupByLibrary.simpleMessage(
      "Duration changed",
    ),
    "bookingHistoryEventItemAdded": MessageLookupByLibrary.simpleMessage(
      "Service added",
    ),
    "bookingHistoryEventItemDeleted": MessageLookupByLibrary.simpleMessage(
      "Service removed",
    ),
    "bookingHistoryEventNotificationSentTitle": m2,
    "bookingHistoryEventPriceChanged": MessageLookupByLibrary.simpleMessage(
      "Price changed",
    ),
    "bookingHistoryEventReplaced": MessageLookupByLibrary.simpleMessage(
      "Booking replaced",
    ),
    "bookingHistoryEventStaffChanged": MessageLookupByLibrary.simpleMessage(
      "Staff changed",
    ),
    "bookingHistoryEventTimeChanged": MessageLookupByLibrary.simpleMessage(
      "Time changed",
    ),
    "bookingHistoryEventUpdated": MessageLookupByLibrary.simpleMessage(
      "Booking updated",
    ),
    "bookingHistoryLoading": MessageLookupByLibrary.simpleMessage(
      "Loading history...",
    ),
    "bookingHistoryNotificationChannelCancelled":
        MessageLookupByLibrary.simpleMessage("Booking cancellation"),
    "bookingHistoryNotificationChannelConfirmed":
        MessageLookupByLibrary.simpleMessage("Booking confirmation"),
    "bookingHistoryNotificationChannelReminder":
        MessageLookupByLibrary.simpleMessage("Booking reminder"),
    "bookingHistoryNotificationChannelRescheduled":
        MessageLookupByLibrary.simpleMessage("Booking rescheduled"),
    "bookingHistoryNotificationRecipient": m3,
    "bookingHistoryNotificationSentAt": m4,
    "bookingHistoryTitle": MessageLookupByLibrary.simpleMessage(
      "Booking history",
    ),
    "bookingRescheduled": MessageLookupByLibrary.simpleMessage(
      "Booking modified successfully",
    ),
    "bookingStepDateTime": MessageLookupByLibrary.simpleMessage("Date & Time"),
    "bookingStepLocation": MessageLookupByLibrary.simpleMessage("Location"),
    "bookingStepServices": MessageLookupByLibrary.simpleMessage("Services"),
    "bookingStepStaff": MessageLookupByLibrary.simpleMessage("Staff"),
    "bookingStepSummary": MessageLookupByLibrary.simpleMessage("Summary"),
    "bookingTitle": MessageLookupByLibrary.simpleMessage("Book appointment"),
    "bookingUpdatedTitle": MessageLookupByLibrary.simpleMessage(
      "Booking updated",
    ),
    "businessNotFound": MessageLookupByLibrary.simpleMessage(
      "Business not found",
    ),
    "businessNotFoundHint": MessageLookupByLibrary.simpleMessage(
      "Please check the URL or contact the business directly.",
    ),
    "cancel": MessageLookupByLibrary.simpleMessage("Cancel"),
    "cancelBookingConfirm": MessageLookupByLibrary.simpleMessage(
      "Are you sure you want to cancel this booking?",
    ),
    "cancelBookingTitle": MessageLookupByLibrary.simpleMessage(
      "Cancel booking",
    ),
    "cancelledBadge": MessageLookupByLibrary.simpleMessage("CANCELLED"),
    "cancelledBookings": MessageLookupByLibrary.simpleMessage("Cancelled"),
    "confirmReschedule": MessageLookupByLibrary.simpleMessage(
      "Confirm changes",
    ),
    "confirmationBookingId": m5,
    "confirmationGoHome": MessageLookupByLibrary.simpleMessage("Go to home"),
    "confirmationNewBooking": MessageLookupByLibrary.simpleMessage(
      "New booking",
    ),
    "confirmationSubtitle": MessageLookupByLibrary.simpleMessage(
      "We\'ve sent you a confirmation email",
    ),
    "confirmationTitle": MessageLookupByLibrary.simpleMessage(
      "Booking confirmed!",
    ),
    "currentBooking": MessageLookupByLibrary.simpleMessage("Current booking"),
    "dateTimeAfternoon": MessageLookupByLibrary.simpleMessage("Afternoon"),
    "dateTimeEvening": MessageLookupByLibrary.simpleMessage("Evening"),
    "dateTimeFirstAvailable": m6,
    "dateTimeGoToFirst": MessageLookupByLibrary.simpleMessage(
      "Go to first available date",
    ),
    "dateTimeGoToNext": MessageLookupByLibrary.simpleMessage(
      "Go to next available date",
    ),
    "dateTimeMorning": MessageLookupByLibrary.simpleMessage("Morning"),
    "dateTimeNoSlots": MessageLookupByLibrary.simpleMessage(
      "No time slots available for this date",
    ),
    "dateTimeSelectDate": MessageLookupByLibrary.simpleMessage("Select a date"),
    "dateTimeSubtitle": MessageLookupByLibrary.simpleMessage(
      "Select when you want to book",
    ),
    "dateTimeTitle": MessageLookupByLibrary.simpleMessage(
      "Choose date and time",
    ),
    "durationHour": m7,
    "durationHourMinute": m8,
    "durationMinute": m9,
    "durationMinutes": m10,
    "errorBusinessNotActive": MessageLookupByLibrary.simpleMessage(
      "Business not active",
    ),
    "errorBusinessNotActiveSubtitle": MessageLookupByLibrary.simpleMessage(
      "This business is not yet configured for online bookings. Please contact the business directly.",
    ),
    "errorBusinessNotFound": MessageLookupByLibrary.simpleMessage(
      "Business not found",
    ),
    "errorBusinessNotFoundSubtitle": MessageLookupByLibrary.simpleMessage(
      "The requested business does not exist. Please check the URL or contact the business directly.",
    ),
    "errorConnectionTimeout": MessageLookupByLibrary.simpleMessage(
      "The connection is taking too long. Please try again.",
    ),
    "errorGeneric": MessageLookupByLibrary.simpleMessage("An error occurred"),
    "errorLoadingAvailability": MessageLookupByLibrary.simpleMessage(
      "Unable to load availability. Check your connection and try again.",
    ),
    "errorLoadingBookings": MessageLookupByLibrary.simpleMessage(
      "Error loading bookings",
    ),
    "errorLoadingServices": MessageLookupByLibrary.simpleMessage(
      "Unable to load services. Check your connection and try again.",
    ),
    "errorLoadingStaff": MessageLookupByLibrary.simpleMessage(
      "Unable to load staff. Check your connection and try again.",
    ),
    "errorLocationNotFound": MessageLookupByLibrary.simpleMessage(
      "Location not available",
    ),
    "errorLocationNotFoundSubtitle": MessageLookupByLibrary.simpleMessage(
      "The selected location is not active. Contact the business for more information.",
    ),
    "errorNoAvailability": MessageLookupByLibrary.simpleMessage(
      "No availability for the selected date",
    ),
    "errorNotFound": m11,
    "errorServiceUnavailable": MessageLookupByLibrary.simpleMessage(
      "Service temporarily unavailable",
    ),
    "errorServiceUnavailableSubtitle": MessageLookupByLibrary.simpleMessage(
      "We are working to fix the issue. Please try again in a few minutes.",
    ),
    "errorTitle": MessageLookupByLibrary.simpleMessage("Error"),
    "loadingAvailability": MessageLookupByLibrary.simpleMessage(
      "Loading availability...",
    ),
    "loadingGeneric": MessageLookupByLibrary.simpleMessage("Loading..."),
    "locationEmpty": MessageLookupByLibrary.simpleMessage(
      "No location available",
    ),
    "locationSubtitle": MessageLookupByLibrary.simpleMessage(
      "Select where you want to book",
    ),
    "locationTitle": MessageLookupByLibrary.simpleMessage("Choose location"),
    "modifiable": MessageLookupByLibrary.simpleMessage("Modifiable"),
    "modifiableUntilDateTime": m12,
    "modifiableUntilDays": m13,
    "modifiableUntilHours": m14,
    "modifiableUntilMinutes": m15,
    "modify": MessageLookupByLibrary.simpleMessage("Reschedule"),
    "modifyNotImplemented": MessageLookupByLibrary.simpleMessage(
      "Modify feature under development",
    ),
    "monthApril": MessageLookupByLibrary.simpleMessage("April"),
    "monthAugust": MessageLookupByLibrary.simpleMessage("August"),
    "monthDecember": MessageLookupByLibrary.simpleMessage("December"),
    "monthFebruary": MessageLookupByLibrary.simpleMessage("February"),
    "monthJanuary": MessageLookupByLibrary.simpleMessage("January"),
    "monthJuly": MessageLookupByLibrary.simpleMessage("July"),
    "monthJune": MessageLookupByLibrary.simpleMessage("June"),
    "monthMarch": MessageLookupByLibrary.simpleMessage("March"),
    "monthMay": MessageLookupByLibrary.simpleMessage("May"),
    "monthNovember": MessageLookupByLibrary.simpleMessage("November"),
    "monthOctober": MessageLookupByLibrary.simpleMessage("October"),
    "monthSeptember": MessageLookupByLibrary.simpleMessage("September"),
    "myBookings": MessageLookupByLibrary.simpleMessage("My bookings"),
    "no": MessageLookupByLibrary.simpleMessage("No"),
    "noCancelledBookings": MessageLookupByLibrary.simpleMessage(
      "You have no cancelled bookings",
    ),
    "noPastBookings": MessageLookupByLibrary.simpleMessage(
      "You have no past bookings",
    ),
    "noStaffForAllServices": MessageLookupByLibrary.simpleMessage(
      "No staff member can perform all selected services. Try selecting fewer or different services.",
    ),
    "noUpcomingBookings": MessageLookupByLibrary.simpleMessage(
      "You have no upcoming bookings",
    ),
    "notModifiable": MessageLookupByLibrary.simpleMessage("Not modifiable"),
    "pastBookings": MessageLookupByLibrary.simpleMessage("Past"),
    "priceFormat": m16,
    "profileTitle": MessageLookupByLibrary.simpleMessage("Profile"),
    "rescheduleBookingTitle": MessageLookupByLibrary.simpleMessage(
      "Modify booking",
    ),
    "selectDate": MessageLookupByLibrary.simpleMessage("Select date"),
    "selectNewDate": MessageLookupByLibrary.simpleMessage("Select new date"),
    "selectNewTime": MessageLookupByLibrary.simpleMessage("Select new time"),
    "servicePackageExpandError": MessageLookupByLibrary.simpleMessage(
      "Unable to expand the selected package.",
    ),
    "servicePackageLabel": MessageLookupByLibrary.simpleMessage("Package"),
    "servicePackagesLoadError": MessageLookupByLibrary.simpleMessage(
      "Unable to load packages.",
    ),
    "servicePackagesLoading": MessageLookupByLibrary.simpleMessage(
      "Loading packages...",
    ),
    "servicePackagesSubtitle": MessageLookupByLibrary.simpleMessage(
      "Or pick a ready-made package",
    ),
    "servicePackagesTitle": MessageLookupByLibrary.simpleMessage("Packages"),
    "servicesCategoryFallbackName": m17,
    "servicesDuration": m18,
    "servicesEmpty": MessageLookupByLibrary.simpleMessage(
      "No services available at the moment",
    ),
    "servicesEmptySubtitle": MessageLookupByLibrary.simpleMessage(
      "There are no services available for online booking at this business",
    ),
    "servicesFree": MessageLookupByLibrary.simpleMessage("Free"),
    "servicesPriceFrom": m19,
    "servicesSelected": m20,
    "servicesSubtitle": MessageLookupByLibrary.simpleMessage(
      "You can select one or more services",
    ),
    "servicesTitle": MessageLookupByLibrary.simpleMessage("Choose services"),
    "servicesTotal": m21,
    "sessionExpired": MessageLookupByLibrary.simpleMessage(
      "Session expired. Please log in again.",
    ),
    "slotNoLongerAvailable": MessageLookupByLibrary.simpleMessage(
      "The time slot is no longer available. Your original booking remains unchanged.",
    ),
    "staffAnyOperator": MessageLookupByLibrary.simpleMessage(
      "Any available staff",
    ),
    "staffAnyOperatorSubtitle": MessageLookupByLibrary.simpleMessage(
      "We\'ll assign you the first available staff member",
    ),
    "staffEmpty": MessageLookupByLibrary.simpleMessage(
      "No staff available at the moment",
    ),
    "staffSubtitle": MessageLookupByLibrary.simpleMessage(
      "Select who you want to be served by",
    ),
    "staffTitle": MessageLookupByLibrary.simpleMessage("Choose staff member"),
    "summaryCancellationPolicyAcceptLabel":
        MessageLookupByLibrary.simpleMessage(
          "I accept the modify/cancel policy",
        ),
    "summaryCancellationPolicyAcceptRequiredError":
        MessageLookupByLibrary.simpleMessage(
          "To confirm, you must accept the modify/cancel policy.",
        ),
    "summaryCancellationPolicyAlways": MessageLookupByLibrary.simpleMessage(
      "Always",
    ),
    "summaryCancellationPolicyDays": m22,
    "summaryCancellationPolicyHours": m23,
    "summaryCancellationPolicyNever": MessageLookupByLibrary.simpleMessage(
      "Never (not allowed after booking)",
    ),
    "summaryCancellationPolicyTitle": MessageLookupByLibrary.simpleMessage(
      "Modify/cancel policy",
    ),
    "summaryDateTime": MessageLookupByLibrary.simpleMessage("Date and time"),
    "summaryDuration": MessageLookupByLibrary.simpleMessage("Total duration"),
    "summaryNotes": MessageLookupByLibrary.simpleMessage("Notes (optional)"),
    "summaryNotesHint": MessageLookupByLibrary.simpleMessage(
      "Add any notes for the appointment...",
    ),
    "summaryOperator": MessageLookupByLibrary.simpleMessage("Staff member"),
    "summaryPrice": MessageLookupByLibrary.simpleMessage("Total price"),
    "summaryServices": MessageLookupByLibrary.simpleMessage(
      "Selected services",
    ),
    "summarySubtitle": MessageLookupByLibrary.simpleMessage(
      "Review the details before confirming",
    ),
    "summaryTitle": MessageLookupByLibrary.simpleMessage("Booking summary"),
    "upcomingBookings": MessageLookupByLibrary.simpleMessage("Upcoming"),
    "validationInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Invalid email",
    ),
    "validationInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Invalid phone",
    ),
    "validationRequired": MessageLookupByLibrary.simpleMessage(
      "Required field",
    ),
    "weekdayFri": MessageLookupByLibrary.simpleMessage("Fri"),
    "weekdayMon": MessageLookupByLibrary.simpleMessage("Mon"),
    "weekdaySat": MessageLookupByLibrary.simpleMessage("Sat"),
    "weekdaySun": MessageLookupByLibrary.simpleMessage("Sun"),
    "weekdayThu": MessageLookupByLibrary.simpleMessage("Thu"),
    "weekdayTue": MessageLookupByLibrary.simpleMessage("Tue"),
    "weekdayWed": MessageLookupByLibrary.simpleMessage("Wed"),
    "wrongBusinessAuthAction": MessageLookupByLibrary.simpleMessage(
      "Log out and sign in here",
    ),
    "wrongBusinessAuthMessage": m24,
    "wrongBusinessAuthTitle": MessageLookupByLibrary.simpleMessage(
      "Account linked to another business",
    ),
    "yes": MessageLookupByLibrary.simpleMessage("Yes"),
  };
}
--- FILE: lib/core/l10n/l10n.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'intl/messages_all.dart';

// **************************************************************************
// Generator: Flutter Intl IDE plugin
// Made by Localizely
// **************************************************************************

// ignore_for_file: non_constant_identifier_names, lines_longer_than_80_chars
// ignore_for_file: join_return_with_assignment, prefer_final_in_for_each
// ignore_for_file: avoid_redundant_argument_values, avoid_escaping_inner_quotes

class L10n {
  L10n();

  static L10n? _current;

  static L10n get current {
    assert(
      _current != null,
      'No instance of L10n was loaded. Try to initialize the L10n delegate before accessing L10n.current.',
    );
    return _current!;
  }

  static const AppLocalizationDelegate delegate = AppLocalizationDelegate();

  static Future<L10n> load(Locale locale) {
    final name = (locale.countryCode?.isEmpty ?? false)
        ? locale.languageCode
        : locale.toString();
    final localeName = Intl.canonicalizedLocale(name);
    return initializeMessages(localeName).then((_) {
      Intl.defaultLocale = localeName;
      final instance = L10n();
      L10n._current = instance;

      return instance;
    });
  }

  static L10n of(BuildContext context) {
    final instance = L10n.maybeOf(context);
    assert(
      instance != null,
      'No instance of L10n present in the widget tree. Did you add L10n.delegate in localizationsDelegates?',
    );
    return instance!;
  }

  static L10n? maybeOf(BuildContext context) {
    return Localizations.of<L10n>(context, L10n);
  }

  /// `Prenota Online`
  String get appTitle {
    return Intl.message('Prenota Online', name: 'appTitle', desc: '', args: []);
  }

  /// `Indietro`
  String get actionBack {
    return Intl.message('Indietro', name: 'actionBack', desc: '', args: []);
  }

  /// `Avanti`
  String get actionNext {
    return Intl.message('Avanti', name: 'actionNext', desc: '', args: []);
  }

  /// `Conferma`
  String get actionConfirm {
    return Intl.message('Conferma', name: 'actionConfirm', desc: '', args: []);
  }

  /// `Annulla`
  String get actionCancel {
    return Intl.message('Annulla', name: 'actionCancel', desc: '', args: []);
  }

  /// `Elimina`
  String get actionDelete {
    return Intl.message('Elimina', name: 'actionDelete', desc: '', args: []);
  }

  /// `Chiudi`
  String get actionClose {
    return Intl.message('Chiudi', name: 'actionClose', desc: '', args: []);
  }

  /// `Riprova`
  String get actionRetry {
    return Intl.message('Riprova', name: 'actionRetry', desc: '', args: []);
  }

  /// `Accedi`
  String get actionLogin {
    return Intl.message('Accedi', name: 'actionLogin', desc: '', args: []);
  }

  /// `Registrati`
  String get actionRegister {
    return Intl.message(
      'Registrati',
      name: 'actionRegister',
      desc: '',
      args: [],
    );
  }

  /// `Esci`
  String get actionLogout {
    return Intl.message('Esci', name: 'actionLogout', desc: '', args: []);
  }

  /// `Caricamento...`
  String get loadingGeneric {
    return Intl.message(
      'Caricamento...',
      name: 'loadingGeneric',
      desc: '',
      args: [],
    );
  }

  /// `Sessione scaduta. Effettua nuovamente l'accesso.`
  String get sessionExpired {
    return Intl.message(
      'Sessione scaduta. Effettua nuovamente l\'accesso.',
      name: 'sessionExpired',
      desc: '',
      args: [],
    );
  }

  /// `Errore`
  String get errorTitle {
    return Intl.message('Errore', name: 'errorTitle', desc: '', args: []);
  }

  /// `Si √® verificato un errore`
  String get errorGeneric {
    return Intl.message(
      'Si √® verificato un errore',
      name: 'errorGeneric',
      desc: '',
      args: [],
    );
  }

  /// `Pagina non trovata: {path}`
  String errorNotFound(String path) {
    return Intl.message(
      'Pagina non trovata: $path',
      name: 'errorNotFound',
      desc: '',
      args: [path],
    );
  }

  /// `Nessuna disponibilit√† per la data selezionata`
  String get errorNoAvailability {
    return Intl.message(
      'Nessuna disponibilit√† per la data selezionata',
      name: 'errorNoAvailability',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile caricare i servizi. Verifica la connessione e riprova.`
  String get errorLoadingServices {
    return Intl.message(
      'Impossibile caricare i servizi. Verifica la connessione e riprova.',
      name: 'errorLoadingServices',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile caricare gli operatori. Verifica la connessione e riprova.`
  String get errorLoadingStaff {
    return Intl.message(
      'Impossibile caricare gli operatori. Verifica la connessione e riprova.',
      name: 'errorLoadingStaff',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile caricare le disponibilit√†. Verifica la connessione e riprova.`
  String get errorLoadingAvailability {
    return Intl.message(
      'Impossibile caricare le disponibilit√†. Verifica la connessione e riprova.',
      name: 'errorLoadingAvailability',
      desc: '',
      args: [],
    );
  }

  /// `Caricamento disponibilit√†...`
  String get loadingAvailability {
    return Intl.message(
      'Caricamento disponibilit√†...',
      name: 'loadingAvailability',
      desc: '',
      args: [],
    );
  }

  /// `Nessun servizio disponibile al momento`
  String get servicesEmpty {
    return Intl.message(
      'Nessun servizio disponibile al momento',
      name: 'servicesEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Non ci sono servizi prenotabili online per questa attivit√†`
  String get servicesEmptySubtitle {
    return Intl.message(
      'Non ci sono servizi prenotabili online per questa attivit√†',
      name: 'servicesEmptySubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessun operatore disponibile al momento`
  String get staffEmpty {
    return Intl.message(
      'Nessun operatore disponibile al momento',
      name: 'staffEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Nessun operatore pu√≤ eseguire tutti i servizi selezionati. Prova a selezionare meno servizi o servizi diversi.`
  String get noStaffForAllServices {
    return Intl.message(
      'Nessun operatore pu√≤ eseguire tutti i servizi selezionati. Prova a selezionare meno servizi o servizi diversi.',
      name: 'noStaffForAllServices',
      desc: '',
      args: [],
    );
  }

  /// `La connessione sta impiegando troppo tempo. Riprova.`
  String get errorConnectionTimeout {
    return Intl.message(
      'La connessione sta impiegando troppo tempo. Riprova.',
      name: 'errorConnectionTimeout',
      desc: '',
      args: [],
    );
  }

  /// `Attivit√† non trovata`
  String get errorBusinessNotFound {
    return Intl.message(
      'Attivit√† non trovata',
      name: 'errorBusinessNotFound',
      desc: '',
      args: [],
    );
  }

  /// `L'attivit√† richiesta non esiste. Verifica l'indirizzo o contatta direttamente l'attivit√†.`
  String get errorBusinessNotFoundSubtitle {
    return Intl.message(
      'L\'attivit√† richiesta non esiste. Verifica l\'indirizzo o contatta direttamente l\'attivit√†.',
      name: 'errorBusinessNotFoundSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Attivit√† non attiva`
  String get errorBusinessNotActive {
    return Intl.message(
      'Attivit√† non attiva',
      name: 'errorBusinessNotActive',
      desc: '',
      args: [],
    );
  }

  /// `Questa attivit√† non √® ancora configurata per le prenotazioni online. Contatta direttamente l'attivit√†.`
  String get errorBusinessNotActiveSubtitle {
    return Intl.message(
      'Questa attivit√† non √® ancora configurata per le prenotazioni online. Contatta direttamente l\'attivit√†.',
      name: 'errorBusinessNotActiveSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Sede non disponibile`
  String get errorLocationNotFound {
    return Intl.message(
      'Sede non disponibile',
      name: 'errorLocationNotFound',
      desc: '',
      args: [],
    );
  }

  /// `La sede selezionata non √® attiva. Contatta l'attivit√† per maggiori informazioni.`
  String get errorLocationNotFoundSubtitle {
    return Intl.message(
      'La sede selezionata non √® attiva. Contatta l\'attivit√† per maggiori informazioni.',
      name: 'errorLocationNotFoundSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Servizio temporaneamente non disponibile`
  String get errorServiceUnavailable {
    return Intl.message(
      'Servizio temporaneamente non disponibile',
      name: 'errorServiceUnavailable',
      desc: '',
      args: [],
    );
  }

  /// `Stiamo lavorando per risolvere il problema. Riprova tra qualche minuto.`
  String get errorServiceUnavailableSubtitle {
    return Intl.message(
      'Stiamo lavorando per risolvere il problema. Riprova tra qualche minuto.',
      name: 'errorServiceUnavailableSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Benvenuto`
  String get authWelcome {
    return Intl.message('Benvenuto', name: 'authWelcome', desc: '', args: []);
  }

  /// `Accedi al tuo account`
  String get authLoginTitle {
    return Intl.message(
      'Accedi al tuo account',
      name: 'authLoginTitle',
      desc: '',
      args: [],
    );
  }

  /// `Crea un nuovo account`
  String get authRegisterTitle {
    return Intl.message(
      'Crea un nuovo account',
      name: 'authRegisterTitle',
      desc: '',
      args: [],
    );
  }

  /// `Email`
  String get authEmail {
    return Intl.message('Email', name: 'authEmail', desc: '', args: []);
  }

  /// `Password`
  String get authPassword {
    return Intl.message('Password', name: 'authPassword', desc: '', args: []);
  }

  /// `Conferma password`
  String get authConfirmPassword {
    return Intl.message(
      'Conferma password',
      name: 'authConfirmPassword',
      desc: '',
      args: [],
    );
  }

  /// `Nome`
  String get authFirstName {
    return Intl.message('Nome', name: 'authFirstName', desc: '', args: []);
  }

  /// `Cognome`
  String get authLastName {
    return Intl.message('Cognome', name: 'authLastName', desc: '', args: []);
  }

  /// `Telefono`
  String get authPhone {
    return Intl.message('Telefono', name: 'authPhone', desc: '', args: []);
  }

  /// `Password dimenticata?`
  String get authForgotPassword {
    return Intl.message(
      'Password dimenticata?',
      name: 'authForgotPassword',
      desc: '',
      args: [],
    );
  }

  /// `Non hai un account?`
  String get authNoAccount {
    return Intl.message(
      'Non hai un account?',
      name: 'authNoAccount',
      desc: '',
      args: [],
    );
  }

  /// `Hai gi√† un account?`
  String get authHaveAccount {
    return Intl.message(
      'Hai gi√† un account?',
      name: 'authHaveAccount',
      desc: '',
      args: [],
    );
  }

  /// `Ricordami`
  String get authRememberMe {
    return Intl.message(
      'Ricordami',
      name: 'authRememberMe',
      desc: '',
      args: [],
    );
  }

  /// `Email non valida`
  String get authInvalidEmail {
    return Intl.message(
      'Email non valida',
      name: 'authInvalidEmail',
      desc: '',
      args: [],
    );
  }

  /// `La password deve contenere almeno 8 caratteri, una maiuscola, una minuscola e un numero`
  String get authInvalidPassword {
    return Intl.message(
      'La password deve contenere almeno 8 caratteri, una maiuscola, una minuscola e un numero',
      name: 'authInvalidPassword',
      desc: '',
      args: [],
    );
  }

  /// `Errore di validazione: {message}`
  String authPasswordValidationError(Object message) {
    return Intl.message(
      'Errore di validazione: $message',
      name: 'authPasswordValidationError',
      desc: '',
      args: [message],
    );
  }

  /// `Le password non coincidono`
  String get authPasswordMismatch {
    return Intl.message(
      'Le password non coincidono',
      name: 'authPasswordMismatch',
      desc: '',
      args: [],
    );
  }

  /// `Campo obbligatorio`
  String get authRequiredField {
    return Intl.message(
      'Campo obbligatorio',
      name: 'authRequiredField',
      desc: '',
      args: [],
    );
  }

  /// `Numero di telefono non valido`
  String get authInvalidPhone {
    return Intl.message(
      'Numero di telefono non valido',
      name: 'authInvalidPhone',
      desc: '',
      args: [],
    );
  }

  /// `Accesso effettuato`
  String get authLoginSuccess {
    return Intl.message(
      'Accesso effettuato',
      name: 'authLoginSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Registrazione completata`
  String get authRegisterSuccess {
    return Intl.message(
      'Registrazione completata',
      name: 'authRegisterSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Credenziali non valide`
  String get authLoginFailed {
    return Intl.message(
      'Credenziali non valide',
      name: 'authLoginFailed',
      desc: '',
      args: [],
    );
  }

  /// `Registrazione fallita`
  String get authRegisterFailed {
    return Intl.message(
      'Registrazione fallita',
      name: 'authRegisterFailed',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile caricare le informazioni del business. Riprova.`
  String get authBusinessNotFound {
    return Intl.message(
      'Impossibile caricare le informazioni del business. Riprova.',
      name: 'authBusinessNotFound',
      desc: '',
      args: [],
    );
  }

  /// `Questa email √® gi√† registrata. Prova ad accedere.`
  String get authEmailAlreadyRegistered {
    return Intl.message(
      'Questa email √® gi√† registrata. Prova ad accedere.',
      name: 'authEmailAlreadyRegistered',
      desc: '',
      args: [],
    );
  }

  /// `Email o password non valide`
  String get authErrorInvalidCredentials {
    return Intl.message(
      'Email o password non valide',
      name: 'authErrorInvalidCredentials',
      desc: '',
      args: [],
    );
  }

  /// `Il tuo account √® disabilitato`
  String get authErrorAccountDisabled {
    return Intl.message(
      'Il tuo account √® disabilitato',
      name: 'authErrorAccountDisabled',
      desc: '',
      args: [],
    );
  }

  /// `Sessione scaduta. Effettua di nuovo il login.`
  String get authErrorTokenExpired {
    return Intl.message(
      'Sessione scaduta. Effettua di nuovo il login.',
      name: 'authErrorTokenExpired',
      desc: '',
      args: [],
    );
  }

  /// `Sessione non valida. Effettua di nuovo il login.`
  String get authErrorTokenInvalid {
    return Intl.message(
      'Sessione non valida. Effettua di nuovo il login.',
      name: 'authErrorTokenInvalid',
      desc: '',
      args: [],
    );
  }

  /// `Sessione revocata. Effettua di nuovo il login.`
  String get authErrorSessionRevoked {
    return Intl.message(
      'Sessione revocata. Effettua di nuovo il login.',
      name: 'authErrorSessionRevoked',
      desc: '',
      args: [],
    );
  }

  /// `Questa email √® gi√† registrata. Prova ad accedere.`
  String get authErrorEmailAlreadyExists {
    return Intl.message(
      'Questa email √® gi√† registrata. Prova ad accedere.',
      name: 'authErrorEmailAlreadyExists',
      desc: '',
      args: [],
    );
  }

  /// `Password troppo debole. Scegline una pi√π sicura.`
  String get authErrorWeakPassword {
    return Intl.message(
      'Password troppo debole. Scegline una pi√π sicura.',
      name: 'authErrorWeakPassword',
      desc: '',
      args: [],
    );
  }

  /// `Token di reset password non valido`
  String get authErrorInvalidResetToken {
    return Intl.message(
      'Token di reset password non valido',
      name: 'authErrorInvalidResetToken',
      desc: '',
      args: [],
    );
  }

  /// `Token di reset password scaduto`
  String get authErrorResetTokenExpired {
    return Intl.message(
      'Token di reset password scaduto',
      name: 'authErrorResetTokenExpired',
      desc: '',
      args: [],
    );
  }

  /// `Recupera password`
  String get authResetPasswordTitle {
    return Intl.message(
      'Recupera password',
      name: 'authResetPasswordTitle',
      desc: '',
      args: [],
    );
  }

  /// `Inserisci la tua email e ti invieremo le istruzioni per reimpostare la password.`
  String get authResetPasswordMessage {
    return Intl.message(
      'Inserisci la tua email e ti invieremo le istruzioni per reimpostare la password.',
      name: 'authResetPasswordMessage',
      desc: '',
      args: [],
    );
  }

  /// `Invia`
  String get authResetPasswordSend {
    return Intl.message(
      'Invia',
      name: 'authResetPasswordSend',
      desc: '',
      args: [],
    );
  }

  /// `Email inviata! Controlla la tua casella di posta.`
  String get authResetPasswordSuccess {
    return Intl.message(
      'Email inviata! Controlla la tua casella di posta.',
      name: 'authResetPasswordSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Errore durante l'invio. Riprova.`
  String get authResetPasswordError {
    return Intl.message(
      'Errore durante l\'invio. Riprova.',
      name: 'authResetPasswordError',
      desc: '',
      args: [],
    );
  }

  /// `Email non trovata nel sistema. Verifica l'indirizzo o registrati.`
  String get authResetPasswordEmailNotFound {
    return Intl.message(
      'Email non trovata nel sistema. Verifica l\'indirizzo o registrati.',
      name: 'authResetPasswordEmailNotFound',
      desc: '',
      args: [],
    );
  }

  /// `Reimposta password`
  String get authResetPasswordConfirmTitle {
    return Intl.message(
      'Reimposta password',
      name: 'authResetPasswordConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `Inserisci la nuova password`
  String get authResetPasswordConfirmMessage {
    return Intl.message(
      'Inserisci la nuova password',
      name: 'authResetPasswordConfirmMessage',
      desc: '',
      args: [],
    );
  }

  /// `Nuova password`
  String get authNewPassword {
    return Intl.message(
      'Nuova password',
      name: 'authNewPassword',
      desc: '',
      args: [],
    );
  }

  /// `Password reimpostata con successo!`
  String get authResetPasswordConfirmSuccess {
    return Intl.message(
      'Password reimpostata con successo!',
      name: 'authResetPasswordConfirmSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Token non valido o scaduto`
  String get authResetPasswordConfirmError {
    return Intl.message(
      'Token non valido o scaduto',
      name: 'authResetPasswordConfirmError',
      desc: '',
      args: [],
    );
  }

  /// `Cambia password`
  String get authChangePasswordTitle {
    return Intl.message(
      'Cambia password',
      name: 'authChangePasswordTitle',
      desc: '',
      args: [],
    );
  }

  /// `Password attuale`
  String get authCurrentPassword {
    return Intl.message(
      'Password attuale',
      name: 'authCurrentPassword',
      desc: '',
      args: [],
    );
  }

  /// `Password modificata con successo`
  String get authChangePasswordSuccess {
    return Intl.message(
      'Password modificata con successo',
      name: 'authChangePasswordSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Password attuale non corretta`
  String get authChangePasswordError {
    return Intl.message(
      'Password attuale non corretta',
      name: 'authChangePasswordError',
      desc: '',
      args: [],
    );
  }

  /// `Password troppo corta (min. 8 caratteri)`
  String get authPasswordTooShort {
    return Intl.message(
      'Password troppo corta (min. 8 caratteri)',
      name: 'authPasswordTooShort',
      desc: '',
      args: [],
    );
  }

  /// `La password deve contenere: maiuscola, minuscola, numero`
  String get authPasswordRequirements {
    return Intl.message(
      'La password deve contenere: maiuscola, minuscola, numero',
      name: 'authPasswordRequirements',
      desc: '',
      args: [],
    );
  }

  /// `Cambia password`
  String get authChangePassword {
    return Intl.message(
      'Cambia password',
      name: 'authChangePassword',
      desc: '',
      args: [],
    );
  }

  /// `Per visualizzare i tuoi appuntamenti, accedi con il tuo account o registrati se non ne hai ancora uno.`
  String get authRedirectFromMyBookings {
    return Intl.message(
      'Per visualizzare i tuoi appuntamenti, accedi con il tuo account o registrati se non ne hai ancora uno.',
      name: 'authRedirectFromMyBookings',
      desc: '',
      args: [],
    );
  }

  /// `Per prenotare un appuntamento, accedi con il tuo account o registrati se non ne hai ancora uno.`
  String get authRedirectFromBooking {
    return Intl.message(
      'Per prenotare un appuntamento, accedi con il tuo account o registrati se non ne hai ancora uno.',
      name: 'authRedirectFromBooking',
      desc: '',
      args: [],
    );
  }

  /// `Profilo`
  String get profileTitle {
    return Intl.message('Profilo', name: 'profileTitle', desc: '', args: []);
  }

  /// `Prenota appuntamento`
  String get bookingTitle {
    return Intl.message(
      'Prenota appuntamento',
      name: 'bookingTitle',
      desc: '',
      args: [],
    );
  }

  /// `Sede`
  String get bookingStepLocation {
    return Intl.message(
      'Sede',
      name: 'bookingStepLocation',
      desc: '',
      args: [],
    );
  }

  /// `Servizi`
  String get bookingStepServices {
    return Intl.message(
      'Servizi',
      name: 'bookingStepServices',
      desc: '',
      args: [],
    );
  }

  /// `Operatore`
  String get bookingStepStaff {
    return Intl.message(
      'Operatore',
      name: 'bookingStepStaff',
      desc: '',
      args: [],
    );
  }

  /// `Data e ora`
  String get bookingStepDateTime {
    return Intl.message(
      'Data e ora',
      name: 'bookingStepDateTime',
      desc: '',
      args: [],
    );
  }

  /// `Riepilogo`
  String get bookingStepSummary {
    return Intl.message(
      'Riepilogo',
      name: 'bookingStepSummary',
      desc: '',
      args: [],
    );
  }

  /// `Scegli la sede`
  String get locationTitle {
    return Intl.message(
      'Scegli la sede',
      name: 'locationTitle',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona dove vuoi effettuare la prenotazione`
  String get locationSubtitle {
    return Intl.message(
      'Seleziona dove vuoi effettuare la prenotazione',
      name: 'locationSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessuna sede disponibile`
  String get locationEmpty {
    return Intl.message(
      'Nessuna sede disponibile',
      name: 'locationEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Scegli i servizi`
  String get servicesTitle {
    return Intl.message(
      'Scegli i servizi',
      name: 'servicesTitle',
      desc: '',
      args: [],
    );
  }

  /// `Puoi selezionare uno o pi√π servizi`
  String get servicesSubtitle {
    return Intl.message(
      'Puoi selezionare uno o pi√π servizi',
      name: 'servicesSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Pacchetti`
  String get servicePackagesTitle {
    return Intl.message(
      'Pacchetti',
      name: 'servicePackagesTitle',
      desc: '',
      args: [],
    );
  }

  /// `Oppure scegli un pacchetto pronto`
  String get servicePackagesSubtitle {
    return Intl.message(
      'Oppure scegli un pacchetto pronto',
      name: 'servicePackagesSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Caricamento pacchetti...`
  String get servicePackagesLoading {
    return Intl.message(
      'Caricamento pacchetti...',
      name: 'servicePackagesLoading',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile caricare i pacchetti.`
  String get servicePackagesLoadError {
    return Intl.message(
      'Impossibile caricare i pacchetti.',
      name: 'servicePackagesLoadError',
      desc: '',
      args: [],
    );
  }

  /// `Pacchetto`
  String get servicePackageLabel {
    return Intl.message(
      'Pacchetto',
      name: 'servicePackageLabel',
      desc: '',
      args: [],
    );
  }

  /// `Categoria {id}`
  String servicesCategoryFallbackName(int id) {
    return Intl.message(
      'Categoria $id',
      name: 'servicesCategoryFallbackName',
      desc: '',
      args: [id],
    );
  }

  /// `Impossibile espandere il pacchetto selezionato.`
  String get servicePackageExpandError {
    return Intl.message(
      'Impossibile espandere il pacchetto selezionato.',
      name: 'servicePackageExpandError',
      desc: '',
      args: [],
    );
  }

  /// `{count, plural, =0{Nessun servizio selezionato} =1{1 servizio selezionato} other{{count} servizi selezionati}}`
  String servicesSelected(int count) {
    return Intl.plural(
      count,
      zero: 'Nessun servizio selezionato',
      one: '1 servizio selezionato',
      other: '$count servizi selezionati',
      name: 'servicesSelected',
      desc: '',
      args: [count],
    );
  }

  /// `Totale: {total}`
  String servicesTotal(String total) {
    return Intl.message(
      'Totale: $total',
      name: 'servicesTotal',
      desc: '',
      args: [total],
    );
  }

  /// `{duration} min`
  String servicesDuration(int duration) {
    return Intl.message(
      '$duration min',
      name: 'servicesDuration',
      desc: '',
      args: [duration],
    );
  }

  /// `Gratis`
  String get servicesFree {
    return Intl.message('Gratis', name: 'servicesFree', desc: '', args: []);
  }

  /// `da {price}`
  String servicesPriceFrom(String price) {
    return Intl.message(
      'da $price',
      name: 'servicesPriceFrom',
      desc: '',
      args: [price],
    );
  }

  /// `Scegli l'operatore`
  String get staffTitle {
    return Intl.message(
      'Scegli l\'operatore',
      name: 'staffTitle',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona con chi desideri essere servito`
  String get staffSubtitle {
    return Intl.message(
      'Seleziona con chi desideri essere servito',
      name: 'staffSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Qualsiasi operatore disponibile`
  String get staffAnyOperator {
    return Intl.message(
      'Qualsiasi operatore disponibile',
      name: 'staffAnyOperator',
      desc: '',
      args: [],
    );
  }

  /// `Ti assegneremo il primo operatore libero`
  String get staffAnyOperatorSubtitle {
    return Intl.message(
      'Ti assegneremo il primo operatore libero',
      name: 'staffAnyOperatorSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Scegli data e ora`
  String get dateTimeTitle {
    return Intl.message(
      'Scegli data e ora',
      name: 'dateTimeTitle',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona quando desideri prenotare`
  String get dateTimeSubtitle {
    return Intl.message(
      'Seleziona quando desideri prenotare',
      name: 'dateTimeSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Prima disponibilit√†: {date}`
  String dateTimeFirstAvailable(String date) {
    return Intl.message(
      'Prima disponibilit√†: $date',
      name: 'dateTimeFirstAvailable',
      desc: '',
      args: [date],
    );
  }

  /// `Vai alla prima data disponibile`
  String get dateTimeGoToFirst {
    return Intl.message(
      'Vai alla prima data disponibile',
      name: 'dateTimeGoToFirst',
      desc: '',
      args: [],
    );
  }

  /// `Vai alla prossima data disponibile`
  String get dateTimeGoToNext {
    return Intl.message(
      'Vai alla prossima data disponibile',
      name: 'dateTimeGoToNext',
      desc: '',
      args: [],
    );
  }

  /// `Nessun orario disponibile per questa data`
  String get dateTimeNoSlots {
    return Intl.message(
      'Nessun orario disponibile per questa data',
      name: 'dateTimeNoSlots',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona una data`
  String get dateTimeSelectDate {
    return Intl.message(
      'Seleziona una data',
      name: 'dateTimeSelectDate',
      desc: '',
      args: [],
    );
  }

  /// `Mattina`
  String get dateTimeMorning {
    return Intl.message('Mattina', name: 'dateTimeMorning', desc: '', args: []);
  }

  /// `Pomeriggio`
  String get dateTimeAfternoon {
    return Intl.message(
      'Pomeriggio',
      name: 'dateTimeAfternoon',
      desc: '',
      args: [],
    );
  }

  /// `Sera`
  String get dateTimeEvening {
    return Intl.message('Sera', name: 'dateTimeEvening', desc: '', args: []);
  }

  /// `Riepilogo prenotazione`
  String get summaryTitle {
    return Intl.message(
      'Riepilogo prenotazione',
      name: 'summaryTitle',
      desc: '',
      args: [],
    );
  }

  /// `Controlla i dettagli prima di confermare`
  String get summarySubtitle {
    return Intl.message(
      'Controlla i dettagli prima di confermare',
      name: 'summarySubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Servizi selezionati`
  String get summaryServices {
    return Intl.message(
      'Servizi selezionati',
      name: 'summaryServices',
      desc: '',
      args: [],
    );
  }

  /// `Operatore`
  String get summaryOperator {
    return Intl.message(
      'Operatore',
      name: 'summaryOperator',
      desc: '',
      args: [],
    );
  }

  /// `Data e ora`
  String get summaryDateTime {
    return Intl.message(
      'Data e ora',
      name: 'summaryDateTime',
      desc: '',
      args: [],
    );
  }

  /// `Policy modifica/cancellazione`
  String get summaryCancellationPolicyTitle {
    return Intl.message(
      'Policy modifica/cancellazione',
      name: 'summaryCancellationPolicyTitle',
      desc: '',
      args: [],
    );
  }

  /// `Sempre`
  String get summaryCancellationPolicyAlways {
    return Intl.message(
      'Sempre',
      name: 'summaryCancellationPolicyAlways',
      desc: '',
      args: [],
    );
  }

  /// `Mai (non consentita dopo la prenotazione)`
  String get summaryCancellationPolicyNever {
    return Intl.message(
      'Mai (non consentita dopo la prenotazione)',
      name: 'summaryCancellationPolicyNever',
      desc: '',
      args: [],
    );
  }

  /// `Fino a {hours} ore prima`
  String summaryCancellationPolicyHours(int hours) {
    return Intl.message(
      'Fino a $hours ore prima',
      name: 'summaryCancellationPolicyHours',
      desc: '',
      args: [hours],
    );
  }

  /// `Fino a {days} giorni prima`
  String summaryCancellationPolicyDays(int days) {
    return Intl.message(
      'Fino a $days giorni prima',
      name: 'summaryCancellationPolicyDays',
      desc: '',
      args: [days],
    );
  }

  /// `Accetto la policy di modifica/cancellazione`
  String get summaryCancellationPolicyAcceptLabel {
    return Intl.message(
      'Accetto la policy di modifica/cancellazione',
      name: 'summaryCancellationPolicyAcceptLabel',
      desc: '',
      args: [],
    );
  }

  /// `Per confermare devi accettare la policy di modifica/cancellazione.`
  String get summaryCancellationPolicyAcceptRequiredError {
    return Intl.message(
      'Per confermare devi accettare la policy di modifica/cancellazione.',
      name: 'summaryCancellationPolicyAcceptRequiredError',
      desc: '',
      args: [],
    );
  }

  /// `Durata totale`
  String get summaryDuration {
    return Intl.message(
      'Durata totale',
      name: 'summaryDuration',
      desc: '',
      args: [],
    );
  }

  /// `Prezzo totale`
  String get summaryPrice {
    return Intl.message(
      'Prezzo totale',
      name: 'summaryPrice',
      desc: '',
      args: [],
    );
  }

  /// `Note (opzionale)`
  String get summaryNotes {
    return Intl.message(
      'Note (opzionale)',
      name: 'summaryNotes',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi eventuali note per l'appuntamento...`
  String get summaryNotesHint {
    return Intl.message(
      'Aggiungi eventuali note per l\'appuntamento...',
      name: 'summaryNotesHint',
      desc: '',
      args: [],
    );
  }

  /// `L'orario selezionato non √® pi√π disponibile`
  String get bookingErrorSlotConflict {
    return Intl.message(
      'L\'orario selezionato non √® pi√π disponibile',
      name: 'bookingErrorSlotConflict',
      desc: '',
      args: [],
    );
  }

  /// `Uno o pi√π servizi selezionati non sono disponibili`
  String get bookingErrorInvalidService {
    return Intl.message(
      'Uno o pi√π servizi selezionati non sono disponibili',
      name: 'bookingErrorInvalidService',
      desc: '',
      args: [],
    );
  }

  /// `L'operatore selezionato non √® disponibile per questi servizi`
  String get bookingErrorInvalidStaff {
    return Intl.message(
      'L\'operatore selezionato non √® disponibile per questi servizi',
      name: 'bookingErrorInvalidStaff',
      desc: '',
      args: [],
    );
  }

  /// `La sede selezionata non √® disponibile`
  String get bookingErrorInvalidLocation {
    return Intl.message(
      'La sede selezionata non √® disponibile',
      name: 'bookingErrorInvalidLocation',
      desc: '',
      args: [],
    );
  }

  /// `Il cliente selezionato non √® valido`
  String get bookingErrorInvalidClient {
    return Intl.message(
      'Il cliente selezionato non √® valido',
      name: 'bookingErrorInvalidClient',
      desc: '',
      args: [],
    );
  }

  /// `L'orario selezionato non √® valido`
  String get bookingErrorInvalidTime {
    return Intl.message(
      'L\'orario selezionato non √® valido',
      name: 'bookingErrorInvalidTime',
      desc: '',
      args: [],
    );
  }

  /// `L'operatore selezionato non √® disponibile in questo orario`
  String get bookingErrorStaffUnavailable {
    return Intl.message(
      'L\'operatore selezionato non √® disponibile in questo orario',
      name: 'bookingErrorStaffUnavailable',
      desc: '',
      args: [],
    );
  }

  /// `L'orario selezionato √® fuori dall'orario di lavoro`
  String get bookingErrorOutsideWorkingHours {
    return Intl.message(
      'L\'orario selezionato √® fuori dall\'orario di lavoro',
      name: 'bookingErrorOutsideWorkingHours',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione non trovata`
  String get bookingErrorNotFound {
    return Intl.message(
      'Prenotazione non trovata',
      name: 'bookingErrorNotFound',
      desc: '',
      args: [],
    );
  }

  /// `Non sei autorizzato a completare questa azione`
  String get bookingErrorUnauthorized {
    return Intl.message(
      'Non sei autorizzato a completare questa azione',
      name: 'bookingErrorUnauthorized',
      desc: '',
      args: [],
    );
  }

  /// `Controlla i dati inseriti`
  String get bookingErrorValidation {
    return Intl.message(
      'Controlla i dati inseriti',
      name: 'bookingErrorValidation',
      desc: '',
      args: [],
    );
  }

  /// `Si √® verificato un errore. Riprova pi√π tardi`
  String get bookingErrorServer {
    return Intl.message(
      'Si √® verificato un errore. Riprova pi√π tardi',
      name: 'bookingErrorServer',
      desc: '',
      args: [],
    );
  }

  /// `Questa prenotazione non pu√≤ essere modificata`
  String get bookingErrorNotModifiable {
    return Intl.message(
      'Questa prenotazione non pu√≤ essere modificata',
      name: 'bookingErrorNotModifiable',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione confermata!`
  String get confirmationTitle {
    return Intl.message(
      'Prenotazione confermata!',
      name: 'confirmationTitle',
      desc: '',
      args: [],
    );
  }

  /// `Ti abbiamo inviato un'email di conferma`
  String get confirmationSubtitle {
    return Intl.message(
      'Ti abbiamo inviato un\'email di conferma',
      name: 'confirmationSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Codice prenotazione: {id}`
  String confirmationBookingId(String id) {
    return Intl.message(
      'Codice prenotazione: $id',
      name: 'confirmationBookingId',
      desc: '',
      args: [id],
    );
  }

  /// `Nuova prenotazione`
  String get confirmationNewBooking {
    return Intl.message(
      'Nuova prenotazione',
      name: 'confirmationNewBooking',
      desc: '',
      args: [],
    );
  }

  /// `Torna alla home`
  String get confirmationGoHome {
    return Intl.message(
      'Torna alla home',
      name: 'confirmationGoHome',
      desc: '',
      args: [],
    );
  }

  /// `{minutes} min`
  String durationMinutes(int minutes) {
    return Intl.message(
      '$minutes min',
      name: 'durationMinutes',
      desc: '',
      args: [minutes],
    );
  }

  /// `{minutes} min`
  String durationMinute(int minutes) {
    return Intl.message(
      '$minutes min',
      name: 'durationMinute',
      desc: '',
      args: [minutes],
    );
  }

  /// `{hours} ora`
  String durationHour(int hours) {
    return Intl.message(
      '$hours ora',
      name: 'durationHour',
      desc: '',
      args: [hours],
    );
  }

  /// `{hours} ora {minutes} min`
  String durationHourMinute(int hours, int minutes) {
    return Intl.message(
      '$hours ora $minutes min',
      name: 'durationHourMinute',
      desc: '',
      args: [hours, minutes],
    );
  }

  /// `‚Ç¨{price}`
  String priceFormat(String price) {
    return Intl.message(
      '‚Ç¨$price',
      name: 'priceFormat',
      desc: '',
      args: [price],
    );
  }

  /// `Gennaio`
  String get monthJanuary {
    return Intl.message('Gennaio', name: 'monthJanuary', desc: '', args: []);
  }

  /// `Febbraio`
  String get monthFebruary {
    return Intl.message('Febbraio', name: 'monthFebruary', desc: '', args: []);
  }

  /// `Marzo`
  String get monthMarch {
    return Intl.message('Marzo', name: 'monthMarch', desc: '', args: []);
  }

  /// `Aprile`
  String get monthApril {
    return Intl.message('Aprile', name: 'monthApril', desc: '', args: []);
  }

  /// `Maggio`
  String get monthMay {
    return Intl.message('Maggio', name: 'monthMay', desc: '', args: []);
  }

  /// `Giugno`
  String get monthJune {
    return Intl.message('Giugno', name: 'monthJune', desc: '', args: []);
  }

  /// `Luglio`
  String get monthJuly {
    return Intl.message('Luglio', name: 'monthJuly', desc: '', args: []);
  }

  /// `Agosto`
  String get monthAugust {
    return Intl.message('Agosto', name: 'monthAugust', desc: '', args: []);
  }

  /// `Settembre`
  String get monthSeptember {
    return Intl.message(
      'Settembre',
      name: 'monthSeptember',
      desc: '',
      args: [],
    );
  }

  /// `Ottobre`
  String get monthOctober {
    return Intl.message('Ottobre', name: 'monthOctober', desc: '', args: []);
  }

  /// `Novembre`
  String get monthNovember {
    return Intl.message('Novembre', name: 'monthNovember', desc: '', args: []);
  }

  /// `Dicembre`
  String get monthDecember {
    return Intl.message('Dicembre', name: 'monthDecember', desc: '', args: []);
  }

  /// `Lun`
  String get weekdayMon {
    return Intl.message('Lun', name: 'weekdayMon', desc: '', args: []);
  }

  /// `Mar`
  String get weekdayTue {
    return Intl.message('Mar', name: 'weekdayTue', desc: '', args: []);
  }

  /// `Mer`
  String get weekdayWed {
    return Intl.message('Mer', name: 'weekdayWed', desc: '', args: []);
  }

  /// `Gio`
  String get weekdayThu {
    return Intl.message('Gio', name: 'weekdayThu', desc: '', args: []);
  }

  /// `Ven`
  String get weekdayFri {
    return Intl.message('Ven', name: 'weekdayFri', desc: '', args: []);
  }

  /// `Sab`
  String get weekdaySat {
    return Intl.message('Sab', name: 'weekdaySat', desc: '', args: []);
  }

  /// `Dom`
  String get weekdaySun {
    return Intl.message('Dom', name: 'weekdaySun', desc: '', args: []);
  }

  /// `Le mie prenotazioni`
  String get myBookings {
    return Intl.message(
      'Le mie prenotazioni',
      name: 'myBookings',
      desc: '',
      args: [],
    );
  }

  /// `Prossime`
  String get upcomingBookings {
    return Intl.message(
      'Prossime',
      name: 'upcomingBookings',
      desc: '',
      args: [],
    );
  }

  /// `Passate`
  String get pastBookings {
    return Intl.message('Passate', name: 'pastBookings', desc: '', args: []);
  }

  /// `Annullate`
  String get cancelledBookings {
    return Intl.message(
      'Annullate',
      name: 'cancelledBookings',
      desc: '',
      args: [],
    );
  }

  /// `Non hai prenotazioni in programma`
  String get noUpcomingBookings {
    return Intl.message(
      'Non hai prenotazioni in programma',
      name: 'noUpcomingBookings',
      desc: '',
      args: [],
    );
  }

  /// `Non hai prenotazioni passate`
  String get noPastBookings {
    return Intl.message(
      'Non hai prenotazioni passate',
      name: 'noPastBookings',
      desc: '',
      args: [],
    );
  }

  /// `Non hai prenotazioni annullate`
  String get noCancelledBookings {
    return Intl.message(
      'Non hai prenotazioni annullate',
      name: 'noCancelledBookings',
      desc: '',
      args: [],
    );
  }

  /// `Errore nel caricamento delle prenotazioni`
  String get errorLoadingBookings {
    return Intl.message(
      'Errore nel caricamento delle prenotazioni',
      name: 'errorLoadingBookings',
      desc: '',
      args: [],
    );
  }

  /// `Modificabile`
  String get modifiable {
    return Intl.message('Modificabile', name: 'modifiable', desc: '', args: []);
  }

  /// `Non modificabile`
  String get notModifiable {
    return Intl.message(
      'Non modificabile',
      name: 'notModifiable',
      desc: '',
      args: [],
    );
  }

  /// `{days, plural, =1{Modificabile fino a domani} other{Modificabile fino a {days} giorni}}`
  String modifiableUntilDays(int days) {
    return Intl.plural(
      days,
      one: 'Modificabile fino a domani',
      other: 'Modificabile fino a $days giorni',
      name: 'modifiableUntilDays',
      desc: '',
      args: [days],
    );
  }

  /// `{hours, plural, =1{Modificabile fino a 1 ora} other{Modificabile fino a {hours} ore}}`
  String modifiableUntilHours(int hours) {
    return Intl.plural(
      hours,
      one: 'Modificabile fino a 1 ora',
      other: 'Modificabile fino a $hours ore',
      name: 'modifiableUntilHours',
      desc: '',
      args: [hours],
    );
  }

  /// `{minutes, plural, =1{Modificabile fino a 1 minuto} other{Modificabile fino a {minutes} minuti}}`
  String modifiableUntilMinutes(int minutes) {
    return Intl.plural(
      minutes,
      one: 'Modificabile fino a 1 minuto',
      other: 'Modificabile fino a $minutes minuti',
      name: 'modifiableUntilMinutes',
      desc: '',
      args: [minutes],
    );
  }

  /// `Modificabile fino al {dateTime}`
  String modifiableUntilDateTime(Object dateTime) {
    return Intl.message(
      'Modificabile fino al $dateTime',
      name: 'modifiableUntilDateTime',
      desc: '',
      args: [dateTime],
    );
  }

  /// `Riprogramma`
  String get modify {
    return Intl.message('Riprogramma', name: 'modify', desc: '', args: []);
  }

  /// `Annulla`
  String get cancel {
    return Intl.message('Annulla', name: 'cancel', desc: '', args: []);
  }

  /// `S√¨`
  String get yes {
    return Intl.message('S√¨', name: 'yes', desc: '', args: []);
  }

  /// `No`
  String get no {
    return Intl.message('No', name: 'no', desc: '', args: []);
  }

  /// `Annulla prenotazione`
  String get cancelBookingTitle {
    return Intl.message(
      'Annulla prenotazione',
      name: 'cancelBookingTitle',
      desc: '',
      args: [],
    );
  }

  /// `Sei sicuro di voler annullare questa prenotazione?`
  String get cancelBookingConfirm {
    return Intl.message(
      'Sei sicuro di voler annullare questa prenotazione?',
      name: 'cancelBookingConfirm',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione annullata con successo`
  String get bookingCancelled {
    return Intl.message(
      'Prenotazione annullata con successo',
      name: 'bookingCancelled',
      desc: '',
      args: [],
    );
  }

  /// `Errore durante l'annullamento della prenotazione. Riprova.`
  String get bookingCancelFailed {
    return Intl.message(
      'Errore durante l\'annullamento della prenotazione. Riprova.',
      name: 'bookingCancelFailed',
      desc: '',
      args: [],
    );
  }

  /// `Annulla`
  String get actionCancelBooking {
    return Intl.message(
      'Annulla',
      name: 'actionCancelBooking',
      desc:
          'Azione per annullare una prenotazione dal punto di vista del cliente',
      args: [],
    );
  }

  /// `Funzione di modifica in sviluppo`
  String get modifyNotImplemented {
    return Intl.message(
      'Funzione di modifica in sviluppo',
      name: 'modifyNotImplemented',
      desc: '',
      args: [],
    );
  }

  /// `Modifica prenotazione`
  String get rescheduleBookingTitle {
    return Intl.message(
      'Modifica prenotazione',
      name: 'rescheduleBookingTitle',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione attuale`
  String get currentBooking {
    return Intl.message(
      'Prenotazione attuale',
      name: 'currentBooking',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona nuova data`
  String get selectNewDate {
    return Intl.message(
      'Seleziona nuova data',
      name: 'selectNewDate',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona data`
  String get selectDate {
    return Intl.message(
      'Seleziona data',
      name: 'selectDate',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona nuovo orario`
  String get selectNewTime {
    return Intl.message(
      'Seleziona nuovo orario',
      name: 'selectNewTime',
      desc: '',
      args: [],
    );
  }

  /// `Conferma modifica`
  String get confirmReschedule {
    return Intl.message(
      'Conferma modifica',
      name: 'confirmReschedule',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione modificata con successo`
  String get bookingRescheduled {
    return Intl.message(
      'Prenotazione modificata con successo',
      name: 'bookingRescheduled',
      desc: '',
      args: [],
    );
  }

  /// `Lo slot non √® pi√π disponibile. La prenotazione originale √® rimasta invariata.`
  String get slotNoLongerAvailable {
    return Intl.message(
      'Lo slot non √® pi√π disponibile. La prenotazione originale √® rimasta invariata.',
      name: 'slotNoLongerAvailable',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione aggiornata`
  String get bookingUpdatedTitle {
    return Intl.message(
      'Prenotazione aggiornata',
      name: 'bookingUpdatedTitle',
      desc: '',
      args: [],
    );
  }

  /// `Campo obbligatorio`
  String get validationRequired {
    return Intl.message(
      'Campo obbligatorio',
      name: 'validationRequired',
      desc: '',
      args: [],
    );
  }

  /// `Email non valida`
  String get validationInvalidEmail {
    return Intl.message(
      'Email non valida',
      name: 'validationInvalidEmail',
      desc: '',
      args: [],
    );
  }

  /// `Telefono non valido`
  String get validationInvalidPhone {
    return Intl.message(
      'Telefono non valido',
      name: 'validationInvalidPhone',
      desc: '',
      args: [],
    );
  }

  /// `Storico prenotazione`
  String get bookingHistoryTitle {
    return Intl.message(
      'Storico prenotazione',
      name: 'bookingHistoryTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessun evento registrato`
  String get bookingHistoryEmpty {
    return Intl.message(
      'Nessun evento registrato',
      name: 'bookingHistoryEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Caricamento storico...`
  String get bookingHistoryLoading {
    return Intl.message(
      'Caricamento storico...',
      name: 'bookingHistoryLoading',
      desc: '',
      args: [],
    );
  }

  /// `Errore nel caricamento dello storico`
  String get bookingHistoryError {
    return Intl.message(
      'Errore nel caricamento dello storico',
      name: 'bookingHistoryError',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione creata`
  String get bookingHistoryEventCreated {
    return Intl.message(
      'Prenotazione creata',
      name: 'bookingHistoryEventCreated',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione modificata`
  String get bookingHistoryEventUpdated {
    return Intl.message(
      'Prenotazione modificata',
      name: 'bookingHistoryEventUpdated',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione annullata`
  String get bookingHistoryEventCancelled {
    return Intl.message(
      'Prenotazione annullata',
      name: 'bookingHistoryEventCancelled',
      desc: '',
      args: [],
    );
  }

  /// `Servizio aggiunto`
  String get bookingHistoryEventItemAdded {
    return Intl.message(
      'Servizio aggiunto',
      name: 'bookingHistoryEventItemAdded',
      desc: '',
      args: [],
    );
  }

  /// `Servizio rimosso`
  String get bookingHistoryEventItemDeleted {
    return Intl.message(
      'Servizio rimosso',
      name: 'bookingHistoryEventItemDeleted',
      desc: '',
      args: [],
    );
  }

  /// `Appuntamento modificato`
  String get bookingHistoryEventAppointmentUpdated {
    return Intl.message(
      'Appuntamento modificato',
      name: 'bookingHistoryEventAppointmentUpdated',
      desc: '',
      args: [],
    );
  }

  /// `Orario modificato`
  String get bookingHistoryEventTimeChanged {
    return Intl.message(
      'Orario modificato',
      name: 'bookingHistoryEventTimeChanged',
      desc: '',
      args: [],
    );
  }

  /// `Operatore cambiato`
  String get bookingHistoryEventStaffChanged {
    return Intl.message(
      'Operatore cambiato',
      name: 'bookingHistoryEventStaffChanged',
      desc: '',
      args: [],
    );
  }

  /// `Prezzo modificato`
  String get bookingHistoryEventPriceChanged {
    return Intl.message(
      'Prezzo modificato',
      name: 'bookingHistoryEventPriceChanged',
      desc: '',
      args: [],
    );
  }

  /// `Durata modificata`
  String get bookingHistoryEventDurationChanged {
    return Intl.message(
      'Durata modificata',
      name: 'bookingHistoryEventDurationChanged',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione sostituita`
  String get bookingHistoryEventReplaced {
    return Intl.message(
      'Prenotazione sostituita',
      name: 'bookingHistoryEventReplaced',
      desc: '',
      args: [],
    );
  }

  /// `Inviata email di tipo: {type}`
  String bookingHistoryEventNotificationSentTitle(Object type) {
    return Intl.message(
      'Inviata email di tipo: $type',
      name: 'bookingHistoryEventNotificationSentTitle',
      desc: '',
      args: [type],
    );
  }

  /// `Cliente`
  String get bookingHistoryActorCustomer {
    return Intl.message(
      'Cliente',
      name: 'bookingHistoryActorCustomer',
      desc: '',
      args: [],
    );
  }

  /// `Staff`
  String get bookingHistoryActorStaff {
    return Intl.message(
      'Staff',
      name: 'bookingHistoryActorStaff',
      desc: '',
      args: [],
    );
  }

  /// `Sistema`
  String get bookingHistoryActorSystem {
    return Intl.message(
      'Sistema',
      name: 'bookingHistoryActorSystem',
      desc: '',
      args: [],
    );
  }

  /// `Destinatario: {email}`
  String bookingHistoryNotificationRecipient(Object email) {
    return Intl.message(
      'Destinatario: $email',
      name: 'bookingHistoryNotificationRecipient',
      desc: '',
      args: [email],
    );
  }

  /// `Data invio: {dateTime}`
  String bookingHistoryNotificationSentAt(Object dateTime) {
    return Intl.message(
      'Data invio: $dateTime',
      name: 'bookingHistoryNotificationSentAt',
      desc: '',
      args: [dateTime],
    );
  }

  /// `Conferma prenotazione`
  String get bookingHistoryNotificationChannelConfirmed {
    return Intl.message(
      'Conferma prenotazione',
      name: 'bookingHistoryNotificationChannelConfirmed',
      desc: '',
      args: [],
    );
  }

  /// `Promemoria prenotazione`
  String get bookingHistoryNotificationChannelReminder {
    return Intl.message(
      'Promemoria prenotazione',
      name: 'bookingHistoryNotificationChannelReminder',
      desc: '',
      args: [],
    );
  }

  /// `Cancellazione prenotazione`
  String get bookingHistoryNotificationChannelCancelled {
    return Intl.message(
      'Cancellazione prenotazione',
      name: 'bookingHistoryNotificationChannelCancelled',
      desc: '',
      args: [],
    );
  }

  /// `Riprogrammazione prenotazione`
  String get bookingHistoryNotificationChannelRescheduled {
    return Intl.message(
      'Riprogrammazione prenotazione',
      name: 'bookingHistoryNotificationChannelRescheduled',
      desc: '',
      args: [],
    );
  }

  /// `Campi modificati: {fields}`
  String bookingHistoryChangedFields(String fields) {
    return Intl.message(
      'Campi modificati: $fields',
      name: 'bookingHistoryChangedFields',
      desc: '',
      args: [fields],
    );
  }

  /// `ANNULLATA`
  String get cancelledBadge {
    return Intl.message(
      'ANNULLATA',
      name: 'cancelledBadge',
      desc: '',
      args: [],
    );
  }

  /// `Attivit√† non trovata`
  String get businessNotFound {
    return Intl.message(
      'Attivit√† non trovata',
      name: 'businessNotFound',
      desc: '',
      args: [],
    );
  }

  /// `Verifica l'indirizzo o contatta direttamente l'attivit√†.`
  String get businessNotFoundHint {
    return Intl.message(
      'Verifica l\'indirizzo o contatta direttamente l\'attivit√†.',
      name: 'businessNotFoundHint',
      desc: '',
      args: [],
    );
  }

  /// `Account associato ad un'altra attivit√†`
  String get wrongBusinessAuthTitle {
    return Intl.message(
      'Account associato ad un\'altra attivit√†',
      name: 'wrongBusinessAuthTitle',
      desc: '',
      args: [],
    );
  }

  /// `Per prenotare su {businessName}, devi accedere con un account registrato qui.`
  String wrongBusinessAuthMessage(String businessName) {
    return Intl.message(
      'Per prenotare su $businessName, devi accedere con un account registrato qui.',
      name: 'wrongBusinessAuthMessage',
      desc: '',
      args: [businessName],
    );
  }

  /// `Esci e accedi qui`
  String get wrongBusinessAuthAction {
    return Intl.message(
      'Esci e accedi qui',
      name: 'wrongBusinessAuthAction',
      desc: '',
      args: [],
    );
  }
}

class AppLocalizationDelegate extends LocalizationsDelegate<L10n> {
  const AppLocalizationDelegate();

  List<Locale> get supportedLocales {
    return const <Locale>[
      Locale.fromSubtags(languageCode: 'it'),
      Locale.fromSubtags(languageCode: 'en'),
    ];
  }

  @override
  bool isSupported(Locale locale) => _isSupported(locale);
  @override
  Future<L10n> load(Locale locale) => L10n.load(locale);
  @override
  bool shouldReload(AppLocalizationDelegate old) => false;

  bool _isSupported(Locale locale) {
    for (var supportedLocale in supportedLocales) {
      if (supportedLocale.languageCode == locale.languageCode) {
        return true;
      }
    }
    return false;
  }
}
--- FILE: lib/core/network/token_storage_mobile.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

import 'token_storage_interface.dart';

/// Implementazione secure storage per mobile/desktop
class SecureTokenStorage implements TokenStorage {
  static const _refreshTokenKey = 'agenda_refresh_token';
  static const _businessIdKey = 'agenda_business_id';

  final FlutterSecureStorage _storage;

  SecureTokenStorage()
    : _storage = const FlutterSecureStorage(
        aOptions: AndroidOptions(encryptedSharedPreferences: true),
        iOptions: IOSOptions(accessibility: KeychainAccessibility.first_unlock),
      );

  @override
  Future<String?> getRefreshToken() async {
    try {
      return await _storage.read(key: _refreshTokenKey);
    } catch (e) {
      debugPrint('TokenStorage: Error reading token: $e');
      return null;
    }
  }

  @override
  Future<void> saveRefreshToken(String token) async {
    try {
      await _storage.write(key: _refreshTokenKey, value: token);
    } catch (e) {
      debugPrint('TokenStorage: Error saving token: $e');
    }
  }

  @override
  Future<void> clearRefreshToken() async {
    try {
      await _storage.delete(key: _refreshTokenKey);
    } catch (e) {
      debugPrint('TokenStorage: Error clearing token: $e');
    }
  }

  @override
  Future<int?> getBusinessId() async {
    try {
      final value = await _storage.read(key: _businessIdKey);
      return value != null ? int.tryParse(value) : null;
    } catch (e) {
      debugPrint('TokenStorage: Error reading businessId: $e');
      return null;
    }
  }

  @override
  Future<void> saveBusinessId(int businessId) async {
    try {
      await _storage.write(key: _businessIdKey, value: businessId.toString());
    } catch (e) {
      debugPrint('TokenStorage: Error saving businessId: $e');
    }
  }

  @override
  Future<void> clearBusinessId() async {
    try {
      await _storage.delete(key: _businessIdKey);
    } catch (e) {
      debugPrint('TokenStorage: Error clearing businessId: $e');
    }
  }
}

/// Factory per creare storage su mobile/desktop
TokenStorage createTokenStorage() => SecureTokenStorage();
--- FILE: lib/core/network/network_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'api_client.dart';
import 'token_storage.dart';

/// Provider per TokenStorage
final tokenStorageProvider = Provider<TokenStorage>((ref) {
  return createTokenStorage();
});

/// Provider per ApiClient
final apiClientProvider = Provider<ApiClient>((ref) {
  final tokenStorage = ref.watch(tokenStorageProvider);
  return ApiClient(tokenStorage: tokenStorage);
});

/// Provider per l'ID del business per cui l'utente √® autenticato.
/// Legge il businessId salvato in localStorage/secureStorage dopo il login.
/// Ritorna null se l'utente non √® autenticato.
final authenticatedBusinessIdProvider = FutureProvider<int?>((ref) async {
  final tokenStorage = ref.watch(tokenStorageProvider);
  return tokenStorage.getBusinessId();
});
--- FILE: lib/core/network/api_config.dart ---
/// Configurazione API
class ApiConfig {
  /// Base URL dell'API - configurabile via environment
  /// Default: produzione (https://api.romeolab.it)
  /// Dev locale: --dart-define=API_BASE_URL=http://localhost:8888/agenda_core/public
  static const String baseUrl = String.fromEnvironment(
    'API_BASE_URL',
    defaultValue: 'https://api.romeolab.it',
  );

  /// Timeout per le richieste (ridotti per risposta rapida)
  static const Duration connectTimeout = Duration(seconds: 5);
  static const Duration receiveTimeout = Duration(seconds: 5);

  // ========== CUSTOMER AUTH ENDPOINTS ==========
  // Usati dal frontend prenotazioni (agenda_frontend)
  // I clienti usano la tabella 'clients', non 'users'

  /// POST /v1/customer/{business_id}/auth/login
  static String customerLogin(int businessId) =>
      '/v1/customer/$businessId/auth/login';

  /// POST /v1/customer/{business_id}/auth/register
  static String customerRegister(int businessId) =>
      '/v1/customer/$businessId/auth/register';

  /// POST /v1/customer/{business_id}/auth/refresh
  static String customerRefresh(int businessId) =>
      '/v1/customer/$businessId/auth/refresh';

  /// POST /v1/customer/{business_id}/auth/logout
  static String customerLogout(int businessId) =>
      '/v1/customer/$businessId/auth/logout';

  /// POST /v1/customer/{business_id}/auth/forgot-password
  static String customerForgotPassword(int businessId) =>
      '/v1/customer/$businessId/auth/forgot-password';

  /// POST /v1/customer/auth/reset-password
  static const String customerResetPassword =
      '/v1/customer/auth/reset-password';

  /// GET /v1/customer/me
  static const String customerMe = '/v1/customer/me';

  /// PUT /v1/customer/me - Aggiorna profilo cliente
  static const String customerUpdateProfile = '/v1/customer/me';

  /// POST /v1/customer/me/change-password
  static const String customerChangePassword =
      '/v1/customer/me/change-password';

  /// GET /v1/customer/bookings
  static const String customerBookings = '/v1/customer/bookings';

  /// PUT /v1/customer/bookings/{booking_id}
  static String customerUpdateBooking(int bookingId) =>
      '/v1/customer/bookings/$bookingId';

  /// DELETE /v1/customer/bookings/{booking_id}
  static String customerDeleteBooking(int bookingId) =>
      '/v1/customer/bookings/$bookingId';

  /// POST /v1/customer/bookings/{booking_id}/replace
  static String customerReplaceBooking(int bookingId) =>
      '/v1/customer/bookings/$bookingId/replace';

  /// GET /v1/customer/bookings/{booking_id}/history
  static String customerBookingHistory(int bookingId) =>
      '/v1/customer/bookings/$bookingId/history';

  /// POST /v1/customer/{business_id}/bookings
  static String customerCreateBooking(int businessId) =>
      '/v1/customer/$businessId/bookings';

  // ========== LEGACY AUTH ENDPOINTS (DEPRECATI per frontend) ==========
  // Questi sono per OPERATORI (gestionale), non per clienti
  static const String authLogin = '/v1/auth/login';
  static const String authRegister = '/v1/auth/register';
  static const String authRefresh = '/v1/auth/refresh';
  static const String authLogout = '/v1/auth/logout';
  static const String authForgotPassword = '/v1/auth/forgot-password';
  static const String authResetPassword = '/v1/auth/reset-password';
  static const String authMe = '/v1/me';
  static const String meChangePassword = '/v1/me/change-password';
  static const String meBookings = '/v1/me/bookings';

  // ========== PUBLIC BROWSE ENDPOINTS ==========
  static const String services = '/v1/services';
  static const String staff = '/v1/staff';
  static const String availability = '/v1/availability';

  // ========== SERVICE PACKAGES ENDPOINTS ==========
  static String servicePackages(int locationId) =>
      '/v1/locations/$locationId/service-packages';

  static String servicePackageExpand(int locationId, int packageId) =>
      '/v1/locations/$locationId/service-packages/$packageId/expand';

  // ========== STAFF PLANNING ENDPOINTS (read-only) ==========
  /// GET /v1/staff/{id}/plannings - tutti i planning per uno staff
  static String staffPlannings(int staffId) => '/v1/staff/$staffId/plannings';

  /// GET /v1/staff/{id}/planning?date=YYYY-MM-DD - planning valido per data
  static String staffPlanningForDate(int staffId) =>
      '/v1/staff/$staffId/planning';

  /// GET /v1/staff/{id}/planning-availability?date=YYYY-MM-DD - slot disponibili per data
  static String staffPlanningAvailability(int staffId) =>
      '/v1/staff/$staffId/planning-availability';

  // ========== BUSINESS ENDPOINTS ==========
  /// Get business by slug (public, no auth required)
  static String businessBySlug(String slug) => '/v1/businesses/by-slug/$slug';

  /// Get locations for a business (public, no auth required)
  static String businessLocations(int businessId) =>
      '/v1/businesses/$businessId/locations/public';

  // ========== BOOKINGS ENDPOINTS (legacy, per operatori) ==========
  static String bookings(int locationId) =>
      '/v1/locations/$locationId/bookings';
}
--- FILE: lib/core/network/token_storage_web.dart ---
// ignore_for_file: avoid_web_libraries_in_flutter
import 'dart:html' as html;

import 'package:flutter/foundation.dart';

import 'token_storage_interface.dart';

/// Implementazione Web che usa localStorage con fallback a sessionStorage
/// NOTA: In produzione si dovrebbe preferire cookie httpOnly server-side
class WebTokenStorage implements TokenStorage {
  static const _refreshTokenKey = 'agenda_refresh_token';
  static const _businessIdKey = 'agenda_business_id';

  html.Storage? _resolveStorage() {
    final candidates = [html.window.localStorage, html.window.sessionStorage];
    for (final storage in candidates) {
      try {
        const probeKey = '__agenda_storage_probe__';
        storage[probeKey] = '1';
        storage.remove(probeKey);
        return storage;
      } catch (_) {
        // Storage non disponibile/bloccato (es. browser embedded o modalit√† privata).
      }
    }
    return null;
  }

  String? _getValue(String key) {
    try {
      final localValue = html.window.localStorage[key];
      if (localValue != null) {
        return localValue;
      }
    } catch (_) {}

    try {
      return html.window.sessionStorage[key];
    } catch (_) {
      return null;
    }
  }

  void _setValue(String key, String value) {
    final storage = _resolveStorage();
    storage?[key] = value;
  }

  void _removeValue(String key) {
    try {
      html.window.localStorage.remove(key);
    } catch (_) {}
    try {
      html.window.sessionStorage.remove(key);
    } catch (_) {}
  }

  @override
  Future<String?> getRefreshToken() async {
    try {
      return _getValue(_refreshTokenKey);
    } catch (e) {
      debugPrint('TokenStorage: Error reading token from web storage: $e');
      return null;
    }
  }

  @override
  Future<void> saveRefreshToken(String token) async {
    try {
      _setValue(_refreshTokenKey, token);
    } catch (e) {
      debugPrint('TokenStorage: Error saving token to web storage: $e');
    }
  }

  @override
  Future<void> clearRefreshToken() async {
    try {
      _removeValue(_refreshTokenKey);
    } catch (e) {
      debugPrint('TokenStorage: Error clearing token from web storage: $e');
    }
  }

  @override
  Future<int?> getBusinessId() async {
    try {
      final value = _getValue(_businessIdKey);
      return value != null ? int.tryParse(value) : null;
    } catch (e) {
      debugPrint('TokenStorage: Error reading businessId from web storage: $e');
      return null;
    }
  }

  @override
  Future<void> saveBusinessId(int businessId) async {
    try {
      _setValue(_businessIdKey, businessId.toString());
    } catch (e) {
      debugPrint('TokenStorage: Error saving businessId to web storage: $e');
    }
  }

  @override
  Future<void> clearBusinessId() async {
    try {
      _removeValue(_businessIdKey);
    } catch (e) {
      debugPrint(
        'TokenStorage: Error clearing businessId from web storage: $e',
      );
    }
  }
}

/// Factory per creare storage su Web
TokenStorage createTokenStorage() => WebTokenStorage();
--- FILE: lib/core/network/token_storage_interface.dart ---
/// Gestione storage per refresh token e business ID
/// - Web: localStorage (con considerazioni di sicurezza per production)
/// - Mobile: secure storage
abstract class TokenStorage {
  Future<String?> getRefreshToken();
  Future<void> saveRefreshToken(String token);
  Future<void> clearRefreshToken();

  /// Business ID per customer auth (necessario per refresh token)
  Future<int?> getBusinessId();
  Future<void> saveBusinessId(int businessId);
  Future<void> clearBusinessId();
}
--- FILE: lib/core/network/api_client.dart ---
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';

import 'api_config.dart';
import 'token_storage.dart';

/// Eccezione per token scaduto (401 non recuperabile)
/// Usata quando il refresh token fallisce
class TokenExpiredException implements Exception {
  final String message;
  const TokenExpiredException([this.message = 'Session expired']);

  @override
  String toString() => 'TokenExpiredException: $message';
}

/// Eccezione API custom
class ApiException implements Exception {
  final String code;
  final String message;
  final int statusCode;
  final dynamic details;

  const ApiException({
    required this.code,
    required this.message,
    required this.statusCode,
    this.details,
  });

  bool get isUnauthorized => statusCode == 401;
  bool get isNotFound => statusCode == 404;
  bool get isConflict => statusCode == 409;
  bool get isSlotConflict => code == 'slot_conflict';
  bool get isServiceUnavailable =>
      statusCode == 503 || code == 'database_error';
  bool get isLocationNotFound =>
      isNotFound && message.toLowerCase().contains('location');
  bool get isBusinessNotFound =>
      isNotFound && message.toLowerCase().contains('business');

  @override
  String toString() => 'ApiException($code): $message';
}

/// Client HTTP per comunicare con agenda_core API
/// Usato dal frontend prenotazioni (agenda_frontend) per CLIENTI
class ApiClient {
  final Dio _dio;
  final TokenStorage _tokenStorage;

  String? _accessToken;

  /// Business ID corrente per refresh token
  /// Necessario perch√© l'endpoint di refresh √® business-scoped
  int? _currentBusinessId;

  ApiClient({required TokenStorage tokenStorage, Dio? dio})
    : _tokenStorage = tokenStorage,
      _dio = dio ?? Dio() {
    _dio.options.baseUrl = ApiConfig.baseUrl;
    _dio.options.connectTimeout = ApiConfig.connectTimeout;
    _dio.options.receiveTimeout = ApiConfig.receiveTimeout;
    _dio.options.headers['Content-Type'] = 'application/json';
    _dio.options.headers['Accept'] = 'application/json';
    if (kIsWeb) {
      _dio.options.extra['withCredentials'] = true;
    }

    // Interceptor per logging in debug
    // LogInterceptor rimosso per evitare log verbosi durante il booking flow.

    // Interceptor per auth token
    _dio.interceptors.add(
      InterceptorsWrapper(
        onRequest: (options, handler) {
          if (_accessToken != null) {
            options.headers['Authorization'] = 'Bearer $_accessToken';
          }
          handler.next(options);
        },
        onError: (error, handler) async {
          // Gestione token expired - auto refresh
          if (error.response?.statusCode == 401 &&
              error.response?.data?['error']?['code'] == 'token_expired') {
            try {
              final refreshed = await _refreshToken();
              if (refreshed) {
                // Riprova la richiesta originale
                final opts = error.requestOptions;
                opts.headers['Authorization'] = 'Bearer $_accessToken';
                final response = await _dio.fetch(opts);
                return handler.resolve(response);
              }
            } catch (_) {
              // Refresh fallito, propaga errore originale
            }
          }
          handler.next(error);
        },
      ),
    );
  }

  /// Imposta access token in memoria
  void setAccessToken(String? token) {
    _accessToken = token;
  }

  /// Imposta il business ID corrente (per refresh token)
  void setCurrentBusinessId(int? businessId) {
    _currentBusinessId = businessId;
  }

  /// Verifica se autenticato
  bool get isAuthenticated => _accessToken != null;

  /// Tenta refresh del token (customer)
  Future<bool> _refreshToken() async {
    final refreshToken = await _tokenStorage.getRefreshToken();
    if (_currentBusinessId == null) return false;
    // On web, refresh token may be in httpOnly cookie (not readable from JS).
    // In that case, call refresh endpoint without refresh_token in body.
    if (!kIsWeb && refreshToken == null) return false;

    try {
      final response = await _dio.post(
        ApiConfig.customerRefresh(_currentBusinessId!),
        data: refreshToken != null ? {'refresh_token': refreshToken} : {},
      );

      if (response.data['success'] == true) {
        final data = response.data['data'];
        _accessToken = data['access_token'];
        final nextRefreshToken = data['refresh_token'];
        if (nextRefreshToken is String && nextRefreshToken.isNotEmpty) {
          await _tokenStorage.saveRefreshToken(nextRefreshToken);
        }
        return true;
      }
    } catch (_) {
      // Token non valido, pulisci storage
      await _tokenStorage.clearRefreshToken();
    }
    return false;
  }

  /// Tenta di ripristinare sessione da refresh token (customer)
  /// Richiede businessId per chiamare l'endpoint corretto
  Future<Map<String, dynamic>?> tryRestoreSession({int? businessId}) async {
    debugPrint('API: tryRestoreSession start, businessId=$businessId');
    final refreshToken = await _tokenStorage.getRefreshToken();
    debugPrint(
      'API: refreshToken from storage: ${refreshToken != null ? "present (${refreshToken.length} chars)" : "null"}',
    );
    // Usa il businessId passato o quello salvato
    final effectiveBusinessId = businessId ?? _currentBusinessId;
    debugPrint('API: effectiveBusinessId=$effectiveBusinessId');
    if (effectiveBusinessId == null) {
      debugPrint('API: no businessId, returning null');
      return null;
    }
    // On web, refresh token may be in httpOnly cookie (not readable from storage).
    // Only skip if not web and no refresh token is available.
    if (!kIsWeb && refreshToken == null) {
      debugPrint('API: no refreshToken, returning null');
      return null;
    }

    try {
      debugPrint(
        'API: calling refresh endpoint: ${ApiConfig.customerRefresh(effectiveBusinessId)}',
      );
      final response = await _dio.post(
        ApiConfig.customerRefresh(effectiveBusinessId),
        data: refreshToken != null ? {'refresh_token': refreshToken} : {},
      );

      debugPrint('API: refresh response: ${response.data}');
      if (response.data['success'] == true) {
        final data = response.data['data'];
        _accessToken = data['access_token'];
        _currentBusinessId = effectiveBusinessId;
        final nextRefreshToken = data['refresh_token'];
        if (nextRefreshToken is String && nextRefreshToken.isNotEmpty) {
          await _tokenStorage.saveRefreshToken(nextRefreshToken);
          debugPrint('API: saved new refresh token');
        }

        // Fetch customer profile
        debugPrint('API: fetching customer profile');
        return await getCustomerMe();
      } else {
        debugPrint('API: refresh response success=false');
      }
    } catch (e, st) {
      debugPrint('API: refresh error: $e');
      debugPrint('API: stack: $st');
      await _tokenStorage.clearRefreshToken();
    }
    return null;
  }

  /// Esegue richiesta GET
  Future<Map<String, dynamic>> get(
    String path, {
    Map<String, dynamic>? queryParameters,
  }) async {
    try {
      final response = await _dio.get(path, queryParameters: queryParameters);
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Esegue richiesta POST
  Future<Map<String, dynamic>> post(
    String path, {
    Map<String, dynamic>? data,
    Map<String, String>? headers,
  }) async {
    try {
      final response = await _dio.post(
        path,
        data: data,
        options: headers != null ? Options(headers: headers) : null,
      );
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Esegue richiesta DELETE
  Future<Map<String, dynamic>> delete(
    String path, {
    Map<String, dynamic>? queryParameters,
  }) async {
    try {
      final response = await _dio.delete(
        path,
        queryParameters: queryParameters,
      );
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Esegue richiesta PUT
  Future<Map<String, dynamic>> put(
    String path, {
    Map<String, dynamic>? data,
  }) async {
    try {
      final response = await _dio.put(path, data: data);
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Gestisce risposta API
  Map<String, dynamic> _handleResponse(Response response) {
    final body = response.data as Map<String, dynamic>;
    if (body['success'] == true) {
      return body['data'] as Map<String, dynamic>? ?? {};
    }
    throw ApiException(
      code: body['error']?['code'] ?? 'unknown_error',
      message: body['error']?['message'] ?? 'Unknown error',
      statusCode: response.statusCode ?? 500,
      details: body['error']?['details'],
    );
  }

  /// Gestisce errori Dio
  ApiException _handleError(DioException error) {
    final response = error.response;
    if (response != null) {
      final body = response.data;
      if (body is Map<String, dynamic>) {
        return ApiException(
          code: body['error']?['code'] ?? 'api_error',
          message: body['error']?['message'] ?? error.message ?? 'API Error',
          statusCode: response.statusCode ?? 500,
          details: body['error']?['details'],
        );
      }
    }
    return ApiException(
      code: 'network_error',
      message: error.message ?? 'Network error',
      statusCode: error.response?.statusCode ?? 0,
    );
  }

  // ========== CUSTOMER AUTH ENDPOINTS ==========
  // Usati dal frontend prenotazioni per CLIENTI (tabella clients)

  /// POST /v1/customer/{business_id}/auth/login
  Future<Map<String, dynamic>> customerLogin({
    required int businessId,
    required String email,
    required String password,
  }) async {
    debugPrint('=== customerLogin ===');
    debugPrint('baseUrl: ${_dio.options.baseUrl}');
    debugPrint('endpoint: ${ApiConfig.customerLogin(businessId)}');
    debugPrint('businessId: $businessId, email: $email');

    final data = await post(
      ApiConfig.customerLogin(businessId),
      data: {'email': email, 'password': password},
    );

    debugPrint('customerLogin SUCCESS: ${data.keys}');
    _accessToken = data['access_token'];
    _currentBusinessId = businessId;
    final refreshToken = data['refresh_token'];
    if (refreshToken is String && refreshToken.isNotEmpty) {
      await _tokenStorage.saveRefreshToken(refreshToken);
    }
    // Salva anche il business ID per restore session
    await _tokenStorage.saveBusinessId(businessId);

    return data;
  }

  /// POST /v1/customer/{business_id}/auth/register
  Future<Map<String, dynamic>> customerRegister({
    required int businessId,
    required String email,
    required String password,
    required String firstName,
    required String lastName,
    String? phone,
  }) async {
    debugPrint('=== API customerRegister ===');
    debugPrint('businessId: $businessId, email: $email');
    debugPrint('endpoint: ${ApiConfig.customerRegister(businessId)}');

    final data = await post(
      ApiConfig.customerRegister(businessId),
      data: {
        'email': email,
        'password': password,
        'first_name': firstName,
        'last_name': lastName,
        if (phone != null) 'phone': phone,
      },
    );

    debugPrint('API response: $data');

    _accessToken = data['access_token'];
    _currentBusinessId = businessId;
    final refreshToken = data['refresh_token'];
    if (refreshToken is String && refreshToken.isNotEmpty) {
      await _tokenStorage.saveRefreshToken(refreshToken);
    }
    await _tokenStorage.saveBusinessId(businessId);

    return data;
  }

  /// POST /v1/customer/{business_id}/auth/logout
  Future<void> customerLogout({required int businessId}) async {
    final refreshToken = await _tokenStorage.getRefreshToken();
    try {
      await post(
        ApiConfig.customerLogout(businessId),
        data: refreshToken != null
            ? {'refresh_token': refreshToken}
            : <String, dynamic>{},
      );
    } finally {
      _accessToken = null;
      _currentBusinessId = null;
      await _tokenStorage.clearRefreshToken();
      await _tokenStorage.clearBusinessId();
    }
  }

  /// POST /v1/customer/{business_id}/auth/forgot-password
  Future<void> customerForgotPassword({
    required int businessId,
    required String email,
  }) async {
    await post(
      ApiConfig.customerForgotPassword(businessId),
      data: {'email': email},
    );
  }

  /// POST /v1/customer/auth/reset-password
  Future<void> customerResetPassword({
    required String token,
    required String password,
  }) async {
    await post(
      ApiConfig.customerResetPassword,
      data: {'token': token, 'password': password},
    );
  }

  /// GET /v1/customer/me
  Future<Map<String, dynamic>> getCustomerMe() async {
    return get(ApiConfig.customerMe);
  }

  /// PUT /v1/customer/me - Aggiorna profilo cliente
  Future<Map<String, dynamic>> customerUpdateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
  }) async {
    final data = <String, dynamic>{};
    if (firstName != null) data['first_name'] = firstName;
    if (lastName != null) data['last_name'] = lastName;
    if (email != null) data['email'] = email;
    if (phone != null) data['phone'] = phone;

    return put(ApiConfig.customerUpdateProfile, data: data);
  }

  /// POST /v1/customer/me/change-password
  Future<void> customerChangePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    await post(
      ApiConfig.customerChangePassword,
      data: {'current_password': currentPassword, 'new_password': newPassword},
    );
  }

  /// GET /v1/customer/bookings
  Future<Map<String, dynamic>> getCustomerBookings() async {
    return get(ApiConfig.customerBookings);
  }

  /// GET /v1/customer/bookings/{booking_id}/history
  /// Recupera lo storico eventi (audit trail) di una prenotazione del cliente
  Future<List<dynamic>> getCustomerBookingHistory(int bookingId) async {
    final response = await get(ApiConfig.customerBookingHistory(bookingId));
    return response['events'] as List<dynamic>? ?? [];
  }

  /// PUT /v1/customer/bookings/{booking_id}
  Future<Map<String, dynamic>> customerUpdateBooking({
    required int bookingId,
    String? startTime,
    String? notes,
  }) async {
    return put(
      ApiConfig.customerUpdateBooking(bookingId),
      data: {
        if (startTime != null) 'start_time': startTime,
        if (notes != null) 'notes': notes,
      },
    );
  }

  /// DELETE /v1/customer/bookings/{booking_id}
  Future<void> customerDeleteBooking(int bookingId) async {
    await delete(ApiConfig.customerDeleteBooking(bookingId));
  }

  /// POST /v1/customer/bookings/{booking_id}/replace
  /// Sostituisce una prenotazione esistente con una nuova (atomic replace pattern).
  /// L'originale viene marcata 'replaced', la nuova viene creata con link bidirezionale.
  Future<Map<String, dynamic>> customerReplaceBooking({
    required int bookingId,
    required String idempotencyKey,
    required int locationId,
    required List<int> serviceIds,
    required String startTime,
    int? staffId,
    String? notes,
    String? reason,
    List<Map<String, dynamic>>? items,
  }) async {
    final data = <String, dynamic>{'location_id': locationId};
    if (items != null) {
      data['items'] = items;
    } else {
      data['service_ids'] = serviceIds;
      data['start_time'] = startTime;
      if (staffId != null) {
        data['staff_id'] = staffId;
      }
    }
    if (notes != null && notes.isNotEmpty) {
      data['notes'] = notes;
    }
    if (reason != null && reason.isNotEmpty) {
      data['reason'] = reason;
    }

    return post(
      ApiConfig.customerReplaceBooking(bookingId),
      data: data,
      headers: {'X-Idempotency-Key': idempotencyKey},
    );
  }

  /// POST /v1/customer/{business_id}/bookings
  Future<Map<String, dynamic>> createCustomerBooking({
    required int businessId,
    required String idempotencyKey,
    required int locationId,
    required List<int> serviceIds,
    required String startTime,
    int? staffId,
    String? notes,
    List<Map<String, dynamic>>? items,
  }) async {
    final data = <String, dynamic>{'location_id': locationId};
    if (items != null) {
      data['items'] = items;
    } else {
      data['service_ids'] = serviceIds;
      data['start_time'] = startTime;
      if (staffId != null) {
        data['staff_id'] = staffId;
      }
    }
    if (notes != null && notes.isNotEmpty) {
      data['notes'] = notes;
    }

    return post(
      ApiConfig.customerCreateBooking(businessId),
      data: data,
      headers: {'X-Idempotency-Key': idempotencyKey},
    );
  }

  // ========== LEGACY AUTH ENDPOINTS (per operatori, non usare nel frontend) ==========

  /// POST /v1/auth/login (DEPRECATO - usare customerLogin)
  @Deprecated('Use customerLogin for frontend auth')
  Future<Map<String, dynamic>> login(String email, String password) async {
    final data = await post(
      ApiConfig.authLogin,
      data: {'email': email, 'password': password},
    );

    _accessToken = data['access_token'];
    await _tokenStorage.saveRefreshToken(data['refresh_token']);

    return data;
  }

  /// POST /v1/auth/logout (DEPRECATO - usare customerLogout)
  @Deprecated('Use customerLogout for frontend auth')
  Future<void> logout() async {
    final refreshToken = await _tokenStorage.getRefreshToken();
    try {
      await post(ApiConfig.authLogout, data: {'refresh_token': refreshToken});
    } finally {
      _accessToken = null;
      await _tokenStorage.clearRefreshToken();
    }
  }

  /// GET /v1/me
  Future<Map<String, dynamic>> getMe() async {
    return get(ApiConfig.authMe);
  }

  /// POST /v1/auth/register
  Future<Map<String, dynamic>> register({
    required String email,
    required String password,
    required String name,
    String? phone,
  }) async {
    final data = await post(
      ApiConfig.authRegister,
      data: {
        'email': email,
        'password': password,
        'name': name,
        if (phone != null) 'phone': phone,
      },
    );

    _accessToken = data['access_token'];
    await _tokenStorage.saveRefreshToken(data['refresh_token']);

    return data;
  }

  /// POST /v1/auth/forgot-password
  Future<void> forgotPassword({required String email}) async {
    await post(ApiConfig.authForgotPassword, data: {'email': email});
  }

  /// POST /v1/auth/reset-password
  Future<void> resetPasswordWithToken({
    required String token,
    required String password,
  }) async {
    await post(
      ApiConfig.authResetPassword,
      data: {'token': token, 'password': password},
    );
  }

  /// POST /v1/me/change-password
  Future<void> changePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    await post(
      ApiConfig.meChangePassword,
      data: {'current_password': currentPassword, 'new_password': newPassword},
    );
  }

  /// PUT /v1/me - Aggiorna profilo utente
  Future<Map<String, dynamic>> updateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
  }) async {
    final data = <String, dynamic>{};
    if (firstName != null) data['first_name'] = firstName;
    if (lastName != null) data['last_name'] = lastName;
    if (email != null) data['email'] = email;
    if (phone != null) data['phone'] = phone;

    return put(ApiConfig.authMe, data: data);
  }

  /// GET /v1/me/bookings
  Future<Map<String, dynamic>> getMyBookings() async {
    return get(ApiConfig.meBookings);
  }

  // ========== PUBLIC BROWSE ENDPOINTS ==========

  /// GET /v1/businesses/by-slug/{slug}
  /// Recupera un business dal suo slug (pubblico, no auth)
  Future<Map<String, dynamic>> getBusinessBySlug(String slug) async {
    return get(ApiConfig.businessBySlug(slug));
  }

  /// GET /v1/businesses/{business_id}/locations/public
  /// Recupera le locations di un business (pubblico, per booking flow)
  Future<Map<String, dynamic>> getBusinessLocations(int businessId) async {
    return get(ApiConfig.businessLocations(businessId));
  }

  /// GET /v1/services?location_id=X
  Future<Map<String, dynamic>> getServices(int locationId) async {
    return get(
      ApiConfig.services,
      queryParameters: {'location_id': locationId},
    );
  }

  /// GET /v1/locations/{location_id}/service-packages
  Future<Map<String, dynamic>> getServicePackages(int locationId) async {
    return get(ApiConfig.servicePackages(locationId));
  }

  /// GET /v1/locations/{location_id}/service-packages/{id}/expand
  Future<Map<String, dynamic>> expandServicePackage({
    required int locationId,
    required int packageId,
  }) async {
    return get(ApiConfig.servicePackageExpand(locationId, packageId));
  }

  /// GET /v1/staff?location_id=X
  Future<Map<String, dynamic>> getStaff(int locationId) async {
    return get(ApiConfig.staff, queryParameters: {'location_id': locationId});
  }

  /// GET /v1/availability?location_id=X&date=YYYY-MM-DD&service_ids=1,2&staff_id=N&exclude_booking_id=N
  Future<Map<String, dynamic>> getAvailability({
    required int locationId,
    required String date,
    required List<int> serviceIds,
    int? staffId,
    int? excludeBookingId,
  }) async {
    final params = <String, dynamic>{
      'location_id': locationId,
      'date': date,
      'service_ids': serviceIds.join(','),
    };
    if (staffId != null) {
      params['staff_id'] = staffId;
    }
    if (excludeBookingId != null) {
      params['exclude_booking_id'] = excludeBookingId;
    }
    return get(ApiConfig.availability, queryParameters: params);
  }

  // ========== STAFF PLANNING ENDPOINTS (read-only) ==========

  /// GET /v1/staff/{id}/plannings - tutti i planning per uno staff
  Future<Map<String, dynamic>> getStaffPlannings(int staffId) async {
    return get(ApiConfig.staffPlannings(staffId));
  }

  /// GET /v1/staff/{id}/planning?date=YYYY-MM-DD - planning valido per data
  Future<Map<String, dynamic>> getStaffPlanningForDate({
    required int staffId,
    required String date,
  }) async {
    return get(
      ApiConfig.staffPlanningForDate(staffId),
      queryParameters: {'date': date},
    );
  }

  /// GET /v1/staff/{id}/planning-availability?date=YYYY-MM-DD - slot disponibili per data
  /// Ritorna array di slot index (es: [36, 37, 38, 48, 49, 50...])
  Future<Map<String, dynamic>> getStaffPlanningAvailability({
    required int staffId,
    required String date,
  }) async {
    return get(
      ApiConfig.staffPlanningAvailability(staffId),
      queryParameters: {'date': date},
    );
  }

  // ========== BOOKING ENDPOINT ==========

  /// POST /v1/locations/{location_id}/bookings
  Future<Map<String, dynamic>> createBooking({
    required int locationId,
    required String idempotencyKey,
    required List<int> serviceIds,
    required String startTime,
    int? staffId,
    String? notes,
  }) async {
    final data = <String, dynamic>{
      'service_ids': serviceIds,
      'start_time': startTime,
    };
    if (staffId != null) {
      data['staff_id'] = staffId;
    }
    if (notes != null && notes.isNotEmpty) {
      data['notes'] = notes;
    }

    return post(
      ApiConfig.bookings(locationId),
      data: data,
      headers: {'X-Idempotency-Key': idempotencyKey},
    );
  }

  /// DELETE /v1/locations/{location_id}/bookings/{id}
  /// NOTE: Richiede location_id, quindi serve prima recuperare il booking completo
  /// da GET /v1/me/bookings per ottenere il location_id associato
  Future<void> deleteBooking(int locationId, int bookingId) async {
    await delete('/v1/locations/$locationId/bookings/$bookingId');
  }

  /// PUT /v1/locations/{location_id}/bookings/{id}
  /// Reschedule booking (modifica data/ora)
  Future<Map<String, dynamic>> updateBooking({
    required int locationId,
    required int bookingId,
    required String startTime,
    String? notes,
  }) async {
    final data = <String, dynamic>{'start_time': startTime};
    if (notes != null) {
      data['notes'] = notes;
    }

    return await _dio
        .put('/v1/locations/$locationId/bookings/$bookingId', data: data)
        .then((response) => _handleResponse(response))
        .catchError((e) => throw _handleError(e as DioException));
  }
}
--- FILE: lib/core/network/token_storage.dart ---
export 'token_storage_interface.dart';
// Conditional import: web vs mobile/desktop
export 'token_storage_mobile.dart'
    if (dart.library.html) 'token_storage_web.dart';
--- FILE: lib/core/navigation/native_login_redirect_stub.dart ---
void redirectToNativeLoginImpl({required String slug, String? from}) {
  // No-op on non-web platforms.
}
--- FILE: lib/core/navigation/native_login_redirect_web.dart ---
// ignore_for_file: avoid_web_libraries_in_flutter
import 'dart:html' as html;

void redirectToNativeLoginImpl({required String slug, String? from}) {
  final queryParameters = <String, String>{
    'slug': slug,
    if (from != null && from.isNotEmpty) 'from': from,
  };
  final query = Uri(queryParameters: queryParameters).query;
  html.window.location.assign('/login.html?$query');
}
--- FILE: lib/core/navigation/native_login_redirect.dart ---
import 'native_login_redirect_stub.dart'
    if (dart.library.html) 'native_login_redirect_web.dart';

void redirectToNativeLogin({required String slug, String? from}) {
  redirectToNativeLoginImpl(slug: slug, from: from);
}
--- FILE: lib/core/utils/initials_utils.dart ---
import 'package:characters/characters.dart';

/// Utility per generare iniziali in modo Unicode-safe (emoji incluse).
class InitialsUtils {
  const InitialsUtils._();

  static String fromName(String name, {int maxChars = 2}) {
    final trimmed = name.trim();
    if (trimmed.isEmpty || maxChars <= 0) return '';

    final parts = trimmed.split(RegExp(r'\s+')).where((p) => p.isNotEmpty);
    final initials = <String>[];

    final partList = parts.toList();
    if (partList.isNotEmpty) {
      initials.add(_firstGrapheme(partList.first));
    }

    for (int i = 1; i < partList.length && initials.length < maxChars; i++) {
      initials.add(_firstGrapheme(partList[i]));
    }

    if (partList.length == 1 && initials.length < maxChars) {
      final graphemes = trimmed.characters;
      if (graphemes.length > 1) {
        initials.add(graphemes.skip(1).first);
      }
    }

    return initials
        .map((g) => g.toUpperCase())
        .take(maxChars)
        .toList()
        .join();
  }

  static String _firstGrapheme(String value) => value.characters.first;
}
--- FILE: lib/core/utils/subdomain_resolver.dart ---
/// Utility per risolvere il business slug dall'URL corrente.
///
/// Pattern supportati (in ordine di priorit√†):
/// 1. Sottodominio: {slug}.prenota.tuodominio.it ‚Üí "slug"
/// 2. Path-based: prenota.tuodominio.it/{slug} ‚Üí "slug"
/// 3. Query param: prenota.tuodominio.it?business={slug} ‚Üí "slug"
///
/// Esempio: salonemario.prenota.romeolab.it ‚Üí "salonemario"
/// Esempio: prenota.romeolab.it/salonemario ‚Üí "salonemario"
class SubdomainResolver {
  /// Pattern regex per estrarre lo slug dal sottodominio.
  /// Supporta: {slug}.prenota.{domain} o {slug}.{domain}
  static final RegExp _subdomainPattern = RegExp(
    r'^([a-z0-9][a-z0-9-]*[a-z0-9]|[a-z0-9])\.(?:prenota\.)?',
    caseSensitive: false,
  );

  /// Pattern per validare lo slug (alfanumerico con trattini)
  static final RegExp _slugPattern = RegExp(
    r'^[a-z0-9][a-z0-9-]*[a-z0-9]$|^[a-z0-9]$',
  );

  /// Domini da escludere (non sono slug di business)
  static const _excludedSubdomains = {
    'www',
    'api',
    'admin',
    'gestionale',
    'app',
    'dev',
    'test',
    'localhost',
    'prenota',
  };

  /// Path segments da escludere (non sono slug)
  static const _excludedPaths = {
    '',
    'index.html',
    'booking',
    'login',
    'register',
    'privacy',
    'terms',
  };

  /// Estrae lo slug del business dall'URL corrente.
  ///
  /// Prova in ordine:
  /// 1. Sottodominio: salonemario.prenota.romeolab.it
  /// 2. Path: prenota.romeolab.it/salonemario
  /// 3. Query: prenota.romeolab.it?business=salonemario
  ///
  /// Returns: slug del business o null se non trovato
  static String? getBusinessSlug() {
    try {
      // 1. Prova sottodominio
      final subdomainSlug = _getSlugFromSubdomain();
      if (subdomainSlug != null) {
        return subdomainSlug;
      }

      // 2. Prova path-based (primo segmento del path)
      final pathSlug = _getSlugFromPath();
      if (pathSlug != null) {
        return pathSlug;
      }

      // 3. Prova query parameter
      final querySlug = _getSlugFromQuery();
      if (querySlug != null) {
        return querySlug;
      }

      return null;
    } catch (_) {
      return null;
    }
  }

  /// Estrae slug dal sottodominio
  static String? _getSlugFromSubdomain() {
    final host = Uri.base.host.toLowerCase();

    // Localhost non ha sottodomini
    if (host.startsWith('localhost') || host.startsWith('127.0.0.1')) {
      return null;
    }

    final match = _subdomainPattern.firstMatch(host);
    if (match == null) {
      return null;
    }

    final slug = match.group(1);
    if (slug == null || _excludedSubdomains.contains(slug)) {
      return null;
    }

    return slug;
  }

  /// Estrae slug dal primo segmento del path
  /// Es: prenota.romeolab.it/salonemario ‚Üí "salonemario"
  static String? _getSlugFromPath() {
    final pathSegments = Uri.base.pathSegments;
    if (pathSegments.isEmpty) {
      return null;
    }

    final firstSegment = pathSegments.first.toLowerCase();

    // Verifica che sia un slug valido
    if (_excludedPaths.contains(firstSegment)) {
      return null;
    }

    if (!_slugPattern.hasMatch(firstSegment)) {
      return null;
    }

    return firstSegment;
  }

  /// Estrae slug dal query parameter "business" o "b"
  /// Es: prenota.romeolab.it?business=salonemario ‚Üí "salonemario"
  static String? _getSlugFromQuery() {
    final params = Uri.base.queryParameters;
    final slug = params['business'] ?? params['b'];

    if (slug == null || slug.isEmpty) {
      return null;
    }

    final normalizedSlug = slug.toLowerCase();
    if (!_slugPattern.hasMatch(normalizedSlug)) {
      return null;
    }

    return normalizedSlug;
  }

  /// Verifica se l'URL corrente contiene un business slug.
  static bool isBusinessSubdomain() {
    return getBusinessSlug() != null;
  }

  /// Costruisce l'URL per un business dato il suo slug.
  ///
  /// Usa il formato path-based per compatibilit√† con hosting standard.
  /// Esempio: buildBusinessUrl("salonemario") ‚Üí "https://prenota.romeolab.it/salonemario"
  static String buildBusinessUrl(
    String slug, {
    String baseDomain = 'prenota.romeolab.it',
    bool usePathBased = true,
  }) {
    if (usePathBased) {
      return 'https://$baseDomain/$slug';
    }
    // Formato sottodominio (richiede wildcard SSL)
    return 'https://$slug.$baseDomain';
  }

  /// Ritorna la modalit√† di risoluzione usata per lo slug corrente.
  /// Utile per debug.
  static String? getResolutionMode() {
    if (_getSlugFromSubdomain() != null) return 'subdomain';
    if (_getSlugFromPath() != null) return 'path';
    if (_getSlugFromQuery() != null) return 'query';
    return null;
  }
}
--- FILE: lib/core/models/service_category.dart ---
/// Categoria di servizi
class ServiceCategory {
  final int id;
  final int businessId;
  final String name;
  final String? description;
  final int sortOrder;

  const ServiceCategory({
    required this.id,
    required this.businessId,
    required this.name,
    this.description,
    this.sortOrder = 0,
  });

  ServiceCategory copyWith({
    int? id,
    int? businessId,
    String? name,
    String? description,
    int? sortOrder,
  }) => ServiceCategory(
    id: id ?? this.id,
    businessId: businessId ?? this.businessId,
    name: name ?? this.name,
    description: description ?? this.description,
    sortOrder: sortOrder ?? this.sortOrder,
  );

  factory ServiceCategory.fromJson(Map<String, dynamic> json) =>
      ServiceCategory(
        id: json['id'] as int? ?? 0,
        businessId: json['business_id'] as int? ?? 0,
        name: json['name'] as String? ?? '',
        description: json['description'] as String?,
        sortOrder: json['sort_order'] as int? ?? 0,
      );

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'name': name,
    if (description != null) 'description': description,
    'sort_order': sortOrder,
  };
}
--- FILE: lib/core/models/user.dart ---
/// Modello utente per l'autenticazione
class User {
  final int id;
  final String email;
  final String firstName;
  final String lastName;
  final String? phone;
  final DateTime? createdAt;

  const User({
    required this.id,
    required this.email,
    required this.firstName,
    required this.lastName,
    this.phone,
    this.createdAt,
  });

  String get fullName => '$firstName $lastName';

  User copyWith({
    int? id,
    String? email,
    String? firstName,
    String? lastName,
    String? phone,
    DateTime? createdAt,
  }) => User(
    id: id ?? this.id,
    email: email ?? this.email,
    firstName: firstName ?? this.firstName,
    lastName: lastName ?? this.lastName,
    phone: phone ?? this.phone,
    createdAt: createdAt ?? this.createdAt,
  );

  factory User.fromJson(Map<String, dynamic> json) => User(
    id: json['id'] as int,
    email: json['email'] as String,
    firstName: json['first_name'] as String,
    lastName: json['last_name'] as String,
    phone: json['phone'] as String?,
    createdAt: json['created_at'] != null
        ? DateTime.parse(json['created_at'] as String)
        : null,
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'first_name': firstName,
    'last_name': lastName,
    if (phone != null) 'phone': phone,
    if (createdAt != null) 'created_at': createdAt!.toIso8601String(),
  };
}
--- FILE: lib/core/models/booking_item.dart ---
/// Modello per le prenotazioni utente recuperate da /v1/me/bookings
class BookingItem {
  final int id;
  final int businessId;
  final String businessName;
  final int locationId;
  final String locationName;
  final String? locationAddress;
  final String? locationCity;
  final List<String> serviceNames;
  final List<int> serviceIds;
  final int? staffId;
  final String? staffName;
  final DateTime startTime;
  final DateTime endTime;
  final double totalPrice;
  final String? notes;
  final bool canModify;
  final DateTime? canModifyUntil;

  /// Raw API string for `can_modify_until` (ISO8601). Useful to display the
  /// location time without device timezone conversion.
  final String? canModifyUntilRaw;
  final String status;

  const BookingItem({
    required this.id,
    required this.businessId,
    required this.businessName,
    required this.locationId,
    required this.locationName,
    this.locationAddress,
    this.locationCity,
    required this.serviceNames,
    this.serviceIds = const [],
    this.staffId,
    this.staffName,
    required this.startTime,
    required this.endTime,
    this.totalPrice = 0.0,
    this.notes,
    required this.canModify,
    this.canModifyUntil,
    this.canModifyUntilRaw,
    this.status = 'confirmed',
  });

  factory BookingItem.fromJson(Map<String, dynamic> json) {
    // Supporta sia formato nested (location.id) che flat (location_id)
    final location = json['location'] as Map<String, dynamic>?;
    final business = json['business'] as Map<String, dynamic>?;

    return BookingItem(
      id: json['id'] as int? ?? json['booking_id'] as int,
      businessId: business?['id'] as int? ?? json['business_id'] as int,
      businessName:
          business?['name'] as String? ?? json['business_name'] as String,
      locationId: location?['id'] as int? ?? json['location_id'] as int,
      locationName:
          location?['name'] as String? ?? json['location_name'] as String,
      locationAddress:
          location?['address'] as String? ??
          json['location_address'] as String?,
      locationCity:
          location?['city'] as String? ?? json['location_city'] as String?,
      serviceNames: _parseServiceNames(json),
      serviceIds: _parseServiceIds(json),
      staffId: json['staff_id'] as int?,
      staffName: json['staff_name'] as String?,
      startTime: DateTime.parse(json['start_time'] as String),
      endTime: DateTime.parse(json['end_time'] as String),
      totalPrice:
          (json['total_price'] as num?)?.toDouble() ??
          (json['price'] as num?)?.toDouble() ??
          0.0,
      notes: json['notes'] as String?,
      canModify: json['can_modify'] as bool? ?? false,
      canModifyUntil: json['can_modify_until'] != null
          ? DateTime.parse(json['can_modify_until'] as String)
          : null,
      canModifyUntilRaw: json['can_modify_until'] as String?,
      status: json['status'] as String? ?? 'confirmed',
    );
  }

  /// Parsa service_names supportando sia array che singolo valore
  static List<String> _parseServiceNames(Map<String, dynamic> json) {
    // Formato array: service_names: ["Taglio", "Piega"]
    if (json.containsKey('service_names') && json['service_names'] != null) {
      final names = json['service_names'];
      if (names is List) {
        return names.map((e) => e.toString()).toList();
      }
    }
    // Formato singolo: service_name: "Taglio + Piega"
    if (json.containsKey('service_name') && json['service_name'] != null) {
      return [json['service_name'] as String];
    }
    return [];
  }

  /// Parsa service_ids supportando sia array che singolo valore
  static List<int> _parseServiceIds(Map<String, dynamic> json) {
    if (json.containsKey('service_ids') && json['service_ids'] != null) {
      final ids = json['service_ids'];
      if (ids is List) {
        return ids.map((e) => e as int).toList();
      }
    }
    return [];
  }

  /// Stringa formattata dei servizi
  String get servicesDisplay => serviceNames.join(' + ');

  bool isPastAt(DateTime referenceNow) => endTime.isBefore(referenceNow);
  bool isUpcomingAt(DateTime referenceNow) => !isPastAt(referenceNow);
  bool get isCancelled => status == 'cancelled';

  bool get isModifiableStatus =>
      status != 'cancelled' &&
      status != 'completed' &&
      status != 'no_show' &&
      status != 'replaced';
  bool get canModifyEffective => canModify && isModifiableStatus;

  /// Crea copia con nuovi valori (per update locale dopo reschedule)
  BookingItem copyWith({
    DateTime? startTime,
    DateTime? endTime,
    String? notes,
    bool? canModify,
    DateTime? canModifyUntil,
    String? canModifyUntilRaw,
    String? status,
  }) {
    return BookingItem(
      id: id,
      businessId: businessId,
      businessName: businessName,
      locationId: locationId,
      locationName: locationName,
      locationAddress: locationAddress,
      locationCity: locationCity,
      serviceNames: serviceNames,
      serviceIds: serviceIds,
      staffId: staffId,
      staffName: staffName,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      totalPrice: totalPrice,
      notes: notes ?? this.notes,
      canModify: canModify ?? this.canModify,
      canModifyUntil: canModifyUntil ?? this.canModifyUntil,
      canModifyUntilRaw: canModifyUntilRaw ?? this.canModifyUntilRaw,
      status: status ?? this.status,
    );
  }
}
--- FILE: lib/core/models/service_package.dart ---
class ServicePackageItem {
  final int serviceId;
  final int sortOrder;
  final String? name;
  final int? durationMinutes;
  final double? price;
  final bool serviceIsActive;
  final bool variantIsActive;

  const ServicePackageItem({
    required this.serviceId,
    required this.sortOrder,
    this.name,
    this.durationMinutes,
    this.price,
    this.serviceIsActive = true,
    this.variantIsActive = true,
  });

  factory ServicePackageItem.fromJson(Map<String, dynamic> json) {
    return ServicePackageItem(
      serviceId: json['service_id'] as int,
      sortOrder: json['sort_order'] as int? ?? 0,
      name: json['name'] as String?,
      durationMinutes: json['duration_minutes'] as int?,
      price: (json['price'] as num?)?.toDouble(),
      serviceIsActive: json['service_is_active'] as bool? ?? true,
      variantIsActive: json['variant_is_active'] as bool? ?? true,
    );
  }
}

class ServicePackage {
  final int id;
  final int businessId;
  final int locationId;
  final int categoryId;
  final int sortOrder;
  final String name;
  final String? categoryName;
  final String? description;
  final double? overridePrice;
  final int? overrideDurationMinutes;
  final bool isActive;
  final bool isBookableOnline;
  final bool isBroken;
  final double effectivePrice;
  final int effectiveDurationMinutes;
  final List<ServicePackageItem> items;

  const ServicePackage({
    required this.id,
    required this.businessId,
    required this.locationId,
    required this.categoryId,
    required this.sortOrder,
    required this.name,
    this.categoryName,
    this.description,
    this.overridePrice,
    this.overrideDurationMinutes,
    this.isActive = true,
    this.isBookableOnline = true,
    this.isBroken = false,
    required this.effectivePrice,
    required this.effectiveDurationMinutes,
    required this.items,
  });

  List<int> get orderedServiceIds {
    final ordered = [...items]..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));
    return ordered.map((item) => item.serviceId).toList();
  }

  factory ServicePackage.fromJson(Map<String, dynamic> json) {
    final itemsJson = json['items'] as List<dynamic>? ?? const [];
    return ServicePackage(
      id: json['id'] as int,
      businessId: json['business_id'] as int,
      locationId: json['location_id'] as int,
      categoryId: json['category_id'] as int? ?? 0,
      sortOrder: json['sort_order'] as int? ?? 0,
      name: json['name'] as String,
      categoryName: json['category_name'] as String?,
      description: json['description'] as String?,
      overridePrice: (json['override_price'] as num?)?.toDouble(),
      overrideDurationMinutes: json['override_duration_minutes'] as int?,
      isActive: json['is_active'] as bool? ?? true,
      isBookableOnline: json['is_bookable_online'] as bool? ?? true,
      isBroken: json['is_broken'] as bool? ?? false,
      effectivePrice: (json['effective_price'] as num?)?.toDouble() ?? 0,
      effectiveDurationMinutes:
          json['effective_duration_minutes'] as int? ?? 0,
      items: itemsJson
          .map(
            (item) =>
                ServicePackageItem.fromJson(item as Map<String, dynamic>),
          )
          .toList(),
    );
  }
}

class ServicePackageExpansion {
  final int packageId;
  final int locationId;
  final List<int> serviceIds;
  final double effectivePrice;
  final int effectiveDurationMinutes;

  const ServicePackageExpansion({
    required this.packageId,
    required this.locationId,
    required this.serviceIds,
    required this.effectivePrice,
    required this.effectiveDurationMinutes,
  });

  factory ServicePackageExpansion.fromJson(Map<String, dynamic> json) {
    return ServicePackageExpansion(
      packageId: json['package_id'] as int,
      locationId: json['location_id'] as int,
      serviceIds:
          (json['service_ids'] as List<dynamic>? ?? const [])
              .map((id) => id as int)
              .toList(),
      effectivePrice: (json['effective_price'] as num?)?.toDouble() ?? 0,
      effectiveDurationMinutes:
          json['effective_duration_minutes'] as int? ?? 0,
    );
  }
}
--- FILE: lib/core/models/service.dart ---
/// Modello Servizio prenotabile online
class Service {
  final int id;
  final int businessId;
  final int? locationId;
  final int categoryId;
  final String name;
  final String? description;
  final int sortOrder;
  final int durationMinutes;
  final int processingTime;
  final int blockedTime;
  final double price;
  final bool isFree;
  final bool isPriceStartingFrom;
  final bool isBookableOnline;
  final bool isActive;

  const Service({
    required this.id,
    required this.businessId,
    this.locationId,
    required this.categoryId,
    required this.name,
    this.description,
    this.sortOrder = 0,
    required this.durationMinutes,
    this.processingTime = 0,
    this.blockedTime = 0,
    required this.price,
    this.isFree = false,
    this.isPriceStartingFrom = false,
    this.isBookableOnline = true,
    this.isActive = true,
  });

  /// Durata totale incluso tempo aggiuntivo (processing + blocked)
  int get totalDurationMinutes =>
      durationMinutes + processingTime + blockedTime;

  Service copyWith({
    int? id,
    int? businessId,
    int? locationId,
    int? categoryId,
    String? name,
    String? description,
    int? sortOrder,
    int? durationMinutes,
    int? processingTime,
    int? blockedTime,
    double? price,
    bool? isFree,
    bool? isPriceStartingFrom,
    bool? isBookableOnline,
    bool? isActive,
  }) => Service(
    id: id ?? this.id,
    businessId: businessId ?? this.businessId,
    locationId: locationId ?? this.locationId,
    categoryId: categoryId ?? this.categoryId,
    name: name ?? this.name,
    description: description ?? this.description,
    sortOrder: sortOrder ?? this.sortOrder,
    durationMinutes: durationMinutes ?? this.durationMinutes,
    processingTime: processingTime ?? this.processingTime,
    blockedTime: blockedTime ?? this.blockedTime,
    price: price ?? this.price,
    isFree: isFree ?? this.isFree,
    isPriceStartingFrom: isPriceStartingFrom ?? this.isPriceStartingFrom,
    isBookableOnline: isBookableOnline ?? this.isBookableOnline,
    isActive: isActive ?? this.isActive,
  );

  factory Service.fromJson(Map<String, dynamic> json) => Service(
    id: json['id'] as int,
    // API pu√≤ usare business_id o derivarlo dalla location
    businessId: json['business_id'] as int? ?? 0,
    locationId: json['location_id'] as int?,
    // category_id pu√≤ essere null per servizi non categorizzati
    categoryId: json['category_id'] as int? ?? 0,
    name: json['name'] as String,
    description: json['description'] as String?,
    sortOrder: json['sort_order'] as int? ?? 0,
    // API ritorna default_duration_minutes o duration_minutes
    durationMinutes:
        json['default_duration_minutes'] as int? ??
        json['duration_minutes'] as int? ??
        30,
    processingTime: json['processing_time'] as int? ?? 0,
    blockedTime: json['blocked_time'] as int? ?? 0,
    // API ritorna default_price o price
    price:
        (json['default_price'] as num?)?.toDouble() ??
        (json['price'] as num?)?.toDouble() ??
        0.0,
    isFree: json['is_free'] as bool? ?? false,
    isPriceStartingFrom: json['is_price_starting_from'] as bool? ?? false,
    isBookableOnline: _parseBookableOnline(json['is_bookable_online']),
    isActive: _parseIsActive(json['is_active']),
  );

  static bool _parseBookableOnline(dynamic value) {
    if (value is bool) return value;
    if (value is num) return value == 1;
    if (value is String) return value == '1' || value.toLowerCase() == 'true';
    return true;
  }

  static bool _parseIsActive(dynamic value) {
    if (value is bool) return value;
    if (value is num) return value == 1;
    if (value is String) return value == '1' || value.toLowerCase() == 'true';
    return true;
  }

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    if (locationId != null) 'location_id': locationId,
    'category_id': categoryId,
    'name': name,
    if (description != null) 'description': description,
    'sort_order': sortOrder,
    'duration_minutes': durationMinutes,
    'price': price,
    'is_free': isFree,
    'is_price_starting_from': isPriceStartingFrom,
    'is_bookable_online': isBookableOnline,
    'is_active': isActive,
  };

  String get formattedPrice {
    if (isFree) return 'Gratis';
    final priceStr = price.toStringAsFixed(2).replaceAll('.', ',');
    return isPriceStartingFrom ? 'da ‚Ç¨$priceStr' : '‚Ç¨$priceStr';
  }
}
--- FILE: lib/core/models/location.dart ---
import 'package:flutter/foundation.dart';

/// Modello Location (sede)
@immutable
class Location {
  final int id;
  final int businessId;
  final String name;
  final String? address;
  final String? city;
  final String? region;
  final String? country;
  final String? phone;
  final String? email;
  final double? latitude;
  final double? longitude;
  final String? currency;
  final String timezone;
  final bool allowCustomerChooseStaff;
  final int? cancellationHours;
  final bool isDefault;
  final int maxBookingAdvanceDays;
  final int onlineBookingSlotIntervalMinutes;

  const Location({
    required this.id,
    required this.businessId,
    required this.name,
    this.address,
    this.city,
    this.region,
    this.country,
    this.phone,
    this.email,
    this.latitude,
    this.longitude,
    this.currency,
    this.timezone = 'Europe/Rome',
    this.allowCustomerChooseStaff = false,
    this.cancellationHours,
    this.isDefault = false,
    this.maxBookingAdvanceDays = 90,
    this.onlineBookingSlotIntervalMinutes = 15,
  });

  factory Location.fromJson(Map<String, dynamic> json) {
    return Location(
      id: json['id'] as int,
      businessId: json['business_id'] as int,
      name: json['name'] as String,
      address: json['address'] as String?,
      city: json['city'] as String?,
      region: json['region'] as String?,
      country: json['country'] as String?,
      phone: json['phone'] as String?,
      email: json['email'] as String?,
      latitude: json['latitude'] != null
          ? (json['latitude'] as num).toDouble()
          : null,
      longitude: json['longitude'] != null
          ? (json['longitude'] as num).toDouble()
          : null,
      currency: json['currency'] as String?,
      timezone: json['timezone'] as String? ?? 'Europe/Rome',
      allowCustomerChooseStaff:
          json['allow_customer_choose_staff'] as bool? ?? false,
      cancellationHours: json['cancellation_hours'] as int?,
      isDefault: json['is_default'] as bool? ?? false,
      maxBookingAdvanceDays: json['max_booking_advance_days'] as int? ?? 90,
      onlineBookingSlotIntervalMinutes:
          json['online_booking_slot_interval_minutes'] as int? ?? 15,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'business_id': businessId,
      'name': name,
      'address': address,
      'city': city,
      'region': region,
      'country': country,
      'phone': phone,
      'email': email,
      'latitude': latitude,
      'longitude': longitude,
      'currency': currency,
      'timezone': timezone,
      'allow_customer_choose_staff': allowCustomerChooseStaff,
      if (cancellationHours != null) 'cancellation_hours': cancellationHours,
      'is_default': isDefault,
      'max_booking_advance_days': maxBookingAdvanceDays,
      'online_booking_slot_interval_minutes': onlineBookingSlotIntervalMinutes,
    };
  }

  /// Indirizzo formattato per visualizzazione
  String get formattedAddress {
    final parts = <String>[];
    if (address != null && address!.isNotEmpty) parts.add(address!);
    if (city != null && city!.isNotEmpty) parts.add(city!);
    return parts.join(', ');
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Location && runtimeType == other.runtimeType && id == other.id;

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() => 'Location(id: $id, name: $name, city: $city)';
}
--- FILE: lib/core/models/staff.dart ---
import '../utils/initials_utils.dart';

/// Modello Staff/Operatore
class Staff {
  final int id;
  final int businessId;
  final String name;
  final String surname;
  final String? avatarUrl;
  final int sortOrder;
  final bool isBookableOnline;
  final bool isActive;
  final List<int> serviceIds;

  const Staff({
    required this.id,
    required this.businessId,
    required this.name,
    required this.surname,
    this.avatarUrl,
    this.sortOrder = 0,
    this.isBookableOnline = true,
    this.isActive = true,
    this.serviceIds = const [],
  });

  String get displayName {
    if (surname.isEmpty) return name;
    return '$name $surname';
  }

  String get fullName => '${name.trim()} ${surname.trim()}'.trim();

  String get initials {
    return InitialsUtils.fromName(fullName, maxChars: 2);
  }

  Staff copyWith({
    int? id,
    int? businessId,
    String? name,
    String? surname,
    String? avatarUrl,
    int? sortOrder,
    bool? isBookableOnline,
    bool? isActive,
    List<int>? serviceIds,
  }) =>
      Staff(
        id: id ?? this.id,
        businessId: businessId ?? this.businessId,
        name: name ?? this.name,
        surname: surname ?? this.surname,
        avatarUrl: avatarUrl ?? this.avatarUrl,
        sortOrder: sortOrder ?? this.sortOrder,
        isBookableOnline: isBookableOnline ?? this.isBookableOnline,
        isActive: isActive ?? this.isActive,
        serviceIds: serviceIds ?? this.serviceIds,
      );

  factory Staff.fromJson(Map<String, dynamic> json) => Staff(
        id: json['id'] as int,
        businessId: json['business_id'] as int,
        name: json['name'] as String,
        surname: json['surname'] as String? ?? '',
        avatarUrl: json['avatar_url'] as String?,
        sortOrder: json['sort_order'] as int? ?? 0,
        isBookableOnline: json['is_bookable_online'] as bool? ?? true,
        isActive: json['is_active'] as bool? ?? true,
        serviceIds: (json['service_ids'] as List<dynamic>? ?? [])
            .map((e) => e is int ? e : int.tryParse(e.toString()) ?? 0)
            .where((id) => id > 0)
            .toList(),
      );

  Map<String, dynamic> toJson() => {
        'id': id,
        'business_id': businessId,
        'name': name,
        'surname': surname,
        if (avatarUrl != null) 'avatar_url': avatarUrl,
        'sort_order': sortOrder,
        'is_bookable_online': isBookableOnline,
        'is_active': isActive,
        'service_ids': serviceIds,
      };
}
--- FILE: lib/core/models/time_slot.dart ---
import '../services/tenant_time_service.dart';

/// Slot temporale disponibile per la prenotazione
class TimeSlot {
  final DateTime startTime;
  final DateTime endTime;
  final int? staffId;

  const TimeSlot({
    required this.startTime,
    required this.endTime,
    this.staffId,
  });

  int get durationMinutes => endTime.difference(startTime).inMinutes;

  String get formattedTime {
    final hour = startTime.hour.toString().padLeft(2, '0');
    final minute = startTime.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }

  TimeSlot copyWith({DateTime? startTime, DateTime? endTime, int? staffId}) =>
      TimeSlot(
        startTime: startTime ?? this.startTime,
        endTime: endTime ?? this.endTime,
        staffId: staffId ?? this.staffId,
      );

  factory TimeSlot.fromJson(Map<String, dynamic> json) {
    // Parse mantenendo l'orario originale (timezone del business)
    // DateTime.parse converte in UTC, quindi usiamo toLocal per evitare
    // confusione, MA il problema √® che toLocal usa il timezone del DISPOSITIVO.
    // La soluzione corretta √® estrarre l'orario "naive" ignorando il timezone.
    final startStr = json['start_time'] as String;
    final endStr = json['end_time'] as String;

    return TimeSlot(
      startTime: TenantTimeService.parseAsLocationTime(startStr),
      endTime: TenantTimeService.parseAsLocationTime(endStr),
      staffId: json['staff_id'] as int?,
    );
  }

  Map<String, dynamic> toJson() => {
    'start_time': startTime.toIso8601String(),
    'end_time': endTime.toIso8601String(),
    if (staffId != null) 'staff_id': staffId,
  };
}
--- FILE: lib/core/models/business.dart ---
import 'package:flutter/foundation.dart';

/// Modello Business
@immutable
class Business {
  final int id;
  final String name;
  final String slug;
  final String? email;
  final String? phone;
  final String timezone;
  final String currency;
  final int? cancellationHours;
  final int? defaultLocationId;

  const Business({
    required this.id,
    required this.name,
    required this.slug,
    this.email,
    this.phone,
    this.timezone = 'Europe/Rome',
    this.currency = 'EUR',
    this.cancellationHours,
    this.defaultLocationId,
  });

  factory Business.fromJson(Map<String, dynamic> json) {
    return Business(
      id: json['id'] as int,
      name: json['name'] as String,
      slug: json['slug'] as String,
      email: json['email'] as String?,
      phone: json['phone'] as String?,
      timezone: json['timezone'] as String? ?? 'Europe/Rome',
      currency: json['currency'] as String? ?? 'EUR',
      cancellationHours: json['cancellation_hours'] as int?,
      defaultLocationId: json['default_location_id'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'slug': slug,
      'email': email,
      'phone': phone,
      'timezone': timezone,
      'currency': currency,
      if (cancellationHours != null) 'cancellation_hours': cancellationHours,
      'default_location_id': defaultLocationId,
    };
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Business && runtimeType == other.runtimeType && id == other.id;

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() => 'Business(id: $id, name: $name, slug: $slug)';
}
--- FILE: lib/core/models/booking_request.dart ---
import 'service.dart';
import 'staff.dart';
import 'time_slot.dart';

/// Modello per la richiesta di prenotazione
class BookingRequest {
  final List<Service> services;
  final Set<int> selectedServiceIds;
  final Set<int> selectedPackageIds;
  final Map<int, List<int>> selectedPackageServiceIdsByPackage;
  final Staff? selectedStaff;
  final Map<int, Staff?> selectedStaffByService;
  final bool anyOperatorSelected;
  final TimeSlot? selectedSlot;
  final String? notes;

  const BookingRequest({
    this.services = const [],
    this.selectedServiceIds = const {},
    this.selectedPackageIds = const {},
    this.selectedPackageServiceIdsByPackage = const {},
    this.selectedStaff,
    this.selectedStaffByService = const {},
    this.anyOperatorSelected = false,
    this.selectedSlot,
    this.notes,
  });

  /// Durata totale in minuti
  int get totalDurationMinutes =>
      services.fold(0, (sum, s) => sum + s.durationMinutes);

  /// Prezzo totale
  double get totalPrice =>
      services.fold(0.0, (sum, s) => sum + (s.isFree ? 0 : s.price));

  /// Formatta il prezzo totale
  String get formattedTotalPrice {
    if (totalPrice == 0) return 'Gratis';
    return '‚Ç¨${totalPrice.toStringAsFixed(2).replaceAll('.', ',')}';
  }

  /// Verifica se la prenotazione √® completa
  bool get isComplete => services.isNotEmpty && selectedSlot != null;

  bool get hasStaffSelectionForAllServices {
    if (services.isEmpty) return false;
    if (anyOperatorSelected) return true;
    if (services.length > 1) {
      return services.every((s) => selectedStaffByService[s.id] != null);
    }
    if (selectedStaffByService.isNotEmpty) {
      return services.every((s) => selectedStaffByService[s.id] != null);
    }
    return selectedStaff != null;
  }

  bool get hasOnlyStaffSelectionForAllServices {
    if (services.isEmpty) return false;
    if (anyOperatorSelected) return false;
    if (services.length > 1) {
      return services.every((s) => selectedStaffByService[s.id] != null);
    }
    if (selectedStaffByService.isNotEmpty) {
      return services.every((s) => selectedStaffByService[s.id] != null);
    }
    return selectedStaff != null;
  }

  bool get allServicesAnyOperatorSelected {
    if (services.isEmpty) return false;
    if (services.length > 1) {
      return anyOperatorSelected;
    }
    if (selectedStaffByService.isNotEmpty) {
      return anyOperatorSelected;
    }
    return anyOperatorSelected || selectedStaff == null;
  }

  int? get singleStaffId {
    if (selectedStaffByService.isNotEmpty) {
      if (anyOperatorSelected) {
        return null;
      }
      final staffIds = selectedStaffByService.values
          .whereType<Staff>()
          .map((s) => s.id)
          .toSet();
      if (staffIds.length == 1 &&
          services.every((s) => selectedStaffByService[s.id] != null)) {
        return staffIds.first;
      }
      return null;
    }
    return selectedStaff?.id;
  }

  Staff? staffForService(int serviceId) {
    if (anyOperatorSelected) {
      return null;
    }
    if (selectedStaffByService.isNotEmpty) {
      return selectedStaffByService[serviceId];
    }
    return selectedStaff;
  }

  bool isAnyOperatorForService(int serviceId) => anyOperatorSelected;

  bool isServiceManuallySelected(int serviceId) =>
      selectedServiceIds.contains(serviceId);

  bool isPackageSelected(int packageId) => selectedPackageIds.contains(packageId);

  Set<int> get selectedPackageServiceIds =>
      selectedPackageServiceIdsByPackage.values
          .expand((ids) => ids)
          .toSet();

  BookingRequest copyWith({
    List<Service>? services,
    Set<int>? selectedServiceIds,
    Set<int>? selectedPackageIds,
    Map<int, List<int>>? selectedPackageServiceIdsByPackage,
    Staff? selectedStaff,
    Map<int, Staff?>? selectedStaffByService,
    bool? anyOperatorSelected,
    TimeSlot? selectedSlot,
    String? notes,
    bool clearStaff = false,
    bool clearStaffSelections = false,
    bool clearAnyOperatorSelections = false,
    bool clearSlot = false,
    bool clearNotes = false,
  }) => BookingRequest(
    services: services ?? this.services,
    selectedServiceIds: selectedServiceIds ?? this.selectedServiceIds,
    selectedPackageIds: selectedPackageIds ?? this.selectedPackageIds,
    selectedPackageServiceIdsByPackage:
        selectedPackageServiceIdsByPackage ??
        this.selectedPackageServiceIdsByPackage,
    selectedStaff: clearStaff ? null : (selectedStaff ?? this.selectedStaff),
    selectedStaffByService: clearStaffSelections
        ? {}
        : (selectedStaffByService ?? this.selectedStaffByService),
    anyOperatorSelected: clearAnyOperatorSelections
        ? false
        : (anyOperatorSelected ?? this.anyOperatorSelected),
    selectedSlot: clearSlot ? null : (selectedSlot ?? this.selectedSlot),
    notes: clearNotes ? null : (notes ?? this.notes),
  );

  Map<String, dynamic> toJson() => {
    'service_ids': services.map((s) => s.id).toList(),
    if (selectedStaff != null) 'staff_id': selectedStaff!.id,
    if (selectedSlot != null)
      'start_time': selectedSlot!.startTime.toIso8601String(),
    if (notes != null && notes!.isNotEmpty) 'notes': notes,
  };
}
--- FILE: lib/core/services/credentials_storage.dart ---
/// Gestione sicura delle credenziali salvate per accesso rapido.
/// - Web: usa localStorage (base64 encoded, non sicuro per dati sensibili in produzione reale)
/// - Mobile: usa flutter_secure_storage
abstract class CredentialsStorage {
  /// Recupera le credenziali salvate (email, password)
  Future<({String? email, String? password})> getSavedCredentials();

  /// Salva le credenziali per accesso rapido futuro
  Future<void> saveCredentials(String email, String password);

  /// Cancella le credenziali salvate
  Future<void> clearCredentials();

  /// Cancella solo la password (mantiene l'email)
  Future<void> clearPassword();

  /// Verifica se ci sono credenziali salvate
  Future<bool> hasCredentials();
}
--- FILE: lib/core/services/credentials_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'credentials_storage.dart';
import 'credentials_storage_stub.dart'
    if (dart.library.html) 'credentials_storage_web.dart'
    if (dart.library.io) 'credentials_storage_mobile.dart';

/// Provider per accedere al credentials storage
final credentialsStorageProvider = Provider<CredentialsStorage>((ref) {
  return createCredentialsStorage();
});

/// Provider per le credenziali salvate
final savedCredentialsProvider =
    FutureProvider<({String? email, String? password})>((ref) async {
      final storage = ref.watch(credentialsStorageProvider);
      return storage.getSavedCredentials();
    });
--- FILE: lib/core/services/credentials_storage_stub.dart ---
import 'credentials_storage.dart';

/// Stub per conditional import
CredentialsStorage createCredentialsStorage() => throw UnsupportedError(
  'Cannot create credentials storage without dart:html or flutter_secure_storage',
);
--- FILE: lib/core/services/version_checker.dart ---
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:http/http.dart' as http;

import 'version_checker_stub.dart'
    if (dart.library.html) 'version_checker_web.dart';

/// Service che controlla periodicamente se c'√® una nuova versione dell'app.
/// Se rileva un aggiornamento, forza il reload automatico della pagina.
///
/// Usa il file `app_version.txt` che contiene solo la stringa versione
/// (es. "20260129-1.6"). Questo file deve essere generato/aggiornato
/// manualmente durante il deploy.
class VersionChecker {
  static VersionChecker? _instance;
  static VersionChecker get instance => _instance ??= VersionChecker._();

  VersionChecker._();

  Timer? _timer;
  String? _currentVersion;
  bool _isChecking = false;

  /// Intervallo di controllo (default: 60 secondi)
  static const _checkInterval = Duration(seconds: 60);

  /// Avvia il controllo periodico della versione.
  /// Chiamare una sola volta all'avvio dell'app.
  void startPeriodicCheck() {
    // Solo su web
    if (!kIsWeb) return;

    // Evita avvii multipli
    if (_timer != null) return;

    debugPrint('VersionChecker: Starting periodic version check');

    // Primo check immediato per salvare la versione corrente
    _checkVersion();

    // Check periodico
    _timer = Timer.periodic(_checkInterval, (_) => _checkVersion());
  }

  /// Ferma il controllo periodico
  void stopPeriodicCheck() {
    _timer?.cancel();
    _timer = null;
  }

  Future<void> _checkVersion() async {
    if (_isChecking) return;
    _isChecking = true;

    try {
      // Fetch app_version.txt con cache-busting
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final response = await http
          .get(Uri.parse('/app_version.txt?_=$timestamp'))
          .timeout(const Duration(seconds: 10));

      if (response.statusCode == 200) {
        final serverVersion = response.body.trim();

        if (serverVersion.isNotEmpty) {
          if (_currentVersion == null) {
            // Prima esecuzione: salva la versione corrente
            _currentVersion = serverVersion;
            debugPrint('VersionChecker: Initial version: $_currentVersion');
          } else if (_currentVersion != serverVersion) {
            // Versione cambiata: forza reload
            debugPrint(
              'VersionChecker: New version detected! '
              '$_currentVersion -> $serverVersion. Reloading...',
            );
            forceReload();
          }
        }
      }
    } catch (e) {
      // Ignora errori di rete - riprover√† al prossimo ciclo
      debugPrint('VersionChecker: Check failed: $e');
    } finally {
      _isChecking = false;
    }
  }

  /// Forza il reload della pagina (solo web)
  void forceReload() {
    performHardReload();
  }
}
--- FILE: lib/core/services/version_checker_web.dart ---
// ignore: avoid_web_libraries_in_flutter
import 'dart:html' as html;

import 'package:flutter/foundation.dart';

/// Esegue un hard reload della pagina web (bypassa la cache)
void performHardReload() {
  // true = forza reload dal server, ignora cache
  html.window.location.reload();
  debugPrint('Performed hard reload of the page');
}
--- FILE: lib/core/services/credentials_storage_web.dart ---
// ignore_for_file: avoid_web_libraries_in_flutter
import 'dart:convert';
import 'dart:html' as html;

import 'package:flutter/foundation.dart';

import 'credentials_storage.dart';

/// Implementazione Web che usa localStorage con encoding base64.
/// NOTA: Non √® una soluzione sicura al 100% ma offre una protezione
/// minima contro lettura casuale. Il browser comunque protegge
/// localStorage per dominio (same-origin policy).
class WebCredentialsStorage implements CredentialsStorage {
  static const _emailKey = 'agenda_frontend_saved_email';
  static const _passwordKey = 'agenda_frontend_saved_password';

  @override
  Future<({String? email, String? password})> getSavedCredentials() async {
    try {
      final encodedEmail = html.window.localStorage[_emailKey];
      final encodedPassword = html.window.localStorage[_passwordKey];

      if (encodedEmail == null || encodedPassword == null) {
        return (email: null, password: null);
      }

      final email = utf8.decode(base64Decode(encodedEmail));
      final password = utf8.decode(base64Decode(encodedPassword));

      return (email: email, password: password);
    } catch (e) {
      debugPrint('CredentialsStorage: Error reading credentials: $e');
      return (email: null, password: null);
    }
  }

  @override
  Future<void> saveCredentials(String email, String password) async {
    try {
      final encodedEmail = base64Encode(utf8.encode(email));
      final encodedPassword = base64Encode(utf8.encode(password));

      html.window.localStorage[_emailKey] = encodedEmail;
      html.window.localStorage[_passwordKey] = encodedPassword;
    } catch (e) {
      debugPrint('CredentialsStorage: Error saving credentials: $e');
    }
  }

  @override
  Future<void> clearCredentials() async {
    try {
      html.window.localStorage.remove(_emailKey);
      html.window.localStorage.remove(_passwordKey);
    } catch (e) {
      debugPrint('CredentialsStorage: Error clearing credentials: $e');
    }
  }

  @override
  Future<void> clearPassword() async {
    try {
      html.window.localStorage.remove(_passwordKey);
    } catch (e) {
      debugPrint('CredentialsStorage: Error clearing password: $e');
    }
  }

  @override
  Future<bool> hasCredentials() async {
    try {
      return html.window.localStorage[_emailKey] != null &&
          html.window.localStorage[_passwordKey] != null;
    } catch (e) {
      return false;
    }
  }
}

/// Factory per creare storage su Web
CredentialsStorage createCredentialsStorage() => WebCredentialsStorage();
--- FILE: lib/core/services/credentials_storage_mobile.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

import 'credentials_storage.dart';

/// Implementazione secure storage per mobile/desktop.
/// Usa flutter_secure_storage per salvare in modo sicuro le credenziali.
class SecureCredentialsStorage implements CredentialsStorage {
  static const _emailKey = 'agenda_frontend_saved_email';
  static const _passwordKey = 'agenda_frontend_saved_password';

  final FlutterSecureStorage _storage;

  SecureCredentialsStorage()
    : _storage = const FlutterSecureStorage(
        aOptions: AndroidOptions(encryptedSharedPreferences: true),
        iOptions: IOSOptions(accessibility: KeychainAccessibility.first_unlock),
      );

  @override
  Future<({String? email, String? password})> getSavedCredentials() async {
    try {
      final email = await _storage.read(key: _emailKey);
      final password = await _storage.read(key: _passwordKey);

      return (email: email, password: password);
    } catch (e) {
      debugPrint('CredentialsStorage: Error reading credentials: $e');
      return (email: null, password: null);
    }
  }

  @override
  Future<void> saveCredentials(String email, String password) async {
    try {
      await _storage.write(key: _emailKey, value: email);
      await _storage.write(key: _passwordKey, value: password);
    } catch (e) {
      debugPrint('CredentialsStorage: Error saving credentials: $e');
    }
  }

  @override
  Future<void> clearCredentials() async {
    try {
      await _storage.delete(key: _emailKey);
      await _storage.delete(key: _passwordKey);
    } catch (e) {
      debugPrint('CredentialsStorage: Error clearing credentials: $e');
    }
  }

  @override
  Future<void> clearPassword() async {
    try {
      await _storage.delete(key: _passwordKey);
    } catch (e) {
      debugPrint('CredentialsStorage: Error clearing password: $e');
    }
  }

  @override
  Future<bool> hasCredentials() async {
    try {
      final email = await _storage.read(key: _emailKey);
      final password = await _storage.read(key: _passwordKey);
      return email != null && password != null;
    } catch (e) {
      return false;
    }
  }
}

/// Factory per creare storage su mobile/desktop
CredentialsStorage createCredentialsStorage() => SecureCredentialsStorage();
--- FILE: lib/core/services/pending_booking_storage.dart ---
import 'dart:convert';

import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../models/booking_request.dart';
import '../models/location.dart';
import '../models/service.dart';
import '../models/staff.dart';
import '../models/time_slot.dart';

/// Dati della prenotazione in sospeso
class PendingBookingData {
  final int businessId;
  final int locationId;
  final Location? selectedLocation;
  final List<Service> services;
  final Map<int, Staff?> staffByService;
  final Staff? selectedStaff;
  final bool anyOperatorSelected;
  final TimeSlot? selectedSlot;
  final String? notes;
  final DateTime savedAt;

  const PendingBookingData({
    required this.businessId,
    required this.locationId,
    this.selectedLocation,
    required this.services,
    required this.staffByService,
    this.selectedStaff,
    required this.anyOperatorSelected,
    this.selectedSlot,
    this.notes,
    required this.savedAt,
  });

  /// Verifica se i dati sono ancora validi (non troppo vecchi)
  bool get isValid {
    // Valido per 1 ora
    final expiry = savedAt.add(const Duration(hours: 1));
    return DateTime.now().isBefore(expiry);
  }

  Map<String, dynamic> toJson() => {
    'businessId': businessId,
    'locationId': locationId,
    'selectedLocation': selectedLocation?.toJson(),
    'services': services.map((s) => s.toJson()).toList(),
    'staffByService': staffByService.map(
      (k, v) => MapEntry(k.toString(), v?.toJson()),
    ),
    'selectedStaff': selectedStaff?.toJson(),
    'anyOperatorSelected': anyOperatorSelected,
    'selectedSlot': selectedSlot?.toJson(),
    'notes': notes,
    'savedAt': savedAt.toIso8601String(),
  };

  factory PendingBookingData.fromJson(Map<String, dynamic> json) {
    return PendingBookingData(
      businessId: json['businessId'] as int,
      locationId: json['locationId'] as int,
      selectedLocation: json['selectedLocation'] != null
          ? Location.fromJson(json['selectedLocation'] as Map<String, dynamic>)
          : null,
      services: (json['services'] as List)
          .map((s) => Service.fromJson(s as Map<String, dynamic>))
          .toList(),
      staffByService: (json['staffByService'] as Map<String, dynamic>).map(
        (k, v) => MapEntry(
          int.parse(k),
          v != null ? Staff.fromJson(v as Map<String, dynamic>) : null,
        ),
      ),
      selectedStaff: json['selectedStaff'] != null
          ? Staff.fromJson(json['selectedStaff'] as Map<String, dynamic>)
          : null,
      anyOperatorSelected: json['anyOperatorSelected'] as bool? ?? false,
      selectedSlot: json['selectedSlot'] != null
          ? TimeSlot.fromJson(json['selectedSlot'] as Map<String, dynamic>)
          : null,
      notes: json['notes'] as String?,
      savedAt: DateTime.parse(json['savedAt'] as String),
    );
  }

  /// Crea da BookingRequest
  factory PendingBookingData.fromBookingRequest({
    required int businessId,
    required int locationId,
    required Location? selectedLocation,
    required BookingRequest request,
  }) {
    return PendingBookingData(
      businessId: businessId,
      locationId: locationId,
      selectedLocation: selectedLocation,
      services: request.services,
      staffByService: request.selectedStaffByService,
      selectedStaff: request.selectedStaff,
      anyOperatorSelected: request.anyOperatorSelected,
      selectedSlot: request.selectedSlot,
      notes: request.notes,
      savedAt: DateTime.now(),
    );
  }

  /// Converte in BookingRequest
  BookingRequest toBookingRequest() {
    return BookingRequest(
      services: services,
      selectedStaffByService: staffByService,
      selectedStaff: selectedStaff,
      anyOperatorSelected: anyOperatorSelected,
      selectedSlot: selectedSlot,
      notes: notes,
    );
  }
}

/// Servizio per salvare/ripristinare lo stato della prenotazione.
/// Usato quando il token scade durante la conferma.
/// Usa SharedPreferences per compatibilit√† cross-platform.
class PendingBookingStorage {
  static const _storageKey = 'pending_booking_state';

  /// Salva lo stato della prenotazione
  static Future<void> save(PendingBookingData data) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final json = data.toJson();
      final encoded = jsonEncode(json);
      await prefs.setString(_storageKey, encoded);
    } catch (e) {
      debugPrint('PendingBookingStorage.save error: $e');
    }
  }

  /// Recupera lo stato salvato (se esiste e valido)
  static Future<PendingBookingData?> load() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final encoded = prefs.getString(_storageKey);
      if (encoded == null || encoded.isEmpty) return null;

      final json = jsonDecode(encoded) as Map<String, dynamic>;
      final data = PendingBookingData.fromJson(json);

      // Verifica se ancora valido
      if (!data.isValid) {
        await clear();
        return null;
      }

      return data;
    } catch (e) {
      debugPrint('PendingBookingStorage.load error: $e');
      await clear();
      return null;
    }
  }

  /// Elimina lo stato salvato
  static Future<void> clear() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      await prefs.remove(_storageKey);
    } catch (e) {
      // Ignora errori
    }
  }

  /// Verifica se c'√® uno stato salvato
  static Future<bool> hasPendingBooking() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final encoded = prefs.getString(_storageKey);
      if (encoded == null || encoded.isEmpty) return false;

      // Verifica anche validit√†
      final json = jsonDecode(encoded) as Map<String, dynamic>;
      final savedAt = DateTime.parse(json['savedAt'] as String);
      final expiry = savedAt.add(const Duration(hours: 1));
      return DateTime.now().isBefore(expiry);
    } catch (e) {
      return false;
    }
  }
}
--- FILE: lib/core/services/version_checker_stub.dart ---
/// Stub per piattaforme non-web
void performHardReload() {
  // No-op su piattaforme native
}
--- FILE: lib/core/services/tenant_time_service.dart ---
import 'package:timezone/timezone.dart' as tz;

class TenantTimeService {
  TenantTimeService._();

  static const String defaultTimezone = 'Europe/Rome';

  static final Map<String, tz.Location> _locationCache =
      <String, tz.Location>{};

  static String normalizeTimezone(String? timezone) {
    final trimmed = timezone?.trim();
    if (trimmed == null || trimmed.isEmpty) {
      return defaultTimezone;
    }
    try {
      tz.getLocation(trimmed);
      return trimmed;
    } catch (_) {
      return defaultTimezone;
    }
  }

  static tz.Location locationFor(String? timezone) {
    final normalized = normalizeTimezone(timezone);
    return _locationCache.putIfAbsent(
      normalized,
      () => tz.getLocation(normalized),
    );
  }

  static DateTime nowInTimezone(String? timezone) {
    return tz.TZDateTime.now(locationFor(timezone));
  }

  static DateTime todayInTimezone(String? timezone) {
    final now = nowInTimezone(timezone);
    return DateTime(now.year, now.month, now.day);
  }

  static DateTime fromUtcToTenant(DateTime value, String? timezone) {
    return tz.TZDateTime.from(value.toUtc(), locationFor(timezone));
  }

  static DateTime parseAsLocationTime(String isoString) {
    final withoutOffset = isoString.replaceAll(RegExp(r'[+-]\d{2}:\d{2}$'), '');
    final cleaned = withoutOffset.replaceAll('Z', '');
    return DateTime.parse(cleaned);
  }
}
--- FILE: lib/core/widgets/app_bottom_sheet.dart ---
import 'dart:math' as math;

import 'package:flutter/material.dart';

/// Helper to show a modal bottom sheet with the app's default styling.
class AppBottomSheet {
  AppBottomSheet._();

  /// Altezza predefinita di tutti i bottom sheet (80% dello schermo).
  static const double defaultHeightFactor = 0.95;

  static Future<T?> show<T>({
    required BuildContext context,
    required WidgetBuilder builder,
    bool isScrollControlled = true,
    bool useSafeArea = true,
    bool useRootNavigator = true,
    EdgeInsetsGeometry? padding,

    /// Fraction of screen height (0.0 to 1.0). If provided, the bottom sheet
    /// will have a minimum height of this fraction of the screen.
    double? heightFactor = defaultHeightFactor,
  }) {
    final effectivePadding =
        padding ?? const EdgeInsets.symmetric(horizontal: 20, vertical: 16);
    return showModalBottomSheet<T>(
      context: context,
      isScrollControlled: isScrollControlled,
      backgroundColor: Colors.white,
      useSafeArea: useSafeArea,
      useRootNavigator: useRootNavigator,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (ctx) => AppBottomSheetContainer(
        padding: effectivePadding,
        heightFactor: heightFactor,
        child: builder(ctx),
      ),
    );
  }
}

/// Provides consistent padding, animation and handle for bottom sheet content.
class AppBottomSheetContainer extends StatelessWidget {
  const AppBottomSheetContainer({
    super.key,
    required this.child,
    this.padding = const EdgeInsets.symmetric(horizontal: 20, vertical: 16),
    this.showHandle = true,
    this.heightFactor,
  });

  final Widget child;
  final EdgeInsetsGeometry padding;
  final bool showHandle;

  /// If provided, the container will have a minimum height of this fraction
  /// of the screen height (0.0 to 1.0).
  final double? heightFactor;

  @override
  Widget build(BuildContext context) {
    final keyboardInset = MediaQuery.of(context).viewInsets.bottom;
    Widget content;

    // Apply height constraint if heightFactor is provided
    // Use SizedBox (not ConstrainedBox) to provide a finite height
    // so that Expanded children inside Column can work properly
    if (heightFactor != null) {
      // Ensure bottom padding is at least 50.0 to leave space above
      // system UI / controls and provide consistent spacing across sheets.
      final resolved = padding.resolve(Directionality.of(context));
      final effectivePadding = resolved.copyWith(
        bottom: math.max(resolved.bottom, 50.0),
      );
      final screenHeight = MediaQuery.of(context).size.height;
      final height = screenHeight * heightFactor!;
      content = SizedBox(
        height: height,
        child: Padding(padding: effectivePadding, child: child),
      );
    } else {
      // Quando heightFactor √® null, il contenuto si adatta all'altezza naturale
      // Usa solo il padding fornito senza forzare altezza minima
      content = Padding(padding: padding, child: child);
    }

    final body = showHandle
        ? Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const SizedBox(height: 8),
              Center(
                child: Container(
                  width: 40,
                  height: 4,
                  decoration: BoxDecoration(
                    color: Colors.grey.shade300,
                    borderRadius: BorderRadius.circular(4),
                  ),
                ),
              ),
              const SizedBox(height: 12),
              // Flexible permette al contenuto di adattarsi senza forzare
              // l'altezza massima della bottom sheet.
              Flexible(child: content),
            ],
          )
        : content;

    return AnimatedPadding(
      padding: EdgeInsets.only(bottom: keyboardInset),
      duration: const Duration(milliseconds: 180),
      curve: Curves.easeOut,
      child: body,
    );
  }
}
--- FILE: lib/core/widgets/feedback_dialog.dart ---
import 'package:flutter/material.dart';

/// Dialog per mostrare messaggi di feedback all'utente (successo/errore).
/// Sostituisce le SnackBar per un'esperienza pi√π consistente.
class FeedbackDialog extends StatelessWidget {
  const FeedbackDialog({
    super.key,
    required this.title,
    required this.message,
    required this.isSuccess,
    this.actionLabel,
    this.onAction,
  });

  final String title;
  final String message;
  final bool isSuccess;
  final String? actionLabel;
  final VoidCallback? onAction;

  /// Mostra un dialog di successo
  static Future<void> showSuccess(
    BuildContext context, {
    required String title,
    required String message,
    String? actionLabel,
    VoidCallback? onAction,
  }) {
    return showDialog(
      context: context,
      builder: (ctx) => FeedbackDialog(
        title: title,
        message: message,
        isSuccess: true,
        actionLabel: actionLabel,
        onAction: onAction,
      ),
    );
  }

  /// Mostra un dialog di errore
  static Future<void> showError(
    BuildContext context, {
    required String title,
    required String message,
    String? actionLabel,
    VoidCallback? onAction,
  }) {
    return showDialog(
      context: context,
      builder: (ctx) => FeedbackDialog(
        title: title,
        message: message,
        isSuccess: false,
        actionLabel: actionLabel,
        onAction: onAction,
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final color = isSuccess
        ? theme.colorScheme.primary
        : theme.colorScheme.error;

    return AlertDialog(
      icon: Icon(
        isSuccess ? Icons.check_circle : Icons.error,
        color: color,
        size: 48,
      ),
      title: Text(title, textAlign: TextAlign.center),
      content: Text(message, textAlign: TextAlign.center),
      actionsAlignment: MainAxisAlignment.center,
      actions: [
        if (actionLabel != null && onAction != null)
          TextButton(
            onPressed: () {
              Navigator.of(context).pop();
              onAction!();
            },
            child: Text(actionLabel!),
          ),
        FilledButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('OK'),
        ),
      ],
    );
  }
}
--- FILE: lib/core/widgets/booking_app_bar.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../app/providers/route_slug_provider.dart';
import '../../features/auth/providers/auth_provider.dart';
import '../../features/booking/providers/business_provider.dart';
import '../l10n/l10_extension.dart';
import '../utils/initials_utils.dart';

/// AppBar professionale per il sistema di prenotazione.
///
/// Caratteristiche:
/// - Mostra nome business centrato
/// - Design minimal e professionale
/// - Menu utente integrato per utenti autenticati
/// - Supporta back button quando necessario
class BookingAppBar extends ConsumerWidget implements PreferredSizeWidget {
  const BookingAppBar({
    super.key,
    this.showBackButton = false,
    this.onBackPressed,
    this.backIcon,
    this.backTooltip,
    this.showUserMenu = true,
    this.bottom,
    this.title,
  });

  /// Se mostrare il pulsante back
  final bool showBackButton;

  /// Callback per il back button (se null, usa Navigator.pop)
  final VoidCallback? onBackPressed;

  /// Icona personalizzata per il back button (default: arrow_back_ios_new)
  final IconData? backIcon;

  /// Tooltip personalizzato per il back button
  final String? backTooltip;

  /// Se mostrare il menu utente per utenti autenticati
  final bool showUserMenu;

  /// Widget opzionale da mostrare sotto l'AppBar (es. TabBar)
  final PreferredSizeWidget? bottom;

  final String? title;
  @override
  Size get preferredSize =>
      Size.fromHeight(kToolbarHeight + (bottom?.preferredSize.height ?? 0));

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final businessAsync = ref.watch(currentBusinessProvider);
    final isAuthenticated = ref.watch(
      authProvider.select((state) => state.isAuthenticated),
    );
    final slug = ref.watch(routeSlugProvider);
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    // Nome business o placeholder
    final businessName = businessAsync.value?.name ?? '';

    return AppBar(
      backgroundColor: colorScheme.surface,
      surfaceTintColor: Colors.transparent,
      elevation: 0,
      scrolledUnderElevation: 0.5,
      centerTitle: true,
      // Leading: back button o niente
      leading: showBackButton
          ? IconButton(
              icon: Icon(
                backIcon ?? Icons.arrow_back_ios_new,
                size: 20,
                color: colorScheme.primary,
              ),
              onPressed: onBackPressed ?? () => Navigator.of(context).pop(),
              tooltip:
                  backTooltip ??
                  MaterialLocalizations.of(context).backButtonTooltip,
            )
          : null,
      // Title: nome business con stile
      title: title != null || businessName.isNotEmpty
          ? Text(
              title ?? businessName,
              style: theme.textTheme.titleLarge?.copyWith(
                fontWeight: FontWeight.w600,
                letterSpacing: -0.3,
                color: colorScheme.onSurface,
              ),
            )
          : null,
      // Actions: menu utente
      actions: [
        if (showUserMenu && isAuthenticated && slug != null)
          _UserMenuButton(slug: slug),
        const SizedBox(width: 12),
      ],
      bottom: bottom,
    );
  }
}

/// Menu utente con avatar iniziali
class _UserMenuButton extends ConsumerWidget {
  const _UserMenuButton({required this.slug});

  final String slug;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final user = ref.watch(authProvider.select((s) => s.user));

    // Iniziali per avatar
    final initials = _getInitials(user?.firstName, user?.lastName);

    return PopupMenuButton<String>(
      offset: const Offset(0, 48),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      position: PopupMenuPosition.under,
      tooltip: l10n.profileTitle,
      onSelected: (value) async {
        switch (value) {
          case 'bookings':
            context.push('/$slug/my-bookings');
          case 'profile':
            context.push('/$slug/profile');
          case 'change-password':
            context.push('/$slug/change-password');
          case 'logout':
            final businessId = ref.read(currentBusinessIdProvider);
            if (businessId != null) {
              await ref
                  .read(authProvider.notifier)
                  .logout(businessId: businessId);
            }
            if (context.mounted) {
              context.go('/$slug/login');
            }
        }
      },
      itemBuilder: (context) => [
        // Header con nome utente
        PopupMenuItem<String>(
          enabled: false,
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                '${user?.firstName ?? ''} ${user?.lastName ?? ''}'.trim(),
                style: theme.textTheme.titleSmall?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
              ),
              if (user?.email != null)
                Text(
                  user!.email,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: colorScheme.onSurface.withOpacity(0.6),
                  ),
                ),
            ],
          ),
        ),
        const PopupMenuDivider(),
        PopupMenuItem<String>(
          value: 'bookings',
          child: _MenuItemContent(
            icon: Icons.calendar_today_outlined,
            label: l10n.myBookings,
          ),
        ),
        PopupMenuItem<String>(
          value: 'profile',
          child: _MenuItemContent(
            icon: Icons.person_outline,
            label: l10n.profileTitle,
          ),
        ),
        PopupMenuItem<String>(
          value: 'change-password',
          child: _MenuItemContent(
            icon: Icons.lock_outline,
            label: l10n.authChangePassword,
          ),
        ),
        const PopupMenuDivider(),
        PopupMenuItem<String>(
          value: 'logout',
          child: _MenuItemContent(
            icon: Icons.logout,
            label: l10n.actionLogout,
            isDestructive: true,
          ),
        ),
      ],
      padding: EdgeInsets.zero,
      splashRadius: 24,
      icon: Container(
        width: 36,
        height: 36,
        decoration: BoxDecoration(
          color: colorScheme.primary.withOpacity(0.1),
          shape: BoxShape.circle,
        ),
        child: Center(
          child: Text(
            initials,
            style: theme.textTheme.labelMedium?.copyWith(
              color: colorScheme.primary,
              fontWeight: FontWeight.w600,
            ),
          ),
        ),
      ),
    );
  }

  String _getInitials(String? firstName, String? lastName) {
    final fullName = '${firstName ?? ''} ${lastName ?? ''}'.trim();
    final initials = InitialsUtils.fromName(fullName, maxChars: 2);
    return initials.isNotEmpty ? initials : '?';
  }
}

/// Contenuto riga menu
class _MenuItemContent extends StatelessWidget {
  const _MenuItemContent({
    required this.icon,
    required this.label,
    this.isDestructive = false,
  });

  final IconData icon;
  final String label;
  final bool isDestructive;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final iconColor = isDestructive ? colorScheme.error : colorScheme.primary;
    final textColor = isDestructive ? colorScheme.error : colorScheme.onSurface;

    return Row(
      children: [
        Icon(icon, size: 20, color: iconColor),
        const SizedBox(width: 12),
        Text(label, style: TextStyle(color: textColor)),
      ],
    );
  }
}

/// AppBar semplice per le schermate secondarie (login, registrazione, ecc.)
class SimpleAppBar extends StatelessWidget implements PreferredSizeWidget {
  const SimpleAppBar({
    super.key,
    required this.title,
    this.showBackButton = true,
    this.onBackPressed,
    this.actions,
  });

  final String title;
  final bool showBackButton;
  final VoidCallback? onBackPressed;
  final List<Widget>? actions;

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return AppBar(
      backgroundColor: colorScheme.surface,
      surfaceTintColor: Colors.transparent,
      elevation: 0,
      scrolledUnderElevation: 0.5,
      centerTitle: true,
      leading: showBackButton
          ? IconButton(
              icon: Icon(
                Icons.arrow_back_ios_new,
                size: 20,
                color: colorScheme.primary,
              ),
              onPressed: onBackPressed ?? () => Navigator.of(context).pop(),
            )
          : null,
      title: Text(
        title,
        style: theme.textTheme.titleLarge?.copyWith(
          fontWeight: FontWeight.w600,
          letterSpacing: -0.3,
          color: colorScheme.onSurface,
        ),
      ),
      actions: actions,
    );
  }
}
--- FILE: lib/core/widgets/centered_error_view.dart ---
import 'package:flutter/material.dart';

class CenteredErrorView extends StatelessWidget {
  const CenteredErrorView({
    super.key,
    required this.title,
    this.subtitle,
    this.icon = Icons.error_outline,
    this.onRetry,
    this.retryLabel,
  });

  final String title;
  final String? subtitle;
  final IconData icon;
  final VoidCallback? onRetry;
  final String? retryLabel;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return SizedBox.expand(
      child: Center(
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(icon, size: 64, color: colorScheme.error.withOpacity(0.6)),
              const SizedBox(height: 16),
              Text(
                title,
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
                textAlign: TextAlign.center,
              ),
              if (subtitle != null && subtitle!.isNotEmpty) ...[
                const SizedBox(height: 8),
                Text(
                  subtitle!,
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: colorScheme.onSurface.withOpacity(0.7),
                  ),
                  textAlign: TextAlign.center,
                ),
              ],
              if (onRetry != null) ...[
                const SizedBox(height: 24),
                OutlinedButton.icon(
                  onPressed: onRetry,
                  icon: const Icon(Icons.refresh),
                  label: Text(retryLabel ?? 'Riprova'),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/core/widgets/app_loading_screen.dart ---
import 'package:flutter/material.dart';

import '../l10n/l10_extension.dart';

/// Loading screen identico a quello in index.html per transizione seamless.
/// Usato durante il caricamento iniziale dell'app.
class AppLoadingScreen extends StatelessWidget {
  const AppLoadingScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: const BoxDecoration(
        gradient: LinearGradient(
          begin: Alignment.topLeft,
          end: Alignment.bottomRight,
          colors: [
            Color(0xFFF5F7FA), // #f5f7fa
            Color(0xFFE4E8EC), // #e4e8ec
          ],
        ),
      ),
      child: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const _LoadingSpinner(),
            const SizedBox(height: 20),
            Text(
              context.l10n.loadingGeneric,
              style: const TextStyle(
                fontSize: 16,
                color: Color(0xFF666666),
                letterSpacing: 0.5,
                fontFamily: null, // usa system font
                decoration: TextDecoration.none,
                fontWeight: FontWeight.normal,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class _LoadingSpinner extends StatefulWidget {
  const _LoadingSpinner();

  @override
  State<_LoadingSpinner> createState() => _LoadingSpinnerState();
}

class _LoadingSpinnerState extends State<_LoadingSpinner>
    with SingleTickerProviderStateMixin {
  late final AnimationController _controller;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 1),
    )..repeat();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _controller,
      builder: (context, child) {
        return Transform.rotate(
          angle: _controller.value * 2 * 3.14159,
          child: child,
        );
      },
      child: Container(
        width: 48,
        height: 48,
        decoration: BoxDecoration(
          shape: BoxShape.circle,
          border: Border.all(color: const Color(0xFFE0E0E0), width: 4),
        ),
        child: const CustomPaint(painter: _SpinnerPainter()),
      ),
    );
  }
}

class _SpinnerPainter extends CustomPainter {
  const _SpinnerPainter();

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color =
          const Color(0xFF2196F3) // Blu accent
      ..strokeWidth = 4
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round;

    final rect = Rect.fromLTWH(0, 0, size.width, size.height);
    // Arco di 90 gradi in alto
    canvas.drawArc(rect, -1.5708, 1.5708, false, paint);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => false;
}
--- FILE: lib/app/router.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../core/l10n/l10_extension.dart';
import '../features/auth/domain/auth_state.dart';
import '../features/auth/presentation/change_password_screen.dart';
import '../features/auth/presentation/login_screen.dart';
import '../features/auth/presentation/profile_screen.dart';
import '../features/auth/presentation/register_screen.dart';
import '../features/auth/presentation/reset_password_screen.dart';
import '../features/auth/presentation/web_login_redirect_screen.dart';
import '../features/auth/providers/auth_provider.dart';
import '../features/booking/presentation/screens/booking_screen.dart';
import '../features/booking/presentation/screens/my_bookings_screen.dart';
import '../features/booking/providers/locations_provider.dart';
import 'providers/route_slug_provider.dart';

/// Router provider con supporto path-based multi-business
///
/// Struttura URL:
/// - /                      ‚Üí Landing page (business non specificato)
/// - /:slug                 ‚Üí Redirect a /:slug/booking
/// - /:slug/booking         ‚Üí Schermata prenotazione
/// - /:slug/login           ‚Üí Login
/// - /:slug/register        ‚Üí Registrazione
/// - /:slug/my-bookings     ‚Üí Le mie prenotazioni
/// - /reset-password/:token ‚Üí Reset password (globale, no slug)
final routerProvider = Provider<GoRouter>((ref) {
  // NOTA: usa ref.read per evitare rebuild del router quando auth cambia
  // Il redirect legge sempre lo stato auth corrente senza causare loop

  // Listenable che triggera refresh del router quando auth cambia
  final authRefreshListenable = _AuthRefreshNotifier(ref);

  return GoRouter(
    initialLocation: '/',
    refreshListenable: authRefreshListenable,
    redirect: (context, state) {
      // Legge auth con ref.read (non ref.watch) per evitare loop
      final authState = ref.read(authProvider);
      final isAuthenticated = authState.isAuthenticated;

      // Se auth √® ancora in loading/initial, non fare redirect auth
      // Il refreshListenable triggherer√† un nuovo check quando l'auth √® pronto
      final authReady =
          authState.status != AuthStatus.initial &&
          authState.status != AuthStatus.loading;

      // Filtra segmenti vuoti (trailing slash produce ['slug', ''])
      final pathSegments = state.uri.pathSegments
          .where((s) => s.isNotEmpty)
          .toList();

      // Estrae lo slug dal path (primo segmento se non √® una route riservata)
      String? slug;
      if (pathSegments.isNotEmpty) {
        final firstSegment = pathSegments.first;
        if (!_reservedPaths.contains(firstSegment)) {
          slug = firstSegment;
        }
      }

      // Estrae location ID dal query param (?location=4)
      final locationParam = state.uri.queryParameters['location'];
      final urlLocationId = locationParam != null
          ? int.tryParse(locationParam)
          : null;

      // Aggiorna i provider con slug e location correnti
      // Usiamo Future.microtask per evitare modifiche durante il build
      Future.microtask(() {
        ref.read(routeSlugProvider.notifier).state = slug;
        ref.read(urlLocationIdProvider.notifier).state = urlLocationId;
      });

      // Se siamo su /:slug senza sotto-path, redirect a /:slug/booking (mantieni query params)
      if (slug != null && pathSegments.length == 1) {
        final query = state.uri.query.isNotEmpty ? '?${state.uri.query}' : '';
        return '/$slug/booking$query';
      }

      // Auth redirect logic per route con slug
      if (slug != null) {
        final subPath = pathSegments.length > 1 ? pathSegments[1] : '';

        // Route protette che richiedono autenticazione
        const protectedRoutes = {
          'booking',
          'my-bookings',
          'profile',
          'change-password',
        };

        // Se non autenticato e cerca di accedere a route protetta, redirect a login
        // Ma solo se auth √® ready! Altrimenti aspettiamo che il session restore completi
        if (authReady &&
            !isAuthenticated &&
            protectedRoutes.contains(subPath)) {
          return '/$slug/login?from=$subPath';
        }

        // Se autenticato e cerca di accedere a login/register, redirect a booking
        // Solo se auth √® ready per evitare loop
        final isForcedAuthRoute = state.uri.queryParameters['force'] == '1';
        if (authReady &&
            isAuthenticated &&
            (subPath == 'login' || subPath == 'register') &&
            !isForcedAuthRoute) {
          return '/$slug/booking';
        }
      }

      return null;
    },

    routes: [
      // ============================================
      // ROUTE GLOBALI (senza business context)
      // ============================================

      /// Landing page - nessun business specificato
      GoRoute(
        path: '/',
        name: 'landing',
        builder: (context, state) => const _LandingScreen(),
      ),

      /// Reset password (globale, il link viene da email)
      GoRoute(
        path: '/reset-password/:token',
        name: 'reset-password',
        builder: (context, state) {
          final token = state.pathParameters['token'] ?? '';
          return ResetPasswordScreen(token: token);
        },
      ),

      // ============================================
      // ROUTE CON BUSINESS CONTEXT (/:slug/*)
      // ============================================

      /// Prenotazione - route principale del business
      GoRoute(
        path: '/:slug/booking',
        name: 'business-booking',
        builder: (context, state) => const BookingScreen(),
      ),

      /// Login con context business
      GoRoute(
        path: '/:slug/login',
        name: 'business-login',
        builder: (context, state) {
          final from = state.uri.queryParameters['from'];
          final slug = state.pathParameters['slug'] ?? '';
          if (kIsWeb) {
            return WebLoginRedirectScreen(slug: slug, from: from);
          }
          return LoginScreen(redirectFrom: from);
        },
      ),

      /// Registrazione con context business
      GoRoute(
        path: '/:slug/register',
        name: 'business-register',
        builder: (context, state) {
          final email = state.uri.queryParameters['email'];
          final from = state.uri.queryParameters['from'];
          return RegisterScreen(initialEmail: email, redirectFrom: from);
        },
      ),

      /// Le mie prenotazioni (richiede auth)
      GoRoute(
        path: '/:slug/my-bookings',
        name: 'business-my-bookings',
        builder: (context, state) => const MyBookingsScreen(),
      ),

      /// Cambio password (richiede auth)
      GoRoute(
        path: '/:slug/change-password',
        name: 'business-change-password',
        builder: (context, state) => const ChangePasswordScreen(),
      ),

      /// Profilo utente (richiede auth)
      GoRoute(
        path: '/:slug/profile',
        name: 'business-profile',
        builder: (context, state) => const ProfileScreen(),
      ),

      /// Reset password con business context (link da email)
      GoRoute(
        path: '/:slug/reset-password/:token',
        name: 'business-reset-password',
        builder: (context, state) {
          final token = state.pathParameters['token'] ?? '';
          return ResetPasswordScreen(token: token);
        },
      ),

      /// Catch-all per /:slug ‚Üí redirect a /:slug/booking
      /// Gestito nel redirect, ma serve come fallback
      GoRoute(
        path: '/:slug',
        redirect: (context, state) {
          final slug = state.pathParameters['slug'];
          return '/$slug/booking';
        },
      ),
    ],

    errorBuilder: (context, state) => _ErrorScreen(path: state.uri.path),
  );
});

/// Path riservati che NON sono slug di business
const _reservedPaths = {
  'reset-password',
  'login',
  'register',
  'booking',
  'my-bookings',
  'change-password',
  'profile',
  'privacy',
  'terms',
};

/// Schermata landing - nessun business specificato
class _LandingScreen extends ConsumerWidget {
  const _LandingScreen();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;

    return Scaffold(
      body: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.storefront_outlined, size: 64),
            const SizedBox(height: 16),
            Text(
              l10n.businessNotFound,
              style: Theme.of(context).textTheme.titleLarge,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 32),
              child: Text(
                l10n.businessNotFoundHint,
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: Theme.of(
                    context,
                  ).colorScheme.onSurface.withAlpha((0.6 * 255).round()),
                ),
                textAlign: TextAlign.center,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// Schermata errore 404
class _ErrorScreen extends StatelessWidget {
  final String path;

  const _ErrorScreen({required this.path});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.error_outline, size: 64, color: Colors.red),
            const SizedBox(height: 16),
            Text(
              'Pagina non trovata',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: 8),
            Text(
              path,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurface.withAlpha(150),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// Listenable che notifica il router quando lo stato auth cambia
/// Permette di ri-valutare i redirect dopo il restore della sessione
class _AuthRefreshNotifier extends ChangeNotifier {
  _AuthRefreshNotifier(this._ref) {
    // Ascolta i cambiamenti dello stato auth
    _ref.listen(authProvider, (previous, next) {
      // Notifica solo quando lo status cambia (non per ogni cambio di state)
      if (previous?.status != next.status) {
        notifyListeners();
      }
    });
  }

  final Ref _ref;
}
--- FILE: lib/app/providers/form_factor_provider.dart ---
import 'dart:ui' as ui;

import 'package:flutter/widgets.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'form_factor_provider.g.dart';

// Definiamo i tre layout che ci interessano
enum AppFormFactor { mobile, tablet, desktop }

AppFormFactor _formFactorForWidth(double width) {
  if (width >= 1024) return AppFormFactor.desktop;
  if (width >= 600) return AppFormFactor.tablet;
  return AppFormFactor.mobile;
}

@riverpod
class FormFactorNotifier extends _$FormFactorNotifier {
  @override
  AppFormFactor build() {
    final binding = WidgetsFlutterBinding.ensureInitialized();
    final dispatcher = binding.platformDispatcher;
    final ui.FlutterView? view = dispatcher.views.isNotEmpty
        ? dispatcher.views.first
        : dispatcher.implicitView;

    if (view != null) {
      final logicalSize = view.physicalSize / view.devicePixelRatio;
      return _formFactorForWidth(logicalSize.width);
    }

    return AppFormFactor.mobile;
  }

  /// Aggiorna il form factor in base alla larghezza dello schermo.
  /// Usa lo stesso breakpoint di 600px che usi nel resto dell'app.
  void update(double screenWidth) {
    final newFactor = _formFactorForWidth(screenWidth);

    // Aggiorna lo stato solo se il form factor cambia
    if (state != newFactor) {
      state = newFactor;
    }
  }
}
--- FILE: lib/app/providers/route_slug_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod/legacy.dart';

/// Provider per lo slug del business estratto dalla route corrente.
///
/// Questo provider viene utilizzato per passare lo slug dal router
/// ai provider che ne hanno bisogno (es. currentBusinessProvider).
///
/// A differenza di SubdomainResolver.getBusinessSlug() che legge Uri.base
/// (statico al caricamento pagina), questo provider viene aggiornato
/// dinamicamente quando la route cambia.
final routeSlugProvider = StateProvider<String?>((ref) => null);

/// Provider per verificare se siamo in una route con business slug
final hasRouteSlugProvider = Provider<bool>((ref) {
  return ref.watch(routeSlugProvider) != null;
});
--- FILE: lib/app/providers/form_factor_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'form_factor_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(FormFactorNotifier)
const formFactorProvider = FormFactorNotifierProvider._();

final class FormFactorNotifierProvider
    extends $NotifierProvider<FormFactorNotifier, AppFormFactor> {
  const FormFactorNotifierProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'formFactorProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$formFactorNotifierHash();

  @$internal
  @override
  FormFactorNotifier create() => FormFactorNotifier();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AppFormFactor value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AppFormFactor>(value),
    );
  }
}

String _$formFactorNotifierHash() =>
    r'c2d345138b8b938ff84a110cd4b6bf3dda7a605e';

abstract class _$FormFactorNotifier extends $Notifier<AppFormFactor> {
  AppFormFactor build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<AppFormFactor, AppFormFactor>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AppFormFactor, AppFormFactor>,
              AppFormFactor,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/app/theme/theme_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'theme.dart';
import 'theme_config.dart';

/// Notifier per gestire il tema dinamico
class ThemeNotifier extends Notifier<AppThemeConfig> {
  @override
  AppThemeConfig build() => const AppThemeConfig(
        seedColor: colorPrimary,
        brightness: Brightness.light,
      );

  void updateSeed(Color color) {
    state = state.copyWith(seedColor: color);
  }

  void toggleBrightness() {
    final newBrightness = state.brightness == Brightness.light
        ? Brightness.dark
        : Brightness.light;
    state = state.copyWith(brightness: newBrightness);
  }
}

/// Provider globale per il tema
final themeNotifierProvider = NotifierProvider<ThemeNotifier, AppThemeConfig>(
  ThemeNotifier.new,
);
--- FILE: lib/app/theme/theme_config.dart ---
import 'package:flutter/material.dart';

class AppThemeConfig {
  final Color seedColor;
  final Brightness brightness;

  const AppThemeConfig({
    required this.seedColor,
    this.brightness = Brightness.light,
  });

  AppThemeConfig copyWith({Color? seedColor, Brightness? brightness}) {
    return AppThemeConfig(
      seedColor: seedColor ?? this.seedColor,
      brightness: brightness ?? this.brightness,
    );
  }
}
--- FILE: lib/app/theme/theme.dart ---
import 'package:flutter/material.dart';

import 'theme_config.dart';

const colorPrimary = Color(0xFF141414);
const colorBackground = Color(0xFFFEFEFE);
const colorAccent = Color(0xFF2196F3);
const _appFontFamily = 'Roboto';
const List<String> _emojiFontFallback = [
  'Apple Color Emoji',
  'Segoe UI Emoji',
  'Segoe UI Symbol',
  'Noto Color Emoji',
  'Noto Emoji',
  'Emoji',
  'sans-serif',
];

TextTheme _withEmojiFallback(TextTheme textTheme) {
  TextStyle? apply(TextStyle? style) =>
      style?.copyWith(fontFamilyFallback: _emojiFontFallback);

  return textTheme.copyWith(
    displayLarge: apply(textTheme.displayLarge),
    displayMedium: apply(textTheme.displayMedium),
    displaySmall: apply(textTheme.displaySmall),
    headlineLarge: apply(textTheme.headlineLarge),
    headlineMedium: apply(textTheme.headlineMedium),
    headlineSmall: apply(textTheme.headlineSmall),
    titleLarge: apply(textTheme.titleLarge),
    titleMedium: apply(textTheme.titleMedium),
    titleSmall: apply(textTheme.titleSmall),
    bodyLarge: apply(textTheme.bodyLarge),
    bodyMedium: apply(textTheme.bodyMedium),
    bodySmall: apply(textTheme.bodySmall),
    labelLarge: apply(textTheme.labelLarge),
    labelMedium: apply(textTheme.labelMedium),
    labelSmall: apply(textTheme.labelSmall),
  );
}

/// Crea il tema dell'app
ThemeData buildTheme(AppThemeConfig config, Brightness brightness) {
  final isDark = brightness == Brightness.dark;

  final background = isDark ? colorPrimary : colorBackground;
  final onBackground = isDark ? colorBackground : colorPrimary;

  final colorScheme = ColorScheme(
    brightness: brightness,
    primary: colorAccent,
    onPrimary: Colors.white,
    secondary: colorAccent,
    onSecondary: Colors.white,
    error: Colors.red,
    onError: Colors.white,
    surface: background,
    onSurface: onBackground,
  );

  final base = ThemeData(
    useMaterial3: true,
    colorScheme: colorScheme,
    brightness: brightness,
    scaffoldBackgroundColor: background,
    fontFamily: _appFontFamily,
    appBarTheme: AppBarTheme(
      backgroundColor: background,
      foregroundColor: onBackground,
      elevation: 0,
      centerTitle: true,
      surfaceTintColor: Colors.transparent,
    ),
    cardTheme: CardThemeData(
      color: background,
      elevation: 0,
      margin: const EdgeInsets.all(8),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: onBackground.withOpacity(0.1)),
      ),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        backgroundColor: colorAccent,
        foregroundColor: Colors.white,
        minimumSize: const Size(double.infinity, 52),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        elevation: 0,
      ),
    ),
    outlinedButtonTheme: OutlinedButtonThemeData(
      style: OutlinedButton.styleFrom(
        foregroundColor: colorPrimary,
        minimumSize: const Size(double.infinity, 52),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        side: BorderSide(color: colorPrimary.withOpacity(0.2)),
      ),
    ),
    textButtonTheme: TextButtonThemeData(
      style: TextButton.styleFrom(
        foregroundColor: colorAccent,
      ),
    ),
    inputDecorationTheme: InputDecorationTheme(
      filled: true,
      fillColor: onBackground.withOpacity(0.05),
      border: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: BorderSide.none,
      ),
      enabledBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: BorderSide(color: onBackground.withOpacity(0.1)),
      ),
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: colorAccent, width: 2),
      ),
      errorBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: Colors.red),
      ),
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
    ),
    chipTheme: ChipThemeData(
      backgroundColor: colorAccent.withOpacity(0.1),
      selectedColor: colorAccent,
      labelStyle: TextStyle(color: onBackground),
      secondaryLabelStyle: const TextStyle(color: Colors.white),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
    ),
    dividerColor: onBackground.withOpacity(0.1),
    progressIndicatorTheme: const ProgressIndicatorThemeData(
      color: colorAccent,
    ),
  );

  return base.copyWith(
    textTheme: _withEmojiFallback(
      base.textTheme.apply(
        bodyColor: onBackground,
        displayColor: onBackground,
        fontFamily: _appFontFamily,
      ),
    ),
  );
}
--- FILE: lib/app/app.dart ---
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../core/l10n/l10n.dart';
import '../core/widgets/app_loading_screen.dart';
import '../features/auth/domain/auth_state.dart';
import '../features/auth/providers/auth_provider.dart';
import 'router.dart';
import 'theme/theme.dart';
import 'theme/theme_provider.dart';

/// Timeout massimo per il loading iniziale (10 secondi)
/// Se l'auth non si risolve entro questo tempo, mostra comunque l'app
const _authTimeoutSeconds = 10;

class App extends ConsumerStatefulWidget {
  const App({super.key});

  @override
  ConsumerState<App> createState() => _AppState();
}

class _AppState extends ConsumerState<App> {
  bool _authTimedOut = false;
  Timer? _timeoutTimer;

  @override
  void initState() {
    super.initState();
    // Timer di sicurezza: se l'auth non si risolve entro il timeout,
    // mostra comunque l'app per evitare loading infinito
    _timeoutTimer = Timer(const Duration(seconds: _authTimeoutSeconds), () {
      if (mounted) {
        debugPrint(
          'AUTH TIMEOUT: forcing loading dismissal after ${_authTimeoutSeconds}s',
        );
        setState(() => _authTimedOut = true);
      }
    });
  }

  @override
  void dispose() {
    _timeoutTimer?.cancel();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final authState = ref.watch(authProvider);
    final router = ref.watch(routerProvider);
    final themeConfig = ref.watch(themeNotifierProvider);
    final theme = buildTheme(themeConfig, themeConfig.brightness);

    // Mostra loading globale finch√© auth non √® risolto
    // (initial = primo avvio, loading = restore session o auto-login in corso)
    // Ma non oltre il timeout di sicurezza
    final authResolving =
        !_authTimedOut &&
        (authState.status == AuthStatus.initial ||
            authState.status == AuthStatus.loading);

    return MaterialApp.router(
      title: 'Agenda Booking',
      debugShowCheckedModeBanner: false,
      theme: theme,
      routerConfig: router,
      localizationsDelegates: [
        L10n.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: L10n.delegate.supportedLocales,
      locale: const Locale('it'),
      builder: (context, child) {
        // Se auth ancora in risoluzione, mostra loading globale
        // che copre tutto (stessa grafica di index.html)
        if (authResolving) {
          return const AppLoadingScreen();
        }
        return child ?? const SizedBox.shrink();
      },
    );
  }
}
--- FILE: lib/features/auth/providers/auth_provider.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/network/api_client.dart';
import '../../../core/network/network_providers.dart';
import '../../../core/services/credentials_provider.dart';
import '../data/auth_repository.dart';
import '../domain/auth_state.dart';

/// Provider per il repository di autenticazione
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return AuthRepository(apiClient);
});

/// Provider per lo stato di autenticazione
final authProvider = NotifierProvider<AuthNotifier, AuthState>(
  AuthNotifier.new,
);

class AuthNotifier extends Notifier<AuthState> {
  /// BusinessId per cui abbiamo gi√† tentato auto-login
  final Set<int> _attemptedAutoLoginBusinessIds = {};

  @override
  AuthState build() {
    // Tenta ripristino sessione all'avvio
    _tryRestoreSession();
    return AuthState.initial();
  }

  AuthRepository get _repository => ref.read(authRepositoryProvider);

  /// Tenta di ripristinare la sessione da refresh token
  /// Se fallisce, prova con le credenziali salvate ("Ricordami")
  Future<void> _tryRestoreSession() async {
    debugPrint('AUTH: _tryRestoreSession started');
    state = AuthState.loading();

    int? savedBusinessId;

    try {
      // Recupera il businessId salvato
      final tokenStorage = ref.read(tokenStorageProvider);
      savedBusinessId = await tokenStorage.getBusinessId();
      debugPrint('AUTH: savedBusinessId=$savedBusinessId');

      final user = await _repository.tryRestoreSession(
        businessId: savedBusinessId,
      );
      debugPrint('AUTH: tryRestoreSession result: user=${user?.email}');
      if (user != null) {
        state = AuthState.authenticated(user);
        debugPrint('AUTH: state set to authenticated');
        return;
      }

      // Refresh token non valido, prova con credenziali salvate
      debugPrint('AUTH: no session, trying saved credentials');
    } catch (e, st) {
      debugPrint('AUTH: tryRestoreSession error: $e');
      debugPrint('AUTH: stack trace: $st');
    }

    // Prova auto-login con credenziali salvate (anche in caso di errore sopra)
    try {
      await _tryAutoLoginWithSavedCredentials(savedBusinessId);
    } catch (e) {
      debugPrint(
        'AUTH: _tryAutoLoginWithSavedCredentials unexpected error: $e',
      );
      // Assicurati che lo stato sia sempre settato
      state = AuthState.unauthenticated();
    }
  }

  /// Tenta auto-login con credenziali salvate da "Ricordami"
  Future<void> _tryAutoLoginWithSavedCredentials(int? businessId) async {
    try {
      final credentialsStorage = ref.read(credentialsStorageProvider);
      final credentials = await credentialsStorage.getSavedCredentials();

      if (credentials.email != null &&
          credentials.password != null &&
          businessId != null) {
        debugPrint(
          'AUTH: auto-login with saved credentials for ${credentials.email}',
        );

        final user = await _repository.login(
          businessId: businessId,
          email: credentials.email!,
          password: credentials.password!,
        );

        state = AuthState.authenticated(user);
        debugPrint('AUTH: auto-login successful');
        return;
      }
    } catch (e) {
      debugPrint('AUTH: auto-login with saved credentials failed: $e');
      // Credenziali non pi√π valide (es. password cambiata) - puliscile
      try {
        final credentialsStorage = ref.read(credentialsStorageProvider);
        await credentialsStorage.clearCredentials();
        debugPrint('AUTH: cleared invalid saved credentials');
      } catch (_) {}
    }

    // Nessuna credenziale salvata o login fallito
    state = AuthState.unauthenticated();
    debugPrint('AUTH: state set to unauthenticated');
  }

  /// Login con email e password
  /// Richiede businessId per usare l'endpoint customer corretto
  Future<bool> login({
    required int businessId,
    required String email,
    required String password,
  }) async {
    state = AuthState.loading();
    try {
      debugPrint('AUTH PROVIDER: calling repository.login');
      final user = await _repository.login(
        businessId: businessId,
        email: email,
        password: password,
      );
      debugPrint('AUTH PROVIDER: login success, user=${user.email}');
      state = AuthState.authenticated(user);
      return true;
    } on ApiException catch (e) {
      debugPrint('AUTH PROVIDER: ApiException: ${e.code} - ${e.message}');
      state = AuthState.error(e.message, code: e.code);
      return false;
    } catch (e, st) {
      debugPrint('AUTH PROVIDER: generic error: $e');
      debugPrint('AUTH PROVIDER: stack trace: $st');
      state = AuthState.error(e.toString());
      return false;
    }
  }

  /// Logout
  Future<void> logout({required int businessId}) async {
    try {
      await _repository.logout(businessId: businessId);
    } finally {
      // Cancella solo la password salvata (mantiene l'email per comodit√†)
      try {
        final credentialsStorage = ref.read(credentialsStorageProvider);
        await credentialsStorage.clearPassword();
        debugPrint('AUTH: cleared saved password on logout');
      } catch (_) {}
      state = AuthState.unauthenticated();
    }
  }

  /// Registrazione nuovo cliente
  Future<bool> register({
    required int businessId,
    required String email,
    required String password,
    required String firstName,
    required String lastName,
    String? phone,
  }) async {
    debugPrint('=== REGISTER START ===');
    debugPrint(
      'Current state before register: errorCode=${state.errorCode}, errorMessage=${state.errorMessage}',
    );
    state = AuthState.loading();
    try {
      debugPrint(
        'Register: businessId=$businessId, email=$email, firstName=$firstName, lastName=$lastName',
      );
      final user = await _repository.register(
        businessId: businessId,
        email: email,
        password: password,
        firstName: firstName,
        lastName: lastName,
        phone: phone,
      );
      debugPrint('Register SUCCESS: user=${user.email}');
      state = AuthState.authenticated(user);
      return true;
    } on ApiException catch (e) {
      debugPrint('Register ApiException: code=${e.code}, message=${e.message}');
      state = AuthState.error(e.message, code: e.code);
      return false;
    } catch (e, st) {
      debugPrint('Register generic error: $e');
      debugPrint('Stack trace: $st');
      state = AuthState.error(e.toString());
      return false;
    }
  }

  /// Reset password (invia email con link)
  /// Lancia ApiException se l'email non esiste (code: email_not_found)
  Future<void> resetPassword({
    required int businessId,
    required String email,
  }) async {
    await _repository.resetPassword(businessId: businessId, email: email);
  }

  /// Conferma reset password con token
  Future<void> resetPasswordWithToken({
    required String token,
    required String newPassword,
  }) async {
    await _repository.confirmResetPassword(
      token: token,
      newPassword: newPassword,
    );
  }

  /// Cambia password (utente loggato)
  Future<bool> changePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    try {
      await _repository.changePassword(
        currentPassword: currentPassword,
        newPassword: newPassword,
      );
      return true;
    } catch (e) {
      state = state.copyWith(errorMessage: e.toString());
      return false;
    }
  }

  /// Aggiorna il profilo utente
  Future<void> updateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
  }) async {
    final updatedUser = await _repository.updateProfile(
      firstName: firstName,
      lastName: lastName,
      email: email,
      phone: phone,
    );
    state = AuthState.authenticated(updatedUser);
  }

  /// Pulisce errore
  void clearError() {
    state = state.copyWith(clearError: true);
  }

  /// Verifica se √® autenticato
  bool get isAuthenticated => state.isAuthenticated;

  /// Tenta auto-login con credenziali salvate per un businessId specifico.
  /// Da chiamare quando il businessId corrente (dall'URL) √® disponibile
  /// e l'utente risulta non autenticato.
  /// Ritorna true se l'auto-login √® avvenuto con successo.
  Future<bool> retryAutoLoginIfNeeded(int businessId) async {
    // Non riprovare se gi√† autenticato
    if (state.isAuthenticated) {
      return false;
    }

    // Non riprovare se siamo in loading
    if (state.status == AuthStatus.loading ||
        state.status == AuthStatus.initial) {
      return false;
    }

    // Non riprovare se abbiamo gi√† tentato per questo business
    if (_attemptedAutoLoginBusinessIds.contains(businessId)) {
      debugPrint(
        'AUTH: already attempted auto-login for businessId=$businessId',
      );
      return false;
    }

    _attemptedAutoLoginBusinessIds.add(businessId);
    debugPrint('AUTH: retryAutoLoginIfNeeded for businessId=$businessId');

    try {
      final credentialsStorage = ref.read(credentialsStorageProvider);
      final credentials = await credentialsStorage.getSavedCredentials();

      if (credentials.email == null || credentials.password == null) {
        debugPrint('AUTH: no saved credentials for retry');
        return false;
      }

      debugPrint(
        'AUTH: retrying auto-login with saved credentials for ${credentials.email}',
      );
      state = AuthState.loading();

      final user = await _repository.login(
        businessId: businessId,
        email: credentials.email!,
        password: credentials.password!,
      );

      state = AuthState.authenticated(user);
      debugPrint('AUTH: retry auto-login successful');
      return true;
    } catch (e) {
      debugPrint('AUTH: retry auto-login failed: $e');
      state = AuthState.unauthenticated();
      return false;
    }
  }
}
--- FILE: lib/features/auth/data/auth_repository.dart ---
import '../../../core/models/user.dart';
import '../../../core/network/api_client.dart';

/// Repository per l'autenticazione CUSTOMER - API reale
/// Usa endpoint /v1/customer/{business_id}/auth/* per clienti (tabella clients)
class AuthRepository {
  final ApiClient _apiClient;

  AuthRepository(this._apiClient);

  /// Login cliente
  /// POST /v1/customer/{business_id}/auth/login
  Future<User> login({
    required int businessId,
    required String email,
    required String password,
  }) async {
    final data = await _apiClient.customerLogin(
      businessId: businessId,
      email: email,
      password: password,
    );
    return User.fromJson(data['client'] as Map<String, dynamic>);
  }

  /// Logout cliente
  /// POST /v1/customer/{business_id}/auth/logout
  Future<void> logout({required int businessId}) async {
    await _apiClient.customerLogout(businessId: businessId);
  }

  /// Recupera profilo cliente corrente
  /// GET /v1/customer/me
  Future<User> getCurrentUser() async {
    final data = await _apiClient.getCustomerMe();
    return User.fromJson(data);
  }

  /// Tenta di ripristinare sessione da refresh token
  Future<User?> tryRestoreSession({int? businessId}) async {
    final data = await _apiClient.tryRestoreSession(businessId: businessId);
    if (data != null) {
      return User.fromJson(data);
    }
    return null;
  }

  /// Registrazione nuovo cliente
  /// POST /v1/customer/{business_id}/auth/register
  Future<User> register({
    required int businessId,
    required String email,
    required String password,
    required String firstName,
    required String lastName,
    String? phone,
  }) async {
    final data = await _apiClient.customerRegister(
      businessId: businessId,
      email: email,
      password: password,
      firstName: firstName,
      lastName: lastName,
      phone: phone,
    );
    return User.fromJson(data['client'] as Map<String, dynamic>);
  }

  /// Reset password (invia email con link)
  /// POST /v1/customer/{business_id}/auth/forgot-password
  Future<void> resetPassword({
    required int businessId,
    required String email,
  }) async {
    await _apiClient.customerForgotPassword(
      businessId: businessId,
      email: email,
    );
  }

  /// Conferma reset password con token
  /// POST /v1/customer/auth/reset-password
  Future<void> confirmResetPassword({
    required String token,
    required String newPassword,
  }) async {
    await _apiClient.customerResetPassword(token: token, password: newPassword);
  }

  /// Cambia password (utente loggato)
  /// POST /v1/customer/me/change-password
  Future<void> changePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    await _apiClient.customerChangePassword(
      currentPassword: currentPassword,
      newPassword: newPassword,
    );
  }

  /// Aggiorna profilo cliente
  /// PUT /v1/customer/me
  Future<User> updateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
  }) async {
    final data = await _apiClient.customerUpdateProfile(
      firstName: firstName,
      lastName: lastName,
      email: email,
      phone: phone,
    );
    return User.fromJson(data);
  }
}
--- FILE: lib/features/auth/domain/auth_state.dart ---
import '../../../core/models/user.dart';

/// Stati possibili dell'autenticazione
enum AuthStatus { initial, loading, authenticated, unauthenticated, error }

/// Stato dell'autenticazione
class AuthState {
  final AuthStatus status;
  final User? user;
  final String? errorMessage;
  final String? errorCode;

  const AuthState({
    this.status = AuthStatus.initial,
    this.user,
    this.errorMessage,
    this.errorCode,
  });

  bool get isAuthenticated =>
      status == AuthStatus.authenticated && user != null;
  bool get isLoading => status == AuthStatus.loading;

  AuthState copyWith({
    AuthStatus? status,
    User? user,
    String? errorMessage,
    String? errorCode,
    bool clearUser = false,
    bool clearError = false,
  }) => AuthState(
    status: status ?? this.status,
    user: clearUser ? null : (user ?? this.user),
    errorMessage: clearError ? null : (errorMessage ?? this.errorMessage),
    errorCode: clearError ? null : (errorCode ?? this.errorCode),
  );

  factory AuthState.initial() => const AuthState(status: AuthStatus.initial);

  factory AuthState.loading() => const AuthState(status: AuthStatus.loading);

  factory AuthState.authenticated(User user) =>
      AuthState(status: AuthStatus.authenticated, user: user);

  factory AuthState.unauthenticated() =>
      const AuthState(status: AuthStatus.unauthenticated);

  factory AuthState.error(String message, {String? code}) =>
      AuthState(status: AuthStatus.error, errorMessage: message, errorCode: code);

  @override
  String toString() =>
      'AuthState(status: $status, user: ${user?.email}, errorMessage: $errorMessage, errorCode: $errorCode)';
}
--- FILE: lib/features/auth/presentation/profile_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../app/providers/route_slug_provider.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../../core/network/api_client.dart';
import '../../../core/utils/initials_utils.dart';
import '../providers/auth_provider.dart';

/// Schermata profilo utente per il frontend clienti.
/// Permette di visualizzare e modificare i propri dati.
class ProfileScreen extends ConsumerStatefulWidget {
  const ProfileScreen({super.key});

  @override
  ConsumerState<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends ConsumerState<ProfileScreen> {
  final _formKey = GlobalKey<FormState>();
  late final TextEditingController _firstNameController;
  late final TextEditingController _lastNameController;
  late final TextEditingController _emailController;
  late final TextEditingController _phoneController;

  bool _isLoading = false;
  bool _isEditing = false;
  String? _error;
  String? _success;

  @override
  void initState() {
    super.initState();
    final user = ref.read(authProvider).user;
    _firstNameController = TextEditingController(text: user?.firstName ?? '');
    _lastNameController = TextEditingController(text: user?.lastName ?? '');
    _emailController = TextEditingController(text: user?.email ?? '');
    _phoneController = TextEditingController(text: user?.phone ?? '');
  }

  @override
  void dispose() {
    _firstNameController.dispose();
    _lastNameController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    super.dispose();
  }

  Future<void> _saveChanges() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _error = null;
      _success = null;
    });

    try {
      await ref
          .read(authProvider.notifier)
          .updateProfile(
            firstName: _firstNameController.text.trim(),
            lastName: _lastNameController.text.trim(),
            email: _emailController.text.trim(),
            phone: _phoneController.text.trim().isEmpty
                ? null
                : _phoneController.text.trim(),
          );

      if (mounted) {
        setState(() {
          _isEditing = false;
          _success = 'Profilo aggiornato con successo';
          _isLoading = false;
        });
      }
    } on ApiException catch (e) {
      setState(() {
        _error = e.message;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  void _cancelEditing() {
    final user = ref.read(authProvider).user;
    setState(() {
      _firstNameController.text = user?.firstName ?? '';
      _lastNameController.text = user?.lastName ?? '';
      _emailController.text = user?.email ?? '';
      _phoneController.text = user?.phone ?? '';
      _isEditing = false;
      _error = null;
    });
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final authState = ref.watch(authProvider);
    final user = authState.user;

    return Scaffold(
      appBar: AppBar(
        backgroundColor: colorScheme.surface,
        surfaceTintColor: Colors.transparent,
        elevation: 0,
        scrolledUnderElevation: 0.5,
        centerTitle: true,
        leading: IconButton(
          icon: Icon(
            Icons.arrow_back_ios_new,
            size: 20,
            color: colorScheme.onSurface,
          ),
          onPressed: () {
            final slug = ref.read(routeSlugProvider);
            context.go('/$slug/booking');
          },
        ),
        title: Text(
          l10n.profileTitle,
          style: theme.textTheme.titleLarge?.copyWith(
            fontWeight: FontWeight.w600,
            letterSpacing: -0.3,
            color: colorScheme.onSurface,
          ),
        ),
        actions: [
          if (!_isEditing)
            IconButton(
              icon: const Icon(Icons.edit_outlined),
              tooltip: 'Modifica',
              onPressed: () => setState(() => _isEditing = true),
            ),
          const SizedBox(width: 4),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(24),
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 500),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // Avatar
                Center(
                  child: CircleAvatar(
                    radius: 50,
                    backgroundColor: colorScheme.primaryContainer,
                    child: Text(
                      _getInitials(user?.firstName, user?.lastName),
                      style: TextStyle(
                        fontSize: 32,
                        fontWeight: FontWeight.bold,
                        color: colorScheme.onPrimaryContainer,
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 24),

                // Messaggi
                if (_success != null) ...[
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: colorScheme.primaryContainer,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Row(
                      children: [
                        Icon(
                          Icons.check_circle,
                          color: colorScheme.onPrimaryContainer,
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            _success!,
                            style: TextStyle(
                              color: colorScheme.onPrimaryContainer,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 16),
                ],

                if (_error != null) ...[
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: colorScheme.errorContainer,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Row(
                      children: [
                        Icon(
                          Icons.error_outline,
                          color: colorScheme.onErrorContainer,
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            _error!,
                            style: TextStyle(
                              color: colorScheme.onErrorContainer,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 16),
                ],

                // Form
                Form(
                  key: _formKey,
                  child: Column(
                    children: [
                      // Nome
                      TextFormField(
                        controller: _firstNameController,
                        enabled: _isEditing,
                        decoration: InputDecoration(
                          labelText: l10n.authFirstName,
                          prefixIcon: const Icon(Icons.person_outline),
                        ),
                        textCapitalization: TextCapitalization.words,
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return l10n.authRequiredField;
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),

                      // Cognome
                      TextFormField(
                        controller: _lastNameController,
                        enabled: _isEditing,
                        decoration: InputDecoration(
                          labelText: l10n.authLastName,
                          prefixIcon: const Icon(Icons.person_outline),
                        ),
                        textCapitalization: TextCapitalization.words,
                      ),
                      const SizedBox(height: 16),

                      // Email
                      TextFormField(
                        controller: _emailController,
                        enabled: _isEditing,
                        decoration: InputDecoration(
                          labelText: l10n.authEmail,
                          prefixIcon: const Icon(Icons.email_outlined),
                          helperText: _isEditing
                              ? 'Attenzione: cambiando email dovrai usarla per il login'
                              : null,
                        ),
                        keyboardType: TextInputType.emailAddress,
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return l10n.authRequiredField;
                          }
                          final emailRegex = RegExp(
                            r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                          );
                          if (!emailRegex.hasMatch(value.trim())) {
                            return l10n.authInvalidEmail;
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),

                      // Telefono
                      TextFormField(
                        controller: _phoneController,
                        enabled: _isEditing,
                        decoration: InputDecoration(
                          labelText: l10n.authPhone,
                          prefixIcon: const Icon(Icons.phone_outlined),
                        ),
                        keyboardType: TextInputType.phone,
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 32),

                // Bottoni
                if (_isEditing) ...[
                  Row(
                    children: [
                      Expanded(
                        child: OutlinedButton(
                          onPressed: _isLoading ? null : _cancelEditing,
                          child: Text(l10n.actionCancel),
                        ),
                      ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: OutlinedButton(
                          onPressed: _isLoading ? null : _saveChanges,
                          style: OutlinedButton.styleFrom(
                            foregroundColor: colorScheme.primary,
                            side: BorderSide(color: colorScheme.primary),
                          ),
                          child: _isLoading
                              ? SizedBox(
                                  width: 20,
                                  height: 20,
                                  child: CircularProgressIndicator(
                                    strokeWidth: 2,
                                    color: colorScheme.primary,
                                  ),
                                )
                              : Text(l10n.actionConfirm),
                        ),
                      ),
                    ],
                  ),
                ] else ...[
                  // Link cambio password
                  OutlinedButton.icon(
                    icon: const Icon(Icons.lock_outline),
                    label: Text(l10n.authChangePassword),
                    onPressed: () {
                      final slug = ref.read(routeSlugProvider);
                      context.push('/$slug/change-password');
                    },
                  ),
                ],
              ],
            ),
          ),
        ),
      ),
    );
  }

  String _getInitials(String? firstName, String? lastName) {
    return InitialsUtils.fromName(
      '${firstName ?? ''} ${lastName ?? ''}'.trim(),
      maxChars: 2,
    );
  }
}
--- FILE: lib/features/auth/presentation/register_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../app/providers/route_slug_provider.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../../core/widgets/feedback_dialog.dart';
import '../../booking/providers/business_provider.dart';
import '../providers/auth_provider.dart';

class RegisterScreen extends ConsumerStatefulWidget {
  final String? initialEmail;

  /// Route da cui l'utente √® stato reindirizzato (es. 'my-bookings')
  final String? redirectFrom;

  const RegisterScreen({super.key, this.initialEmail, this.redirectFrom});

  @override
  ConsumerState<RegisterScreen> createState() => _RegisterScreenState();
}

class _RegisterScreenState extends ConsumerState<RegisterScreen> {
  final _formKey = GlobalKey<FormState>();
  final _firstNameController = TextEditingController();
  final _lastNameController = TextEditingController();
  final _emailController = TextEditingController();
  final _phoneController = TextEditingController();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  bool _obscurePassword = true;
  bool _obscureConfirmPassword = true;
  bool _hasAttemptedRegister = false;
  bool _isInitialized = false;
  bool _isRegistering = false;

  @override
  void initState() {
    super.initState();
    // Pulisci errori residui dopo che il widget √® montato
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(authProvider.notifier).clearError();
      if (mounted) {
        setState(() => _isInitialized = true);
      }
    });
    // Pre-compila l'email se passata dal login
    _initEmail();
  }

  void _initEmail() {
    final email = widget.initialEmail;
    debugPrint('RegisterScreen initialEmail: $email');
    if (email != null && email.isNotEmpty) {
      _emailController.text = email;
    }
  }

  @override
  void dispose() {
    _firstNameController.dispose();
    _lastNameController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  /// Traduce il codice errore dall'API
  String _getErrorMessage(String? errorCode, String? rawMessage, dynamic l10n) {
    switch (errorCode) {
      case 'email_already_exists':
        return l10n.authErrorEmailAlreadyExists;
      case 'weak_password':
        return l10n.authErrorWeakPassword;
      case 'invalid_credentials':
        return l10n.authErrorInvalidCredentials;
      case 'account_disabled':
        return l10n.authErrorAccountDisabled;
      case 'token_expired':
        return l10n.authErrorTokenExpired;
      case 'token_invalid':
        return l10n.authErrorTokenInvalid;
      case 'session_revoked':
        return l10n.authErrorSessionRevoked;
      case 'invalid_reset_token':
        return l10n.authErrorInvalidResetToken;
      case 'reset_token_expired':
        return l10n.authErrorResetTokenExpired;
      case 'validation_error':
        // Mostra il messaggio dettagliato dal server
        if (rawMessage != null && rawMessage.isNotEmpty) {
          return rawMessage;
        }
        return l10n.authRegisterFailed;
    }
    return l10n.authRegisterFailed;
  }

  Future<void> _handleRegister() async {
    if (_isRegistering) return;
    if (!_formKey.currentState!.validate()) return;

    setState(() => _hasAttemptedRegister = true);
    setState(() => _isRegistering = true);

    try {
      // Ottieni il businessId - prima prova il provider sincrono
      var businessId = ref.read(currentBusinessIdProvider);

      // Se null, attendi che il business sia caricato (necessario quando
      // l'utente arriva direttamente sulla pagina via URL)
      if (businessId == null) {
        final businessAsync = await ref.read(currentBusinessProvider.future);
        businessId = businessAsync?.id;
      }

      if (businessId == null) {
        if (mounted) {
          await FeedbackDialog.showError(
            context,
            title: context.l10n.errorTitle,
            message: context.l10n.authBusinessNotFound,
          );
        }
        return;
      }

      final success = await ref
          .read(authProvider.notifier)
          .register(
            businessId: businessId,
            email: _emailController.text.trim(),
            password: _passwordController.text,
            firstName: _firstNameController.text.trim(),
            lastName: _lastNameController.text.trim(),
            phone: _phoneController.text.trim().isNotEmpty
                ? _phoneController.text.trim()
                : null,
          );

      if (success && mounted) {
        // Segnala al browser che l'autofill √® completato con successo
        TextInput.finishAutofillContext();
        final slug = ref.read(routeSlugProvider);

        // Se l'utente voleva vedere my-bookings, portalo l√¨
        if (widget.redirectFrom == 'my-bookings') {
          context.go('/$slug/my-bookings');
          return;
        }

        context.go('/$slug/booking');
      }
    } finally {
      if (mounted) {
        setState(() => _isRegistering = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final authState = ref.watch(authProvider);
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final isLoading = _isRegistering || authState.isLoading;

    return Scaffold(
      appBar: AppBar(
        backgroundColor: colorScheme.surface,
        surfaceTintColor: Colors.transparent,
        elevation: 0,
        scrolledUnderElevation: 0.5,
        centerTitle: true,
        leading: IconButton(
          icon: Icon(
            Icons.arrow_back_ios_new,
            size: 20,
            color: colorScheme.onSurface,
          ),
          onPressed: () {
            final slug = ref.read(routeSlugProvider);
            context.go('/$slug/booking');
          },
        ),
        title: Text(
          l10n.authRegisterTitle,
          style: theme.textTheme.titleLarge?.copyWith(
            fontWeight: FontWeight.w600,
            letterSpacing: -0.3,
            color: colorScheme.onSurface,
          ),
        ),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: AutofillGroup(
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  const SizedBox(height: 16),

                  // Nome
                  TextFormField(
                    controller: _firstNameController,
                    textInputAction: TextInputAction.next,
                    textCapitalization: TextCapitalization.words,
                    autofillHints: const [AutofillHints.givenName],
                    decoration: InputDecoration(
                      labelText: l10n.authFirstName,
                      prefixIcon: const Icon(Icons.person_outline),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // Cognome
                  TextFormField(
                    controller: _lastNameController,
                    textInputAction: TextInputAction.next,
                    textCapitalization: TextCapitalization.words,
                    autofillHints: const [AutofillHints.familyName],
                    decoration: InputDecoration(
                      labelText: l10n.authLastName,
                      prefixIcon: const Icon(Icons.person_outline),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // Email
                  TextFormField(
                    controller: _emailController,
                    keyboardType: TextInputType.emailAddress,
                    textInputAction: TextInputAction.next,
                    autocorrect: false,
                    enableSuggestions: true,
                    autofillHints: const [AutofillHints.email],
                    decoration: InputDecoration(
                      labelText: l10n.authEmail,
                      prefixIcon: const Icon(Icons.email_outlined),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      if (!value.contains('@')) {
                        return l10n.authInvalidEmail;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // Telefono (opzionale)
                  TextFormField(
                    controller: _phoneController,
                    keyboardType: TextInputType.phone,
                    textInputAction: TextInputAction.next,
                    autofillHints: const [AutofillHints.telephoneNumber],
                    decoration: InputDecoration(
                      labelText: '${l10n.authPhone} (opzionale)',
                      prefixIcon: const Icon(Icons.phone_outlined),
                    ),
                  ),
                  const SizedBox(height: 16),

                  // Password
                  TextFormField(
                    controller: _passwordController,
                    obscureText: _obscurePassword,
                    textInputAction: TextInputAction.next,
                    enableSuggestions: false,
                    autocorrect: false,
                    autofillHints: const [AutofillHints.newPassword],
                    decoration: InputDecoration(
                      labelText: l10n.authPassword,
                      prefixIcon: const Icon(Icons.lock_outlined),
                      suffixIcon: IconButton(
                        icon: Icon(
                          _obscurePassword
                              ? Icons.visibility_outlined
                              : Icons.visibility_off_outlined,
                        ),
                        onPressed: () {
                          setState(() => _obscurePassword = !_obscurePassword);
                        },
                      ),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      // Validazione allineata al backend
                      if (value.length < 8 ||
                          !RegExp(r'[A-Z]').hasMatch(value) ||
                          !RegExp(r'[a-z]').hasMatch(value) ||
                          !RegExp(r'[0-9]').hasMatch(value)) {
                        return l10n.authInvalidPassword;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // Conferma Password
                  TextFormField(
                    controller: _confirmPasswordController,
                    obscureText: _obscureConfirmPassword,
                    textInputAction: TextInputAction.done,
                    onFieldSubmitted: (_) => _handleRegister(),
                    decoration: InputDecoration(
                      labelText: l10n.authConfirmPassword,
                      prefixIcon: const Icon(Icons.lock_outlined),
                      suffixIcon: IconButton(
                        icon: Icon(
                          _obscureConfirmPassword
                              ? Icons.visibility_outlined
                              : Icons.visibility_off_outlined,
                        ),
                        onPressed: () {
                          setState(
                            () => _obscureConfirmPassword =
                                !_obscureConfirmPassword,
                          );
                        },
                      ),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      if (value != _passwordController.text) {
                        return l10n.authPasswordMismatch;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 24),

                  // Errore (mostrato solo dopo un tentativo di registrazione e dopo init)
                  if (_isInitialized &&
                      _hasAttemptedRegister &&
                      authState.errorMessage != null) ...[
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: theme.colorScheme.error.withValues(alpha: 0.1),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Row(
                        children: [
                          Icon(
                            Icons.error_outline,
                            color: theme.colorScheme.error,
                          ),
                          const SizedBox(width: 8),
                          Expanded(
                            child: Text(
                              _getErrorMessage(
                                authState.errorCode,
                                authState.errorMessage,
                                l10n,
                              ),
                              style: TextStyle(color: theme.colorScheme.error),
                            ),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(height: 16),
                  ],

                  // Bottone Registra
                  ElevatedButton(
                    onPressed: isLoading ? null : _handleRegister,
                    child: isLoading
                        ? const SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              color: Colors.white,
                            ),
                          )
                        : Text(l10n.actionRegister),
                  ),
                  const SizedBox(height: 24),

                  // Link login
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Text(l10n.authHaveAccount),
                      TextButton(
                        onPressed: () {
                          final slug = ref.read(routeSlugProvider);
                          context.go('/$slug/login');
                        },
                        child: Text(l10n.actionLogin),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/auth/presentation/change_password_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../app/providers/route_slug_provider.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../../core/widgets/feedback_dialog.dart';
import '../providers/auth_provider.dart';

class ChangePasswordScreen extends ConsumerStatefulWidget {
  const ChangePasswordScreen({super.key});

  @override
  ConsumerState<ChangePasswordScreen> createState() =>
      _ChangePasswordScreenState();
}

class _ChangePasswordScreenState extends ConsumerState<ChangePasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final _currentPasswordController = TextEditingController();
  final _newPasswordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  bool _obscureCurrentPassword = true;
  bool _obscureNewPassword = true;
  bool _obscureConfirmPassword = true;
  bool _isLoading = false;

  @override
  void dispose() {
    _currentPasswordController.dispose();
    _newPasswordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  Future<void> _handleChangePassword() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    final success = await ref
        .read(authProvider.notifier)
        .changePassword(
          currentPassword: _currentPasswordController.text,
          newPassword: _newPasswordController.text,
        );

    setState(() => _isLoading = false);

    if (mounted) {
      if (success) {
        await FeedbackDialog.showSuccess(
          context,
          title: context.l10n.authChangePasswordTitle,
          message: context.l10n.authChangePasswordSuccess,
        );
        if (mounted) context.pop();
      } else {
        await FeedbackDialog.showError(
          context,
          title: context.l10n.errorTitle,
          message: context.l10n.authChangePasswordError,
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Scaffold(
      appBar: AppBar(
        backgroundColor: colorScheme.surface,
        surfaceTintColor: Colors.transparent,
        elevation: 0,
        scrolledUnderElevation: 0.5,
        centerTitle: true,
        leading: IconButton(
          icon: Icon(
            Icons.arrow_back_ios_new,
            size: 20,
            color: colorScheme.onSurface,
          ),
          onPressed: () {
            final slug = ref.read(routeSlugProvider);
            context.go('/$slug/booking');
          },
        ),
        title: Text(
          l10n.authChangePasswordTitle,
          style: theme.textTheme.titleLarge?.copyWith(
            fontWeight: FontWeight.w600,
            letterSpacing: -0.3,
            color: colorScheme.onSurface,
          ),
        ),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                const SizedBox(height: 32),

                // Icon
                Icon(
                  Icons.lock_reset,
                  size: 64,
                  color: theme.colorScheme.primary,
                ),
                const SizedBox(height: 32),

                // Current password
                TextFormField(
                  controller: _currentPasswordController,
                  obscureText: _obscureCurrentPassword,
                  textInputAction: TextInputAction.next,
                  decoration: InputDecoration(
                    labelText: l10n.authCurrentPassword,
                    prefixIcon: const Icon(Icons.lock_outlined),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscureCurrentPassword
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(
                          () => _obscureCurrentPassword =
                              !_obscureCurrentPassword,
                        );
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // New password
                TextFormField(
                  controller: _newPasswordController,
                  obscureText: _obscureNewPassword,
                  textInputAction: TextInputAction.next,
                  decoration: InputDecoration(
                    labelText: l10n.authNewPassword,
                    prefixIcon: const Icon(Icons.lock_outlined),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscureNewPassword
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(
                          () => _obscureNewPassword = !_obscureNewPassword,
                        );
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    if (value.length < 8) {
                      return l10n.authPasswordTooShort;
                    }
                    if (!RegExp(r'[A-Z]').hasMatch(value) ||
                        !RegExp(r'[a-z]').hasMatch(value) ||
                        !RegExp(r'[0-9]').hasMatch(value)) {
                      return l10n.authPasswordRequirements;
                    }
                    if (value == _currentPasswordController.text) {
                      return 'La nuova password deve essere diversa';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // Confirm password
                TextFormField(
                  controller: _confirmPasswordController,
                  obscureText: _obscureConfirmPassword,
                  textInputAction: TextInputAction.done,
                  decoration: InputDecoration(
                    labelText: l10n.authConfirmPassword,
                    prefixIcon: const Icon(Icons.lock_outlined),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscureConfirmPassword
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(
                          () => _obscureConfirmPassword =
                              !_obscureConfirmPassword,
                        );
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    if (value != _newPasswordController.text) {
                      return l10n.authPasswordMismatch;
                    }
                    return null;
                  },
                  onFieldSubmitted: (_) => _handleChangePassword(),
                ),
                const SizedBox(height: 32),

                // Submit button
                FilledButton(
                  onPressed: _isLoading ? null : _handleChangePassword,
                  child: _isLoading
                      ? const SizedBox(
                          height: 20,
                          width: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : Text(l10n.actionConfirm),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/auth/presentation/login_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../app/providers/route_slug_provider.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../../core/network/api_client.dart';
import '../../../core/services/credentials_provider.dart';
import '../../../core/services/pending_booking_storage.dart';
import '../../../core/widgets/feedback_dialog.dart';
import '../../booking/providers/booking_provider.dart';
import '../../booking/providers/business_provider.dart';
import '../domain/auth_state.dart';
import '../providers/auth_provider.dart';

class LoginScreen extends ConsumerStatefulWidget {
  const LoginScreen({super.key, this.redirectFrom});

  /// Route da cui l'utente √® stato reindirizzato (es. 'my-bookings')
  final String? redirectFrom;

  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends ConsumerState<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _obscurePassword = true;
  bool _rememberMe = true;
  bool _autoLoginAttempted = false;

  @override
  void initState() {
    super.initState();
    _loadSavedCredentials();
    // Pulisci eventuali errori residui quando si entra nella pagina
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(authProvider.notifier).clearError();
      _tryAutoLoginOnReady();
    });
  }

  /// Tenta auto-login quando businessId e auth state sono pronti
  Future<void> _tryAutoLoginOnReady() async {
    // Evita tentativi multipli
    if (_autoLoginAttempted) {
      return;
    }
    _autoLoginAttempted = true;

    // Verifica che il widget sia ancora montato
    if (!mounted) {
      return;
    }

    final authState = ref.read(authProvider);

    // Se siamo gi√† autenticati, non fare nulla
    if (authState.isAuthenticated) {
      return;
    }

    // Se l'auth sta ancora caricando/inizializzando, aspetta
    if (authState.status == AuthStatus.initial ||
        authState.status == AuthStatus.loading) {
      _autoLoginAttempted = false; // Reset per riprovare dopo
      return;
    }

    // Ottieni il businessId dall'URL (sincrono)
    int? businessId = ref.read(currentBusinessIdProvider);

    // Se non disponibile, prova a leggere dal business async
    if (businessId == null) {
      final businessAsync = ref.read(currentBusinessProvider);
      if (businessAsync.hasValue) {
        businessId = businessAsync.value?.id;
      } else if (businessAsync.isLoading) {
        // Business ancora in caricamento - riproveremo dal listener
        _autoLoginAttempted = false;
        return;
      } else if (businessAsync.hasError) {
        debugPrint('LOGIN auto-login: business has error, skipping');
        return;
      }
    }

    if (businessId == null || !mounted) {
      return;
    }

    // Tenta l'auto-login con le credenziali salvate
    debugPrint('LOGIN: trying auto-login for businessId=$businessId');
    final success = await ref
        .read(authProvider.notifier)
        .retryAutoLoginIfNeeded(businessId);

    if (success && mounted) {
      _navigateAfterAutoLogin();
    }
  }

  /// Naviga alla destinazione appropriata dopo auto-login
  void _navigateAfterAutoLogin() async {
    final slug = ref.read(routeSlugProvider);

    // Verifica se c'√® una prenotazione in sospeso
    if (await PendingBookingStorage.hasPendingBooking()) {
      final restored = await ref
          .read(bookingFlowProvider.notifier)
          .restorePendingBooking();
      if (restored && mounted) {
        debugPrint('AUTO-LOGIN: pending booking restored - going to booking');
        context.go('/$slug/booking');
        return;
      }
    }

    // Se l'utente voleva vedere my-bookings, portalo l√¨
    if (widget.redirectFrom == 'my-bookings' && mounted) {
      context.go('/$slug/my-bookings');
      return;
    }

    // Altrimenti vai al booking
    if (mounted) {
      context.go('/$slug/booking');
    }
  }

  Future<void> _loadSavedCredentials() async {
    try {
      final storage = ref.read(credentialsStorageProvider);
      final credentials = await storage.getSavedCredentials();

      if (credentials.email != null && credentials.password != null) {
        if (mounted) {
          setState(() {
            _emailController.text = credentials.email!;
            _passwordController.text = credentials.password!;
            _rememberMe = true;
          });
        }
      }
    } catch (e) {
      debugPrint('Error loading saved credentials: $e');
    }
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _handleLogin() async {
    if (!_formKey.currentState!.validate()) {
      return;
    }

    // Attendi che il business sia caricato
    int? businessId = ref.read(currentBusinessIdProvider);

    if (businessId == null) {
      // Il business potrebbe non essere ancora caricato, aspettiamo
      try {
        final business = await ref.read(currentBusinessProvider.future);
        businessId = business?.id;
      } catch (e) {
        debugPrint('LOGIN business load failed: $e');
      }
    }

    if (businessId == null) {
      // Se non c'√® un business, mostra errore appropriato
      if (mounted) {
        await FeedbackDialog.showError(
          context,
          title: context.l10n.errorTitle,
          message: context.l10n.authBusinessNotFound,
        );
      }
      return;
    }

    final success = await ref
        .read(authProvider.notifier)
        .login(
          businessId: businessId,
          email: _emailController.text.trim(),
          password: _passwordController.text.trim(),
        );
    debugPrint('LOGIN API returned: success=$success');

    if (success && mounted) {
      // Salva o cancella le credenziali in base alla scelta dell'utente
      final storage = ref.read(credentialsStorageProvider);
      if (_rememberMe) {
        await storage.saveCredentials(
          _emailController.text.trim(),
          _passwordController.text.trim(),
        );
      } else {
        await storage.clearCredentials();
      }

      // Segnala al browser che l'autofill √® completato con successo
      // Questo triggera la richiesta di salvataggio credenziali
      TextInput.finishAutofillContext();

      final slug = ref.read(routeSlugProvider);

      // Verifica se c'√® una prenotazione in sospeso (da token scaduto)
      if (await PendingBookingStorage.hasPendingBooking()) {
        // Ripristina la prenotazione e vai al riepilogo
        final restored = await ref
            .read(bookingFlowProvider.notifier)
            .restorePendingBooking();
        if (restored && mounted) {
          debugPrint(
            'LOGIN pending booking restored - going to booking (summary step)',
          );
          context.go('/$slug/booking');
          return;
        }
      }

      // Se l'utente voleva vedere my-bookings, portalo l√¨
      if (widget.redirectFrom == 'my-bookings' && mounted) {
        context.go('/$slug/my-bookings');
        return;
      }

      // Altrimenti vai al booking (default o se veniva da booking)
      if (mounted) {
        context.go('/$slug/booking');
      }
    }
  }

  String _resolveAuthErrorMessage(BuildContext context, AuthState authState) {
    final l10n = context.l10n;
    switch (authState.errorCode) {
      case 'invalid_credentials':
        return l10n.authErrorInvalidCredentials;
      case 'account_disabled':
        return l10n.authErrorAccountDisabled;
      case 'token_expired':
        return l10n.authErrorTokenExpired;
      case 'token_invalid':
        return l10n.authErrorTokenInvalid;
      case 'session_revoked':
        return l10n.authErrorSessionRevoked;
      case 'email_already_exists':
        return l10n.authErrorEmailAlreadyExists;
      case 'weak_password':
        return l10n.authErrorWeakPassword;
      case 'invalid_reset_token':
        return l10n.authErrorInvalidResetToken;
      case 'reset_token_expired':
        return l10n.authErrorResetTokenExpired;
    }
    return authState.errorMessage ?? l10n.authLoginFailed;
  }

  @override
  Widget build(BuildContext context) {
    final authState = ref.watch(authProvider);
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    // Ascolta i cambiamenti di stato auth per tentare auto-login
    // quando passa da loading a unauthenticated
    ref.listen<AuthState>(authProvider, (previous, next) {
      if (previous != null &&
          (previous.status == AuthStatus.loading ||
              previous.status == AuthStatus.initial) &&
          next.status == AuthStatus.unauthenticated) {
        _tryAutoLoginOnReady();
      }
    });

    // Ascolta quando il business finisce di caricarsi per tentare auto-login
    ref.listen(currentBusinessProvider, (previous, next) {
      if (previous != null && previous.isLoading && next.hasValue) {
        _tryAutoLoginOnReady();
      }
    });

    return Scaffold(
      appBar: AppBar(
        backgroundColor: colorScheme.surface,
        surfaceTintColor: Colors.transparent,
        elevation: 0,
        scrolledUnderElevation: 0.5,
        centerTitle: true,
        title: Text(
          l10n.authLoginTitle,
          style: theme.textTheme.titleLarge?.copyWith(
            fontWeight: FontWeight.w600,
            letterSpacing: -0.3,
            color: colorScheme.onSurface,
          ),
        ),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: AutofillGroup(
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  const SizedBox(height: 32),

                  // Logo o icona
                  Icon(
                    Icons.lock_outline,
                    size: 64,
                    color: theme.colorScheme.primary,
                  ),
                  const SizedBox(height: 32),

                  // Messaggio contestuale se redirect da route protetta
                  if (widget.redirectFrom == 'my-bookings' ||
                      widget.redirectFrom == 'booking') ...[
                    Container(
                      padding: const EdgeInsets.all(16),
                      decoration: BoxDecoration(
                        color: colorScheme.primaryContainer.withOpacity(0.3),
                        borderRadius: BorderRadius.circular(12),
                        border: Border.all(
                          color: colorScheme.primary.withOpacity(0.3),
                        ),
                      ),
                      child: Row(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Icon(
                            Icons.info_outline,
                            color: colorScheme.primary,
                            size: 20,
                          ),
                          const SizedBox(width: 12),
                          Expanded(
                            child: Text(
                              widget.redirectFrom == 'my-bookings'
                                  ? l10n.authRedirectFromMyBookings
                                  : l10n.authRedirectFromBooking,
                              style: theme.textTheme.bodyMedium?.copyWith(
                                color: colorScheme.onSurface,
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(height: 24),
                  ],

                  // Email
                  TextFormField(
                    controller: _emailController,
                    keyboardType: TextInputType.emailAddress,
                    textInputAction: TextInputAction.next,
                    textCapitalization: TextCapitalization.none,
                    // Non usare autofocus: interferisce con autofill su Safari iOS
                    autocorrect: false,
                    enableSuggestions: true,
                    // Email + username per miglior compatibilit√† autofill Safari iOS
                    autofillHints: const [
                      AutofillHints.email,
                      AutofillHints.username,
                    ],
                    decoration: InputDecoration(
                      labelText: l10n.authEmail,
                      prefixIcon: const Icon(Icons.email_outlined),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      if (!value.contains('@')) {
                        return l10n.authInvalidEmail;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // Password
                  TextFormField(
                    controller: _passwordController,
                    obscureText: _obscurePassword,
                    textInputAction: TextInputAction.done,
                    enableSuggestions: false,
                    autocorrect: false,
                    autofillHints: const [AutofillHints.password],
                    onFieldSubmitted: (_) => _handleLogin(),
                    decoration: InputDecoration(
                      labelText: l10n.authPassword,
                      prefixIcon: const Icon(Icons.lock_outlined),
                      suffixIcon: IconButton(
                        icon: Icon(
                          _obscurePassword
                              ? Icons.visibility_outlined
                              : Icons.visibility_off_outlined,
                        ),
                        onPressed: () {
                          setState(() => _obscurePassword = !_obscurePassword);
                        },
                      ),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      // Nel login non validiamo la lunghezza minima,
                      // sar√† l'API a rispondere con credenziali non valide
                      return null;
                    },
                  ),
                  const SizedBox(height: 8),

                  // Ricordami e Password dimenticata
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      // Checkbox Ricordami
                      Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          SizedBox(
                            height: 24,
                            width: 24,
                            child: Checkbox(
                              value: _rememberMe,
                              onChanged: (value) {
                                setState(() => _rememberMe = value ?? true);
                              },
                            ),
                          ),
                          const SizedBox(width: 8),
                          GestureDetector(
                            onTap: () {
                              setState(() => _rememberMe = !_rememberMe);
                            },
                            child: Text(
                              l10n.authRememberMe,
                              style: theme.textTheme.bodyMedium,
                            ),
                          ),
                        ],
                      ),
                      // Password dimenticata
                      TextButton(
                        onPressed: () => _showResetPasswordDialog(context, ref),
                        child: Text(l10n.authForgotPassword),
                      ),
                    ],
                  ),
                  const SizedBox(height: 24),

                  // Errore
                  if (authState.errorMessage != null) ...[
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: theme.colorScheme.error.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Row(
                        children: [
                          Icon(
                            Icons.error_outline,
                            color: theme.colorScheme.error,
                          ),
                          const SizedBox(width: 8),
                          Expanded(
                            child: Text(
                              _resolveAuthErrorMessage(context, authState),
                              style: TextStyle(color: theme.colorScheme.error),
                            ),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(height: 16),
                  ],

                  // Bottone Login
                  ElevatedButton(
                    onPressed: authState.isLoading ? null : _handleLogin,
                    child: authState.isLoading
                        ? const SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              color: Colors.white,
                            ),
                          )
                        : Text(l10n.actionLogin),
                  ),
                  const SizedBox(height: 24),

                  // Link registrazione
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Text(l10n.authNoAccount),
                      TextButton(
                        onPressed: () {
                          final slug = ref.read(routeSlugProvider);
                          final email = _emailController.text.trim();
                          final params = <String, String>{};
                          if (email.isNotEmpty) {
                            params['email'] = email;
                          }
                          if (widget.redirectFrom != null) {
                            params['from'] = widget.redirectFrom!;
                          }
                          final query = params.entries
                              .map(
                                (e) =>
                                    '${e.key}=${Uri.encodeComponent(e.value)}',
                              )
                              .join('&');
                          context.go(
                            '/$slug/register${query.isNotEmpty ? '?$query' : ''}',
                          );
                        },
                        child: Text(l10n.actionRegister),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  void _showResetPasswordDialog(BuildContext context, WidgetRef ref) {
    final emailController = TextEditingController();
    final l10n = context.l10n;
    final parentContext = context;

    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: Text(l10n.authResetPasswordTitle),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(l10n.authResetPasswordMessage),
            const SizedBox(height: 16),
            TextField(
              controller: emailController,
              keyboardType: TextInputType.emailAddress,
              decoration: InputDecoration(
                labelText: l10n.authEmail,
                prefixIcon: const Icon(Icons.email_outlined),
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(dialogContext),
            child: Text(l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () async {
              final email = emailController.text.trim();
              if (email.isEmpty) return;

              // Chiudi il dialog prima di fare la chiamata
              Navigator.pop(dialogContext);

              // Ottieni businessId - se non disponibile, prova ad aspettare
              var businessId = ref.read(currentBusinessIdProvider);

              // Se businessId √® null, attendi il caricamento del business
              if (businessId == null) {
                final businessAsync = await ref.read(
                  currentBusinessProvider.future,
                );
                businessId = businessAsync?.id;
              }

              // Verifica businessId
              if (businessId == null) {
                if (parentContext.mounted) {
                  await FeedbackDialog.showError(
                    parentContext,
                    title: l10n.errorTitle,
                    message: l10n.authResetPasswordError,
                  );
                }
                return;
              }

              try {
                await ref
                    .read(authProvider.notifier)
                    .resetPassword(businessId: businessId, email: email);

                if (parentContext.mounted) {
                  await FeedbackDialog.showSuccess(
                    parentContext,
                    title: l10n.authResetPasswordTitle,
                    message: l10n.authResetPasswordSuccess,
                  );
                }
              } on ApiException catch (e) {
                if (parentContext.mounted) {
                  // Messaggio specifico se email non trovata
                  final message = e.code == 'email_not_found'
                      ? l10n.authResetPasswordEmailNotFound
                      : l10n.authResetPasswordError;
                  await FeedbackDialog.showError(
                    parentContext,
                    title: l10n.errorTitle,
                    message: message,
                  );
                }
              } catch (e) {
                if (parentContext.mounted) {
                  await FeedbackDialog.showError(
                    parentContext,
                    title: l10n.errorTitle,
                    message: l10n.authResetPasswordError,
                  );
                }
              }
            },
            child: Text(l10n.authResetPasswordSend),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/auth/presentation/web_login_redirect_screen.dart ---
import 'package:flutter/material.dart';

import '../../../core/navigation/native_login_redirect.dart';

class WebLoginRedirectScreen extends StatefulWidget {
  const WebLoginRedirectScreen({super.key, required this.slug, this.from});

  final String slug;
  final String? from;

  @override
  State<WebLoginRedirectScreen> createState() => _WebLoginRedirectScreenState();
}

class _WebLoginRedirectScreenState extends State<WebLoginRedirectScreen> {
  bool _redirectStarted = false;

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    if (_redirectStarted) return;
    _redirectStarted = true;
    WidgetsBinding.instance.addPostFrameCallback((_) {
      redirectToNativeLogin(slug: widget.slug, from: widget.from);
    });
  }

  @override
  Widget build(BuildContext context) {
    return const Scaffold(body: Center(child: CircularProgressIndicator()));
  }
}
--- FILE: lib/features/auth/presentation/reset_password_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../app/providers/route_slug_provider.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../../core/network/api_client.dart';
import '../../../core/widgets/feedback_dialog.dart';
import '../providers/auth_provider.dart';

class ResetPasswordScreen extends ConsumerStatefulWidget {
  final String token;

  const ResetPasswordScreen({required this.token, super.key});

  @override
  ConsumerState<ResetPasswordScreen> createState() =>
      _ResetPasswordScreenState();
}

class _ResetPasswordScreenState extends ConsumerState<ResetPasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  bool _obscurePassword = true;
  bool _obscureConfirmPassword = true;
  bool _isLoading = false;

  @override
  void dispose() {
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  Future<void> _handleResetPassword() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      await ref
          .read(authProvider.notifier)
          .resetPasswordWithToken(
            token: widget.token,
            newPassword: _passwordController.text,
          );

      if (mounted) {
        await FeedbackDialog.showSuccess(
          context,
          title: context.l10n.authResetPasswordConfirmTitle,
          message: context.l10n.authResetPasswordConfirmSuccess,
        );
        // Redirect al login del business
        if (mounted) {
          final slug = ref.read(routeSlugProvider);
          if (slug != null) {
            context.go('/$slug/login');
          } else {
            context.go('/');
          }
        }
      }
    } on ApiException catch (e) {
      if (mounted) {
        await FeedbackDialog.showError(
          context,
          title: context.l10n.errorTitle,
          message: _resolveResetPasswordError(context, e.code),
        );
      }
    } catch (e) {
      if (mounted) {
        await FeedbackDialog.showError(
          context,
          title: context.l10n.errorTitle,
          message: context.l10n.authResetPasswordConfirmError,
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  String _resolveResetPasswordError(BuildContext context, String errorCode) {
    final l10n = context.l10n;
    switch (errorCode) {
      case 'invalid_reset_token':
        return l10n.authErrorInvalidResetToken;
      case 'reset_token_expired':
        return l10n.authErrorResetTokenExpired;
      case 'weak_password':
        return l10n.authErrorWeakPassword;
    }
    return l10n.authResetPasswordConfirmError;
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Scaffold(
      appBar: AppBar(
        backgroundColor: colorScheme.surface,
        surfaceTintColor: Colors.transparent,
        elevation: 0,
        scrolledUnderElevation: 0.5,
        centerTitle: true,
        automaticallyImplyLeading: false,
        title: Text(
          l10n.authResetPasswordConfirmTitle,
          style: theme.textTheme.titleLarge?.copyWith(
            fontWeight: FontWeight.w600,
            letterSpacing: -0.3,
            color: colorScheme.onSurface,
          ),
        ),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                const SizedBox(height: 32),

                // Icon
                Icon(
                  Icons.lock_reset,
                  size: 64,
                  color: theme.colorScheme.primary,
                ),
                const SizedBox(height: 16),

                // Message
                Text(
                  l10n.authResetPasswordConfirmMessage,
                  style: theme.textTheme.bodyLarge,
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 32),

                // New password
                TextFormField(
                  controller: _passwordController,
                  obscureText: _obscurePassword,
                  textInputAction: TextInputAction.next,
                  decoration: InputDecoration(
                    labelText: l10n.authNewPassword,
                    prefixIcon: const Icon(Icons.lock_outlined),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscurePassword
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(() => _obscurePassword = !_obscurePassword);
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    if (value.length < 8) {
                      return l10n.authPasswordTooShort;
                    }
                    if (!RegExp(r'[A-Z]').hasMatch(value) ||
                        !RegExp(r'[a-z]').hasMatch(value) ||
                        !RegExp(r'[0-9]').hasMatch(value)) {
                      return l10n.authPasswordRequirements;
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // Confirm password
                TextFormField(
                  controller: _confirmPasswordController,
                  obscureText: _obscureConfirmPassword,
                  textInputAction: TextInputAction.done,
                  decoration: InputDecoration(
                    labelText: l10n.authConfirmPassword,
                    prefixIcon: const Icon(Icons.lock_outlined),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscureConfirmPassword
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(
                          () => _obscureConfirmPassword =
                              !_obscureConfirmPassword,
                        );
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    if (value != _passwordController.text) {
                      return l10n.authPasswordMismatch;
                    }
                    return null;
                  },
                  onFieldSubmitted: (_) => _handleResetPassword(),
                ),
                const SizedBox(height: 32),

                // Submit button
                FilledButton(
                  onPressed: _isLoading ? null : _handleResetPassword,
                  child: _isLoading
                      ? const SizedBox(
                          height: 20,
                          width: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : Text(l10n.actionConfirm),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/providers/business_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'business_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning
/// Provider per il business corrente (caricato da slug nel path URL)
///
/// L'URL segue il pattern: /{slug}/booking, /{slug}/login, ecc.
/// Il router estrae lo slug e lo aggiorna in routeSlugProvider.
/// Questo provider reagisce ai cambi di slug e carica il business.

@ProviderFor(CurrentBusiness)
const currentBusinessProvider = CurrentBusinessProvider._();

/// Provider per il business corrente (caricato da slug nel path URL)
///
/// L'URL segue il pattern: /{slug}/booking, /{slug}/login, ecc.
/// Il router estrae lo slug e lo aggiorna in routeSlugProvider.
/// Questo provider reagisce ai cambi di slug e carica il business.
final class CurrentBusinessProvider
    extends $AsyncNotifierProvider<CurrentBusiness, Business?> {
  /// Provider per il business corrente (caricato da slug nel path URL)
  ///
  /// L'URL segue il pattern: /{slug}/booking, /{slug}/login, ecc.
  /// Il router estrae lo slug e lo aggiorna in routeSlugProvider.
  /// Questo provider reagisce ai cambi di slug e carica il business.
  const CurrentBusinessProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'currentBusinessProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$currentBusinessHash();

  @$internal
  @override
  CurrentBusiness create() => CurrentBusiness();
}

String _$currentBusinessHash() => r'2f00cc58e347ca0a27ea6647bd55565535f95823';

/// Provider per il business corrente (caricato da slug nel path URL)
///
/// L'URL segue il pattern: /{slug}/booking, /{slug}/login, ecc.
/// Il router estrae lo slug e lo aggiorna in routeSlugProvider.
/// Questo provider reagisce ai cambi di slug e carica il business.

abstract class _$CurrentBusiness extends $AsyncNotifier<Business?> {
  FutureOr<Business?> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<AsyncValue<Business?>, Business?>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<Business?>, Business?>,
              AsyncValue<Business?>,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Provider per l'ID del business corrente (sincrono, utility)

@ProviderFor(CurrentBusinessId)
const currentBusinessIdProvider = CurrentBusinessIdProvider._();

/// Provider per l'ID del business corrente (sincrono, utility)
final class CurrentBusinessIdProvider
    extends $NotifierProvider<CurrentBusinessId, int?> {
  /// Provider per l'ID del business corrente (sincrono, utility)
  const CurrentBusinessIdProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'currentBusinessIdProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$currentBusinessIdHash();

  @$internal
  @override
  CurrentBusinessId create() => CurrentBusinessId();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(int? value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<int?>(value),
    );
  }
}

String _$currentBusinessIdHash() => r'dbb21b4e931947e9e1f0a0e7d3927a478d463ae0';

/// Provider per l'ID del business corrente (sincrono, utility)

abstract class _$CurrentBusinessId extends $Notifier<int?> {
  int? build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<int?, int?>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<int?, int?>,
              int?,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Provider per verificare se il business slug √® valido
/// (slug presente e business trovato nel database)

@ProviderFor(IsBusinessValid)
const isBusinessValidProvider = IsBusinessValidProvider._();

/// Provider per verificare se il business slug √® valido
/// (slug presente e business trovato nel database)
final class IsBusinessValidProvider
    extends $NotifierProvider<IsBusinessValid, bool> {
  /// Provider per verificare se il business slug √® valido
  /// (slug presente e business trovato nel database)
  const IsBusinessValidProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'isBusinessValidProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$isBusinessValidHash();

  @$internal
  @override
  IsBusinessValid create() => IsBusinessValid();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(bool value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<bool>(value),
    );
  }
}

String _$isBusinessValidHash() => r'4d0814c4ad8b342b9ca7225311cb5e49a929041e';

/// Provider per verificare se il business slug √® valido
/// (slug presente e business trovato nel database)

abstract class _$IsBusinessValid extends $Notifier<bool> {
  bool build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<bool, bool>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<bool, bool>,
              bool,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Provider semplice per lo slug corrente (letto dal path URL)

@ProviderFor(businessSlug)
const businessSlugProvider = BusinessSlugProvider._();

/// Provider semplice per lo slug corrente (letto dal path URL)

final class BusinessSlugProvider
    extends $FunctionalProvider<String?, String?, String?>
    with $Provider<String?> {
  /// Provider semplice per lo slug corrente (letto dal path URL)
  const BusinessSlugProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'businessSlugProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$businessSlugHash();

  @$internal
  @override
  $ProviderElement<String?> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  String? create(Ref ref) {
    return businessSlug(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(String? value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<String?>(value),
    );
  }
}

String _$businessSlugHash() => r'2b426e8d5b02f0bf413dc03053031703750be5df';

/// Provider per verificare se siamo su un sottodominio business

@ProviderFor(isBusinessSubdomain)
const isBusinessSubdomainProvider = IsBusinessSubdomainProvider._();

/// Provider per verificare se siamo su un sottodominio business

final class IsBusinessSubdomainProvider
    extends $FunctionalProvider<bool, bool, bool>
    with $Provider<bool> {
  /// Provider per verificare se siamo su un sottodominio business
  const IsBusinessSubdomainProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'isBusinessSubdomainProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$isBusinessSubdomainHash();

  @$internal
  @override
  $ProviderElement<bool> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  bool create(Ref ref) {
    return isBusinessSubdomain(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(bool value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<bool>(value),
    );
  }
}

String _$isBusinessSubdomainHash() =>
    r'7af66aeaae959e3aa4b1de252d5328627d90c0a1';

/// Provider che verifica se l'utente √® autenticato per un business DIVERSO
/// da quello corrente (basato su URL slug).
///
/// Restituisce:
/// - `null` se l'utente non √® autenticato o dati non ancora caricati
/// - `true` se l'utente √® autenticato per un business DIVERSO
/// - `false` se l'utente √® autenticato per lo STESSO business o non autenticato
///
/// Utile per mostrare un avviso quando l'utente naviga su un business
/// diverso da quello per cui si √® autenticato.

@ProviderFor(IsAuthenticatedForDifferentBusiness)
const isAuthenticatedForDifferentBusinessProvider =
    IsAuthenticatedForDifferentBusinessProvider._();

/// Provider che verifica se l'utente √® autenticato per un business DIVERSO
/// da quello corrente (basato su URL slug).
///
/// Restituisce:
/// - `null` se l'utente non √® autenticato o dati non ancora caricati
/// - `true` se l'utente √® autenticato per un business DIVERSO
/// - `false` se l'utente √® autenticato per lo STESSO business o non autenticato
///
/// Utile per mostrare un avviso quando l'utente naviga su un business
/// diverso da quello per cui si √® autenticato.
final class IsAuthenticatedForDifferentBusinessProvider
    extends $AsyncNotifierProvider<IsAuthenticatedForDifferentBusiness, bool> {
  /// Provider che verifica se l'utente √® autenticato per un business DIVERSO
  /// da quello corrente (basato su URL slug).
  ///
  /// Restituisce:
  /// - `null` se l'utente non √® autenticato o dati non ancora caricati
  /// - `true` se l'utente √® autenticato per un business DIVERSO
  /// - `false` se l'utente √® autenticato per lo STESSO business o non autenticato
  ///
  /// Utile per mostrare un avviso quando l'utente naviga su un business
  /// diverso da quello per cui si √® autenticato.
  const IsAuthenticatedForDifferentBusinessProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'isAuthenticatedForDifferentBusinessProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() =>
      _$isAuthenticatedForDifferentBusinessHash();

  @$internal
  @override
  IsAuthenticatedForDifferentBusiness create() =>
      IsAuthenticatedForDifferentBusiness();
}

String _$isAuthenticatedForDifferentBusinessHash() =>
    r'f5d1cb4db2d0827c8cb31f2a8bb0be419d3b11ee';

/// Provider che verifica se l'utente √® autenticato per un business DIVERSO
/// da quello corrente (basato su URL slug).
///
/// Restituisce:
/// - `null` se l'utente non √® autenticato o dati non ancora caricati
/// - `true` se l'utente √® autenticato per un business DIVERSO
/// - `false` se l'utente √® autenticato per lo STESSO business o non autenticato
///
/// Utile per mostrare un avviso quando l'utente naviga su un business
/// diverso da quello per cui si √® autenticato.

abstract class _$IsAuthenticatedForDifferentBusiness
    extends $AsyncNotifier<bool> {
  FutureOr<bool> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<AsyncValue<bool>, bool>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<bool>, bool>,
              AsyncValue<bool>,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/features/booking/providers/my_bookings_provider.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '/core/models/booking_item.dart';
import '/core/models/location.dart';
import '/core/models/service_package.dart';
import '/core/network/api_client.dart';
import '/core/network/network_providers.dart';
import '/features/booking/providers/locations_provider.dart';

part 'my_bookings_provider.g.dart';

/// Stato delle prenotazioni utente (upcoming + past)
class MyBookingsState {
  final List<BookingItem> upcoming;
  final List<BookingItem> past;
  final bool isLoading;
  final String? error;
  final String? errorCode;

  const MyBookingsState({
    this.upcoming = const [],
    this.past = const [],
    this.isLoading = false,
    this.error,
    this.errorCode,
  });

  MyBookingsState copyWith({
    List<BookingItem>? upcoming,
    List<BookingItem>? past,
    bool? isLoading,
    String? error,
    String? errorCode,
  }) {
    return MyBookingsState(
      upcoming: upcoming ?? this.upcoming,
      past: past ?? this.past,
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
      errorCode: errorCode ?? this.errorCode,
    );
  }
}

@riverpod
class MyBookings extends _$MyBookings {
  @override
  MyBookingsState build() {
    return const MyBookingsState();
  }

  List<BookingItem> _withoutReplaced(List<BookingItem> items) =>
      items.where((b) => b.status != 'replaced').toList();

  /// Carica le prenotazioni utente da API
  Future<void> loadBookings() async {
    state = state.copyWith(isLoading: true, error: null, errorCode: null);

    try {
      final apiClient = ref.read(apiClientProvider);
      final response = await apiClient.getCustomerBookings();

      final locationsAsync = ref.read(locationsProvider);
      final locationNames = <int, String>{};
      final locations = locationsAsync.value ?? const <Location>[];
      for (final location in locations) {
        locationNames[location.id] = location.name;
      }

      final upcomingJson = response['upcoming'] as List<dynamic>? ?? [];
      final pastJson = response['past'] as List<dynamic>? ?? [];

      final packagesByLocation = await _loadPackagesByLocation(apiClient, [
        ...upcomingJson,
        ...pastJson,
      ]);

      final upcoming = upcomingJson
          .map(
            (json) => _fromCustomerBooking(
              json as Map<String, dynamic>,
              locationNames: locationNames,
              packagesByLocation: packagesByLocation,
            ),
          )
          .where((b) => b.status != 'replaced')
          .toList();

      final past = pastJson
          .map(
            (json) => _fromCustomerBooking(
              json as Map<String, dynamic>,
              locationNames: locationNames,
              packagesByLocation: packagesByLocation,
            ),
          )
          .where((b) => b.status != 'replaced')
          .toList();

      state = MyBookingsState(
        upcoming: _withoutReplaced(upcoming),
        past: _withoutReplaced(past),
        isLoading: false,
      );
    } on ApiException catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.message,
        errorCode: e.code,
      );
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }

  /// Cancella una prenotazione (DELETE /v1/customer/bookings/{id})
  Future<bool> cancelBooking(int locationId, int bookingId) async {
    try {
      final apiClient = ref.read(apiClientProvider);
      await apiClient.customerDeleteBooking(bookingId);

      // Ricarica le prenotazioni - NON usiamo loadBookings() che setta isLoading
      // perch√© il widget ha gi√† il suo indicatore di loading per la cancellazione
      await _refreshBookingsAfterChange();
      return true;
    } on ApiException catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.message,
        errorCode: e.code,
      );
      return false;
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
      return false;
    }
  }

  /// Ricarica le prenotazioni senza mostrare loading globale
  Future<void> _refreshBookingsAfterChange() async {
    try {
      final apiClient = ref.read(apiClientProvider);
      final response = await apiClient.getCustomerBookings();

      final locationsAsync = ref.read(locationsProvider);
      final locationNames = <int, String>{};
      final locations = locationsAsync.value ?? const <Location>[];
      for (final location in locations) {
        locationNames[location.id] = location.name;
      }

      final upcomingJson = response['upcoming'] as List<dynamic>? ?? [];
      final pastJson = response['past'] as List<dynamic>? ?? [];

      final packagesByLocation = await _loadPackagesByLocation(apiClient, [
        ...upcomingJson,
        ...pastJson,
      ]);

      final upcoming = upcomingJson
          .map(
            (json) => _fromCustomerBooking(
              json as Map<String, dynamic>,
              locationNames: locationNames,
              packagesByLocation: packagesByLocation,
            ),
          )
          .where((b) => b.status != 'replaced')
          .toList();

      final past = pastJson
          .map(
            (json) => _fromCustomerBooking(
              json as Map<String, dynamic>,
              locationNames: locationNames,
              packagesByLocation: packagesByLocation,
            ),
          )
          .where((b) => b.status != 'replaced')
          .toList();

      state = MyBookingsState(
        upcoming: _withoutReplaced(upcoming),
        past: _withoutReplaced(past),
        isLoading: false,
      );
    } on ApiException catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.message,
        errorCode: e.code,
      );
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }

  /// Modifica una prenotazione (PUT /v1/customer/bookings/{id})
  Future<bool> rescheduleBooking({
    required int locationId,
    required int bookingId,
    required String newStartTime,
    String? notes,
  }) async {
    try {
      final apiClient = ref.read(apiClientProvider);
      final updated = await apiClient.customerUpdateBooking(
        bookingId: bookingId,
        startTime: newStartTime,
        notes: notes,
      );

      final locationsAsync = ref.read(locationsProvider);
      final locationNames = <int, String>{};
      final locations = locationsAsync.value ?? const <Location>[];
      for (final location in locations) {
        locationNames[location.id] = location.name;
      }

      final packagesByLocation = await _loadPackagesByLocation(apiClient, [
        updated,
      ]);
      final updatedBooking = _fromCustomerBooking(
        updated,
        locationNames: locationNames,
        packagesByLocation: packagesByLocation,
      );

      final nextUpcoming = state.upcoming
          .where((b) => b.id != bookingId)
          .toList();
      final nextPast = state.past.where((b) => b.id != bookingId).toList();
      final locationNow = ref.read(locationNowProvider);

      if (updatedBooking.isUpcomingAt(locationNow)) {
        nextUpcoming.insert(0, updatedBooking);
      } else {
        nextPast.insert(0, updatedBooking);
      }

      state = state.copyWith(
        upcoming: _withoutReplaced(nextUpcoming),
        past: _withoutReplaced(nextPast),
        error: null,
      );
      return true;
    } on ApiException catch (e) {
      state = state.copyWith(error: e.message, errorCode: e.code);
      return false;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return false;
    }
  }

  /// Sostituisce una prenotazione (POST /v1/customer/bookings/{id}/replace)
  /// Usa il pattern atomic replace: l'originale diventa 'replaced', viene creata una nuova
  Future<({bool success, int? newBookingId})> replaceBooking({
    required int originalBookingId,
    required int locationId,
    required List<int> serviceIds,
    required String startTime,
    required String idempotencyKey,
    int? staffId,
    String? notes,
    String? reason,
  }) async {
    try {
      final apiClient = ref.read(apiClientProvider);
      final response = await apiClient.customerReplaceBooking(
        bookingId: originalBookingId,
        idempotencyKey: idempotencyKey,
        locationId: locationId,
        serviceIds: serviceIds,
        startTime: startTime,
        staffId: staffId,
        notes: notes,
        reason: reason,
      );

      // L'API restituisce { status, original_booking_id, new_booking_id, booking: {...} }
      final bookingData =
          response['booking'] as Map<String, dynamic>? ?? response;

      final locationsAsync = ref.read(locationsProvider);
      final locationNames = <int, String>{};
      final locations = locationsAsync.value ?? const <Location>[];
      for (final location in locations) {
        locationNames[location.id] = location.name;
      }

      final packagesByLocation = await _loadPackagesByLocation(apiClient, [
        bookingData,
      ]);
      final newBooking = _fromCustomerBooking(
        bookingData,
        locationNames: locationNames,
        packagesByLocation: packagesByLocation,
      );

      // Dopo replace la prenotazione originale diventa 'replaced': ricarichiamo la lista
      // per riflettere lo stato aggiornato dal server.
      await _refreshBookingsAfterChange();

      return (success: true, newBookingId: newBooking.id);
    } on ApiException catch (e) {
      state = state.copyWith(error: e.message, errorCode: e.code);
      return (success: false, newBookingId: null);
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return (success: false, newBookingId: null);
    }
  }
}

BookingItem _fromCustomerBooking(
  Map<String, dynamic> json, {
  required Map<int, String> locationNames,
  required Map<int, List<ServicePackage>> packagesByLocation,
}) {
  final items = (json['items'] as List<dynamic>? ?? [])
      .cast<Map<String, dynamic>>();
  final firstItem = items.isNotEmpty ? items.first : const <String, dynamic>{};
  final lastItem = items.isNotEmpty ? items.last : const <String, dynamic>{};

  final locationId =
      json['location_id'] as int? ?? firstItem['location_id'] as int? ?? 0;
  // FIX BUG CRITICO: usa location_name dalla response API invece che dal provider
  // Il provider locationNames puo essere vuoto o riferirsi al business corrente dell'URL
  final locationName =
      json['location_name'] as String? ?? locationNames[locationId] ?? '';

  // FIX BUG CRITICO: usa business_name dalla response API invece che dal provider URL
  // Questo evita di mostrare il nome del business sbagliato quando l'utente
  // naviga su un business diverso da quello delle sue prenotazioni
  final businessName = json['business_name'] as String? ?? '';

  final startTimeValue = firstItem['start_time'] ?? json['start_time'];
  final endTimeValue =
      lastItem['end_time'] ?? firstItem['end_time'] ?? json['end_time'];
  final startTime = startTimeValue is String
      ? DateTime.parse(startTimeValue)
      : DateTime(1970, 1, 1);
  final endTime = endTimeValue is String
      ? DateTime.parse(endTimeValue)
      : startTime;

  final serviceIds = items
      .map((item) => item['service_id'])
      .whereType<int>()
      .toList();

  final serviceNameById = <int, String>{};
  for (final item in items) {
    final serviceId = item['service_id'];
    if (serviceId is! int || serviceNameById.containsKey(serviceId)) {
      continue;
    }
    final name = item['service_name'] ?? item['service_name_snapshot'];
    if (name is String && name.isNotEmpty) {
      serviceNameById[serviceId] = name;
    }
  }

  final remainingServiceIds = serviceIds.toSet();
  final packageNames = <String>[];
  final packages = packagesByLocation[locationId] ?? const <ServicePackage>[];
  final sortedPackages = [...packages]
    ..sort(
      (a, b) =>
          b.orderedServiceIds.length.compareTo(a.orderedServiceIds.length),
    );
  for (final package in sortedPackages) {
    if (!package.isActive || package.isBroken) continue;
    final packageServiceIds = package.orderedServiceIds;
    if (packageServiceIds.isEmpty) continue;
    if (packageServiceIds.every(remainingServiceIds.contains)) {
      packageNames.add(package.name);
      for (final id in packageServiceIds) {
        remainingServiceIds.remove(id);
      }
    }
  }

  final remainingServiceNames = <String>[];
  for (final item in items) {
    final serviceId = item['service_id'];
    if (serviceId is! int || !remainingServiceIds.contains(serviceId)) {
      continue;
    }
    final name = item['service_name'] ?? item['service_name_snapshot'];
    if (name is String && name.isNotEmpty) {
      remainingServiceNames.add(name);
      remainingServiceIds.remove(serviceId);
    }
  }

  final serviceNames = [...packageNames, ...remainingServiceNames];

  return BookingItem(
    id: json['id'] as int? ?? json['booking_id'] as int,
    businessId: json['business_id'] as int,
    businessName: businessName,
    locationId: locationId,
    locationName: locationName,
    locationAddress: json['location_address'] as String?,
    locationCity: json['location_city'] as String?,
    serviceNames: serviceNames,
    serviceIds: serviceIds,
    staffId: items.isNotEmpty ? items.first['staff_id'] as int? : null,
    staffName: items.isNotEmpty
        ? items.first['staff_display_name'] as String?
        : null,
    startTime: startTime,
    endTime: endTime,
    totalPrice: (json['total_price'] as num?)?.toDouble() ?? 0.0,
    notes: json['notes'] as String?,
    canModify: json['can_modify'] as bool? ?? false,
    canModifyUntil: json['can_modify_until'] != null
        ? DateTime.parse(json['can_modify_until'] as String)
        : null,
    canModifyUntilRaw: json['can_modify_until'] as String?,
    status: json['status'] as String? ?? 'confirmed',
  );
}

Future<Map<int, List<ServicePackage>>> _loadPackagesByLocation(
  ApiClient apiClient,
  List<dynamic> bookingsJson,
) async {
  final locationIds = <int>{};
  for (final entry in bookingsJson) {
    if (entry is! Map<String, dynamic>) continue;
    final items = (entry['items'] as List<dynamic>? ?? const [])
        .cast<Map<String, dynamic>>();
    final firstItem = items.isNotEmpty
        ? items.first
        : const <String, dynamic>{};
    final locationId =
        entry['location_id'] as int? ?? firstItem['location_id'] as int? ?? 0;
    if (locationId > 0) {
      locationIds.add(locationId);
    }
  }

  final packagesByLocation = <int, List<ServicePackage>>{};
  for (final locationId in locationIds) {
    final response = await apiClient.getServicePackages(locationId);
    final packagesJson = response['packages'] as List<dynamic>? ?? [];
    final packages = packagesJson
        .map((json) => ServicePackage.fromJson(json as Map<String, dynamic>))
        .toList();
    packagesByLocation[locationId] = packages;
  }

  return packagesByLocation;
}
--- FILE: lib/features/booking/providers/booking_provider.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod/legacy.dart';

import '../../../core/models/booking_request.dart';
import '../../../core/models/location.dart';
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/models/service_package.dart';
import '../../../core/models/staff.dart';
import '../../../core/models/time_slot.dart';
import '../../../core/network/api_client.dart';
import '../../../core/network/network_providers.dart';
import '../../../core/services/pending_booking_storage.dart';
import '../data/booking_repository.dart';
import '../domain/booking_config.dart';
import 'business_provider.dart';
import 'locations_provider.dart';

/// Provider per il repository
final bookingRepositoryProvider = Provider<BookingRepository>((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return BookingRepository(apiClient);
});

/// Provider per la configurazione del booking (dinamico basato sul business corrente)
final bookingConfigProvider = Provider<BookingConfig>((ref) {
  final businessAsync = ref.watch(currentBusinessProvider);
  final effectiveLocation = ref.watch(effectiveLocationProvider);

  // Se il business √® ancora in caricamento o ha errori, ritorna placeholder
  if (businessAsync.isLoading || businessAsync.hasError) {
    return placeholderBookingConfig;
  }

  final business = businessAsync.value;
  if (business == null) {
    // Business non trovato (slug non valido)
    return placeholderBookingConfig;
  }

  // Se il business non ha una location di default, segnala che esiste ma non √® attivo
  final locationId = business.defaultLocationId;
  if (locationId == null) {
    return BookingConfig(
      allowStaffSelection: true,
      businessId: business.id,
      locationId: 0,
      businessExistsButNotActive: true,
    );
  }

  final allowStaffSelection = effectiveLocation != null
      ? effectiveLocation.allowCustomerChooseStaff
      : true;

  return BookingConfig(
    allowStaffSelection: allowStaffSelection,
    businessId: business.id,
    locationId: locationId,
  );
});

/// Provider per la location ID effettiva (da location selezionata o default)
final effectiveLocationIdProvider = Provider<int>((ref) {
  final effectiveLocation = ref.watch(effectiveLocationProvider);
  if (effectiveLocation != null) {
    return effectiveLocation.id;
  }
  // Fallback alla config
  return ref.watch(bookingConfigProvider).locationId;
});

/// Provider per il numero massimo di giorni prenotabili in anticipo
final maxBookingAdvanceDaysProvider = Provider<int>((ref) {
  final effectiveLocation = ref.watch(effectiveLocationProvider);
  if (effectiveLocation != null) {
    return effectiveLocation.maxBookingAdvanceDays;
  }

  final locationsAsync = ref.watch(locationsProvider);
  final fallbackLocationId = ref.watch(bookingConfigProvider).locationId;
  return locationsAsync.maybeWhen(
        data: (locations) {
          if (locations.isEmpty) return 90;
          final fallback = locations.firstWhere(
            (l) => l.id == fallbackLocationId,
            orElse: () => locations.first,
          );
          return fallback.maxBookingAdvanceDays;
        },
        orElse: () => 90,
      ) ??
      90;
});

/// Step del flow di prenotazione
enum BookingStep { location, services, staff, dateTime, summary, confirmation }

/// Stato del flow di prenotazione
class BookingFlowState {
  final BookingStep currentStep;
  final BookingRequest request;
  final bool isLoading;
  final String? errorMessage;
  final String? errorCode;
  final String? confirmedBookingId;
  final bool isStaffAutoSelected;

  const BookingFlowState({
    this.currentStep = BookingStep.location,
    this.request = const BookingRequest(),
    this.isLoading = false,
    this.errorMessage,
    this.errorCode,
    this.confirmedBookingId,
    this.isStaffAutoSelected = false,
  });

  bool get canGoBack =>
      currentStep.index > 0 && currentStep != BookingStep.confirmation;

  bool get canGoNext {
    switch (currentStep) {
      case BookingStep.location:
        return true; // Gestito dal provider
      case BookingStep.services:
        return request.services.isNotEmpty;
      case BookingStep.staff:
        return true; // Staff opzionale
      case BookingStep.dateTime:
        return request.selectedSlot != null;
      case BookingStep.summary:
        return request.isComplete;
      case BookingStep.confirmation:
        return false;
    }
  }

  BookingFlowState copyWith({
    BookingStep? currentStep,
    BookingRequest? request,
    bool? isLoading,
    String? errorMessage,
    String? errorCode,
    String? confirmedBookingId,
    bool clearError = false,
    bool? isStaffAutoSelected,
  }) => BookingFlowState(
    currentStep: currentStep ?? this.currentStep,
    request: request ?? this.request,
    isLoading: isLoading ?? this.isLoading,
    errorMessage: clearError ? null : (errorMessage ?? this.errorMessage),
    errorCode: clearError ? null : (errorCode ?? this.errorCode),
    confirmedBookingId: confirmedBookingId ?? this.confirmedBookingId,
    isStaffAutoSelected: isStaffAutoSelected ?? this.isStaffAutoSelected,
  );
}

class BookingTotals {
  final double totalPrice;
  final int totalDurationMinutes;
  final List<ServicePackage> selectedPackages;
  final Set<int> coveredServiceIds;
  final int selectedItemCount;

  const BookingTotals({
    required this.totalPrice,
    required this.totalDurationMinutes,
    required this.selectedPackages,
    required this.coveredServiceIds,
    required this.selectedItemCount,
  });
}

/// Provider principale per il flow di prenotazione
final bookingFlowProvider =
    NotifierProvider<BookingFlowNotifier, BookingFlowState>(
      BookingFlowNotifier.new,
    );

class BookingFlowNotifier extends Notifier<BookingFlowState> {
  bool? _initialHasMultipleLocations;
  bool _didAutoSelectService = false;

  @override
  BookingFlowState build() {
    // Determina lo step iniziale in base al numero di locations
    // Usa ref.read per non ricostruire quando cambia
    final hasMultipleLocations = ref.read(hasMultipleLocationsProvider);

    // Memorizza il valore iniziale (quando i dati sono disponibili)
    // per evitare reset quando il provider viene rivalutato
    _initialHasMultipleLocations ??= hasMultipleLocations;

    // Ascolta cambiamenti di hasMultipleLocations solo per aggiornare lo step iniziale
    // se siamo ancora allo step iniziale e non abbiamo ancora dati
    ref.listen<bool>(hasMultipleLocationsProvider, (previous, next) {
      // Se √® la prima volta che riceviamo true (locations caricate)
      // e siamo ancora allo step services (default loading), vai a location
      if (previous == false &&
          next == true &&
          state.currentStep == BookingStep.services &&
          state.request.services.isEmpty) {
        state = state.copyWith(currentStep: BookingStep.location);
      }
    });

    // Auto-seleziona servizio se c'√® un solo servizio prenotabile
    ref.listen<AsyncValue<ServicesData>>(servicesDataProvider, (
      previous,
      next,
    ) {
      if (_didAutoSelectService) return;
      next.whenData((data) {
        final bookableServices = data.bookableServices;
        if (bookableServices.length == 1 && state.request.services.isEmpty) {
          _didAutoSelectService = true;
          final service = bookableServices.first;
          state = state.copyWith(
            request: state.request.copyWith(
              services: [service],
              selectedServiceIds: {service.id},
            ),
          );
        }
      });
    });

    final initialStep = hasMultipleLocations
        ? BookingStep.location
        : BookingStep.services;
    ref.listen<Location?>(effectiveLocationProvider, (previous, next) {
      if (previous?.id == next?.id) return;
      state = state.copyWith(
        request: state.request.copyWith(
          clearStaff: true,
          clearStaffSelections: true,
          clearAnyOperatorSelections: true,
          clearSlot: true,
        ),
        isStaffAutoSelected: false,
      );
    });
    ref.listen<int?>(urlLocationIdProvider, (previous, next) {
      if (previous == next) return;
      state = state.copyWith(
        request: state.request.copyWith(
          clearStaff: true,
          clearStaffSelections: true,
          clearAnyOperatorSelections: true,
          clearSlot: true,
        ),
        isStaffAutoSelected: false,
      );
    });
    return BookingFlowState(currentStep: initialStep);
  }

  BookingRepository get _repository => ref.read(bookingRepositoryProvider);
  BookingConfig get _config => ref.read(bookingConfigProvider);
  bool get _hasMultipleLocations => ref.read(hasMultipleLocationsProvider);

  /// Reset del flow
  void reset() {
    final initialStep = _hasMultipleLocations
        ? BookingStep.location
        : BookingStep.services;
    state = BookingFlowState(currentStep: initialStep);
    // Reset anche la location selezionata
    ref.read(selectedLocationProvider.notifier).clear();
    // Note: availableDatesProvider si resetta automaticamente via listeners
    // quando cambiano services/staff
  }

  /// Vai allo step successivo
  void nextStep() {
    if (!state.canGoNext) return;

    final nextIndex = state.currentStep.index + 1;
    if (nextIndex < BookingStep.values.length) {
      var nextStep = BookingStep.values[nextIndex];

      // Se c'√® una sola location, salta lo step location
      if (nextStep == BookingStep.location && !_hasMultipleLocations) {
        nextStep = BookingStep.services;
      }

      // Se staff selection √® disabilitata, salta lo step staff
      if (nextStep == BookingStep.staff && !_config.allowStaffSelection) {
        nextStep = BookingStep.dateTime;
      }
      state = state.copyWith(currentStep: nextStep, clearError: true);
      // Il prefetch viene gestito automaticamente dai listener in DateTimeStep
    }
  }

  /// Avanza dallo step servizi con auto-selezione staff se possibile
  Future<void> nextFromServicesWithAutoStaff() async {
    if (state.currentStep != BookingStep.services) {
      nextStep();
      return;
    }
    if (!_config.allowStaffSelection) {
      state = state.copyWith(
        request: state.request.copyWith(
          clearStaff: true,
          clearAnyOperatorSelections: true,
          clearSlot: true,
        ),
        isStaffAutoSelected: false,
      );
      nextStep();
      return;
    }

    final locationId = ref.read(effectiveLocationIdProvider);
    final services = state.request.services;
    final serviceIds = services.map((s) => s.id).toList();
    if (locationId <= 0 || serviceIds.isEmpty) return;

    state = state.copyWith(
      isLoading: true,
      currentStep: BookingStep.staff,
      clearError: true,
    );

    try {
      final repository = ref.read(bookingRepositoryProvider);
      final allStaff = await repository.getStaff(locationId);

      // Per ogni servizio, trova gli operatori che possono erogarlo
      final staffByService = <int, List<Staff>>{};
      for (final service in services) {
        staffByService[service.id] =
            allStaff.where((s) => s.serviceIds.contains(service.id)).toList()
              ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));
      }

      // Pre-seleziona automaticamente gli operatori per servizi con un solo operatore
      final autoSelected = <int, Staff?>{};
      var allAutoSelected = true;
      for (final service in services) {
        final staffForService = staffByService[service.id] ?? [];
        if (staffForService.length == 1) {
          autoSelected[service.id] = staffForService.first;
        } else {
          autoSelected[service.id] = null;
          allAutoSelected = false;
        }
      }

      // Se tutti i servizi hanno un solo operatore, auto-seleziona e mostra lo step
      if (allAutoSelected && services.isNotEmpty) {
        final isSingleService = services.length == 1;
        final selectedStaff = isSingleService
            ? autoSelected[services.first.id]
            : null;
        state = state.copyWith(
          request: state.request.copyWith(
            selectedStaff: selectedStaff,
            selectedStaffByService: autoSelected,
            clearSlot: true,
            anyOperatorSelected: false,
          ),
          isStaffAutoSelected: false,
          currentStep: BookingStep.staff,
        );
        return;
      }

      // Altrimenti mostra lo step staff con le pre-selezioni
      state = state.copyWith(
        request: state.request.copyWith(
          selectedStaffByService: autoSelected,
          clearSlot: true,
          anyOperatorSelected: false,
        ),
        isStaffAutoSelected: false,
        currentStep: BookingStep.staff,
      );
    } finally {
      state = state.copyWith(isLoading: false);
    }
  }

  /// Vai allo step precedente
  void previousStep() {
    if (!state.canGoBack) return;

    var prevIndex = state.currentStep.index - 1;
    var prevStep = BookingStep.values[prevIndex];

    // Se staff selection √® disabilitata, salta lo step staff
    if (prevStep == BookingStep.staff && !_config.allowStaffSelection) {
      prevIndex--;
      prevStep = BookingStep.values[prevIndex];
    }

    // Se c'√® una sola location, salta lo step location
    if (prevStep == BookingStep.location && !_hasMultipleLocations) {
      // Non andare oltre, siamo gi√† al primo step
      return;
    }

    final updatedRequest = _resetRequestForStep(prevStep);
    final shouldClearSelectedDate = _shouldClearSelectedDate(prevStep);
    final shouldResetAutoStaff = _shouldResetAutoStaff(prevStep);
    final shouldResetAvailability = _shouldResetAvailability(prevStep);

    state = state.copyWith(
      currentStep: prevStep,
      request: updatedRequest,
      clearError: true,
      isStaffAutoSelected: shouldResetAutoStaff
          ? false
          : state.isStaffAutoSelected,
    );

    // Note: availableDatesProvider si resetta automaticamente via listeners
    // quando cambiano services/staff. Resettiamo solo focusedMonth e selectedDate.
    if (shouldResetAvailability) {
      ref.read(focusedMonthProvider.notifier).state = ref.read(
        locationNowProvider,
      );
    }

    if (shouldClearSelectedDate) {
      ref.read(selectedDateProvider.notifier).state = null;
    }
  }

  /// Vai a uno step specifico
  void goToStep(BookingStep step) {
    // Non permettere di tornare allo step location se c'√® una sola location
    if (step == BookingStep.location && !_hasMultipleLocations) {
      return;
    }
    if (step.index < state.currentStep.index) {
      final updatedRequest = _resetRequestForStep(step);
      final shouldClearSelectedDate = _shouldClearSelectedDate(step);
      final shouldResetAutoStaff = _shouldResetAutoStaff(step);
      final shouldResetAvailability = _shouldResetAvailability(step);

      state = state.copyWith(
        currentStep: step,
        request: updatedRequest,
        clearError: true,
        isStaffAutoSelected: shouldResetAutoStaff
            ? false
            : state.isStaffAutoSelected,
      );

      // Note: availableDatesProvider si resetta automaticamente via listeners
      // quando cambiano services/staff. Resettiamo solo focusedMonth e selectedDate.
      if (shouldResetAvailability) {
        ref.read(focusedMonthProvider.notifier).state = ref.read(
          locationNowProvider,
        );
      }

      if (shouldClearSelectedDate) {
        ref.read(selectedDateProvider.notifier).state = null;
      }
    }
  }

  BookingRequest _resetRequestForStep(BookingStep step) {
    final request = state.request;
    switch (step) {
      case BookingStep.location:
        return request.copyWith(
          services: const [],
          selectedServiceIds: const {},
          selectedPackageIds: const {},
          selectedPackageServiceIdsByPackage: const {},
          clearStaff: true,
          clearStaffSelections: true,
          clearAnyOperatorSelections: true,
          clearSlot: true,
          clearNotes: true,
        );
      case BookingStep.services:
        return request.copyWith(
          clearStaff: true,
          clearStaffSelections: true,
          clearAnyOperatorSelections: true,
          clearSlot: true,
          clearNotes: true,
        );
      case BookingStep.staff:
        return request.copyWith(clearSlot: true, clearNotes: true);
      case BookingStep.dateTime:
        return request.copyWith(clearSlot: true, clearNotes: true);
      case BookingStep.summary:
      case BookingStep.confirmation:
        return request;
    }
  }

  bool _shouldClearSelectedDate(BookingStep step) {
    switch (step) {
      case BookingStep.location:
      case BookingStep.services:
      case BookingStep.staff:
      case BookingStep.dateTime:
        return true;
      case BookingStep.summary:
      case BookingStep.confirmation:
        return false;
    }
  }

  bool _shouldResetAutoStaff(BookingStep step) {
    switch (step) {
      case BookingStep.location:
      case BookingStep.services:
      case BookingStep.staff:
        return true;
      case BookingStep.dateTime:
      case BookingStep.summary:
      case BookingStep.confirmation:
        return false;
    }
  }

  bool _shouldResetAvailability(BookingStep step) {
    switch (step) {
      case BookingStep.location:
      case BookingStep.services:
      case BookingStep.staff:
      case BookingStep.dateTime:
        return true;
      case BookingStep.summary:
      case BookingStep.confirmation:
        return false;
    }
  }

  /// Toggle selezione servizio
  void toggleService(Service service) {
    final currentServices = List<Service>.from(state.request.services);
    final selectedServiceIds = Set<int>.from(state.request.selectedServiceIds);
    final packageServiceIds = state.request.selectedPackageServiceIds;

    final isSelected = selectedServiceIds.contains(service.id);
    if (isSelected) {
      selectedServiceIds.remove(service.id);
      if (!packageServiceIds.contains(service.id)) {
        currentServices.removeWhere((s) => s.id == service.id);
      }
    } else {
      selectedServiceIds.add(service.id);
      if (!currentServices.any((s) => s.id == service.id)) {
        currentServices.add(service);
      }
    }

    final shouldClearStaff = !_config.allowStaffSelection;
    final updatedStaffByService =
        Map<int, Staff?>.from(state.request.selectedStaffByService)
          ..removeWhere(
            (serviceId, _) => !currentServices.any((s) => s.id == serviceId),
          );

    // Quando cambiano i servizi, resetta slot selezionato
    state = state.copyWith(
      request: state.request.copyWith(
        services: currentServices,
        selectedServiceIds: selectedServiceIds,
        selectedStaffByService: shouldClearStaff ? {} : updatedStaffByService,
        clearStaff: shouldClearStaff,
        clearAnyOperatorSelections: shouldClearStaff,
        clearSlot: true,
      ),
      clearError: true,
      isStaffAutoSelected: shouldClearStaff ? false : state.isStaffAutoSelected,
    );
  }

  /// Aggiunge servizi in ordine (usato per pacchetti)
  void addServicesFromPackage(List<Service> servicesInOrder) {
    if (servicesInOrder.isEmpty) return;

    final currentServices = List<Service>.from(state.request.services);
    for (final service in servicesInOrder) {
      if (!currentServices.any((s) => s.id == service.id)) {
        currentServices.add(service);
      }
    }

    final shouldClearStaff = !_config.allowStaffSelection;
    final updatedStaffByService =
        Map<int, Staff?>.from(state.request.selectedStaffByService)
          ..removeWhere(
            (serviceId, _) => !currentServices.any((s) => s.id == serviceId),
          );

    state = state.copyWith(
      request: state.request.copyWith(
        services: currentServices,
        selectedStaffByService: shouldClearStaff ? {} : updatedStaffByService,
        clearStaff: shouldClearStaff,
        clearAnyOperatorSelections: shouldClearStaff,
        clearSlot: true,
      ),
      clearError: true,
      isStaffAutoSelected: shouldClearStaff ? false : state.isStaffAutoSelected,
    );
  }

  /// Toggle pacchetto come selezione servizi
  void togglePackageSelection(
    ServicePackage package,
    List<Service> availableServices,
  ) {
    final serviceIds = package.orderedServiceIds;
    if (serviceIds.isEmpty) return;

    final currentServices = List<Service>.from(state.request.services);
    final selectedPackageIds = Set<int>.from(state.request.selectedPackageIds);
    final packageServicesByPackage = Map<int, List<int>>.from(
      state.request.selectedPackageServiceIdsByPackage,
    );
    final selectedServiceIds = Set<int>.from(state.request.selectedServiceIds);

    final servicesById = {for (final s in availableServices) s.id: s};
    for (final item in package.items) {
      servicesById.putIfAbsent(
        item.serviceId,
        () => _serviceFromPackageItem(package, item),
      );
    }
    if (selectedPackageIds.contains(package.id)) {
      selectedPackageIds.remove(package.id);
      packageServicesByPackage.remove(package.id);
    } else {
      selectedPackageIds.add(package.id);
      packageServicesByPackage[package.id] = List<int>.from(serviceIds);
    }

    final packageServiceIds = packageServicesByPackage.values
        .expand((ids) => ids)
        .toSet();

    currentServices.removeWhere(
      (s) =>
          !selectedServiceIds.contains(s.id) &&
          !packageServiceIds.contains(s.id),
    );

    for (final id in packageServiceIds) {
      if (!currentServices.any((s) => s.id == id)) {
        final service = servicesById[id];
        if (service != null) {
          currentServices.add(service);
        }
      }
    }

    final shouldClearStaff = !_config.allowStaffSelection;
    final updatedStaffByService =
        Map<int, Staff?>.from(state.request.selectedStaffByService)
          ..removeWhere(
            (serviceId, _) => !currentServices.any((s) => s.id == serviceId),
          );

    state = state.copyWith(
      request: state.request.copyWith(
        services: currentServices,
        selectedPackageIds: selectedPackageIds,
        selectedPackageServiceIdsByPackage: packageServicesByPackage,
        selectedStaffByService: shouldClearStaff ? {} : updatedStaffByService,
        clearStaff: shouldClearStaff,
        clearAnyOperatorSelections: shouldClearStaff,
        clearSlot: true,
      ),
      clearError: true,
      isStaffAutoSelected: shouldClearStaff ? false : state.isStaffAutoSelected,
    );
  }

  Service _serviceFromPackageItem(
    ServicePackage package,
    ServicePackageItem item,
  ) {
    final price = (item.price ?? 0).toDouble();
    final categoryId = package.categoryId;
    return Service(
      id: item.serviceId,
      businessId: _config.businessId,
      categoryId: categoryId,
      name: item.name ?? package.name,
      durationMinutes: item.durationMinutes ?? 0,
      price: price,
      isFree: price == 0,
      isBookableOnline: true,
      isActive: item.serviceIsActive && item.variantIsActive,
    );
  }

  /// Seleziona staff specifico (resetta "qualsiasi operatore")
  void selectStaff(Staff? staff) {
    // Se staff √® null, usa selectAnyOperator() invece
    if (staff == null) {
      selectAnyOperator();
      return;
    }

    state = state.copyWith(
      request: state.request.copyWith(
        selectedStaff: staff,
        selectedStaffByService: const {},
        anyOperatorSelected: false,
        clearSlot: true, // Resetta slot quando cambia staff
      ),
      clearError: true,
      isStaffAutoSelected: false,
    );
  }

  /// Seleziona staff per servizio (usato con allowMultiStaffBooking = true)
  void selectStaffForService(Service service, Staff? staff) {
    final updated = Map<int, Staff?>.from(state.request.selectedStaffByService);
    updated[service.id] = staff;
    final isSingleService = state.request.services.length == 1;
    state = state.copyWith(
      request: state.request.copyWith(
        selectedStaff: isSingleService ? staff : state.request.selectedStaff,
        selectedStaffByService: updated,
        clearStaff: isSingleService && staff == null,
        clearSlot: true,
        anyOperatorSelected: false,
      ),
      clearError: true,
      isStaffAutoSelected: false,
    );
  }

  /// Seleziona "qualsiasi operatore" (caso semplice, un solo staff per tutti i servizi)
  void selectAnyOperator() {
    state = state.copyWith(
      request: state.request.copyWith(
        selectedStaff: null,
        selectedStaffByService: const {},
        anyOperatorSelected: true,
        clearStaff: true,
        clearSlot: true,
      ),
      clearError: true,
      isStaffAutoSelected: false,
    );
  }

  /// Seleziona "qualsiasi operatore" per i servizi con pi√π operatori,
  /// ma mantiene l'operatore selezionato per i servizi con un solo operatore
  /// NOTA: Usato solo con allowMultiStaffBooking = true
  void selectAnyOperatorForAllServices(Map<int, List<Staff>> staffByService) {
    // Per i servizi con un solo operatore, mantieni quell'operatore
    final selectedStaffByService = <int, Staff?>{};
    for (final entry in staffByService.entries) {
      if (entry.value.length == 1) {
        selectedStaffByService[entry.key] = entry.value.first;
      }
    }

    state = state.copyWith(
      request: state.request.copyWith(
        selectedStaff: null,
        selectedStaffByService: selectedStaffByService,
        anyOperatorSelected: true,
        clearStaff: true,
        clearSlot: true,
      ),
      clearError: true,
      isStaffAutoSelected: false,
    );
  }

  /// Seleziona staff automaticamente e disabilita ritorno allo step staff
  void autoSelectStaff(Staff staff) {
    final services = state.request.services;
    final updated = Map<int, Staff?>.from(state.request.selectedStaffByService);
    if (services.isNotEmpty) {
      updated[services.first.id] = staff;
    }
    state = state.copyWith(
      request: state.request.copyWith(
        selectedStaff: staff,
        clearStaff: false,
        selectedStaffByService: updated,
        clearSlot: true,
        anyOperatorSelected: false,
      ),
      clearError: true,
      isStaffAutoSelected: true,
    );
  }

  /// Seleziona slot temporale
  void selectTimeSlot(TimeSlot slot) {
    state = state.copyWith(
      request: state.request.copyWith(selectedSlot: slot),
      clearError: true,
    );
  }

  /// Aggiorna note
  void updateNotes(String notes) {
    state = state.copyWith(request: state.request.copyWith(notes: notes));
  }

  /// Conferma prenotazione
  /// Ritorna:
  /// - true: prenotazione confermata con successo
  /// - false: errore generico
  /// - Lancia TokenExpiredException se il token √® scaduto (401)
  Future<bool> confirmBooking() async {
    debugPrint('[confirmBooking] isComplete=${state.request.isComplete}');
    debugPrint(
      '[confirmBooking] services=${state.request.services.map((s) => s.id).toList()}',
    );
    debugPrint(
      '[confirmBooking] selectedSlot=${state.request.selectedSlot?.startTime}',
    );
    debugPrint(
      '[confirmBooking] selectedStaff=${state.request.selectedStaff?.id}',
    );
    debugPrint(
      '[confirmBooking] selectedStaffByService=${state.request.selectedStaffByService}',
    );
    debugPrint(
      '[confirmBooking] anyOperatorSelected=${state.request.anyOperatorSelected}',
    );
    debugPrint('[confirmBooking] singleStaffId=${state.request.singleStaffId}');

    if (!state.request.isComplete) {
      debugPrint('[confirmBooking] ABORT: request not complete');
      return false;
    }

    state = state.copyWith(isLoading: true, clearError: true);

    // Salva lo stato PRIMA di tentare la conferma (per recovery in caso di 401)
    final locationId = ref.read(effectiveLocationIdProvider);
    final businessId = _config.businessId;
    final selectedLocation = ref.read(selectedLocationProvider);

    await PendingBookingStorage.save(
      PendingBookingData.fromBookingRequest(
        businessId: businessId,
        locationId: locationId,
        selectedLocation: selectedLocation,
        request: state.request,
      ),
    );

    try {
      final services = state.request.services;

      List<Map<String, dynamic>>? items;
      final shouldUseItems =
          services.length > 1 &&
          state.request.hasOnlyStaffSelectionForAllServices;
      if (shouldUseItems) {
        if (!state.request.hasStaffSelectionForAllServices) {
          state = state.copyWith(isLoading: false);
          return false;
        }
        var currentStart = state.request.selectedSlot!.startTime;
        items = [];
        for (final service in services) {
          final staff = state.request.staffForService(service.id);
          if (staff == null) {
            state = state.copyWith(isLoading: false);
            return false;
          }
          items.add({
            'service_id': service.id,
            'staff_id': staff.id,
            // Invia orario come ISO locale (NO toUtc - il backend gestisce il timezone)
            'start_time': currentStart.toIso8601String(),
          });
          currentStart = currentStart.add(
            Duration(minutes: service.durationMinutes),
          );
        }
      }

      final staffId = state.request.singleStaffId;
      // Se ci sono pi√π servizi senza selezione staff specifica,
      // trattiamo come "qualsiasi operatore" (staffId = null)
      // Questo √® valido quando:
      // - Lo step staff √® stato saltato (allowStaffSelection = false)
      // - L'utente ha selezionato "qualsiasi operatore"
      // - Non c'√® selezione per servizio
      if (!shouldUseItems && services.length > 1) {
        // OK: procedi con staffId (che sar√† null per "qualsiasi operatore")
      }

      final result = await _repository.confirmBooking(
        businessId: businessId,
        locationId: locationId,
        serviceIds: services.map((s) => s.id).toList(),
        startTime: state.request.selectedSlot!.startTime,
        staffId: staffId,
        notes: state.request.notes,
        items: items,
      );

      // Prenotazione confermata - elimina lo stato salvato
      await PendingBookingStorage.clear();

      // Estrai booking ID dalla risposta
      final bookingId =
          result['id']?.toString() ??
          result['booking_id']?.toString() ??
          'confirmed';

      state = state.copyWith(
        isLoading: false,
        currentStep: BookingStep.confirmation,
        confirmedBookingId: bookingId,
      );
      return true;
    } on ApiException catch (e) {
      // Se √® 401, converti in TokenExpiredException
      // (il refresh token √® gi√† stato tentato dall'interceptor)
      if (e.isUnauthorized) {
        state = state.copyWith(isLoading: false);
        throw const TokenExpiredException(
          'Sessione scaduta. Effettua nuovamente il login.',
        );
      }
      // Altri errori API - elimina lo stato salvato
      await PendingBookingStorage.clear();
      state = state.copyWith(
        isLoading: false,
        errorMessage: e.message,
        errorCode: e.code,
      );
      return false;
    } on TokenExpiredException {
      // Token scaduto - lo stato √® gi√† salvato, rilancia per gestione UI
      state = state.copyWith(isLoading: false);
      rethrow;
    } catch (e) {
      // Errore generico - elimina lo stato salvato
      await PendingBookingStorage.clear();
      state = state.copyWith(
        isLoading: false,
        errorMessage: e.toString(),
        errorCode: null,
      );
      return false;
    }
  }

  /// Ripristina una prenotazione salvata (dopo login da token scaduto)
  Future<bool> restorePendingBooking() async {
    final pending = await PendingBookingStorage.load();
    if (pending == null) return false;

    // Verifica che il business corrisponda
    if (pending.businessId != _config.businessId) {
      await PendingBookingStorage.clear();
      return false;
    }

    // Ripristina lo stato
    state = state.copyWith(
      currentStep: BookingStep.summary,
      request: pending.toBookingRequest(),
    );

    // Ripristina la location selezionata se presente
    final location = pending.selectedLocation;
    if (location != null) {
      ref.read(selectedLocationProvider.notifier).select(location);
    }

    // Pulisci lo storage
    await PendingBookingStorage.clear();

    return true;
  }

  /// Verifica se c'√® una prenotazione in sospeso
  Future<bool> hasPendingBooking() => PendingBookingStorage.hasPendingBooking();
}

/// Dati servizi (categories + services in un'unica chiamata API)
class ServicesData {
  final List<ServiceCategory> categories;
  final List<Service> services;

  const ServicesData({required this.categories, required this.services});

  /// Servizi prenotabili online
  List<Service> get bookableServices =>
      services.where((s) => s.isBookableOnline && s.isActive).toList();

  /// Compat getter usato dalla UI servizi.
  /// In assenza di un calcolo separato di eleggibilit√† staff, considera eleggibili
  /// i servizi prenotabili/attivi visibili in lista.
  Set<int> get serviceIdsWithEligibleStaff =>
      bookableServices.map((s) => s.id).toSet();

  bool get isEmpty => bookableServices.isEmpty;
}

Set<int> _eligibleServiceIdsFromActiveStaff(List<Staff> staffMembers) {
  final eligible = <int>{};
  for (final staff in staffMembers) {
    if (!staff.isBookableOnline || !staff.isActive) continue;
    eligible.addAll(staff.serviceIds);
  }
  return eligible;
}

/// Notifier per gestire il caricamento dei servizi con controllo TOTALE sullo stato
class ServicesDataNotifier extends StateNotifier<AsyncValue<ServicesData>> {
  final Ref _ref;
  bool _hasFetched = false;
  int? _lastLocationId;

  ServicesDataNotifier(this._ref) : super(const AsyncValue.loading()) {
    // Ascolta cambiamenti della location effettiva
    _ref.listen(effectiveLocationIdProvider, (previous, next) {
      if (next > 0 && next != _lastLocationId) {
        _hasFetched = false;
        _lastLocationId = next;
        _loadData();
      }
    }, fireImmediately: true);
  }

  Future<void> _loadData() async {
    if (_hasFetched) return;

    final locationId = _ref.read(effectiveLocationIdProvider);
    if (locationId <= 0) return;

    _hasFetched = true;

    try {
      final repository = _ref.read(bookingRepositoryProvider);

      final result = await repository.getCategoriesWithServices(locationId);
      final staff = await repository.getStaff(locationId);
      final eligibleServiceIds = _eligibleServiceIdsFromActiveStaff(staff);

      final sortedCategories = List<ServiceCategory>.from(result.categories)
        ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));
      final sortedServices = List<Service>.from(
        result.services.where((s) => eligibleServiceIds.contains(s.id)),
      )..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));

      state = AsyncValue.data(
        ServicesData(categories: sortedCategories, services: sortedServices),
      );
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }

  /// Forza il refresh dei dati (per retry manuale)
  Future<void> refresh() async {
    _hasFetched = false;
    state = const AsyncValue.loading();
    await _loadData();
  }
}

/// Provider unico per categorie e servizi (UNA sola chiamata API)
final servicesDataProvider =
    StateNotifierProvider<ServicesDataNotifier, AsyncValue<ServicesData>>(
      (ref) => ServicesDataNotifier(ref),
    );

/// Provider per i pacchetti di servizi
class ServicePackagesNotifier
    extends StateNotifier<AsyncValue<List<ServicePackage>>> {
  final Ref _ref;
  bool _hasFetched = false;
  int? _lastLocationId;

  ServicePackagesNotifier(this._ref) : super(const AsyncValue.loading()) {
    _ref.listen(effectiveLocationIdProvider, (previous, next) {
      if (next > 0 && next != _lastLocationId) {
        _hasFetched = false;
        _lastLocationId = next;
        _loadData();
      }
    }, fireImmediately: true);
  }

  Future<void> _loadData() async {
    if (_hasFetched) return;

    final locationId = _ref.read(effectiveLocationIdProvider);
    if (locationId <= 0) return;

    _hasFetched = true;

    try {
      final repository = _ref.read(bookingRepositoryProvider);
      final packages = await repository.getServicePackages(locationId);
      final staff = await repository.getStaff(locationId);
      final eligibleServiceIds = _eligibleServiceIdsFromActiveStaff(staff);
      final filteredPackages = packages.where((package) {
        final serviceIds = package.orderedServiceIds;
        if (serviceIds.isEmpty) return false;
        return serviceIds.every(eligibleServiceIds.contains);
      }).toList();
      state = AsyncValue.data(filteredPackages);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }

  Future<void> refresh() async {
    _hasFetched = false;
    state = const AsyncValue.loading();
    await _loadData();
  }
}

final servicePackagesProvider =
    StateNotifierProvider<
      ServicePackagesNotifier,
      AsyncValue<List<ServicePackage>>
    >((ref) => ServicePackagesNotifier(ref));

final bookingTotalsProvider = Provider<BookingTotals>((ref) {
  final bookingState = ref.watch(bookingFlowProvider);
  final services = bookingState.request.services;
  final selectedServiceIds = services.map((s) => s.id).toSet();
  final packages = ref.watch(servicePackagesProvider).value ?? [];
  final selectedPackageIds = bookingState.request.selectedPackageIds;

  final selectedPackages = <ServicePackage>[];
  final coveredServiceIds = <int>{};
  for (final pkg in packages) {
    if (!pkg.isActive || pkg.isBroken) continue;
    if (!selectedPackageIds.contains(pkg.id)) continue;
    final ids = pkg.orderedServiceIds;
    if (ids.isEmpty) continue;
    if (ids.every(selectedServiceIds.contains)) {
      selectedPackages.add(pkg);
      coveredServiceIds.addAll(ids);
    }
  }

  var totalPrice = 0.0;
  var totalDuration = 0;
  for (final pkg in selectedPackages) {
    totalPrice += pkg.effectivePrice;
    totalDuration += pkg.effectiveDurationMinutes;
  }

  final remainingServices = services
      .where((s) => !coveredServiceIds.contains(s.id))
      .toList();
  for (final service in remainingServices) {
    totalPrice += service.isFree ? 0 : service.price;
    totalDuration +=
        service.totalDurationMinutes; // Include processing_time + blocked_time
  }

  final selectedItemCount = selectedPackages.length + remainingServices.length;

  return BookingTotals(
    totalPrice: totalPrice,
    totalDurationMinutes: totalDuration,
    selectedPackages: selectedPackages,
    coveredServiceIds: coveredServiceIds,
    selectedItemCount: selectedItemCount,
  );
});

/// Provider per le categorie (legacy - usa servicesDataProvider)
final categoriesProvider = FutureProvider<List<ServiceCategory>>((ref) async {
  final asyncData = ref.watch(servicesDataProvider);
  return asyncData.whenData((data) => data.categories).value ?? [];
});

/// Provider per i servizi (legacy - usa servicesDataProvider)
final servicesProvider = FutureProvider<List<Service>>((ref) async {
  final asyncData = ref.watch(servicesDataProvider);
  return asyncData.whenData((data) => data.services).value ?? [];
});

/// Provider per lo staff
final staffProvider =
    StateNotifierProvider<AvailableStaffNotifier, AsyncValue<List<Staff>>>(
      (ref) => AvailableStaffNotifier(ref),
    );

/// Provider per la data selezionata nel calendario
final selectedDateProvider = StateProvider<DateTime?>((ref) => null);

/// Provider per il mese attualmente focalizzato nel calendario
final focusedMonthProvider = StateProvider<DateTime>(
  (ref) => ref.watch(locationNowProvider),
);

/// Notifier per le date disponibili (con slot reali)
/// Carica le date disponibili in blocchi di 15 giorni per performance
class AvailableDatesNotifier extends StateNotifier<AsyncValue<Set<DateTime>>> {
  final Ref _ref;
  String? _lastKey;
  int _loadedDays = 0;
  bool _isLoadingMore = false;
  bool _didPreload = false;
  final Set<DateTime> _allDates = {};
  static const int _chunkSize = 15;

  AvailableDatesNotifier(this._ref) : super(const AsyncValue.loading()) {
    _ref.listen(effectiveLocationIdProvider, (_, __) => _reset());
    _ref.listen(maxBookingAdvanceDaysProvider, (_, __) => _reset());
    _ref.listen(
      bookingFlowProvider.select((s) => s.request.services),
      (_, __) => _reset(),
      fireImmediately: true,
    );
    _ref.listen(
      bookingFlowProvider.select((s) => s.request.singleStaffId),
      (_, __) => _reset(),
    );
  }

  void _reset() {
    final key = _currentKey();
    debugPrint(
      '[AvailableDatesNotifier] _reset called, key=$key, lastKey=$_lastKey',
    );
    if (key != null && _lastKey == key) {
      debugPrint('[AvailableDatesNotifier] Key unchanged, skipping reset');
      return;
    }
    debugPrint('[AvailableDatesNotifier] Resetting with new key');
    _lastKey = key;
    _loadedDays = 0;
    _allDates.clear();
    _didPreload = false;
    // Forza interruzione del caricamento in corso per permettere il nuovo
    _isLoadingMore = false;
    _loadNextChunk();
  }

  void resetForNewSelection() {
    _lastKey = null;
    _loadedDays = 0;
    _allDates.clear();
    _didPreload = false;
    // Forza interruzione del caricamento in corso
    _isLoadingMore = false;
    state = const AsyncValue.loading();
    _loadNextChunk();
  }

  String? _currentKey() {
    final locationId = _ref.read(effectiveLocationIdProvider);
    final maxDays = _ref.read(maxBookingAdvanceDaysProvider);
    final bookingState = _ref.read(bookingFlowProvider);
    final serviceIds = bookingState.request.services.map((s) => s.id).toList();
    final staffId = bookingState.request.singleStaffId;

    if (locationId <= 0 || serviceIds.isEmpty) {
      return null;
    }
    return '$locationId|$maxDays|${staffId ?? 0}|${serviceIds.join(',')}';
  }

  /// Carica il prossimo blocco di 15 giorni
  Future<void> loadMore() async {
    final maxDays = _ref.read(maxBookingAdvanceDaysProvider);
    if (_loadedDays >= maxDays || _isLoadingMore) return;
    await _loadNextChunk();
  }

  /// Carica fino a coprire almeno il giorno richiesto (indice relativo a oggi)
  Future<void> loadUntilDay(int dayIndex) async {
    if (dayIndex < 0 || _isLoadingMore) return;
    final maxDays = _ref.read(maxBookingAdvanceDaysProvider);
    if (maxDays <= 0) return;

    final target = (dayIndex + _chunkSize).clamp(0, maxDays);
    while (_loadedDays < target) {
      final before = _loadedDays;
      await _loadNextChunk();
      if (_loadedDays == before) {
        break;
      }
    }
  }

  /// Verifica se ci sono altri giorni da caricare
  bool get hasMore {
    final maxDays = _ref.read(maxBookingAdvanceDaysProvider);
    return _loadedDays < maxDays;
  }

  /// Numero di giorni gi√† caricati
  int get loadedDays => _loadedDays;

  Future<void> _loadNextChunk() async {
    if (_isLoadingMore) return;
    _isLoadingMore = true;

    final locationId = _ref.read(effectiveLocationIdProvider);
    final maxDays = _ref.read(maxBookingAdvanceDaysProvider);
    final bookingState = _ref.read(bookingFlowProvider);
    final serviceIds = bookingState.request.services.map((s) => s.id).toList();
    final staffId = bookingState.request.singleStaffId;

    debugPrint(
      '[AvailableDatesNotifier] _loadNextChunk: locationId=$locationId, serviceIds=$serviceIds, staffId=$staffId, loadedDays=$_loadedDays, maxDays=$maxDays',
    );

    if (locationId <= 0 || serviceIds.isEmpty) {
      state = const AsyncValue.data({});
      _isLoadingMore = false;
      return;
    }

    // Se √® il primo caricamento, mostra loading
    if (_loadedDays == 0) {
      state = const AsyncValue.loading();
    }

    try {
      final repository = _ref.read(bookingRepositoryProvider);
      final today = _ref.read(locationTodayProvider);

      // Calcola il range di giorni da caricare
      final startDay = _loadedDays;
      final endDay = (startDay + _chunkSize).clamp(0, maxDays);

      // Carica le date per questo blocco di giorni
      for (var i = startDay; i < endDay; i++) {
        final date = today.add(Duration(days: i));
        try {
          final slots = await repository.getAvailableSlots(
            locationId: locationId,
            date: date,
            serviceIds: serviceIds,
            staffId: staffId,
          );
          if (slots.isNotEmpty) {
            _allDates.add(DateTime(date.year, date.month, date.day));
          }
        } catch (_) {
          // Ignora errori per singoli giorni
        }
      }

      _loadedDays = endDay;
      state = AsyncValue.data(Set.from(_allDates));

      if (!_didPreload) {
        _didPreload = true;
        if (_loadedDays < maxDays) {
          Future(() async {
            await _loadNextChunk();
          });
        }
      }
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    } finally {
      _isLoadingMore = false;
    }
  }
}

/// Provider per le date disponibili (slot reali)
final availableDatesProvider =
    StateNotifierProvider<AvailableDatesNotifier, AsyncValue<Set<DateTime>>>(
      (ref) => AvailableDatesNotifier(ref),
    );

/// Provider per gli slot disponibili
final availableSlotsProvider = FutureProvider<List<TimeSlot>>((ref) async {
  final repository = ref.read(bookingRepositoryProvider);
  final locationId = ref.watch(effectiveLocationIdProvider);
  final bookingState = ref.watch(bookingFlowProvider);
  final selectedDate = ref.watch(selectedDateProvider);

  if (locationId <= 0 ||
      selectedDate == null ||
      bookingState.request.services.isEmpty) {
    return [];
  }

  final services = bookingState.request.services;
  if (services.isEmpty) {
    return [];
  }

  // Con allowMultiStaffBooking = false, usiamo sempre la chiamata standard
  // che cerca uno staff capace di fare TUTTI i servizi
  return repository.getAvailableSlots(
    locationId: locationId,
    date: selectedDate,
    serviceIds: services.map((s) => s.id).toList(),
    staffId: bookingState.request.singleStaffId,
  );

  // === CODICE MULTI-STAFF (DISABILITATO) ===
  // Riabilitare quando allowMultiStaffBooking = true in BookingConfig
  // e l'API multi-staff √® implementata.
  /*
  final selectedStaffByService = bookingState.request.selectedStaffByService;
  final hasPerServiceSelection =
      services.length > 1 &&
      selectedStaffByService.isNotEmpty &&
      !bookingState.request.anyOperatorSelected;
  final allAnyOperatorSelected =
      bookingState.request.allServicesAnyOperatorSelected &&
      selectedStaffByService.isEmpty;

  if (!hasPerServiceSelection || allAnyOperatorSelected) {
    return repository.getAvailableSlots(
      locationId: locationId,
      date: selectedDate,
      serviceIds: services.map((s) => s.id).toList(),
      staffId: bookingState.request.singleStaffId,
    );
  }

  final slotsByService = <int, List<TimeSlot>>{};
  for (final service in services) {
    final staffId = selectedStaffByService[service.id]?.id;
    final slots = await repository.getAvailableSlots(
      locationId: locationId,
      date: selectedDate,
      serviceIds: [service.id],
      staffId: staffId,
    );
    slotsByService[service.id] = slots;
    if (slots.isEmpty) {
      return [];
    }
  }

  final totalDuration = services.fold<int>(
    0,
    (sum, service) => sum + service.totalDurationMinutes, // Include processing_time + blocked_time
  );
  final startSets = <int, Set<int>>{};
  for (final entry in slotsByService.entries) {
    startSets[entry.key] = entry.value
        .map((s) => s.startTime.millisecondsSinceEpoch)
        .toSet();
  }

  final baseService = services.first;
  final baseStarts = startSets[baseService.id] ?? {};
  if (baseStarts.isEmpty) {
    return [];
  }

  // Calcola gli offset per ogni servizio, arrotondando al prossimo multiplo
  // del passo slot configurato sulla location.
  final location = ref.read(effectiveLocationProvider);
  final rawInterval = location?.onlineBookingSlotIntervalMinutes ?? 15;
  final slotInterval = rawInterval > 0 ? rawInterval : 15;
  final offsets = <int>[];
  var running = 0;
  for (final service in services) {
    offsets.add(running);
    final duration = service.durationMinutes;
    final roundedDuration =
        ((duration + slotInterval - 1) ~/ slotInterval) * slotInterval;
    running += roundedDuration;
  }

  final available = <TimeSlot>[];
  for (final startEpoch in baseStarts) {
    final startTime = DateTime.fromMillisecondsSinceEpoch(startEpoch);
    var valid = true;
    for (var i = 0; i < services.length; i++) {
      final service = services[i];
      final requiredStart = startTime.add(Duration(minutes: offsets[i]));
      final requiredEpoch = requiredStart.millisecondsSinceEpoch;
      final set = startSets[service.id];
      if (set == null || !set.contains(requiredEpoch)) {
        valid = false;
        break;
      }
    }
    if (valid) {
      available.add(
        TimeSlot(
          startTime: startTime,
          endTime: startTime.add(Duration(minutes: totalDuration)),
        ),
      );
    }
  }
  available.sort((a, b) => a.startTime.compareTo(b.startTime));
  return available;
  */
});

/// Provider per la prima data disponibile
final firstAvailableDateProvider = FutureProvider<DateTime>((ref) async {
  final repository = ref.read(bookingRepositoryProvider);
  final locationId = ref.watch(effectiveLocationIdProvider);
  final bookingState = ref.watch(bookingFlowProvider);

  if (locationId <= 0) {
    return ref.read(locationTodayProvider).add(const Duration(days: 1));
  }

  return repository.getFirstAvailableDate(
    locationId: locationId,
    serviceIds: bookingState.request.services.map((s) => s.id).toList(),
    staffId: bookingState.request.singleStaffId,
    now: ref.read(locationNowProvider),
  );
});

/// Notifier per lo staff disponibile (planning + slots reali)
class AvailableStaffNotifier extends StateNotifier<AsyncValue<List<Staff>>> {
  final Ref _ref;
  bool _hasFetched = false;
  String? _lastKey;
  List<Staff> _allStaff = const [];

  AvailableStaffNotifier(this._ref) : super(const AsyncValue.loading()) {
    _ref.listen(
      effectiveLocationIdProvider,
      (_, __) => _invalidate(),
      fireImmediately: true,
    );
    _ref.listen(
      bookingFlowProvider.select((s) => s.currentStep),
      (_, __) => _invalidate(),
    );
    _ref.listen(
      bookingFlowProvider.select((s) => s.request.services),
      (_, __) => _applyFilter(),
    );
  }

  void _invalidate() {
    _hasFetched = false;
    _loadData();
  }

  Future<void> _loadData() async {
    final currentStep = _ref.read(bookingFlowProvider).currentStep;
    if (currentStep != BookingStep.staff) {
      return;
    }

    final locationId = _ref.read(effectiveLocationIdProvider);
    final bookingState = _ref.read(bookingFlowProvider);
    final serviceIds = bookingState.request.services.map((s) => s.id).toList();

    final key = '$locationId|${serviceIds.join(',')}';
    if (_hasFetched && _lastKey == key) return;
    _lastKey = key;
    _hasFetched = true;

    if (locationId <= 0 || serviceIds.isEmpty) {
      state = const AsyncValue.data([]);
      return;
    }

    state = const AsyncValue.loading();

    try {
      final repository = _ref.read(bookingRepositoryProvider);
      _allStaff = await repository.getStaff(locationId);
      _applyFilter();
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }

  void _applyFilter() {
    final bookingState = _ref.read(bookingFlowProvider);
    final serviceIds = bookingState.request.services.map((s) => s.id).toList();
    if (serviceIds.isEmpty) {
      state = const AsyncValue.data([]);
      return;
    }

    final serviceIdSet = serviceIds.toSet();
    final availableStaff = _allStaff.where((s) {
      if (s.serviceIds.isEmpty) {
        return false;
      }
      return s.serviceIds.any(serviceIdSet.contains);
    }).toList()..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));

    state = AsyncValue.data(availableStaff);
  }
}
--- FILE: lib/features/booking/providers/business_provider.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../app/providers/route_slug_provider.dart';
import '../../../core/models/business.dart';
import '../../../core/network/api_client.dart';
import '../../../core/network/network_providers.dart';

part 'business_provider.g.dart';

/// Provider per il business corrente (caricato da slug nel path URL)
///
/// L'URL segue il pattern: /{slug}/booking, /{slug}/login, ecc.
/// Il router estrae lo slug e lo aggiorna in routeSlugProvider.
/// Questo provider reagisce ai cambi di slug e carica il business.
@riverpod
class CurrentBusiness extends _$CurrentBusiness {
  String? _lastSlug;
  Business? _cachedBusiness;
  Object? _cachedError;

  @override
  Future<Business?> build() async {
    // Legge lo slug dal path URL (gestito dal router)
    final slug = ref.watch(routeSlugProvider);

    // Se lo slug non √® cambiato, ritorna la cache
    if (_lastSlug == slug && _cachedBusiness != null) {
      return _cachedBusiness;
    }

    // Se c'era un errore per questo slug, rilancia
    if (_lastSlug == slug && _cachedError != null) {
      throw _cachedError!;
    }

    _lastSlug = slug;
    _cachedBusiness = null;
    _cachedError = null;

    if (slug == null) {
      // Nessun slug nel path ‚Üí landing page
      return null;
    }

    final apiClient = ref.watch(apiClientProvider);

    try {
      final data = await apiClient.getBusinessBySlug(slug);
      _cachedBusiness = Business.fromJson(data);
      return _cachedBusiness;
    } on ApiException catch (e) {
      if (e.statusCode == 404) {
        // Business non trovato - slug non valido
        // Non √® un errore, ritorna null e l'app mostrer√† "business non trovato"
        _cachedBusiness = null;
        return null;
      }
      _cachedError = e;
      rethrow;
    } catch (e) {
      _cachedError = e;
      rethrow;
    }
  }

  /// Ricarica il business corrente (forza refresh)
  Future<void> refresh() async {
    _lastSlug = null;
    _cachedBusiness = null;
    _cachedError = null;
    ref.invalidateSelf();
  }
}

/// Provider per l'ID del business corrente (sincrono, utility)
@riverpod
class CurrentBusinessId extends _$CurrentBusinessId {
  @override
  int? build() {
    final businessAsync = ref.watch(currentBusinessProvider);
    return businessAsync.value?.id;
  }
}

/// Provider per verificare se il business slug √® valido
/// (slug presente e business trovato nel database)
@riverpod
class IsBusinessValid extends _$IsBusinessValid {
  @override
  bool build() {
    final slug = ref.watch(routeSlugProvider);

    if (slug == null) {
      // Nessun slug nel path ‚Üí landing page, non √® un errore
      return true;
    }

    // Se c'√® uno slug, verifica che il business esista
    final businessAsync = ref.watch(currentBusinessProvider);
    return businessAsync.value != null;
  }
}

/// Provider semplice per lo slug corrente (letto dal path URL)
@riverpod
String? businessSlug(Ref ref) {
  return ref.watch(routeSlugProvider);
}

/// Provider per verificare se siamo su un sottodominio business
@riverpod
bool isBusinessSubdomain(Ref ref) {
  return ref.watch(businessSlugProvider) != null;
}

/// Provider che verifica se l'utente √® autenticato per un business DIVERSO
/// da quello corrente (basato su URL slug).
///
/// Restituisce:
/// - `null` se l'utente non √® autenticato o dati non ancora caricati
/// - `true` se l'utente √® autenticato per un business DIVERSO
/// - `false` se l'utente √® autenticato per lo STESSO business o non autenticato
///
/// Utile per mostrare un avviso quando l'utente naviga su un business
/// diverso da quello per cui si √® autenticato.
@riverpod
class IsAuthenticatedForDifferentBusiness
    extends _$IsAuthenticatedForDifferentBusiness {
  @override
  Future<bool> build() async {
    final currentBusinessAsync = ref.watch(currentBusinessProvider);
    final authenticatedBusinessIdAsync = ref.watch(
      authenticatedBusinessIdProvider,
    );

    // Attendo i valori
    final currentBusiness = currentBusinessAsync.value;
    final authenticatedBusinessId = authenticatedBusinessIdAsync.value;

    // Se l'utente non √® autenticato, non c'√® mismatch
    if (authenticatedBusinessId == null) {
      return false;
    }

    // Se il business corrente non √® caricato, non possiamo verificare
    if (currentBusiness == null) {
      return false;
    }

    // Verifica se il business corrente √® DIVERSO da quello autenticato
    return currentBusiness.id != authenticatedBusinessId;
  }
}
--- FILE: lib/features/booking/providers/my_bookings_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'my_bookings_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(MyBookings)
const myBookingsProvider = MyBookingsProvider._();

final class MyBookingsProvider
    extends $NotifierProvider<MyBookings, MyBookingsState> {
  const MyBookingsProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'myBookingsProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$myBookingsHash();

  @$internal
  @override
  MyBookings create() => MyBookings();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(MyBookingsState value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<MyBookingsState>(value),
    );
  }
}

String _$myBookingsHash() => r'7e90d183a854bbb2914d2d7e3bc20d3538f6ba6b';

abstract class _$MyBookings extends $Notifier<MyBookingsState> {
  MyBookingsState build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<MyBookingsState, MyBookingsState>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<MyBookingsState, MyBookingsState>,
              MyBookingsState,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/features/booking/providers/locations_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod/legacy.dart';

import '../../../core/models/location.dart';
import '../../../core/services/tenant_time_service.dart';
import 'booking_provider.dart';
import 'business_provider.dart';

/// Provider per la location ID passata via URL (?location=4)
/// Se valorizzato, lo step location viene saltato
final urlLocationIdProvider = StateProvider<int?>((ref) => null);

/// Provider per le locations del business corrente
final locationsProvider =
    NotifierProvider<LocationsNotifier, AsyncValue<List<Location>>>(
      LocationsNotifier.new,
    );

class LocationsNotifier extends Notifier<AsyncValue<List<Location>>> {
  bool _hasFetched = false;
  int? _lastBusinessId;

  @override
  AsyncValue<List<Location>> build() {
    // Ascolta cambiamenti del business
    ref.listen(currentBusinessProvider, (previous, next) {
      if (next.hasValue && next.value != null) {
        final businessId = next.value!.id;
        if (businessId != _lastBusinessId) {
          _hasFetched = false;
          _lastBusinessId = businessId;
          _loadLocations(businessId);
        }
      }
    }, fireImmediately: true);

    return const AsyncValue.loading();
  }

  Future<void> _loadLocations(int businessId) async {
    if (_hasFetched) return;
    _hasFetched = true;

    state = const AsyncValue.loading();

    try {
      final repo = ref.read(bookingRepositoryProvider);
      final locations = await repo.getLocations(businessId);
      state = AsyncValue.data(locations);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }

  Future<void> refresh() async {
    final business = ref.read(currentBusinessProvider).value;
    if (business == null) return;

    _hasFetched = false;
    await _loadLocations(business.id);
  }
}

/// Provider per la location selezionata dall'utente
class SelectedLocationNotifier extends Notifier<Location?> {
  @override
  Location? build() => null;

  void select(Location location) {
    state = location;
  }

  void clear() {
    state = null;
  }
}

final selectedLocationProvider =
    NotifierProvider<SelectedLocationNotifier, Location?>(
      SelectedLocationNotifier.new,
    );

/// Flag persistente che indica se il business ha multiple locations.
/// Una volta settato a true, rimane true per tutta la sessione.
/// Viene aggiornato solo quando locationsProvider ha dati.
bool _hasMultipleLocationsFlag = false;

/// Flag che indica se l'utente √® arrivato con location pre-selezionata via URL.
/// Viene controllato solo UNA VOLTA all'inizio, prima che le locations vengano caricate.
bool? _initialUrlHadLocation;

/// Provider derivato: true se ci sono multiple locations E nessuna location pre-selezionata via URL iniziale.
/// IMPORTANTE:
/// - Se l'utente arriva con ?location=X nell'URL iniziale, lo step √® nascosto
/// - Se l'utente seleziona una location durante il flow (che aggiorna l'URL), lo step rimane visibile
final hasMultipleLocationsProvider = Provider<bool>((ref) {
  // Controlla se c'era una location nell'URL iniziale (solo la prima volta)
  if (_initialUrlHadLocation == null) {
    final urlLocationId = ref.read(urlLocationIdProvider);
    _initialUrlHadLocation = urlLocationId != null;
  }

  // Se l'utente √® arrivato con location gi√† nell'URL, nascondi lo step
  if (_initialUrlHadLocation == true) {
    return false;
  }

  // Se gi√† sappiamo che ci sono multiple locations, ritorna true
  if (_hasMultipleLocationsFlag) {
    return true;
  }

  // Altrimenti controlla i dati attuali
  final locationsAsync = ref.watch(locationsProvider);
  locationsAsync.whenData((locations) {
    if (locations.length > 1) {
      _hasMultipleLocationsFlag = true;
    }
  });

  return _hasMultipleLocationsFlag;
});

/// Provider derivato: la location effettiva da usare per il booking
/// Priorit√†: 1) URL param, 2) Selezione utente, 3) Location singola/default
final effectiveLocationProvider = Provider<Location?>((ref) {
  final locationsAsync = ref.watch(locationsProvider);
  final urlLocationId = ref.watch(urlLocationIdProvider);
  final selectedLocation = ref.watch(selectedLocationProvider);

  return locationsAsync.maybeWhen(
    data: (locations) {
      if (locations.isEmpty) return null;

      // 1) Se c'√® location da URL, cerca quella
      if (urlLocationId != null) {
        final urlLocation = locations
            .where((l) => l.id == urlLocationId)
            .firstOrNull;
        if (urlLocation != null) return urlLocation;
        // Se non trovata, fallback a default
      }

      // 2) Se c'√® una sola location, usa quella
      if (locations.length == 1) return locations.first;

      // 3) Usa la selezione dell'utente
      return selectedLocation;
    },
    orElse: () => null,
  );
});

/// Timezone effettivo del flow booking:
/// 1) timezone della location effettiva
/// 2) fallback timezone del business
/// 3) fallback Europe/Rome
final locationTimezoneProvider = Provider<String>((ref) {
  final location = ref.watch(effectiveLocationProvider);
  if (location != null) {
    return TenantTimeService.normalizeTimezone(location.timezone);
  }

  final businessAsync = ref.watch(currentBusinessProvider);
  return TenantTimeService.normalizeTimezone(businessAsync.value?.timezone);
});

final locationNowProvider = Provider<DateTime>((ref) {
  final timezone = ref.watch(locationTimezoneProvider);
  return TenantTimeService.nowInTimezone(timezone);
});

final locationTodayProvider = Provider<DateTime>((ref) {
  final timezone = ref.watch(locationTimezoneProvider);
  return TenantTimeService.todayInTimezone(timezone);
});
--- FILE: lib/features/booking/data/booking_repository.dart ---
import 'package:uuid/uuid.dart';

import '../../../core/models/location.dart';
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/models/service_package.dart';
import '../../../core/models/staff.dart';
import '../../../core/models/time_slot.dart';
import '../../../core/network/api_client.dart';

/// Repository per le prenotazioni - API reale
class BookingRepository {
  final ApiClient _apiClient;
  final Uuid _uuid = const Uuid();

  BookingRepository(this._apiClient);

  /// GET /v1/businesses/{business_id}/locations/public
  /// Recupera le locations attive di un business
  Future<List<Location>> getLocations(int businessId) async {
    final data = await _apiClient.getBusinessLocations(businessId);
    final locationsJson = data['data'] as List<dynamic>? ?? [];

    return locationsJson
        .map((json) => Location.fromJson(json as Map<String, dynamic>))
        .toList();
  }

  /// GET /v1/services?location_id=X
  /// Recupera categorie e servizi in un'unica chiamata
  Future<({List<ServiceCategory> categories, List<Service> services})>
  getCategoriesWithServices(int locationId) async {
    final data = await _apiClient.getServices(locationId);
    final categoriesJson = data['categories'] as List<dynamic>? ?? [];

    final categories = <ServiceCategory>[];
    final services = <Service>[];

    for (final json in categoriesJson) {
      final catJson = json as Map<String, dynamic>;

      // Skip categorie senza ID (non categorizzate)
      final catId = catJson['id'] as int?;
      if (catId == null) continue;

      categories.add(ServiceCategory.fromJson(catJson));

      final servicesJson = catJson['services'] as List<dynamic>? ?? [];

      for (final svcJson in servicesJson) {
        final svc = svcJson as Map<String, dynamic>;
        if (!svc.containsKey('category_id')) {
          svc['category_id'] = catId;
        }
        services.add(Service.fromJson(svc));
      }
    }

    return (categories: categories, services: services);
  }

  /// GET /v1/services?location_id=X
  /// Recupera categorie con servizi annidati (legacy)
  Future<List<ServiceCategory>> getCategories(int locationId) async {
    final result = await getCategoriesWithServices(locationId);
    return result.categories;
  }

  /// GET /v1/services?location_id=X
  /// Recupera tutti i servizi (flat list) (legacy)
  Future<List<Service>> getServices(int locationId) async {
    final result = await getCategoriesWithServices(locationId);
    return result.services;
  }

  /// GET /v1/locations/{location_id}/service-packages
  Future<List<ServicePackage>> getServicePackages(int locationId) async {
    final data = await _apiClient.getServicePackages(locationId);
    final packagesJson = data['packages'] as List<dynamic>? ?? [];
    return packagesJson
        .map((json) => ServicePackage.fromJson(json as Map<String, dynamic>))
        .toList();
  }

  /// GET /v1/locations/{location_id}/service-packages/{id}/expand
  Future<ServicePackageExpansion> expandServicePackage({
    required int locationId,
    required int packageId,
  }) async {
    final data = await _apiClient.expandServicePackage(
      locationId: locationId,
      packageId: packageId,
    );
    return ServicePackageExpansion.fromJson(data);
  }

  /// GET /v1/staff?location_id=X
  /// Recupera staff prenotabili online
  Future<List<Staff>> getStaff(int locationId) async {
    final data = await _apiClient.getStaff(locationId);

    // Formato atteso: { "staff": [...] }
    final staffJson = data['staff'] as List<dynamic>? ?? [];

    return staffJson.map((json) {
      final staffData = json as Map<String, dynamic>;
      // Mappa display_name se presente
      if (staffData.containsKey('display_name') &&
          !staffData.containsKey('name')) {
        final displayName = staffData['display_name'] as String;
        final parts = displayName.split(' ');
        staffData['name'] = parts.isNotEmpty ? parts.first : displayName;
        staffData['surname'] = parts.length > 1
            ? parts.sublist(1).join(' ')
            : '';
      }
      // Default business_id se non presente
      if (!staffData.containsKey('business_id')) {
        staffData['business_id'] = 1;
      }
      return Staff.fromJson(staffData);
    }).toList();
  }

  /// GET /v1/availability?location_id=X&date=YYYY-MM-DD&service_ids=1,2&staff_id=N
  /// Recupera slot disponibili
  Future<List<TimeSlot>> getAvailableSlots({
    required int locationId,
    required DateTime date,
    required List<int> serviceIds,
    int? staffId,
  }) async {
    if (serviceIds.isEmpty) return [];

    final dateStr =
        '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';

    final data = await _apiClient.getAvailability(
      locationId: locationId,
      date: dateStr,
      serviceIds: serviceIds,
      staffId: staffId,
    );

    final slotsJson = data['slots'] as List<dynamic>? ?? [];

    return slotsJson.map((json) {
      return TimeSlot.fromJson(json as Map<String, dynamic>);
    }).toList();
  }

  /// Recupera le date del mese con almeno uno slot disponibile
  Future<Set<DateTime>> getAvailableDatesForMonth({
    required int locationId,
    required DateTime month,
    required List<int> serviceIds,
    int? staffId,
  }) async {
    if (serviceIds.isEmpty) return {};

    final year = month.year;
    final monthNumber = month.month;
    final daysInMonth = DateTime(year, monthNumber + 1, 0).day;
    final availableDates = <DateTime>{};

    for (var day = 1; day <= daysInMonth; day++) {
      final date = DateTime(year, monthNumber, day);
      try {
        final slots = await getAvailableSlots(
          locationId: locationId,
          date: date,
          serviceIds: serviceIds,
          staffId: staffId,
        );
        if (slots.isNotEmpty) {
          availableDates.add(DateTime(year, monthNumber, day));
        }
      } catch (_) {
        // Ignora errori e continua con il giorno successivo
      }
    }

    return availableDates;
  }

  /// Trova la prima data con disponibilit√†
  /// Cerca nei prossimi 30 giorni
  Future<DateTime> getFirstAvailableDate({
    required int locationId,
    required List<int> serviceIds,
    int? staffId,
    DateTime? now,
  }) async {
    final effectiveNow = now ?? DateTime.now();
    if (serviceIds.isEmpty) {
      return effectiveNow.add(const Duration(days: 1));
    }

    var checkDate = DateTime(
      effectiveNow.year,
      effectiveNow.month,
      effectiveNow.day,
    );

    // Se oggi √® gi√† tardi, inizia da domani
    if (effectiveNow.hour >= 18) {
      checkDate = checkDate.add(const Duration(days: 1));
    }

    // Cerca nei prossimi 30 giorni
    for (var i = 0; i < 30; i++) {
      try {
        final slots = await getAvailableSlots(
          locationId: locationId,
          date: checkDate,
          serviceIds: serviceIds,
          staffId: staffId,
        );

        if (slots.isNotEmpty) {
          return checkDate;
        }
      } catch (_) {
        // Ignora errori e prova il giorno successivo
      }
      checkDate = checkDate.add(const Duration(days: 1));
    }

    // Fallback: domani
    return DateTime(
      effectiveNow.year,
      effectiveNow.month,
      effectiveNow.day + 1,
    );
  }

  /// POST /v1/locations/{location_id}/bookings
  /// Conferma prenotazione
  ///
  /// Ritorna i dati del booking creato
  /// Throws ApiException con code='slot_conflict' se slot occupato
  Future<Map<String, dynamic>> confirmBooking({
    required int businessId,
    required int locationId,
    required List<int> serviceIds,
    required DateTime startTime,
    int? staffId,
    String? notes,
    String? idempotencyKey,
    List<Map<String, dynamic>>? items,
  }) async {
    // Genera idempotency key se non fornita
    final key = idempotencyKey ?? _uuid.v4();

    return _apiClient.createCustomerBooking(
      businessId: businessId,
      locationId: locationId,
      idempotencyKey: key,
      serviceIds: serviceIds,
      // Invia orario come ISO locale (NO toUtc - il backend gestisce il timezone)
      startTime: startTime.toIso8601String(),
      staffId: staffId,
      notes: notes,
      items: items,
    );
  }

  /// Genera un nuovo idempotency key (UUID v4)
  String generateIdempotencyKey() => _uuid.v4();
}
--- FILE: lib/features/booking/domain/booking_config.dart ---
/// Configurazione per il flow di prenotazione
class BookingConfig {
  /// Consente all'utente di scegliere l'operatore
  final bool allowStaffSelection;

  /// Consente di selezionare staff diversi per servizi diversi nella stessa prenotazione.
  /// TEMPORANEAMENTE DISABILITATO: richiede implementazione API multi-staff.
  /// Per riabilitare, impostare a true qui e nel placeholderBookingConfig.
  final bool allowMultiStaffBooking;

  /// ID del business
  final int businessId;

  /// ID della location (sede)
  final int locationId;

  /// True se il business esiste ma non ha location configurata
  final bool businessExistsButNotActive;

  const BookingConfig({
    this.allowStaffSelection = true,
    this.allowMultiStaffBooking =
        false, // riabilitare quando API multi-staff pronta
    required this.businessId,
    required this.locationId,
    this.businessExistsButNotActive = false,
  });

  /// Crea una config valida solo se businessId e locationId sono noti
  bool get isValid => businessId > 0 && locationId > 0;
}

/// Config placeholder usata quando il business non √® ancora caricato.
/// NON usare direttamente - serve solo come fallback temporaneo.
const placeholderBookingConfig = BookingConfig(
  allowStaffSelection: true,
  allowMultiStaffBooking: false, //  riabilitare quando API multi-staff pronta
  businessId: 0,
  locationId: 0,
);
--- FILE: lib/features/booking/presentation/screens/staff_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/staff.dart';
import '../../../../core/widgets/centered_error_view.dart';
import '../../providers/booking_provider.dart';

class StaffStep extends ConsumerStatefulWidget {
  const StaffStep({super.key});

  @override
  ConsumerState<StaffStep> createState() => _StaffStepState();
}

class _StaffStepState extends ConsumerState<StaffStep> {
  @override
  void initState() {
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final staffAsync = ref.watch(staffProvider);
    final bookingState = ref.watch(bookingFlowProvider);
    final bookingConfig = ref.watch(bookingConfigProvider);
    final selectedStaff = bookingState.request.selectedStaff;
    final services = bookingState.request.services;
    final selectedStaffByService = bookingState.request.selectedStaffByService;
    final anyOperatorSelected = bookingState.request.anyOperatorSelected;
    // Multi-staff UI solo se abilitata E pi√π servizi selezionati
    final showMultiStaffUI =
        bookingConfig.allowMultiStaffBooking && services.length > 1;
    final isLoading = staffAsync.isLoading || bookingState.isLoading;

    if (staffAsync.hasError) {
      return CenteredErrorView(
        title: l10n.errorLoadingStaff,
        onRetry: () => ref.refresh(staffProvider),
        retryLabel: l10n.actionRetry,
      );
    }

    return Stack(
      children: [
        Column(
          children: [
            // Header
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    l10n.staffTitle,
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    l10n.staffSubtitle,
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: theme.colorScheme.onSurface.withOpacity(0.7),
                    ),
                  ),
                ],
              ),
            ),

            // Lista staff
            Expanded(
              child: staffAsync.when(
                loading: () => const SizedBox.shrink(),
                error: (e, _) => const SizedBox.shrink(),
                data: (staffList) {
                  if (staffList.isEmpty) {
                    return Center(child: Text(l10n.staffEmpty));
                  }

                  // UI multi-staff: permette di selezionare staff diversi per servizi diversi
                  // NOTA: Temporaneamente disabilitata (allowMultiStaffBooking = false)
                  if (showMultiStaffUI) {
                    final staffByService = <int, List<Staff>>{};
                    for (final service in services) {
                      final eligible =
                          staffList
                              .where((s) => s.serviceIds.contains(service.id))
                              .toList()
                            ..sort(
                              (a, b) => a.sortOrder.compareTo(b.sortOrder),
                            );
                      staffByService[service.id] = eligible;
                    }

                    final hasEmpty = staffByService.values.any(
                      (list) => list.isEmpty,
                    );
                    if (hasEmpty) {
                      return Center(child: Text(l10n.staffEmpty));
                    }

                    return ListView(
                      padding: const EdgeInsets.symmetric(horizontal: 16),
                      children: [
                        _StaffTile(
                          staff: null,
                          isSelected: anyOperatorSelected,
                          onTap: () {
                            ref
                                .read(bookingFlowProvider.notifier)
                                .selectAnyOperatorForAllServices(
                                  staffByService,
                                );
                          },
                        ),
                        const SizedBox(height: 16),
                        for (final service in services) ...[
                          Text(
                            service.name,
                            style: theme.textTheme.titleMedium?.copyWith(
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                          const SizedBox(height: 8),
                          ...staffByService[service.id]!.map(
                            (staff) => Padding(
                              padding: const EdgeInsets.only(bottom: 8),
                              child: _StaffTile(
                                staff: staff,
                                isSelected:
                                    selectedStaffByService[service.id]?.id ==
                                    staff.id,
                                onTap: () {
                                  ref
                                      .read(bookingFlowProvider.notifier)
                                      .selectStaffForService(service, staff);
                                },
                              ),
                            ),
                          ),
                          const SizedBox(height: 16),
                        ],
                      ],
                    );
                  }

                  // UI standard: un solo staff per tutti i servizi
                  // Filtra solo staff che possono fare TUTTI i servizi selezionati
                  final eligibleStaff = services.length > 1
                      ? staffList
                            .where(
                              (staff) => services.every(
                                (s) => staff.serviceIds.contains(s.id),
                              ),
                            )
                            .toList()
                      : staffList;

                  if (eligibleStaff.isEmpty) {
                    return Center(
                      child: Padding(
                        padding: const EdgeInsets.all(24),
                        child: Text(
                          l10n.noStaffForAllServices,
                          textAlign: TextAlign.center,
                          style: theme.textTheme.bodyLarge,
                        ),
                      ),
                    );
                  }

                  // Se c'√® un solo staff idoneo, auto-selezionalo
                  if (eligibleStaff.length == 1 && selectedStaff == null) {
                    // Auto-selezione differita per evitare rebuild durante build
                    WidgetsBinding.instance.addPostFrameCallback((_) {
                      ref
                          .read(bookingFlowProvider.notifier)
                          .autoSelectStaff(eligibleStaff.first);
                    });
                  }

                  // Se c'√® un solo staff, mostra solo quello (gi√† selezionato)
                  if (eligibleStaff.length == 1) {
                    return ListView(
                      padding: const EdgeInsets.symmetric(horizontal: 16),
                      children: [
                        _StaffTile(
                          staff: eligibleStaff.first,
                          isSelected:
                              true, // Sempre selezionato quando √® l'unico
                          onTap: null, // Non cliccabile, √® l'unica opzione
                        ),
                      ],
                    );
                  }

                  // Pi√π staff disponibili: mostra "Qualsiasi" + lista
                  return ListView(
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    children: [
                      // Opzione "Qualsiasi operatore"
                      _StaffTile(
                        staff: null,
                        isSelected: anyOperatorSelected,
                        onTap: () {
                          ref
                              .read(bookingFlowProvider.notifier)
                              .selectAnyOperator();
                        },
                      ),
                      const SizedBox(height: 8),
                      // Lista operatori
                      ...eligibleStaff.map(
                        (staff) => Padding(
                          padding: const EdgeInsets.only(bottom: 8),
                          child: _StaffTile(
                            staff: staff,
                            isSelected: selectedStaff?.id == staff.id,
                            onTap: () {
                              ref
                                  .read(bookingFlowProvider.notifier)
                                  .selectStaff(staff);
                            },
                          ),
                        ),
                      ),
                    ],
                  );
                },
              ),
            ),

            // Footer con bottone
            _buildFooter(context, ref),
          ],
        ),
        if (isLoading)
          Positioned.fill(
            child: ColoredBox(
              color: theme.colorScheme.surface.withOpacity(0.6),
              child: const Center(child: CircularProgressIndicator()),
            ),
          ),
      ],
    );
  }

  Widget _buildFooter(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final bookingState = ref.watch(bookingFlowProvider);
    final staffAsync = ref.watch(staffProvider);
    final totals = ref.watch(bookingTotalsProvider);

    // Logica semplificata: il pulsante √® abilitato se:
    // 1. "Qualsiasi operatore" √® selezionato (selectedStaff == null e anyOperatorSelected == true)
    // 2. Uno staff specifico √® selezionato (selectedStaff != null)
    // 3. C'√® un solo staff disponibile (auto-selezionato)
    final selectedStaff = bookingState.request.selectedStaff;
    final anyOperatorSelected = bookingState.request.anyOperatorSelected;

    // Conta gli staff idonei
    final eligibleStaffCount = staffAsync.maybeWhen(
      data: (staffList) {
        final services = bookingState.request.services;
        if (services.length > 1) {
          return staffList
              .where(
                (staff) =>
                    services.every((s) => staff.serviceIds.contains(s.id)),
              )
              .length;
        }
        return staffList.length;
      },
      orElse: () => 0,
    );

    // canProceed: staff selezionato OPPURE "qualsiasi" OPPURE un solo staff (auto)
    final canProceed =
        selectedStaff != null || anyOperatorSelected || eligibleStaffCount == 1;

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, -5),
          ),
        ],
      ),
      child: SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Info selezione
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  l10n.servicesSelected(totals.selectedItemCount),
                  style: theme.textTheme.bodyMedium,
                ),
                if (bookingState.request.services.isNotEmpty)
                  Text(
                    _formatTotalPrice(context, totals.totalPrice),
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: theme.colorScheme.primary,
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 12),
            ElevatedButton(
              onPressed: canProceed
                  ? () => ref.read(bookingFlowProvider.notifier).nextStep()
                  : null,
              child: Text(l10n.actionNext),
            ),
          ],
        ),
      ),
    );
  }

  String _formatTotalPrice(BuildContext context, double totalPrice) {
    final l10n = context.l10n;
    if (totalPrice == 0) return l10n.servicesFree;
    return '‚Ç¨${totalPrice.toStringAsFixed(2).replaceAll('.', ',')}';
  }
}

class _StaffTile extends StatelessWidget {
  final Staff? staff;
  final bool isSelected;
  final VoidCallback? onTap;

  const _StaffTile({required this.staff, required this.isSelected, this.onTap});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    return Card(
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(
          color: isSelected ? theme.colorScheme.primary : theme.dividerColor,
          width: isSelected ? 2 : 1,
        ),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Avatar
              CircleAvatar(
                radius: 24,
                backgroundColor: staff == null
                    ? theme.colorScheme.primary.withOpacity(0.1)
                    : theme.colorScheme.secondary.withOpacity(0.1),
                child: staff == null
                    ? Icon(Icons.groups, color: theme.colorScheme.primary)
                    : Text(
                        staff!.initials,
                        style: TextStyle(
                          color: theme.colorScheme.secondary,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
              ),
              const SizedBox(width: 16),
              // Info
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      staff?.displayName ?? l10n.staffAnyOperator,
                      style: theme.textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    if (staff == null) ...[
                      const SizedBox(height: 4),
                      Text(
                        l10n.staffAnyOperatorSubtitle,
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.6),
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              // Radio
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected
                      ? theme.colorScheme.primary
                      : Colors.transparent,
                  border: Border.all(
                    color: isSelected
                        ? theme.colorScheme.primary
                        : theme.colorScheme.onSurface.withOpacity(0.3),
                    width: 2,
                  ),
                ),
                child: isSelected
                    ? const Icon(Icons.check, size: 16, color: Colors.white)
                    : null,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/summary_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:intl/intl.dart';

import '../../../../app/providers/route_slug_provider.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/network/api_client.dart';
import '../../../auth/providers/auth_provider.dart';
import '../../providers/booking_provider.dart';
import '../../providers/business_provider.dart';
import '../../providers/locations_provider.dart';
import '../widgets/wrong_business_auth_banner.dart';

class SummaryStep extends ConsumerStatefulWidget {
  const SummaryStep({super.key});

  @override
  ConsumerState<SummaryStep> createState() => _SummaryStepState();
}

class _SummaryStepState extends ConsumerState<SummaryStep> {
  static const int _neverCancellationHours = 100000;
  final _notesController = TextEditingController();
  final _scrollController = ScrollController();
  bool _cancellationPolicyAccepted = false;
  bool _showCancellationPolicyWarning = false;

  void _scrollToBottom() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!_scrollController.hasClients) return;
      final max = _scrollController.position.maxScrollExtent;
      _scrollController.animateTo(
        max,
        duration: const Duration(milliseconds: 260),
        curve: Curves.easeOut,
      );
    });
  }

  @override
  void dispose() {
    _notesController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final bookingState = ref.watch(bookingFlowProvider);
    final request = bookingState.request;
    final totals = ref.watch(bookingTotalsProvider);
    final location = ref.watch(effectiveLocationProvider);
    final business = ref.watch(currentBusinessProvider).value;
    final cancellationHours =
        location?.cancellationHours ?? business?.cancellationHours ?? 24;

    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Header
              Text(
                l10n.summaryTitle,
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                l10n.summarySubtitle,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurface.withOpacity(0.7),
                ),
              ),
              const SizedBox(height: 16),
            ],
          ),
        ),
        Expanded(
          child: SingleChildScrollView(
            controller: _scrollController,
            padding: const EdgeInsets.fromLTRB(16, 0, 16, 16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Banner se autenticato per business diverso
                const WrongBusinessAuthBanner(),

                // Data e ora
                if (request.selectedSlot != null)
                  _SummarySection(
                    title: l10n.summaryDateTime,
                    icon: Icons.calendar_today,
                    child: Text(
                      DateFormat(
                        "EEEE d MMMM yyyy 'alle' HH:mm",
                        'it',
                      ).format(request.selectedSlot!.startTime),
                      style: theme.textTheme.bodyMedium,
                    ),
                  ),
                if (request.selectedSlot != null) const SizedBox(height: 16),

                // Servizi selezionati (con operatore)
                _SummarySection(
                  title: l10n.summaryServices,
                  icon: Icons.list_alt,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      if (totals.selectedPackages.isNotEmpty)
                        ...totals.selectedPackages.map((package) {
                          return Padding(
                            padding: const EdgeInsets.symmetric(vertical: 4),
                            child: Row(
                              mainAxisAlignment: MainAxisAlignment.spaceBetween,
                              crossAxisAlignment: CrossAxisAlignment.end,
                              children: [
                                Expanded(
                                  child: Column(
                                    crossAxisAlignment:
                                        CrossAxisAlignment.start,
                                    children: [
                                      Text(
                                        package.name,
                                        style: theme.textTheme.bodyMedium
                                            ?.copyWith(
                                              fontWeight: FontWeight.w600,
                                            ),
                                      ),
                                      if (totals.selectedItemCount > 1)
                                        Text(
                                          context.localizedDurationLabel(
                                            package.effectiveDurationMinutes,
                                          ),
                                          style: theme.textTheme.bodySmall
                                              ?.copyWith(
                                                color: theme
                                                    .colorScheme
                                                    .onSurface
                                                    .withOpacity(0.6),
                                              ),
                                        ),
                                    ],
                                  ),
                                ),
                                if (totals.selectedItemCount > 1)
                                  Text(
                                    _formatTotalPrice(
                                      context,
                                      package.effectivePrice,
                                    ).replaceFirst('‚Ç¨', '').trim(),
                                    style: theme.textTheme.bodySmall?.copyWith(
                                      color: theme.colorScheme.onSurface
                                          .withOpacity(0.6),
                                    ),
                                  ),
                              ],
                            ),
                          );
                        }),
                      ...request.services
                          .where(
                            (service) =>
                                request.isServiceManuallySelected(service.id),
                          )
                          .map((service) {
                            final staff = request.staffForService(service.id);
                            final isCovered = totals.coveredServiceIds.contains(
                              service.id,
                            );
                            final operatorLabel =
                                request.isAnyOperatorForService(service.id)
                                ? l10n.staffAnyOperator
                                : (staff != null
                                      ? staff.fullName
                                      : l10n.staffAnyOperator);
                            return Padding(
                              padding: const EdgeInsets.symmetric(vertical: 4),
                              child: Row(
                                mainAxisAlignment:
                                    MainAxisAlignment.spaceBetween,
                                crossAxisAlignment: CrossAxisAlignment.end,
                                children: [
                                  Expanded(
                                    child: Column(
                                      crossAxisAlignment:
                                          CrossAxisAlignment.start,
                                      children: [
                                        Text(
                                          service.name,
                                          style: theme.textTheme.bodyMedium
                                              ?.copyWith(
                                                fontWeight: FontWeight.w600,
                                              ),
                                        ),
                                        Text(
                                          operatorLabel,
                                          style: theme.textTheme.bodySmall
                                              ?.copyWith(
                                                color: theme
                                                    .colorScheme
                                                    .onSurface
                                                    .withOpacity(0.6),
                                              ),
                                        ),
                                        if (totals.selectedItemCount > 1 &&
                                            !isCovered)
                                          Text(
                                            context.localizedDurationLabel(
                                              service.totalDurationMinutes,
                                            ),
                                            style: theme.textTheme.bodySmall
                                                ?.copyWith(
                                                  color: theme
                                                      .colorScheme
                                                      .onSurface
                                                      .withOpacity(0.6),
                                                ),
                                          ),
                                      ],
                                    ),
                                  ),
                                  if (totals.selectedItemCount > 1 &&
                                      !isCovered)
                                    Text(
                                      service.formattedPrice,
                                      style: theme.textTheme.bodySmall
                                          ?.copyWith(
                                            color: theme.colorScheme.onSurface
                                                .withOpacity(0.6),
                                          ),
                                    ),
                                ],
                              ),
                            );
                          }),
                      const SizedBox(height: 12),
                      LayoutBuilder(
                        builder: (context, constraints) {
                          return SizedBox(
                            height: 1,
                            child: Stack(
                              children: [
                                Positioned(
                                  left: -16,
                                  right: -16,
                                  top: 0,
                                  child: Divider(
                                    height: 1,
                                    color: theme.dividerColor,
                                  ),
                                ),
                              ],
                            ),
                          );
                        },
                      ),
                      const SizedBox(height: 12),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(
                            l10n.summaryDuration,
                            style: theme.textTheme.bodyMedium?.copyWith(
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                          Row(
                            children: [
                              Text(
                                l10n.summaryPrice,
                                style: theme.textTheme.bodyMedium?.copyWith(
                                  fontWeight: FontWeight.w600,
                                ),
                              ),
                            ],
                          ),
                        ],
                      ),
                      const SizedBox(height: 6),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Row(
                            children: [
                              Icon(
                                Icons.schedule,
                                size: 16,
                                color: theme.colorScheme.onSurface.withOpacity(
                                  0.7,
                                ),
                              ),
                              const SizedBox(width: 6),
                              Text(
                                context.localizedDurationLabel(
                                  totals.totalDurationMinutes,
                                ),
                                style: theme.textTheme.bodyMedium,
                              ),
                            ],
                          ),
                          Row(
                            children: [
                              Icon(
                                Icons.euro,
                                size: 16,
                                color: theme.colorScheme.primary,
                              ),
                              const SizedBox(width: 6),
                              Text(
                                _formatTotalPrice(
                                  context,
                                  totals.totalPrice,
                                ).replaceFirst('‚Ç¨', '').trim(),
                                style: theme.textTheme.bodyMedium?.copyWith(
                                  fontWeight: FontWeight.w700,
                                  color: theme.colorScheme.primary,
                                ),
                              ),
                            ],
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 16),

                const SizedBox(height: 24),

                // Note
                Text(
                  l10n.summaryNotes,
                  style: theme.textTheme.titleSmall?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 8),
                TextField(
                  controller: _notesController,
                  maxLines: 3,
                  decoration: InputDecoration(
                    hintText: l10n.summaryNotesHint,
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                  onChanged: (value) {
                    ref.read(bookingFlowProvider.notifier).updateNotes(value);
                  },
                ),
                const SizedBox(height: 16),

                // Policy modifica/cancellazione (ultima informazione)
                _SummarySection(
                  title: l10n.summaryCancellationPolicyTitle,
                  icon: Icons.policy_outlined,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        _formatCancellationPolicy(context, cancellationHours),
                        style: theme.textTheme.bodyMedium,
                      ),
                      const SizedBox(height: 14),
                      Row(
                        crossAxisAlignment: CrossAxisAlignment.center,
                        children: [
                          SizedBox(
                            width: 18,
                            height: 18,
                            child: Theme(
                              data: theme.copyWith(
                                materialTapTargetSize:
                                    MaterialTapTargetSize.shrinkWrap,
                                visualDensity: const VisualDensity(
                                  horizontal: -4,
                                  vertical: -4,
                                ),
                              ),
                              child: Checkbox(
                                value: _cancellationPolicyAccepted,
                                onChanged: (value) {
                                  setState(() {
                                    _cancellationPolicyAccepted =
                                        value ?? false;
                                    if (_cancellationPolicyAccepted) {
                                      _showCancellationPolicyWarning = false;
                                    }
                                  });
                                },
                              ),
                            ),
                          ),
                          const SizedBox(width: 8),
                          Flexible(
                            child: GestureDetector(
                              behavior: HitTestBehavior.opaque,
                              onTap: () {
                                setState(() {
                                  _cancellationPolicyAccepted =
                                      !_cancellationPolicyAccepted;
                                  if (_cancellationPolicyAccepted) {
                                    _showCancellationPolicyWarning = false;
                                  }
                                });
                              },
                              child: Text(
                                l10n.summaryCancellationPolicyAcceptLabel,
                                textAlign: TextAlign.left,
                                style: theme.textTheme.bodyMedium,
                              ),
                            ),
                          ),
                        ],
                      ),
                      if (_showCancellationPolicyWarning) ...[
                        const SizedBox(height: 8),
                        Text(
                          l10n.summaryCancellationPolicyAcceptRequiredError,
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: theme.colorScheme.error,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      ],
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),

        // Footer
        _buildFooter(context, ref, bookingState),
      ],
    );
  }

  Widget _buildFooter(
    BuildContext context,
    WidgetRef ref,
    BookingFlowState state,
  ) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final isAuthenticated = ref.watch(
      authProvider.select((state) => state.isAuthenticated),
    );
    final slug = ref.watch(routeSlugProvider);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, -5),
          ),
        ],
      ),
      child: SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Errore
            if (state.errorMessage != null) ...[
              Container(
                padding: const EdgeInsets.all(12),
                margin: const EdgeInsets.only(bottom: 12),
                decoration: BoxDecoration(
                  color: theme.colorScheme.error.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    Icon(Icons.error_outline, color: theme.colorScheme.error),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        _resolveBookingErrorMessage(context, state),
                        style: TextStyle(color: theme.colorScheme.error),
                      ),
                    ),
                  ],
                ),
              ),
            ],
            // Bottone conferma
            ElevatedButton(
              onPressed: state.isLoading
                  ? null
                  : () async {
                      if (!isAuthenticated && slug != null) {
                        context.go('/$slug/login');
                        return;
                      }
                      if (!_cancellationPolicyAccepted) {
                        setState(() {
                          _showCancellationPolicyWarning = true;
                        });
                        _scrollToBottom();
                        return;
                      }
                      if (_showCancellationPolicyWarning) {
                        setState(() {
                          _showCancellationPolicyWarning = false;
                        });
                      }
                      try {
                        await ref
                            .read(bookingFlowProvider.notifier)
                            .confirmBooking();
                      } on TokenExpiredException {
                        // Sessione scaduta - reindirizza al login
                        // Lo stato della prenotazione √® gi√† salvato in localStorage
                        if (context.mounted && slug != null) {
                          context.go('/$slug/login');
                        }
                      }
                    },
              child: state.isLoading
                  ? const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.white,
                      ),
                    )
                  : Text(l10n.actionConfirm),
            ),
          ],
        ),
      ),
    );
  }

  String _formatTotalPrice(BuildContext context, double totalPrice) {
    final l10n = context.l10n;
    if (totalPrice == 0) return l10n.servicesFree;
    return '‚Ç¨${totalPrice.toStringAsFixed(2).replaceAll('.', ',')}';
  }

  String _resolveBookingErrorMessage(
    BuildContext context,
    BookingFlowState state,
  ) {
    final l10n = context.l10n;
    switch (state.errorCode) {
      case 'slot_conflict':
        return l10n.bookingErrorSlotConflict;
      case 'invalid_service':
        return l10n.bookingErrorInvalidService;
      case 'invalid_staff':
        return l10n.bookingErrorInvalidStaff;
      case 'invalid_location':
        return l10n.bookingErrorInvalidLocation;
      case 'invalid_client':
        return l10n.bookingErrorInvalidClient;
      case 'invalid_time':
        return l10n.bookingErrorInvalidTime;
      case 'staff_unavailable':
        return l10n.bookingErrorStaffUnavailable;
      case 'outside_working_hours':
        return l10n.bookingErrorOutsideWorkingHours;
      case 'not_found':
        return l10n.bookingErrorNotFound;
      case 'unauthorized':
        return l10n.bookingErrorUnauthorized;
      case 'validation_error':
        return l10n.bookingErrorValidation;
      case 'internal_error':
        return l10n.bookingErrorServer;
    }
    return state.errorMessage ?? l10n.errorGeneric;
  }

  String _formatCancellationPolicy(BuildContext context, int hours) {
    final l10n = context.l10n;
    if (hours == _neverCancellationHours) {
      return l10n.summaryCancellationPolicyNever;
    }
    if (hours == 0) {
      return l10n.summaryCancellationPolicyAlways;
    }
    if (hours >= 24 && hours % 24 == 0) {
      return l10n.summaryCancellationPolicyDays(hours ~/ 24);
    }
    return l10n.summaryCancellationPolicyHours(hours);
  }
}

class _SummarySection extends StatelessWidget {
  final String title;
  final IconData icon;
  final Widget child;

  const _SummarySection({
    required this.title,
    required this.icon,
    required this.child,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Card(
      margin: EdgeInsets.zero,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(icon, size: 18, color: theme.colorScheme.primary),
                const SizedBox(width: 8),
                Text(
                  title,
                  style: theme.textTheme.titleSmall?.copyWith(
                    fontWeight: FontWeight.w600,
                    color: theme.colorScheme.onSurface.withOpacity(0.7),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            child,
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/services_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';
import '../../../../core/models/service_package.dart';
import '../../../../core/network/api_client.dart';
import '../../../../core/widgets/centered_error_view.dart';
import '../../providers/booking_provider.dart';

class ServicesStep extends ConsumerStatefulWidget {
  const ServicesStep({super.key});

  @override
  ConsumerState<ServicesStep> createState() => _ServicesStepState();
}

class _ServicesStepState extends ConsumerState<ServicesStep> {
  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final servicesDataAsync = ref.watch(servicesDataProvider);
    final packagesAsync = ref.watch(servicePackagesProvider);
    final bookingState = ref.watch(bookingFlowProvider);
    final selectedServices = bookingState.request.services;
    final isLoading = servicesDataAsync.isLoading;

    if (servicesDataAsync.hasError) {
      return _buildErrorWidget(context, ref, servicesDataAsync.error!);
    }

    return Stack(
      children: [
        Column(
          children: [
            // Header
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    l10n.servicesTitle,
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    l10n.servicesSubtitle,
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: theme.colorScheme.onSurface.withOpacity(0.7),
                    ),
                  ),
                ],
              ),
            ),

            // Lista servizi per categoria (singola chiamata API)
            Expanded(
              child: servicesDataAsync.when(
                loading: () => const SizedBox.shrink(),
                error: (e, _) => const SizedBox.shrink(),
                data: (data) {
                  final packages =
                      packagesAsync.value ?? const <ServicePackage>[];
                  if (data.bookableServices.isEmpty && packages.isEmpty) {
                    return _EmptyView(
                      title: l10n.servicesEmpty,
                      subtitle: l10n.servicesEmptySubtitle,
                    );
                  }

                  return _buildServicesList(
                    context,
                    ref,
                    data.categories,
                    data.bookableServices,
                    data.serviceIdsWithEligibleStaff,
                    data.services,
                    bookingState.request.selectedServiceIds,
                    bookingState.request.selectedPackageIds,
                    selectedServices,
                    packagesAsync,
                  );
                },
              ),
            ),

            // Footer con selezione e bottone
            _buildFooter(context, ref, selectedServices),
          ],
        ),
        if (isLoading)
          Positioned.fill(
            child: ColoredBox(
              color: theme.colorScheme.surface.withOpacity(0.6),
              child: const Center(child: CircularProgressIndicator()),
            ),
          ),
      ],
    );
  }

  /// Costruisce il widget di errore appropriato in base al tipo di errore
  Widget _buildErrorWidget(BuildContext context, WidgetRef ref, Object error) {
    final l10n = context.l10n;

    // Determina titolo e sottotitolo in base al tipo di errore
    String title;
    String subtitle;
    IconData icon;
    bool showRetry;

    if (error is ApiException) {
      if (error.isLocationNotFound) {
        title = l10n.errorLocationNotFound;
        subtitle = l10n.errorLocationNotFoundSubtitle;
        icon = Icons.location_off_outlined;
        showRetry = false;
      } else if (error.isBusinessNotFound) {
        title = l10n.errorBusinessNotFound;
        subtitle = l10n.errorBusinessNotFoundSubtitle;
        icon = Icons.store_outlined;
        showRetry = false;
      } else if (error.isServiceUnavailable) {
        title = l10n.errorServiceUnavailable;
        subtitle = l10n.errorServiceUnavailableSubtitle;
        icon = Icons.cloud_off_outlined;
        showRetry = true;
      } else {
        title = l10n.errorLoadingServices;
        subtitle = error.message;
        icon = Icons.error_outline;
        showRetry = true;
      }
    } else {
      title = l10n.errorLoadingServices;
      subtitle = '';
      icon = Icons.cloud_off_outlined;
      showRetry = true;
    }

    return _ErrorView(
      title: title,
      subtitle: subtitle,
      icon: icon,
      onRetry: showRetry
          ? () => ref.read(servicesDataProvider.notifier).refresh()
          : null,
    );
  }

  Widget _buildServicesList(
    BuildContext context,
    WidgetRef ref,
    List<ServiceCategory> categories,
    List<Service> services,
    Set<int> serviceIdsWithEligibleStaff,
    List<Service> allServices,
    Set<int> selectedServiceIds,
    Set<int> selectedPackageIds,
    List<Service> selectedServices,
    AsyncValue<List<ServicePackage>> packagesAsync,
  ) {
    final widgets = <Widget>[];
    final packages = packagesAsync.value ?? [];
    // Per i pacchetti usiamo tutti i servizi con staff eligible (non solo quelli
    // prenotabili online singolarmente): un pacchetto deve essere visibile anche
    // se i suoi servizi componenti non sono prenotabili online individualmente.
    final allServiceIds = allServices.map((s) => s.id).toSet();
    final visiblePackages = packages.where((package) {
      if (!package.isActive || !package.isBookableOnline || package.isBroken) {
        return false;
      }
      final packageServiceIds = package.orderedServiceIds;
      if (packageServiceIds.isEmpty) return false;
      return packageServiceIds.every(
        (serviceId) => allServiceIds.contains(serviceId),
      );
    }).toList();
    final serviceById = {for (final s in allServices) s.id: s};
    final l10n = context.l10n;

    if (packagesAsync.hasError) {
      widgets.add(
        Padding(
          padding: const EdgeInsets.fromLTRB(16, 8, 16, 8),
          child: Text(
            context.l10n.servicePackagesLoadError,
            style: TextStyle(color: Theme.of(context).colorScheme.error),
          ),
        ),
      );
    }

    final categoryIds = categories.map((c) => c.id).toSet();
    final maxSortOrder = categories.fold<int>(
      -1,
      (max, c) => c.sortOrder > max ? c.sortOrder : max,
    );
    var extraIndex = 0;
    final extraCategories = <ServiceCategory>[];
    for (final package in visiblePackages) {
      final packageCategoryId = package.categoryId;
      if (packageCategoryId <= 0 || categoryIds.contains(packageCategoryId)) {
        continue;
      }
      final name =
          (package.categoryName != null &&
              package.categoryName!.trim().isNotEmpty)
          ? package.categoryName!
          : l10n.servicesCategoryFallbackName(packageCategoryId);
      extraCategories.add(
        ServiceCategory(
          id: packageCategoryId,
          businessId: 0,
          name: name,
          sortOrder: maxSortOrder + 1 + extraIndex++,
        ),
      );
      categoryIds.add(packageCategoryId);
    }

    final allCategories = [...categories, ...extraCategories]
      ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));

    // Prima passata: costruisci le entries per categoria.
    final categoryDataList =
        <({ServiceCategory category, List<_CategoryEntry> entries})>[];

    for (final category in allCategories) {
      final categoryServices =
          services
              .where((s) => s.categoryId == category.id && s.isBookableOnline)
              .toList()
            ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));

      final categoryPackages =
          visiblePackages.where((p) {
            final effectiveCategoryId = p.categoryId != 0
                ? p.categoryId
                : (p.items.isNotEmpty
                      ? serviceById[p.items.first.serviceId]?.categoryId
                      : null);
            return effectiveCategoryId == category.id;
          }).toList()..sort((a, b) {
            final so = a.sortOrder.compareTo(b.sortOrder);
            return so != 0
                ? so
                : a.name.toLowerCase().compareTo(b.name.toLowerCase());
          });

      // Non mostrare categorie senza servizi prenotabili n√© pacchetti visibili.
      if (categoryServices.isEmpty && categoryPackages.isEmpty) continue;

      final categoryEntries =
          <_CategoryEntry>[
            for (final service in categoryServices)
              _CategoryEntry.service(service),
            for (final package in categoryPackages)
              _CategoryEntry.package(package),
          ]..sort((a, b) {
            final so = a.sortOrder.compareTo(b.sortOrder);
            return so != 0
                ? so
                : a.name.toLowerCase().compareTo(b.name.toLowerCase());
          });

      if (categoryEntries.isEmpty) continue;
      categoryDataList.add((category: category, entries: categoryEntries));
    }

    // Seconda passata: determina se mostrare categorie collassabili.
    final totalEntries = categoryDataList.fold<int>(
      0,
      (sum, d) => sum + d.entries.length,
    );
    final isCollapsible = totalEntries > 30 && categoryDataList.length >= 3;

    for (final data in categoryDataList) {
      widgets.add(
        _CategorySection(
          category: data.category,
          entries: data.entries,
          selectedServiceIds: selectedServiceIds,
          selectedPackageIds: selectedPackageIds,
          selectedServices: selectedServices,
          isCollapsible: isCollapsible,
          onServiceTap: (service) {
            ref.read(bookingFlowProvider.notifier).toggleService(service);
          },
          onPackageTap: (package) {
            ref
                .read(bookingFlowProvider.notifier)
                .togglePackageSelection(package, services);
          },
        ),
      );
    }

    return ListView(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      children: widgets,
    );
  }

  Widget _buildFooter(
    BuildContext context,
    WidgetRef ref,
    List<Service> selectedServices,
  ) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final bookingState = ref.watch(bookingFlowProvider);
    final totals = ref.watch(bookingTotalsProvider);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, -5),
          ),
        ],
      ),
      child: SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Info selezione
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  l10n.servicesSelected(totals.selectedItemCount),
                  style: theme.textTheme.bodyMedium,
                ),
                if (selectedServices.isNotEmpty)
                  Text(
                    _formatTotalPrice(context, totals.totalPrice),
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: theme.colorScheme.primary,
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 12),
            // Bottone avanti
            ElevatedButton(
              onPressed: bookingState.canGoNext
                  ? () => ref
                        .read(bookingFlowProvider.notifier)
                        .nextFromServicesWithAutoStaff()
                  : null,
              child: Text(l10n.actionNext),
            ),
          ],
        ),
      ),
    );
  }

  String _formatTotalPrice(BuildContext context, double totalPrice) {
    final l10n = context.l10n;
    if (totalPrice == 0) return l10n.servicesFree;
    return '‚Ç¨${totalPrice.toStringAsFixed(2).replaceAll('.', ',')}';
  }
}

class _CategorySection extends StatefulWidget {
  final ServiceCategory category;
  final List<_CategoryEntry> entries;
  final Set<int> selectedServiceIds;
  final Set<int> selectedPackageIds;
  final List<Service> selectedServices;
  final void Function(Service) onServiceTap;
  final void Function(ServicePackage) onPackageTap;
  final bool isCollapsible;

  const _CategorySection({
    required this.category,
    required this.entries,
    required this.selectedServiceIds,
    required this.selectedPackageIds,
    required this.selectedServices,
    required this.onServiceTap,
    required this.onPackageTap,
    this.isCollapsible = false,
  });

  @override
  State<_CategorySection> createState() => _CategorySectionState();
}

class _CategorySectionState extends State<_CategorySection> {
  late bool _isExpanded;

  @override
  void initState() {
    super.initState();
    _isExpanded = !widget.isCollapsible;
  }

  @override
  void didUpdateWidget(_CategorySection oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.isCollapsible != widget.isCollapsible) {
      _isExpanded = !widget.isCollapsible;
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final borderColor = theme.colorScheme.outlineVariant.withOpacity(0.18);

    final selectedCount = widget.entries.where((e) {
      if (e.isPackage) return widget.selectedPackageIds.contains(e.package!.id);
      return widget.selectedServiceIds.contains(e.service!.id);
    }).length;

    final header = GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: widget.isCollapsible
          ? () => setState(() => _isExpanded = !_isExpanded)
          : null,
      child: Padding(
        padding: EdgeInsets.fromLTRB(
          widget.isCollapsible ? 14 : 0,
          12,
          widget.isCollapsible ? 8 : 0,
          12,
        ),
        child: Row(
          children: [
            // Sinistra: nome + chip totale
            Expanded(
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Flexible(
                    child: Text(
                      widget.category.name,
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                  if (widget.isCollapsible) ...[
                    const SizedBox(width: 8),
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 7,
                        vertical: 2,
                      ),
                      decoration: BoxDecoration(
                        color: theme.colorScheme.onSurface.withOpacity(0.06),
                        borderRadius: BorderRadius.circular(10),
                      ),
                      child: Text(
                        '${widget.entries.length}',
                        style: theme.textTheme.labelSmall?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.45),
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                  ],
                ],
              ),
            ),
            // Destra: chip selezionati + freccia
            if (selectedCount > 0) ...[
              const SizedBox(width: 8),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 7, vertical: 2),
                decoration: BoxDecoration(
                  color: theme.colorScheme.primary.withOpacity(0.12),
                  borderRadius: BorderRadius.circular(10),
                ),
                child: Text(
                  '$selectedCount',
                  style: theme.textTheme.labelSmall?.copyWith(
                    color: theme.colorScheme.primary,
                    fontWeight: FontWeight.w700,
                  ),
                ),
              ),
            ],
            if (widget.isCollapsible) ...[
              const SizedBox(width: 4),
              AnimatedRotation(
                turns: _isExpanded ? 0.25 : 0,
                duration: const Duration(milliseconds: 250),
                child: const Icon(Icons.chevron_right),
              ),
            ],
          ],
        ),
      ),
    );

    final body = AnimatedSize(
      duration: const Duration(milliseconds: 250),
      curve: Curves.easeInOut,
      alignment: Alignment.topCenter,
      child: _isExpanded
          ? Padding(
              padding: widget.isCollapsible
                  ? const EdgeInsets.fromLTRB(10, 0, 10, 10)
                  : EdgeInsets.zero,
              child: Column(
                children: [
                  for (final entry in widget.entries)
                    if (entry.isPackage)
                      _PackageTile(
                        package: entry.package!,
                        isSelected: widget.selectedPackageIds.contains(
                          entry.package!.id,
                        ),
                        isDisabled:
                            !entry.package!.isActive ||
                            entry.package!.isBroken,
                        onTap:
                            (!entry.package!.isActive ||
                                entry.package!.isBroken)
                            ? null
                            : () => widget.onPackageTap(entry.package!),
                      )
                    else
                      _ServiceTile(
                        service: entry.service!,
                        isSelected: widget.selectedServiceIds.contains(
                          entry.service!.id,
                        ),
                        onTap: () => widget.onServiceTap(entry.service!),
                      ),
                  if (!widget.isCollapsible) const SizedBox(height: 8),
                ],
              ),
            )
          : const SizedBox.shrink(),
    );

    if (!widget.isCollapsible) {
      return Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [header, body],
      );
    }

    return Container(
      margin: const EdgeInsets.only(bottom: 12),
      decoration: BoxDecoration(
        border: Border.all(color: borderColor),
        borderRadius: BorderRadius.circular(12),
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(12),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [header, body],
        ),
      ),
    );
  }
}

class _ServiceTile extends StatelessWidget {
  final Service service;
  final bool isSelected;
  final VoidCallback onTap;

  const _ServiceTile({
    required this.service,
    required this.isSelected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(
          color: isSelected ? theme.colorScheme.primary : theme.dividerColor,
          width: isSelected ? 2 : 1,
        ),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Checkbox
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected
                      ? theme.colorScheme.primary
                      : Colors.transparent,
                  border: Border.all(
                    color: isSelected
                        ? theme.colorScheme.primary
                        : theme.colorScheme.onSurface.withOpacity(0.3),
                    width: 2,
                  ),
                ),
                child: isSelected
                    ? const Icon(Icons.check, size: 16, color: Colors.white)
                    : null,
              ),
              const SizedBox(width: 16),
              // Info servizio
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      service.name,
                      style: theme.textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      context.localizedDurationLabel(service.totalDurationMinutes),
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onSurface.withOpacity(0.6),
                      ),
                    ),
                  ],
                ),
              ),
              // Prezzo
              Text(
                service.formattedPrice,
                style: theme.textTheme.titleSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: theme.colorScheme.primary,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _CategoryEntry {
  final Service? service;
  final ServicePackage? package;

  const _CategoryEntry._({this.service, this.package});

  const _CategoryEntry.service(Service service) : this._(service: service);

  const _CategoryEntry.package(ServicePackage package)
    : this._(package: package);

  bool get isPackage => package != null;

  int get sortOrder => service?.sortOrder ?? package!.sortOrder;

  String get name => service?.name ?? package!.name;
}

class _PackageTile extends StatelessWidget {
  final ServicePackage package;
  final bool isSelected;
  final bool isDisabled;
  final VoidCallback? onTap;

  const _PackageTile({
    required this.package,
    required this.isSelected,
    required this.isDisabled,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final price = package.effectivePrice;
    final priceLabel = price == 0
        ? l10n.servicesFree
        : '‚Ç¨${price.toStringAsFixed(2).replaceAll('.', ',')}';

    return Opacity(
      opacity: isDisabled ? 0.5 : 1.0,
      child: Card(
        margin: const EdgeInsets.only(bottom: 8),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(12),
          side: BorderSide(
            color: isSelected ? theme.colorScheme.primary : theme.dividerColor,
            width: isSelected ? 2 : 1,
          ),
        ),
        child: InkWell(
          onTap: onTap,
          borderRadius: BorderRadius.circular(12),
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Row(
              children: [
                Container(
                  width: 24,
                  height: 24,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    color: isSelected
                        ? theme.colorScheme.primary
                        : Colors.transparent,
                    border: Border.all(
                      color: isSelected
                          ? theme.colorScheme.primary
                          : theme.colorScheme.onSurface.withOpacity(0.3),
                      width: 2,
                    ),
                  ),
                  child: isSelected
                      ? const Icon(Icons.check, size: 16, color: Colors.white)
                      : null,
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Expanded(
                            child: Text(
                              package.name,
                              style: theme.textTheme.titleSmall?.copyWith(
                                fontWeight: FontWeight.w600,
                              ),
                            ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 4),
                      Text(
                        context.localizedDurationLabel(
                          package.effectiveDurationMinutes,
                        ),
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.6),
                        ),
                      ),
                    ],
                  ),
                ),
                Text(
                  priceLabel,
                  style: theme.textTheme.titleSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: theme.colorScheme.primary,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

/// Widget per mostrare errori con bottone retry
class _ErrorView extends StatelessWidget {
  final String title;
  final String subtitle;
  final IconData icon;
  final VoidCallback? onRetry;

  const _ErrorView({
    required this.title,
    this.subtitle = '',
    this.icon = Icons.cloud_off_outlined,
    this.onRetry,
  });

  @override
  Widget build(BuildContext context) {
    return CenteredErrorView(
      title: title,
      subtitle: subtitle,
      icon: icon,
      onRetry: onRetry,
      retryLabel: context.l10n.actionRetry,
    );
  }
}

/// Widget per mostrare stato vuoto
class _EmptyView extends StatelessWidget {
  final String title;
  final String subtitle;

  const _EmptyView({required this.title, required this.subtitle});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.event_busy_outlined,
              size: 64,
              color: theme.colorScheme.onSurface.withOpacity(0.3),
            ),
            const SizedBox(height: 16),
            Text(
              title,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              subtitle,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.6),
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/my_bookings_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:intl/intl.dart';

import '/app/providers/form_factor_provider.dart';
import '/app/providers/route_slug_provider.dart';
import '/core/l10n/l10_extension.dart';
import '/core/models/booking_item.dart';
import '/core/services/tenant_time_service.dart';
import '/core/widgets/booking_app_bar.dart';
import '/core/widgets/feedback_dialog.dart';
import '/features/auth/domain/auth_state.dart';
import '/features/auth/providers/auth_provider.dart';
import '/features/booking/providers/business_provider.dart';
import '/features/booking/providers/locations_provider.dart';
import '/features/booking/providers/my_bookings_provider.dart';
import '../dialogs/booking_history_dialog.dart';
import '../dialogs/reschedule_booking_dialog.dart';

class MyBookingsScreen extends ConsumerStatefulWidget {
  const MyBookingsScreen({super.key});

  @override
  ConsumerState<MyBookingsScreen> createState() => _MyBookingsScreenState();
}

class _MyBookingsScreenState extends ConsumerState<MyBookingsScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  bool _isCancellingBooking = false;
  bool _hasRequestedLoad = false;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    ref.listen<AuthState>(authProvider, (previous, next) {
      if (!next.isAuthenticated) {
        _hasRequestedLoad = false;
        return;
      }
      if (_hasRequestedLoad) return;
      _hasRequestedLoad = true;
      ref.read(myBookingsProvider.notifier).loadBookings();
    });

    final authState = ref.watch(authProvider);
    if (authState.isAuthenticated && !_hasRequestedLoad) {
      _hasRequestedLoad = true;
      Future.microtask(
        () => ref.read(myBookingsProvider.notifier).loadBookings(),
      );
    }

    final bookingsState = ref.watch(myBookingsProvider);
    final cancelledBookings =
        [
            ...bookingsState.upcoming,
            ...bookingsState.past,
          ].where((b) => b.isCancelled && b.status != 'replaced').toList()
          ..sort((a, b) => b.startTime.compareTo(a.startTime));
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final l10n = context.l10n;

    return Scaffold(
      appBar: BookingAppBar(
        showBackButton: true,
        // Mostra sempre icona calendario per navigare a nuova prenotazione
        backIcon: Icons.calendar_month,
        backTooltip: l10n.confirmationNewBooking,
        onBackPressed: () {
          // Naviga sempre alla pagina di prenotazione (pi√π affidabile su web)
          final slug = ref.read(routeSlugProvider);
          context.go('/$slug/booking');
        },
        showUserMenu: false,
        title: l10n.myBookings,
        bottom: TabBar(
          controller: _tabController,
          labelColor: colorScheme.primary,
          unselectedLabelColor: colorScheme.onSurface.withOpacity(0.6),
          indicatorColor: colorScheme.primary,
          indicatorWeight: 2,
          labelStyle: theme.textTheme.labelLarge?.copyWith(
            fontWeight: FontWeight.w600,
          ),
          tabs: [
            Tab(text: context.l10n.upcomingBookings),
            Tab(text: context.l10n.pastBookings),
            Tab(text: context.l10n.cancelledBookings),
          ],
        ),
      ),
      body: Stack(
        children: [
          bookingsState.isLoading
              ? const Center(child: CircularProgressIndicator())
              : bookingsState.error != null
              ? _ErrorView(error: bookingsState.error!)
              : Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Expanded(
                      child: TabBarView(
                        controller: _tabController,
                        children: [
                          _BookingsList(
                            bookings: bookingsState.upcoming,
                            tabType: _BookingsTabType.upcoming,
                            onCancelLoadingChanged: _setCancelLoading,
                          ),
                          _BookingsList(
                            bookings: bookingsState.past,
                            tabType: _BookingsTabType.past,
                            onCancelLoadingChanged: _setCancelLoading,
                          ),
                          _BookingsList(
                            bookings: cancelledBookings,
                            tabType: _BookingsTabType.cancelled,
                            onCancelLoadingChanged: _setCancelLoading,
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
          if (_isCancellingBooking)
            Positioned.fill(
              child: AbsorbPointer(
                child: DecoratedBox(
                  decoration: BoxDecoration(
                    color: theme.colorScheme.surface.withOpacity(0.6),
                  ),
                  child: const Center(child: CircularProgressIndicator()),
                ),
              ),
            ),
        ],
      ),
    );
  }

  void _setCancelLoading(bool value) {
    if (_isCancellingBooking == value) return;
    setState(() => _isCancellingBooking = value);
  }
}

class _ErrorView extends StatelessWidget {
  const _ErrorView({required this.error});

  final String error;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 64, color: Colors.red),
            const SizedBox(height: 16),
            Text(
              context.l10n.errorLoadingBookings,
              style: Theme.of(context).textTheme.titleMedium,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              error,
              style: Theme.of(context).textTheme.bodySmall,
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}

class _BookingsList extends StatelessWidget {
  const _BookingsList({
    required this.bookings,
    required this.tabType,
    required this.onCancelLoadingChanged,
  });

  final List<BookingItem> bookings;
  final _BookingsTabType tabType;
  final ValueChanged<bool> onCancelLoadingChanged;

  @override
  Widget build(BuildContext context) {
    final visibleBookings = bookings.where((b) => b.status != 'replaced').where(
      (b) {
        switch (tabType) {
          case _BookingsTabType.upcoming:
          case _BookingsTabType.past:
            return !b.isCancelled;
          case _BookingsTabType.cancelled:
            return b.isCancelled;
        }
      },
    ).toList();
    if (visibleBookings.isEmpty) {
      final emptyIcon = switch (tabType) {
        _BookingsTabType.upcoming => Icons.event_busy,
        _BookingsTabType.past => Icons.history,
        _BookingsTabType.cancelled => Icons.cancel_outlined,
      };
      final emptyText = switch (tabType) {
        _BookingsTabType.upcoming => context.l10n.noUpcomingBookings,
        _BookingsTabType.past => context.l10n.noPastBookings,
        _BookingsTabType.cancelled => context.l10n.noCancelledBookings,
      };
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(emptyIcon, size: 64, color: Colors.grey),
            const SizedBox(height: 16),
            Text(emptyText, style: Theme.of(context).textTheme.titleMedium),
          ],
        ),
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: visibleBookings.length,
      itemBuilder: (context, index) {
        final booking = visibleBookings[index];
        return _BookingCard(
          booking: booking,
          isUpcoming: tabType == _BookingsTabType.upcoming,
          onCancelLoadingChanged: onCancelLoadingChanged,
        );
      },
    );
  }
}

enum _BookingsTabType { upcoming, past, cancelled }

class _BookingCard extends ConsumerStatefulWidget {
  const _BookingCard({
    required this.booking,
    required this.isUpcoming,
    required this.onCancelLoadingChanged,
  });

  final BookingItem booking;
  final bool isUpcoming;
  final ValueChanged<bool> onCancelLoadingChanged;

  @override
  ConsumerState<_BookingCard> createState() => _BookingCardState();
}

class _BookingCardState extends ConsumerState<_BookingCard> {
  static const int _neverCancellationHours = 100000;
  bool _isCancelling = false;

  @override
  Widget build(BuildContext context) {
    final booking = widget.booking;
    final formFactor = ref.watch(formFactorProvider);
    final locationsAsync = ref.watch(locationsProvider);
    final location = locationsAsync.maybeWhen(
      data: (locations) =>
          locations.where((l) => l.id == booking.locationId).firstOrNull,
      orElse: () => null,
    );
    final locale = _localeForLocation(context, location?.country);
    final business = ref.watch(currentBusinessProvider).value;
    final showLocation = locationsAsync.maybeWhen(
      data: (locations) => locations.length > 1,
      orElse: () => true,
    );
    final cancellationHours =
        location?.cancellationHours ?? business?.cancellationHours ?? 24;
    final showCancellationPolicy = widget.isUpcoming && !booking.isCancelled;
    final fallbackAddressParts = <String>[
      if ((booking.locationAddress ?? '').trim().isNotEmpty)
        booking.locationAddress!.trim(),
      if ((booking.locationCity ?? '').trim().isNotEmpty)
        booking.locationCity!.trim(),
    ];
    final locationAddress = location?.formattedAddress.isNotEmpty == true
        ? location!.formattedAddress
        : fallbackAddressParts.join(', ');
    final locationDisplayText = locationAddress.isNotEmpty
        ? '${booking.locationName} - $locationAddress'
        : booking.locationName;
    final dateFormat = DateFormat.yMd(locale);
    final timeFormat = DateFormat.jm(locale);
    final theme = Theme.of(context);
    final rowIconColor = theme.colorScheme.onSurface.withOpacity(0.6);
    const actionButtonPadding = EdgeInsets.symmetric(horizontal: 12);
    final modifyButtonStyle = ElevatedButton.styleFrom(
      minimumSize: const Size(0, 40),
      padding: actionButtonPadding,
    );
    final cancelButtonStyle = OutlinedButton.styleFrom(
      minimumSize: const Size(0, 40),
      padding: actionButtonPadding,
      foregroundColor: theme.colorScheme.error,
      side: BorderSide(color: theme.colorScheme.error),
    );

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Intestazione con business e location
            Row(
              children: [
                Icon(Icons.business, size: 20, color: rowIconColor),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    booking.businessName,
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                ),
                // Badge CANCELLATO
                if (booking.isCancelled)
                  Container(
                    margin: const EdgeInsets.only(right: 8),
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: Colors.red.shade600,
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      context.l10n.cancelledBadge,
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 11,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ),
                // Pulsante storico
                IconButton(
                  icon: Icon(Icons.history, size: 20, color: rowIconColor),
                  tooltip: context.l10n.bookingHistoryTitle,
                  onPressed: () => showBookingHistoryDialog(
                    context,
                    ref,
                    bookingId: booking.id,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 4),
            if (showLocation)
              Row(
                children: [
                  Icon(Icons.location_on, size: 18, color: rowIconColor),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      locationDisplayText,
                      style: theme.textTheme.bodyMedium,
                    ),
                  ),
                ],
              ),
            Divider(
              height: 24,
              thickness: 0.8,
              color: theme.colorScheme.outline.withOpacity(0.25),
            ),

            // Servizi
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Icon(Icons.list_alt, size: 18, color: rowIconColor),
                const SizedBox(width: 8),
                Expanded(
                  child: booking.serviceNames.length <= 1
                      ? Text(
                          booking.servicesDisplay,
                          style: theme.textTheme.bodyMedium,
                        )
                      : Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            for (final service in booking.serviceNames)
                              Text(service, style: theme.textTheme.bodyMedium),
                          ],
                        ),
                ),
              ],
            ),

            // Staff (se presente)
            if (booking.staffName != null) ...[
              const SizedBox(height: 8),
              Row(
                children: [
                  Icon(Icons.person, size: 18, color: rowIconColor),
                  const SizedBox(width: 8),
                  Text(
                    booking.staffName!,
                    style: Theme.of(context).textTheme.bodyMedium,
                  ),
                ],
              ),
            ],
            const SizedBox(height: 12),

            // Data e ora
            Row(
              children: [
                Icon(Icons.calendar_today, size: 18, color: rowIconColor),
                const SizedBox(width: 8),
                Text(dateFormat.format(booking.startTime)),
                const SizedBox(width: 16),
                Icon(Icons.access_time, size: 18, color: rowIconColor),
                const SizedBox(width: 8),
                Text(
                  '${timeFormat.format(booking.startTime)} - ${timeFormat.format(booking.endTime)}',
                ),
              ],
            ),

            // Prezzo (se > 0)
            if (booking.totalPrice > 0) ...[
              const SizedBox(height: 8),
              Row(
                children: [
                  Icon(Icons.euro, size: 18, color: rowIconColor),
                  const SizedBox(width: 8),
                  Text(
                    booking.totalPrice.toStringAsFixed(2),
                    style: theme.textTheme.bodyMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ],
              ),
            ],

            if (showCancellationPolicy) ...[
              const SizedBox(height: 8),
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Icon(Icons.policy_outlined, size: 18, color: rowIconColor),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      '${context.l10n.summaryCancellationPolicyTitle}: ${_formatCancellationPolicy(context, cancellationHours)}',
                      style: theme.textTheme.bodySmall,
                    ),
                  ),
                ],
              ),
            ],

            // Note (se presenti)
            if (booking.notes != null && booking.notes!.isNotEmpty) ...[
              const SizedBox(height: 12),
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Icon(
                    Icons.sticky_note_2_outlined,
                    size: 18,
                    color: rowIconColor,
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      booking.notes!,
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                  ),
                ],
              ),
            ],

            // Badge e azioni per prenotazioni future (non cancellate)
            if (widget.isUpcoming && !booking.isCancelled) ...[
              const SizedBox(height: 16),
              if (formFactor == AppFormFactor.mobile)
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    if (booking.canModifyEffective &&
                        booking.canModifyUntil != null)
                      Text(
                        _formatModifiableUntil(
                          context,
                          booking: booking,
                          locale: locale,
                        ),
                        style: Theme.of(context).textTheme.bodySmall,
                      ),
                    if (booking.canModifyEffective) ...[
                      const SizedBox(height: 8),
                      Row(
                        children: [
                          ElevatedButton(
                            onPressed: () => _handleModify(context, ref),
                            style: modifyButtonStyle,
                            child: Text(context.l10n.modify),
                          ),
                          const Spacer(),
                          OutlinedButton(
                            onPressed: _isCancelling
                                ? null
                                : () => _handleCancel(context, ref),
                            style: cancelButtonStyle,
                            child: _isCancelling
                                ? const SizedBox(
                                    width: 16,
                                    height: 16,
                                    child: CircularProgressIndicator(
                                      strokeWidth: 2,
                                    ),
                                  )
                                : Text(context.l10n.actionCancelBooking),
                          ),
                        ],
                      ),
                    ],
                  ],
                )
              else
                Row(
                  children: [
                    // Countdown se modificabile
                    if (booking.canModifyEffective &&
                        booking.canModifyUntil != null)
                      Text(
                        _formatModifiableUntil(
                          context,
                          booking: booking,
                          locale: locale,
                        ),
                        style: Theme.of(context).textTheme.bodySmall,
                      ),

                    const Spacer(),

                    // Pulsanti azione
                    if (booking.canModifyEffective) ...[
                      ElevatedButton(
                        onPressed: () => _handleModify(context, ref),
                        style: modifyButtonStyle,
                        child: Text(context.l10n.modify),
                      ),
                      const SizedBox(width: 8),
                      OutlinedButton(
                        onPressed: _isCancelling
                            ? null
                            : () => _handleCancel(context, ref),
                        style: cancelButtonStyle,
                        child: _isCancelling
                            ? const SizedBox(
                                width: 16,
                                height: 16,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                ),
                              )
                            : Text(context.l10n.actionCancelBooking),
                      ),
                    ],
                  ],
                ),
            ],
          ],
        ),
      ),
    );
  }

  String _formatModifiableUntil(
    BuildContext context, {
    required BookingItem booking,
    required String locale,
  }) {
    final deadline = _modifiableDeadline(booking);
    final formatted = DateFormat.yMd(locale).add_jm().format(deadline);
    return context.l10n.modifiableUntilDateTime(formatted);
  }

  static DateTime _modifiableDeadline(BookingItem booking) {
    final raw = booking.canModifyUntilRaw;
    if (raw != null && raw.isNotEmpty) {
      try {
        return TenantTimeService.parseAsLocationTime(raw);
      } catch (_) {
        // Fallback to parsed DateTime if raw parsing fails.
      }
    }
    return booking.canModifyUntil!;
  }

  static String _localeForLocation(BuildContext context, String? country) {
    final upper = (country ?? '').toUpperCase();
    if (upper == 'IT') return 'it';

    final appLocale = Localizations.localeOf(context);
    return appLocale.languageCode == 'it' ? 'it' : 'en';
  }

  String _formatCancellationPolicy(BuildContext context, int hours) {
    final l10n = context.l10n;
    if (hours == _neverCancellationHours) {
      return l10n.summaryCancellationPolicyNever;
    }
    if (hours == 0) {
      return l10n.summaryCancellationPolicyAlways;
    }
    if (hours >= 24 && hours % 24 == 0) {
      return l10n.summaryCancellationPolicyDays(hours ~/ 24);
    }
    return l10n.summaryCancellationPolicyHours(hours);
  }

  Future<void> _handleModify(BuildContext context, WidgetRef ref) async {
    final result = await showDialog<bool>(
      context: context,
      builder: (ctx) => RescheduleBookingDialog(booking: widget.booking),
    );

    if (result == true && context.mounted) {
      await FeedbackDialog.showSuccess(
        context,
        title: context.l10n.rescheduleBookingTitle,
        message: context.l10n.bookingRescheduled,
      );
    }
  }

  Future<void> _handleCancel(BuildContext context, WidgetRef ref) async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(context.l10n.cancelBookingTitle),
        content: Text(context.l10n.cancelBookingConfirm),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(false),
            child: Text(context.l10n.actionCancel),
          ),
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(true),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: Text(context.l10n.actionCancelBooking),
          ),
        ],
      ),
    );

    if (confirm == true && context.mounted) {
      setState(() => _isCancelling = true);
      widget.onCancelLoadingChanged(true);
      final success = await ref
          .read(myBookingsProvider.notifier)
          .cancelBooking(widget.booking.locationId, widget.booking.id);
      if (mounted) {
        setState(() => _isCancelling = false);
        widget.onCancelLoadingChanged(false);
      }

      if (context.mounted) {
        if (success) {
          await FeedbackDialog.showSuccess(
            context,
            title: context.l10n.cancelBookingTitle,
            message: context.l10n.bookingCancelled,
          );
        } else {
          await FeedbackDialog.showError(
            context,
            title: context.l10n.errorTitle,
            message: context.l10n.bookingCancelFailed,
          );
        }
      }
    }
  }
}
--- FILE: lib/features/booking/presentation/screens/booking_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../auth/providers/auth_provider.dart';
import '../../../booking/providers/business_provider.dart';
import '../../../../core/network/network_providers.dart';
import '../../../../core/widgets/app_loading_screen.dart';
import '../../../../core/widgets/booking_app_bar.dart';
import '../../providers/booking_provider.dart';
import '../../providers/locations_provider.dart';
import '../widgets/booking_step_indicator.dart';
import 'confirmation_step.dart';
import 'date_time_step.dart';
import 'location_step.dart';
import 'services_step.dart';
import 'staff_step.dart';
import 'summary_step.dart';

class BookingScreen extends ConsumerStatefulWidget {
  const BookingScreen({super.key});

  @override
  ConsumerState<BookingScreen> createState() => _BookingScreenState();
}

class _BookingScreenState extends ConsumerState<BookingScreen> {
  bool _redirectingWrongBusiness = false;

  Future<void> _redirectToRegisterForBusiness({
    required int authenticatedBusinessId,
    required String? slug,
  }) async {
    if (_redirectingWrongBusiness) return;
    _redirectingWrongBusiness = true;

    await ref
        .read(authProvider.notifier)
        .logout(businessId: authenticatedBusinessId);
    if (!mounted || !context.mounted) return;
    final businessSlug = slug ?? '';
    if (businessSlug.isEmpty) return;
    context.go('/$businessSlug/register?from=booking&force=1');
  }

  @override
  Widget build(BuildContext context) {
    final businessAsync = ref.watch(currentBusinessProvider);
    final config = ref.watch(bookingConfigProvider);
    final authState = ref.watch(authProvider);
    final businessSlug = ref.watch(businessSlugProvider);
    final authenticatedBusinessIdAsync = ref.watch(authenticatedBusinessIdProvider);
    final l10n = context.l10n;

    final currentBusinessId = businessAsync.value?.id;
    final authenticatedBusinessId = authenticatedBusinessIdAsync.value;
    final isWrongBusinessAuthenticated =
        authState.isAuthenticated &&
        currentBusinessId != null &&
        authenticatedBusinessId != null &&
        currentBusinessId != authenticatedBusinessId;

    if (isWrongBusinessAuthenticated) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _redirectToRegisterForBusiness(
          authenticatedBusinessId: authenticatedBusinessId,
          slug: businessSlug,
        );
      });
      return const AppLoadingScreen();
    }

    // Se il business √® in caricamento, mostra loading identico a index.html
    // per transizione seamless
    if (businessAsync.isLoading) {
      return const AppLoadingScreen();
    }

    // Se c'√® un errore nel caricamento del business
    if (businessAsync.hasError) {
      return Scaffold(
        appBar: const BookingAppBar(showUserMenu: false),
        body: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Icon(Icons.error_outline, size: 64, color: Colors.red),
              const SizedBox(height: 16),
              Text(
                l10n.errorGeneric,
                style: Theme.of(context).textTheme.titleLarge,
              ),
              const SizedBox(height: 16),
              ElevatedButton.icon(
                onPressed: () =>
                    ref.read(currentBusinessProvider.notifier).refresh(),
                icon: const Icon(Icons.refresh),
                label: Text(l10n.actionRetry),
              ),
            ],
          ),
        ),
      );
    }

    // Se la config non √® valida (business o location mancanti)
    if (!config.isValid) {
      // Distingui tra "business non trovato" e "business non attivo"
      final isNotActive = config.businessExistsButNotActive;
      final title = isNotActive
          ? l10n.errorBusinessNotActive
          : l10n.errorBusinessNotFound;
      final subtitle = isNotActive
          ? l10n.errorBusinessNotActiveSubtitle
          : l10n.errorBusinessNotFoundSubtitle;
      final icon = isNotActive ? Icons.schedule : Icons.storefront_outlined;

      return Scaffold(
        appBar: const BookingAppBar(showUserMenu: false),
        body: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(icon, size: 64),
              const SizedBox(height: 16),
              Text(title, style: Theme.of(context).textTheme.titleLarge),
              const SizedBox(height: 8),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 32),
                child: Text(
                  subtitle,
                  textAlign: TextAlign.center,
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: Theme.of(
                      context,
                    ).colorScheme.onSurface.withAlpha((0.6 * 255).round()),
                  ),
                ),
              ),
            ],
          ),
        ),
      );
    }

    // Normal booking flow
    final bookingState = ref.watch(bookingFlowProvider);
    final hasMultipleLocations = ref.watch(hasMultipleLocationsProvider);
    final isMobile =
        _formFactorForWidth(MediaQuery.of(context).size.width) ==
        AppFormFactor.mobile;

    // Determina se mostrare il back button
    // Se c'√® una sola location e siamo su services, non mostrare back
    final showBackButton =
        bookingState.canGoBack &&
        !(bookingState.currentStep == BookingStep.services &&
            !hasMultipleLocations);

    return PopScope(
      canPop: !(isMobile && showBackButton),
      onPopInvoked: (didPop) {
        if (didPop) return;
        if (isMobile && showBackButton) {
          ref.read(bookingFlowProvider.notifier).previousStep();
        }
      },
      child: Scaffold(
        appBar: BookingAppBar(
          showBackButton: showBackButton,
          onBackPressed: () =>
              ref.read(bookingFlowProvider.notifier).previousStep(),
        ),
        body: LayoutBuilder(
          builder: (context, constraints) {
            WidgetsBinding.instance.addPostFrameCallback((_) {
              ref
                  .read(formFactorProvider.notifier)
                  .update(constraints.maxWidth);
            });
            final formFactor = _formFactorForWidth(constraints.maxWidth);
            final maxWidth = switch (formFactor) {
              AppFormFactor.desktop => 980.0,
              AppFormFactor.tablet => 760.0,
              AppFormFactor.mobile => double.infinity,
            };
            final horizontalPadding = switch (formFactor) {
              AppFormFactor.desktop => 32.0,
              AppFormFactor.tablet => 24.0,
              AppFormFactor.mobile => 0.0,
            };

            return Center(
              child: ConstrainedBox(
                constraints: BoxConstraints(maxWidth: maxWidth),
                child: Padding(
                  padding: EdgeInsets.symmetric(horizontal: horizontalPadding),
                  child: Column(
                    children: [
                      // Step indicator
                      if (bookingState.currentStep != BookingStep.confirmation)
                        BookingStepIndicator(
                          currentStep: bookingState.currentStep,
                          allowStaffSelection: config.allowStaffSelection,
                          showLocationStep: hasMultipleLocations,
                          onStepTap: (step) {
                            ref
                                .read(bookingFlowProvider.notifier)
                                .goToStep(step);
                          },
                        ),

                      // Content
                      Expanded(
                        child: AnimatedSwitcher(
                          duration: const Duration(milliseconds: 300),
                          child: _buildStepContent(bookingState.currentStep),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            );
          },
        ),
      ),
    );
  }

  AppFormFactor _formFactorForWidth(double width) {
    if (width >= 1024) return AppFormFactor.desktop;
    if (width >= 600) return AppFormFactor.tablet;
    return AppFormFactor.mobile;
  }

  Widget _buildStepContent(BookingStep step) {
    switch (step) {
      case BookingStep.location:
        return const LocationStep();
      case BookingStep.services:
        return const ServicesStep();
      case BookingStep.staff:
        return const StaffStep();
      case BookingStep.dateTime:
        return const DateTimeStep();
      case BookingStep.summary:
        return const SummaryStep();
      case BookingStep.confirmation:
        return const ConfirmationStep();
    }
  }
}
--- FILE: lib/features/booking/presentation/screens/location_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/location.dart';
import '../../../../core/widgets/centered_error_view.dart';
import '../../providers/booking_provider.dart';
import '../../providers/locations_provider.dart';

class LocationStep extends ConsumerWidget {
  const LocationStep({super.key});

  /// Aggiorna l'URL con il parametro location per persistenza
  void _updateUrlWithLocation(BuildContext context, int locationId) {
    final uri = GoRouterState.of(context).uri;
    final newUri = uri.replace(
      queryParameters: {
        ...uri.queryParameters,
        'location': locationId.toString(),
      },
    );
    // Usa replaceLocation per non aggiungere alla history del browser
    context.go(newUri.toString());
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final locationsAsync = ref.watch(locationsProvider);
    final selectedLocation = ref.watch(selectedLocationProvider);
    final isLoading = locationsAsync.isLoading;

    if (locationsAsync.hasError) {
      return CenteredErrorView(
        title: l10n.errorGeneric,
        onRetry: () => ref.read(locationsProvider.notifier).refresh(),
        retryLabel: l10n.actionRetry,
      );
    }

    return Stack(
      children: [
        Column(
          children: [
            // Header
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    l10n.locationTitle,
                    style: theme.textTheme.headlineSmall?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 4),
                  Text(
                    l10n.locationSubtitle,
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: theme.colorScheme.onSurface.withOpacity(0.7),
                    ),
                  ),
                ],
              ),
            ),

            // Lista locations
            Expanded(
              child: locationsAsync.when(
                loading: () => const SizedBox.shrink(),
                error: (e, _) => const SizedBox.shrink(),
                data: (locations) {
                  if (locations.isEmpty) {
                    return Center(
                      child: Column(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Icon(
                            Icons.location_off,
                            size: 64,
                            color: theme.colorScheme.onSurface.withOpacity(0.4),
                          ),
                          const SizedBox(height: 16),
                          Text(
                            l10n.locationEmpty,
                            style: theme.textTheme.titleMedium,
                          ),
                        ],
                      ),
                    );
                  }

                  return ListView.builder(
                    padding: const EdgeInsets.symmetric(horizontal: 16),
                    itemCount: locations.length,
                    itemBuilder: (context, index) {
                      final location = locations[index];
                      final isSelected = selectedLocation?.id == location.id;

                      return _LocationCard(
                        location: location,
                        isSelected: isSelected,
                        onTap: () {
                          ref
                              .read(selectedLocationProvider.notifier)
                              .select(location);
                          // Aggiorna URL con location selezionata per persistenza
                          _updateUrlWithLocation(context, location.id);
                        },
                      );
                    },
                  );
                },
              ),
            ),

            // Footer con bottone
            _buildFooter(context, ref, selectedLocation),
          ],
        ),
        if (isLoading)
          Positioned.fill(
            child: ColoredBox(
              color: theme.colorScheme.surface.withOpacity(0.6),
              child: const Center(child: CircularProgressIndicator()),
            ),
          ),
      ],
    );
  }

  Widget _buildFooter(
    BuildContext context,
    WidgetRef ref,
    Location? selectedLocation,
  ) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
      ),
      child: SafeArea(
        child: SizedBox(
          width: double.infinity,
          child: FilledButton(
            onPressed: selectedLocation != null
                ? () => ref.read(bookingFlowProvider.notifier).nextStep()
                : null,
            child: Text(l10n.actionNext),
          ),
        ),
      ),
    );
  }
}

class _LocationCard extends StatelessWidget {
  final Location location;
  final bool isSelected;
  final VoidCallback onTap;

  const _LocationCard({
    required this.location,
    required this.isSelected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: isSelected
            ? BorderSide(color: theme.colorScheme.primary, width: 2)
            : BorderSide.none,
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Icona location
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: isSelected
                      ? theme.colorScheme.primary.withOpacity(0.1)
                      : theme.colorScheme.surfaceContainerHighest,
                  border: Border.all(
                    color: isSelected
                        ? theme.colorScheme.primary.withOpacity(0.35)
                        : theme.dividerColor.withOpacity(0.8),
                  ),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(
                  Icons.location_on,
                  color: isSelected
                      ? theme.colorScheme.primary
                      : theme.colorScheme.onSurfaceVariant,
                ),
              ),
              const SizedBox(width: 16),

              // Info location
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            location.name,
                            style: theme.textTheme.titleMedium?.copyWith(
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ),
                        if (location.isDefault)
                          Container(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 8,
                              vertical: 2,
                            ),
                            decoration: BoxDecoration(
                              color: theme.colorScheme.primaryContainer,
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: Text(
                              'Principale',
                              style: theme.textTheme.labelSmall?.copyWith(
                                color: theme.colorScheme.onPrimaryContainer,
                              ),
                            ),
                          ),
                      ],
                    ),
                    if (location.formattedAddress.isNotEmpty) ...[
                      const SizedBox(height: 4),
                      Text(
                        location.formattedAddress,
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.7),
                        ),
                      ),
                    ],
                    if (location.phone != null &&
                        location.phone!.isNotEmpty) ...[
                      const SizedBox(height: 4),
                      Row(
                        children: [
                          Icon(
                            Icons.phone_outlined,
                            size: 14,
                            color: theme.colorScheme.onSurface.withOpacity(0.5),
                          ),
                          const SizedBox(width: 4),
                          Text(
                            location.phone!,
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: theme.colorScheme.onSurface.withOpacity(
                                0.7,
                              ),
                            ),
                          ),
                        ],
                      ),
                    ],
                  ],
                ),
              ),

              // Checkmark se selezionato
              if (isSelected)
                Icon(Icons.check_circle, color: theme.colorScheme.primary),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/date_time_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/l10n/l10n.dart';
import '../../../../core/models/time_slot.dart';
import '../../../../core/widgets/centered_error_view.dart';
import '../../providers/booking_provider.dart';
import '../../providers/locations_provider.dart';

class DateTimeStep extends ConsumerStatefulWidget {
  const DateTimeStep({super.key});

  @override
  ConsumerState<DateTimeStep> createState() => _DateTimeStepState();
}

class _DateTimeStepState extends ConsumerState<DateTimeStep> {
  bool _hasInitialized = false;
  List<int>? _lastServiceIds;
  int? _lastStaffId;
  int? _lastLocationId;

  @override
  void initState() {
    super.initState();
  }

  void _tryInitializeSelectedDate(AsyncValue<DateTime> firstDateAsync) {
    // Controlla se servizi o staff sono cambiati ‚Üí reset
    final bookingState = ref.read(bookingFlowProvider);
    final currentServiceIds = bookingState.request.services
        .map((s) => s.id)
        .toList();
    final currentStaffId = bookingState.request.singleStaffId;
    final currentLocationId = ref.read(effectiveLocationIdProvider);

    bool selectionChanged = false;
    if (_lastServiceIds != null &&
        !_listEquals(_lastServiceIds!, currentServiceIds)) {
      selectionChanged = true;
    }
    if (_lastStaffId != currentStaffId) {
      selectionChanged = true;
    }
    if (_lastLocationId != currentLocationId) {
      selectionChanged = true;
    }

    if (selectionChanged) {
      _hasInitialized = false;
      // Resetta anche la data selezionata
      Future(() {
        if (!mounted) return;
        ref.read(selectedDateProvider.notifier).state = null;
      });
    }

    _lastServiceIds = currentServiceIds;
    _lastStaffId = currentStaffId;
    _lastLocationId = currentLocationId;

    if (_hasInitialized) return;

    // Se gi√† selezionata una data e non √® cambiata la selezione, non fare nulla
    final currentDate = ref.read(selectedDateProvider);
    if (currentDate != null && !selectionChanged) {
      _hasInitialized = true;
      return;
    }

    // Se la prima data √® disponibile, impostala
    firstDateAsync.whenData((date) {
      _hasInitialized = true;
      // Usa Future per evitare di modificare lo stato durante il build
      Future(() {
        if (!mounted) return;
        // Imposta la data selezionata
        ref.read(selectedDateProvider.notifier).state = date;
        // Aggiorna il mese focalizzato se necessario
        final focusedMonth = ref.read(focusedMonthProvider);
        if (focusedMonth.year != date.year ||
            focusedMonth.month != date.month) {
          ref.read(focusedMonthProvider.notifier).state = DateTime(
            date.year,
            date.month,
            1,
          );
        }
      });
    });
  }

  bool _listEquals(List<int> a, List<int> b) {
    if (a.length != b.length) return false;
    for (var i = 0; i < a.length; i++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final selectedDate = ref.watch(selectedDateProvider);
    final slotsAsync = ref.watch(availableSlotsProvider);
    final bookingState = ref.watch(bookingFlowProvider);
    final firstDateAsync = ref.watch(firstAvailableDateProvider);
    final focusedMonth = ref.watch(focusedMonthProvider);
    final availableDatesAsync = ref.watch(availableDatesProvider);
    final availableDates = availableDatesAsync.value ?? <DateTime>{};
    final isLoading = availableDatesAsync.isLoading || slotsAsync.isLoading;

    if (availableDatesAsync.hasError || slotsAsync.hasError) {
      return CenteredErrorView(
        title: l10n.errorLoadingAvailability,
        onRetry: () {
          ref.read(availableDatesProvider.notifier).resetForNewSelection();
          ref.invalidate(availableSlotsProvider);
          ref.invalidate(firstAvailableDateProvider);
        },
        retryLabel: l10n.actionRetry,
      );
    }

    // Imposta automaticamente la prima data disponibile all'ingresso nello step
    _tryInitializeSelectedDate(firstDateAsync);

    return Stack(
      children: [
        Column(
          children: [
            // Header
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    l10n.dateTimeTitle,
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ],
              ),
            ),

            // Contenuto scrollabile
            Expanded(
              child: SingleChildScrollView(
                child: Column(
                  children: [
                    // Calendario
                    _buildCalendar(
                      context,
                      selectedDate,
                      focusedMonth,
                      availableDates,
                      isLoading: availableDatesAsync.isLoading,
                      l10n: l10n,
                    ),

                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 16),
                      child: Container(height: 2, color: theme.dividerColor),
                    ),

                    // Slot orari
                    if (!isLoading)
                      slotsAsync.when(
                        loading: () => const SizedBox.shrink(),
                        error: (e, _) => const SizedBox.shrink(),
                        data: (slots) => slots.isEmpty
                            ? Padding(
                                padding: const EdgeInsets.all(32),
                                child: Column(
                                  mainAxisSize: MainAxisSize.min,
                                  children: [
                                    Icon(
                                      Icons.event_busy,
                                      size: 48,
                                      color: theme.colorScheme.onSurface
                                          .withOpacity(0.3),
                                    ),
                                    const SizedBox(height: 16),
                                    Text(
                                      l10n.dateTimeNoSlots,
                                      textAlign: TextAlign.center,
                                      style: theme.textTheme.bodyLarge
                                          ?.copyWith(
                                            color: theme.colorScheme.onSurface
                                                .withOpacity(0.6),
                                          ),
                                    ),
                                    const SizedBox(height: 36),
                                    _buildGoToAvailableDateButton(
                                      context,
                                      ref,
                                      selectedDate,
                                      availableDates,
                                      focusedMonth,
                                      l10n,
                                      theme,
                                    ),
                                  ],
                                ),
                              )
                            : _buildTimeSlots(context, ref, slots),
                      ),
                  ],
                ),
              ),
            ),

            // Footer
            _buildFooter(context, ref, bookingState),
          ],
        ),
        if (isLoading)
          Positioned.fill(
            child: ColoredBox(
              color: theme.colorScheme.surface,
              child: const Center(child: CircularProgressIndicator()),
            ),
          ),
      ],
    );
  }

  /// Costruisce il pulsante per andare alla prima o prossima data disponibile
  Widget _buildGoToAvailableDateButton(
    BuildContext context,
    WidgetRef ref,
    DateTime? selectedDate,
    Set<DateTime> availableDates,
    DateTime focusedMonth,
    L10n l10n,
    ThemeData theme,
  ) {
    if (selectedDate == null || availableDates.isEmpty) {
      return const SizedBox.shrink();
    }

    // Ordina le date disponibili
    final sortedDates = availableDates.toList()..sort((a, b) => a.compareTo(b));

    // Trova la prima data disponibile in assoluto
    final firstAvailable = sortedDates.first;

    // Verifica se siamo gi√† su una data disponibile
    final isOnAvailableDate = sortedDates.any(
      (d) =>
          d.year == selectedDate.year &&
          d.month == selectedDate.month &&
          d.day == selectedDate.day,
    );

    if (isOnAvailableDate) {
      return const SizedBox.shrink();
    }

    // Helper per creare un pulsante
    Widget buildButton(DateTime date, String text, IconData icon) {
      return TextButton.icon(
        onPressed: () {
          if (focusedMonth.year != date.year ||
              focusedMonth.month != date.month) {
            ref.read(focusedMonthProvider.notifier).state = DateTime(
              date.year,
              date.month,
              1,
            );
          }
          ref.read(selectedDateProvider.notifier).state = date;
        },
        icon: Icon(icon, size: 18, color: theme.colorScheme.primary),
        label: Text(
          text,
          style: theme.textTheme.bodyMedium?.copyWith(
            color: theme.colorScheme.primary,
            fontWeight: FontWeight.w500,
          ),
        ),
        style: TextButton.styleFrom(
          padding: EdgeInsets.zero,
          minimumSize: Size.zero,
          tapTargetSize: MaterialTapTargetSize.shrinkWrap,
        ),
      );
    }

    if (selectedDate.isBefore(firstAvailable)) {
      // Caso 1: Data selezionata √® prima della prima disponibile
      return buildButton(
        firstAvailable,
        l10n.dateTimeGoToFirst,
        Icons.fast_forward,
      );
    } else {
      // Caso 2: Data selezionata √® dopo la prima disponibile
      // Mostra "Vai alla prima" + eventualmente "Vai alla prossima"
      final buttons = <Widget>[
        buildButton(firstAvailable, l10n.dateTimeGoToFirst, Icons.fast_rewind),
      ];

      // Cerca la prossima data disponibile
      final nextAvailable = sortedDates
          .where((d) => d.isAfter(selectedDate))
          .toList();
      if (nextAvailable.isNotEmpty) {
        buttons.add(const SizedBox(height: 32));
        buttons.add(
          buildButton(
            nextAvailable.first,
            l10n.dateTimeGoToNext,
            Icons.fast_forward,
          ),
        );
      }

      return Column(mainAxisSize: MainAxisSize.min, children: buttons);
    }
  }

  Widget _buildCalendar(
    BuildContext context,
    DateTime? selectedDate,
    DateTime focusedMonth,
    Set<DateTime> availableDates, {
    required bool isLoading,
    required L10n l10n,
  }) {
    final today = ref.watch(locationTodayProvider);

    // Usa maxBookingAdvanceDays dalla location
    final daysToShow = ref.watch(maxBookingAdvanceDaysProvider);
    final days = List.generate(daysToShow, (i) => today.add(Duration(days: i)));

    // Calcola il numero della settimana per ogni giorno (per alternare sfondo)
    int getWeekNumber(DateTime date) {
      // Settimana ISO: Luned√¨ √® il primo giorno
      final firstDayOfYear = DateTime(date.year, 1, 1);
      final dayOfYear = date.difference(firstDayOfYear).inDays;
      return ((dayOfYear + firstDayOfYear.weekday - 1) / 7).floor();
    }

    // Abbreviazione giorno della settimana
    String getWeekdayAbbr(DateTime date) {
      const weekdays = ['L', 'M', 'M', 'G', 'V', 'S', 'D'];
      return weekdays[date.weekday - 1];
    }

    // Trova indice del giorno selezionato per lo scroll iniziale
    int initialScrollIndex = 0;
    if (selectedDate != null) {
      final idx = days.indexWhere(
        (d) =>
            d.year == selectedDate.year &&
            d.month == selectedDate.month &&
            d.day == selectedDate.day,
      );
      if (idx >= 0) initialScrollIndex = idx;
    }

    return Container(
      padding: const EdgeInsets.symmetric(vertical: 8),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Lista orizzontale scrollabile
          SizedBox(
            height: 90,
            child: _HorizontalDateList(
              days: days,
              selectedDate: selectedDate,
              availableDates: availableDates,
              initialScrollIndex: initialScrollIndex,
              getWeekNumber: getWeekNumber,
              getWeekdayAbbr: getWeekdayAbbr,
              today: today,
              loadedDays: ref.watch(availableDatesProvider.notifier).loadedDays,
              onLoadMore: (dayIndex) {
                ref
                    .read(availableDatesProvider.notifier)
                    .loadUntilDay(dayIndex);
              },
              onDateSelected: (date) {
                ref.read(selectedDateProvider.notifier).state = date;
                // Aggiorna anche il mese focalizzato se cambia
                final currentFocused = ref.read(focusedMonthProvider);
                if (currentFocused.year != date.year ||
                    currentFocused.month != date.month) {
                  ref.read(focusedMonthProvider.notifier).state = DateTime(
                    date.year,
                    date.month,
                    1,
                  );
                }
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildTimeSlots(
    BuildContext context,
    WidgetRef ref,
    List<TimeSlot> slots,
  ) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final bookingState = ref.watch(bookingFlowProvider);
    final selectedSlot = bookingState.request.selectedSlot;
    final selectedDate = ref.watch(selectedDateProvider);

    // Raggruppa per fascia oraria
    final morningSlots = slots.where((s) => s.startTime.hour < 12).toList();
    final afternoonSlots = slots
        .where((s) => s.startTime.hour >= 12 && s.startTime.hour < 18)
        .toList();
    final eveningSlots = slots.where((s) => s.startTime.hour >= 18).toList();

    // Formatta la data in formato esteso localizzato
    String formattedDate = '';
    if (selectedDate != null) {
      final locale = Localizations.localeOf(context).toString();
      final now = ref.watch(locationNowProvider);
      // Se l'anno √® diverso dall'attuale, mostralo
      if (selectedDate.year != now.year) {
        formattedDate = DateFormat(
          'EEEE d MMMM yyyy',
          locale,
        ).format(selectedDate);
      } else {
        formattedDate = DateFormat('EEEE d MMMM', locale).format(selectedDate);
      }
      // Capitalizza la prima lettera
      formattedDate =
          formattedDate[0].toUpperCase() + formattedDate.substring(1);
    }

    return Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Data selezionata in formato esteso
          if (formattedDate.isNotEmpty) ...[
            Text(
              formattedDate,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
                color: theme.colorScheme.primary,
              ),
            ),
            const SizedBox(height: 16),
          ],
          if (morningSlots.isNotEmpty) ...[
            Text(l10n.dateTimeMorning, style: theme.textTheme.titleSmall),
            const SizedBox(height: 8),
            _buildSlotGrid(context, ref, morningSlots, selectedSlot),
            const SizedBox(height: 16),
          ],
          if (afternoonSlots.isNotEmpty) ...[
            Text(l10n.dateTimeAfternoon, style: theme.textTheme.titleSmall),
            const SizedBox(height: 8),
            _buildSlotGrid(context, ref, afternoonSlots, selectedSlot),
            const SizedBox(height: 16),
          ],
          if (eveningSlots.isNotEmpty) ...[
            Text(l10n.dateTimeEvening, style: theme.textTheme.titleSmall),
            const SizedBox(height: 8),
            _buildSlotGrid(context, ref, eveningSlots, selectedSlot),
          ],
        ],
      ),
    );
  }

  Widget _buildSlotGrid(
    BuildContext context,
    WidgetRef ref,
    List<TimeSlot> slots,
    TimeSlot? selectedSlot,
  ) {
    final theme = Theme.of(context);

    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: slots.map((slot) {
        final isSelected = selectedSlot?.startTime == slot.startTime;
        return GestureDetector(
          onTap: () {
            ref.read(bookingFlowProvider.notifier).selectTimeSlot(slot);
          },
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
            decoration: BoxDecoration(
              color: isSelected
                  ? theme.colorScheme.primary
                  : Colors.transparent,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(
                color: isSelected
                    ? theme.colorScheme.primary
                    : theme.dividerColor,
              ),
            ),
            child: Text(
              slot.formattedTime,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: isSelected ? Colors.white : theme.colorScheme.onSurface,
                fontWeight: isSelected ? FontWeight.bold : null,
              ),
            ),
          ),
        );
      }).toList(),
    );
  }

  Widget _buildFooter(
    BuildContext context,
    WidgetRef ref,
    BookingFlowState state,
  ) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, -5),
          ),
        ],
      ),
      child: SafeArea(
        child: ElevatedButton(
          onPressed: state.canGoNext
              ? () => ref.read(bookingFlowProvider.notifier).nextStep()
              : null,
          child: Text(l10n.actionNext),
        ),
      ),
    );
  }
}

/// Widget per la lista orizzontale scrollabile dei giorni
class _HorizontalDateList extends StatefulWidget {
  const _HorizontalDateList({
    required this.days,
    required this.selectedDate,
    required this.availableDates,
    required this.initialScrollIndex,
    required this.getWeekNumber,
    required this.getWeekdayAbbr,
    required this.today,
    required this.onDateSelected,
    required this.onLoadMore,
    required this.loadedDays,
  });

  final List<DateTime> days;
  final DateTime? selectedDate;
  final Set<DateTime> availableDates;
  final int initialScrollIndex;
  final int Function(DateTime) getWeekNumber;
  final String Function(DateTime) getWeekdayAbbr;
  final DateTime today;
  final void Function(DateTime) onDateSelected;
  final void Function(int dayIndex) onLoadMore;
  final int loadedDays;

  @override
  State<_HorizontalDateList> createState() => _HorizontalDateListState();
}

class _HorizontalDateListState extends State<_HorizontalDateList> {
  late ScrollController _scrollController;
  static const double _itemWidth = 56.0;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController(
      initialScrollOffset: widget.initialScrollIndex * _itemWidth,
    );
    _scrollController.addListener(_onScroll);
  }

  void _onScroll() {
    _maybeLoadMore();
  }

  void _maybeLoadMore() {
    // Carica pi√π date quando si avvicina alla fine dei giorni caricati
    final currentDay = (_scrollController.offset / _itemWidth).floor();
    // Triggerare caricamento quando siamo a 5 giorni dalla fine dei giorni caricati
    if (currentDay >= widget.loadedDays - 5) {
      widget.onLoadMore(currentDay);
    }
  }

  @override
  void didUpdateWidget(_HorizontalDateList oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Se cambia la data selezionata, scrolla per renderla visibile
    if (widget.selectedDate != oldWidget.selectedDate &&
        widget.selectedDate != null) {
      final idx = widget.days.indexWhere(
        (d) =>
            d.year == widget.selectedDate!.year &&
            d.month == widget.selectedDate!.month &&
            d.day == widget.selectedDate!.day,
      );
      if (idx >= 0) {
        final screenWidth = MediaQuery.of(context).size.width;
        final targetOffset =
            (idx * _itemWidth) - (screenWidth / 2) + (_itemWidth / 2);
        _scrollController.animateTo(
          targetOffset.clamp(0.0, _scrollController.position.maxScrollExtent),
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeInOut,
        );
      }
    }
    if (widget.loadedDays != oldWidget.loadedDays) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (!mounted) return;
        _maybeLoadMore();
      });
    }
  }

  @override
  void dispose() {
    _scrollController.removeListener(_onScroll);
    _scrollController.dispose();
    super.dispose();
  }

  bool _containsDate(Set<DateTime> dates, DateTime date) {
    return dates.any(
      (d) => d.year == date.year && d.month == date.month && d.day == date.day,
    );
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return ListView.builder(
      controller: _scrollController,
      scrollDirection: Axis.horizontal,
      padding: const EdgeInsets.symmetric(horizontal: 12),
      itemCount: widget.days.length,
      itemBuilder: (context, index) {
        final date = widget.days[index];
        final isToday =
            date.year == widget.today.year &&
            date.month == widget.today.month &&
            date.day == widget.today.day;
        final isAvailable = _containsDate(widget.availableDates, date);
        final isSelected =
            widget.selectedDate != null &&
            date.year == widget.selectedDate!.year &&
            date.month == widget.selectedDate!.month &&
            date.day == widget.selectedDate!.day;
        final weekNumber = widget.getWeekNumber(date);
        final isOddWeek = weekNumber % 2 == 1;

        // Colore sfondo alternato per settimane
        final weekBgColor = isOddWeek
            ? theme.colorScheme.surfaceContainerHighest.withOpacity(0.5)
            : Colors.transparent;

        // Verifica se questa data √® gi√† stata caricata
        final isLoaded = index < widget.loadedDays;

        return GestureDetector(
          // Selezionabile se gi√† caricata (anche se non disponibile)
          onTap: isLoaded ? () => widget.onDateSelected(date) : null,
          child: Container(
            width: _itemWidth,
            margin: const EdgeInsets.symmetric(horizontal: 2),
            decoration: BoxDecoration(
              color: weekBgColor,
              borderRadius: BorderRadius.circular(8),
            ),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                // Giorno della settimana
                Text(
                  widget.getWeekdayAbbr(date),
                  style: theme.textTheme.labelSmall?.copyWith(
                    color: isAvailable
                        ? theme.colorScheme.onSurface.withOpacity(0.6)
                        : theme.colorScheme.onSurface.withOpacity(0.3),
                    fontWeight: FontWeight.w500,
                  ),
                ),
                const SizedBox(height: 4),
                // Pallino con numero giorno
                Container(
                  width: 40,
                  height: 40,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    color: isSelected ? theme.colorScheme.primary : null,
                    border: isToday && !isSelected
                        ? Border.all(
                            color: theme.colorScheme.primary,
                            width: 1.5,
                          )
                        : null,
                  ),
                  child: Center(
                    child: Text(
                      '${date.day}',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: isSelected
                            ? theme.colorScheme.onPrimary
                            : isAvailable
                            ? theme.colorScheme.onSurface
                            : theme.colorScheme.onSurface.withOpacity(0.3),
                        fontWeight: isToday || isSelected
                            ? FontWeight.bold
                            : FontWeight.w500,
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 6),
                // Pallino indicatore disponibilit√† o loading
                if (index >= widget.loadedDays)
                  // Ancora in caricamento per questa data
                  SizedBox(
                    width: 6,
                    height: 6,
                    child: CircularProgressIndicator(
                      strokeWidth: 1.5,
                      color: theme.colorScheme.outline.withOpacity(0.5),
                    ),
                  )
                else if (isAvailable)
                  Container(
                    width: 6,
                    height: 6,
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      color: isOddWeek
                          ? theme.colorScheme.primary
                          : theme.colorScheme.tertiary,
                    ),
                  )
                else
                  const SizedBox(height: 6),
                // Indicatore mese quando cambia
                if (date.day == 1 || index == 0)
                  Text(
                    DateFormat('MMM', 'it').format(date).toUpperCase(),
                    style: theme.textTheme.labelSmall?.copyWith(
                      color: theme.colorScheme.primary,
                      fontWeight: FontWeight.bold,
                      fontSize: 9,
                    ),
                  )
                else
                  const SizedBox(height: 11),
              ],
            ),
          ),
        );
      },
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/confirmation_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../app/providers/route_slug_provider.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../providers/booking_provider.dart';
import '../../providers/locations_provider.dart';

class ConfirmationStep extends ConsumerWidget {
  const ConfirmationStep({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final bookingState = ref.watch(bookingFlowProvider);

    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Spacer(),

            // Icona successo
            Container(
              width: 100,
              height: 100,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                color: Colors.green.withOpacity(0.1),
              ),
              child: const Icon(
                Icons.check_circle,
                size: 64,
                color: Colors.green,
              ),
            ),
            const SizedBox(height: 32),

            // Titolo
            Text(
              l10n.confirmationTitle,
              style: theme.textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.bold,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),

            // Sottotitolo
            Text(
              l10n.confirmationSubtitle,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 24),

            // Codice prenotazione
            if (bookingState.confirmedBookingId != null)
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 24,
                  vertical: 16,
                ),
                decoration: BoxDecoration(
                  color: theme.colorScheme.primary.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  l10n.confirmationBookingId(bookingState.confirmedBookingId!),
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: theme.colorScheme.primary,
                  ),
                ),
              ),

            const Spacer(),

            // Bottoni azioni
            ElevatedButton(
              onPressed: () {
                final slug = ref.read(routeSlugProvider);
                final locationId = ref.read(effectiveLocationProvider)?.id;
                ref.read(bookingFlowProvider.notifier).reset();
                if (locationId != null) {
                  context.go('/$slug/booking?location=$locationId');
                } else {
                  context.go('/$slug/booking');
                }
              },
              child: Text(l10n.confirmationNewBooking),
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/dialogs/booking_history_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '/app/providers/form_factor_provider.dart';
import '/core/l10n/l10_extension.dart';
import '/core/network/network_providers.dart';
import '/core/widgets/app_bottom_sheet.dart';

/// Mostra il dialog/bottom sheet con lo storico di una prenotazione (customer)
Future<void> showBookingHistoryDialog(
  BuildContext context,
  WidgetRef ref, {
  required int bookingId,
}) async {
  final formFactor = ref.read(formFactorProvider);

  final content = _BookingHistoryContent(bookingId: bookingId);

  if (formFactor == AppFormFactor.desktop) {
    await showDialog(
      context: context,
      builder: (_) => Dialog(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 500, maxHeight: 600),
          child: content,
        ),
      ),
    );
  } else {
    await AppBottomSheet.show(
      context: context,
      useRootNavigator: true,
      builder: (_) => content,
      heightFactor: 0.7,
    );
  }
}

class _BookingHistoryContent extends ConsumerStatefulWidget {
  const _BookingHistoryContent({required this.bookingId});

  final int bookingId;

  @override
  ConsumerState<_BookingHistoryContent> createState() =>
      _BookingHistoryContentState();
}

class _BookingHistoryContentState
    extends ConsumerState<_BookingHistoryContent> {
  List<dynamic>? _events;
  bool _isLoading = true;
  String? _error;
  bool _isAuthError = false;

  @override
  void initState() {
    super.initState();
    _loadHistory();
  }

  Future<void> _loadHistory() async {
    try {
      final apiClient = ref.read(apiClientProvider);
      final events = await apiClient.getCustomerBookingHistory(
        widget.bookingId,
      );

      if (mounted) {
        final rawEvents = List<Map<String, dynamic>>.from(events);
        final filteredEvents = rawEvents
            .where((event) => !_isRedundantCancellationUpdate(event))
            .toList();
        setState(() {
          _events = filteredEvents;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (mounted) {
        // Controlla se √® un errore di autenticazione
        final isAuth =
            e.toString().contains('401') ||
            e.toString().contains('Unauthorized') ||
            e.toString().contains('token');
        setState(() {
          _error = e.toString();
          _isAuthError = isAuth;
          _isLoading = false;
        });
      }
    }
  }

  bool _isRedundantCancellationUpdate(Map<String, dynamic> event) {
    final eventType = event['event_type'] as String? ?? '';
    if (eventType != 'booking_updated') {
      return false;
    }

    final payload = event['payload'] as Map<String, dynamic>? ?? {};
    final changedFields =
        (payload['changed_fields'] as List<dynamic>?)?.cast<String>() ?? const [];
    if (changedFields.length != 1 || changedFields.first != 'status') {
      return false;
    }

    final after = payload['after'] as Map<String, dynamic>? ?? {};
    final status = (after['status'] as String?)?.trim().toLowerCase();
    return status == 'cancelled';
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              const Icon(Icons.history),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  l10n.bookingHistoryTitle,
                  style: theme.textTheme.titleLarge,
                ),
              ),
              IconButton(
                icon: const Icon(Icons.close),
                onPressed: () => Navigator.of(context).pop(),
              ),
            ],
          ),
        ),
        const Divider(height: 1),

        // Content
        Flexible(child: _buildContent(l10n, theme)),
      ],
    );
  }

  Widget _buildContent(dynamic l10n, ThemeData theme) {
    if (_isLoading) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const CircularProgressIndicator(),
              const SizedBox(height: 16),
              Text(l10n.bookingHistoryLoading),
            ],
          ),
        ),
      );
    }

    if (_error != null) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(
                _isAuthError ? Icons.lock_outline : Icons.error_outline,
                size: 48,
                color: theme.colorScheme.error,
              ),
              const SizedBox(height: 16),
              Text(
                _isAuthError ? l10n.sessionExpired : l10n.bookingHistoryError,
                style: TextStyle(color: theme.colorScheme.error),
              ),
              if (_isAuthError) ...[
                const SizedBox(height: 16),
                FilledButton(
                  onPressed: () => Navigator.of(context).pop(),
                  child: Text(l10n.actionClose),
                ),
              ],
            ],
          ),
        ),
      );
    }

    if (_events == null || _events!.isEmpty) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.inbox_outlined, size: 48, color: theme.hintColor),
              const SizedBox(height: 16),
              Text(
                l10n.bookingHistoryEmpty,
                style: TextStyle(color: theme.hintColor),
              ),
            ],
          ),
        ),
      );
    }

    return ListView.separated(
      padding: const EdgeInsets.symmetric(vertical: 8),
      itemCount: _events!.length,
      separatorBuilder: (_, __) => const Divider(height: 1, indent: 56),
      itemBuilder: (context, index) {
        final event = _events![index] as Map<String, dynamic>;
        return _EventTile(event: event);
      },
    );
  }
}

class _EventTile extends StatelessWidget {
  const _EventTile({required this.event});

  final Map<String, dynamic> event;

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final locale = Localizations.localeOf(context).toString();

    final eventType = event['event_type'] as String? ?? 'unknown';
    final actorType = event['actor_type'] as String? ?? 'system';
    final actorName = event['actor_name'] as String?;
    final createdAt = event['created_at'] as String?;
    final payload = event['payload'] as Map<String, dynamic>? ?? {};

    final (icon, color, title) = _getEventDisplay(eventType, payload, l10n);
    final actorLabel = actorName ?? _getActorLabel(actorType, l10n);

    // Format date with locale-adaptive format
    String formattedDate = '';
    if (createdAt != null) {
      try {
        final date = DateTime.parse(createdAt);
        final dateStr = DateFormat.yMMMd(locale).format(date);
        final timeStr = DateFormat.Hm(locale).format(date);
        formattedDate = '$dateStr, $timeStr';
      } catch (_) {
        formattedDate = createdAt;
      }
    }

    // Build user-friendly description based on event type and payload
    final description = _buildDescription(eventType, payload, locale);
    final isNotificationSent = eventType == 'booking_notification_sent';
    final recipientEmail =
        (payload['recipient_email'] as String?)?.trim() ?? '';

    return ListTile(
      leading: CircleAvatar(
        backgroundColor: color.withOpacity(0.15),
        child: Icon(icon, color: color, size: 20),
      ),
      title: Text(title),
      subtitle: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (description != null)
            Padding(
              padding: const EdgeInsets.only(bottom: 4),
              child: Text(description, style: theme.textTheme.bodySmall),
            ),
          if (isNotificationSent && recipientEmail.isNotEmpty)
            Padding(
              padding: const EdgeInsets.only(bottom: 2),
              child: Text(
                l10n.bookingHistoryNotificationRecipient(recipientEmail),
                style: theme.textTheme.bodySmall,
              ),
            ),
          Text(
            isNotificationSent
                ? l10n.bookingHistoryNotificationSentAt(formattedDate)
                : '$formattedDate ‚Ä¢ $actorLabel',
            style: theme.textTheme.bodySmall?.copyWith(color: theme.hintColor),
          ),
        ],
      ),
      isThreeLine:
          description != null || (isNotificationSent && recipientEmail.isNotEmpty),
    );
  }

  String? _buildDescription(
    String eventType,
    Map<String, dynamic> payload,
    String locale,
  ) {
    switch (eventType) {
      case 'appointment_updated':
        return _describeAppointmentUpdate(payload, locale);
      case 'booking_created':
        return _describeBookingCreated(payload, locale);
      case 'booking_cancelled':
        return _describeBookingCancelled(payload, locale);
      case 'booking_item_added':
        return _describeItemAdded(payload);
      case 'booking_item_deleted':
        return _describeItemDeleted(payload);
      case 'booking_updated':
        return _describeBookingUpdate(payload);
      case 'booking_notification_sent':
        return null;
      default:
        return null;
    }
  }

  String? _describeAppointmentUpdate(
    Map<String, dynamic> payload,
    String locale,
  ) {
    final before = payload['before'] as Map<String, dynamic>? ?? {};
    final after = payload['after'] as Map<String, dynamic>? ?? {};
    final changedFields =
        (payload['changed_fields'] as List<dynamic>?)?.cast<String>() ?? [];

    if (changedFields.isEmpty) return null;

    final descriptions = <String>[];

    // Check for time/duration changes
    final beforeStart = _parseTime(before['start_time']);
    final beforeEnd = _parseTime(before['end_time']);
    final afterStart = _parseTime(after['start_time']);
    final afterEnd = _parseTime(after['end_time']);

    if (beforeStart != null &&
        beforeEnd != null &&
        afterStart != null &&
        afterEnd != null) {
      final beforeDuration = beforeEnd.difference(beforeStart).inMinutes;
      final afterDuration = afterEnd.difference(afterStart).inMinutes;

      final startChanged = changedFields.contains('start_time');
      final endChanged = changedFields.contains('end_time');

      if (startChanged && endChanged) {
        // Both changed - check if it's a move or resize
        if (beforeDuration == afterDuration) {
          // Same duration = moved
          descriptions.add(
            'Orario spostato da ${_formatTime(beforeStart, locale)} a ${_formatTime(afterStart, locale)}',
          );
        } else {
          // Different duration = resized and possibly moved
          if (beforeStart != afterStart) {
            descriptions.add(
              'Orario spostato da ${_formatTime(beforeStart, locale)} a ${_formatTime(afterStart, locale)}',
            );
          }
          descriptions.add(
            'Durata modificata da ${_formatDuration(beforeDuration)} a ${_formatDuration(afterDuration)}, termina alle ${_formatTime(afterEnd, locale)}',
          );
        }
      } else if (endChanged && !startChanged) {
        // Only end changed = resize
        descriptions.add(
          'Durata modificata da ${_formatDuration(beforeDuration)} a ${_formatDuration(afterDuration)}, termina alle ${_formatTime(afterEnd, locale)}',
        );
      } else if (startChanged && !endChanged) {
        // Only start changed (rare)
        descriptions.add(
          'Orario inizio modificato da ${_formatTime(beforeStart, locale)} a ${_formatTime(afterStart, locale)}',
        );
      }
    }

    // Check for staff change
    if (changedFields.contains('staff_id')) {
      final beforeStaff = before['staff_id'];
      final afterStaff = after['staff_id'];
      if (beforeStaff != afterStaff) {
        final beforeStaffName = before['staff_name'] as String?;
        final afterStaffName = after['staff_name'] as String?;
        if (beforeStaffName != null && afterStaffName != null) {
          descriptions.add(
            'Operatore cambiato da $beforeStaffName a $afterStaffName',
          );
        } else {
          descriptions.add('Operatore cambiato');
        }
      }
    }

    // Check for price change
    if (changedFields.contains('price')) {
      final beforePrice = (before['price'] as num?)?.toDouble();
      final afterPrice = (after['price'] as num?)?.toDouble();
      if (beforePrice != null && afterPrice != null) {
        descriptions.add(
          'Prezzo modificato da ‚Ç¨${beforePrice.toStringAsFixed(2)} a ‚Ç¨${afterPrice.toStringAsFixed(2)}',
        );
      }
    }

    return descriptions.isNotEmpty ? descriptions.join('\n') : null;
  }

  String? _describeBookingCreated(Map<String, dynamic> payload, String locale) {
    final items = payload['items'] as List<dynamic>?;
    final totalPrice = (payload['total_price'] as num?)?.toDouble();
    final firstStartTime = payload['first_start_time'] as String?;

    final parts = <String>[];

    // Data e ora
    if (firstStartTime != null) {
      try {
        final dateTime = DateTime.parse(firstStartTime);
        final dateStr = DateFormat.yMMMd(locale).format(dateTime);
        final timeStr = DateFormat.Hm(locale).format(dateTime);
        parts.add('$dateStr alle $timeStr');
      } catch (_) {}
    }

    // Staff (dal primo item)
    if (items != null && items.isNotEmpty) {
      final firstItem = items[0] as Map<String, dynamic>?;
      final staffName = firstItem?['staff_name'] as String?;
      if (staffName != null && staffName.isNotEmpty) {
        parts.add('con $staffName');
      }
    }

    // Servizi e prezzo
    if (items != null && items.isNotEmpty) {
      parts.add(
        '${items.length} ${items.length == 1 ? 'servizio' : 'servizi'}',
      );
    }

    if (totalPrice != null && totalPrice > 0) {
      parts.add('‚Ç¨${totalPrice.toStringAsFixed(2)}');
    }

    return parts.isNotEmpty ? parts.join(' ‚Ä¢ ') : null;
  }

  String? _describeBookingCancelled(
    Map<String, dynamic> payload,
    String locale,
  ) {
    final items = payload['items'] as List<dynamic>?;
    if (items != null && items.isNotEmpty) {
      return '${items.length} ${items.length == 1 ? 'appuntamento cancellato' : 'appuntamenti cancellati'}';
    }
    return null;
  }

  String? _describeItemAdded(Map<String, dynamic> payload) {
    // Il nome servizio pu√≤ essere in item_data.service_name_snapshot o direttamente in payload
    final itemData = payload['item_data'] as Map<String, dynamic>? ?? {};
    final serviceName =
        itemData['service_name_snapshot'] as String? ??
        payload['service_name'] as String?;
    final price =
        (itemData['price'] as num?)?.toDouble() ??
        (payload['price'] as num?)?.toDouble();

    if (serviceName != null && serviceName.isNotEmpty) {
      if (price != null && price > 0) {
        return 'Aggiunto: $serviceName ‚Ä¢ ‚Ç¨${price.toStringAsFixed(2)}';
      }
      return 'Aggiunto: $serviceName';
    }
    return null;
  }

  String? _describeItemDeleted(Map<String, dynamic> payload) {
    // Il nome servizio pu√≤ essere in deleted_item o direttamente in payload
    final deletedItem = payload['deleted_item'] as Map<String, dynamic>? ?? {};
    final serviceName =
        deletedItem['service_name_snapshot'] as String? ??
        deletedItem['service_name'] as String? ??
        payload['service_name'] as String?;

    if (serviceName != null && serviceName.isNotEmpty) {
      return 'Rimosso: $serviceName';
    }
    return null;
  }

  String? _describeBookingUpdate(Map<String, dynamic> payload) {
    final changedFields =
        (payload['changed_fields'] as List<dynamic>?)?.cast<String>() ?? [];
    final before = payload['before'] as Map<String, dynamic>? ?? {};
    final after = payload['after'] as Map<String, dynamic>? ?? {};

    final descriptions = <String>[];

    if (changedFields.contains('client_id') ||
        changedFields.contains('customer_name')) {
      final beforeName = before['customer_name'] as String?;
      final afterName = after['customer_name'] as String?;
      if (beforeName != null && afterName != null && beforeName != afterName) {
        descriptions.add('Cliente cambiato da "$beforeName" a "$afterName"');
      } else if (afterName != null) {
        descriptions.add('Cliente assegnato: $afterName');
      }
    }

    if (changedFields.contains('notes')) {
      descriptions.add('Note modificate');
    }

    if (changedFields.contains('status')) {
      final afterStatus = after['status'] as String?;
      if (afterStatus != null) {
        descriptions.add('Stato: $afterStatus');
      }
    }

    return descriptions.isNotEmpty ? descriptions.join('\n') : null;
  }

  DateTime? _parseTime(dynamic value) {
    if (value == null) return null;
    if (value is String) {
      try {
        return DateTime.parse(value);
      } catch (_) {
        return null;
      }
    }
    return null;
  }

  String _formatTime(DateTime time, String locale) {
    return DateFormat.Hm(locale).format(time);
  }

  String _formatDuration(int minutes) {
    if (minutes < 60) {
      return '$minutes min';
    }
    final hours = minutes ~/ 60;
    final mins = minutes % 60;
    if (mins == 0) {
      return '${hours}h';
    }
    return '${hours}h ${mins}min';
  }

  (IconData, Color, String) _getEventDisplay(
    String eventType,
    Map<String, dynamic> payload,
    dynamic l10n,
  ) {
    switch (eventType) {
      case 'booking_created':
        return (
          Icons.add_circle_outline,
          Colors.green,
          l10n.bookingHistoryEventCreated,
        );
      case 'booking_updated':
        return (
          Icons.edit_outlined,
          Colors.blue,
          l10n.bookingHistoryEventUpdated,
        );
      case 'booking_cancelled':
        return (
          Icons.cancel_outlined,
          Colors.red,
          l10n.bookingHistoryEventCancelled,
        );
      case 'booking_notification_sent':
        final channel = ((payload['channel'] as String?) ?? '').trim();
        return (
          Icons.mail_outline,
          Colors.lightBlue,
          l10n.bookingHistoryEventNotificationSentTitle(
            _notificationChannelLabel(channel, l10n),
          ),
        );
      case 'booking_item_added':
        return (
          Icons.add_box_outlined,
          Colors.teal,
          l10n.bookingHistoryEventItemAdded,
        );
      case 'booking_item_deleted':
        return (
          Icons.indeterminate_check_box_outlined,
          Colors.orange,
          l10n.bookingHistoryEventItemDeleted,
        );
      case 'appointment_updated':
        // Genera titolo dinamico in base ai campi modificati
        final title = _getAppointmentUpdateTitle(payload, l10n);
        return (Icons.update, Colors.purple, title);
      case 'booking_replaced':
      case 'booking_created_by_replace':
        return (
          Icons.swap_horiz,
          Colors.indigo,
          l10n.bookingHistoryEventReplaced,
        );
      default:
        return (Icons.info_outline, Colors.grey, eventType);
    }
  }

  String _notificationChannelLabel(String channel, dynamic l10n) {
    switch (channel) {
      case 'booking_confirmed':
        return l10n.bookingHistoryNotificationChannelConfirmed;
      case 'booking_reminder':
        return l10n.bookingHistoryNotificationChannelReminder;
      case 'booking_cancelled':
        return l10n.bookingHistoryNotificationChannelCancelled;
      case 'booking_rescheduled':
        return l10n.bookingHistoryNotificationChannelRescheduled;
      default:
        return channel;
    }
  }

  /// Genera un titolo specifico per appointment_updated in base ai campi modificati
  String _getAppointmentUpdateTitle(
    Map<String, dynamic> payload,
    dynamic l10n,
  ) {
    final changedFields =
        (payload['changed_fields'] as List<dynamic>?)?.cast<String>() ?? [];

    if (changedFields.isEmpty) {
      return l10n.bookingHistoryEventAppointmentUpdated;
    }

    // Se cambiano pi√π di un tipo di campo, usa titolo generico
    final hasTimeChange =
        changedFields.contains('start_time') ||
        changedFields.contains('end_time');
    final hasStaffChange = changedFields.contains('staff_id');
    final hasPriceChange = changedFields.contains('price');

    final changeCount = [
      hasTimeChange,
      hasStaffChange,
      hasPriceChange,
    ].where((b) => b).length;

    if (changeCount > 1) {
      // Modifiche multiple, usa titolo generico
      return l10n.bookingHistoryEventUpdated;
    }

    // Singola modifica, usa titolo specifico
    if (hasStaffChange) {
      return l10n.bookingHistoryEventStaffChanged;
    }
    if (hasPriceChange) {
      return l10n.bookingHistoryEventPriceChanged;
    }
    if (hasTimeChange) {
      // Determina se √® cambio orario o solo durata
      final before = payload['before'] as Map<String, dynamic>? ?? {};
      final after = payload['after'] as Map<String, dynamic>? ?? {};
      final beforeStart = _parseTime(before['start_time']);
      final afterStart = _parseTime(after['start_time']);

      if (beforeStart != null &&
          afterStart != null &&
          beforeStart != afterStart) {
        return l10n.bookingHistoryEventTimeChanged;
      }
      // Solo end_time cambiato = cambio durata
      return l10n.bookingHistoryEventDurationChanged;
    }

    return l10n.bookingHistoryEventAppointmentUpdated;
  }

  String _getActorLabel(String actorType, dynamic l10n) {
    switch (actorType) {
      case 'staff':
        return l10n.bookingHistoryActorStaff;
      case 'customer':
        return l10n.bookingHistoryActorCustomer;
      case 'system':
        return l10n.bookingHistoryActorSystem;
      default:
        return actorType;
    }
  }
}
--- FILE: lib/features/booking/presentation/dialogs/reschedule_booking_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:uuid/uuid.dart';

import '/core/l10n/l10_extension.dart';
import '/core/models/booking_item.dart';
import '/core/network/network_providers.dart';
import '/core/services/tenant_time_service.dart';
import '/core/widgets/feedback_dialog.dart';
import '../../providers/locations_provider.dart';
import '../../providers/my_bookings_provider.dart';

/// Dialog per riprogrammare una prenotazione esistente
class RescheduleBookingDialog extends ConsumerStatefulWidget {
  const RescheduleBookingDialog({required this.booking, super.key});

  final BookingItem booking;

  @override
  ConsumerState<RescheduleBookingDialog> createState() =>
      _RescheduleBookingDialogState();
}

class _RescheduleBookingDialogState
    extends ConsumerState<RescheduleBookingDialog> {
  DateTime? _selectedDate;
  String? _selectedTimeSlot;
  List<String> _availableSlots = [];
  bool _isLoadingSlots = false;
  bool _isSubmitting = false;
  String? _error;
  final _notesController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _notesController.text = widget.booking.notes ?? '';
    // Imposta data corrente della prenotazione
    _selectedDate = widget.booking.startTime;
    _loadAvailability(_selectedDate!);
  }

  @override
  void dispose() {
    _notesController.dispose();
    super.dispose();
  }

  Future<void> _loadAvailability(DateTime date) async {
    setState(() {
      _isLoadingSlots = true;
      _error = null;
      _selectedTimeSlot = null;
    });

    try {
      final apiClient = ref.read(apiClientProvider);
      final dateStr = DateFormat('yyyy-MM-dd').format(date);

      // Recupera service IDs dalla prenotazione corrente
      final serviceIds = widget.booking.serviceIds;
      final staffId = widget.booking.staffId;

      // Debug info
      debugPrint('RESCHEDULE - locationId: ${widget.booking.locationId}');
      debugPrint('RESCHEDULE - serviceIds: $serviceIds');
      debugPrint('RESCHEDULE - staffId: $staffId');
      debugPrint('RESCHEDULE - bookingId: ${widget.booking.id}');
      debugPrint('RESCHEDULE - date: $dateStr');

      if (serviceIds.isEmpty) {
        setState(() {
          _error = 'Impossibile recuperare i servizi della prenotazione';
          _isLoadingSlots = false;
        });
        return;
      }

      // Passa exclude_booking_id per escludere la prenotazione originale dai conflitti
      // Passa staffId per mostrare solo slot disponibili per quello specifico operatore
      final response = await apiClient.getAvailability(
        locationId: widget.booking.locationId,
        date: dateStr,
        serviceIds: serviceIds,
        staffId: staffId,
        excludeBookingId: widget.booking.id,
      );

      debugPrint(
        'RESCHEDULE - response slots count: ${(response['slots'] as List?)?.length ?? 0}',
      );

      final slots = response['slots'] as List<dynamic>? ?? [];
      final original = widget.booking.startTime;
      final isSameDayAsOriginal =
          date.year == original.year &&
          date.month == original.month &&
          date.day == original.day;
      final originalTimeSlot = isSameDayAsOriginal
          ? DateFormat('HH:mm').format(original)
          : null;
      setState(() {
        _availableSlots = slots
            .map((slot) {
              final startTime = slot['start_time'] as String;
              // Estrai orario ignorando timezone (orario della location, non locale utente)
              final dt = TenantTimeService.parseAsLocationTime(startTime);
              return DateFormat('HH:mm').format(dt);
            })
            // Non mostrare lo stesso identico orario (data+ora) della prenotazione originale
            // quando si sta modificando la prenotazione sulla stessa data.
            .where((t) => originalTimeSlot == null || t != originalTimeSlot)
            .toList()
            .cast<String>();
        _isLoadingSlots = false;
      });
    } catch (e) {
      debugPrint('RESCHEDULE - error: $e');
      setState(() {
        _error = e.toString();
        _isLoadingSlots = false;
      });
    }
  }

  Future<void> _selectDate() async {
    final now = ref.read(locationNowProvider);
    final firstDate = now;
    final lastDate = now.add(const Duration(days: 90));

    final picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate ?? now,
      firstDate: firstDate,
      lastDate: lastDate,
      locale: const Locale('it'),
    );

    if (picked != null && mounted) {
      setState(() {
        _selectedDate = picked;
      });
      await _loadAvailability(picked);
    }
  }

  Future<void> _confirmReschedule() async {
    if (_selectedDate == null || _selectedTimeSlot == null) {
      return;
    }
    if (_isSubmitting) return;

    final serviceIds = widget.booking.serviceIds;
    if (serviceIds.isEmpty) {
      await FeedbackDialog.showError(
        context,
        title: context.l10n.errorTitle,
        message: 'Impossibile recuperare i servizi della prenotazione',
      );
      return;
    }

    setState(() => _isSubmitting = true);

    // Costruisci nuovo start_time ISO8601
    final timeParts = _selectedTimeSlot!.split(':');
    final newDateTime = DateTime(
      _selectedDate!.year,
      _selectedDate!.month,
      _selectedDate!.day,
      int.parse(timeParts[0]),
      int.parse(timeParts[1]),
    );

    final newStartTime = newDateTime.toIso8601String();

    // Genera idempotency key per il replace
    final idempotencyKey = const Uuid().v4();

    // Usa il pattern atomic replace
    try {
      final result = await ref
          .read(myBookingsProvider.notifier)
          .replaceBooking(
            originalBookingId: widget.booking.id,
            locationId: widget.booking.locationId,
            serviceIds: serviceIds,
            startTime: newStartTime,
            idempotencyKey: idempotencyKey,
            notes: _notesController.text.isNotEmpty
                ? _notesController.text
                : null,
          );

      if (!mounted) return;

      if (result.success) {
        Navigator.of(context).pop(true);
      } else {
        final bookingsState = ref.read(myBookingsProvider);
        // Messaggio specifico per conflitto slot (spec C6)
        final errorMessage = bookingsState.errorCode == 'slot_conflict'
            ? context.l10n.slotNoLongerAvailable
            : bookingsState.errorCode == 'not_modifiable'
            ? context.l10n.bookingErrorNotModifiable
            : (bookingsState.error ?? context.l10n.errorGeneric);
        await FeedbackDialog.showError(
          context,
          title: context.l10n.errorTitle,
          message: errorMessage,
        );
      }
    } finally {
      if (mounted) setState(() => _isSubmitting = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    final dateFormat = DateFormat('dd/MM/yyyy', 'it');

    return AlertDialog(
      title: Text(context.l10n.rescheduleBookingTitle),
      content: SingleChildScrollView(
        child: SizedBox(
          width: MediaQuery.of(context).size.width * 0.8,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Info prenotazione corrente
              Text(
                context.l10n.currentBooking,
                style: Theme.of(context).textTheme.titleSmall,
              ),
              const SizedBox(height: 8),
              Text(
                '${widget.booking.serviceNames.join(', ')} - ${dateFormat.format(widget.booking.startTime)} ${DateFormat('HH:mm').format(widget.booking.startTime)}',
                style: Theme.of(context).textTheme.bodyMedium,
              ),
              const Divider(height: 24),

              // Selezione nuova data
              Text(
                context.l10n.selectNewDate,
                style: Theme.of(context).textTheme.titleSmall,
              ),
              const SizedBox(height: 8),
              OutlinedButton.icon(
                onPressed: _selectDate,
                icon: const Icon(Icons.calendar_today),
                label: Text(
                  _selectedDate != null
                      ? dateFormat.format(_selectedDate!)
                      : context.l10n.selectDate,
                ),
              ),
              const SizedBox(height: 16),

              // Slot disponibili
              if (_isLoadingSlots)
                const Center(child: CircularProgressIndicator())
              else if (_error != null)
                Text(_error!, style: const TextStyle(color: Colors.red))
              else if (_availableSlots.isEmpty)
                Text(context.l10n.dateTimeNoSlots)
              else ...[
                Text(
                  context.l10n.selectNewTime,
                  style: Theme.of(context).textTheme.titleSmall,
                ),
                const SizedBox(height: 8),
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: _availableSlots.map((slot) {
                    final isSelected = _selectedTimeSlot == slot;
                    return ChoiceChip(
                      label: Text(slot),
                      selected: isSelected,
                      onSelected: (selected) {
                        setState(() {
                          _selectedTimeSlot = selected ? slot : null;
                        });
                      },
                    );
                  }).toList(),
                ),
              ],
              const SizedBox(height: 16),

              // Note
              TextField(
                controller: _notesController,
                decoration: InputDecoration(
                  labelText: context.l10n.summaryNotes,
                  hintText: context.l10n.summaryNotesHint,
                  border: const OutlineInputBorder(),
                ),
                maxLines: 3,
              ),
            ],
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isSubmitting
              ? null
              : () => Navigator.of(context).pop(false),
          child: Text(context.l10n.actionCancel),
        ),
        FilledButton(
          onPressed: (_selectedDate != null && _selectedTimeSlot != null)
              ? (_isSubmitting ? null : _confirmReschedule)
              : null,
          child: _isSubmitting
              ? const SizedBox(
                  width: 18,
                  height: 18,
                  child: CircularProgressIndicator(strokeWidth: 2),
                )
              : Text(context.l10n.confirmReschedule),
        ),
      ],
    );
  }
}
--- FILE: lib/features/booking/presentation/widgets/booking_step_indicator.dart ---
import 'package:flutter/material.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../providers/booking_provider.dart';

class BookingStepIndicator extends StatelessWidget {
  final BookingStep currentStep;
  final bool allowStaffSelection;
  final bool showLocationStep;
  final void Function(BookingStep) onStepTap;

  const BookingStepIndicator({
    super.key,
    required this.currentStep,
    required this.allowStaffSelection,
    this.showLocationStep = false,
    required this.onStepTap,
  });

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    final steps = [
      if (showLocationStep)
        (BookingStep.location, l10n.bookingStepLocation, Icons.location_on),
      (BookingStep.services, l10n.bookingStepServices, Icons.list_alt),
      if (allowStaffSelection)
        (BookingStep.staff, l10n.bookingStepStaff, Icons.person),
      (BookingStep.dateTime, l10n.bookingStepDateTime, Icons.calendar_today),
      (
        BookingStep.summary,
        l10n.bookingStepSummary,
        Icons.check_circle_outline,
      ),
    ];

    return Container(
      padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 8),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(bottom: BorderSide(color: theme.dividerColor)),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        children: steps.asMap().entries.map((entry) {
          final index = entry.key;
          final (step, label, icon) = entry.value;
          final isActive = step == currentStep;
          final isPast = step.index < currentStep.index;
          final isClickable = isPast;

          return Expanded(
            child: GestureDetector(
              onTap: isClickable ? () => onStepTap(step) : null,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    children: [
                      if (index > 0)
                        Expanded(
                          child: Container(
                            height: 2,
                            color: isPast || isActive
                                ? theme.colorScheme.primary
                                : theme.dividerColor,
                          ),
                        ),
                      Container(
                        width: 32,
                        height: 32,
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          color: isActive
                              ? theme.colorScheme.primary
                              : isPast
                              ? theme.colorScheme.primary.withOpacity(0.2)
                              : theme.dividerColor,
                        ),
                        child: Icon(
                          isPast ? Icons.check : icon,
                          size: 18,
                          color: isActive
                              ? Colors.white
                              : isPast
                              ? theme.colorScheme.primary
                              : theme.colorScheme.onSurface.withOpacity(0.5),
                        ),
                      ),
                      if (index < steps.length - 1)
                        Expanded(
                          child: Container(
                            height: 2,
                            color: isPast
                                ? theme.colorScheme.primary
                                : theme.dividerColor,
                          ),
                        ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Text(
                    label,
                    style: theme.textTheme.bodySmall?.copyWith(
                      fontWeight: isActive
                          ? FontWeight.bold
                          : FontWeight.normal,
                      color: isActive || isPast
                          ? theme.colorScheme.onSurface
                          : theme.colorScheme.onSurface.withOpacity(0.5),
                    ),
                    textAlign: TextAlign.center,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ),
            ),
          );
        }).toList(),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/widgets/wrong_business_auth_banner.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../app/providers/route_slug_provider.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/network/network_providers.dart';
import '../../../auth/providers/auth_provider.dart';
import '../../providers/business_provider.dart';

/// Banner che appare quando l'utente √® autenticato per un business diverso
/// da quello corrente (URL slug).
///
/// Mostra un avviso e permette all'utente di fare logout e login nel business
/// corrente.
class WrongBusinessAuthBanner extends ConsumerWidget {
  const WrongBusinessAuthBanner({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    // Verifica se l'utente √® autenticato per un business diverso
    final isWrongBusiness = ref.watch(
      isAuthenticatedForDifferentBusinessProvider,
    );
    final isAuthenticated = ref.watch(
      authProvider.select((state) => state.isAuthenticated),
    );
    final currentBusiness = ref.watch(currentBusinessProvider).value;
    final slug = ref.watch(routeSlugProvider);

    // Non mostrare se:
    // - Non √® autenticato
    // - √à autenticato per il business corretto
    // - Dati non ancora caricati
    if (!isAuthenticated ||
        !isWrongBusiness.hasValue ||
        isWrongBusiness.value != true) {
      return const SizedBox.shrink();
    }

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      margin: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.errorContainer,
        borderRadius: BorderRadius.circular(12),
        border: Border.all(
          color: theme.colorScheme.error.withAlpha((0.3 * 255).round()),
        ),
      ),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(
            Icons.warning_amber_rounded,
            color: theme.colorScheme.error,
            size: 24,
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  l10n.wrongBusinessAuthTitle,
                  style: theme.textTheme.titleSmall?.copyWith(
                    color: theme.colorScheme.onErrorContainer,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  l10n.wrongBusinessAuthMessage(currentBusiness?.name ?? ''),
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.onErrorContainer,
                  ),
                ),
                const SizedBox(height: 12),
                SizedBox(
                  width: double.infinity,
                  child: OutlinedButton.icon(
                    onPressed: () => _handleLogoutAndLogin(context, ref, slug),
                    style: OutlinedButton.styleFrom(
                      foregroundColor: theme.colorScheme.error,
                      side: BorderSide(color: theme.colorScheme.error),
                    ),
                    icon: const Icon(Icons.logout, size: 18),
                    label: Text(l10n.wrongBusinessAuthAction),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _handleLogoutAndLogin(
    BuildContext context,
    WidgetRef ref,
    String? slug,
  ) async {
    if (slug == null) return;

    // Ottieni il businessId corrente per il logout
    final currentBusinessId = ref.read(currentBusinessIdProvider);
    if (currentBusinessId != null) {
      await ref
          .read(authProvider.notifier)
          .logout(businessId: currentBusinessId);
    }

    // Invalida il provider per forzare il refresh dello stato auth
    ref.invalidate(authenticatedBusinessIdProvider);

    // Naviga al login
    if (context.mounted) {
      context.go('/$slug/login');
    }
  }
}
--- FILE: lib/main.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_web_plugins/url_strategy.dart';
import 'package:timezone/data/latest.dart' as tz_data;

import 'app/app.dart';
import 'core/services/version_checker.dart';

void main() {
  WidgetsFlutterBinding.ensureInitialized();
  tz_data.initializeTimeZones();

  // Usa path URL strategy invece di hash (#) per URL puliti
  // Es: /vamps/booking invece di /#/vamps/booking
  usePathUrlStrategy();

  // Avvia il controllo periodico della versione (solo web).
  // Se rileva una nuova versione, forza il reload automatico.
  VersionChecker.instance.startPeriodicCheck();

  runApp(const ProviderScope(child: App()));
}
--- FILE: pubspec.yaml ---
name: agenda_frontend
description: "Frontend per prenotazioni online - Agenda Platform"
publish_to: 'none'
version: 1.0.0+1

environment:
  sdk: ^3.10.4

dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter
  flutter_web_plugins:
    sdk: flutter
  
  intl: ^0.20.2    
  characters: ^1.4.0
  flutter_riverpod: ^3.0.3
  riverpod_annotation: ^3.0.3
  go_router: ^16.2.4
  dio: ^5.4.0
  uuid: ^4.3.3
  flutter_secure_storage: ^9.0.0
  shared_preferences: ^2.2.2
  http: ^1.6.0
  timezone: ^0.10.1
dev_dependencies:
  build_runner: ^2.7.1
  riverpod_generator: ^3.0.3
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0
  intl_utils: ^2.8.11

flutter:
  uses-material-design: true
  
  fonts:
    - family: Roboto
      fonts:
        - asset: fonts/Roboto-Regular.ttf

flutter_intl:
  enabled: true
  class_name: L10n
  main_locale: it
  arb_dir: lib/core/l10n
  output_dir: lib/core/l10n
