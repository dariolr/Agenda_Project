=== Bundle di tutti i file TXT dei progetti ===
Bundle generato il: Thu Jan 15 10:01:30 +07 2026

>>> CONTENUTO: Frontend
--- FILE: lib/core/l10n/l10_extension.dart ---
import 'package:flutter/widgets.dart';

import 'l10n.dart';

/// üî§ Estensione per accedere facilmente alle stringhe localizzate.
///
/// Permette di scrivere:
/// ```dart
/// Text(context.l10n.welcomeMessage)
/// ```
/// invece di:
/// ```dart
/// Text(L10n.of(context).welcomeMessage)
/// ```
///
/// ‚úÖ Compatibile con aggiornamenti runtime della lingua.
/// ‚úÖ Evita dipendenze da `L10n.current` statico.
/// ‚úÖ Standard consigliato per progetti Flutter internazionalizzati.
extension L10nX on BuildContext {
  /// Restituisce l'istanza corrente di [L10n] per questo [BuildContext].
  L10n get l10n => L10n.of(this);
}

extension DurationLocalization on BuildContext {
  String localizedDurationLabel(int minutes) {
    final hours = minutes ~/ 60;
    final mins = minutes % 60;
    final l10n = this.l10n;

    if (hours > 0 && mins > 0) {
      return l10n.durationHourMinute(hours, mins);
    } else if (hours > 0) {
      return l10n.durationHour(hours);
    } else {
      return l10n.durationMinute(mins);
    }
  }
}
--- FILE: lib/core/l10n/intl/messages_all.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that looks up messages for specific locales by
// delegating to the appropriate library.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:implementation_imports, file_names, unnecessary_new
// ignore_for_file:unnecessary_brace_in_string_interps, directives_ordering
// ignore_for_file:argument_type_not_assignable, invalid_assignment
// ignore_for_file:prefer_single_quotes, prefer_generic_function_type_aliases
// ignore_for_file:comment_references

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';
import 'package:intl/src/intl_helpers.dart';

import 'messages_en.dart' as messages_en;
import 'messages_it.dart' as messages_it;

typedef Future<dynamic> LibraryLoader();
Map<String, LibraryLoader> _deferredLibraries = {
  'en': () => new SynchronousFuture(null),
  'it': () => new SynchronousFuture(null),
};

MessageLookupByLibrary? _findExact(String localeName) {
  switch (localeName) {
    case 'en':
      return messages_en.messages;
    case 'it':
      return messages_it.messages;
    default:
      return null;
  }
}

/// User programs should call this before using [localeName] for messages.
Future<bool> initializeMessages(String localeName) {
  var availableLocale = Intl.verifiedLocale(
    localeName,
    (locale) => _deferredLibraries[locale] != null,
    onFailure: (_) => null,
  );
  if (availableLocale == null) {
    return new SynchronousFuture(false);
  }
  var lib = _deferredLibraries[availableLocale];
  lib == null ? new SynchronousFuture(false) : lib();
  initializeInternalMessageLookup(() => new CompositeMessageLookup());
  messageLookup.addLocale(availableLocale, _findGeneratedMessagesFor);
  return new SynchronousFuture(true);
}

bool _messagesExistFor(String locale) {
  try {
    return _findExact(locale) != null;
  } catch (e) {
    return false;
  }
}

MessageLookupByLibrary? _findGeneratedMessagesFor(String locale) {
  var actualLocale = Intl.verifiedLocale(
    locale,
    _messagesExistFor,
    onFailure: (_) => null,
  );
  if (actualLocale == null) return null;
  return _findExact(actualLocale);
}
--- FILE: lib/core/l10n/intl/messages_it.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that provides messages for a it locale. All the
// messages from the main program should be duplicated here with the same
// function name.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:unnecessary_brace_in_string_interps, unnecessary_new
// ignore_for_file:prefer_single_quotes,comment_references, directives_ordering
// ignore_for_file:annotate_overrides,prefer_generic_function_type_aliases
// ignore_for_file:unused_import, file_names, avoid_escaping_inner_quotes
// ignore_for_file:unnecessary_string_interpolations, unnecessary_string_escapes

import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = new MessageLookup();

typedef String MessageIfAbsent(String messageStr, List<dynamic> args);

class MessageLookup extends MessageLookupByLibrary {
  String get localeName => 'it';

  static String m0(id) => "Codice prenotazione: ${id}";

  static String m1(date) => "Prima disponibilit√†: ${date}";

  static String m2(hours) => "${hours} ora";

  static String m3(hours, minutes) => "${hours} ora ${minutes} min";

  static String m4(minutes) => "${minutes} min";

  static String m5(minutes) => "${minutes} min";

  static String m6(path) => "Pagina non trovata: ${path}";

  static String m7(days) =>
      "${Intl.plural(days, one: 'Modificabile fino a domani', other: 'Modificabile fino a ${days} giorni')}";

  static String m8(hours) =>
      "${Intl.plural(hours, one: 'Modificabile fino a 1 ora', other: 'Modificabile fino a ${hours} ore')}";

  static String m9(minutes) =>
      "${Intl.plural(minutes, one: 'Modificabile fino a 1 minuto', other: 'Modificabile fino a ${minutes} minuti')}";

  static String m10(price) => "‚Ç¨${price}";

  static String m11(duration) => "${duration} min";

  static String m12(price) => "da ${price}";

  static String m13(count) =>
      "${Intl.plural(count, zero: 'Nessun servizio selezionato', one: '1 servizio selezionato', other: '${count} servizi selezionati')}";

  static String m14(total) => "Totale: ${total}";

  final messages = _notInlinedMessages(_notInlinedMessages);
  static Map<String, Function> _notInlinedMessages(_) => <String, Function>{
    "actionBack": MessageLookupByLibrary.simpleMessage("Indietro"),
    "actionCancel": MessageLookupByLibrary.simpleMessage("Annulla"),
    "actionClose": MessageLookupByLibrary.simpleMessage("Chiudi"),
    "actionConfirm": MessageLookupByLibrary.simpleMessage("Conferma"),
    "actionLogin": MessageLookupByLibrary.simpleMessage("Accedi"),
    "actionLogout": MessageLookupByLibrary.simpleMessage("Esci"),
    "actionNext": MessageLookupByLibrary.simpleMessage("Avanti"),
    "actionRegister": MessageLookupByLibrary.simpleMessage("Registrati"),
    "actionRetry": MessageLookupByLibrary.simpleMessage("Riprova"),
    "appTitle": MessageLookupByLibrary.simpleMessage("Prenota Online"),
    "authChangePassword": MessageLookupByLibrary.simpleMessage(
      "Cambia password",
    ),
    "authChangePasswordError": MessageLookupByLibrary.simpleMessage(
      "Password attuale non corretta",
    ),
    "authChangePasswordSuccess": MessageLookupByLibrary.simpleMessage(
      "Password modificata con successo",
    ),
    "authChangePasswordTitle": MessageLookupByLibrary.simpleMessage(
      "Cambia password",
    ),
    "authConfirmPassword": MessageLookupByLibrary.simpleMessage(
      "Conferma password",
    ),
    "authCurrentPassword": MessageLookupByLibrary.simpleMessage(
      "Password attuale",
    ),
    "authEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "authFirstName": MessageLookupByLibrary.simpleMessage("Nome"),
    "authForgotPassword": MessageLookupByLibrary.simpleMessage(
      "Password dimenticata?",
    ),
    "authHaveAccount": MessageLookupByLibrary.simpleMessage(
      "Hai gi√† un account?",
    ),
    "authInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Email non valida",
    ),
    "authInvalidPassword": MessageLookupByLibrary.simpleMessage(
      "Password troppo corta (min. 6 caratteri)",
    ),
    "authInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Numero di telefono non valido",
    ),
    "authLastName": MessageLookupByLibrary.simpleMessage("Cognome"),
    "authLoginFailed": MessageLookupByLibrary.simpleMessage(
      "Credenziali non valide",
    ),
    "authLoginSuccess": MessageLookupByLibrary.simpleMessage(
      "Accesso effettuato",
    ),
    "authLoginTitle": MessageLookupByLibrary.simpleMessage(
      "Accedi al tuo account",
    ),
    "authNewPassword": MessageLookupByLibrary.simpleMessage("Nuova password"),
    "authNoAccount": MessageLookupByLibrary.simpleMessage(
      "Non hai un account?",
    ),
    "authPassword": MessageLookupByLibrary.simpleMessage("Password"),
    "authPasswordMismatch": MessageLookupByLibrary.simpleMessage(
      "Le password non coincidono",
    ),
    "authPasswordRequirements": MessageLookupByLibrary.simpleMessage(
      "La password deve contenere: maiuscola, minuscola, numero",
    ),
    "authPasswordTooShort": MessageLookupByLibrary.simpleMessage(
      "Password troppo corta (min. 8 caratteri)",
    ),
    "authPhone": MessageLookupByLibrary.simpleMessage("Telefono"),
    "authRegisterFailed": MessageLookupByLibrary.simpleMessage(
      "Registrazione fallita",
    ),
    "authRegisterSuccess": MessageLookupByLibrary.simpleMessage(
      "Registrazione completata",
    ),
    "authRegisterTitle": MessageLookupByLibrary.simpleMessage(
      "Crea un nuovo account",
    ),
    "authRequiredField": MessageLookupByLibrary.simpleMessage(
      "Campo obbligatorio",
    ),
    "authResetPasswordConfirmError": MessageLookupByLibrary.simpleMessage(
      "Token non valido o scaduto",
    ),
    "authResetPasswordConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "Inserisci la nuova password",
    ),
    "authResetPasswordConfirmSuccess": MessageLookupByLibrary.simpleMessage(
      "Password reimpostata con successo!",
    ),
    "authResetPasswordConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Reimposta password",
    ),
    "authResetPasswordError": MessageLookupByLibrary.simpleMessage(
      "Errore durante l\'invio. Riprova.",
    ),
    "authResetPasswordMessage": MessageLookupByLibrary.simpleMessage(
      "Inserisci la tua email e ti invieremo le istruzioni per reimpostare la password.",
    ),
    "authResetPasswordSend": MessageLookupByLibrary.simpleMessage("Invia"),
    "authResetPasswordSuccess": MessageLookupByLibrary.simpleMessage(
      "Email inviata! Controlla la tua casella di posta.",
    ),
    "authResetPasswordTitle": MessageLookupByLibrary.simpleMessage(
      "Recupera password",
    ),
    "authWelcome": MessageLookupByLibrary.simpleMessage("Benvenuto"),
    "bookingCancelFailed": MessageLookupByLibrary.simpleMessage(
      "Errore durante l\'annullamento",
    ),
    "bookingCancelled": MessageLookupByLibrary.simpleMessage(
      "Prenotazione annullata con successo",
    ),
    "bookingRescheduled": MessageLookupByLibrary.simpleMessage(
      "Prenotazione riprogrammata con successo",
    ),
    "bookingStepDateTime": MessageLookupByLibrary.simpleMessage("Data e ora"),
    "bookingStepLocation": MessageLookupByLibrary.simpleMessage("Sede"),
    "bookingStepServices": MessageLookupByLibrary.simpleMessage("Servizi"),
    "bookingStepStaff": MessageLookupByLibrary.simpleMessage("Operatore"),
    "bookingStepSummary": MessageLookupByLibrary.simpleMessage("Riepilogo"),
    "bookingTitle": MessageLookupByLibrary.simpleMessage(
      "Prenota appuntamento",
    ),
    "businessNotFound": MessageLookupByLibrary.simpleMessage(
      "Attivit√† non trovata",
    ),
    "businessNotFoundHint": MessageLookupByLibrary.simpleMessage(
      "Verifica l\'indirizzo o contatta direttamente l\'attivit√†.",
    ),
    "cancel": MessageLookupByLibrary.simpleMessage("Annulla"),
    "cancelBookingConfirm": MessageLookupByLibrary.simpleMessage(
      "Sei sicuro di voler annullare questa prenotazione?",
    ),
    "cancelBookingTitle": MessageLookupByLibrary.simpleMessage(
      "Annulla prenotazione",
    ),
    "confirmReschedule": MessageLookupByLibrary.simpleMessage(
      "Conferma modifica",
    ),
    "confirmationBookingId": m0,
    "confirmationGoHome": MessageLookupByLibrary.simpleMessage(
      "Torna alla home",
    ),
    "confirmationNewBooking": MessageLookupByLibrary.simpleMessage(
      "Nuova prenotazione",
    ),
    "confirmationSubtitle": MessageLookupByLibrary.simpleMessage(
      "Ti abbiamo inviato un\'email di conferma",
    ),
    "confirmationTitle": MessageLookupByLibrary.simpleMessage(
      "Prenotazione confermata!",
    ),
    "currentBooking": MessageLookupByLibrary.simpleMessage(
      "Prenotazione attuale",
    ),
    "dateTimeAfternoon": MessageLookupByLibrary.simpleMessage("Pomeriggio"),
    "dateTimeEvening": MessageLookupByLibrary.simpleMessage("Sera"),
    "dateTimeFirstAvailable": m1,
    "dateTimeMorning": MessageLookupByLibrary.simpleMessage("Mattina"),
    "dateTimeNoSlots": MessageLookupByLibrary.simpleMessage(
      "Nessun orario disponibile per questa data",
    ),
    "dateTimeSelectDate": MessageLookupByLibrary.simpleMessage(
      "Seleziona una data",
    ),
    "dateTimeSubtitle": MessageLookupByLibrary.simpleMessage(
      "Seleziona quando desideri prenotare",
    ),
    "dateTimeTitle": MessageLookupByLibrary.simpleMessage("Scegli data e ora"),
    "durationHour": m2,
    "durationHourMinute": m3,
    "durationMinute": m4,
    "durationMinutes": m5,
    "errorBusinessNotActive": MessageLookupByLibrary.simpleMessage(
      "Attivit√† non attiva",
    ),
    "errorBusinessNotActiveSubtitle": MessageLookupByLibrary.simpleMessage(
      "Questa attivit√† non √® ancora configurata per le prenotazioni online. Contatta direttamente l\'attivit√†.",
    ),
    "errorBusinessNotFound": MessageLookupByLibrary.simpleMessage(
      "Attivit√† non trovata",
    ),
    "errorBusinessNotFoundSubtitle": MessageLookupByLibrary.simpleMessage(
      "L\'attivit√† richiesta non esiste. Verifica l\'indirizzo o contatta direttamente l\'attivit√†.",
    ),
    "errorConnectionTimeout": MessageLookupByLibrary.simpleMessage(
      "La connessione sta impiegando troppo tempo. Riprova.",
    ),
    "errorGeneric": MessageLookupByLibrary.simpleMessage(
      "Si √® verificato un errore",
    ),
    "errorLoadingAvailability": MessageLookupByLibrary.simpleMessage(
      "Impossibile caricare le disponibilit√†. Verifica la connessione e riprova.",
    ),
    "errorLoadingBookings": MessageLookupByLibrary.simpleMessage(
      "Errore nel caricamento delle prenotazioni",
    ),
    "errorLoadingServices": MessageLookupByLibrary.simpleMessage(
      "Impossibile caricare i servizi. Verifica la connessione e riprova.",
    ),
    "errorLoadingStaff": MessageLookupByLibrary.simpleMessage(
      "Impossibile caricare gli operatori. Verifica la connessione e riprova.",
    ),
    "errorLocationNotFound": MessageLookupByLibrary.simpleMessage(
      "Sede non disponibile",
    ),
    "errorLocationNotFoundSubtitle": MessageLookupByLibrary.simpleMessage(
      "La sede selezionata non √® attiva. Contatta l\'attivit√† per maggiori informazioni.",
    ),
    "errorNoAvailability": MessageLookupByLibrary.simpleMessage(
      "Nessuna disponibilit√† per la data selezionata",
    ),
    "errorNotFound": m6,
    "errorServiceUnavailable": MessageLookupByLibrary.simpleMessage(
      "Servizio temporaneamente non disponibile",
    ),
    "errorServiceUnavailableSubtitle": MessageLookupByLibrary.simpleMessage(
      "Stiamo lavorando per risolvere il problema. Riprova tra qualche minuto.",
    ),
    "errorTitle": MessageLookupByLibrary.simpleMessage("Errore"),
    "locationEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessuna sede disponibile",
    ),
    "locationSubtitle": MessageLookupByLibrary.simpleMessage(
      "Seleziona dove vuoi effettuare la prenotazione",
    ),
    "locationTitle": MessageLookupByLibrary.simpleMessage("Scegli la sede"),
    "modifiable": MessageLookupByLibrary.simpleMessage("Modificabile"),
    "modifiableUntilDays": m7,
    "modifiableUntilHours": m8,
    "modifiableUntilMinutes": m9,
    "modify": MessageLookupByLibrary.simpleMessage("Modifica"),
    "modifyNotImplemented": MessageLookupByLibrary.simpleMessage(
      "Funzione di modifica in sviluppo",
    ),
    "monthApril": MessageLookupByLibrary.simpleMessage("Aprile"),
    "monthAugust": MessageLookupByLibrary.simpleMessage("Agosto"),
    "monthDecember": MessageLookupByLibrary.simpleMessage("Dicembre"),
    "monthFebruary": MessageLookupByLibrary.simpleMessage("Febbraio"),
    "monthJanuary": MessageLookupByLibrary.simpleMessage("Gennaio"),
    "monthJuly": MessageLookupByLibrary.simpleMessage("Luglio"),
    "monthJune": MessageLookupByLibrary.simpleMessage("Giugno"),
    "monthMarch": MessageLookupByLibrary.simpleMessage("Marzo"),
    "monthMay": MessageLookupByLibrary.simpleMessage("Maggio"),
    "monthNovember": MessageLookupByLibrary.simpleMessage("Novembre"),
    "monthOctober": MessageLookupByLibrary.simpleMessage("Ottobre"),
    "monthSeptember": MessageLookupByLibrary.simpleMessage("Settembre"),
    "myBookings": MessageLookupByLibrary.simpleMessage("Le mie prenotazioni"),
    "no": MessageLookupByLibrary.simpleMessage("No"),
    "noPastBookings": MessageLookupByLibrary.simpleMessage(
      "Non hai prenotazioni passate",
    ),
    "noUpcomingBookings": MessageLookupByLibrary.simpleMessage(
      "Non hai prenotazioni in programma",
    ),
    "notModifiable": MessageLookupByLibrary.simpleMessage("Non modificabile"),
    "pastBookings": MessageLookupByLibrary.simpleMessage("Passate"),
    "priceFormat": m10,
    "profileTitle": MessageLookupByLibrary.simpleMessage("Profilo"),
    "rescheduleBookingTitle": MessageLookupByLibrary.simpleMessage(
      "Riprogramma prenotazione",
    ),
    "selectDate": MessageLookupByLibrary.simpleMessage("Seleziona data"),
    "selectNewDate": MessageLookupByLibrary.simpleMessage(
      "Seleziona nuova data",
    ),
    "selectNewTime": MessageLookupByLibrary.simpleMessage(
      "Seleziona nuovo orario",
    ),
    "servicesDuration": m11,
    "servicesEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessun servizio disponibile al momento",
    ),
    "servicesEmptySubtitle": MessageLookupByLibrary.simpleMessage(
      "Non ci sono servizi prenotabili online per questa attivit√†",
    ),
    "servicesFree": MessageLookupByLibrary.simpleMessage("Gratis"),
    "servicesPriceFrom": m12,
    "servicesSelected": m13,
    "servicesSubtitle": MessageLookupByLibrary.simpleMessage(
      "Puoi selezionare uno o pi√π servizi",
    ),
    "servicesTitle": MessageLookupByLibrary.simpleMessage("Scegli i servizi"),
    "servicesTotal": m14,
    "staffAnyOperator": MessageLookupByLibrary.simpleMessage(
      "Qualsiasi operatore disponibile",
    ),
    "staffAnyOperatorSubtitle": MessageLookupByLibrary.simpleMessage(
      "Ti assegneremo il primo operatore libero",
    ),
    "staffEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessun operatore disponibile al momento",
    ),
    "staffSubtitle": MessageLookupByLibrary.simpleMessage(
      "Seleziona con chi desideri essere servito",
    ),
    "staffTitle": MessageLookupByLibrary.simpleMessage("Scegli l\'operatore"),
    "summaryDateTime": MessageLookupByLibrary.simpleMessage("Data e ora"),
    "summaryDuration": MessageLookupByLibrary.simpleMessage("Durata totale"),
    "summaryNotes": MessageLookupByLibrary.simpleMessage("Note (opzionale)"),
    "summaryNotesHint": MessageLookupByLibrary.simpleMessage(
      "Aggiungi eventuali note per l\'appuntamento...",
    ),
    "summaryOperator": MessageLookupByLibrary.simpleMessage("Operatore"),
    "summaryPrice": MessageLookupByLibrary.simpleMessage("Prezzo totale"),
    "summaryServices": MessageLookupByLibrary.simpleMessage(
      "Servizi selezionati",
    ),
    "summarySubtitle": MessageLookupByLibrary.simpleMessage(
      "Controlla i dettagli prima di confermare",
    ),
    "summaryTitle": MessageLookupByLibrary.simpleMessage(
      "Riepilogo prenotazione",
    ),
    "upcomingBookings": MessageLookupByLibrary.simpleMessage("Prossime"),
    "validationInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Email non valida",
    ),
    "validationInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Telefono non valido",
    ),
    "validationRequired": MessageLookupByLibrary.simpleMessage(
      "Campo obbligatorio",
    ),
    "weekdayFri": MessageLookupByLibrary.simpleMessage("Ven"),
    "weekdayMon": MessageLookupByLibrary.simpleMessage("Lun"),
    "weekdaySat": MessageLookupByLibrary.simpleMessage("Sab"),
    "weekdaySun": MessageLookupByLibrary.simpleMessage("Dom"),
    "weekdayThu": MessageLookupByLibrary.simpleMessage("Gio"),
    "weekdayTue": MessageLookupByLibrary.simpleMessage("Mar"),
    "weekdayWed": MessageLookupByLibrary.simpleMessage("Mer"),
    "yes": MessageLookupByLibrary.simpleMessage("S√¨"),
  };
}
--- FILE: lib/core/l10n/intl/messages_en.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that provides messages for a en locale. All the
// messages from the main program should be duplicated here with the same
// function name.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:unnecessary_brace_in_string_interps, unnecessary_new
// ignore_for_file:prefer_single_quotes,comment_references, directives_ordering
// ignore_for_file:annotate_overrides,prefer_generic_function_type_aliases
// ignore_for_file:unused_import, file_names, avoid_escaping_inner_quotes
// ignore_for_file:unnecessary_string_interpolations, unnecessary_string_escapes

import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = new MessageLookup();

typedef String MessageIfAbsent(String messageStr, List<dynamic> args);

class MessageLookup extends MessageLookupByLibrary {
  String get localeName => 'en';

  static String m0(id) => "Booking code: ${id}";

  static String m1(date) => "First available: ${date}";

  static String m2(hours) => "${hours} hour";

  static String m3(hours, minutes) => "${hours} hour ${minutes} min";

  static String m4(minutes) => "${minutes} min";

  static String m5(minutes) => "${minutes} min";

  static String m6(path) => "Page not found: ${path}";

  static String m7(days) =>
      "${Intl.plural(days, one: 'Modifiable until tomorrow', other: 'Modifiable for ${days} days')}";

  static String m8(hours) =>
      "${Intl.plural(hours, one: 'Modifiable for 1 hour', other: 'Modifiable for ${hours} hours')}";

  static String m9(minutes) =>
      "${Intl.plural(minutes, one: 'Modifiable for 1 minute', other: 'Modifiable for ${minutes} minutes')}";

  static String m10(price) => "‚Ç¨${price}";

  static String m11(duration) => "${duration} min";

  static String m12(price) => "from ${price}";

  static String m13(count) =>
      "${Intl.plural(count, zero: 'No service selected', one: '1 service selected', other: '${count} services selected')}";

  static String m14(total) => "Total: ${total}";

  final messages = _notInlinedMessages(_notInlinedMessages);
  static Map<String, Function> _notInlinedMessages(_) => <String, Function>{
    "actionBack": MessageLookupByLibrary.simpleMessage("Back"),
    "actionCancel": MessageLookupByLibrary.simpleMessage("Cancel"),
    "actionClose": MessageLookupByLibrary.simpleMessage("Close"),
    "actionConfirm": MessageLookupByLibrary.simpleMessage("Confirm"),
    "actionLogin": MessageLookupByLibrary.simpleMessage("Login"),
    "actionLogout": MessageLookupByLibrary.simpleMessage("Logout"),
    "actionNext": MessageLookupByLibrary.simpleMessage("Next"),
    "actionRegister": MessageLookupByLibrary.simpleMessage("Register"),
    "actionRetry": MessageLookupByLibrary.simpleMessage("Retry"),
    "appTitle": MessageLookupByLibrary.simpleMessage("Book Online"),
    "authChangePassword": MessageLookupByLibrary.simpleMessage(
      "Change password",
    ),
    "authChangePasswordError": MessageLookupByLibrary.simpleMessage(
      "Current password is incorrect",
    ),
    "authChangePasswordSuccess": MessageLookupByLibrary.simpleMessage(
      "Password changed successfully",
    ),
    "authChangePasswordTitle": MessageLookupByLibrary.simpleMessage(
      "Change password",
    ),
    "authConfirmPassword": MessageLookupByLibrary.simpleMessage(
      "Confirm password",
    ),
    "authCurrentPassword": MessageLookupByLibrary.simpleMessage(
      "Current password",
    ),
    "authEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "authFirstName": MessageLookupByLibrary.simpleMessage("First name"),
    "authForgotPassword": MessageLookupByLibrary.simpleMessage(
      "Forgot password?",
    ),
    "authHaveAccount": MessageLookupByLibrary.simpleMessage(
      "Already have an account?",
    ),
    "authInvalidEmail": MessageLookupByLibrary.simpleMessage("Invalid email"),
    "authInvalidPassword": MessageLookupByLibrary.simpleMessage(
      "Password too short (min. 6 characters)",
    ),
    "authInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Invalid phone number",
    ),
    "authLastName": MessageLookupByLibrary.simpleMessage("Last name"),
    "authLoginFailed": MessageLookupByLibrary.simpleMessage(
      "Invalid credentials",
    ),
    "authLoginSuccess": MessageLookupByLibrary.simpleMessage(
      "Login successful",
    ),
    "authLoginTitle": MessageLookupByLibrary.simpleMessage(
      "Login to your account",
    ),
    "authNewPassword": MessageLookupByLibrary.simpleMessage("New password"),
    "authNoAccount": MessageLookupByLibrary.simpleMessage(
      "Don\'t have an account?",
    ),
    "authPassword": MessageLookupByLibrary.simpleMessage("Password"),
    "authPasswordMismatch": MessageLookupByLibrary.simpleMessage(
      "Passwords don\'t match",
    ),
    "authPasswordRequirements": MessageLookupByLibrary.simpleMessage(
      "Password must contain: uppercase, lowercase, number",
    ),
    "authPasswordTooShort": MessageLookupByLibrary.simpleMessage(
      "Password too short (min. 8 characters)",
    ),
    "authPhone": MessageLookupByLibrary.simpleMessage("Phone"),
    "authRegisterFailed": MessageLookupByLibrary.simpleMessage(
      "Registration failed",
    ),
    "authRegisterSuccess": MessageLookupByLibrary.simpleMessage(
      "Registration completed",
    ),
    "authRegisterTitle": MessageLookupByLibrary.simpleMessage(
      "Create a new account",
    ),
    "authRequiredField": MessageLookupByLibrary.simpleMessage("Required field"),
    "authResetPasswordConfirmError": MessageLookupByLibrary.simpleMessage(
      "Invalid or expired token",
    ),
    "authResetPasswordConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "Enter your new password",
    ),
    "authResetPasswordConfirmSuccess": MessageLookupByLibrary.simpleMessage(
      "Password reset successful!",
    ),
    "authResetPasswordConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Reset password",
    ),
    "authResetPasswordError": MessageLookupByLibrary.simpleMessage(
      "Error sending email. Please try again.",
    ),
    "authResetPasswordMessage": MessageLookupByLibrary.simpleMessage(
      "Enter your email and we\'ll send you instructions to reset your password.",
    ),
    "authResetPasswordSend": MessageLookupByLibrary.simpleMessage("Send"),
    "authResetPasswordSuccess": MessageLookupByLibrary.simpleMessage(
      "Email sent! Check your inbox.",
    ),
    "authResetPasswordTitle": MessageLookupByLibrary.simpleMessage(
      "Reset password",
    ),
    "authWelcome": MessageLookupByLibrary.simpleMessage("Welcome"),
    "bookingCancelFailed": MessageLookupByLibrary.simpleMessage(
      "Error cancelling booking",
    ),
    "bookingCancelled": MessageLookupByLibrary.simpleMessage(
      "Booking cancelled successfully",
    ),
    "bookingRescheduled": MessageLookupByLibrary.simpleMessage(
      "Booking rescheduled successfully",
    ),
    "bookingStepDateTime": MessageLookupByLibrary.simpleMessage("Date & Time"),
    "bookingStepLocation": MessageLookupByLibrary.simpleMessage("Location"),
    "bookingStepServices": MessageLookupByLibrary.simpleMessage("Services"),
    "bookingStepStaff": MessageLookupByLibrary.simpleMessage("Staff"),
    "bookingStepSummary": MessageLookupByLibrary.simpleMessage("Summary"),
    "bookingTitle": MessageLookupByLibrary.simpleMessage("Book appointment"),
    "businessNotFound": MessageLookupByLibrary.simpleMessage(
      "Business not found",
    ),
    "businessNotFoundHint": MessageLookupByLibrary.simpleMessage(
      "Please check the URL or contact the business directly.",
    ),
    "cancel": MessageLookupByLibrary.simpleMessage("Cancel"),
    "cancelBookingConfirm": MessageLookupByLibrary.simpleMessage(
      "Are you sure you want to cancel this booking?",
    ),
    "cancelBookingTitle": MessageLookupByLibrary.simpleMessage(
      "Cancel booking",
    ),
    "confirmReschedule": MessageLookupByLibrary.simpleMessage(
      "Confirm reschedule",
    ),
    "confirmationBookingId": m0,
    "confirmationGoHome": MessageLookupByLibrary.simpleMessage("Go to home"),
    "confirmationNewBooking": MessageLookupByLibrary.simpleMessage(
      "New booking",
    ),
    "confirmationSubtitle": MessageLookupByLibrary.simpleMessage(
      "We\'ve sent you a confirmation email",
    ),
    "confirmationTitle": MessageLookupByLibrary.simpleMessage(
      "Booking confirmed!",
    ),
    "currentBooking": MessageLookupByLibrary.simpleMessage("Current booking"),
    "dateTimeAfternoon": MessageLookupByLibrary.simpleMessage("Afternoon"),
    "dateTimeEvening": MessageLookupByLibrary.simpleMessage("Evening"),
    "dateTimeFirstAvailable": m1,
    "dateTimeMorning": MessageLookupByLibrary.simpleMessage("Morning"),
    "dateTimeNoSlots": MessageLookupByLibrary.simpleMessage(
      "No time slots available for this date",
    ),
    "dateTimeSelectDate": MessageLookupByLibrary.simpleMessage("Select a date"),
    "dateTimeSubtitle": MessageLookupByLibrary.simpleMessage(
      "Select when you want to book",
    ),
    "dateTimeTitle": MessageLookupByLibrary.simpleMessage(
      "Choose date and time",
    ),
    "durationHour": m2,
    "durationHourMinute": m3,
    "durationMinute": m4,
    "durationMinutes": m5,
    "errorBusinessNotActive": MessageLookupByLibrary.simpleMessage(
      "Business not active",
    ),
    "errorBusinessNotActiveSubtitle": MessageLookupByLibrary.simpleMessage(
      "This business is not yet configured for online bookings. Please contact the business directly.",
    ),
    "errorBusinessNotFound": MessageLookupByLibrary.simpleMessage(
      "Business not found",
    ),
    "errorBusinessNotFoundSubtitle": MessageLookupByLibrary.simpleMessage(
      "The requested business does not exist. Please check the URL or contact the business directly.",
    ),
    "errorConnectionTimeout": MessageLookupByLibrary.simpleMessage(
      "The connection is taking too long. Please try again.",
    ),
    "errorGeneric": MessageLookupByLibrary.simpleMessage("An error occurred"),
    "errorLoadingAvailability": MessageLookupByLibrary.simpleMessage(
      "Unable to load availability. Check your connection and try again.",
    ),
    "errorLoadingBookings": MessageLookupByLibrary.simpleMessage(
      "Error loading bookings",
    ),
    "errorLoadingServices": MessageLookupByLibrary.simpleMessage(
      "Unable to load services. Check your connection and try again.",
    ),
    "errorLoadingStaff": MessageLookupByLibrary.simpleMessage(
      "Unable to load staff. Check your connection and try again.",
    ),
    "errorLocationNotFound": MessageLookupByLibrary.simpleMessage(
      "Location not available",
    ),
    "errorLocationNotFoundSubtitle": MessageLookupByLibrary.simpleMessage(
      "The selected location is not active. Contact the business for more information.",
    ),
    "errorNoAvailability": MessageLookupByLibrary.simpleMessage(
      "No availability for the selected date",
    ),
    "errorNotFound": m6,
    "errorServiceUnavailable": MessageLookupByLibrary.simpleMessage(
      "Service temporarily unavailable",
    ),
    "errorServiceUnavailableSubtitle": MessageLookupByLibrary.simpleMessage(
      "We are working to fix the issue. Please try again in a few minutes.",
    ),
    "errorTitle": MessageLookupByLibrary.simpleMessage("Error"),
    "locationEmpty": MessageLookupByLibrary.simpleMessage(
      "No location available",
    ),
    "locationSubtitle": MessageLookupByLibrary.simpleMessage(
      "Select where you want to book",
    ),
    "locationTitle": MessageLookupByLibrary.simpleMessage("Choose location"),
    "modifiable": MessageLookupByLibrary.simpleMessage("Modifiable"),
    "modifiableUntilDays": m7,
    "modifiableUntilHours": m8,
    "modifiableUntilMinutes": m9,
    "modify": MessageLookupByLibrary.simpleMessage("Modify"),
    "modifyNotImplemented": MessageLookupByLibrary.simpleMessage(
      "Modify feature under development",
    ),
    "monthApril": MessageLookupByLibrary.simpleMessage("April"),
    "monthAugust": MessageLookupByLibrary.simpleMessage("August"),
    "monthDecember": MessageLookupByLibrary.simpleMessage("December"),
    "monthFebruary": MessageLookupByLibrary.simpleMessage("February"),
    "monthJanuary": MessageLookupByLibrary.simpleMessage("January"),
    "monthJuly": MessageLookupByLibrary.simpleMessage("July"),
    "monthJune": MessageLookupByLibrary.simpleMessage("June"),
    "monthMarch": MessageLookupByLibrary.simpleMessage("March"),
    "monthMay": MessageLookupByLibrary.simpleMessage("May"),
    "monthNovember": MessageLookupByLibrary.simpleMessage("November"),
    "monthOctober": MessageLookupByLibrary.simpleMessage("October"),
    "monthSeptember": MessageLookupByLibrary.simpleMessage("September"),
    "myBookings": MessageLookupByLibrary.simpleMessage("My bookings"),
    "no": MessageLookupByLibrary.simpleMessage("No"),
    "noPastBookings": MessageLookupByLibrary.simpleMessage(
      "You have no past bookings",
    ),
    "noUpcomingBookings": MessageLookupByLibrary.simpleMessage(
      "You have no upcoming bookings",
    ),
    "notModifiable": MessageLookupByLibrary.simpleMessage("Not modifiable"),
    "pastBookings": MessageLookupByLibrary.simpleMessage("Past"),
    "priceFormat": m10,
    "profileTitle": MessageLookupByLibrary.simpleMessage("Profile"),
    "rescheduleBookingTitle": MessageLookupByLibrary.simpleMessage(
      "Reschedule booking",
    ),
    "selectDate": MessageLookupByLibrary.simpleMessage("Select date"),
    "selectNewDate": MessageLookupByLibrary.simpleMessage("Select new date"),
    "selectNewTime": MessageLookupByLibrary.simpleMessage("Select new time"),
    "servicesDuration": m11,
    "servicesEmpty": MessageLookupByLibrary.simpleMessage(
      "No services available at the moment",
    ),
    "servicesEmptySubtitle": MessageLookupByLibrary.simpleMessage(
      "There are no services available for online booking at this business",
    ),
    "servicesFree": MessageLookupByLibrary.simpleMessage("Free"),
    "servicesPriceFrom": m12,
    "servicesSelected": m13,
    "servicesSubtitle": MessageLookupByLibrary.simpleMessage(
      "You can select one or more services",
    ),
    "servicesTitle": MessageLookupByLibrary.simpleMessage("Choose services"),
    "servicesTotal": m14,
    "staffAnyOperator": MessageLookupByLibrary.simpleMessage(
      "Any available staff",
    ),
    "staffAnyOperatorSubtitle": MessageLookupByLibrary.simpleMessage(
      "We\'ll assign you the first available staff member",
    ),
    "staffEmpty": MessageLookupByLibrary.simpleMessage(
      "No staff available at the moment",
    ),
    "staffSubtitle": MessageLookupByLibrary.simpleMessage(
      "Select who you want to be served by",
    ),
    "staffTitle": MessageLookupByLibrary.simpleMessage("Choose staff member"),
    "summaryDateTime": MessageLookupByLibrary.simpleMessage("Date and time"),
    "summaryDuration": MessageLookupByLibrary.simpleMessage("Total duration"),
    "summaryNotes": MessageLookupByLibrary.simpleMessage("Notes (optional)"),
    "summaryNotesHint": MessageLookupByLibrary.simpleMessage(
      "Add any notes for the appointment...",
    ),
    "summaryOperator": MessageLookupByLibrary.simpleMessage("Staff member"),
    "summaryPrice": MessageLookupByLibrary.simpleMessage("Total price"),
    "summaryServices": MessageLookupByLibrary.simpleMessage(
      "Selected services",
    ),
    "summarySubtitle": MessageLookupByLibrary.simpleMessage(
      "Review the details before confirming",
    ),
    "summaryTitle": MessageLookupByLibrary.simpleMessage("Booking summary"),
    "upcomingBookings": MessageLookupByLibrary.simpleMessage("Upcoming"),
    "validationInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Invalid email",
    ),
    "validationInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Invalid phone",
    ),
    "validationRequired": MessageLookupByLibrary.simpleMessage(
      "Required field",
    ),
    "weekdayFri": MessageLookupByLibrary.simpleMessage("Fri"),
    "weekdayMon": MessageLookupByLibrary.simpleMessage("Mon"),
    "weekdaySat": MessageLookupByLibrary.simpleMessage("Sat"),
    "weekdaySun": MessageLookupByLibrary.simpleMessage("Sun"),
    "weekdayThu": MessageLookupByLibrary.simpleMessage("Thu"),
    "weekdayTue": MessageLookupByLibrary.simpleMessage("Tue"),
    "weekdayWed": MessageLookupByLibrary.simpleMessage("Wed"),
    "yes": MessageLookupByLibrary.simpleMessage("Yes"),
  };
}
--- FILE: lib/core/l10n/l10n.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'intl/messages_all.dart';

// **************************************************************************
// Generator: Flutter Intl IDE plugin
// Made by Localizely
// **************************************************************************

// ignore_for_file: non_constant_identifier_names, lines_longer_than_80_chars
// ignore_for_file: join_return_with_assignment, prefer_final_in_for_each
// ignore_for_file: avoid_redundant_argument_values, avoid_escaping_inner_quotes

class L10n {
  L10n();

  static L10n? _current;

  static L10n get current {
    assert(
      _current != null,
      'No instance of L10n was loaded. Try to initialize the L10n delegate before accessing L10n.current.',
    );
    return _current!;
  }

  static const AppLocalizationDelegate delegate = AppLocalizationDelegate();

  static Future<L10n> load(Locale locale) {
    final name = (locale.countryCode?.isEmpty ?? false)
        ? locale.languageCode
        : locale.toString();
    final localeName = Intl.canonicalizedLocale(name);
    return initializeMessages(localeName).then((_) {
      Intl.defaultLocale = localeName;
      final instance = L10n();
      L10n._current = instance;

      return instance;
    });
  }

  static L10n of(BuildContext context) {
    final instance = L10n.maybeOf(context);
    assert(
      instance != null,
      'No instance of L10n present in the widget tree. Did you add L10n.delegate in localizationsDelegates?',
    );
    return instance!;
  }

  static L10n? maybeOf(BuildContext context) {
    return Localizations.of<L10n>(context, L10n);
  }

  /// `Prenota Online`
  String get appTitle {
    return Intl.message('Prenota Online', name: 'appTitle', desc: '', args: []);
  }

  /// `Indietro`
  String get actionBack {
    return Intl.message('Indietro', name: 'actionBack', desc: '', args: []);
  }

  /// `Avanti`
  String get actionNext {
    return Intl.message('Avanti', name: 'actionNext', desc: '', args: []);
  }

  /// `Conferma`
  String get actionConfirm {
    return Intl.message('Conferma', name: 'actionConfirm', desc: '', args: []);
  }

  /// `Annulla`
  String get actionCancel {
    return Intl.message('Annulla', name: 'actionCancel', desc: '', args: []);
  }

  /// `Chiudi`
  String get actionClose {
    return Intl.message('Chiudi', name: 'actionClose', desc: '', args: []);
  }

  /// `Riprova`
  String get actionRetry {
    return Intl.message('Riprova', name: 'actionRetry', desc: '', args: []);
  }

  /// `Accedi`
  String get actionLogin {
    return Intl.message('Accedi', name: 'actionLogin', desc: '', args: []);
  }

  /// `Registrati`
  String get actionRegister {
    return Intl.message(
      'Registrati',
      name: 'actionRegister',
      desc: '',
      args: [],
    );
  }

  /// `Esci`
  String get actionLogout {
    return Intl.message('Esci', name: 'actionLogout', desc: '', args: []);
  }

  /// `Errore`
  String get errorTitle {
    return Intl.message('Errore', name: 'errorTitle', desc: '', args: []);
  }

  /// `Si √® verificato un errore`
  String get errorGeneric {
    return Intl.message(
      'Si √® verificato un errore',
      name: 'errorGeneric',
      desc: '',
      args: [],
    );
  }

  /// `Pagina non trovata: {path}`
  String errorNotFound(String path) {
    return Intl.message(
      'Pagina non trovata: $path',
      name: 'errorNotFound',
      desc: '',
      args: [path],
    );
  }

  /// `Nessuna disponibilit√† per la data selezionata`
  String get errorNoAvailability {
    return Intl.message(
      'Nessuna disponibilit√† per la data selezionata',
      name: 'errorNoAvailability',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile caricare i servizi. Verifica la connessione e riprova.`
  String get errorLoadingServices {
    return Intl.message(
      'Impossibile caricare i servizi. Verifica la connessione e riprova.',
      name: 'errorLoadingServices',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile caricare gli operatori. Verifica la connessione e riprova.`
  String get errorLoadingStaff {
    return Intl.message(
      'Impossibile caricare gli operatori. Verifica la connessione e riprova.',
      name: 'errorLoadingStaff',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile caricare le disponibilit√†. Verifica la connessione e riprova.`
  String get errorLoadingAvailability {
    return Intl.message(
      'Impossibile caricare le disponibilit√†. Verifica la connessione e riprova.',
      name: 'errorLoadingAvailability',
      desc: '',
      args: [],
    );
  }

  /// `Nessun servizio disponibile al momento`
  String get servicesEmpty {
    return Intl.message(
      'Nessun servizio disponibile al momento',
      name: 'servicesEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Non ci sono servizi prenotabili online per questa attivit√†`
  String get servicesEmptySubtitle {
    return Intl.message(
      'Non ci sono servizi prenotabili online per questa attivit√†',
      name: 'servicesEmptySubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessun operatore disponibile al momento`
  String get staffEmpty {
    return Intl.message(
      'Nessun operatore disponibile al momento',
      name: 'staffEmpty',
      desc: '',
      args: [],
    );
  }

  /// `La connessione sta impiegando troppo tempo. Riprova.`
  String get errorConnectionTimeout {
    return Intl.message(
      'La connessione sta impiegando troppo tempo. Riprova.',
      name: 'errorConnectionTimeout',
      desc: '',
      args: [],
    );
  }

  /// `Attivit√† non trovata`
  String get errorBusinessNotFound {
    return Intl.message(
      'Attivit√† non trovata',
      name: 'errorBusinessNotFound',
      desc: '',
      args: [],
    );
  }

  /// `L'attivit√† richiesta non esiste. Verifica l'indirizzo o contatta direttamente l'attivit√†.`
  String get errorBusinessNotFoundSubtitle {
    return Intl.message(
      'L\'attivit√† richiesta non esiste. Verifica l\'indirizzo o contatta direttamente l\'attivit√†.',
      name: 'errorBusinessNotFoundSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Attivit√† non attiva`
  String get errorBusinessNotActive {
    return Intl.message(
      'Attivit√† non attiva',
      name: 'errorBusinessNotActive',
      desc: '',
      args: [],
    );
  }

  /// `Questa attivit√† non √® ancora configurata per le prenotazioni online. Contatta direttamente l'attivit√†.`
  String get errorBusinessNotActiveSubtitle {
    return Intl.message(
      'Questa attivit√† non √® ancora configurata per le prenotazioni online. Contatta direttamente l\'attivit√†.',
      name: 'errorBusinessNotActiveSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Sede non disponibile`
  String get errorLocationNotFound {
    return Intl.message(
      'Sede non disponibile',
      name: 'errorLocationNotFound',
      desc: '',
      args: [],
    );
  }

  /// `La sede selezionata non √® attiva. Contatta l'attivit√† per maggiori informazioni.`
  String get errorLocationNotFoundSubtitle {
    return Intl.message(
      'La sede selezionata non √® attiva. Contatta l\'attivit√† per maggiori informazioni.',
      name: 'errorLocationNotFoundSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Servizio temporaneamente non disponibile`
  String get errorServiceUnavailable {
    return Intl.message(
      'Servizio temporaneamente non disponibile',
      name: 'errorServiceUnavailable',
      desc: '',
      args: [],
    );
  }

  /// `Stiamo lavorando per risolvere il problema. Riprova tra qualche minuto.`
  String get errorServiceUnavailableSubtitle {
    return Intl.message(
      'Stiamo lavorando per risolvere il problema. Riprova tra qualche minuto.',
      name: 'errorServiceUnavailableSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Benvenuto`
  String get authWelcome {
    return Intl.message('Benvenuto', name: 'authWelcome', desc: '', args: []);
  }

  /// `Accedi al tuo account`
  String get authLoginTitle {
    return Intl.message(
      'Accedi al tuo account',
      name: 'authLoginTitle',
      desc: '',
      args: [],
    );
  }

  /// `Crea un nuovo account`
  String get authRegisterTitle {
    return Intl.message(
      'Crea un nuovo account',
      name: 'authRegisterTitle',
      desc: '',
      args: [],
    );
  }

  /// `Email`
  String get authEmail {
    return Intl.message('Email', name: 'authEmail', desc: '', args: []);
  }

  /// `Password`
  String get authPassword {
    return Intl.message('Password', name: 'authPassword', desc: '', args: []);
  }

  /// `Conferma password`
  String get authConfirmPassword {
    return Intl.message(
      'Conferma password',
      name: 'authConfirmPassword',
      desc: '',
      args: [],
    );
  }

  /// `Nome`
  String get authFirstName {
    return Intl.message('Nome', name: 'authFirstName', desc: '', args: []);
  }

  /// `Cognome`
  String get authLastName {
    return Intl.message('Cognome', name: 'authLastName', desc: '', args: []);
  }

  /// `Telefono`
  String get authPhone {
    return Intl.message('Telefono', name: 'authPhone', desc: '', args: []);
  }

  /// `Password dimenticata?`
  String get authForgotPassword {
    return Intl.message(
      'Password dimenticata?',
      name: 'authForgotPassword',
      desc: '',
      args: [],
    );
  }

  /// `Non hai un account?`
  String get authNoAccount {
    return Intl.message(
      'Non hai un account?',
      name: 'authNoAccount',
      desc: '',
      args: [],
    );
  }

  /// `Hai gi√† un account?`
  String get authHaveAccount {
    return Intl.message(
      'Hai gi√† un account?',
      name: 'authHaveAccount',
      desc: '',
      args: [],
    );
  }

  /// `Email non valida`
  String get authInvalidEmail {
    return Intl.message(
      'Email non valida',
      name: 'authInvalidEmail',
      desc: '',
      args: [],
    );
  }

  /// `Password troppo corta (min. 6 caratteri)`
  String get authInvalidPassword {
    return Intl.message(
      'Password troppo corta (min. 6 caratteri)',
      name: 'authInvalidPassword',
      desc: '',
      args: [],
    );
  }

  /// `Le password non coincidono`
  String get authPasswordMismatch {
    return Intl.message(
      'Le password non coincidono',
      name: 'authPasswordMismatch',
      desc: '',
      args: [],
    );
  }

  /// `Campo obbligatorio`
  String get authRequiredField {
    return Intl.message(
      'Campo obbligatorio',
      name: 'authRequiredField',
      desc: '',
      args: [],
    );
  }

  /// `Numero di telefono non valido`
  String get authInvalidPhone {
    return Intl.message(
      'Numero di telefono non valido',
      name: 'authInvalidPhone',
      desc: '',
      args: [],
    );
  }

  /// `Accesso effettuato`
  String get authLoginSuccess {
    return Intl.message(
      'Accesso effettuato',
      name: 'authLoginSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Registrazione completata`
  String get authRegisterSuccess {
    return Intl.message(
      'Registrazione completata',
      name: 'authRegisterSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Credenziali non valide`
  String get authLoginFailed {
    return Intl.message(
      'Credenziali non valide',
      name: 'authLoginFailed',
      desc: '',
      args: [],
    );
  }

  /// `Registrazione fallita`
  String get authRegisterFailed {
    return Intl.message(
      'Registrazione fallita',
      name: 'authRegisterFailed',
      desc: '',
      args: [],
    );
  }

  /// `Recupera password`
  String get authResetPasswordTitle {
    return Intl.message(
      'Recupera password',
      name: 'authResetPasswordTitle',
      desc: '',
      args: [],
    );
  }

  /// `Inserisci la tua email e ti invieremo le istruzioni per reimpostare la password.`
  String get authResetPasswordMessage {
    return Intl.message(
      'Inserisci la tua email e ti invieremo le istruzioni per reimpostare la password.',
      name: 'authResetPasswordMessage',
      desc: '',
      args: [],
    );
  }

  /// `Invia`
  String get authResetPasswordSend {
    return Intl.message(
      'Invia',
      name: 'authResetPasswordSend',
      desc: '',
      args: [],
    );
  }

  /// `Email inviata! Controlla la tua casella di posta.`
  String get authResetPasswordSuccess {
    return Intl.message(
      'Email inviata! Controlla la tua casella di posta.',
      name: 'authResetPasswordSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Errore durante l'invio. Riprova.`
  String get authResetPasswordError {
    return Intl.message(
      'Errore durante l\'invio. Riprova.',
      name: 'authResetPasswordError',
      desc: '',
      args: [],
    );
  }

  /// `Reimposta password`
  String get authResetPasswordConfirmTitle {
    return Intl.message(
      'Reimposta password',
      name: 'authResetPasswordConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `Inserisci la nuova password`
  String get authResetPasswordConfirmMessage {
    return Intl.message(
      'Inserisci la nuova password',
      name: 'authResetPasswordConfirmMessage',
      desc: '',
      args: [],
    );
  }

  /// `Nuova password`
  String get authNewPassword {
    return Intl.message(
      'Nuova password',
      name: 'authNewPassword',
      desc: '',
      args: [],
    );
  }

  /// `Password reimpostata con successo!`
  String get authResetPasswordConfirmSuccess {
    return Intl.message(
      'Password reimpostata con successo!',
      name: 'authResetPasswordConfirmSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Token non valido o scaduto`
  String get authResetPasswordConfirmError {
    return Intl.message(
      'Token non valido o scaduto',
      name: 'authResetPasswordConfirmError',
      desc: '',
      args: [],
    );
  }

  /// `Cambia password`
  String get authChangePasswordTitle {
    return Intl.message(
      'Cambia password',
      name: 'authChangePasswordTitle',
      desc: '',
      args: [],
    );
  }

  /// `Password attuale`
  String get authCurrentPassword {
    return Intl.message(
      'Password attuale',
      name: 'authCurrentPassword',
      desc: '',
      args: [],
    );
  }

  /// `Password modificata con successo`
  String get authChangePasswordSuccess {
    return Intl.message(
      'Password modificata con successo',
      name: 'authChangePasswordSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Password attuale non corretta`
  String get authChangePasswordError {
    return Intl.message(
      'Password attuale non corretta',
      name: 'authChangePasswordError',
      desc: '',
      args: [],
    );
  }

  /// `Password troppo corta (min. 8 caratteri)`
  String get authPasswordTooShort {
    return Intl.message(
      'Password troppo corta (min. 8 caratteri)',
      name: 'authPasswordTooShort',
      desc: '',
      args: [],
    );
  }

  /// `La password deve contenere: maiuscola, minuscola, numero`
  String get authPasswordRequirements {
    return Intl.message(
      'La password deve contenere: maiuscola, minuscola, numero',
      name: 'authPasswordRequirements',
      desc: '',
      args: [],
    );
  }

  /// `Cambia password`
  String get authChangePassword {
    return Intl.message(
      'Cambia password',
      name: 'authChangePassword',
      desc: '',
      args: [],
    );
  }

  /// `Profilo`
  String get profileTitle {
    return Intl.message('Profilo', name: 'profileTitle', desc: '', args: []);
  }

  /// `Prenota appuntamento`
  String get bookingTitle {
    return Intl.message(
      'Prenota appuntamento',
      name: 'bookingTitle',
      desc: '',
      args: [],
    );
  }

  /// `Sede`
  String get bookingStepLocation {
    return Intl.message(
      'Sede',
      name: 'bookingStepLocation',
      desc: '',
      args: [],
    );
  }

  /// `Servizi`
  String get bookingStepServices {
    return Intl.message(
      'Servizi',
      name: 'bookingStepServices',
      desc: '',
      args: [],
    );
  }

  /// `Operatore`
  String get bookingStepStaff {
    return Intl.message(
      'Operatore',
      name: 'bookingStepStaff',
      desc: '',
      args: [],
    );
  }

  /// `Data e ora`
  String get bookingStepDateTime {
    return Intl.message(
      'Data e ora',
      name: 'bookingStepDateTime',
      desc: '',
      args: [],
    );
  }

  /// `Riepilogo`
  String get bookingStepSummary {
    return Intl.message(
      'Riepilogo',
      name: 'bookingStepSummary',
      desc: '',
      args: [],
    );
  }

  /// `Scegli la sede`
  String get locationTitle {
    return Intl.message(
      'Scegli la sede',
      name: 'locationTitle',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona dove vuoi effettuare la prenotazione`
  String get locationSubtitle {
    return Intl.message(
      'Seleziona dove vuoi effettuare la prenotazione',
      name: 'locationSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessuna sede disponibile`
  String get locationEmpty {
    return Intl.message(
      'Nessuna sede disponibile',
      name: 'locationEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Scegli i servizi`
  String get servicesTitle {
    return Intl.message(
      'Scegli i servizi',
      name: 'servicesTitle',
      desc: '',
      args: [],
    );
  }

  /// `Puoi selezionare uno o pi√π servizi`
  String get servicesSubtitle {
    return Intl.message(
      'Puoi selezionare uno o pi√π servizi',
      name: 'servicesSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `{count, plural, =0{Nessun servizio selezionato} =1{1 servizio selezionato} other{{count} servizi selezionati}}`
  String servicesSelected(int count) {
    return Intl.plural(
      count,
      zero: 'Nessun servizio selezionato',
      one: '1 servizio selezionato',
      other: '$count servizi selezionati',
      name: 'servicesSelected',
      desc: '',
      args: [count],
    );
  }

  /// `Totale: {total}`
  String servicesTotal(String total) {
    return Intl.message(
      'Totale: $total',
      name: 'servicesTotal',
      desc: '',
      args: [total],
    );
  }

  /// `{duration} min`
  String servicesDuration(int duration) {
    return Intl.message(
      '$duration min',
      name: 'servicesDuration',
      desc: '',
      args: [duration],
    );
  }

  /// `Gratis`
  String get servicesFree {
    return Intl.message('Gratis', name: 'servicesFree', desc: '', args: []);
  }

  /// `da {price}`
  String servicesPriceFrom(String price) {
    return Intl.message(
      'da $price',
      name: 'servicesPriceFrom',
      desc: '',
      args: [price],
    );
  }

  /// `Scegli l'operatore`
  String get staffTitle {
    return Intl.message(
      'Scegli l\'operatore',
      name: 'staffTitle',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona con chi desideri essere servito`
  String get staffSubtitle {
    return Intl.message(
      'Seleziona con chi desideri essere servito',
      name: 'staffSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Qualsiasi operatore disponibile`
  String get staffAnyOperator {
    return Intl.message(
      'Qualsiasi operatore disponibile',
      name: 'staffAnyOperator',
      desc: '',
      args: [],
    );
  }

  /// `Ti assegneremo il primo operatore libero`
  String get staffAnyOperatorSubtitle {
    return Intl.message(
      'Ti assegneremo il primo operatore libero',
      name: 'staffAnyOperatorSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Scegli data e ora`
  String get dateTimeTitle {
    return Intl.message(
      'Scegli data e ora',
      name: 'dateTimeTitle',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona quando desideri prenotare`
  String get dateTimeSubtitle {
    return Intl.message(
      'Seleziona quando desideri prenotare',
      name: 'dateTimeSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Prima disponibilit√†: {date}`
  String dateTimeFirstAvailable(String date) {
    return Intl.message(
      'Prima disponibilit√†: $date',
      name: 'dateTimeFirstAvailable',
      desc: '',
      args: [date],
    );
  }

  /// `Nessun orario disponibile per questa data`
  String get dateTimeNoSlots {
    return Intl.message(
      'Nessun orario disponibile per questa data',
      name: 'dateTimeNoSlots',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona una data`
  String get dateTimeSelectDate {
    return Intl.message(
      'Seleziona una data',
      name: 'dateTimeSelectDate',
      desc: '',
      args: [],
    );
  }

  /// `Mattina`
  String get dateTimeMorning {
    return Intl.message('Mattina', name: 'dateTimeMorning', desc: '', args: []);
  }

  /// `Pomeriggio`
  String get dateTimeAfternoon {
    return Intl.message(
      'Pomeriggio',
      name: 'dateTimeAfternoon',
      desc: '',
      args: [],
    );
  }

  /// `Sera`
  String get dateTimeEvening {
    return Intl.message('Sera', name: 'dateTimeEvening', desc: '', args: []);
  }

  /// `Riepilogo prenotazione`
  String get summaryTitle {
    return Intl.message(
      'Riepilogo prenotazione',
      name: 'summaryTitle',
      desc: '',
      args: [],
    );
  }

  /// `Controlla i dettagli prima di confermare`
  String get summarySubtitle {
    return Intl.message(
      'Controlla i dettagli prima di confermare',
      name: 'summarySubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Servizi selezionati`
  String get summaryServices {
    return Intl.message(
      'Servizi selezionati',
      name: 'summaryServices',
      desc: '',
      args: [],
    );
  }

  /// `Operatore`
  String get summaryOperator {
    return Intl.message(
      'Operatore',
      name: 'summaryOperator',
      desc: '',
      args: [],
    );
  }

  /// `Data e ora`
  String get summaryDateTime {
    return Intl.message(
      'Data e ora',
      name: 'summaryDateTime',
      desc: '',
      args: [],
    );
  }

  /// `Durata totale`
  String get summaryDuration {
    return Intl.message(
      'Durata totale',
      name: 'summaryDuration',
      desc: '',
      args: [],
    );
  }

  /// `Prezzo totale`
  String get summaryPrice {
    return Intl.message(
      'Prezzo totale',
      name: 'summaryPrice',
      desc: '',
      args: [],
    );
  }

  /// `Note (opzionale)`
  String get summaryNotes {
    return Intl.message(
      'Note (opzionale)',
      name: 'summaryNotes',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi eventuali note per l'appuntamento...`
  String get summaryNotesHint {
    return Intl.message(
      'Aggiungi eventuali note per l\'appuntamento...',
      name: 'summaryNotesHint',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione confermata!`
  String get confirmationTitle {
    return Intl.message(
      'Prenotazione confermata!',
      name: 'confirmationTitle',
      desc: '',
      args: [],
    );
  }

  /// `Ti abbiamo inviato un'email di conferma`
  String get confirmationSubtitle {
    return Intl.message(
      'Ti abbiamo inviato un\'email di conferma',
      name: 'confirmationSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Codice prenotazione: {id}`
  String confirmationBookingId(String id) {
    return Intl.message(
      'Codice prenotazione: $id',
      name: 'confirmationBookingId',
      desc: '',
      args: [id],
    );
  }

  /// `Nuova prenotazione`
  String get confirmationNewBooking {
    return Intl.message(
      'Nuova prenotazione',
      name: 'confirmationNewBooking',
      desc: '',
      args: [],
    );
  }

  /// `Torna alla home`
  String get confirmationGoHome {
    return Intl.message(
      'Torna alla home',
      name: 'confirmationGoHome',
      desc: '',
      args: [],
    );
  }

  /// `{minutes} min`
  String durationMinutes(int minutes) {
    return Intl.message(
      '$minutes min',
      name: 'durationMinutes',
      desc: '',
      args: [minutes],
    );
  }

  /// `{minutes} min`
  String durationMinute(int minutes) {
    return Intl.message(
      '$minutes min',
      name: 'durationMinute',
      desc: '',
      args: [minutes],
    );
  }

  /// `{hours} ora`
  String durationHour(int hours) {
    return Intl.message(
      '$hours ora',
      name: 'durationHour',
      desc: '',
      args: [hours],
    );
  }

  /// `{hours} ora {minutes} min`
  String durationHourMinute(int hours, int minutes) {
    return Intl.message(
      '$hours ora $minutes min',
      name: 'durationHourMinute',
      desc: '',
      args: [hours, minutes],
    );
  }

  /// `‚Ç¨{price}`
  String priceFormat(String price) {
    return Intl.message(
      '‚Ç¨$price',
      name: 'priceFormat',
      desc: '',
      args: [price],
    );
  }

  /// `Gennaio`
  String get monthJanuary {
    return Intl.message('Gennaio', name: 'monthJanuary', desc: '', args: []);
  }

  /// `Febbraio`
  String get monthFebruary {
    return Intl.message('Febbraio', name: 'monthFebruary', desc: '', args: []);
  }

  /// `Marzo`
  String get monthMarch {
    return Intl.message('Marzo', name: 'monthMarch', desc: '', args: []);
  }

  /// `Aprile`
  String get monthApril {
    return Intl.message('Aprile', name: 'monthApril', desc: '', args: []);
  }

  /// `Maggio`
  String get monthMay {
    return Intl.message('Maggio', name: 'monthMay', desc: '', args: []);
  }

  /// `Giugno`
  String get monthJune {
    return Intl.message('Giugno', name: 'monthJune', desc: '', args: []);
  }

  /// `Luglio`
  String get monthJuly {
    return Intl.message('Luglio', name: 'monthJuly', desc: '', args: []);
  }

  /// `Agosto`
  String get monthAugust {
    return Intl.message('Agosto', name: 'monthAugust', desc: '', args: []);
  }

  /// `Settembre`
  String get monthSeptember {
    return Intl.message(
      'Settembre',
      name: 'monthSeptember',
      desc: '',
      args: [],
    );
  }

  /// `Ottobre`
  String get monthOctober {
    return Intl.message('Ottobre', name: 'monthOctober', desc: '', args: []);
  }

  /// `Novembre`
  String get monthNovember {
    return Intl.message('Novembre', name: 'monthNovember', desc: '', args: []);
  }

  /// `Dicembre`
  String get monthDecember {
    return Intl.message('Dicembre', name: 'monthDecember', desc: '', args: []);
  }

  /// `Lun`
  String get weekdayMon {
    return Intl.message('Lun', name: 'weekdayMon', desc: '', args: []);
  }

  /// `Mar`
  String get weekdayTue {
    return Intl.message('Mar', name: 'weekdayTue', desc: '', args: []);
  }

  /// `Mer`
  String get weekdayWed {
    return Intl.message('Mer', name: 'weekdayWed', desc: '', args: []);
  }

  /// `Gio`
  String get weekdayThu {
    return Intl.message('Gio', name: 'weekdayThu', desc: '', args: []);
  }

  /// `Ven`
  String get weekdayFri {
    return Intl.message('Ven', name: 'weekdayFri', desc: '', args: []);
  }

  /// `Sab`
  String get weekdaySat {
    return Intl.message('Sab', name: 'weekdaySat', desc: '', args: []);
  }

  /// `Dom`
  String get weekdaySun {
    return Intl.message('Dom', name: 'weekdaySun', desc: '', args: []);
  }

  /// `Le mie prenotazioni`
  String get myBookings {
    return Intl.message(
      'Le mie prenotazioni',
      name: 'myBookings',
      desc: '',
      args: [],
    );
  }

  /// `Prossime`
  String get upcomingBookings {
    return Intl.message(
      'Prossime',
      name: 'upcomingBookings',
      desc: '',
      args: [],
    );
  }

  /// `Passate`
  String get pastBookings {
    return Intl.message('Passate', name: 'pastBookings', desc: '', args: []);
  }

  /// `Non hai prenotazioni in programma`
  String get noUpcomingBookings {
    return Intl.message(
      'Non hai prenotazioni in programma',
      name: 'noUpcomingBookings',
      desc: '',
      args: [],
    );
  }

  /// `Non hai prenotazioni passate`
  String get noPastBookings {
    return Intl.message(
      'Non hai prenotazioni passate',
      name: 'noPastBookings',
      desc: '',
      args: [],
    );
  }

  /// `Errore nel caricamento delle prenotazioni`
  String get errorLoadingBookings {
    return Intl.message(
      'Errore nel caricamento delle prenotazioni',
      name: 'errorLoadingBookings',
      desc: '',
      args: [],
    );
  }

  /// `Modificabile`
  String get modifiable {
    return Intl.message('Modificabile', name: 'modifiable', desc: '', args: []);
  }

  /// `Non modificabile`
  String get notModifiable {
    return Intl.message(
      'Non modificabile',
      name: 'notModifiable',
      desc: '',
      args: [],
    );
  }

  /// `{days, plural, =1{Modificabile fino a domani} other{Modificabile fino a {days} giorni}}`
  String modifiableUntilDays(int days) {
    return Intl.plural(
      days,
      one: 'Modificabile fino a domani',
      other: 'Modificabile fino a $days giorni',
      name: 'modifiableUntilDays',
      desc: '',
      args: [days],
    );
  }

  /// `{hours, plural, =1{Modificabile fino a 1 ora} other{Modificabile fino a {hours} ore}}`
  String modifiableUntilHours(int hours) {
    return Intl.plural(
      hours,
      one: 'Modificabile fino a 1 ora',
      other: 'Modificabile fino a $hours ore',
      name: 'modifiableUntilHours',
      desc: '',
      args: [hours],
    );
  }

  /// `{minutes, plural, =1{Modificabile fino a 1 minuto} other{Modificabile fino a {minutes} minuti}}`
  String modifiableUntilMinutes(int minutes) {
    return Intl.plural(
      minutes,
      one: 'Modificabile fino a 1 minuto',
      other: 'Modificabile fino a $minutes minuti',
      name: 'modifiableUntilMinutes',
      desc: '',
      args: [minutes],
    );
  }

  /// `Modifica`
  String get modify {
    return Intl.message('Modifica', name: 'modify', desc: '', args: []);
  }

  /// `Annulla`
  String get cancel {
    return Intl.message('Annulla', name: 'cancel', desc: '', args: []);
  }

  /// `S√¨`
  String get yes {
    return Intl.message('S√¨', name: 'yes', desc: '', args: []);
  }

  /// `No`
  String get no {
    return Intl.message('No', name: 'no', desc: '', args: []);
  }

  /// `Annulla prenotazione`
  String get cancelBookingTitle {
    return Intl.message(
      'Annulla prenotazione',
      name: 'cancelBookingTitle',
      desc: '',
      args: [],
    );
  }

  /// `Sei sicuro di voler annullare questa prenotazione?`
  String get cancelBookingConfirm {
    return Intl.message(
      'Sei sicuro di voler annullare questa prenotazione?',
      name: 'cancelBookingConfirm',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione annullata con successo`
  String get bookingCancelled {
    return Intl.message(
      'Prenotazione annullata con successo',
      name: 'bookingCancelled',
      desc: '',
      args: [],
    );
  }

  /// `Errore durante l'annullamento`
  String get bookingCancelFailed {
    return Intl.message(
      'Errore durante l\'annullamento',
      name: 'bookingCancelFailed',
      desc: '',
      args: [],
    );
  }

  /// `Funzione di modifica in sviluppo`
  String get modifyNotImplemented {
    return Intl.message(
      'Funzione di modifica in sviluppo',
      name: 'modifyNotImplemented',
      desc: '',
      args: [],
    );
  }

  /// `Riprogramma prenotazione`
  String get rescheduleBookingTitle {
    return Intl.message(
      'Riprogramma prenotazione',
      name: 'rescheduleBookingTitle',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione attuale`
  String get currentBooking {
    return Intl.message(
      'Prenotazione attuale',
      name: 'currentBooking',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona nuova data`
  String get selectNewDate {
    return Intl.message(
      'Seleziona nuova data',
      name: 'selectNewDate',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona data`
  String get selectDate {
    return Intl.message(
      'Seleziona data',
      name: 'selectDate',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona nuovo orario`
  String get selectNewTime {
    return Intl.message(
      'Seleziona nuovo orario',
      name: 'selectNewTime',
      desc: '',
      args: [],
    );
  }

  /// `Conferma modifica`
  String get confirmReschedule {
    return Intl.message(
      'Conferma modifica',
      name: 'confirmReschedule',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione riprogrammata con successo`
  String get bookingRescheduled {
    return Intl.message(
      'Prenotazione riprogrammata con successo',
      name: 'bookingRescheduled',
      desc: '',
      args: [],
    );
  }

  /// `Campo obbligatorio`
  String get validationRequired {
    return Intl.message(
      'Campo obbligatorio',
      name: 'validationRequired',
      desc: '',
      args: [],
    );
  }

  /// `Email non valida`
  String get validationInvalidEmail {
    return Intl.message(
      'Email non valida',
      name: 'validationInvalidEmail',
      desc: '',
      args: [],
    );
  }

  /// `Telefono non valido`
  String get validationInvalidPhone {
    return Intl.message(
      'Telefono non valido',
      name: 'validationInvalidPhone',
      desc: '',
      args: [],
    );
  }

  /// `Attivit√† non trovata`
  String get businessNotFound {
    return Intl.message(
      'Attivit√† non trovata',
      name: 'businessNotFound',
      desc: '',
      args: [],
    );
  }

  /// `Verifica l'indirizzo o contatta direttamente l'attivit√†.`
  String get businessNotFoundHint {
    return Intl.message(
      'Verifica l\'indirizzo o contatta direttamente l\'attivit√†.',
      name: 'businessNotFoundHint',
      desc: '',
      args: [],
    );
  }
}

class AppLocalizationDelegate extends LocalizationsDelegate<L10n> {
  const AppLocalizationDelegate();

  List<Locale> get supportedLocales {
    return const <Locale>[
      Locale.fromSubtags(languageCode: 'it'),
      Locale.fromSubtags(languageCode: 'en'),
    ];
  }

  @override
  bool isSupported(Locale locale) => _isSupported(locale);
  @override
  Future<L10n> load(Locale locale) => L10n.load(locale);
  @override
  bool shouldReload(AppLocalizationDelegate old) => false;

  bool _isSupported(Locale locale) {
    for (var supportedLocale in supportedLocales) {
      if (supportedLocale.languageCode == locale.languageCode) {
        return true;
      }
    }
    return false;
  }
}
--- FILE: lib/core/network/token_storage_mobile.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

import 'token_storage_interface.dart';

/// Implementazione secure storage per mobile/desktop
class SecureTokenStorage implements TokenStorage {
  static const _refreshTokenKey = 'agenda_refresh_token';
  static const _businessIdKey = 'agenda_business_id';

  final FlutterSecureStorage _storage;

  SecureTokenStorage()
    : _storage = const FlutterSecureStorage(
        aOptions: AndroidOptions(encryptedSharedPreferences: true),
        iOptions: IOSOptions(accessibility: KeychainAccessibility.first_unlock),
      );

  @override
  Future<String?> getRefreshToken() async {
    try {
      return await _storage.read(key: _refreshTokenKey);
    } catch (e) {
      debugPrint('TokenStorage: Error reading token: $e');
      return null;
    }
  }

  @override
  Future<void> saveRefreshToken(String token) async {
    try {
      await _storage.write(key: _refreshTokenKey, value: token);
    } catch (e) {
      debugPrint('TokenStorage: Error saving token: $e');
    }
  }

  @override
  Future<void> clearRefreshToken() async {
    try {
      await _storage.delete(key: _refreshTokenKey);
    } catch (e) {
      debugPrint('TokenStorage: Error clearing token: $e');
    }
  }

  @override
  Future<int?> getBusinessId() async {
    try {
      final value = await _storage.read(key: _businessIdKey);
      return value != null ? int.tryParse(value) : null;
    } catch (e) {
      debugPrint('TokenStorage: Error reading businessId: $e');
      return null;
    }
  }

  @override
  Future<void> saveBusinessId(int businessId) async {
    try {
      await _storage.write(key: _businessIdKey, value: businessId.toString());
    } catch (e) {
      debugPrint('TokenStorage: Error saving businessId: $e');
    }
  }

  @override
  Future<void> clearBusinessId() async {
    try {
      await _storage.delete(key: _businessIdKey);
    } catch (e) {
      debugPrint('TokenStorage: Error clearing businessId: $e');
    }
  }
}

/// Factory per creare storage su mobile/desktop
TokenStorage createTokenStorage() => SecureTokenStorage();
--- FILE: lib/core/network/network_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'api_client.dart';
import 'token_storage.dart';

/// Provider per TokenStorage
final tokenStorageProvider = Provider<TokenStorage>((ref) {
  return createTokenStorage();
});

/// Provider per ApiClient
final apiClientProvider = Provider<ApiClient>((ref) {
  final tokenStorage = ref.watch(tokenStorageProvider);
  return ApiClient(tokenStorage: tokenStorage);
});
--- FILE: lib/core/network/api_config.dart ---
/// Configurazione API
class ApiConfig {
  /// Base URL dell'API - configurabile via environment
  /// Default: produzione (https://api.romeolab.it)
  /// Dev locale: --dart-define=API_BASE_URL=http://localhost:8888/agenda_core/public
  static const String baseUrl = String.fromEnvironment(
    'API_BASE_URL',
    defaultValue: 'https://api.romeolab.it',
  );

  /// Location ID di default (per MVP single-location)
  static const int defaultLocationId = 1;

  /// Timeout per le richieste (ridotti per risposta rapida)
  static const Duration connectTimeout = Duration(seconds: 5);
  static const Duration receiveTimeout = Duration(seconds: 5);

  // ========== CUSTOMER AUTH ENDPOINTS ==========
  // Usati dal frontend prenotazioni (agenda_frontend)
  // I clienti usano la tabella 'clients', non 'users'

  /// POST /v1/customer/{business_id}/auth/login
  static String customerLogin(int businessId) =>
      '/v1/customer/$businessId/auth/login';

  /// POST /v1/customer/{business_id}/auth/register
  static String customerRegister(int businessId) =>
      '/v1/customer/$businessId/auth/register';

  /// POST /v1/customer/{business_id}/auth/refresh
  static String customerRefresh(int businessId) =>
      '/v1/customer/$businessId/auth/refresh';

  /// POST /v1/customer/{business_id}/auth/logout
  static String customerLogout(int businessId) =>
      '/v1/customer/$businessId/auth/logout';

  /// POST /v1/customer/{business_id}/auth/forgot-password
  static String customerForgotPassword(int businessId) =>
      '/v1/customer/$businessId/auth/forgot-password';

  /// POST /v1/customer/auth/reset-password
  static const String customerResetPassword =
      '/v1/customer/auth/reset-password';

  /// GET /v1/customer/me
  static const String customerMe = '/v1/customer/me';

  /// PUT /v1/customer/me - Aggiorna profilo cliente
  static const String customerUpdateProfile = '/v1/customer/me';

  /// POST /v1/customer/me/change-password
  static const String customerChangePassword =
      '/v1/customer/me/change-password';

  /// GET /v1/customer/bookings
  static const String customerBookings = '/v1/customer/bookings';

  /// POST /v1/customer/{business_id}/bookings
  static String customerCreateBooking(int businessId) =>
      '/v1/customer/$businessId/bookings';

  // ========== LEGACY AUTH ENDPOINTS (DEPRECATI per frontend) ==========
  // Questi sono per OPERATORI (gestionale), non per clienti
  static const String authLogin = '/v1/auth/login';
  static const String authRegister = '/v1/auth/register';
  static const String authRefresh = '/v1/auth/refresh';
  static const String authLogout = '/v1/auth/logout';
  static const String authForgotPassword = '/v1/auth/forgot-password';
  static const String authResetPassword = '/v1/auth/reset-password';
  static const String authMe = '/v1/me';
  static const String meChangePassword = '/v1/me/change-password';
  static const String meBookings = '/v1/me/bookings';

  // ========== PUBLIC BROWSE ENDPOINTS ==========
  static const String services = '/v1/services';
  static const String staff = '/v1/staff';
  static const String availability = '/v1/availability';

  // ========== STAFF PLANNING ENDPOINTS (read-only) ==========
  /// GET /v1/staff/{id}/plannings - tutti i planning per uno staff
  static String staffPlannings(int staffId) => '/v1/staff/$staffId/plannings';

  /// GET /v1/staff/{id}/planning?date=YYYY-MM-DD - planning valido per data
  static String staffPlanningForDate(int staffId) =>
      '/v1/staff/$staffId/planning';

  /// GET /v1/staff/{id}/planning-availability?date=YYYY-MM-DD - slot disponibili per data
  static String staffPlanningAvailability(int staffId) =>
      '/v1/staff/$staffId/planning-availability';

  // ========== BUSINESS ENDPOINTS ==========
  /// Get business by slug (public, no auth required)
  static String businessBySlug(String slug) => '/v1/businesses/by-slug/$slug';

  /// Get locations for a business (public, no auth required)
  static String businessLocations(int businessId) =>
      '/v1/businesses/$businessId/locations/public';

  // ========== BOOKINGS ENDPOINTS (legacy, per operatori) ==========
  static String bookings(int locationId) =>
      '/v1/locations/$locationId/bookings';
}
--- FILE: lib/core/network/token_storage_web.dart ---
// ignore_for_file: avoid_web_libraries_in_flutter
import 'dart:html' as html;

import 'package:flutter/foundation.dart';

import 'token_storage_interface.dart';

/// Implementazione Web che usa localStorage
/// NOTA: In produzione si dovrebbe preferire cookie httpOnly server-side
class WebTokenStorage implements TokenStorage {
  static const _refreshTokenKey = 'agenda_refresh_token';
  static const _businessIdKey = 'agenda_business_id';

  @override
  Future<String?> getRefreshToken() async {
    try {
      return html.window.localStorage[_refreshTokenKey];
    } catch (e) {
      debugPrint('TokenStorage: Error reading token from localStorage: $e');
      return null;
    }
  }

  @override
  Future<void> saveRefreshToken(String token) async {
    try {
      html.window.localStorage[_refreshTokenKey] = token;
    } catch (e) {
      debugPrint('TokenStorage: Error saving token to localStorage: $e');
    }
  }

  @override
  Future<void> clearRefreshToken() async {
    try {
      html.window.localStorage.remove(_refreshTokenKey);
    } catch (e) {
      debugPrint('TokenStorage: Error clearing token from localStorage: $e');
    }
  }

  @override
  Future<int?> getBusinessId() async {
    try {
      final value = html.window.localStorage[_businessIdKey];
      return value != null ? int.tryParse(value) : null;
    } catch (e) {
      debugPrint(
        'TokenStorage: Error reading businessId from localStorage: $e',
      );
      return null;
    }
  }

  @override
  Future<void> saveBusinessId(int businessId) async {
    try {
      html.window.localStorage[_businessIdKey] = businessId.toString();
    } catch (e) {
      debugPrint('TokenStorage: Error saving businessId to localStorage: $e');
    }
  }

  @override
  Future<void> clearBusinessId() async {
    try {
      html.window.localStorage.remove(_businessIdKey);
    } catch (e) {
      debugPrint(
        'TokenStorage: Error clearing businessId from localStorage: $e',
      );
    }
  }
}

/// Factory per creare storage su Web
TokenStorage createTokenStorage() => WebTokenStorage();
--- FILE: lib/core/network/token_storage_interface.dart ---
/// Gestione storage per refresh token e business ID
/// - Web: localStorage (con considerazioni di sicurezza per production)
/// - Mobile: secure storage
abstract class TokenStorage {
  Future<String?> getRefreshToken();
  Future<void> saveRefreshToken(String token);
  Future<void> clearRefreshToken();

  /// Business ID per customer auth (necessario per refresh token)
  Future<int?> getBusinessId();
  Future<void> saveBusinessId(int businessId);
  Future<void> clearBusinessId();
}
--- FILE: lib/core/network/api_client.dart ---
import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';

import 'api_config.dart';
import 'token_storage.dart';

/// Eccezione API custom
class ApiException implements Exception {
  final String code;
  final String message;
  final int statusCode;
  final dynamic details;

  const ApiException({
    required this.code,
    required this.message,
    required this.statusCode,
    this.details,
  });

  bool get isUnauthorized => statusCode == 401;
  bool get isNotFound => statusCode == 404;
  bool get isConflict => statusCode == 409;
  bool get isSlotConflict => code == 'slot_conflict';
  bool get isServiceUnavailable =>
      statusCode == 503 || code == 'database_error';
  bool get isLocationNotFound =>
      isNotFound && message.toLowerCase().contains('location');
  bool get isBusinessNotFound =>
      isNotFound && message.toLowerCase().contains('business');

  @override
  String toString() => 'ApiException($code): $message';
}

/// Client HTTP per comunicare con agenda_core API
/// Usato dal frontend prenotazioni (agenda_frontend) per CLIENTI
class ApiClient {
  final Dio _dio;
  final TokenStorage _tokenStorage;

  String? _accessToken;

  /// Business ID corrente per refresh token
  /// Necessario perch√© l'endpoint di refresh √® business-scoped
  int? _currentBusinessId;

  ApiClient({required TokenStorage tokenStorage, Dio? dio})
    : _tokenStorage = tokenStorage,
      _dio = dio ?? Dio() {
    _dio.options.baseUrl = ApiConfig.baseUrl;
    _dio.options.connectTimeout = ApiConfig.connectTimeout;
    _dio.options.receiveTimeout = ApiConfig.receiveTimeout;
    _dio.options.headers['Content-Type'] = 'application/json';
    _dio.options.headers['Accept'] = 'application/json';

    // Interceptor per logging in debug
    if (kDebugMode) {
      _dio.interceptors.add(
        LogInterceptor(requestBody: true, responseBody: true),
      );
    }

    // Interceptor per auth token
    _dio.interceptors.add(
      InterceptorsWrapper(
        onRequest: (options, handler) {
          if (_accessToken != null) {
            options.headers['Authorization'] = 'Bearer $_accessToken';
          }
          handler.next(options);
        },
        onError: (error, handler) async {
          // Gestione token expired - auto refresh
          if (error.response?.statusCode == 401 &&
              error.response?.data?['error']?['code'] == 'token_expired') {
            try {
              final refreshed = await _refreshToken();
              if (refreshed) {
                // Riprova la richiesta originale
                final opts = error.requestOptions;
                opts.headers['Authorization'] = 'Bearer $_accessToken';
                final response = await _dio.fetch(opts);
                return handler.resolve(response);
              }
            } catch (_) {
              // Refresh fallito, propaga errore originale
            }
          }
          handler.next(error);
        },
      ),
    );
  }

  /// Imposta access token in memoria
  void setAccessToken(String? token) {
    _accessToken = token;
  }

  /// Imposta il business ID corrente (per refresh token)
  void setCurrentBusinessId(int? businessId) {
    _currentBusinessId = businessId;
  }

  /// Verifica se autenticato
  bool get isAuthenticated => _accessToken != null;

  /// Tenta refresh del token (customer)
  Future<bool> _refreshToken() async {
    final refreshToken = await _tokenStorage.getRefreshToken();
    if (refreshToken == null || _currentBusinessId == null) return false;

    try {
      final response = await _dio.post(
        ApiConfig.customerRefresh(_currentBusinessId!),
        data: {'refresh_token': refreshToken},
      );

      if (response.data['success'] == true) {
        final data = response.data['data'];
        _accessToken = data['access_token'];
        await _tokenStorage.saveRefreshToken(data['refresh_token']);
        return true;
      }
    } catch (_) {
      // Token non valido, pulisci storage
      await _tokenStorage.clearRefreshToken();
    }
    return false;
  }

  /// Tenta di ripristinare sessione da refresh token (customer)
  /// Richiede businessId per chiamare l'endpoint corretto
  Future<Map<String, dynamic>?> tryRestoreSession({int? businessId}) async {
    final refreshToken = await _tokenStorage.getRefreshToken();
    if (refreshToken == null) return null;

    // Usa il businessId passato o quello salvato
    final effectiveBusinessId = businessId ?? _currentBusinessId;
    if (effectiveBusinessId == null) return null;

    try {
      final response = await _dio.post(
        ApiConfig.customerRefresh(effectiveBusinessId),
        data: {'refresh_token': refreshToken},
      );

      if (response.data['success'] == true) {
        final data = response.data['data'];
        _accessToken = data['access_token'];
        _currentBusinessId = effectiveBusinessId;
        await _tokenStorage.saveRefreshToken(data['refresh_token']);

        // Fetch customer profile
        return await getCustomerMe();
      }
    } catch (_) {
      await _tokenStorage.clearRefreshToken();
    }
    return null;
  }

  /// Esegue richiesta GET
  Future<Map<String, dynamic>> get(
    String path, {
    Map<String, dynamic>? queryParameters,
  }) async {
    try {
      final response = await _dio.get(path, queryParameters: queryParameters);
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Esegue richiesta POST
  Future<Map<String, dynamic>> post(
    String path, {
    Map<String, dynamic>? data,
    Map<String, String>? headers,
  }) async {
    try {
      final response = await _dio.post(
        path,
        data: data,
        options: headers != null ? Options(headers: headers) : null,
      );
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Esegue richiesta DELETE
  Future<Map<String, dynamic>> delete(
    String path, {
    Map<String, dynamic>? queryParameters,
  }) async {
    try {
      final response = await _dio.delete(
        path,
        queryParameters: queryParameters,
      );
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Esegue richiesta PUT
  Future<Map<String, dynamic>> put(
    String path, {
    Map<String, dynamic>? data,
  }) async {
    try {
      final response = await _dio.put(path, data: data);
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Gestisce risposta API
  Map<String, dynamic> _handleResponse(Response response) {
    final body = response.data as Map<String, dynamic>;
    if (body['success'] == true) {
      return body['data'] as Map<String, dynamic>? ?? {};
    }
    throw ApiException(
      code: body['error']?['code'] ?? 'unknown_error',
      message: body['error']?['message'] ?? 'Unknown error',
      statusCode: response.statusCode ?? 500,
      details: body['error']?['details'],
    );
  }

  /// Gestisce errori Dio
  ApiException _handleError(DioException error) {
    final response = error.response;
    if (response != null) {
      final body = response.data;
      if (body is Map<String, dynamic>) {
        return ApiException(
          code: body['error']?['code'] ?? 'api_error',
          message: body['error']?['message'] ?? error.message ?? 'API Error',
          statusCode: response.statusCode ?? 500,
          details: body['error']?['details'],
        );
      }
    }
    return ApiException(
      code: 'network_error',
      message: error.message ?? 'Network error',
      statusCode: error.response?.statusCode ?? 0,
    );
  }

  // ========== CUSTOMER AUTH ENDPOINTS ==========
  // Usati dal frontend prenotazioni per CLIENTI (tabella clients)

  /// POST /v1/customer/{business_id}/auth/login
  Future<Map<String, dynamic>> customerLogin({
    required int businessId,
    required String email,
    required String password,
  }) async {
    final data = await post(
      ApiConfig.customerLogin(businessId),
      data: {'email': email, 'password': password},
    );

    _accessToken = data['access_token'];
    _currentBusinessId = businessId;
    await _tokenStorage.saveRefreshToken(data['refresh_token']);
    // Salva anche il business ID per restore session
    await _tokenStorage.saveBusinessId(businessId);

    return data;
  }

  /// POST /v1/customer/{business_id}/auth/register
  Future<Map<String, dynamic>> customerRegister({
    required int businessId,
    required String email,
    required String password,
    required String firstName,
    required String lastName,
    String? phone,
  }) async {
    final data = await post(
      ApiConfig.customerRegister(businessId),
      data: {
        'email': email,
        'password': password,
        'first_name': firstName,
        'last_name': lastName,
        if (phone != null) 'phone': phone,
      },
    );

    _accessToken = data['access_token'];
    _currentBusinessId = businessId;
    await _tokenStorage.saveRefreshToken(data['refresh_token']);
    await _tokenStorage.saveBusinessId(businessId);

    return data;
  }

  /// POST /v1/customer/{business_id}/auth/logout
  Future<void> customerLogout({required int businessId}) async {
    final refreshToken = await _tokenStorage.getRefreshToken();
    try {
      await post(
        ApiConfig.customerLogout(businessId),
        data: {'refresh_token': refreshToken},
      );
    } finally {
      _accessToken = null;
      _currentBusinessId = null;
      await _tokenStorage.clearRefreshToken();
      await _tokenStorage.clearBusinessId();
    }
  }

  /// POST /v1/customer/{business_id}/auth/forgot-password
  Future<void> customerForgotPassword({
    required int businessId,
    required String email,
  }) async {
    await post(
      ApiConfig.customerForgotPassword(businessId),
      data: {'email': email},
    );
  }

  /// POST /v1/customer/auth/reset-password
  Future<void> customerResetPassword({
    required String token,
    required String password,
  }) async {
    await post(
      ApiConfig.customerResetPassword,
      data: {'token': token, 'password': password},
    );
  }

  /// GET /v1/customer/me
  Future<Map<String, dynamic>> getCustomerMe() async {
    return get(ApiConfig.customerMe);
  }

  /// PUT /v1/customer/me - Aggiorna profilo cliente
  Future<Map<String, dynamic>> customerUpdateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
  }) async {
    final data = <String, dynamic>{};
    if (firstName != null) data['first_name'] = firstName;
    if (lastName != null) data['last_name'] = lastName;
    if (email != null) data['email'] = email;
    if (phone != null) data['phone'] = phone;

    return put(ApiConfig.customerUpdateProfile, data: data);
  }

  /// POST /v1/customer/me/change-password
  Future<void> customerChangePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    await post(
      ApiConfig.customerChangePassword,
      data: {'current_password': currentPassword, 'new_password': newPassword},
    );
  }

  /// GET /v1/customer/bookings
  Future<Map<String, dynamic>> getCustomerBookings() async {
    return get(ApiConfig.customerBookings);
  }

  /// POST /v1/customer/{business_id}/bookings
  Future<Map<String, dynamic>> createCustomerBooking({
    required int businessId,
    required String idempotencyKey,
    required List<int> serviceIds,
    required String startTime,
    int? staffId,
    String? notes,
  }) async {
    final data = <String, dynamic>{
      'service_ids': serviceIds,
      'start_time': startTime,
    };
    if (staffId != null) {
      data['staff_id'] = staffId;
    }
    if (notes != null && notes.isNotEmpty) {
      data['notes'] = notes;
    }

    return post(
      ApiConfig.customerCreateBooking(businessId),
      data: data,
      headers: {'X-Idempotency-Key': idempotencyKey},
    );
  }

  // ========== LEGACY AUTH ENDPOINTS (per operatori, non usare nel frontend) ==========

  /// POST /v1/auth/login (DEPRECATO - usare customerLogin)
  @Deprecated('Use customerLogin for frontend auth')
  Future<Map<String, dynamic>> login(String email, String password) async {
    final data = await post(
      ApiConfig.authLogin,
      data: {'email': email, 'password': password},
    );

    _accessToken = data['access_token'];
    await _tokenStorage.saveRefreshToken(data['refresh_token']);

    return data;
  }

  /// POST /v1/auth/logout (DEPRECATO - usare customerLogout)
  @Deprecated('Use customerLogout for frontend auth')
  Future<void> logout() async {
    final refreshToken = await _tokenStorage.getRefreshToken();
    try {
      await post(ApiConfig.authLogout, data: {'refresh_token': refreshToken});
    } finally {
      _accessToken = null;
      await _tokenStorage.clearRefreshToken();
    }
  }

  /// GET /v1/me
  Future<Map<String, dynamic>> getMe() async {
    return get(ApiConfig.authMe);
  }

  /// POST /v1/auth/register
  Future<Map<String, dynamic>> register({
    required String email,
    required String password,
    required String name,
    String? phone,
  }) async {
    final data = await post(
      ApiConfig.authRegister,
      data: {
        'email': email,
        'password': password,
        'name': name,
        if (phone != null) 'phone': phone,
      },
    );

    _accessToken = data['access_token'];
    await _tokenStorage.saveRefreshToken(data['refresh_token']);

    return data;
  }

  /// POST /v1/auth/forgot-password
  Future<void> forgotPassword({required String email}) async {
    await post(ApiConfig.authForgotPassword, data: {'email': email});
  }

  /// POST /v1/auth/reset-password
  Future<void> resetPasswordWithToken({
    required String token,
    required String password,
  }) async {
    await post(
      ApiConfig.authResetPassword,
      data: {'token': token, 'password': password},
    );
  }

  /// POST /v1/me/change-password
  Future<void> changePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    await post(
      ApiConfig.meChangePassword,
      data: {'current_password': currentPassword, 'new_password': newPassword},
    );
  }

  /// PUT /v1/me - Aggiorna profilo utente
  Future<Map<String, dynamic>> updateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
  }) async {
    final data = <String, dynamic>{};
    if (firstName != null) data['first_name'] = firstName;
    if (lastName != null) data['last_name'] = lastName;
    if (email != null) data['email'] = email;
    if (phone != null) data['phone'] = phone;

    return put(ApiConfig.authMe, data: data);
  }

  /// GET /v1/me/bookings
  Future<Map<String, dynamic>> getMyBookings() async {
    return get(ApiConfig.meBookings);
  }

  // ========== PUBLIC BROWSE ENDPOINTS ==========

  /// GET /v1/businesses/by-slug/{slug}
  /// Recupera un business dal suo slug (pubblico, no auth)
  Future<Map<String, dynamic>> getBusinessBySlug(String slug) async {
    return get(ApiConfig.businessBySlug(slug));
  }

  /// GET /v1/businesses/{business_id}/locations/public
  /// Recupera le locations di un business (pubblico, per booking flow)
  Future<Map<String, dynamic>> getBusinessLocations(int businessId) async {
    return get(ApiConfig.businessLocations(businessId));
  }

  /// GET /v1/services?location_id=X
  Future<Map<String, dynamic>> getServices(int locationId) async {
    return get(
      ApiConfig.services,
      queryParameters: {'location_id': locationId},
    );
  }

  /// GET /v1/staff?location_id=X
  Future<Map<String, dynamic>> getStaff(int locationId) async {
    return get(ApiConfig.staff, queryParameters: {'location_id': locationId});
  }

  /// GET /v1/availability?location_id=X&date=YYYY-MM-DD&service_ids=1,2&staff_id=N
  Future<Map<String, dynamic>> getAvailability({
    required int locationId,
    required String date,
    required List<int> serviceIds,
    int? staffId,
  }) async {
    final params = <String, dynamic>{
      'location_id': locationId,
      'date': date,
      'service_ids': serviceIds.join(','),
    };
    if (staffId != null) {
      params['staff_id'] = staffId;
    }
    return get(ApiConfig.availability, queryParameters: params);
  }

  // ========== STAFF PLANNING ENDPOINTS (read-only) ==========

  /// GET /v1/staff/{id}/plannings - tutti i planning per uno staff
  Future<Map<String, dynamic>> getStaffPlannings(int staffId) async {
    return get(ApiConfig.staffPlannings(staffId));
  }

  /// GET /v1/staff/{id}/planning?date=YYYY-MM-DD - planning valido per data
  Future<Map<String, dynamic>> getStaffPlanningForDate({
    required int staffId,
    required String date,
  }) async {
    return get(
      ApiConfig.staffPlanningForDate(staffId),
      queryParameters: {'date': date},
    );
  }

  /// GET /v1/staff/{id}/planning-availability?date=YYYY-MM-DD - slot disponibili per data
  /// Ritorna array di slot index (es: [36, 37, 38, 48, 49, 50...])
  Future<Map<String, dynamic>> getStaffPlanningAvailability({
    required int staffId,
    required String date,
  }) async {
    return get(
      ApiConfig.staffPlanningAvailability(staffId),
      queryParameters: {'date': date},
    );
  }

  // ========== BOOKING ENDPOINT ==========

  /// POST /v1/locations/{location_id}/bookings
  Future<Map<String, dynamic>> createBooking({
    required int locationId,
    required String idempotencyKey,
    required List<int> serviceIds,
    required String startTime,
    int? staffId,
    String? notes,
  }) async {
    final data = <String, dynamic>{
      'service_ids': serviceIds,
      'start_time': startTime,
    };
    if (staffId != null) {
      data['staff_id'] = staffId;
    }
    if (notes != null && notes.isNotEmpty) {
      data['notes'] = notes;
    }

    return post(
      ApiConfig.bookings(locationId),
      data: data,
      headers: {'X-Idempotency-Key': idempotencyKey},
    );
  }

  /// DELETE /v1/locations/{location_id}/bookings/{id}
  /// NOTE: Richiede location_id, quindi serve prima recuperare il booking completo
  /// da GET /v1/me/bookings per ottenere il location_id associato
  Future<void> deleteBooking(int locationId, int bookingId) async {
    await delete('/v1/locations/$locationId/bookings/$bookingId');
  }

  /// PUT /v1/locations/{location_id}/bookings/{id}
  /// Reschedule booking (modifica data/ora)
  Future<Map<String, dynamic>> updateBooking({
    required int locationId,
    required int bookingId,
    required String startTime,
    String? notes,
  }) async {
    final data = <String, dynamic>{'start_time': startTime};
    if (notes != null) {
      data['notes'] = notes;
    }

    return await _dio
        .put('/v1/locations/$locationId/bookings/$bookingId', data: data)
        .then((response) => _handleResponse(response))
        .catchError((e) => throw _handleError(e as DioException));
  }
}
--- FILE: lib/core/network/token_storage.dart ---
export 'token_storage_interface.dart';
// Conditional import: web vs mobile/desktop
export 'token_storage_mobile.dart'
    if (dart.library.html) 'token_storage_web.dart';
--- FILE: lib/core/utils/subdomain_resolver.dart ---
/// Utility per risolvere il business slug dall'URL corrente.
///
/// Pattern supportati (in ordine di priorit√†):
/// 1. Sottodominio: {slug}.prenota.tuodominio.it ‚Üí "slug"
/// 2. Path-based: prenota.tuodominio.it/{slug} ‚Üí "slug"
/// 3. Query param: prenota.tuodominio.it?business={slug} ‚Üí "slug"
///
/// Esempio: salonemario.prenota.romeolab.it ‚Üí "salonemario"
/// Esempio: prenota.romeolab.it/salonemario ‚Üí "salonemario"
class SubdomainResolver {
  /// Pattern regex per estrarre lo slug dal sottodominio.
  /// Supporta: {slug}.prenota.{domain} o {slug}.{domain}
  static final RegExp _subdomainPattern = RegExp(
    r'^([a-z0-9][a-z0-9-]*[a-z0-9]|[a-z0-9])\.(?:prenota\.)?',
    caseSensitive: false,
  );

  /// Pattern per validare lo slug (alfanumerico con trattini)
  static final RegExp _slugPattern = RegExp(
    r'^[a-z0-9][a-z0-9-]*[a-z0-9]$|^[a-z0-9]$',
  );

  /// Domini da escludere (non sono slug di business)
  static const _excludedSubdomains = {
    'www',
    'api',
    'admin',
    'gestionale',
    'app',
    'staging',
    'dev',
    'test',
    'localhost',
    'prenota',
  };

  /// Path segments da escludere (non sono slug)
  static const _excludedPaths = {
    '',
    'index.html',
    'booking',
    'login',
    'register',
    'privacy',
    'terms',
  };

  /// Estrae lo slug del business dall'URL corrente.
  ///
  /// Prova in ordine:
  /// 1. Sottodominio: salonemario.prenota.romeolab.it
  /// 2. Path: prenota.romeolab.it/salonemario
  /// 3. Query: prenota.romeolab.it?business=salonemario
  ///
  /// Returns: slug del business o null se non trovato
  static String? getBusinessSlug() {
    try {
      // 1. Prova sottodominio
      final subdomainSlug = _getSlugFromSubdomain();
      if (subdomainSlug != null) {
        return subdomainSlug;
      }

      // 2. Prova path-based (primo segmento del path)
      final pathSlug = _getSlugFromPath();
      if (pathSlug != null) {
        return pathSlug;
      }

      // 3. Prova query parameter
      final querySlug = _getSlugFromQuery();
      if (querySlug != null) {
        return querySlug;
      }

      return null;
    } catch (_) {
      return null;
    }
  }

  /// Estrae slug dal sottodominio
  static String? _getSlugFromSubdomain() {
    final host = Uri.base.host.toLowerCase();

    // Localhost non ha sottodomini
    if (host.startsWith('localhost') || host.startsWith('127.0.0.1')) {
      return null;
    }

    final match = _subdomainPattern.firstMatch(host);
    if (match == null) {
      return null;
    }

    final slug = match.group(1);
    if (slug == null || _excludedSubdomains.contains(slug)) {
      return null;
    }

    return slug;
  }

  /// Estrae slug dal primo segmento del path
  /// Es: prenota.romeolab.it/salonemario ‚Üí "salonemario"
  static String? _getSlugFromPath() {
    final pathSegments = Uri.base.pathSegments;
    if (pathSegments.isEmpty) {
      return null;
    }

    final firstSegment = pathSegments.first.toLowerCase();

    // Verifica che sia un slug valido
    if (_excludedPaths.contains(firstSegment)) {
      return null;
    }

    if (!_slugPattern.hasMatch(firstSegment)) {
      return null;
    }

    return firstSegment;
  }

  /// Estrae slug dal query parameter "business" o "b"
  /// Es: prenota.romeolab.it?business=salonemario ‚Üí "salonemario"
  static String? _getSlugFromQuery() {
    final params = Uri.base.queryParameters;
    final slug = params['business'] ?? params['b'];

    if (slug == null || slug.isEmpty) {
      return null;
    }

    final normalizedSlug = slug.toLowerCase();
    if (!_slugPattern.hasMatch(normalizedSlug)) {
      return null;
    }

    return normalizedSlug;
  }

  /// Verifica se l'URL corrente contiene un business slug.
  static bool isBusinessSubdomain() {
    return getBusinessSlug() != null;
  }

  /// Costruisce l'URL per un business dato il suo slug.
  ///
  /// Usa il formato path-based per compatibilit√† con hosting standard.
  /// Esempio: buildBusinessUrl("salonemario") ‚Üí "https://prenota.romeolab.it/salonemario"
  static String buildBusinessUrl(
    String slug, {
    String baseDomain = 'prenota.romeolab.it',
    bool usePathBased = true,
  }) {
    if (usePathBased) {
      return 'https://$baseDomain/$slug';
    }
    // Formato sottodominio (richiede wildcard SSL)
    return 'https://$slug.$baseDomain';
  }

  /// Ritorna la modalit√† di risoluzione usata per lo slug corrente.
  /// Utile per debug.
  static String? getResolutionMode() {
    if (_getSlugFromSubdomain() != null) return 'subdomain';
    if (_getSlugFromPath() != null) return 'path';
    if (_getSlugFromQuery() != null) return 'query';
    return null;
  }
}
--- FILE: lib/core/models/service_category.dart ---
/// Categoria di servizi
class ServiceCategory {
  final int id;
  final int businessId;
  final String name;
  final String? description;
  final int sortOrder;

  const ServiceCategory({
    required this.id,
    required this.businessId,
    required this.name,
    this.description,
    this.sortOrder = 0,
  });

  ServiceCategory copyWith({
    int? id,
    int? businessId,
    String? name,
    String? description,
    int? sortOrder,
  }) =>
      ServiceCategory(
        id: id ?? this.id,
        businessId: businessId ?? this.businessId,
        name: name ?? this.name,
        description: description ?? this.description,
        sortOrder: sortOrder ?? this.sortOrder,
      );

  factory ServiceCategory.fromJson(Map<String, dynamic> json) =>
      ServiceCategory(
        id: json['id'] as int,
        businessId: json['business_id'] as int,
        name: json['name'] as String,
        description: json['description'] as String?,
        sortOrder: json['sort_order'] as int? ?? 0,
      );

  Map<String, dynamic> toJson() => {
        'id': id,
        'business_id': businessId,
        'name': name,
        if (description != null) 'description': description,
        'sort_order': sortOrder,
      };
}
--- FILE: lib/core/models/user.dart ---
/// Modello utente per l'autenticazione
class User {
  final int id;
  final String email;
  final String firstName;
  final String lastName;
  final String? phone;
  final DateTime createdAt;

  const User({
    required this.id,
    required this.email,
    required this.firstName,
    required this.lastName,
    this.phone,
    required this.createdAt,
  });

  String get fullName => '$firstName $lastName';

  User copyWith({
    int? id,
    String? email,
    String? firstName,
    String? lastName,
    String? phone,
    DateTime? createdAt,
  }) =>
      User(
        id: id ?? this.id,
        email: email ?? this.email,
        firstName: firstName ?? this.firstName,
        lastName: lastName ?? this.lastName,
        phone: phone ?? this.phone,
        createdAt: createdAt ?? this.createdAt,
      );

  factory User.fromJson(Map<String, dynamic> json) => User(
        id: json['id'] as int,
        email: json['email'] as String,
        firstName: json['first_name'] as String,
        lastName: json['last_name'] as String,
        phone: json['phone'] as String?,
        createdAt: DateTime.parse(json['created_at'] as String),
      );

  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'first_name': firstName,
        'last_name': lastName,
        if (phone != null) 'phone': phone,
        'created_at': createdAt.toIso8601String(),
      };
}
--- FILE: lib/core/models/booking_item.dart ---
/// Modello per le prenotazioni utente recuperate da /v1/me/bookings
class BookingItem {
  final int id;
  final int businessId;
  final String businessName;
  final int locationId;
  final String locationName;
  final String? locationAddress;
  final String? locationCity;
  final List<String> serviceNames;
  final List<int> serviceIds;
  final String? staffName;
  final DateTime startTime;
  final DateTime endTime;
  final double totalPrice;
  final String? notes;
  final bool canModify;
  final DateTime? canModifyUntil;
  final String status;

  const BookingItem({
    required this.id,
    required this.businessId,
    required this.businessName,
    required this.locationId,
    required this.locationName,
    this.locationAddress,
    this.locationCity,
    required this.serviceNames,
    this.serviceIds = const [],
    this.staffName,
    required this.startTime,
    required this.endTime,
    this.totalPrice = 0.0,
    this.notes,
    required this.canModify,
    this.canModifyUntil,
    this.status = 'confirmed',
  });

  factory BookingItem.fromJson(Map<String, dynamic> json) {
    // Supporta sia formato nested (location.id) che flat (location_id)
    final location = json['location'] as Map<String, dynamic>?;
    final business = json['business'] as Map<String, dynamic>?;

    return BookingItem(
      id: json['id'] as int? ?? json['booking_id'] as int,
      businessId: business?['id'] as int? ?? json['business_id'] as int,
      businessName:
          business?['name'] as String? ?? json['business_name'] as String,
      locationId: location?['id'] as int? ?? json['location_id'] as int,
      locationName:
          location?['name'] as String? ?? json['location_name'] as String,
      locationAddress:
          location?['address'] as String? ??
          json['location_address'] as String?,
      locationCity:
          location?['city'] as String? ?? json['location_city'] as String?,
      serviceNames: _parseServiceNames(json),
      serviceIds: _parseServiceIds(json),
      staffName: json['staff_name'] as String?,
      startTime: DateTime.parse(json['start_time'] as String),
      endTime: DateTime.parse(json['end_time'] as String),
      totalPrice:
          (json['total_price'] as num?)?.toDouble() ??
          (json['price'] as num?)?.toDouble() ??
          0.0,
      notes: json['notes'] as String?,
      canModify: json['can_modify'] as bool? ?? false,
      canModifyUntil: json['can_modify_until'] != null
          ? DateTime.parse(json['can_modify_until'] as String)
          : null,
      status: json['status'] as String? ?? 'confirmed',
    );
  }

  /// Parsa service_names supportando sia array che singolo valore
  static List<String> _parseServiceNames(Map<String, dynamic> json) {
    // Formato array: service_names: ["Taglio", "Piega"]
    if (json.containsKey('service_names') && json['service_names'] != null) {
      final names = json['service_names'];
      if (names is List) {
        return names.map((e) => e.toString()).toList();
      }
    }
    // Formato singolo: service_name: "Taglio + Piega"
    if (json.containsKey('service_name') && json['service_name'] != null) {
      return [json['service_name'] as String];
    }
    return [];
  }

  /// Parsa service_ids supportando sia array che singolo valore
  static List<int> _parseServiceIds(Map<String, dynamic> json) {
    if (json.containsKey('service_ids') && json['service_ids'] != null) {
      final ids = json['service_ids'];
      if (ids is List) {
        return ids.map((e) => e as int).toList();
      }
    }
    return [];
  }

  /// Stringa formattata dei servizi
  String get servicesDisplay => serviceNames.join(' + ');

  bool get isPast => endTime.isBefore(DateTime.now());
  bool get isUpcoming => !isPast;

  /// Crea copia con nuovi valori (per update locale dopo reschedule)
  BookingItem copyWith({
    DateTime? startTime,
    DateTime? endTime,
    String? notes,
    bool? canModify,
    DateTime? canModifyUntil,
    String? status,
  }) {
    return BookingItem(
      id: id,
      businessId: businessId,
      businessName: businessName,
      locationId: locationId,
      locationName: locationName,
      locationAddress: locationAddress,
      locationCity: locationCity,
      serviceNames: serviceNames,
      serviceIds: serviceIds,
      staffName: staffName,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      totalPrice: totalPrice,
      notes: notes ?? this.notes,
      canModify: canModify ?? this.canModify,
      canModifyUntil: canModifyUntil ?? this.canModifyUntil,
      status: status ?? this.status,
    );
  }
}
--- FILE: lib/core/models/service.dart ---
/// Modello Servizio prenotabile online
class Service {
  final int id;
  final int businessId;
  final int categoryId;
  final String name;
  final String? description;
  final int sortOrder;
  final int durationMinutes;
  final double price;
  final bool isFree;
  final bool isPriceStartingFrom;
  final bool isBookableOnline;

  const Service({
    required this.id,
    required this.businessId,
    required this.categoryId,
    required this.name,
    this.description,
    this.sortOrder = 0,
    required this.durationMinutes,
    required this.price,
    this.isFree = false,
    this.isPriceStartingFrom = false,
    this.isBookableOnline = true,
  });

  Service copyWith({
    int? id,
    int? businessId,
    int? categoryId,
    String? name,
    String? description,
    int? sortOrder,
    int? durationMinutes,
    double? price,
    bool? isFree,
    bool? isPriceStartingFrom,
    bool? isBookableOnline,
  }) => Service(
    id: id ?? this.id,
    businessId: businessId ?? this.businessId,
    categoryId: categoryId ?? this.categoryId,
    name: name ?? this.name,
    description: description ?? this.description,
    sortOrder: sortOrder ?? this.sortOrder,
    durationMinutes: durationMinutes ?? this.durationMinutes,
    price: price ?? this.price,
    isFree: isFree ?? this.isFree,
    isPriceStartingFrom: isPriceStartingFrom ?? this.isPriceStartingFrom,
    isBookableOnline: isBookableOnline ?? this.isBookableOnline,
  );

  factory Service.fromJson(Map<String, dynamic> json) => Service(
    id: json['id'] as int,
    // API pu√≤ usare business_id o derivarlo dalla location
    businessId: json['business_id'] as int? ?? 1,
    categoryId: json['category_id'] as int,
    name: json['name'] as String,
    description: json['description'] as String?,
    sortOrder: json['sort_order'] as int? ?? 0,
    // API ritorna default_duration_minutes o duration_minutes
    durationMinutes:
        json['default_duration_minutes'] as int? ??
        json['duration_minutes'] as int? ??
        30,
    // API ritorna default_price o price
    price:
        (json['default_price'] as num?)?.toDouble() ??
        (json['price'] as num?)?.toDouble() ??
        0.0,
    isFree: json['is_free'] as bool? ?? false,
    isPriceStartingFrom: json['is_price_starting_from'] as bool? ?? false,
    isBookableOnline: json['is_bookable_online'] as bool? ?? true,
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'category_id': categoryId,
    'name': name,
    if (description != null) 'description': description,
    'sort_order': sortOrder,
    'duration_minutes': durationMinutes,
    'price': price,
    'is_free': isFree,
    'is_price_starting_from': isPriceStartingFrom,
    'is_bookable_online': isBookableOnline,
  };

  String get formattedPrice {
    if (isFree) return 'Gratis';
    final priceStr = price.toStringAsFixed(2).replaceAll('.', ',');
    return isPriceStartingFrom ? 'da ‚Ç¨$priceStr' : '‚Ç¨$priceStr';
  }
}
--- FILE: lib/core/models/location.dart ---
import 'package:flutter/foundation.dart';

/// Modello Location (sede)
@immutable
class Location {
  final int id;
  final int businessId;
  final String name;
  final String? address;
  final String? city;
  final String? region;
  final String? country;
  final String? phone;
  final String? email;
  final double? latitude;
  final double? longitude;
  final String? currency;
  final String timezone;
  final bool isDefault;

  const Location({
    required this.id,
    required this.businessId,
    required this.name,
    this.address,
    this.city,
    this.region,
    this.country,
    this.phone,
    this.email,
    this.latitude,
    this.longitude,
    this.currency,
    this.timezone = 'Europe/Rome',
    this.isDefault = false,
  });

  factory Location.fromJson(Map<String, dynamic> json) {
    return Location(
      id: json['id'] as int,
      businessId: json['business_id'] as int,
      name: json['name'] as String,
      address: json['address'] as String?,
      city: json['city'] as String?,
      region: json['region'] as String?,
      country: json['country'] as String?,
      phone: json['phone'] as String?,
      email: json['email'] as String?,
      latitude: json['latitude'] != null
          ? (json['latitude'] as num).toDouble()
          : null,
      longitude: json['longitude'] != null
          ? (json['longitude'] as num).toDouble()
          : null,
      currency: json['currency'] as String?,
      timezone: json['timezone'] as String? ?? 'Europe/Rome',
      isDefault: json['is_default'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'business_id': businessId,
      'name': name,
      'address': address,
      'city': city,
      'region': region,
      'country': country,
      'phone': phone,
      'email': email,
      'latitude': latitude,
      'longitude': longitude,
      'currency': currency,
      'timezone': timezone,
      'is_default': isDefault,
    };
  }

  /// Indirizzo formattato per visualizzazione
  String get formattedAddress {
    final parts = <String>[];
    if (address != null && address!.isNotEmpty) parts.add(address!);
    if (city != null && city!.isNotEmpty) parts.add(city!);
    return parts.join(', ');
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Location && runtimeType == other.runtimeType && id == other.id;

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() => 'Location(id: $id, name: $name, city: $city)';
}
--- FILE: lib/core/models/staff.dart ---
/// Modello Staff/Operatore
class Staff {
  final int id;
  final int businessId;
  final String name;
  final String surname;
  final String? avatarUrl;
  final int sortOrder;
  final bool isBookableOnline;

  const Staff({
    required this.id,
    required this.businessId,
    required this.name,
    required this.surname,
    this.avatarUrl,
    this.sortOrder = 0,
    this.isBookableOnline = true,
  });

  String get displayName {
    if (surname.isEmpty) return name;
    return '$name $surname';
  }

  String get initials {
    final nameInitial = name.isNotEmpty ? name[0].toUpperCase() : '';
    final surnameInitial = surname.isNotEmpty ? surname[0].toUpperCase() : '';
    return '$nameInitial$surnameInitial';
  }

  Staff copyWith({
    int? id,
    int? businessId,
    String? name,
    String? surname,
    String? avatarUrl,
    int? sortOrder,
    bool? isBookableOnline,
  }) =>
      Staff(
        id: id ?? this.id,
        businessId: businessId ?? this.businessId,
        name: name ?? this.name,
        surname: surname ?? this.surname,
        avatarUrl: avatarUrl ?? this.avatarUrl,
        sortOrder: sortOrder ?? this.sortOrder,
        isBookableOnline: isBookableOnline ?? this.isBookableOnline,
      );

  factory Staff.fromJson(Map<String, dynamic> json) => Staff(
        id: json['id'] as int,
        businessId: json['business_id'] as int,
        name: json['name'] as String,
        surname: json['surname'] as String? ?? '',
        avatarUrl: json['avatar_url'] as String?,
        sortOrder: json['sort_order'] as int? ?? 0,
        isBookableOnline: json['is_bookable_online'] as bool? ?? true,
      );

  Map<String, dynamic> toJson() => {
        'id': id,
        'business_id': businessId,
        'name': name,
        'surname': surname,
        if (avatarUrl != null) 'avatar_url': avatarUrl,
        'sort_order': sortOrder,
        'is_bookable_online': isBookableOnline,
      };
}
--- FILE: lib/core/models/time_slot.dart ---
/// Slot temporale disponibile per la prenotazione
class TimeSlot {
  final DateTime startTime;
  final DateTime endTime;
  final int? staffId;

  const TimeSlot({
    required this.startTime,
    required this.endTime,
    this.staffId,
  });

  int get durationMinutes => endTime.difference(startTime).inMinutes;

  String get formattedTime {
    final hour = startTime.hour.toString().padLeft(2, '0');
    final minute = startTime.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }

  TimeSlot copyWith({
    DateTime? startTime,
    DateTime? endTime,
    int? staffId,
  }) =>
      TimeSlot(
        startTime: startTime ?? this.startTime,
        endTime: endTime ?? this.endTime,
        staffId: staffId ?? this.staffId,
      );

  factory TimeSlot.fromJson(Map<String, dynamic> json) => TimeSlot(
        startTime: DateTime.parse(json['start_time'] as String),
        endTime: DateTime.parse(json['end_time'] as String),
        staffId: json['staff_id'] as int?,
      );

  Map<String, dynamic> toJson() => {
        'start_time': startTime.toIso8601String(),
        'end_time': endTime.toIso8601String(),
        if (staffId != null) 'staff_id': staffId,
      };
}
--- FILE: lib/core/models/business.dart ---
import 'package:flutter/foundation.dart';

/// Modello Business
@immutable
class Business {
  final int id;
  final String name;
  final String slug;
  final String? email;
  final String? phone;
  final String timezone;
  final String currency;
  final int? defaultLocationId;

  const Business({
    required this.id,
    required this.name,
    required this.slug,
    this.email,
    this.phone,
    this.timezone = 'Europe/Rome',
    this.currency = 'EUR',
    this.defaultLocationId,
  });

  factory Business.fromJson(Map<String, dynamic> json) {
    return Business(
      id: json['id'] as int,
      name: json['name'] as String,
      slug: json['slug'] as String,
      email: json['email'] as String?,
      phone: json['phone'] as String?,
      timezone: json['timezone'] as String? ?? 'Europe/Rome',
      currency: json['currency'] as String? ?? 'EUR',
      defaultLocationId: json['default_location_id'] as int?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'slug': slug,
      'email': email,
      'phone': phone,
      'timezone': timezone,
      'currency': currency,
      'default_location_id': defaultLocationId,
    };
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Business && runtimeType == other.runtimeType && id == other.id;

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() => 'Business(id: $id, name: $name, slug: $slug)';
}
--- FILE: lib/core/models/booking_request.dart ---
import 'service.dart';
import 'staff.dart';
import 'time_slot.dart';

/// Modello per la richiesta di prenotazione
class BookingRequest {
  final List<Service> services;
  final Staff? selectedStaff;
  final TimeSlot? selectedSlot;
  final String? notes;

  const BookingRequest({
    this.services = const [],
    this.selectedStaff,
    this.selectedSlot,
    this.notes,
  });

  /// Durata totale in minuti
  int get totalDurationMinutes =>
      services.fold(0, (sum, s) => sum + s.durationMinutes);

  /// Prezzo totale
  double get totalPrice =>
      services.fold(0.0, (sum, s) => sum + (s.isFree ? 0 : s.price));

  /// Formatta il prezzo totale
  String get formattedTotalPrice {
    if (totalPrice == 0) return 'Gratis';
    return '‚Ç¨${totalPrice.toStringAsFixed(2).replaceAll('.', ',')}';
  }

  /// Verifica se la prenotazione √® completa
  bool get isComplete =>
      services.isNotEmpty && selectedSlot != null;

  BookingRequest copyWith({
    List<Service>? services,
    Staff? selectedStaff,
    TimeSlot? selectedSlot,
    String? notes,
    bool clearStaff = false,
    bool clearSlot = false,
  }) =>
      BookingRequest(
        services: services ?? this.services,
        selectedStaff: clearStaff ? null : (selectedStaff ?? this.selectedStaff),
        selectedSlot: clearSlot ? null : (selectedSlot ?? this.selectedSlot),
        notes: notes ?? this.notes,
      );

  Map<String, dynamic> toJson() => {
        'service_ids': services.map((s) => s.id).toList(),
        if (selectedStaff != null) 'staff_id': selectedStaff!.id,
        if (selectedSlot != null) 'start_time': selectedSlot!.startTime.toIso8601String(),
        if (notes != null && notes!.isNotEmpty) 'notes': notes,
      };
}
--- FILE: lib/app/router.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../core/l10n/l10_extension.dart';
import '../features/auth/presentation/change_password_screen.dart';
import '../features/auth/presentation/login_screen.dart';
import '../features/auth/presentation/profile_screen.dart';
import '../features/auth/presentation/register_screen.dart';
import '../features/auth/presentation/reset_password_screen.dart';
import '../features/auth/providers/auth_provider.dart';
import '../features/booking/presentation/screens/booking_screen.dart';
import '../features/booking/presentation/screens/my_bookings_screen.dart';
import '../features/booking/providers/locations_provider.dart';
import 'providers/route_slug_provider.dart';

/// Router provider con supporto path-based multi-business
///
/// Struttura URL:
/// - /                      ‚Üí Landing page (business non specificato)
/// - /:slug                 ‚Üí Redirect a /:slug/booking
/// - /:slug/booking         ‚Üí Schermata prenotazione
/// - /:slug/login           ‚Üí Login
/// - /:slug/register        ‚Üí Registrazione
/// - /:slug/my-bookings     ‚Üí Le mie prenotazioni
/// - /reset-password/:token ‚Üí Reset password (globale, no slug)
final routerProvider = Provider<GoRouter>((ref) {
  // NOTA: usa ref.read per evitare rebuild del router quando auth cambia
  // Il redirect legge sempre lo stato auth corrente senza causare loop

  return GoRouter(
    initialLocation: '/',
    redirect: (context, state) {
      // Legge auth con ref.read (non ref.watch) per evitare loop
      final isAuthenticated = ref.read(authProvider).isAuthenticated;

      // Filtra segmenti vuoti (trailing slash produce ['slug', ''])
      final pathSegments = state.uri.pathSegments
          .where((s) => s.isNotEmpty)
          .toList();

      // Estrae lo slug dal path (primo segmento se non √® una route riservata)
      String? slug;
      if (pathSegments.isNotEmpty) {
        final firstSegment = pathSegments.first;
        if (!_reservedPaths.contains(firstSegment)) {
          slug = firstSegment;
        }
      }

      debugPrint('üîÄ ROUTER: extracted slug=$slug');

      // Estrae location ID dal query param (?location=4)
      final locationParam = state.uri.queryParameters['location'];
      final urlLocationId = locationParam != null
          ? int.tryParse(locationParam)
          : null;

      // Aggiorna i provider con slug e location correnti
      // Usiamo Future.microtask per evitare modifiche durante il build
      Future.microtask(() {
        ref.read(routeSlugProvider.notifier).state = slug;
        ref.read(urlLocationIdProvider.notifier).state = urlLocationId;
        debugPrint(
          'üîÄ ROUTER: routeSlugProvider updated to $slug, urlLocationId=$urlLocationId',
        );
      });

      // Se siamo su /:slug senza sotto-path, redirect a /:slug/booking (mantieni query params)
      if (slug != null && pathSegments.length == 1) {
        final query = state.uri.query.isNotEmpty ? '?${state.uri.query}' : '';
        debugPrint('üîÄ ROUTER: redirecting to /$slug/booking$query');
        return '/$slug/booking$query';
      }

      // Auth redirect logic per route con slug
      if (slug != null) {
        final subPath = pathSegments.length > 1 ? pathSegments[1] : '';

        // Route protette che richiedono autenticazione
        const protectedRoutes = {'my-bookings', 'profile', 'change-password'};

        // Se non autenticato e cerca di accedere a route protetta, redirect a login
        if (!isAuthenticated && protectedRoutes.contains(subPath)) {
          return '/$slug/login';
        }

        // Se autenticato e cerca di accedere a login/register, redirect a booking
        if (isAuthenticated && (subPath == 'login' || subPath == 'register')) {
          return '/$slug/booking';
        }
      }

      return null;
    },

    routes: [
      // ============================================
      // ROUTE GLOBALI (senza business context)
      // ============================================

      /// Landing page - nessun business specificato
      GoRoute(
        path: '/',
        name: 'landing',
        builder: (context, state) => const _LandingScreen(),
      ),

      /// Reset password (globale, il link viene da email)
      GoRoute(
        path: '/reset-password/:token',
        name: 'reset-password',
        builder: (context, state) {
          final token = state.pathParameters['token'] ?? '';
          return ResetPasswordScreen(token: token);
        },
      ),

      // ============================================
      // ROUTE CON BUSINESS CONTEXT (/:slug/*)
      // ============================================

      /// Prenotazione - route principale del business
      GoRoute(
        path: '/:slug/booking',
        name: 'business-booking',
        builder: (context, state) => const BookingScreen(),
      ),

      /// Login con context business
      GoRoute(
        path: '/:slug/login',
        name: 'business-login',
        builder: (context, state) => const LoginScreen(),
      ),

      /// Registrazione con context business
      GoRoute(
        path: '/:slug/register',
        name: 'business-register',
        builder: (context, state) => const RegisterScreen(),
      ),

      /// Le mie prenotazioni (richiede auth)
      GoRoute(
        path: '/:slug/my-bookings',
        name: 'business-my-bookings',
        builder: (context, state) => const MyBookingsScreen(),
      ),

      /// Cambio password (richiede auth)
      GoRoute(
        path: '/:slug/change-password',
        name: 'business-change-password',
        builder: (context, state) => const ChangePasswordScreen(),
      ),

      /// Profilo utente (richiede auth)
      GoRoute(
        path: '/:slug/profile',
        name: 'business-profile',
        builder: (context, state) => const ProfileScreen(),
      ),

      /// Catch-all per /:slug ‚Üí redirect a /:slug/booking
      /// Gestito nel redirect, ma serve come fallback
      GoRoute(
        path: '/:slug',
        redirect: (context, state) {
          final slug = state.pathParameters['slug'];
          return '/$slug/booking';
        },
      ),
    ],

    errorBuilder: (context, state) => _ErrorScreen(path: state.uri.path),
  );
});

/// Path riservati che NON sono slug di business
const _reservedPaths = {
  'reset-password',
  'login',
  'register',
  'booking',
  'my-bookings',
  'change-password',
  'profile',
  'privacy',
  'terms',
};

/// Schermata landing - nessun business specificato
class _LandingScreen extends ConsumerWidget {
  const _LandingScreen();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;

    return Scaffold(
      body: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.storefront_outlined, size: 64),
            const SizedBox(height: 16),
            Text(
              l10n.businessNotFound,
              style: Theme.of(context).textTheme.titleLarge,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 32),
              child: Text(
                l10n.businessNotFoundHint,
                style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                  color: Theme.of(
                    context,
                  ).colorScheme.onSurface.withAlpha((0.6 * 255).round()),
                ),
                textAlign: TextAlign.center,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// Schermata errore 404
class _ErrorScreen extends StatelessWidget {
  final String path;

  const _ErrorScreen({required this.path});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.error_outline, size: 64, color: Colors.red),
            const SizedBox(height: 16),
            Text(
              'Pagina non trovata',
              style: Theme.of(context).textTheme.titleLarge,
            ),
            const SizedBox(height: 8),
            Text(
              path,
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                color: Theme.of(context).colorScheme.onSurface.withAlpha(150),
              ),
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/app/providers/form_factor_provider.dart ---
import 'dart:ui' as ui;

import 'package:flutter/widgets.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'form_factor_provider.g.dart';

// Definiamo i tre layout che ci interessano
enum AppFormFactor { mobile, tablet, desktop }

AppFormFactor _formFactorForWidth(double width) {
  if (width >= 1024) return AppFormFactor.desktop;
  if (width >= 600) return AppFormFactor.tablet;
  return AppFormFactor.mobile;
}

@riverpod
class FormFactorNotifier extends _$FormFactorNotifier {
  @override
  AppFormFactor build() {
    final binding = WidgetsFlutterBinding.ensureInitialized();
    final dispatcher = binding.platformDispatcher;
    final ui.FlutterView? view = dispatcher.views.isNotEmpty
        ? dispatcher.views.first
        : dispatcher.implicitView;

    if (view != null) {
      final logicalSize = view.physicalSize / view.devicePixelRatio;
      return _formFactorForWidth(logicalSize.width);
    }

    return AppFormFactor.mobile;
  }

  /// Aggiorna il form factor in base alla larghezza dello schermo.
  /// Usa lo stesso breakpoint di 600px che usi nel resto dell'app.
  void update(double screenWidth) {
    final newFactor = _formFactorForWidth(screenWidth);

    // Aggiorna lo stato solo se il form factor cambia
    if (state != newFactor) {
      state = newFactor;
    }
  }
}
--- FILE: lib/app/providers/route_slug_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod/legacy.dart';

/// Provider per lo slug del business estratto dalla route corrente.
///
/// Questo provider viene utilizzato per passare lo slug dal router
/// ai provider che ne hanno bisogno (es. currentBusinessProvider).
///
/// A differenza di SubdomainResolver.getBusinessSlug() che legge Uri.base
/// (statico al caricamento pagina), questo provider viene aggiornato
/// dinamicamente quando la route cambia.
final routeSlugProvider = StateProvider<String?>((ref) => null);

/// Provider per verificare se siamo in una route con business slug
final hasRouteSlugProvider = Provider<bool>((ref) {
  return ref.watch(routeSlugProvider) != null;
});
--- FILE: lib/app/providers/form_factor_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'form_factor_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(FormFactorNotifier)
const formFactorProvider = FormFactorNotifierProvider._();

final class FormFactorNotifierProvider
    extends $NotifierProvider<FormFactorNotifier, AppFormFactor> {
  const FormFactorNotifierProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'formFactorProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$formFactorNotifierHash();

  @$internal
  @override
  FormFactorNotifier create() => FormFactorNotifier();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AppFormFactor value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AppFormFactor>(value),
    );
  }
}

String _$formFactorNotifierHash() =>
    r'c2d345138b8b938ff84a110cd4b6bf3dda7a605e';

abstract class _$FormFactorNotifier extends $Notifier<AppFormFactor> {
  AppFormFactor build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<AppFormFactor, AppFormFactor>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AppFormFactor, AppFormFactor>,
              AppFormFactor,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/app/theme/theme_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'theme.dart';
import 'theme_config.dart';

/// Notifier per gestire il tema dinamico
class ThemeNotifier extends Notifier<AppThemeConfig> {
  @override
  AppThemeConfig build() => const AppThemeConfig(
        seedColor: colorPrimary,
        brightness: Brightness.light,
      );

  void updateSeed(Color color) {
    state = state.copyWith(seedColor: color);
  }

  void toggleBrightness() {
    final newBrightness = state.brightness == Brightness.light
        ? Brightness.dark
        : Brightness.light;
    state = state.copyWith(brightness: newBrightness);
  }
}

/// Provider globale per il tema
final themeNotifierProvider = NotifierProvider<ThemeNotifier, AppThemeConfig>(
  ThemeNotifier.new,
);
--- FILE: lib/app/theme/theme_config.dart ---
import 'package:flutter/material.dart';

class AppThemeConfig {
  final Color seedColor;
  final Brightness brightness;

  const AppThemeConfig({
    required this.seedColor,
    this.brightness = Brightness.light,
  });

  AppThemeConfig copyWith({Color? seedColor, Brightness? brightness}) {
    return AppThemeConfig(
      seedColor: seedColor ?? this.seedColor,
      brightness: brightness ?? this.brightness,
    );
  }
}
--- FILE: lib/app/theme/theme.dart ---
import 'package:flutter/material.dart';

import 'theme_config.dart';

const colorPrimary = Color(0xFF141414);
const colorBackground = Color(0xFFFEFEFE);
const colorAccent = Color(0xFF2196F3);

/// Crea il tema dell'app
ThemeData buildTheme(AppThemeConfig config, Brightness brightness) {
  final isDark = brightness == Brightness.dark;

  final background = isDark ? colorPrimary : colorBackground;
  final onBackground = isDark ? colorBackground : colorPrimary;

  final colorScheme = ColorScheme(
    brightness: brightness,
    primary: colorAccent,
    onPrimary: Colors.white,
    secondary: colorAccent,
    onSecondary: Colors.white,
    error: Colors.red,
    onError: Colors.white,
    surface: background,
    onSurface: onBackground,
  );

  return ThemeData(
    useMaterial3: true,
    colorScheme: colorScheme,
    brightness: brightness,
    scaffoldBackgroundColor: background,
    appBarTheme: AppBarTheme(
      backgroundColor: background,
      foregroundColor: onBackground,
      elevation: 0,
      centerTitle: true,
      surfaceTintColor: Colors.transparent,
    ),
    cardTheme: CardThemeData(
      color: background,
      elevation: 0,
      margin: const EdgeInsets.all(8),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: onBackground.withOpacity(0.1)),
      ),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        backgroundColor: colorAccent,
        foregroundColor: Colors.white,
        minimumSize: const Size(double.infinity, 52),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        elevation: 0,
      ),
    ),
    outlinedButtonTheme: OutlinedButtonThemeData(
      style: OutlinedButton.styleFrom(
        foregroundColor: colorPrimary,
        minimumSize: const Size(double.infinity, 52),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        side: BorderSide(color: colorPrimary.withOpacity(0.2)),
      ),
    ),
    textButtonTheme: TextButtonThemeData(
      style: TextButton.styleFrom(
        foregroundColor: colorAccent,
      ),
    ),
    inputDecorationTheme: InputDecorationTheme(
      filled: true,
      fillColor: onBackground.withOpacity(0.05),
      border: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: BorderSide.none,
      ),
      enabledBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: BorderSide(color: onBackground.withOpacity(0.1)),
      ),
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: colorAccent, width: 2),
      ),
      errorBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: Colors.red),
      ),
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
    ),
    chipTheme: ChipThemeData(
      backgroundColor: colorAccent.withOpacity(0.1),
      selectedColor: colorAccent,
      labelStyle: TextStyle(color: onBackground),
      secondaryLabelStyle: const TextStyle(color: Colors.white),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
    ),
    dividerColor: onBackground.withOpacity(0.1),
    progressIndicatorTheme: const ProgressIndicatorThemeData(
      color: colorAccent,
    ),
  );
}
--- FILE: lib/app/app.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../core/l10n/l10n.dart';
import 'router.dart';
import 'theme/theme.dart';
import 'theme/theme_provider.dart';

class App extends ConsumerWidget {
  const App({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final router = ref.watch(routerProvider);
    final themeConfig = ref.watch(themeNotifierProvider);
    final theme = buildTheme(themeConfig, themeConfig.brightness);

    return MaterialApp.router(
      title: 'Agenda Booking',
      debugShowCheckedModeBanner: false,
      theme: theme,
      routerConfig: router,
      localizationsDelegates: [
        L10n.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: L10n.delegate.supportedLocales,
      locale: const Locale('it'),
    );
  }
}
--- FILE: lib/features/auth/providers/auth_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/network/api_client.dart';
import '../../../core/network/network_providers.dart';
import '../../../core/network/token_storage.dart';
import '../data/auth_repository.dart';
import '../domain/auth_state.dart';

/// Provider per il repository di autenticazione
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return AuthRepository(apiClient);
});

/// Provider per lo stato di autenticazione
final authProvider = NotifierProvider<AuthNotifier, AuthState>(
  AuthNotifier.new,
);

class AuthNotifier extends Notifier<AuthState> {
  @override
  AuthState build() {
    // Tenta ripristino sessione all'avvio
    _tryRestoreSession();
    return AuthState.initial();
  }

  AuthRepository get _repository => ref.read(authRepositoryProvider);

  /// Tenta di ripristinare la sessione da refresh token
  Future<void> _tryRestoreSession() async {
    state = AuthState.loading();
    try {
      // Recupera il businessId salvato
      final tokenStorage = createTokenStorage();
      final savedBusinessId = await tokenStorage.getBusinessId();

      final user = await _repository.tryRestoreSession(
        businessId: savedBusinessId,
      );
      if (user != null) {
        state = AuthState.authenticated(user);
      } else {
        state = AuthState.unauthenticated();
      }
    } catch (e) {
      state = AuthState.unauthenticated();
    }
  }

  /// Login con email e password
  /// Richiede businessId per usare l'endpoint customer corretto
  Future<bool> login({
    required int businessId,
    required String email,
    required String password,
  }) async {
    state = AuthState.loading();
    try {
      final user = await _repository.login(
        businessId: businessId,
        email: email,
        password: password,
      );
      state = AuthState.authenticated(user);
      return true;
    } on ApiException catch (e) {
      state = AuthState.error(e.message);
      return false;
    } catch (e) {
      state = AuthState.error(e.toString());
      return false;
    }
  }

  /// Logout
  Future<void> logout({required int businessId}) async {
    try {
      await _repository.logout(businessId: businessId);
    } finally {
      state = AuthState.unauthenticated();
    }
  }

  /// Registrazione nuovo cliente
  Future<bool> register({
    required int businessId,
    required String email,
    required String password,
    required String firstName,
    required String lastName,
    String? phone,
  }) async {
    state = AuthState.loading();
    try {
      final user = await _repository.register(
        businessId: businessId,
        email: email,
        password: password,
        firstName: firstName,
        lastName: lastName,
        phone: phone,
      );
      state = AuthState.authenticated(user);
      return true;
    } on ApiException catch (e) {
      state = AuthState.error(e.message);
      return false;
    } catch (e) {
      state = AuthState.error(e.toString());
      return false;
    }
  }

  /// Reset password (invia email con link)
  Future<bool> resetPassword({
    required int businessId,
    required String email,
  }) async {
    state = AuthState.loading();
    try {
      await _repository.resetPassword(businessId: businessId, email: email);
      state = AuthState.unauthenticated();
      return true;
    } catch (e) {
      state = AuthState.error(e.toString());
      return false;
    }
  }

  /// Conferma reset password con token
  Future<void> resetPasswordWithToken({
    required String token,
    required String newPassword,
  }) async {
    await _repository.confirmResetPassword(
      token: token,
      newPassword: newPassword,
    );
  }

  /// Cambia password (utente loggato)
  Future<bool> changePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    try {
      await _repository.changePassword(
        currentPassword: currentPassword,
        newPassword: newPassword,
      );
      return true;
    } catch (e) {
      state = AuthState.error(e.toString());
      return false;
    }
  }

  /// Aggiorna il profilo utente
  Future<void> updateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
  }) async {
    final updatedUser = await _repository.updateProfile(
      firstName: firstName,
      lastName: lastName,
      email: email,
      phone: phone,
    );
    state = AuthState.authenticated(updatedUser);
  }

  /// Pulisce errore
  void clearError() {
    state = state.copyWith(clearError: true);
  }

  /// Verifica se √® autenticato
  bool get isAuthenticated => state.isAuthenticated;
}
--- FILE: lib/features/auth/data/auth_repository.dart ---
import '../../../core/models/user.dart';
import '../../../core/network/api_client.dart';

/// Repository per l'autenticazione CUSTOMER - API reale
/// Usa endpoint /v1/customer/{business_id}/auth/* per clienti (tabella clients)
class AuthRepository {
  final ApiClient _apiClient;

  AuthRepository(this._apiClient);

  /// Login cliente
  /// POST /v1/customer/{business_id}/auth/login
  Future<User> login({
    required int businessId,
    required String email,
    required String password,
  }) async {
    final data = await _apiClient.customerLogin(
      businessId: businessId,
      email: email,
      password: password,
    );
    return User.fromJson(data['client'] as Map<String, dynamic>);
  }

  /// Logout cliente
  /// POST /v1/customer/{business_id}/auth/logout
  Future<void> logout({required int businessId}) async {
    await _apiClient.customerLogout(businessId: businessId);
  }

  /// Recupera profilo cliente corrente
  /// GET /v1/customer/me
  Future<User> getCurrentUser() async {
    final data = await _apiClient.getCustomerMe();
    return User.fromJson(data);
  }

  /// Tenta di ripristinare sessione da refresh token
  Future<User?> tryRestoreSession({int? businessId}) async {
    final data = await _apiClient.tryRestoreSession(businessId: businessId);
    if (data != null) {
      return User.fromJson(data);
    }
    return null;
  }

  /// Registrazione nuovo cliente
  /// POST /v1/customer/{business_id}/auth/register
  Future<User> register({
    required int businessId,
    required String email,
    required String password,
    required String firstName,
    required String lastName,
    String? phone,
  }) async {
    final data = await _apiClient.customerRegister(
      businessId: businessId,
      email: email,
      password: password,
      firstName: firstName,
      lastName: lastName,
      phone: phone,
    );
    return User.fromJson(data['client'] as Map<String, dynamic>);
  }

  /// Reset password (invia email con link)
  /// POST /v1/customer/{business_id}/auth/forgot-password
  Future<void> resetPassword({
    required int businessId,
    required String email,
  }) async {
    await _apiClient.customerForgotPassword(
      businessId: businessId,
      email: email,
    );
  }

  /// Conferma reset password con token
  /// POST /v1/customer/auth/reset-password
  Future<void> confirmResetPassword({
    required String token,
    required String newPassword,
  }) async {
    await _apiClient.customerResetPassword(token: token, password: newPassword);
  }

  /// Cambia password (utente loggato)
  /// POST /v1/customer/me/change-password
  Future<void> changePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    await _apiClient.customerChangePassword(
      currentPassword: currentPassword,
      newPassword: newPassword,
    );
  }

  /// Aggiorna profilo cliente
  /// PUT /v1/customer/me
  Future<User> updateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
  }) async {
    final data = await _apiClient.customerUpdateProfile(
      firstName: firstName,
      lastName: lastName,
      email: email,
      phone: phone,
    );
    return User.fromJson(data);
  }
}
--- FILE: lib/features/auth/domain/auth_state.dart ---
import '../../../core/models/user.dart';

/// Stati possibili dell'autenticazione
enum AuthStatus {
  initial,
  loading,
  authenticated,
  unauthenticated,
  error,
}

/// Stato dell'autenticazione
class AuthState {
  final AuthStatus status;
  final User? user;
  final String? errorMessage;

  const AuthState({
    this.status = AuthStatus.initial,
    this.user,
    this.errorMessage,
  });

  bool get isAuthenticated => status == AuthStatus.authenticated && user != null;
  bool get isLoading => status == AuthStatus.loading;

  AuthState copyWith({
    AuthStatus? status,
    User? user,
    String? errorMessage,
    bool clearUser = false,
    bool clearError = false,
  }) =>
      AuthState(
        status: status ?? this.status,
        user: clearUser ? null : (user ?? this.user),
        errorMessage: clearError ? null : (errorMessage ?? this.errorMessage),
      );

  factory AuthState.initial() => const AuthState(status: AuthStatus.initial);
  
  factory AuthState.loading() => const AuthState(status: AuthStatus.loading);
  
  factory AuthState.authenticated(User user) => AuthState(
        status: AuthStatus.authenticated,
        user: user,
      );
  
  factory AuthState.unauthenticated() => const AuthState(
        status: AuthStatus.unauthenticated,
      );
  
  factory AuthState.error(String message) => AuthState(
        status: AuthStatus.error,
        errorMessage: message,
      );
}
--- FILE: lib/features/auth/presentation/profile_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../app/providers/route_slug_provider.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../../core/network/api_client.dart';
import '../providers/auth_provider.dart';

/// Schermata profilo utente per il frontend clienti.
/// Permette di visualizzare e modificare i propri dati.
class ProfileScreen extends ConsumerStatefulWidget {
  const ProfileScreen({super.key});

  @override
  ConsumerState<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends ConsumerState<ProfileScreen> {
  final _formKey = GlobalKey<FormState>();
  late final TextEditingController _firstNameController;
  late final TextEditingController _lastNameController;
  late final TextEditingController _emailController;
  late final TextEditingController _phoneController;

  bool _isLoading = false;
  bool _isEditing = false;
  String? _error;
  String? _success;

  @override
  void initState() {
    super.initState();
    final user = ref.read(authProvider).user;
    _firstNameController = TextEditingController(text: user?.firstName ?? '');
    _lastNameController = TextEditingController(text: user?.lastName ?? '');
    _emailController = TextEditingController(text: user?.email ?? '');
    _phoneController = TextEditingController(text: user?.phone ?? '');
  }

  @override
  void dispose() {
    _firstNameController.dispose();
    _lastNameController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    super.dispose();
  }

  Future<void> _saveChanges() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _error = null;
      _success = null;
    });

    try {
      await ref
          .read(authProvider.notifier)
          .updateProfile(
            firstName: _firstNameController.text.trim(),
            lastName: _lastNameController.text.trim(),
            email: _emailController.text.trim(),
            phone: _phoneController.text.trim().isEmpty
                ? null
                : _phoneController.text.trim(),
          );

      if (mounted) {
        setState(() {
          _isEditing = false;
          _success = 'Profilo aggiornato con successo';
          _isLoading = false;
        });
      }
    } on ApiException catch (e) {
      setState(() {
        _error = e.message;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  void _cancelEditing() {
    final user = ref.read(authProvider).user;
    setState(() {
      _firstNameController.text = user?.firstName ?? '';
      _lastNameController.text = user?.lastName ?? '';
      _emailController.text = user?.email ?? '';
      _phoneController.text = user?.phone ?? '';
      _isEditing = false;
      _error = null;
    });
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final authState = ref.watch(authProvider);
    final user = authState.user;

    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.profileTitle),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.pop(),
        ),
        actions: [
          if (!_isEditing)
            IconButton(
              icon: const Icon(Icons.edit),
              tooltip: 'Modifica',
              onPressed: () => setState(() => _isEditing = true),
            ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(24),
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 500),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // Avatar
                Center(
                  child: CircleAvatar(
                    radius: 50,
                    backgroundColor: colorScheme.primaryContainer,
                    child: Text(
                      _getInitials(user?.firstName, user?.lastName),
                      style: TextStyle(
                        fontSize: 32,
                        fontWeight: FontWeight.bold,
                        color: colorScheme.onPrimaryContainer,
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 24),

                // Messaggi
                if (_success != null) ...[
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: colorScheme.primaryContainer,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Row(
                      children: [
                        Icon(
                          Icons.check_circle,
                          color: colorScheme.onPrimaryContainer,
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            _success!,
                            style: TextStyle(
                              color: colorScheme.onPrimaryContainer,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 16),
                ],

                if (_error != null) ...[
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: colorScheme.errorContainer,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Row(
                      children: [
                        Icon(
                          Icons.error_outline,
                          color: colorScheme.onErrorContainer,
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            _error!,
                            style: TextStyle(
                              color: colorScheme.onErrorContainer,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 16),
                ],

                // Form
                Form(
                  key: _formKey,
                  child: Column(
                    children: [
                      // Nome
                      TextFormField(
                        controller: _firstNameController,
                        enabled: _isEditing,
                        decoration: InputDecoration(
                          labelText: l10n.authFirstName,
                          prefixIcon: const Icon(Icons.person_outline),
                        ),
                        textCapitalization: TextCapitalization.words,
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return l10n.authRequiredField;
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),

                      // Cognome
                      TextFormField(
                        controller: _lastNameController,
                        enabled: _isEditing,
                        decoration: InputDecoration(
                          labelText: l10n.authLastName,
                          prefixIcon: const Icon(Icons.person_outline),
                        ),
                        textCapitalization: TextCapitalization.words,
                      ),
                      const SizedBox(height: 16),

                      // Email
                      TextFormField(
                        controller: _emailController,
                        enabled: _isEditing,
                        decoration: InputDecoration(
                          labelText: l10n.authEmail,
                          prefixIcon: const Icon(Icons.email_outlined),
                          helperText: _isEditing
                              ? 'Attenzione: cambiando email dovrai usarla per il login'
                              : null,
                        ),
                        keyboardType: TextInputType.emailAddress,
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return l10n.authRequiredField;
                          }
                          final emailRegex = RegExp(
                            r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                          );
                          if (!emailRegex.hasMatch(value.trim())) {
                            return l10n.authInvalidEmail;
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),

                      // Telefono
                      TextFormField(
                        controller: _phoneController,
                        enabled: _isEditing,
                        decoration: InputDecoration(
                          labelText: l10n.authPhone,
                          prefixIcon: const Icon(Icons.phone_outlined),
                        ),
                        keyboardType: TextInputType.phone,
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 32),

                // Bottoni
                if (_isEditing) ...[
                  Row(
                    children: [
                      Expanded(
                        child: OutlinedButton(
                          onPressed: _isLoading ? null : _cancelEditing,
                          child: Text(l10n.actionCancel),
                        ),
                      ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: FilledButton(
                          onPressed: _isLoading ? null : _saveChanges,
                          child: _isLoading
                              ? const SizedBox(
                                  width: 20,
                                  height: 20,
                                  child: CircularProgressIndicator(
                                    strokeWidth: 2,
                                  ),
                                )
                              : Text(l10n.actionConfirm),
                        ),
                      ),
                    ],
                  ),
                ] else ...[
                  // Link cambio password
                  OutlinedButton.icon(
                    icon: const Icon(Icons.lock_outline),
                    label: Text(l10n.authChangePassword),
                    onPressed: () {
                      final slug = ref.read(routeSlugProvider);
                      context.push('/$slug/change-password');
                    },
                  ),
                ],
              ],
            ),
          ),
        ),
      ),
    );
  }

  String _getInitials(String? firstName, String? lastName) {
    final first = firstName?.isNotEmpty == true ? firstName![0] : '';
    final last = lastName?.isNotEmpty == true ? lastName![0] : '';
    return '$first$last'.toUpperCase();
  }
}
--- FILE: lib/features/auth/presentation/register_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../app/providers/route_slug_provider.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../booking/providers/business_provider.dart';
import '../providers/auth_provider.dart';

class RegisterScreen extends ConsumerStatefulWidget {
  const RegisterScreen({super.key});

  @override
  ConsumerState<RegisterScreen> createState() => _RegisterScreenState();
}

class _RegisterScreenState extends ConsumerState<RegisterScreen> {
  final _formKey = GlobalKey<FormState>();
  final _firstNameController = TextEditingController();
  final _lastNameController = TextEditingController();
  final _emailController = TextEditingController();
  final _phoneController = TextEditingController();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  bool _obscurePassword = true;
  bool _obscureConfirmPassword = true;

  @override
  void dispose() {
    _firstNameController.dispose();
    _lastNameController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  Future<void> _handleRegister() async {
    if (!_formKey.currentState!.validate()) return;

    // Ottieni il businessId dal provider
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(context.l10n.authLoginFailed),
          backgroundColor: Colors.red,
        ),
      );
      return;
    }

    final success = await ref
        .read(authProvider.notifier)
        .register(
          businessId: businessId,
          email: _emailController.text.trim(),
          password: _passwordController.text,
          firstName: _firstNameController.text.trim(),
          lastName: _lastNameController.text.trim(),
          phone: _phoneController.text.trim().isNotEmpty
              ? _phoneController.text.trim()
              : null,
        );

    if (success && mounted) {
      // Segnala al browser che l'autofill √® completato con successo
      TextInput.finishAutofillContext();
      final slug = ref.read(routeSlugProvider);
      context.go('/$slug/booking');
    }
  }

  @override
  Widget build(BuildContext context) {
    final authState = ref.watch(authProvider);
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.pop(),
        ),
        title: Text(l10n.authRegisterTitle),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: AutofillGroup(
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  const SizedBox(height: 16),

                  // Nome
                  TextFormField(
                    controller: _firstNameController,
                    textInputAction: TextInputAction.next,
                    textCapitalization: TextCapitalization.words,
                    autofillHints: const [AutofillHints.givenName],
                    decoration: InputDecoration(
                      labelText: l10n.authFirstName,
                      prefixIcon: const Icon(Icons.person_outline),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // Cognome
                  TextFormField(
                    controller: _lastNameController,
                    textInputAction: TextInputAction.next,
                    textCapitalization: TextCapitalization.words,
                    autofillHints: const [AutofillHints.familyName],
                    decoration: InputDecoration(
                      labelText: l10n.authLastName,
                      prefixIcon: const Icon(Icons.person_outline),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // Email
                  TextFormField(
                    controller: _emailController,
                    keyboardType: TextInputType.emailAddress,
                    textInputAction: TextInputAction.next,
                    autocorrect: false,
                    enableSuggestions: true,
                    autofillHints: const [AutofillHints.email],
                    decoration: InputDecoration(
                      labelText: l10n.authEmail,
                      prefixIcon: const Icon(Icons.email_outlined),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      if (!value.contains('@')) {
                        return l10n.authInvalidEmail;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // Telefono (opzionale)
                  TextFormField(
                    controller: _phoneController,
                    keyboardType: TextInputType.phone,
                    textInputAction: TextInputAction.next,
                    autofillHints: const [AutofillHints.telephoneNumber],
                    decoration: InputDecoration(
                      labelText: '${l10n.authPhone} (opzionale)',
                      prefixIcon: const Icon(Icons.phone_outlined),
                    ),
                  ),
                  const SizedBox(height: 16),

                  // Password
                  TextFormField(
                    controller: _passwordController,
                    obscureText: _obscurePassword,
                    textInputAction: TextInputAction.next,
                    enableSuggestions: false,
                    autocorrect: false,
                    autofillHints: const [AutofillHints.newPassword],
                    decoration: InputDecoration(
                      labelText: l10n.authPassword,
                      prefixIcon: const Icon(Icons.lock_outlined),
                      suffixIcon: IconButton(
                        icon: Icon(
                          _obscurePassword
                              ? Icons.visibility_outlined
                              : Icons.visibility_off_outlined,
                        ),
                        onPressed: () {
                          setState(() => _obscurePassword = !_obscurePassword);
                        },
                      ),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      if (value.length < 6) {
                        return l10n.authInvalidPassword;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // Conferma Password
                  TextFormField(
                    controller: _confirmPasswordController,
                    obscureText: _obscureConfirmPassword,
                    textInputAction: TextInputAction.done,
                    onFieldSubmitted: (_) => _handleRegister(),
                    decoration: InputDecoration(
                      labelText: l10n.authConfirmPassword,
                      prefixIcon: const Icon(Icons.lock_outlined),
                      suffixIcon: IconButton(
                        icon: Icon(
                          _obscureConfirmPassword
                              ? Icons.visibility_outlined
                              : Icons.visibility_off_outlined,
                        ),
                        onPressed: () {
                          setState(
                            () => _obscureConfirmPassword =
                                !_obscureConfirmPassword,
                          );
                        },
                      ),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      if (value != _passwordController.text) {
                        return l10n.authPasswordMismatch;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 24),

                  // Errore
                  if (authState.errorMessage != null) ...[
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: theme.colorScheme.error.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Row(
                        children: [
                          Icon(
                            Icons.error_outline,
                            color: theme.colorScheme.error,
                          ),
                          const SizedBox(width: 8),
                          Expanded(
                            child: Text(
                              l10n.authRegisterFailed,
                              style: TextStyle(color: theme.colorScheme.error),
                            ),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(height: 16),
                  ],

                  // Bottone Registra
                  ElevatedButton(
                    onPressed: authState.isLoading ? null : _handleRegister,
                    child: authState.isLoading
                        ? const SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              color: Colors.white,
                            ),
                          )
                        : Text(l10n.actionRegister),
                  ),
                  const SizedBox(height: 24),

                  // Link login
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Text(l10n.authHaveAccount),
                      TextButton(
                        onPressed: () {
                          final slug = ref.read(routeSlugProvider);
                          context.go('/$slug/login');
                        },
                        child: Text(l10n.actionLogin),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/auth/presentation/change_password_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/l10_extension.dart';
import '../providers/auth_provider.dart';

class ChangePasswordScreen extends ConsumerStatefulWidget {
  const ChangePasswordScreen({super.key});

  @override
  ConsumerState<ChangePasswordScreen> createState() =>
      _ChangePasswordScreenState();
}

class _ChangePasswordScreenState extends ConsumerState<ChangePasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final _currentPasswordController = TextEditingController();
  final _newPasswordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  bool _obscureCurrentPassword = true;
  bool _obscureNewPassword = true;
  bool _obscureConfirmPassword = true;
  bool _isLoading = false;

  @override
  void dispose() {
    _currentPasswordController.dispose();
    _newPasswordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  Future<void> _handleChangePassword() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    final success = await ref
        .read(authProvider.notifier)
        .changePassword(
          currentPassword: _currentPasswordController.text,
          newPassword: _newPasswordController.text,
        );

    setState(() => _isLoading = false);

    if (mounted) {
      if (success) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(context.l10n.authChangePasswordSuccess),
            backgroundColor: Colors.green,
          ),
        );
        context.pop();
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(context.l10n.authChangePasswordError),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.pop(),
        ),
        title: Text(l10n.authChangePasswordTitle),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                const SizedBox(height: 32),

                // Icon
                Icon(
                  Icons.lock_reset,
                  size: 64,
                  color: theme.colorScheme.primary,
                ),
                const SizedBox(height: 32),

                // Current password
                TextFormField(
                  controller: _currentPasswordController,
                  obscureText: _obscureCurrentPassword,
                  textInputAction: TextInputAction.next,
                  decoration: InputDecoration(
                    labelText: l10n.authCurrentPassword,
                    prefixIcon: const Icon(Icons.lock_outlined),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscureCurrentPassword
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(
                          () => _obscureCurrentPassword =
                              !_obscureCurrentPassword,
                        );
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // New password
                TextFormField(
                  controller: _newPasswordController,
                  obscureText: _obscureNewPassword,
                  textInputAction: TextInputAction.next,
                  decoration: InputDecoration(
                    labelText: l10n.authNewPassword,
                    prefixIcon: const Icon(Icons.lock_outlined),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscureNewPassword
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(
                          () => _obscureNewPassword = !_obscureNewPassword,
                        );
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    if (value.length < 8) {
                      return l10n.authPasswordTooShort;
                    }
                    if (!RegExp(r'[A-Z]').hasMatch(value) ||
                        !RegExp(r'[a-z]').hasMatch(value) ||
                        !RegExp(r'[0-9]').hasMatch(value)) {
                      return l10n.authPasswordRequirements;
                    }
                    if (value == _currentPasswordController.text) {
                      return 'La nuova password deve essere diversa';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // Confirm password
                TextFormField(
                  controller: _confirmPasswordController,
                  obscureText: _obscureConfirmPassword,
                  textInputAction: TextInputAction.done,
                  decoration: InputDecoration(
                    labelText: l10n.authConfirmPassword,
                    prefixIcon: const Icon(Icons.lock_outlined),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscureConfirmPassword
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(
                          () => _obscureConfirmPassword =
                              !_obscureConfirmPassword,
                        );
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    if (value != _newPasswordController.text) {
                      return l10n.authPasswordMismatch;
                    }
                    return null;
                  },
                  onFieldSubmitted: (_) => _handleChangePassword(),
                ),
                const SizedBox(height: 32),

                // Submit button
                FilledButton(
                  onPressed: _isLoading ? null : _handleChangePassword,
                  child: _isLoading
                      ? const SizedBox(
                          height: 20,
                          width: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : Text(l10n.actionConfirm),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/auth/presentation/login_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../app/providers/route_slug_provider.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../booking/providers/business_provider.dart';
import '../providers/auth_provider.dart';

class LoginScreen extends ConsumerStatefulWidget {
  const LoginScreen({super.key});

  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends ConsumerState<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _obscurePassword = true;

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _handleLogin() async {
    if (!_formKey.currentState!.validate()) return;

    // Ottieni il businessId dal provider
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId == null) {
      // Se non c'√® un business, mostra errore
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(context.l10n.authLoginFailed),
          backgroundColor: Colors.red,
        ),
      );
      return;
    }

    final success = await ref
        .read(authProvider.notifier)
        .login(
          businessId: businessId,
          email: _emailController.text.trim(),
          password: _passwordController.text,
        );

    if (success && mounted) {
      // Segnala al browser che l'autofill √® completato con successo
      // Questo triggera la richiesta di salvataggio credenziali
      TextInput.finishAutofillContext();
      final slug = ref.read(routeSlugProvider);
      context.go('/$slug/booking');
    }
  }

  @override
  Widget build(BuildContext context) {
    final authState = ref.watch(authProvider);
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.pop(),
        ),
        title: Text(l10n.authLoginTitle),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: AutofillGroup(
            child: Form(
              key: _formKey,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  const SizedBox(height: 32),

                  // Logo o icona
                  Icon(
                    Icons.lock_outline,
                    size: 64,
                    color: theme.colorScheme.primary,
                  ),
                  const SizedBox(height: 32),

                  // Email
                  TextFormField(
                    controller: _emailController,
                    keyboardType: TextInputType.emailAddress,
                    textInputAction: TextInputAction.next,
                    autofocus:
                        true, // Aiuta Safari mobile a riconoscere il form
                    autocorrect: false,
                    enableSuggestions: true,
                    autofillHints: const [
                      AutofillHints.username,
                      AutofillHints.email,
                    ],
                    decoration: InputDecoration(
                      labelText: l10n.authEmail,
                      prefixIcon: const Icon(Icons.email_outlined),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      if (!value.contains('@')) {
                        return l10n.authInvalidEmail;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 16),

                  // Password
                  TextFormField(
                    controller: _passwordController,
                    obscureText: _obscurePassword,
                    textInputAction: TextInputAction.done,
                    enableSuggestions: false,
                    autocorrect: false,
                    autofillHints: const [AutofillHints.password],
                    onFieldSubmitted: (_) => _handleLogin(),
                    decoration: InputDecoration(
                      labelText: l10n.authPassword,
                      prefixIcon: const Icon(Icons.lock_outlined),
                      suffixIcon: IconButton(
                        icon: Icon(
                          _obscurePassword
                              ? Icons.visibility_outlined
                              : Icons.visibility_off_outlined,
                        ),
                        onPressed: () {
                          setState(() => _obscurePassword = !_obscurePassword);
                        },
                      ),
                    ),
                    validator: (value) {
                      if (value == null || value.isEmpty) {
                        return l10n.authRequiredField;
                      }
                      if (value.length < 6) {
                        return l10n.authInvalidPassword;
                      }
                      return null;
                    },
                  ),
                  const SizedBox(height: 8),

                  // Password dimenticata
                  Align(
                    alignment: Alignment.centerRight,
                    child: TextButton(
                      onPressed: () => _showResetPasswordDialog(context, ref),
                      child: Text(l10n.authForgotPassword),
                    ),
                  ),
                  const SizedBox(height: 24),

                  // Errore
                  if (authState.errorMessage != null) ...[
                    Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: theme.colorScheme.error.withOpacity(0.1),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Row(
                        children: [
                          Icon(
                            Icons.error_outline,
                            color: theme.colorScheme.error,
                          ),
                          const SizedBox(width: 8),
                          Expanded(
                            child: Text(
                              l10n.authLoginFailed,
                              style: TextStyle(color: theme.colorScheme.error),
                            ),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(height: 16),
                  ],

                  // Bottone Login
                  ElevatedButton(
                    onPressed: authState.isLoading ? null : _handleLogin,
                    child: authState.isLoading
                        ? const SizedBox(
                            height: 20,
                            width: 20,
                            child: CircularProgressIndicator(
                              strokeWidth: 2,
                              color: Colors.white,
                            ),
                          )
                        : Text(l10n.actionLogin),
                  ),
                  const SizedBox(height: 24),

                  // Link registrazione
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Text(l10n.authNoAccount),
                      TextButton(
                        onPressed: () {
                          final slug = ref.read(routeSlugProvider);
                          context.go('/$slug/register');
                        },
                        child: Text(l10n.actionRegister),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  void _showResetPasswordDialog(BuildContext context, WidgetRef ref) {
    final emailController = TextEditingController();
    final l10n = context.l10n;
    final businessId = ref.read(currentBusinessIdProvider);

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.authResetPasswordTitle),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(l10n.authResetPasswordMessage),
            const SizedBox(height: 16),
            TextField(
              controller: emailController,
              keyboardType: TextInputType.emailAddress,
              decoration: InputDecoration(
                labelText: l10n.authEmail,
                prefixIcon: const Icon(Icons.email_outlined),
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () async {
              final email = emailController.text.trim();
              if (email.isEmpty) return;

              // Chiudi il dialog prima di fare la chiamata
              Navigator.pop(context);

              // Verifica businessId
              if (businessId == null) {
                if (context.mounted) {
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text(l10n.authResetPasswordError),
                      backgroundColor: Colors.red,
                    ),
                  );
                }
                return;
              }

              final success = await ref
                  .read(authProvider.notifier)
                  .resetPassword(businessId: businessId, email: email);

              if (context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text(
                      success
                          ? l10n.authResetPasswordSuccess
                          : l10n.authResetPasswordError,
                    ),
                    backgroundColor: success ? Colors.green : Colors.red,
                  ),
                );
              }
            },
            child: Text(l10n.authResetPasswordSend),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/auth/presentation/reset_password_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/l10_extension.dart';
import '../providers/auth_provider.dart';

class ResetPasswordScreen extends ConsumerStatefulWidget {
  final String token;

  const ResetPasswordScreen({required this.token, super.key});

  @override
  ConsumerState<ResetPasswordScreen> createState() =>
      _ResetPasswordScreenState();
}

class _ResetPasswordScreenState extends ConsumerState<ResetPasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  bool _obscurePassword = true;
  bool _obscureConfirmPassword = true;
  bool _isLoading = false;

  @override
  void dispose() {
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  Future<void> _handleResetPassword() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      await ref
          .read(authProvider.notifier)
          .resetPasswordWithToken(
            token: widget.token,
            newPassword: _passwordController.text,
          );

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(context.l10n.authResetPasswordConfirmSuccess),
            backgroundColor: Colors.green,
          ),
        );
        // Redirect a landing - l'utente dovr√† navigare al business per fare login
        context.go('/');
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(context.l10n.authResetPasswordConfirmError),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.go('/'),
        ),
        title: Text(l10n.authResetPasswordConfirmTitle),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                const SizedBox(height: 32),

                // Icon
                Icon(
                  Icons.lock_reset,
                  size: 64,
                  color: theme.colorScheme.primary,
                ),
                const SizedBox(height: 16),

                // Message
                Text(
                  l10n.authResetPasswordConfirmMessage,
                  style: theme.textTheme.bodyLarge,
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 32),

                // New password
                TextFormField(
                  controller: _passwordController,
                  obscureText: _obscurePassword,
                  textInputAction: TextInputAction.next,
                  decoration: InputDecoration(
                    labelText: l10n.authNewPassword,
                    prefixIcon: const Icon(Icons.lock_outlined),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscurePassword
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(() => _obscurePassword = !_obscurePassword);
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    if (value.length < 8) {
                      return l10n.authPasswordTooShort;
                    }
                    if (!RegExp(r'[A-Z]').hasMatch(value) ||
                        !RegExp(r'[a-z]').hasMatch(value) ||
                        !RegExp(r'[0-9]').hasMatch(value)) {
                      return l10n.authPasswordRequirements;
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // Confirm password
                TextFormField(
                  controller: _confirmPasswordController,
                  obscureText: _obscureConfirmPassword,
                  textInputAction: TextInputAction.done,
                  decoration: InputDecoration(
                    labelText: l10n.authConfirmPassword,
                    prefixIcon: const Icon(Icons.lock_outlined),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscureConfirmPassword
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(
                          () => _obscureConfirmPassword =
                              !_obscureConfirmPassword,
                        );
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    if (value != _passwordController.text) {
                      return l10n.authPasswordMismatch;
                    }
                    return null;
                  },
                  onFieldSubmitted: (_) => _handleResetPassword(),
                ),
                const SizedBox(height: 32),

                // Submit button
                FilledButton(
                  onPressed: _isLoading ? null : _handleResetPassword,
                  child: _isLoading
                      ? const SizedBox(
                          height: 20,
                          width: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        )
                      : Text(l10n.actionConfirm),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/providers/business_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'business_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning
/// Provider per il business corrente (caricato da slug nel path URL)
///
/// L'URL segue il pattern: /{slug}/booking, /{slug}/login, ecc.
/// Il router estrae lo slug e lo aggiorna in routeSlugProvider.
/// Questo provider reagisce ai cambi di slug e carica il business.

@ProviderFor(CurrentBusiness)
const currentBusinessProvider = CurrentBusinessProvider._();

/// Provider per il business corrente (caricato da slug nel path URL)
///
/// L'URL segue il pattern: /{slug}/booking, /{slug}/login, ecc.
/// Il router estrae lo slug e lo aggiorna in routeSlugProvider.
/// Questo provider reagisce ai cambi di slug e carica il business.
final class CurrentBusinessProvider
    extends $AsyncNotifierProvider<CurrentBusiness, Business?> {
  /// Provider per il business corrente (caricato da slug nel path URL)
  ///
  /// L'URL segue il pattern: /{slug}/booking, /{slug}/login, ecc.
  /// Il router estrae lo slug e lo aggiorna in routeSlugProvider.
  /// Questo provider reagisce ai cambi di slug e carica il business.
  const CurrentBusinessProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'currentBusinessProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$currentBusinessHash();

  @$internal
  @override
  CurrentBusiness create() => CurrentBusiness();
}

String _$currentBusinessHash() => r'2f00cc58e347ca0a27ea6647bd55565535f95823';

/// Provider per il business corrente (caricato da slug nel path URL)
///
/// L'URL segue il pattern: /{slug}/booking, /{slug}/login, ecc.
/// Il router estrae lo slug e lo aggiorna in routeSlugProvider.
/// Questo provider reagisce ai cambi di slug e carica il business.

abstract class _$CurrentBusiness extends $AsyncNotifier<Business?> {
  FutureOr<Business?> build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<AsyncValue<Business?>, Business?>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AsyncValue<Business?>, Business?>,
              AsyncValue<Business?>,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Provider per l'ID del business corrente (sincrono, utility)

@ProviderFor(CurrentBusinessId)
const currentBusinessIdProvider = CurrentBusinessIdProvider._();

/// Provider per l'ID del business corrente (sincrono, utility)
final class CurrentBusinessIdProvider
    extends $NotifierProvider<CurrentBusinessId, int?> {
  /// Provider per l'ID del business corrente (sincrono, utility)
  const CurrentBusinessIdProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'currentBusinessIdProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$currentBusinessIdHash();

  @$internal
  @override
  CurrentBusinessId create() => CurrentBusinessId();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(int? value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<int?>(value),
    );
  }
}

String _$currentBusinessIdHash() => r'dbb21b4e931947e9e1f0a0e7d3927a478d463ae0';

/// Provider per l'ID del business corrente (sincrono, utility)

abstract class _$CurrentBusinessId extends $Notifier<int?> {
  int? build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<int?, int?>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<int?, int?>,
              int?,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Provider per verificare se il business slug √® valido
/// (slug presente e business trovato nel database)

@ProviderFor(IsBusinessValid)
const isBusinessValidProvider = IsBusinessValidProvider._();

/// Provider per verificare se il business slug √® valido
/// (slug presente e business trovato nel database)
final class IsBusinessValidProvider
    extends $NotifierProvider<IsBusinessValid, bool> {
  /// Provider per verificare se il business slug √® valido
  /// (slug presente e business trovato nel database)
  const IsBusinessValidProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'isBusinessValidProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$isBusinessValidHash();

  @$internal
  @override
  IsBusinessValid create() => IsBusinessValid();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(bool value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<bool>(value),
    );
  }
}

String _$isBusinessValidHash() => r'4d0814c4ad8b342b9ca7225311cb5e49a929041e';

/// Provider per verificare se il business slug √® valido
/// (slug presente e business trovato nel database)

abstract class _$IsBusinessValid extends $Notifier<bool> {
  bool build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<bool, bool>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<bool, bool>,
              bool,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}

/// Provider semplice per lo slug corrente (letto dal path URL)

@ProviderFor(businessSlug)
const businessSlugProvider = BusinessSlugProvider._();

/// Provider semplice per lo slug corrente (letto dal path URL)

final class BusinessSlugProvider
    extends $FunctionalProvider<String?, String?, String?>
    with $Provider<String?> {
  /// Provider semplice per lo slug corrente (letto dal path URL)
  const BusinessSlugProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'businessSlugProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$businessSlugHash();

  @$internal
  @override
  $ProviderElement<String?> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  String? create(Ref ref) {
    return businessSlug(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(String? value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<String?>(value),
    );
  }
}

String _$businessSlugHash() => r'2b426e8d5b02f0bf413dc03053031703750be5df';

/// Provider per verificare se siamo su un sottodominio business

@ProviderFor(isBusinessSubdomain)
const isBusinessSubdomainProvider = IsBusinessSubdomainProvider._();

/// Provider per verificare se siamo su un sottodominio business

final class IsBusinessSubdomainProvider
    extends $FunctionalProvider<bool, bool, bool>
    with $Provider<bool> {
  /// Provider per verificare se siamo su un sottodominio business
  const IsBusinessSubdomainProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'isBusinessSubdomainProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$isBusinessSubdomainHash();

  @$internal
  @override
  $ProviderElement<bool> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  bool create(Ref ref) {
    return isBusinessSubdomain(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(bool value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<bool>(value),
    );
  }
}

String _$isBusinessSubdomainHash() =>
    r'7af66aeaae959e3aa4b1de252d5328627d90c0a1';
--- FILE: lib/features/booking/providers/my_bookings_provider.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '/core/models/booking_item.dart';
import '/core/network/network_providers.dart';

part 'my_bookings_provider.g.dart';

/// Stato delle prenotazioni utente (upcoming + past)
class MyBookingsState {
  final List<BookingItem> upcoming;
  final List<BookingItem> past;
  final bool isLoading;
  final String? error;

  const MyBookingsState({
    this.upcoming = const [],
    this.past = const [],
    this.isLoading = false,
    this.error,
  });

  MyBookingsState copyWith({
    List<BookingItem>? upcoming,
    List<BookingItem>? past,
    bool? isLoading,
    String? error,
  }) {
    return MyBookingsState(
      upcoming: upcoming ?? this.upcoming,
      past: past ?? this.past,
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
    );
  }
}

@riverpod
class MyBookings extends _$MyBookings {
  @override
  MyBookingsState build() {
    return const MyBookingsState();
  }

  /// Carica le prenotazioni utente da API
  Future<void> loadBookings() async {
    state = state.copyWith(isLoading: true, error: null);

    try {
      final apiClient = ref.read(apiClientProvider);
      final response = await apiClient.getMyBookings();

      final upcomingJson = response['upcoming'] as List<dynamic>? ?? [];
      final pastJson = response['past'] as List<dynamic>? ?? [];

      final upcoming = upcomingJson
          .map((json) => BookingItem.fromJson(json as Map<String, dynamic>))
          .toList();

      final past = pastJson
          .map((json) => BookingItem.fromJson(json as Map<String, dynamic>))
          .toList();

      state = MyBookingsState(upcoming: upcoming, past: past, isLoading: false);
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }

  /// Cancella una prenotazione (DELETE /v1/locations/{location_id}/bookings/{id})
  Future<bool> cancelBooking(int locationId, int bookingId) async {
    try {
      final apiClient = ref.read(apiClientProvider);
      await apiClient.deleteBooking(locationId, bookingId);

      // Rimuovi localmente
      state = state.copyWith(
        upcoming: state.upcoming.where((b) => b.id != bookingId).toList(),
      );
      return true;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return false;
    }
  }

  /// Modifica una prenotazione (PUT /v1/locations/{location_id}/bookings/{id})
  Future<bool> rescheduleBooking({
    required int locationId,
    required int bookingId,
    required String newStartTime,
    String? notes,
  }) async {
    try {
      final apiClient = ref.read(apiClientProvider);
      final updated = await apiClient.updateBooking(
        locationId: locationId,
        bookingId: bookingId,
        startTime: newStartTime,
        notes: notes,
      );

      // Aggiorna localmente
      final updatedBooking = BookingItem.fromJson(updated);
      state = state.copyWith(
        upcoming: state.upcoming
            .map((b) => b.id == bookingId ? updatedBooking : b)
            .toList(),
      );
      return true;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return false;
    }
  }
}
--- FILE: lib/features/booking/providers/booking_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod/legacy.dart';

import '../../../core/models/booking_request.dart';
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/models/staff.dart';
import '../../../core/models/time_slot.dart';
import '../../../core/network/network_providers.dart';
import '../data/booking_repository.dart';
import '../domain/booking_config.dart';
import 'business_provider.dart';
import 'locations_provider.dart';

/// Provider per il repository
final bookingRepositoryProvider = Provider<BookingRepository>((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return BookingRepository(apiClient);
});

/// Provider per la configurazione del booking (dinamico basato sul business corrente)
final bookingConfigProvider = Provider<BookingConfig>((ref) {
  final businessAsync = ref.watch(currentBusinessProvider);

  // Se il business √® ancora in caricamento o ha errori, ritorna placeholder
  if (businessAsync.isLoading || businessAsync.hasError) {
    return placeholderBookingConfig;
  }

  final business = businessAsync.value;
  if (business == null) {
    // Business non trovato (slug non valido)
    return placeholderBookingConfig;
  }

  // Se il business non ha una location di default, segnala che esiste ma non √® attivo
  final locationId = business.defaultLocationId;
  if (locationId == null) {
    return BookingConfig(
      allowStaffSelection: true,
      businessId: business.id,
      locationId: 0,
      businessExistsButNotActive: true,
    );
  }

  return BookingConfig(
    allowStaffSelection: true,
    businessId: business.id,
    locationId: locationId,
  );
});

/// Provider per la location ID effettiva (da location selezionata o default)
final effectiveLocationIdProvider = Provider<int>((ref) {
  final effectiveLocation = ref.watch(effectiveLocationProvider);
  if (effectiveLocation != null) {
    return effectiveLocation.id;
  }
  // Fallback alla config
  return ref.watch(bookingConfigProvider).locationId;
});

/// Step del flow di prenotazione
enum BookingStep { location, services, staff, dateTime, summary, confirmation }

/// Stato del flow di prenotazione
class BookingFlowState {
  final BookingStep currentStep;
  final BookingRequest request;
  final bool isLoading;
  final String? errorMessage;
  final String? confirmedBookingId;

  const BookingFlowState({
    this.currentStep = BookingStep.location,
    this.request = const BookingRequest(),
    this.isLoading = false,
    this.errorMessage,
    this.confirmedBookingId,
  });

  bool get canGoBack =>
      currentStep.index > 0 && currentStep != BookingStep.confirmation;

  bool get canGoNext {
    switch (currentStep) {
      case BookingStep.location:
        return true; // Gestito dal provider
      case BookingStep.services:
        return request.services.isNotEmpty;
      case BookingStep.staff:
        return true; // Staff opzionale
      case BookingStep.dateTime:
        return request.selectedSlot != null;
      case BookingStep.summary:
        return request.isComplete;
      case BookingStep.confirmation:
        return false;
    }
  }

  BookingFlowState copyWith({
    BookingStep? currentStep,
    BookingRequest? request,
    bool? isLoading,
    String? errorMessage,
    String? confirmedBookingId,
    bool clearError = false,
  }) => BookingFlowState(
    currentStep: currentStep ?? this.currentStep,
    request: request ?? this.request,
    isLoading: isLoading ?? this.isLoading,
    errorMessage: clearError ? null : (errorMessage ?? this.errorMessage),
    confirmedBookingId: confirmedBookingId ?? this.confirmedBookingId,
  );
}

/// Provider principale per il flow di prenotazione
final bookingFlowProvider =
    NotifierProvider<BookingFlowNotifier, BookingFlowState>(
      BookingFlowNotifier.new,
    );

class BookingFlowNotifier extends Notifier<BookingFlowState> {
  @override
  BookingFlowState build() {
    // Determina lo step iniziale in base al numero di locations
    final hasMultipleLocations = ref.watch(hasMultipleLocationsProvider);
    final initialStep = hasMultipleLocations
        ? BookingStep.location
        : BookingStep.services;
    return BookingFlowState(currentStep: initialStep);
  }

  BookingRepository get _repository => ref.read(bookingRepositoryProvider);
  BookingConfig get _config => ref.read(bookingConfigProvider);
  bool get _hasMultipleLocations => ref.read(hasMultipleLocationsProvider);

  /// Reset del flow
  void reset() {
    final initialStep = _hasMultipleLocations
        ? BookingStep.location
        : BookingStep.services;
    state = BookingFlowState(currentStep: initialStep);
    // Reset anche la location selezionata
    ref.read(selectedLocationProvider.notifier).clear();
  }

  /// Vai allo step successivo
  void nextStep() {
    if (!state.canGoNext) return;

    final nextIndex = state.currentStep.index + 1;
    if (nextIndex < BookingStep.values.length) {
      var nextStep = BookingStep.values[nextIndex];

      // Se c'√® una sola location, salta lo step location
      if (nextStep == BookingStep.location && !_hasMultipleLocations) {
        nextStep = BookingStep.services;
      }

      // Se staff selection √® disabilitata, salta lo step staff
      if (nextStep == BookingStep.staff && !_config.allowStaffSelection) {
        nextStep = BookingStep.dateTime;
      }
      state = state.copyWith(currentStep: nextStep);
    }
  }

  /// Vai allo step precedente
  void previousStep() {
    if (!state.canGoBack) return;

    var prevIndex = state.currentStep.index - 1;
    var prevStep = BookingStep.values[prevIndex];

    // Se staff selection √® disabilitata, salta lo step staff
    if (prevStep == BookingStep.staff && !_config.allowStaffSelection) {
      prevIndex--;
      prevStep = BookingStep.values[prevIndex];
    }

    // Se c'√® una sola location, salta lo step location
    if (prevStep == BookingStep.location && !_hasMultipleLocations) {
      // Non andare oltre, siamo gi√† al primo step
      return;
    }

    state = state.copyWith(currentStep: prevStep);
  }

  /// Vai a uno step specifico
  void goToStep(BookingStep step) {
    // Non permettere di tornare allo step location se c'√® una sola location
    if (step == BookingStep.location && !_hasMultipleLocations) {
      return;
    }
    if (step.index < state.currentStep.index) {
      state = state.copyWith(currentStep: step);
    }
  }

  /// Toggle selezione servizio
  void toggleService(Service service) {
    final currentServices = List<Service>.from(state.request.services);

    if (currentServices.any((s) => s.id == service.id)) {
      currentServices.removeWhere((s) => s.id == service.id);
    } else {
      currentServices.add(service);
    }

    // Quando cambiano i servizi, resetta slot selezionato
    state = state.copyWith(
      request: state.request.copyWith(
        services: currentServices,
        clearSlot: true,
      ),
    );
  }

  /// Seleziona staff
  void selectStaff(Staff? staff) {
    state = state.copyWith(
      request: state.request.copyWith(
        selectedStaff: staff,
        clearStaff: staff == null,
        clearSlot: true, // Resetta slot quando cambia staff
      ),
    );
  }

  /// Seleziona slot temporale
  void selectTimeSlot(TimeSlot slot) {
    state = state.copyWith(request: state.request.copyWith(selectedSlot: slot));
  }

  /// Aggiorna note
  void updateNotes(String notes) {
    state = state.copyWith(request: state.request.copyWith(notes: notes));
  }

  /// Conferma prenotazione
  Future<bool> confirmBooking() async {
    if (!state.request.isComplete) return false;

    state = state.copyWith(isLoading: true, clearError: true);

    try {
      // Usa la location effettiva (selezionata o default)
      final locationId = ref.read(effectiveLocationIdProvider);

      final result = await _repository.confirmBooking(
        locationId: locationId,
        serviceIds: state.request.services.map((s) => s.id).toList(),
        startTime: state.request.selectedSlot!.startTime,
        staffId: state.request.selectedStaff?.id,
        notes: state.request.notes,
      );

      // Estrai booking ID dalla risposta
      final bookingId =
          result['id']?.toString() ??
          result['booking_id']?.toString() ??
          'confirmed';

      state = state.copyWith(
        isLoading: false,
        currentStep: BookingStep.confirmation,
        confirmedBookingId: bookingId,
      );
      return true;
    } catch (e) {
      state = state.copyWith(isLoading: false, errorMessage: e.toString());
      return false;
    }
  }
}

/// Dati servizi (categories + services in un'unica chiamata API)
class ServicesData {
  final List<ServiceCategory> categories;
  final List<Service> services;

  const ServicesData({required this.categories, required this.services});

  /// Servizi prenotabili online
  List<Service> get bookableServices =>
      services.where((s) => s.isBookableOnline).toList();

  bool get isEmpty => bookableServices.isEmpty;
}

/// Notifier per gestire il caricamento dei servizi con controllo TOTALE sullo stato
class ServicesDataNotifier extends StateNotifier<AsyncValue<ServicesData>> {
  final Ref _ref;
  bool _hasFetched = false;
  int? _lastLocationId;

  ServicesDataNotifier(this._ref) : super(const AsyncValue.loading()) {
    // Ascolta cambiamenti della location effettiva
    _ref.listen(effectiveLocationIdProvider, (previous, next) {
      if (next > 0 && next != _lastLocationId) {
        _hasFetched = false;
        _lastLocationId = next;
        _loadData();
      }
    }, fireImmediately: true);
  }

  Future<void> _loadData() async {
    if (_hasFetched) return;

    final locationId = _ref.read(effectiveLocationIdProvider);
    if (locationId <= 0) return;

    _hasFetched = true;

    try {
      final repository = _ref.read(bookingRepositoryProvider);

      final result = await repository.getCategoriesWithServices(locationId);

      final sortedCategories = List<ServiceCategory>.from(result.categories)
        ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));
      final sortedServices = List<Service>.from(result.services)
        ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));

      state = AsyncValue.data(
        ServicesData(categories: sortedCategories, services: sortedServices),
      );
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }

  /// Forza il refresh dei dati (per retry manuale)
  Future<void> refresh() async {
    _hasFetched = false;
    state = const AsyncValue.loading();
    await _loadData();
  }
}

/// Provider unico per categorie e servizi (UNA sola chiamata API)
final servicesDataProvider =
    StateNotifierProvider<ServicesDataNotifier, AsyncValue<ServicesData>>(
      (ref) => ServicesDataNotifier(ref),
    );

/// Provider per le categorie (legacy - usa servicesDataProvider)
final categoriesProvider = FutureProvider<List<ServiceCategory>>((ref) async {
  final asyncData = ref.watch(servicesDataProvider);
  return asyncData.whenData((data) => data.categories).value ?? [];
});

/// Provider per i servizi (legacy - usa servicesDataProvider)
final servicesProvider = FutureProvider<List<Service>>((ref) async {
  final asyncData = ref.watch(servicesDataProvider);
  return asyncData.whenData((data) => data.services).value ?? [];
});

/// Notifier per lo staff con protezione da loop
class StaffDataNotifier extends StateNotifier<AsyncValue<List<Staff>>> {
  final Ref _ref;
  bool _hasFetched = false;
  int? _lastLocationId;

  StaffDataNotifier(this._ref) : super(const AsyncValue.loading()) {
    // Ascolta cambiamenti della location effettiva
    _ref.listen(effectiveLocationIdProvider, (previous, next) {
      if (next > 0 && next != _lastLocationId) {
        _hasFetched = false;
        _lastLocationId = next;
        _loadData();
      }
    }, fireImmediately: true);
  }

  Future<void> _loadData() async {
    if (_hasFetched) return;

    final locationId = _ref.read(effectiveLocationIdProvider);
    if (locationId <= 0) return;

    _hasFetched = true;

    try {
      final repository = _ref.read(bookingRepositoryProvider);
      final staff = await repository.getStaff(locationId);
      final sortedStaff = List<Staff>.from(staff)
        ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));
      state = AsyncValue.data(sortedStaff);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }

  Future<void> refresh() async {
    _hasFetched = false;
    state = const AsyncValue.loading();
    await _loadData();
  }
}

/// Provider per lo staff
final staffProvider =
    StateNotifierProvider<StaffDataNotifier, AsyncValue<List<Staff>>>(
      (ref) => StaffDataNotifier(ref),
    );

/// Provider per la data selezionata nel calendario
final selectedDateProvider = StateProvider<DateTime?>((ref) => null);

/// Provider per gli slot disponibili
final availableSlotsProvider = FutureProvider<List<TimeSlot>>((ref) async {
  final repository = ref.read(bookingRepositoryProvider);
  final locationId = ref.watch(effectiveLocationIdProvider);
  final bookingState = ref.watch(bookingFlowProvider);
  final selectedDate = ref.watch(selectedDateProvider);

  if (locationId <= 0 ||
      selectedDate == null ||
      bookingState.request.services.isEmpty) {
    return [];
  }

  return repository.getAvailableSlots(
    locationId: locationId,
    date: selectedDate,
    serviceIds: bookingState.request.services.map((s) => s.id).toList(),
    staffId: bookingState.request.selectedStaff?.id,
  );
});

/// Provider per la prima data disponibile
final firstAvailableDateProvider = FutureProvider<DateTime>((ref) async {
  final repository = ref.read(bookingRepositoryProvider);
  final locationId = ref.watch(effectiveLocationIdProvider);
  final bookingState = ref.watch(bookingFlowProvider);

  if (locationId <= 0) {
    return DateTime.now().add(const Duration(days: 1));
  }

  return repository.getFirstAvailableDate(
    locationId: locationId,
    serviceIds: bookingState.request.services.map((s) => s.id).toList(),
    staffId: bookingState.request.selectedStaff?.id,
  );
});
--- FILE: lib/features/booking/providers/business_provider.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../app/providers/route_slug_provider.dart';
import '../../../core/models/business.dart';
import '../../../core/network/api_client.dart';
import '../../../core/network/network_providers.dart';

part 'business_provider.g.dart';

/// Provider per il business corrente (caricato da slug nel path URL)
///
/// L'URL segue il pattern: /{slug}/booking, /{slug}/login, ecc.
/// Il router estrae lo slug e lo aggiorna in routeSlugProvider.
/// Questo provider reagisce ai cambi di slug e carica il business.
@riverpod
class CurrentBusiness extends _$CurrentBusiness {
  String? _lastSlug;
  Business? _cachedBusiness;
  Object? _cachedError;

  @override
  Future<Business?> build() async {
    // Legge lo slug dal path URL (gestito dal router)
    final slug = ref.watch(routeSlugProvider);

    // Se lo slug non √® cambiato, ritorna la cache
    if (_lastSlug == slug && _cachedBusiness != null) {
      return _cachedBusiness;
    }

    // Se c'era un errore per questo slug, rilancia
    if (_lastSlug == slug && _cachedError != null) {
      throw _cachedError!;
    }

    _lastSlug = slug;
    _cachedBusiness = null;
    _cachedError = null;

    if (slug == null) {
      // Nessun slug nel path ‚Üí landing page
      return null;
    }

    final apiClient = ref.watch(apiClientProvider);

    try {
      final data = await apiClient.getBusinessBySlug(slug);
      _cachedBusiness = Business.fromJson(data);
      return _cachedBusiness;
    } on ApiException catch (e) {
      if (e.statusCode == 404) {
        // Business non trovato - slug non valido
        // Non √® un errore, ritorna null e l'app mostrer√† "business non trovato"
        _cachedBusiness = null;
        return null;
      }
      _cachedError = e;
      rethrow;
    } catch (e) {
      _cachedError = e;
      rethrow;
    }
  }

  /// Ricarica il business corrente (forza refresh)
  Future<void> refresh() async {
    _lastSlug = null;
    _cachedBusiness = null;
    _cachedError = null;
    ref.invalidateSelf();
  }
}

/// Provider per l'ID del business corrente (sincrono, utility)
@riverpod
class CurrentBusinessId extends _$CurrentBusinessId {
  @override
  int? build() {
    final businessAsync = ref.watch(currentBusinessProvider);
    return businessAsync.value?.id;
  }
}

/// Provider per verificare se il business slug √® valido
/// (slug presente e business trovato nel database)
@riverpod
class IsBusinessValid extends _$IsBusinessValid {
  @override
  bool build() {
    final slug = ref.watch(routeSlugProvider);

    if (slug == null) {
      // Nessun slug nel path ‚Üí landing page, non √® un errore
      return true;
    }

    // Se c'√® uno slug, verifica che il business esista
    final businessAsync = ref.watch(currentBusinessProvider);
    return businessAsync.value != null;
  }
}

/// Provider semplice per lo slug corrente (letto dal path URL)
@riverpod
String? businessSlug(Ref ref) {
  return ref.watch(routeSlugProvider);
}

/// Provider per verificare se siamo su un sottodominio business
@riverpod
bool isBusinessSubdomain(Ref ref) {
  return ref.watch(businessSlugProvider) != null;
}
--- FILE: lib/features/booking/providers/my_bookings_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'my_bookings_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(MyBookings)
const myBookingsProvider = MyBookingsProvider._();

final class MyBookingsProvider
    extends $NotifierProvider<MyBookings, MyBookingsState> {
  const MyBookingsProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'myBookingsProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$myBookingsHash();

  @$internal
  @override
  MyBookings create() => MyBookings();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(MyBookingsState value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<MyBookingsState>(value),
    );
  }
}

String _$myBookingsHash() => r'c1c0e43f3b187527bcf855f1e9451fb613e1ddd5';

abstract class _$MyBookings extends $Notifier<MyBookingsState> {
  MyBookingsState build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<MyBookingsState, MyBookingsState>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<MyBookingsState, MyBookingsState>,
              MyBookingsState,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/features/booking/providers/locations_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod/legacy.dart';

import '../../../core/models/location.dart';
import 'booking_provider.dart';
import 'business_provider.dart';

/// Provider per la location ID passata via URL (?location=4)
/// Se valorizzato, lo step location viene saltato
final urlLocationIdProvider = StateProvider<int?>((ref) => null);

/// Provider per le locations del business corrente
final locationsProvider =
    NotifierProvider<LocationsNotifier, AsyncValue<List<Location>>>(
      LocationsNotifier.new,
    );

class LocationsNotifier extends Notifier<AsyncValue<List<Location>>> {
  bool _hasFetched = false;
  int? _lastBusinessId;

  @override
  AsyncValue<List<Location>> build() {
    // Ascolta cambiamenti del business
    ref.listen(currentBusinessProvider, (previous, next) {
      if (next.hasValue && next.value != null) {
        final businessId = next.value!.id;
        if (businessId != _lastBusinessId) {
          _hasFetched = false;
          _lastBusinessId = businessId;
          _loadLocations(businessId);
        }
      }
    }, fireImmediately: true);

    return const AsyncValue.loading();
  }

  Future<void> _loadLocations(int businessId) async {
    if (_hasFetched) return;
    _hasFetched = true;

    state = const AsyncValue.loading();

    try {
      final repo = ref.read(bookingRepositoryProvider);
      final locations = await repo.getLocations(businessId);
      state = AsyncValue.data(locations);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }

  Future<void> refresh() async {
    final business = ref.read(currentBusinessProvider).value;
    if (business == null) return;

    _hasFetched = false;
    await _loadLocations(business.id);
  }
}

/// Provider per la location selezionata dall'utente
class SelectedLocationNotifier extends Notifier<Location?> {
  @override
  Location? build() => null;

  void select(Location location) {
    state = location;
  }

  void clear() {
    state = null;
  }
}

final selectedLocationProvider =
    NotifierProvider<SelectedLocationNotifier, Location?>(
      SelectedLocationNotifier.new,
    );

/// Provider derivato: true se ci sono multiple locations E nessuna location pre-selezionata via URL
/// Se urlLocationIdProvider √® valorizzato, consideriamo come "singola location" (step saltato)
final hasMultipleLocationsProvider = Provider<bool>((ref) {
  // Se c'√® una location passata via URL, non mostrare lo step location
  final urlLocationId = ref.watch(urlLocationIdProvider);
  if (urlLocationId != null) {
    return false;
  }

  final locationsAsync = ref.watch(locationsProvider);
  return locationsAsync.maybeWhen(
    data: (locations) => locations.length > 1,
    orElse: () => false,
  );
});

/// Provider derivato: la location effettiva da usare per il booking
/// Priorit√†: 1) URL param, 2) Selezione utente, 3) Location singola/default
final effectiveLocationProvider = Provider<Location?>((ref) {
  final locationsAsync = ref.watch(locationsProvider);
  final urlLocationId = ref.watch(urlLocationIdProvider);
  final selectedLocation = ref.watch(selectedLocationProvider);

  return locationsAsync.maybeWhen(
    data: (locations) {
      if (locations.isEmpty) return null;

      // 1) Se c'√® location da URL, cerca quella
      if (urlLocationId != null) {
        final urlLocation = locations
            .where((l) => l.id == urlLocationId)
            .firstOrNull;
        if (urlLocation != null) return urlLocation;
        // Se non trovata, fallback a default
      }

      // 2) Se c'√® una sola location, usa quella
      if (locations.length == 1) return locations.first;

      // 3) Usa la selezione dell'utente
      return selectedLocation;
    },
    orElse: () => null,
  );
});
--- FILE: lib/features/booking/data/booking_repository.dart ---
import 'package:uuid/uuid.dart';

import '../../../core/models/location.dart';
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/models/staff.dart';
import '../../../core/models/time_slot.dart';
import '../../../core/network/api_client.dart';

/// Repository per le prenotazioni - API reale
class BookingRepository {
  final ApiClient _apiClient;
  final Uuid _uuid = const Uuid();

  BookingRepository(this._apiClient);

  /// GET /v1/businesses/{business_id}/locations/public
  /// Recupera le locations attive di un business
  Future<List<Location>> getLocations(int businessId) async {
    final data = await _apiClient.getBusinessLocations(businessId);
    final locationsJson = data['data'] as List<dynamic>? ?? [];

    return locationsJson
        .map((json) => Location.fromJson(json as Map<String, dynamic>))
        .toList();
  }

  /// GET /v1/services?location_id=X
  /// Recupera categorie e servizi in un'unica chiamata
  Future<({List<ServiceCategory> categories, List<Service> services})>
  getCategoriesWithServices(int locationId) async {
    final data = await _apiClient.getServices(locationId);
    final categoriesJson = data['categories'] as List<dynamic>? ?? [];

    final categories = <ServiceCategory>[];
    final services = <Service>[];

    for (final json in categoriesJson) {
      final catJson = json as Map<String, dynamic>;
      categories.add(ServiceCategory.fromJson(catJson));

      final catId = catJson['id'] as int;
      final servicesJson = catJson['services'] as List<dynamic>? ?? [];

      for (final svcJson in servicesJson) {
        final svc = svcJson as Map<String, dynamic>;
        if (!svc.containsKey('category_id')) {
          svc['category_id'] = catId;
        }
        services.add(Service.fromJson(svc));
      }
    }

    return (categories: categories, services: services);
  }

  /// GET /v1/services?location_id=X
  /// Recupera categorie con servizi annidati (legacy)
  Future<List<ServiceCategory>> getCategories(int locationId) async {
    final result = await getCategoriesWithServices(locationId);
    return result.categories;
  }

  /// GET /v1/services?location_id=X
  /// Recupera tutti i servizi (flat list) (legacy)
  Future<List<Service>> getServices(int locationId) async {
    final result = await getCategoriesWithServices(locationId);
    return result.services;
  }

  /// GET /v1/staff?location_id=X
  /// Recupera staff prenotabili online
  Future<List<Staff>> getStaff(int locationId) async {
    final data = await _apiClient.getStaff(locationId);

    // Formato atteso: { "staff": [...] }
    final staffJson = data['staff'] as List<dynamic>? ?? [];

    return staffJson.map((json) {
      final staffData = json as Map<String, dynamic>;
      // Mappa display_name se presente
      if (staffData.containsKey('display_name') &&
          !staffData.containsKey('name')) {
        final displayName = staffData['display_name'] as String;
        final parts = displayName.split(' ');
        staffData['name'] = parts.isNotEmpty ? parts.first : displayName;
        staffData['surname'] = parts.length > 1
            ? parts.sublist(1).join(' ')
            : '';
      }
      // Default business_id se non presente
      if (!staffData.containsKey('business_id')) {
        staffData['business_id'] = 1;
      }
      return Staff.fromJson(staffData);
    }).toList();
  }

  /// GET /v1/availability?location_id=X&date=YYYY-MM-DD&service_ids=1,2&staff_id=N
  /// Recupera slot disponibili
  Future<List<TimeSlot>> getAvailableSlots({
    required int locationId,
    required DateTime date,
    required List<int> serviceIds,
    int? staffId,
  }) async {
    if (serviceIds.isEmpty) return [];

    final dateStr =
        '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';

    final data = await _apiClient.getAvailability(
      locationId: locationId,
      date: dateStr,
      serviceIds: serviceIds,
      staffId: staffId,
    );

    final slotsJson = data['slots'] as List<dynamic>? ?? [];

    return slotsJson.map((json) {
      return TimeSlot.fromJson(json as Map<String, dynamic>);
    }).toList();
  }

  /// Trova la prima data con disponibilit√†
  /// Cerca nei prossimi 30 giorni
  Future<DateTime> getFirstAvailableDate({
    required int locationId,
    required List<int> serviceIds,
    int? staffId,
  }) async {
    if (serviceIds.isEmpty) {
      return DateTime.now().add(const Duration(days: 1));
    }

    final now = DateTime.now();
    var checkDate = DateTime(now.year, now.month, now.day);

    // Se oggi √® gi√† tardi, inizia da domani
    if (now.hour >= 18) {
      checkDate = checkDate.add(const Duration(days: 1));
    }

    // Cerca nei prossimi 30 giorni
    for (var i = 0; i < 30; i++) {
      try {
        final slots = await getAvailableSlots(
          locationId: locationId,
          date: checkDate,
          serviceIds: serviceIds,
          staffId: staffId,
        );

        if (slots.isNotEmpty) {
          return checkDate;
        }
      } catch (_) {
        // Ignora errori e prova il giorno successivo
      }
      checkDate = checkDate.add(const Duration(days: 1));
    }

    // Fallback: domani
    return DateTime(now.year, now.month, now.day + 1);
  }

  /// POST /v1/locations/{location_id}/bookings
  /// Conferma prenotazione
  ///
  /// Ritorna i dati del booking creato
  /// Throws ApiException con code='slot_conflict' se slot occupato
  Future<Map<String, dynamic>> confirmBooking({
    required int locationId,
    required List<int> serviceIds,
    required DateTime startTime,
    int? staffId,
    String? notes,
    String? idempotencyKey,
  }) async {
    // Genera idempotency key se non fornita
    final key = idempotencyKey ?? _uuid.v4();

    return _apiClient.createBooking(
      locationId: locationId,
      idempotencyKey: key,
      serviceIds: serviceIds,
      startTime: startTime.toUtc().toIso8601String(),
      staffId: staffId,
      notes: notes,
    );
  }

  /// Genera un nuovo idempotency key (UUID v4)
  String generateIdempotencyKey() => _uuid.v4();
}
--- FILE: lib/features/booking/domain/booking_config.dart ---
/// Configurazione per il flow di prenotazione
class BookingConfig {
  /// Consente all'utente di scegliere l'operatore
  final bool allowStaffSelection;

  /// ID del business
  final int businessId;

  /// ID della location (sede)
  final int locationId;

  /// True se il business esiste ma non ha location configurata
  final bool businessExistsButNotActive;

  const BookingConfig({
    this.allowStaffSelection = true,
    required this.businessId,
    required this.locationId,
    this.businessExistsButNotActive = false,
  });

  /// Crea una config valida solo se businessId e locationId sono noti
  bool get isValid => businessId > 0 && locationId > 0;
}

/// Config placeholder usata quando il business non √® ancora caricato.
/// NON usare direttamente - serve solo come fallback temporaneo.
const placeholderBookingConfig = BookingConfig(
  allowStaffSelection: true,
  businessId: 0,
  locationId: 0,
);
--- FILE: lib/features/booking/presentation/screens/staff_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/staff.dart';
import '../../providers/booking_provider.dart';

class StaffStep extends ConsumerWidget {
  const StaffStep({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final staffAsync = ref.watch(staffProvider);
    final bookingState = ref.watch(bookingFlowProvider);
    final selectedStaff = bookingState.request.selectedStaff;

    return Column(
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                l10n.staffTitle,
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                l10n.staffSubtitle,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurface.withOpacity(0.7),
                ),
              ),
            ],
          ),
        ),

        // Lista staff
        Expanded(
          child: staffAsync.when(
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (e, _) => Center(child: Text(l10n.errorLoadingStaff)),
            data: (staffList) => ListView(
              padding: const EdgeInsets.symmetric(horizontal: 16),
              children: [
                // Opzione "Qualsiasi operatore"
                _StaffTile(
                  staff: null,
                  isSelected: selectedStaff == null,
                  onTap: () {
                    ref.read(bookingFlowProvider.notifier).selectStaff(null);
                  },
                ),
                const SizedBox(height: 8),
                // Lista operatori
                ...staffList
                    .where((s) => s.isBookableOnline)
                    .map(
                      (staff) => Padding(
                        padding: const EdgeInsets.only(bottom: 8),
                        child: _StaffTile(
                          staff: staff,
                          isSelected: selectedStaff?.id == staff.id,
                          onTap: () {
                            ref
                                .read(bookingFlowProvider.notifier)
                                .selectStaff(staff);
                          },
                        ),
                      ),
                    ),
              ],
            ),
          ),
        ),

        // Footer con bottone
        _buildFooter(context, ref),
      ],
    );
  }

  Widget _buildFooter(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, -5),
          ),
        ],
      ),
      child: SafeArea(
        child: ElevatedButton(
          onPressed: () => ref.read(bookingFlowProvider.notifier).nextStep(),
          child: Text(l10n.actionNext),
        ),
      ),
    );
  }
}

class _StaffTile extends StatelessWidget {
  final Staff? staff;
  final bool isSelected;
  final VoidCallback onTap;

  const _StaffTile({
    required this.staff,
    required this.isSelected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    return Card(
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(
          color: isSelected ? theme.colorScheme.primary : theme.dividerColor,
          width: isSelected ? 2 : 1,
        ),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Avatar
              CircleAvatar(
                radius: 24,
                backgroundColor: staff == null
                    ? theme.colorScheme.primary.withOpacity(0.1)
                    : theme.colorScheme.secondary.withOpacity(0.1),
                child: staff == null
                    ? Icon(Icons.groups, color: theme.colorScheme.primary)
                    : Text(
                        staff!.initials,
                        style: TextStyle(
                          color: theme.colorScheme.secondary,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
              ),
              const SizedBox(width: 16),
              // Info
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      staff?.displayName ?? l10n.staffAnyOperator,
                      style: theme.textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    if (staff == null) ...[
                      const SizedBox(height: 4),
                      Text(
                        l10n.staffAnyOperatorSubtitle,
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.6),
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              // Radio
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected
                      ? theme.colorScheme.primary
                      : Colors.transparent,
                  border: Border.all(
                    color: isSelected
                        ? theme.colorScheme.primary
                        : theme.colorScheme.onSurface.withOpacity(0.3),
                    width: 2,
                  ),
                ),
                child: isSelected
                    ? const Icon(Icons.check, size: 16, color: Colors.white)
                    : null,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/summary_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../providers/booking_provider.dart';

class SummaryStep extends ConsumerStatefulWidget {
  const SummaryStep({super.key});

  @override
  ConsumerState<SummaryStep> createState() => _SummaryStepState();
}

class _SummaryStepState extends ConsumerState<SummaryStep> {
  final _notesController = TextEditingController();

  @override
  void dispose() {
    _notesController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final bookingState = ref.watch(bookingFlowProvider);
    final request = bookingState.request;

    return Column(
      children: [
        Expanded(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Header
                Text(
                  l10n.summaryTitle,
                  style: theme.textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  l10n.summarySubtitle,
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.onSurface.withOpacity(0.7),
                  ),
                ),
                const SizedBox(height: 24),

                // Servizi selezionati
                _SummarySection(
                  title: l10n.summaryServices,
                  icon: Icons.list_alt,
                  child: Column(
                    children: request.services.map((service) {
                      return Padding(
                        padding: const EdgeInsets.symmetric(vertical: 4),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    service.name,
                                    style: theme.textTheme.bodyMedium,
                                  ),
                                  Text(
                                    l10n.durationMinutes(
                                      service.durationMinutes,
                                    ),
                                    style: theme.textTheme.bodySmall?.copyWith(
                                      color: theme.colorScheme.onSurface
                                          .withOpacity(0.6),
                                    ),
                                  ),
                                ],
                              ),
                            ),
                            Text(
                              service.formattedPrice,
                              style: theme.textTheme.bodyMedium?.copyWith(
                                fontWeight: FontWeight.w600,
                              ),
                            ),
                          ],
                        ),
                      );
                    }).toList(),
                  ),
                ),
                const SizedBox(height: 16),

                // Operatore
                if (request.selectedStaff != null)
                  _SummarySection(
                    title: l10n.summaryOperator,
                    icon: Icons.person,
                    child: Row(
                      children: [
                        CircleAvatar(
                          radius: 20,
                          backgroundColor: theme.colorScheme.primary
                              .withOpacity(0.1),
                          child: Text(
                            request.selectedStaff!.initials,
                            style: TextStyle(
                              color: theme.colorScheme.primary,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                        const SizedBox(width: 12),
                        Text(
                          request.selectedStaff!.displayName,
                          style: theme.textTheme.bodyMedium,
                        ),
                      ],
                    ),
                  ),
                if (request.selectedStaff != null) const SizedBox(height: 16),

                // Data e ora
                if (request.selectedSlot != null)
                  _SummarySection(
                    title: l10n.summaryDateTime,
                    icon: Icons.calendar_today,
                    child: Text(
                      DateFormat(
                        "EEEE d MMMM yyyy 'alle' HH:mm",
                        'it',
                      ).format(request.selectedSlot!.startTime),
                      style: theme.textTheme.bodyMedium,
                    ),
                  ),
                if (request.selectedSlot != null) const SizedBox(height: 16),

                // Durata totale
                _SummarySection(
                  title: l10n.summaryDuration,
                  icon: Icons.schedule,
                  child: Text(
                    l10n.durationMinutes(request.totalDurationMinutes),
                    style: theme.textTheme.bodyMedium,
                  ),
                ),
                const SizedBox(height: 16),

                // Prezzo totale
                _SummarySection(
                  title: l10n.summaryPrice,
                  icon: Icons.euro,
                  child: Text(
                    request.formattedTotalPrice,
                    style: theme.textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: theme.colorScheme.primary,
                    ),
                  ),
                ),
                const SizedBox(height: 24),

                // Note
                Text(
                  l10n.summaryNotes,
                  style: theme.textTheme.titleSmall?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 8),
                TextField(
                  controller: _notesController,
                  maxLines: 3,
                  decoration: InputDecoration(
                    hintText: l10n.summaryNotesHint,
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                  onChanged: (value) {
                    ref.read(bookingFlowProvider.notifier).updateNotes(value);
                  },
                ),
              ],
            ),
          ),
        ),

        // Footer
        _buildFooter(context, ref, bookingState),
      ],
    );
  }

  Widget _buildFooter(
    BuildContext context,
    WidgetRef ref,
    BookingFlowState state,
  ) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, -5),
          ),
        ],
      ),
      child: SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Errore
            if (state.errorMessage != null) ...[
              Container(
                padding: const EdgeInsets.all(12),
                margin: const EdgeInsets.only(bottom: 12),
                decoration: BoxDecoration(
                  color: theme.colorScheme.error.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    Icon(Icons.error_outline, color: theme.colorScheme.error),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        state.errorMessage!,
                        style: TextStyle(color: theme.colorScheme.error),
                      ),
                    ),
                  ],
                ),
              ),
            ],
            // Bottone conferma
            ElevatedButton(
              onPressed: state.isLoading
                  ? null
                  : () =>
                        ref.read(bookingFlowProvider.notifier).confirmBooking(),
              child: state.isLoading
                  ? const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.white,
                      ),
                    )
                  : Text(l10n.actionConfirm),
            ),
          ],
        ),
      ),
    );
  }
}

class _SummarySection extends StatelessWidget {
  final String title;
  final IconData icon;
  final Widget child;

  const _SummarySection({
    required this.title,
    required this.icon,
    required this.child,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Card(
      margin: EdgeInsets.zero,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(icon, size: 18, color: theme.colorScheme.primary),
                const SizedBox(width: 8),
                Text(
                  title,
                  style: theme.textTheme.titleSmall?.copyWith(
                    fontWeight: FontWeight.w600,
                    color: theme.colorScheme.onSurface.withOpacity(0.7),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            child,
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/services_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';
import '../../../../core/network/api_client.dart';
import '../../providers/booking_provider.dart';

class ServicesStep extends ConsumerWidget {
  const ServicesStep({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final servicesDataAsync = ref.watch(servicesDataProvider);
    final bookingState = ref.watch(bookingFlowProvider);
    final selectedServices = bookingState.request.services;

    return Column(
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                l10n.servicesTitle,
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                l10n.servicesSubtitle,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurface.withOpacity(0.7),
                ),
              ),
            ],
          ),
        ),

        // Lista servizi per categoria (singola chiamata API)
        Expanded(
          child: servicesDataAsync.when(
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (e, _) => _buildErrorWidget(context, ref, e),
            data: (data) {
              if (data.isEmpty) {
                return _EmptyView(
                  title: l10n.servicesEmpty,
                  subtitle: l10n.servicesEmptySubtitle,
                );
              }

              return _buildServicesList(
                context,
                ref,
                data.categories,
                data.bookableServices,
                selectedServices,
              );
            },
          ),
        ),

        // Footer con selezione e bottone
        _buildFooter(context, ref, selectedServices),
      ],
    );
  }

  /// Costruisce il widget di errore appropriato in base al tipo di errore
  Widget _buildErrorWidget(BuildContext context, WidgetRef ref, Object error) {
    final l10n = context.l10n;

    // Determina titolo e sottotitolo in base al tipo di errore
    String title;
    String subtitle;
    IconData icon;
    bool showRetry;

    if (error is ApiException) {
      if (error.isLocationNotFound) {
        title = l10n.errorLocationNotFound;
        subtitle = l10n.errorLocationNotFoundSubtitle;
        icon = Icons.location_off_outlined;
        showRetry = false;
      } else if (error.isBusinessNotFound) {
        title = l10n.errorBusinessNotFound;
        subtitle = l10n.errorBusinessNotFoundSubtitle;
        icon = Icons.store_outlined;
        showRetry = false;
      } else if (error.isServiceUnavailable) {
        title = l10n.errorServiceUnavailable;
        subtitle = l10n.errorServiceUnavailableSubtitle;
        icon = Icons.cloud_off_outlined;
        showRetry = true;
      } else {
        title = l10n.errorLoadingServices;
        subtitle = error.message;
        icon = Icons.error_outline;
        showRetry = true;
      }
    } else {
      title = l10n.errorLoadingServices;
      subtitle = '';
      icon = Icons.cloud_off_outlined;
      showRetry = true;
    }

    return _ErrorView(
      title: title,
      subtitle: subtitle,
      icon: icon,
      onRetry: showRetry
          ? () => ref.read(servicesDataProvider.notifier).refresh()
          : null,
    );
  }

  Widget _buildServicesList(
    BuildContext context,
    WidgetRef ref,
    List<ServiceCategory> categories,
    List<Service> services,
    List<Service> selectedServices,
  ) {
    return ListView.builder(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      itemCount: categories.length,
      itemBuilder: (context, index) {
        final category = categories[index];
        final categoryServices =
            services
                .where((s) => s.categoryId == category.id && s.isBookableOnline)
                .toList()
              ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));

        if (categoryServices.isEmpty) return const SizedBox.shrink();

        return _CategorySection(
          category: category,
          services: categoryServices,
          selectedServices: selectedServices,
          onServiceTap: (service) {
            ref.read(bookingFlowProvider.notifier).toggleService(service);
          },
        );
      },
    );
  }

  Widget _buildFooter(
    BuildContext context,
    WidgetRef ref,
    List<Service> selectedServices,
  ) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final bookingState = ref.watch(bookingFlowProvider);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, -5),
          ),
        ],
      ),
      child: SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Info selezione
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  l10n.servicesSelected(selectedServices.length),
                  style: theme.textTheme.bodyMedium,
                ),
                if (selectedServices.isNotEmpty)
                  Text(
                    bookingState.request.formattedTotalPrice,
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: theme.colorScheme.primary,
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 12),
            // Bottone avanti
            ElevatedButton(
              onPressed: bookingState.canGoNext
                  ? () => ref.read(bookingFlowProvider.notifier).nextStep()
                  : null,
              child: Text(l10n.actionNext),
            ),
          ],
        ),
      ),
    );
  }
}

class _CategorySection extends StatelessWidget {
  final ServiceCategory category;
  final List<Service> services;
  final List<Service> selectedServices;
  final void Function(Service) onServiceTap;

  const _CategorySection({
    required this.category,
    required this.services,
    required this.selectedServices,
    required this.onServiceTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.symmetric(vertical: 12),
          child: Text(
            category.name,
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
        ...services.map((service) {
          final isSelected = selectedServices.any((s) => s.id == service.id);
          return _ServiceTile(
            service: service,
            isSelected: isSelected,
            onTap: () => onServiceTap(service),
          );
        }),
        const SizedBox(height: 8),
      ],
    );
  }
}

class _ServiceTile extends StatelessWidget {
  final Service service;
  final bool isSelected;
  final VoidCallback onTap;

  const _ServiceTile({
    required this.service,
    required this.isSelected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(
          color: isSelected ? theme.colorScheme.primary : theme.dividerColor,
          width: isSelected ? 2 : 1,
        ),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Checkbox
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected
                      ? theme.colorScheme.primary
                      : Colors.transparent,
                  border: Border.all(
                    color: isSelected
                        ? theme.colorScheme.primary
                        : theme.colorScheme.onSurface.withOpacity(0.3),
                    width: 2,
                  ),
                ),
                child: isSelected
                    ? const Icon(Icons.check, size: 16, color: Colors.white)
                    : null,
              ),
              const SizedBox(width: 16),
              // Info servizio
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      service.name,
                      style: theme.textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      l10n.servicesDuration(service.durationMinutes),
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onSurface.withOpacity(0.6),
                      ),
                    ),
                  ],
                ),
              ),
              // Prezzo
              Text(
                service.formattedPrice,
                style: theme.textTheme.titleSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: theme.colorScheme.primary,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// Widget per mostrare errori con bottone retry
class _ErrorView extends StatelessWidget {
  final String title;
  final String subtitle;
  final IconData icon;
  final VoidCallback? onRetry;

  const _ErrorView({
    required this.title,
    this.subtitle = '',
    this.icon = Icons.cloud_off_outlined,
    this.onRetry,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              icon,
              size: 64,
              color: theme.colorScheme.error.withOpacity(0.5),
            ),
            const SizedBox(height: 16),
            Text(
              title,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
              ),
              textAlign: TextAlign.center,
            ),
            if (subtitle.isNotEmpty) ...[
              const SizedBox(height: 8),
              Text(
                subtitle,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurfaceVariant,
                ),
                textAlign: TextAlign.center,
              ),
            ],
            if (onRetry != null) ...[
              const SizedBox(height: 24),
              OutlinedButton.icon(
                onPressed: onRetry,
                icon: const Icon(Icons.refresh),
                label: Text(l10n.actionRetry),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

/// Widget per mostrare stato vuoto
class _EmptyView extends StatelessWidget {
  final String title;
  final String subtitle;

  const _EmptyView({required this.title, required this.subtitle});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.event_busy_outlined,
              size: 64,
              color: theme.colorScheme.onSurface.withOpacity(0.3),
            ),
            const SizedBox(height: 16),
            Text(
              title,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              subtitle,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.6),
              ),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/my_bookings_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '/core/l10n/l10_extension.dart';
import '/core/models/booking_item.dart';
import '/features/booking/providers/my_bookings_provider.dart';
import '../dialogs/reschedule_booking_dialog.dart';

class MyBookingsScreen extends ConsumerStatefulWidget {
  const MyBookingsScreen({super.key});

  @override
  ConsumerState<MyBookingsScreen> createState() => _MyBookingsScreenState();
}

class _MyBookingsScreenState extends ConsumerState<MyBookingsScreen>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    // Carica prenotazioni all'avvio
    Future.microtask(
      () => ref.read(myBookingsProvider.notifier).loadBookings(),
    );
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final bookingsState = ref.watch(myBookingsProvider);

    return Scaffold(
      appBar: AppBar(
        title: Text(context.l10n.myBookings),
        bottom: TabBar(
          controller: _tabController,
          tabs: [
            Tab(
              text: context.l10n.upcomingBookings,
              icon: const Icon(Icons.event_available),
            ),
            Tab(
              text: context.l10n.pastBookings,
              icon: const Icon(Icons.history),
            ),
          ],
        ),
      ),
      body: bookingsState.isLoading
          ? const Center(child: CircularProgressIndicator())
          : bookingsState.error != null
          ? _ErrorView(error: bookingsState.error!)
          : TabBarView(
              controller: _tabController,
              children: [
                _BookingsList(
                  bookings: bookingsState.upcoming,
                  isUpcoming: true,
                ),
                _BookingsList(bookings: bookingsState.past, isUpcoming: false),
              ],
            ),
    );
  }
}

class _ErrorView extends StatelessWidget {
  const _ErrorView({required this.error});

  final String error;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 64, color: Colors.red),
            const SizedBox(height: 16),
            Text(
              context.l10n.errorLoadingBookings,
              style: Theme.of(context).textTheme.titleMedium,
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              error,
              style: Theme.of(context).textTheme.bodySmall,
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }
}

class _BookingsList extends StatelessWidget {
  const _BookingsList({required this.bookings, required this.isUpcoming});

  final List<BookingItem> bookings;
  final bool isUpcoming;

  @override
  Widget build(BuildContext context) {
    if (bookings.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              isUpcoming ? Icons.event_busy : Icons.history,
              size: 64,
              color: Colors.grey,
            ),
            const SizedBox(height: 16),
            Text(
              isUpcoming
                  ? context.l10n.noUpcomingBookings
                  : context.l10n.noPastBookings,
              style: Theme.of(context).textTheme.titleMedium,
            ),
          ],
        ),
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: bookings.length,
      itemBuilder: (context, index) {
        final booking = bookings[index];
        return _BookingCard(booking: booking, isUpcoming: isUpcoming);
      },
    );
  }
}

class _BookingCard extends ConsumerWidget {
  const _BookingCard({required this.booking, required this.isUpcoming});

  final BookingItem booking;
  final bool isUpcoming;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final dateFormat = DateFormat('dd/MM/yyyy', 'it');
    final timeFormat = DateFormat('HH:mm', 'it');

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Intestazione con business e location
            Row(
              children: [
                const Icon(Icons.business, size: 20),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    booking.businessName,
                    style: Theme.of(context).textTheme.titleMedium,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 4),
            Row(
              children: [
                const Icon(Icons.location_on, size: 18, color: Colors.grey),
                const SizedBox(width: 8),
                Text(
                  booking.locationName,
                  style: Theme.of(context).textTheme.bodyMedium,
                ),
              ],
            ),
            const Divider(height: 24),

            // Servizi
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Icon(Icons.work_outline, size: 18),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    booking.servicesDisplay,
                    style: Theme.of(context).textTheme.bodyMedium,
                  ),
                ),
              ],
            ),

            // Staff (se presente)
            if (booking.staffName != null) ...[
              const SizedBox(height: 8),
              Row(
                children: [
                  const Icon(Icons.person, size: 18, color: Colors.grey),
                  const SizedBox(width: 8),
                  Text(
                    booking.staffName!,
                    style: Theme.of(context).textTheme.bodyMedium,
                  ),
                ],
              ),
            ],
            const SizedBox(height: 12),

            // Data e ora
            Row(
              children: [
                const Icon(Icons.calendar_today, size: 18),
                const SizedBox(width: 8),
                Text(dateFormat.format(booking.startTime)),
                const SizedBox(width: 16),
                const Icon(Icons.access_time, size: 18),
                const SizedBox(width: 8),
                Text(
                  '${timeFormat.format(booking.startTime)} - ${timeFormat.format(booking.endTime)}',
                ),
              ],
            ),

            // Prezzo (se > 0)
            if (booking.totalPrice > 0) ...[
              const SizedBox(height: 8),
              Row(
                children: [
                  const Icon(Icons.euro, size: 18, color: Colors.grey),
                  const SizedBox(width: 8),
                  Text(
                    '${booking.totalPrice.toStringAsFixed(2)} ‚Ç¨',
                    style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ],
              ),
            ],

            // Note (se presenti)
            if (booking.notes != null && booking.notes!.isNotEmpty) ...[
              const SizedBox(height: 12),
              Row(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  const Icon(Icons.note, size: 18),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      booking.notes!,
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                  ),
                ],
              ),
            ],

            // Badge e azioni per prenotazioni future
            if (isUpcoming) ...[
              const SizedBox(height: 16),
              Row(
                children: [
                  // Badge can_modify
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 8,
                      vertical: 4,
                    ),
                    decoration: BoxDecoration(
                      color: booking.canModify ? Colors.green : Colors.orange,
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      booking.canModify
                          ? context.l10n.modifiable
                          : context.l10n.notModifiable,
                      style: const TextStyle(color: Colors.white, fontSize: 12),
                    ),
                  ),
                  const SizedBox(width: 8),

                  // Countdown se modificabile
                  if (booking.canModify && booking.canModifyUntil != null)
                    Text(
                      _formatTimeUntil(context, booking.canModifyUntil!),
                      style: Theme.of(context).textTheme.bodySmall,
                    ),

                  const Spacer(),

                  // Pulsanti azione
                  if (booking.canModify) ...[
                    TextButton.icon(
                      onPressed: () => _handleModify(context, ref),
                      icon: const Icon(Icons.edit),
                      label: Text(context.l10n.modify),
                    ),
                    const SizedBox(width: 8),
                    TextButton.icon(
                      onPressed: () => _handleCancel(context, ref),
                      icon: const Icon(Icons.cancel),
                      label: Text(context.l10n.cancel),
                      style: TextButton.styleFrom(foregroundColor: Colors.red),
                    ),
                  ],
                ],
              ),
            ],
          ],
        ),
      ),
    );
  }

  String _formatTimeUntil(BuildContext context, DateTime deadline) {
    final now = DateTime.now();
    final diff = deadline.difference(now);

    if (diff.inHours > 24) {
      final days = diff.inDays;
      return context.l10n.modifiableUntilDays(days);
    } else if (diff.inHours > 0) {
      return context.l10n.modifiableUntilHours(diff.inHours);
    } else {
      return context.l10n.modifiableUntilMinutes(diff.inMinutes);
    }
  }

  Future<void> _handleModify(BuildContext context, WidgetRef ref) async {
    final result = await showDialog<bool>(
      context: context,
      builder: (ctx) => RescheduleBookingDialog(booking: booking),
    );

    if (result == true && context.mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(context.l10n.bookingRescheduled),
          backgroundColor: Colors.green,
        ),
      );
    }
  }

  Future<void> _handleCancel(BuildContext context, WidgetRef ref) async {
    final confirm = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(context.l10n.cancelBookingTitle),
        content: Text(context.l10n.cancelBookingConfirm),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(false),
            child: Text(context.l10n.no),
          ),
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(true),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: Text(context.l10n.yes),
          ),
        ],
      ),
    );

    if (confirm == true && context.mounted) {
      final success = await ref
          .read(myBookingsProvider.notifier)
          .cancelBooking(booking.locationId, booking.id);

      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(
              success
                  ? context.l10n.bookingCancelled
                  : context.l10n.bookingCancelFailed,
            ),
            backgroundColor: success ? Colors.green : Colors.red,
          ),
        );
      }
    }
  }
}
--- FILE: lib/features/booking/presentation/screens/booking_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../app/providers/route_slug_provider.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../auth/providers/auth_provider.dart';
import '../../providers/booking_provider.dart';
import '../../providers/business_provider.dart';
import '../../providers/locations_provider.dart';
import '../widgets/booking_step_indicator.dart';
import 'confirmation_step.dart';
import 'date_time_step.dart';
import 'location_step.dart';
import 'services_step.dart';
import 'staff_step.dart';
import 'summary_step.dart';

class BookingScreen extends ConsumerWidget {
  const BookingScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final businessAsync = ref.watch(currentBusinessProvider);
    final config = ref.watch(bookingConfigProvider);
    final l10n = context.l10n;

    // Se il business √® in caricamento, mostra loading
    if (businessAsync.isLoading) {
      return Scaffold(
        appBar: AppBar(title: Text(l10n.bookingTitle)),
        body: const Center(child: CircularProgressIndicator()),
      );
    }

    // Se c'√® un errore nel caricamento del business
    if (businessAsync.hasError) {
      return Scaffold(
        appBar: AppBar(title: Text(l10n.bookingTitle)),
        body: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Icon(Icons.error_outline, size: 64, color: Colors.red),
              const SizedBox(height: 16),
              Text(
                l10n.errorGeneric,
                style: Theme.of(context).textTheme.titleLarge,
              ),
              const SizedBox(height: 16),
              ElevatedButton.icon(
                onPressed: () =>
                    ref.read(currentBusinessProvider.notifier).refresh(),
                icon: const Icon(Icons.refresh),
                label: Text(l10n.actionRetry),
              ),
            ],
          ),
        ),
      );
    }

    // Se la config non √® valida (business o location mancanti)
    if (!config.isValid) {
      // Distingui tra "business non trovato" e "business non attivo"
      final isNotActive = config.businessExistsButNotActive;
      final title = isNotActive
          ? l10n.errorBusinessNotActive
          : l10n.errorBusinessNotFound;
      final subtitle = isNotActive
          ? l10n.errorBusinessNotActiveSubtitle
          : l10n.errorBusinessNotFoundSubtitle;
      final icon = isNotActive ? Icons.schedule : Icons.storefront_outlined;

      return Scaffold(
        appBar: AppBar(title: Text(l10n.bookingTitle)),
        body: Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(icon, size: 64),
              const SizedBox(height: 16),
              Text(title, style: Theme.of(context).textTheme.titleLarge),
              const SizedBox(height: 8),
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 32),
                child: Text(
                  subtitle,
                  textAlign: TextAlign.center,
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: Theme.of(
                      context,
                    ).colorScheme.onSurface.withAlpha((0.6 * 255).round()),
                  ),
                ),
              ),
            ],
          ),
        ),
      );
    }

    // Normal booking flow
    final bookingState = ref.watch(bookingFlowProvider);
    final hasMultipleLocations = ref.watch(hasMultipleLocationsProvider);
    final isAuthenticated = ref.watch(
      authProvider.select((state) => state.isAuthenticated),
    );
    final slug = ref.watch(routeSlugProvider);

    // Determina se mostrare il back button
    // Se c'√® una sola location e siamo su services, non mostrare back
    final showBackButton =
        bookingState.canGoBack &&
        !(bookingState.currentStep == BookingStep.services &&
            !hasMultipleLocations);

    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.bookingTitle),
        leading: showBackButton
            ? IconButton(
                icon: const Icon(Icons.arrow_back),
                onPressed: () =>
                    ref.read(bookingFlowProvider.notifier).previousStep(),
              )
            : null,
        actions: [
          if (isAuthenticated && slug != null)
            PopupMenuButton<String>(
              icon: const Icon(Icons.account_circle_outlined),
              tooltip: l10n.profileTitle,
              onSelected: (value) {
                switch (value) {
                  case 'bookings':
                    context.go('/$slug/my-bookings');
                  case 'profile':
                    context.push('/$slug/profile');
                }
              },
              itemBuilder: (context) => [
                PopupMenuItem<String>(
                  value: 'bookings',
                  child: ListTile(
                    leading: const Icon(Icons.event_note),
                    title: Text(l10n.myBookings),
                    contentPadding: EdgeInsets.zero,
                    dense: true,
                  ),
                ),
                PopupMenuItem<String>(
                  value: 'profile',
                  child: ListTile(
                    leading: const Icon(Icons.person_outline),
                    title: Text(l10n.profileTitle),
                    contentPadding: EdgeInsets.zero,
                    dense: true,
                  ),
                ),
              ],
            ),
        ],
      ),
      body: Column(
        children: [
          // Step indicator
          if (bookingState.currentStep != BookingStep.confirmation)
            BookingStepIndicator(
              currentStep: bookingState.currentStep,
              allowStaffSelection: config.allowStaffSelection,
              showLocationStep: hasMultipleLocations,
              onStepTap: (step) {
                ref.read(bookingFlowProvider.notifier).goToStep(step);
              },
            ),

          // Content
          Expanded(
            child: AnimatedSwitcher(
              duration: const Duration(milliseconds: 300),
              child: _buildStepContent(bookingState.currentStep),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStepContent(BookingStep step) {
    switch (step) {
      case BookingStep.location:
        return const LocationStep();
      case BookingStep.services:
        return const ServicesStep();
      case BookingStep.staff:
        return const StaffStep();
      case BookingStep.dateTime:
        return const DateTimeStep();
      case BookingStep.summary:
        return const SummaryStep();
      case BookingStep.confirmation:
        return const ConfirmationStep();
    }
  }
}
--- FILE: lib/features/booking/presentation/screens/location_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/location.dart';
import '../../providers/booking_provider.dart';
import '../../providers/locations_provider.dart';

class LocationStep extends ConsumerWidget {
  const LocationStep({super.key});

  /// Aggiorna l'URL con il parametro location per persistenza
  void _updateUrlWithLocation(BuildContext context, int locationId) {
    final uri = GoRouterState.of(context).uri;
    final newUri = uri.replace(
      queryParameters: {
        ...uri.queryParameters,
        'location': locationId.toString(),
      },
    );
    // Usa replaceLocation per non aggiungere alla history del browser
    context.go(newUri.toString());
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final locationsAsync = ref.watch(locationsProvider);
    final selectedLocation = ref.watch(selectedLocationProvider);

    return Column(
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                l10n.locationTitle,
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                l10n.locationSubtitle,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurface.withOpacity(0.7),
                ),
              ),
            ],
          ),
        ),

        // Lista locations
        Expanded(
          child: locationsAsync.when(
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (e, _) => Center(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Icon(Icons.error_outline, size: 48, color: Colors.red),
                  const SizedBox(height: 16),
                  Text(l10n.errorGeneric),
                  const SizedBox(height: 16),
                  ElevatedButton.icon(
                    onPressed: () =>
                        ref.read(locationsProvider.notifier).refresh(),
                    icon: const Icon(Icons.refresh),
                    label: Text(l10n.actionRetry),
                  ),
                ],
              ),
            ),
            data: (locations) {
              if (locations.isEmpty) {
                return Center(
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Icon(
                        Icons.location_off,
                        size: 64,
                        color: theme.colorScheme.onSurface.withOpacity(0.4),
                      ),
                      const SizedBox(height: 16),
                      Text(
                        l10n.locationEmpty,
                        style: theme.textTheme.titleMedium,
                      ),
                    ],
                  ),
                );
              }

              return ListView.builder(
                padding: const EdgeInsets.symmetric(horizontal: 16),
                itemCount: locations.length,
                itemBuilder: (context, index) {
                  final location = locations[index];
                  final isSelected = selectedLocation?.id == location.id;

                  return _LocationCard(
                    location: location,
                    isSelected: isSelected,
                    onTap: () {
                      ref
                          .read(selectedLocationProvider.notifier)
                          .select(location);
                      // Aggiorna URL con location selezionata per persistenza
                      _updateUrlWithLocation(context, location.id);
                    },
                  );
                },
              );
            },
          ),
        ),

        // Footer con bottone
        _buildFooter(context, ref, selectedLocation),
      ],
    );
  }

  Widget _buildFooter(
    BuildContext context,
    WidgetRef ref,
    Location? selectedLocation,
  ) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
      ),
      child: SafeArea(
        child: SizedBox(
          width: double.infinity,
          child: FilledButton(
            onPressed: selectedLocation != null
                ? () => ref.read(bookingFlowProvider.notifier).nextStep()
                : null,
            child: Text(l10n.actionNext),
          ),
        ),
      ),
    );
  }
}

class _LocationCard extends StatelessWidget {
  final Location location;
  final bool isSelected;
  final VoidCallback onTap;

  const _LocationCard({
    required this.location,
    required this.isSelected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: isSelected
            ? BorderSide(color: theme.colorScheme.primary, width: 2)
            : BorderSide.none,
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Icona location
              Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: isSelected
                      ? theme.colorScheme.primary.withOpacity(0.1)
                      : theme.colorScheme.surfaceContainerHighest,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Icon(
                  Icons.location_on,
                  color: isSelected
                      ? theme.colorScheme.primary
                      : theme.colorScheme.onSurfaceVariant,
                ),
              ),
              const SizedBox(width: 16),

              // Info location
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            location.name,
                            style: theme.textTheme.titleMedium?.copyWith(
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ),
                        if (location.isDefault)
                          Container(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 8,
                              vertical: 2,
                            ),
                            decoration: BoxDecoration(
                              color: theme.colorScheme.primaryContainer,
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: Text(
                              'Principale',
                              style: theme.textTheme.labelSmall?.copyWith(
                                color: theme.colorScheme.onPrimaryContainer,
                              ),
                            ),
                          ),
                      ],
                    ),
                    if (location.formattedAddress.isNotEmpty) ...[
                      const SizedBox(height: 4),
                      Text(
                        location.formattedAddress,
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.7),
                        ),
                      ),
                    ],
                    if (location.phone != null &&
                        location.phone!.isNotEmpty) ...[
                      const SizedBox(height: 4),
                      Row(
                        children: [
                          Icon(
                            Icons.phone_outlined,
                            size: 14,
                            color: theme.colorScheme.onSurface.withOpacity(0.5),
                          ),
                          const SizedBox(width: 4),
                          Text(
                            location.phone!,
                            style: theme.textTheme.bodySmall?.copyWith(
                              color: theme.colorScheme.onSurface.withOpacity(
                                0.7,
                              ),
                            ),
                          ),
                        ],
                      ),
                    ],
                  ],
                ),
              ),

              // Checkmark se selezionato
              if (isSelected)
                Icon(Icons.check_circle, color: theme.colorScheme.primary),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/date_time_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/time_slot.dart';
import '../../providers/booking_provider.dart';

class DateTimeStep extends ConsumerStatefulWidget {
  const DateTimeStep({super.key});

  @override
  ConsumerState<DateTimeStep> createState() => _DateTimeStepState();
}

class _DateTimeStepState extends ConsumerState<DateTimeStep> {
  DateTime _focusedMonth = DateTime.now();

  @override
  void initState() {
    super.initState();
    // Imposta la prima data disponibile
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadFirstAvailableDate();
    });
  }

  Future<void> _loadFirstAvailableDate() async {
    final firstDateAsync = ref.read(firstAvailableDateProvider);
    firstDateAsync.whenData((date) {
      ref.read(selectedDateProvider.notifier).state = date;
      setState(() => _focusedMonth = date);
    });
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final selectedDate = ref.watch(selectedDateProvider);
    final slotsAsync = ref.watch(availableSlotsProvider);
    final bookingState = ref.watch(bookingFlowProvider);
    final firstDateAsync = ref.watch(firstAvailableDateProvider);

    return Column(
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                l10n.dateTimeTitle,
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              firstDateAsync.when(
                loading: () => const SizedBox.shrink(),
                error: (_, __) => const SizedBox.shrink(),
                data: (date) => Text(
                  l10n.dateTimeFirstAvailable(
                    DateFormat('EEEE d MMMM', 'it').format(date),
                  ),
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.primary,
                  ),
                ),
              ),
            ],
          ),
        ),

        // Contenuto scrollabile
        Expanded(
          child: SingleChildScrollView(
            child: Column(
              children: [
                // Calendario
                _buildCalendar(context, selectedDate),

                const Divider(),

                // Slot orari
                slotsAsync.when(
                  loading: () =>
                      const Center(child: CircularProgressIndicator()),
                  error: (e, _) =>
                      Center(child: Text(l10n.errorLoadingAvailability)),
                  data: (slots) => slots.isEmpty
                      ? Padding(
                          padding: const EdgeInsets.all(32),
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                Icons.event_busy,
                                size: 48,
                                color: theme.colorScheme.onSurface.withOpacity(
                                  0.3,
                                ),
                              ),
                              const SizedBox(height: 16),
                              Text(
                                l10n.dateTimeNoSlots,
                                textAlign: TextAlign.center,
                                style: theme.textTheme.bodyLarge?.copyWith(
                                  color: theme.colorScheme.onSurface
                                      .withOpacity(0.6),
                                ),
                              ),
                            ],
                          ),
                        )
                      : _buildTimeSlots(context, ref, slots),
                ),
              ],
            ),
          ),
        ),

        // Footer
        _buildFooter(context, ref, bookingState),
      ],
    );
  }

  Widget _buildCalendar(BuildContext context, DateTime? selectedDate) {
    final theme = Theme.of(context);
    final now = DateTime.now();
    final firstDayOfMonth = DateTime(
      _focusedMonth.year,
      _focusedMonth.month,
      1,
    );
    final lastDayOfMonth = DateTime(
      _focusedMonth.year,
      _focusedMonth.month + 1,
      0,
    );
    final firstWeekday = firstDayOfMonth.weekday;
    final daysInMonth = lastDayOfMonth.day;

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      child: Column(
        children: [
          // Header mese
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              IconButton(
                icon: const Icon(Icons.chevron_left),
                onPressed: () {
                  setState(() {
                    _focusedMonth = DateTime(
                      _focusedMonth.year,
                      _focusedMonth.month - 1,
                    );
                  });
                },
              ),
              Text(
                DateFormat('MMMM yyyy', 'it').format(_focusedMonth),
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              IconButton(
                icon: const Icon(Icons.chevron_right),
                onPressed: () {
                  setState(() {
                    _focusedMonth = DateTime(
                      _focusedMonth.year,
                      _focusedMonth.month + 1,
                    );
                  });
                },
              ),
            ],
          ),
          const SizedBox(height: 8),
          // Giorni della settimana
          Row(
            children: ['L', 'M', 'M', 'G', 'V', 'S', 'D']
                .map(
                  (day) => Expanded(
                    child: Center(
                      child: Text(
                        day,
                        style: theme.textTheme.bodySmall?.copyWith(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.onSurface.withOpacity(0.5),
                        ),
                      ),
                    ),
                  ),
                )
                .toList(),
          ),
          const SizedBox(height: 8),
          // Griglia giorni
          GridView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 7,
              mainAxisSpacing: 4,
              crossAxisSpacing: 4,
            ),
            itemCount: 42,
            itemBuilder: (context, index) {
              final dayOffset = index - (firstWeekday - 1);
              if (dayOffset < 1 || dayOffset > daysInMonth) {
                return const SizedBox.shrink();
              }

              final date = DateTime(
                _focusedMonth.year,
                _focusedMonth.month,
                dayOffset,
              );
              final isToday =
                  date.year == now.year &&
                  date.month == now.month &&
                  date.day == now.day;
              final isPast = date.isBefore(
                DateTime(now.year, now.month, now.day),
              );
              final isSelected =
                  selectedDate != null &&
                  date.year == selectedDate.year &&
                  date.month == selectedDate.month &&
                  date.day == selectedDate.day;

              return GestureDetector(
                onTap: isPast
                    ? null
                    : () {
                        ref.read(selectedDateProvider.notifier).state = date;
                      },
                child: Container(
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    color: isSelected
                        ? theme.colorScheme.primary
                        : isToday
                        ? theme.colorScheme.primary.withOpacity(0.1)
                        : null,
                  ),
                  child: Center(
                    child: Text(
                      '$dayOffset',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: isSelected
                            ? Colors.white
                            : isPast
                            ? theme.colorScheme.onSurface.withOpacity(0.3)
                            : theme.colorScheme.onSurface,
                        fontWeight: isToday || isSelected
                            ? FontWeight.bold
                            : null,
                      ),
                    ),
                  ),
                ),
              );
            },
          ),
        ],
      ),
    );
  }

  Widget _buildTimeSlots(
    BuildContext context,
    WidgetRef ref,
    List<TimeSlot> slots,
  ) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final bookingState = ref.watch(bookingFlowProvider);
    final selectedSlot = bookingState.request.selectedSlot;

    // Raggruppa per fascia oraria
    final morningSlots = slots.where((s) => s.startTime.hour < 12).toList();
    final afternoonSlots = slots
        .where((s) => s.startTime.hour >= 12 && s.startTime.hour < 18)
        .toList();
    final eveningSlots = slots.where((s) => s.startTime.hour >= 18).toList();

    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        if (morningSlots.isNotEmpty) ...[
          Text(l10n.dateTimeMorning, style: theme.textTheme.titleSmall),
          const SizedBox(height: 8),
          _buildSlotGrid(context, ref, morningSlots, selectedSlot),
          const SizedBox(height: 16),
        ],
        if (afternoonSlots.isNotEmpty) ...[
          Text(l10n.dateTimeAfternoon, style: theme.textTheme.titleSmall),
          const SizedBox(height: 8),
          _buildSlotGrid(context, ref, afternoonSlots, selectedSlot),
          const SizedBox(height: 16),
        ],
        if (eveningSlots.isNotEmpty) ...[
          Text(l10n.dateTimeEvening, style: theme.textTheme.titleSmall),
          const SizedBox(height: 8),
          _buildSlotGrid(context, ref, eveningSlots, selectedSlot),
        ],
      ],
    );
  }

  Widget _buildSlotGrid(
    BuildContext context,
    WidgetRef ref,
    List<TimeSlot> slots,
    TimeSlot? selectedSlot,
  ) {
    final theme = Theme.of(context);

    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: slots.map((slot) {
        final isSelected = selectedSlot?.startTime == slot.startTime;
        return GestureDetector(
          onTap: () {
            ref.read(bookingFlowProvider.notifier).selectTimeSlot(slot);
          },
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
            decoration: BoxDecoration(
              color: isSelected
                  ? theme.colorScheme.primary
                  : Colors.transparent,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(
                color: isSelected
                    ? theme.colorScheme.primary
                    : theme.dividerColor,
              ),
            ),
            child: Text(
              slot.formattedTime,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: isSelected ? Colors.white : theme.colorScheme.onSurface,
                fontWeight: isSelected ? FontWeight.bold : null,
              ),
            ),
          ),
        );
      }).toList(),
    );
  }

  Widget _buildFooter(
    BuildContext context,
    WidgetRef ref,
    BookingFlowState state,
  ) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, -5),
          ),
        ],
      ),
      child: SafeArea(
        child: ElevatedButton(
          onPressed: state.canGoNext
              ? () => ref.read(bookingFlowProvider.notifier).nextStep()
              : null,
          child: Text(l10n.actionNext),
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/confirmation_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../app/providers/route_slug_provider.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../providers/booking_provider.dart';

class ConfirmationStep extends ConsumerWidget {
  const ConfirmationStep({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final bookingState = ref.watch(bookingFlowProvider);

    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Spacer(),

            // Icona successo
            Container(
              width: 100,
              height: 100,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                color: Colors.green.withOpacity(0.1),
              ),
              child: const Icon(
                Icons.check_circle,
                size: 64,
                color: Colors.green,
              ),
            ),
            const SizedBox(height: 32),

            // Titolo
            Text(
              l10n.confirmationTitle,
              style: theme.textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.bold,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),

            // Sottotitolo
            Text(
              l10n.confirmationSubtitle,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 24),

            // Codice prenotazione
            if (bookingState.confirmedBookingId != null)
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 24,
                  vertical: 16,
                ),
                decoration: BoxDecoration(
                  color: theme.colorScheme.primary.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  l10n.confirmationBookingId(bookingState.confirmedBookingId!),
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: theme.colorScheme.primary,
                  ),
                ),
              ),

            const Spacer(),

            // Bottoni azioni
            ElevatedButton(
              onPressed: () {
                ref.read(bookingFlowProvider.notifier).reset();
                final slug = ref.read(routeSlugProvider);
                context.go('/$slug/booking');
              },
              child: Text(l10n.confirmationNewBooking),
            ),
            const SizedBox(height: 12),
            OutlinedButton(
              onPressed: () {
                ref.read(bookingFlowProvider.notifier).reset();
                context.go('/');
              },
              child: Text(l10n.confirmationGoHome),
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/dialogs/reschedule_booking_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '/core/l10n/l10_extension.dart';
import '/core/models/booking_item.dart';
import '/core/network/network_providers.dart';
import '../../providers/my_bookings_provider.dart';

/// Dialog per riprogrammare una prenotazione esistente
class RescheduleBookingDialog extends ConsumerStatefulWidget {
  const RescheduleBookingDialog({required this.booking, super.key});

  final BookingItem booking;

  @override
  ConsumerState<RescheduleBookingDialog> createState() =>
      _RescheduleBookingDialogState();
}

class _RescheduleBookingDialogState
    extends ConsumerState<RescheduleBookingDialog> {
  DateTime? _selectedDate;
  String? _selectedTimeSlot;
  List<String> _availableSlots = [];
  bool _isLoadingSlots = false;
  String? _error;
  final _notesController = TextEditingController();

  @override
  void initState() {
    super.initState();
    _notesController.text = widget.booking.notes ?? '';
    // Imposta data corrente della prenotazione
    _selectedDate = widget.booking.startTime;
    _loadAvailability(_selectedDate!);
  }

  @override
  void dispose() {
    _notesController.dispose();
    super.dispose();
  }

  Future<void> _loadAvailability(DateTime date) async {
    setState(() {
      _isLoadingSlots = true;
      _error = null;
      _selectedTimeSlot = null;
    });

    try {
      final apiClient = ref.read(apiClientProvider);
      final dateStr = DateFormat('yyyy-MM-dd').format(date);

      // Recupera service IDs dalla prenotazione corrente
      final serviceIds = widget.booking.serviceIds.isNotEmpty
          ? widget.booking.serviceIds
          : [1]; // Fallback se non disponibili (backward compatibility)

      final response = await apiClient.getAvailability(
        locationId: widget.booking.locationId,
        date: dateStr,
        serviceIds: serviceIds,
      );

      final slots = response['slots'] as List<dynamic>? ?? [];
      setState(() {
        _availableSlots = slots
            .map((slot) {
              final startTime = slot['start_time'] as String;
              final dt = DateTime.parse(startTime);
              return DateFormat('HH:mm').format(dt);
            })
            .toList()
            .cast<String>();
        _isLoadingSlots = false;
      });
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoadingSlots = false;
      });
    }
  }

  Future<void> _selectDate() async {
    final now = DateTime.now();
    final firstDate = now;
    final lastDate = now.add(const Duration(days: 90));

    final picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate ?? now,
      firstDate: firstDate,
      lastDate: lastDate,
      locale: const Locale('it'),
    );

    if (picked != null && mounted) {
      setState(() {
        _selectedDate = picked;
      });
      await _loadAvailability(picked);
    }
  }

  Future<void> _confirmReschedule() async {
    if (_selectedDate == null || _selectedTimeSlot == null) {
      return;
    }

    // Costruisci nuovo start_time ISO8601
    final timeParts = _selectedTimeSlot!.split(':');
    final newDateTime = DateTime(
      _selectedDate!.year,
      _selectedDate!.month,
      _selectedDate!.day,
      int.parse(timeParts[0]),
      int.parse(timeParts[1]),
    );

    final newStartTime = newDateTime.toIso8601String();

    final success = await ref
        .read(myBookingsProvider.notifier)
        .rescheduleBooking(
          locationId: widget.booking.locationId,
          bookingId: widget.booking.id,
          newStartTime: newStartTime,
          notes: _notesController.text.isNotEmpty
              ? _notesController.text
              : null,
        );

    if (mounted) {
      if (success) {
        Navigator.of(context).pop(true);
      } else {
        final bookingsState = ref.read(myBookingsProvider);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(bookingsState.error ?? context.l10n.errorGeneric),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final dateFormat = DateFormat('dd/MM/yyyy', 'it');

    return AlertDialog(
      title: Text(context.l10n.rescheduleBookingTitle),
      content: SingleChildScrollView(
        child: SizedBox(
          width: MediaQuery.of(context).size.width * 0.8,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Info prenotazione corrente
              Text(
                context.l10n.currentBooking,
                style: Theme.of(context).textTheme.titleSmall,
              ),
              const SizedBox(height: 8),
              Text(
                '${widget.booking.serviceNames.join(', ')} - ${dateFormat.format(widget.booking.startTime)} ${DateFormat('HH:mm').format(widget.booking.startTime)}',
                style: Theme.of(context).textTheme.bodyMedium,
              ),
              const Divider(height: 24),

              // Selezione nuova data
              Text(
                context.l10n.selectNewDate,
                style: Theme.of(context).textTheme.titleSmall,
              ),
              const SizedBox(height: 8),
              OutlinedButton.icon(
                onPressed: _selectDate,
                icon: const Icon(Icons.calendar_today),
                label: Text(
                  _selectedDate != null
                      ? dateFormat.format(_selectedDate!)
                      : context.l10n.selectDate,
                ),
              ),
              const SizedBox(height: 16),

              // Slot disponibili
              if (_isLoadingSlots)
                const Center(child: CircularProgressIndicator())
              else if (_error != null)
                Text(_error!, style: const TextStyle(color: Colors.red))
              else if (_availableSlots.isEmpty)
                Text(context.l10n.dateTimeNoSlots)
              else ...[
                Text(
                  context.l10n.selectNewTime,
                  style: Theme.of(context).textTheme.titleSmall,
                ),
                const SizedBox(height: 8),
                Wrap(
                  spacing: 8,
                  runSpacing: 8,
                  children: _availableSlots.map((slot) {
                    final isSelected = _selectedTimeSlot == slot;
                    return ChoiceChip(
                      label: Text(slot),
                      selected: isSelected,
                      onSelected: (selected) {
                        setState(() {
                          _selectedTimeSlot = selected ? slot : null;
                        });
                      },
                    );
                  }).toList(),
                ),
              ],
              const SizedBox(height: 16),

              // Note
              TextField(
                controller: _notesController,
                decoration: InputDecoration(
                  labelText: context.l10n.summaryNotes,
                  hintText: context.l10n.summaryNotesHint,
                  border: const OutlineInputBorder(),
                ),
                maxLines: 3,
              ),
            ],
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(false),
          child: Text(context.l10n.actionCancel),
        ),
        FilledButton(
          onPressed: _selectedDate != null && _selectedTimeSlot != null
              ? _confirmReschedule
              : null,
          child: Text(context.l10n.confirmReschedule),
        ),
      ],
    );
  }
}
--- FILE: lib/features/booking/presentation/widgets/booking_step_indicator.dart ---
import 'package:flutter/material.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../providers/booking_provider.dart';

class BookingStepIndicator extends StatelessWidget {
  final BookingStep currentStep;
  final bool allowStaffSelection;
  final bool showLocationStep;
  final void Function(BookingStep) onStepTap;

  const BookingStepIndicator({
    super.key,
    required this.currentStep,
    required this.allowStaffSelection,
    this.showLocationStep = false,
    required this.onStepTap,
  });

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    final steps = [
      if (showLocationStep)
        (BookingStep.location, l10n.bookingStepLocation, Icons.location_on),
      (BookingStep.services, l10n.bookingStepServices, Icons.list_alt),
      if (allowStaffSelection)
        (BookingStep.staff, l10n.bookingStepStaff, Icons.person),
      (BookingStep.dateTime, l10n.bookingStepDateTime, Icons.calendar_today),
      (
        BookingStep.summary,
        l10n.bookingStepSummary,
        Icons.check_circle_outline,
      ),
    ];

    return Container(
      padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 8),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(bottom: BorderSide(color: theme.dividerColor)),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        children: steps.asMap().entries.map((entry) {
          final index = entry.key;
          final (step, label, icon) = entry.value;
          final isActive = step == currentStep;
          final isPast = step.index < currentStep.index;
          final isClickable = isPast;

          return Expanded(
            child: GestureDetector(
              onTap: isClickable ? () => onStepTap(step) : null,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    children: [
                      if (index > 0)
                        Expanded(
                          child: Container(
                            height: 2,
                            color: isPast || isActive
                                ? theme.colorScheme.primary
                                : theme.dividerColor,
                          ),
                        ),
                      Container(
                        width: 32,
                        height: 32,
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          color: isActive
                              ? theme.colorScheme.primary
                              : isPast
                              ? theme.colorScheme.primary.withOpacity(0.2)
                              : theme.dividerColor,
                        ),
                        child: Icon(
                          isPast ? Icons.check : icon,
                          size: 18,
                          color: isActive
                              ? Colors.white
                              : isPast
                              ? theme.colorScheme.primary
                              : theme.colorScheme.onSurface.withOpacity(0.5),
                        ),
                      ),
                      if (index < steps.length - 1)
                        Expanded(
                          child: Container(
                            height: 2,
                            color: isPast
                                ? theme.colorScheme.primary
                                : theme.dividerColor,
                          ),
                        ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Text(
                    label,
                    style: theme.textTheme.bodySmall?.copyWith(
                      fontWeight: isActive
                          ? FontWeight.bold
                          : FontWeight.normal,
                      color: isActive || isPast
                          ? theme.colorScheme.onSurface
                          : theme.colorScheme.onSurface.withOpacity(0.5),
                    ),
                    textAlign: TextAlign.center,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ),
            ),
          );
        }).toList(),
      ),
    );
  }
}
--- FILE: lib/main.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_web_plugins/url_strategy.dart';

import 'app/app.dart';

void main() {
  WidgetsFlutterBinding.ensureInitialized();

  // Usa path URL strategy invece di hash (#) per URL puliti
  // Es: /vamps/booking invece di /#/vamps/booking
  usePathUrlStrategy();

  runApp(const ProviderScope(child: App()));
}
--- FILE: pubspec.yaml ---
name: agenda_frontend
description: "Frontend per prenotazioni online - Agenda Platform"
publish_to: 'none'
version: 1.0.0+1

environment:
  sdk: ^3.10.4

dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter
  flutter_web_plugins:
    sdk: flutter
  
  intl: ^0.20.2    
  flutter_riverpod: ^3.0.3
  riverpod_annotation: ^3.0.3
  go_router: ^16.2.4
  dio: ^5.4.0
  uuid: ^4.3.3
  flutter_secure_storage: ^9.0.0

dev_dependencies:
  build_runner: ^2.7.1
  riverpod_generator: ^3.0.3
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0
  intl_utils: ^2.8.11

flutter:
  uses-material-design: true

flutter_intl:
  enabled: true
  class_name: L10n
  main_locale: it
  arb_dir: lib/core/l10n
  output_dir: lib/core/l10n

--------------------------

>>> CONTENUTO: Backend
--- FILE: lib/core/l10n/l10_extension.dart ---
import 'package:flutter/widgets.dart';

import 'l10n.dart';

/// üî§ Estensione per accedere facilmente alle stringhe localizzate.
///
/// Permette di scrivere:
/// ```dart
/// Text(context.l10n.welcomeMessage)
/// ```
/// invece di:
/// ```dart
/// Text(L10n.of(context).welcomeMessage)
/// ```
///
/// ‚úÖ Compatibile con aggiornamenti runtime della lingua.
/// ‚úÖ Evita dipendenze da `L10n.current` statico.
/// ‚úÖ Standard consigliato per progetti Flutter internazionalizzati.
extension L10nX on BuildContext {
  /// Restituisce l'istanza corrente di [L10n] per questo [BuildContext].
  L10n get l10n => L10n.of(this);
}

extension DurationLocalization on BuildContext {
  String localizedDurationLabel(int minutes) {
    final hours = minutes ~/ 60;
    final mins = minutes % 60;
    final l10n = this.l10n;

    if (hours > 0 && mins > 0) {
      return l10n.durationHourMinute(hours, mins);
    } else if (hours > 0) {
      return l10n.durationHour(hours);
    } else {
      return l10n.durationMinute(mins);
    }
  }
}
--- FILE: lib/core/l10n/intl/messages_all.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that looks up messages for specific locales by
// delegating to the appropriate library.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:implementation_imports, file_names, unnecessary_new
// ignore_for_file:unnecessary_brace_in_string_interps, directives_ordering
// ignore_for_file:argument_type_not_assignable, invalid_assignment
// ignore_for_file:prefer_single_quotes, prefer_generic_function_type_aliases
// ignore_for_file:comment_references

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';
import 'package:intl/src/intl_helpers.dart';

import 'messages_en.dart' as messages_en;
import 'messages_it.dart' as messages_it;

typedef Future<dynamic> LibraryLoader();
Map<String, LibraryLoader> _deferredLibraries = {
  'en': () => new SynchronousFuture(null),
  'it': () => new SynchronousFuture(null),
};

MessageLookupByLibrary? _findExact(String localeName) {
  switch (localeName) {
    case 'en':
      return messages_en.messages;
    case 'it':
      return messages_it.messages;
    default:
      return null;
  }
}

/// User programs should call this before using [localeName] for messages.
Future<bool> initializeMessages(String localeName) {
  var availableLocale = Intl.verifiedLocale(
    localeName,
    (locale) => _deferredLibraries[locale] != null,
    onFailure: (_) => null,
  );
  if (availableLocale == null) {
    return new SynchronousFuture(false);
  }
  var lib = _deferredLibraries[availableLocale];
  lib == null ? new SynchronousFuture(false) : lib();
  initializeInternalMessageLookup(() => new CompositeMessageLookup());
  messageLookup.addLocale(availableLocale, _findGeneratedMessagesFor);
  return new SynchronousFuture(true);
}

bool _messagesExistFor(String locale) {
  try {
    return _findExact(locale) != null;
  } catch (e) {
    return false;
  }
}

MessageLookupByLibrary? _findGeneratedMessagesFor(String locale) {
  var actualLocale = Intl.verifiedLocale(
    locale,
    _messagesExistFor,
    onFailure: (_) => null,
  );
  if (actualLocale == null) return null;
  return _findExact(actualLocale);
}
--- FILE: lib/core/l10n/intl/messages_it.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that provides messages for a it locale. All the
// messages from the main program should be duplicated here with the same
// function name.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:unnecessary_brace_in_string_interps, unnecessary_new
// ignore_for_file:prefer_single_quotes,comment_references, directives_ordering
// ignore_for_file:annotate_overrides,prefer_generic_function_type_aliases
// ignore_for_file:unused_import, file_names, avoid_escaping_inner_quotes
// ignore_for_file:unnecessary_string_interpolations, unnecessary_string_escapes

import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = new MessageLookup();

typedef String MessageIfAbsent(String messageStr, List<dynamic> args);

class MessageLookup extends MessageLookupByLibrary {
  String get localeName => 'it';

  static String m0(count) =>
      "Il cliente verr√† associato anche agli altri ${count} appuntamenti di questa prenotazione.";

  static String m1(name) => "Disponibilit√† ‚Äì ${name}";

  static String m2(clientName) => "Appuntamenti di ${clientName}";

  static String m3(hours) => "${hours} ora";

  static String m4(hours, minutes) => "${hours} ora ${minutes} min";

  static String m5(minutes) => "${minutes} min";

  static String m6(id) => "Eccezione non trovata: ${id}";

  static String m7(factor) => "Nessun builder disponibile per ${factor}";

  static String m8(path) => "Pagina non trovata: ${path}";

  static String m9(count) =>
      "${count} ${Intl.plural(count, one: 'giorno', other: 'giorni')}";

  static String m10(dates) => "Alcuni giorni non sono stati salvati: ${dates}.";

  static String m11(details) =>
      "Alcuni giorni non sono stati salvati: ${details}.";

  static String m12(hours) => "${hours}h";

  static String m13(hours, minutes) => "${hours}h ${minutes}m";

  static String m14(date) => "Ultima visita: ${date}";

  static String m15(newTime, staffName) =>
      "L\'appuntamento verr√† spostato alle ${newTime} per ${staffName}.";

  static String m16(date) => "Scade il ${date}";

  static String m17(email) => "Invito inviato a ${email}";

  static String m18(name) => "Invitato da ${name}";

  static String m19(count) => "${count} inviti in attesa";

  static String m20(name) => "Vuoi rimuovere ${name} dal team?";

  static String m21(email) => "Vuoi revocare l\'invito per ${email}?";

  static String m22(count) => "${count} membri abilitati";

  static String m23(count) =>
      "${Intl.plural(count, one: '1 servizio selezionato', other: '${count} servizi selezionati')}";

  static String m24(dayName) =>
      "Elimina la fascia oraria settimanale di ogni ${dayName}";

  static String m25(date) => "Elimina solo la fascia oraria di ${date}";

  static String m26(dayName) =>
      "Modifica la fascia oraria settimanale di ogni ${dayName}";

  static String m27(date) => "Modifica solo la fascia oraria di ${date}";

  static String m28(count) => "${count} servizi abilitati";

  static String m29(selected, total) => "${selected} su ${total}";

  static String m30(hours) => "${hours} ore totale";

  final messages = _notInlinedMessages(_notInlinedMessages);
  static Map<String, Function> _notInlinedMessages(_) => <String, Function>{
    "actionCancel": MessageLookupByLibrary.simpleMessage("Annulla"),
    "actionClose": MessageLookupByLibrary.simpleMessage("Conferma"),
    "actionConfirm": MessageLookupByLibrary.simpleMessage("Conferma"),
    "actionDelete": MessageLookupByLibrary.simpleMessage("Elimina"),
    "actionDeleteBooking": MessageLookupByLibrary.simpleMessage(
      "Elimina prenotazione",
    ),
    "actionDiscard": MessageLookupByLibrary.simpleMessage("Annulla"),
    "actionEdit": MessageLookupByLibrary.simpleMessage("Modifica"),
    "actionKeepEditing": MessageLookupByLibrary.simpleMessage(
      "Continua a modificare",
    ),
    "actionSave": MessageLookupByLibrary.simpleMessage("Salva"),
    "addClientToAppointment": MessageLookupByLibrary.simpleMessage(
      "Aggiungi un cliente all\'appuntamento",
    ),
    "addService": MessageLookupByLibrary.simpleMessage("Aggiungi un servizio"),
    "addServiceTooltip": MessageLookupByLibrary.simpleMessage(
      "Aggiungi servizio",
    ),
    "additionalTimeOptionBlocked": MessageLookupByLibrary.simpleMessage(
      "Tempo bloccato",
    ),
    "additionalTimeOptionProcessing": MessageLookupByLibrary.simpleMessage(
      "Tempo di lavorazione",
    ),
    "additionalTimeSwitch": MessageLookupByLibrary.simpleMessage(
      "Tempo aggiuntivo",
    ),
    "agendaAdd": MessageLookupByLibrary.simpleMessage("Aggiungi"),
    "agendaAddAppointment": MessageLookupByLibrary.simpleMessage(
      "Nuovo appuntamento",
    ),
    "agendaAddBlock": MessageLookupByLibrary.simpleMessage("Nuovo blocco"),
    "agendaAddTitle": MessageLookupByLibrary.simpleMessage("Aggiungi un..."),
    "agendaNextDay": MessageLookupByLibrary.simpleMessage("Giorno successivo"),
    "agendaNextMonth": MessageLookupByLibrary.simpleMessage("Mese successivo"),
    "agendaNextWeek": MessageLookupByLibrary.simpleMessage(
      "Settimana successivo",
    ),
    "agendaNoLocations": MessageLookupByLibrary.simpleMessage(
      "Nessuna sede disponibile",
    ),
    "agendaNoOnDutyTeamTitle": MessageLookupByLibrary.simpleMessage(
      "Nessun membro del team di turno oggi",
    ),
    "agendaNoSelectedTeamTitle": MessageLookupByLibrary.simpleMessage(
      "Nessun membro del team selezionato",
    ),
    "agendaPrevDay": MessageLookupByLibrary.simpleMessage("Giorno precedente"),
    "agendaPrevMonth": MessageLookupByLibrary.simpleMessage("Mese precedente"),
    "agendaPrevWeek": MessageLookupByLibrary.simpleMessage(
      "Settimana precedente",
    ),
    "agendaSelectLocation": MessageLookupByLibrary.simpleMessage(
      "Seleziona sede",
    ),
    "agendaShowAllTeamButton": MessageLookupByLibrary.simpleMessage(
      "Visualizza tutto il team",
    ),
    "agendaToday": MessageLookupByLibrary.simpleMessage("Oggi"),
    "allLocations": MessageLookupByLibrary.simpleMessage("Tutte le sedi"),
    "appTitle": MessageLookupByLibrary.simpleMessage("Agenda Platform"),
    "applyClientToAllAppointmentsMessage": m0,
    "applyClientToAllAppointmentsTitle": MessageLookupByLibrary.simpleMessage(
      "Applicare il cliente a tutta la prenotazione?",
    ),
    "appointmentDialogTitleEdit": MessageLookupByLibrary.simpleMessage(
      "Modifica appuntamento",
    ),
    "appointmentDialogTitleNew": MessageLookupByLibrary.simpleMessage(
      "Nuovo appuntamento",
    ),
    "appointmentNoteLabel": MessageLookupByLibrary.simpleMessage(
      "Nota appuntamento",
    ),
    "appointmentNotesTitle": MessageLookupByLibrary.simpleMessage("Note"),
    "atLeastOneServiceRequired": MessageLookupByLibrary.simpleMessage(
      "Aggiungi almeno un servizio",
    ),
    "authEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "authFirstName": MessageLookupByLibrary.simpleMessage("Nome"),
    "authForgotPassword": MessageLookupByLibrary.simpleMessage(
      "Password dimenticata?",
    ),
    "authForgotPasswordInfo": MessageLookupByLibrary.simpleMessage(
      "Contatta l\'amministratore di sistema per reimpostare la password.",
    ),
    "authInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Email non valida",
    ),
    "authLastName": MessageLookupByLibrary.simpleMessage("Cognome"),
    "authLogin": MessageLookupByLibrary.simpleMessage("Accedi"),
    "authLoginFailed": MessageLookupByLibrary.simpleMessage(
      "Credenziali non valide. Riprova.",
    ),
    "authLoginFooter": MessageLookupByLibrary.simpleMessage(
      "Accesso riservato agli operatori autorizzati",
    ),
    "authLoginSubtitle": MessageLookupByLibrary.simpleMessage(
      "Accedi al gestionale",
    ),
    "authLogout": MessageLookupByLibrary.simpleMessage("Esci"),
    "authPassword": MessageLookupByLibrary.simpleMessage("Password"),
    "authPasswordTooShort": MessageLookupByLibrary.simpleMessage(
      "Password troppo corta",
    ),
    "authPhone": MessageLookupByLibrary.simpleMessage("Telefono"),
    "authRememberMe": MessageLookupByLibrary.simpleMessage("Ricordami"),
    "authRequiredField": MessageLookupByLibrary.simpleMessage(
      "Campo obbligatorio",
    ),
    "authResetPasswordError": MessageLookupByLibrary.simpleMessage(
      "Si √® verificato un errore. Riprova pi√π tardi.",
    ),
    "authResetPasswordMessage": MessageLookupByLibrary.simpleMessage(
      "Inserisci la tua email. Ti invieremo un link per reimpostare la password.",
    ),
    "authResetPasswordSend": MessageLookupByLibrary.simpleMessage("Invia"),
    "authResetPasswordSuccess": MessageLookupByLibrary.simpleMessage(
      "Se l\'email esiste nel sistema, riceverai un link per reimpostare la password.",
    ),
    "authResetPasswordTitle": MessageLookupByLibrary.simpleMessage(
      "Recupera password",
    ),
    "availabilitySave": MessageLookupByLibrary.simpleMessage("Salva modifiche"),
    "availabilityTitle": MessageLookupByLibrary.simpleMessage(
      "Disponibilit√† settimanale",
    ),
    "availabilityTitleFor": m1,
    "blockAllDay": MessageLookupByLibrary.simpleMessage("Giornata intera"),
    "blockDialogTitleEdit": MessageLookupByLibrary.simpleMessage(
      "Modifica blocco",
    ),
    "blockDialogTitleNew": MessageLookupByLibrary.simpleMessage("Nuovo blocco"),
    "blockEndTime": MessageLookupByLibrary.simpleMessage("Orario fine"),
    "blockReason": MessageLookupByLibrary.simpleMessage("Motivo (opzionale)"),
    "blockReasonHint": MessageLookupByLibrary.simpleMessage(
      "Es. Riunione, Pausa, ecc.",
    ),
    "blockSelectStaff": MessageLookupByLibrary.simpleMessage("Seleziona team"),
    "blockSelectStaffError": MessageLookupByLibrary.simpleMessage(
      "Seleziona almeno un team",
    ),
    "blockStartTime": MessageLookupByLibrary.simpleMessage("Orario inizio"),
    "blockTimeError": MessageLookupByLibrary.simpleMessage(
      "L\'ora di fine deve essere successiva all\'ora di inizio",
    ),
    "bookableOnlineSwitch": MessageLookupByLibrary.simpleMessage(
      "Prenotabile online",
    ),
    "bookingDetails": MessageLookupByLibrary.simpleMessage(
      "Dettagli prenotazione",
    ),
    "bookingItems": MessageLookupByLibrary.simpleMessage("Servizi"),
    "bookingNotes": MessageLookupByLibrary.simpleMessage("Note prenotazione"),
    "bookingStaffNotEligibleWarning": MessageLookupByLibrary.simpleMessage(
      "Attenzione: il membro del team selezionato non √® abilitato per questo servizio.",
    ),
    "bookingTotal": MessageLookupByLibrary.simpleMessage("Totale"),
    "bookingUnavailableTimeWarningAppointment":
        MessageLookupByLibrary.simpleMessage(
          "Attenzione: l‚Äôorario selezionato per l‚Äôappuntamento include fasce non disponibili per il team scelto.",
        ),
    "bookingUnavailableTimeWarningService": MessageLookupByLibrary.simpleMessage(
      "Attenzione: l‚Äôorario di questo servizio include fasce non disponibili per il team scelto.",
    ),
    "cannotDeleteCategoryContent": MessageLookupByLibrary.simpleMessage(
      "La categoria contiene uno o pi√π servizi.",
    ),
    "cannotDeleteTitle": MessageLookupByLibrary.simpleMessage(
      "Impossibile eliminare",
    ),
    "cannotUndoWarning": MessageLookupByLibrary.simpleMessage(
      "Questa azione non pu√≤ essere annullata.",
    ),
    "categoryDuplicateError": MessageLookupByLibrary.simpleMessage(
      "Esiste gi√† una categoria con questo nome",
    ),
    "clientAppointmentsEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessun appuntamento",
    ),
    "clientAppointmentsPast": MessageLookupByLibrary.simpleMessage("Passati"),
    "clientAppointmentsTitle": m2,
    "clientAppointmentsUpcoming": MessageLookupByLibrary.simpleMessage(
      "Prossimi",
    ),
    "clientLockedHint": MessageLookupByLibrary.simpleMessage(
      "Il cliente non pu√≤ essere modificato per questo appuntamento",
    ),
    "clientNoteLabel": MessageLookupByLibrary.simpleMessage("Nota cliente"),
    "clientOptionalHint": MessageLookupByLibrary.simpleMessage(
      "Lascia il campo vuoto se non vuoi associare un cliente all\'appuntamento",
    ),
    "clientsEdit": MessageLookupByLibrary.simpleMessage("Modifica cliente"),
    "clientsEmpty": MessageLookupByLibrary.simpleMessage("Nessun cliente"),
    "clientsNew": MessageLookupByLibrary.simpleMessage("Nuovo cliente"),
    "clientsTitle": MessageLookupByLibrary.simpleMessage("Elenco Clienti"),
    "createCategoryButtonLabel": MessageLookupByLibrary.simpleMessage(
      "Nuova categoria",
    ),
    "createNewClient": MessageLookupByLibrary.simpleMessage(
      "Crea nuovo cliente",
    ),
    "currentWeek": MessageLookupByLibrary.simpleMessage("Settimana corrente"),
    "dayFridayFull": MessageLookupByLibrary.simpleMessage("venerd√¨"),
    "dayMondayFull": MessageLookupByLibrary.simpleMessage("luned√¨"),
    "daySaturdayFull": MessageLookupByLibrary.simpleMessage("sabato"),
    "daySundayFull": MessageLookupByLibrary.simpleMessage("domenica"),
    "dayThursdayFull": MessageLookupByLibrary.simpleMessage("gioved√¨"),
    "dayTuesdayFull": MessageLookupByLibrary.simpleMessage("marted√¨"),
    "dayWednesdayFull": MessageLookupByLibrary.simpleMessage("mercoled√¨"),
    "deleteAppointmentConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "L\'appuntamento verr√† rimosso. L\'operazione non pu√≤ essere annullata.",
    ),
    "deleteAppointmentConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare l\'appuntamento?",
    ),
    "deleteBookingConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "Verranno rimossi tutti i servizi collegati. L\'operazione non pu√≤ essere annullata.",
    ),
    "deleteBookingConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare l‚Äôintera prenotazione?",
    ),
    "deleteClientConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "Il cliente verr√† eliminato definitivamente. Questa azione non pu√≤ essere annullata.",
    ),
    "deleteClientConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare il cliente?",
    ),
    "deleteConfirmationTitle": MessageLookupByLibrary.simpleMessage(
      "Confermi l‚Äôeliminazione?",
    ),
    "deleteServiceQuestion": MessageLookupByLibrary.simpleMessage(
      "Eliminare il servizio?",
    ),
    "discardChangesMessage": MessageLookupByLibrary.simpleMessage(
      "Hai delle modifiche non salvate. Vuoi scartarle?",
    ),
    "discardChangesTitle": MessageLookupByLibrary.simpleMessage(
      "Modifiche non salvate",
    ),
    "duplicateAction": MessageLookupByLibrary.simpleMessage("Duplica"),
    "durationHour": m3,
    "durationHourMinute": m4,
    "durationMinute": m5,
    "editCategoryTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica categoria",
    ),
    "editServiceTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica servizio",
    ),
    "emptyCategoriesNotReorderableNote": MessageLookupByLibrary.simpleMessage(
      "Le categorie senza servizi non sono riordinabili e restano in coda.",
    ),
    "errorExceptionNotFound": m6,
    "errorFormFactorBuilderMissing": m7,
    "errorFormFactorBuilderRequired": MessageLookupByLibrary.simpleMessage(
      "Specificare almeno un builder per form factor",
    ),
    "errorNotFound": m8,
    "errorServiceNotFound": MessageLookupByLibrary.simpleMessage(
      "Servizio non trovato",
    ),
    "errorTitle": MessageLookupByLibrary.simpleMessage("Errore"),
    "exceptionAllDay": MessageLookupByLibrary.simpleMessage("Giornata intera"),
    "exceptionAvailableNoEffect": MessageLookupByLibrary.simpleMessage(
      "La disponibilit√† extra deve aggiungere ore rispetto alla disponibilit√† base.",
    ),
    "exceptionDateFrom": MessageLookupByLibrary.simpleMessage("Data inizio"),
    "exceptionDateTo": MessageLookupByLibrary.simpleMessage("Data fine"),
    "exceptionDeleteMessage": MessageLookupByLibrary.simpleMessage(
      "L\'eccezione verr√† eliminata definitivamente.",
    ),
    "exceptionDeleteShift": MessageLookupByLibrary.simpleMessage(
      "Elimina eccezione",
    ),
    "exceptionDeleteShiftDesc": MessageLookupByLibrary.simpleMessage(
      "Ripristina la disponibilit√† base",
    ),
    "exceptionDeleteTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare l\'eccezione?",
    ),
    "exceptionDialogTitleEdit": MessageLookupByLibrary.simpleMessage(
      "Modifica eccezione",
    ),
    "exceptionDialogTitleNew": MessageLookupByLibrary.simpleMessage(
      "Nuova eccezione",
    ),
    "exceptionDuration": MessageLookupByLibrary.simpleMessage(
      "Durata (giorni)",
    ),
    "exceptionDurationDays": m9,
    "exceptionEditShift": MessageLookupByLibrary.simpleMessage(
      "Modifica eccezione",
    ),
    "exceptionEditShiftDesc": MessageLookupByLibrary.simpleMessage(
      "Modifica gli orari di questa eccezione",
    ),
    "exceptionEndTime": MessageLookupByLibrary.simpleMessage("Orario fine"),
    "exceptionPartialSaveInfo": m10,
    "exceptionPartialSaveInfoDetailed": m11,
    "exceptionPartialSaveMessage": MessageLookupByLibrary.simpleMessage(
      "I giorni sotto non erano congruenti e non sono stati salvati:",
    ),
    "exceptionPartialSaveTitle": MessageLookupByLibrary.simpleMessage(
      "Eccezioni non salvate",
    ),
    "exceptionPeriodDuration": MessageLookupByLibrary.simpleMessage("Durata"),
    "exceptionPeriodMode": MessageLookupByLibrary.simpleMessage("Periodo"),
    "exceptionPeriodRange": MessageLookupByLibrary.simpleMessage("Da - A"),
    "exceptionPeriodSingle": MessageLookupByLibrary.simpleMessage(
      "Giorno singolo",
    ),
    "exceptionReason": MessageLookupByLibrary.simpleMessage(
      "Motivo (opzionale)",
    ),
    "exceptionReasonExtraShift": MessageLookupByLibrary.simpleMessage(
      "Turno extra",
    ),
    "exceptionReasonHint": MessageLookupByLibrary.simpleMessage(
      "Es. Ferie, Visita medica, Turno extra...",
    ),
    "exceptionReasonMedicalVisit": MessageLookupByLibrary.simpleMessage(
      "Visita medica",
    ),
    "exceptionReasonVacation": MessageLookupByLibrary.simpleMessage("Ferie"),
    "exceptionSelectTime": MessageLookupByLibrary.simpleMessage(
      "Seleziona orario",
    ),
    "exceptionStartTime": MessageLookupByLibrary.simpleMessage("Orario inizio"),
    "exceptionTimeError": MessageLookupByLibrary.simpleMessage(
      "L\'ora di fine deve essere successiva all\'ora di inizio",
    ),
    "exceptionType": MessageLookupByLibrary.simpleMessage("Tipo eccezione"),
    "exceptionTypeAvailable": MessageLookupByLibrary.simpleMessage(
      "Disponibile",
    ),
    "exceptionTypeUnavailable": MessageLookupByLibrary.simpleMessage(
      "Non disponibile",
    ),
    "exceptionUnavailableNoBase": MessageLookupByLibrary.simpleMessage(
      "Non puoi aggiungere una non disponibilit√† in un giorno senza disponibilit√† base.",
    ),
    "exceptionUnavailableNoOverlap": MessageLookupByLibrary.simpleMessage(
      "La non disponibilit√† deve sovrapporsi alla disponibilit√† base.",
    ),
    "exceptionsAdd": MessageLookupByLibrary.simpleMessage("Aggiungi eccezione"),
    "exceptionsEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessuna eccezione configurata",
    ),
    "exceptionsTitle": MessageLookupByLibrary.simpleMessage("Eccezioni"),
    "fieldBlockedTimeLabel": MessageLookupByLibrary.simpleMessage(
      "Tempo bloccato",
    ),
    "fieldCategoryRequiredLabel": MessageLookupByLibrary.simpleMessage(
      "Categoria *",
    ),
    "fieldDescriptionLabel": MessageLookupByLibrary.simpleMessage(
      "Descrizione",
    ),
    "fieldDurationRequiredError": MessageLookupByLibrary.simpleMessage(
      "Seleziona una durata",
    ),
    "fieldDurationRequiredLabel": MessageLookupByLibrary.simpleMessage(
      "Durata *",
    ),
    "fieldNameRequiredError": MessageLookupByLibrary.simpleMessage(
      "Il nome √® obbligatorio",
    ),
    "fieldNameRequiredLabel": MessageLookupByLibrary.simpleMessage("Nome *"),
    "fieldPriceLabel": MessageLookupByLibrary.simpleMessage("Prezzo"),
    "fieldProcessingTimeLabel": MessageLookupByLibrary.simpleMessage(
      "Tempo di lavorazione",
    ),
    "filterAll": MessageLookupByLibrary.simpleMessage("Tutti"),
    "filterInactive": MessageLookupByLibrary.simpleMessage("Inattivi"),
    "filterNew": MessageLookupByLibrary.simpleMessage("Nuovi"),
    "filterVIP": MessageLookupByLibrary.simpleMessage("VIP"),
    "formClient": MessageLookupByLibrary.simpleMessage("Cliente"),
    "formDate": MessageLookupByLibrary.simpleMessage("Data"),
    "formEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "formFirstName": MessageLookupByLibrary.simpleMessage("Nome"),
    "formLastName": MessageLookupByLibrary.simpleMessage("Cognome"),
    "formNotes": MessageLookupByLibrary.simpleMessage(
      "Note (non visibili al cliente)",
    ),
    "formPhone": MessageLookupByLibrary.simpleMessage("Telefono"),
    "formService": MessageLookupByLibrary.simpleMessage("Servizio"),
    "formServices": MessageLookupByLibrary.simpleMessage("Servizi"),
    "formStaff": MessageLookupByLibrary.simpleMessage("Team"),
    "freeLabel": MessageLookupByLibrary.simpleMessage("Gratis"),
    "freeServiceSwitch": MessageLookupByLibrary.simpleMessage(
      "Servizio gratuito",
    ),
    "hoursHoursOnly": m12,
    "hoursMinutesCompact": m13,
    "labelSelect": MessageLookupByLibrary.simpleMessage("Seleziona"),
    "labelStaff": MessageLookupByLibrary.simpleMessage("Team:"),
    "lastVisitLabel": m14,
    "moveAppointmentConfirmMessage": m15,
    "moveAppointmentConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Confermi lo spostamento?",
    ),
    "navAgenda": MessageLookupByLibrary.simpleMessage("Agenda"),
    "navClients": MessageLookupByLibrary.simpleMessage("Clienti"),
    "navProfile": MessageLookupByLibrary.simpleMessage("Profilo"),
    "navServices": MessageLookupByLibrary.simpleMessage("Servizi"),
    "navStaff": MessageLookupByLibrary.simpleMessage("Team"),
    "newCategoryTitle": MessageLookupByLibrary.simpleMessage("Nuova categoria"),
    "newServiceTitle": MessageLookupByLibrary.simpleMessage("Nuovo servizio"),
    "noClientForAppointment": MessageLookupByLibrary.simpleMessage(
      "Nessun cliente per l\'appuntamento",
    ),
    "noServicesAdded": MessageLookupByLibrary.simpleMessage(
      "Nessun servizio aggiunto",
    ),
    "noServicesInCategory": MessageLookupByLibrary.simpleMessage(
      "Nessun servizio in questa categoria",
    ),
    "noStaffAvailable": MessageLookupByLibrary.simpleMessage(
      "Nessun team disponibile",
    ),
    "notBookableOnline": MessageLookupByLibrary.simpleMessage(
      "Non prenotabile online",
    ),
    "notesPlaceholder": MessageLookupByLibrary.simpleMessage(
      "Note sull\'appuntamento...",
    ),
    "operatorsEditRole": MessageLookupByLibrary.simpleMessage("Modifica ruolo"),
    "operatorsEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessun operatore configurato",
    ),
    "operatorsExpires": m16,
    "operatorsInviteCopied": MessageLookupByLibrary.simpleMessage(
      "Link di invito copiato",
    ),
    "operatorsInviteEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "operatorsInviteRole": MessageLookupByLibrary.simpleMessage("Ruolo"),
    "operatorsInviteSend": MessageLookupByLibrary.simpleMessage("Invia invito"),
    "operatorsInviteSubtitle": MessageLookupByLibrary.simpleMessage(
      "Invia un invito via email",
    ),
    "operatorsInviteSuccess": m17,
    "operatorsInviteTitle": MessageLookupByLibrary.simpleMessage(
      "Invita operatore",
    ),
    "operatorsInvitedBy": m18,
    "operatorsPendingInvites": MessageLookupByLibrary.simpleMessage(
      "Inviti in attesa",
    ),
    "operatorsPendingInvitesCount": m19,
    "operatorsRemove": MessageLookupByLibrary.simpleMessage(
      "Rimuovi operatore",
    ),
    "operatorsRemoveConfirm": m20,
    "operatorsRemoveSuccess": MessageLookupByLibrary.simpleMessage(
      "Operatore rimosso",
    ),
    "operatorsRevokeInvite": MessageLookupByLibrary.simpleMessage(
      "Revoca invito",
    ),
    "operatorsRevokeInviteConfirm": m21,
    "operatorsRoleAdmin": MessageLookupByLibrary.simpleMessage(
      "Amministratore",
    ),
    "operatorsRoleDescription": MessageLookupByLibrary.simpleMessage(
      "Seleziona il livello di accesso",
    ),
    "operatorsRoleManager": MessageLookupByLibrary.simpleMessage("Manager"),
    "operatorsRoleOwner": MessageLookupByLibrary.simpleMessage("Proprietario"),
    "operatorsRoleStaff": MessageLookupByLibrary.simpleMessage("Staff"),
    "operatorsSubtitle": MessageLookupByLibrary.simpleMessage(
      "Gestisci chi pu√≤ accedere al gestionale",
    ),
    "operatorsTitle": MessageLookupByLibrary.simpleMessage("Operatori"),
    "operatorsYou": MessageLookupByLibrary.simpleMessage("Tu"),
    "priceNotAvailable": MessageLookupByLibrary.simpleMessage("N/D"),
    "priceStartingFromPrefix": MessageLookupByLibrary.simpleMessage(
      "a partire da",
    ),
    "priceStartingFromSwitch": MessageLookupByLibrary.simpleMessage(
      "Prezzo \"a partire da\"",
    ),
    "profileTitle": MessageLookupByLibrary.simpleMessage("Profilo"),
    "removeClient": MessageLookupByLibrary.simpleMessage("Rimuovi cliente"),
    "reorderCategoriesLabel": MessageLookupByLibrary.simpleMessage("Categorie"),
    "reorderHelpDescription": MessageLookupByLibrary.simpleMessage(
      "Riordina categorie e servizi trascinandoli: l‚Äôordine sar√† lo stesso anche nella prenotazione online. Seleziona se ordinare categorie o servizi.",
    ),
    "reorderServicesLabel": MessageLookupByLibrary.simpleMessage("Servizi"),
    "reorderTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica ordinamento",
    ),
    "searchClientPlaceholder": MessageLookupByLibrary.simpleMessage(
      "Cerca cliente...",
    ),
    "selectClientTitle": MessageLookupByLibrary.simpleMessage(
      "Seleziona cliente",
    ),
    "selectService": MessageLookupByLibrary.simpleMessage(
      "Seleziona un servizio",
    ),
    "selectStaffTitle": MessageLookupByLibrary.simpleMessage("Seleziona team"),
    "serviceColorLabel": MessageLookupByLibrary.simpleMessage(
      "Colore servizio",
    ),
    "serviceDuplicateCopyWord": MessageLookupByLibrary.simpleMessage("Copia"),
    "serviceDuplicateError": MessageLookupByLibrary.simpleMessage(
      "Esiste gi√† un servizio con questo nome",
    ),
    "serviceEligibleStaffCount": m22,
    "serviceEligibleStaffNone": MessageLookupByLibrary.simpleMessage(
      "Nessun membro abilitato",
    ),
    "serviceSeedCategoryBodyDescription": MessageLookupByLibrary.simpleMessage(
      "Servizi dedicati al benessere del corpo",
    ),
    "serviceSeedCategoryBodyName": MessageLookupByLibrary.simpleMessage(
      "Trattamenti Corpo",
    ),
    "serviceSeedCategoryFaceDescription": MessageLookupByLibrary.simpleMessage(
      "Cura estetica e rigenerante per il viso",
    ),
    "serviceSeedCategoryFaceName": MessageLookupByLibrary.simpleMessage(
      "Trattamenti Viso",
    ),
    "serviceSeedCategorySportsDescription":
        MessageLookupByLibrary.simpleMessage(
          "Percorsi pensati per atleti e persone attive",
        ),
    "serviceSeedCategorySportsName": MessageLookupByLibrary.simpleMessage(
      "Trattamenti Sportivi",
    ),
    "serviceSeedServiceFaceDescription": MessageLookupByLibrary.simpleMessage(
      "Pulizia e trattamento illuminante",
    ),
    "serviceSeedServiceFaceName": MessageLookupByLibrary.simpleMessage(
      "Trattamento Viso",
    ),
    "serviceSeedServiceRelaxDescription": MessageLookupByLibrary.simpleMessage(
      "Trattamento rilassante da 30 minuti",
    ),
    "serviceSeedServiceRelaxName": MessageLookupByLibrary.simpleMessage(
      "Massaggio Relax",
    ),
    "serviceSeedServiceSportDescription": MessageLookupByLibrary.simpleMessage(
      "Trattamento decontratturante intensivo",
    ),
    "serviceSeedServiceSportName": MessageLookupByLibrary.simpleMessage(
      "Massaggio Sportivo",
    ),
    "servicesNewServiceMenu": MessageLookupByLibrary.simpleMessage(
      "Nuovo servizio",
    ),
    "servicesSelectedCount": m23,
    "setPriceToEnable": MessageLookupByLibrary.simpleMessage(
      "Imposta un prezzo per abilitarlo",
    ),
    "shiftDeleteAll": MessageLookupByLibrary.simpleMessage(
      "Elimina tutti questi turni",
    ),
    "shiftDeleteAllDesc": m24,
    "shiftDeleteThisOnly": MessageLookupByLibrary.simpleMessage(
      "Elimina solo questo turno",
    ),
    "shiftDeleteThisOnlyDesc": m25,
    "shiftEditAll": MessageLookupByLibrary.simpleMessage(
      "Modifica tutti questi turni",
    ),
    "shiftEditAllDesc": m26,
    "shiftEditThisOnly": MessageLookupByLibrary.simpleMessage(
      "Modifica solo questo turno",
    ),
    "shiftEditThisOnlyDesc": m27,
    "shiftEditTitle": MessageLookupByLibrary.simpleMessage("Modifica turno"),
    "shiftEndTime": MessageLookupByLibrary.simpleMessage("Ora fine"),
    "shiftStartTime": MessageLookupByLibrary.simpleMessage("Ora inizio"),
    "sortByCreatedAtAsc": MessageLookupByLibrary.simpleMessage(
      "Data creazione (vecchi)",
    ),
    "sortByCreatedAtDesc": MessageLookupByLibrary.simpleMessage(
      "Data creazione (nuovi)",
    ),
    "sortByLastNameAsc": MessageLookupByLibrary.simpleMessage("Cognome (A-Z)"),
    "sortByLastNameDesc": MessageLookupByLibrary.simpleMessage("Cognome (Z-A)"),
    "sortByLastVisitAsc": MessageLookupByLibrary.simpleMessage(
      "Ultima visita (meno recenti)",
    ),
    "sortByLastVisitDesc": MessageLookupByLibrary.simpleMessage(
      "Ultima visita (recenti)",
    ),
    "sortByNameAsc": MessageLookupByLibrary.simpleMessage("Nome (A-Z)"),
    "sortByNameDesc": MessageLookupByLibrary.simpleMessage("Nome (Z-A)"),
    "sortByTitle": MessageLookupByLibrary.simpleMessage("Ordina per"),
    "staffEditHours": MessageLookupByLibrary.simpleMessage("Modifica orari"),
    "staffFilterAllTeam": MessageLookupByLibrary.simpleMessage("Tutto il team"),
    "staffFilterOnDuty": MessageLookupByLibrary.simpleMessage("Team di turno"),
    "staffFilterSelectMembers": MessageLookupByLibrary.simpleMessage(
      "Seleziona membri del team",
    ),
    "staffFilterTitle": MessageLookupByLibrary.simpleMessage("Filtra team"),
    "staffFilterTooltip": MessageLookupByLibrary.simpleMessage("Filtra team"),
    "staffHubAvailabilitySubtitle": MessageLookupByLibrary.simpleMessage(
      "Configura gli orari di lavoro settimanali",
    ),
    "staffHubAvailabilityTitle": MessageLookupByLibrary.simpleMessage(
      "Disponibilit√†",
    ),
    "staffHubNotYetAvailable": MessageLookupByLibrary.simpleMessage(
      "Non ancora disponibile",
    ),
    "staffHubStatsSubtitle": MessageLookupByLibrary.simpleMessage(
      "Performance e carichi di lavoro",
    ),
    "staffHubStatsTitle": MessageLookupByLibrary.simpleMessage("Statistiche"),
    "staffHubTeamSubtitle": MessageLookupByLibrary.simpleMessage(
      "Gestione membri e ruoli",
    ),
    "staffHubTeamTitle": MessageLookupByLibrary.simpleMessage("Team"),
    "staffNotBookableOnlineMessage": MessageLookupByLibrary.simpleMessage(
      "Questo membro del team non √® abilitato alle prenotazioni online. Puoi modificare l‚Äôimpostazione dal form di modifica dello staff.",
    ),
    "staffNotBookableOnlineTitle": MessageLookupByLibrary.simpleMessage(
      "Non prenotabile online",
    ),
    "staffNotBookableOnlineTooltip": MessageLookupByLibrary.simpleMessage(
      "Non prenotabile online",
    ),
    "staffScreenPlaceholder": MessageLookupByLibrary.simpleMessage(
      "Schermata Team",
    ),
    "switchBusiness": MessageLookupByLibrary.simpleMessage("Cambia"),
    "teamAddStaff": MessageLookupByLibrary.simpleMessage("Aggiungi membro"),
    "teamChooseLocationSingleButton": MessageLookupByLibrary.simpleMessage(
      "Seleziona la sede",
    ),
    "teamChooseLocationsButton": MessageLookupByLibrary.simpleMessage(
      "Seleziona sedi",
    ),
    "teamDeleteLocationBlockedMessage": MessageLookupByLibrary.simpleMessage(
      "Rimuovi prima tutti i membri del team associati.",
    ),
    "teamDeleteLocationBlockedTitle": MessageLookupByLibrary.simpleMessage(
      "Impossibile eliminare la sede",
    ),
    "teamDeleteLocationMessage": MessageLookupByLibrary.simpleMessage(
      "La sede verr√† rimossa dal team. L\'operazione non pu√≤ essere annullata.",
    ),
    "teamDeleteLocationTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare la sede?",
    ),
    "teamDeleteStaffMessage": MessageLookupByLibrary.simpleMessage(
      "Il membro verr√† rimosso dal team. L\'operazione non pu√≤ essere annullata.",
    ),
    "teamDeleteStaffTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare il membro del team?",
    ),
    "teamEditLocationTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica sede",
    ),
    "teamEditStaffTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica membro del team",
    ),
    "teamEligibleServicesCount": m28,
    "teamEligibleServicesLabel": MessageLookupByLibrary.simpleMessage(
      "Servizi abilitati",
    ),
    "teamEligibleServicesNone": MessageLookupByLibrary.simpleMessage(
      "Nessun servizio abilitato",
    ),
    "teamEligibleStaffLabel": MessageLookupByLibrary.simpleMessage(
      "Team abilitato",
    ),
    "teamLocationAddressLabel": MessageLookupByLibrary.simpleMessage(
      "Indirizzo",
    ),
    "teamLocationEmailHint": MessageLookupByLibrary.simpleMessage(
      "Email per notifiche ai clienti",
    ),
    "teamLocationEmailLabel": MessageLookupByLibrary.simpleMessage("Email"),
    "teamLocationIsActiveHint": MessageLookupByLibrary.simpleMessage(
      "Se disattivata, la sede non sar√† visibile ai clienti",
    ),
    "teamLocationIsActiveLabel": MessageLookupByLibrary.simpleMessage(
      "Sede attiva",
    ),
    "teamLocationLabel": MessageLookupByLibrary.simpleMessage("Sede"),
    "teamLocationNameLabel": MessageLookupByLibrary.simpleMessage("Nome sede"),
    "teamLocationsLabel": MessageLookupByLibrary.simpleMessage("Sedi"),
    "teamNewLocationTitle": MessageLookupByLibrary.simpleMessage("Nuova sede"),
    "teamNewStaffTitle": MessageLookupByLibrary.simpleMessage(
      "Nuovo membro del team",
    ),
    "teamNoStaffInLocation": MessageLookupByLibrary.simpleMessage(
      "Nessun membro in questa sede",
    ),
    "teamReorderHelpDescription": MessageLookupByLibrary.simpleMessage(
      "Riordina sedi e membri del team trascinandoli. Seleziona se ordinare sedi o team. L‚Äôordine sar√† lo stesso anche nella sezione agenda.",
    ),
    "teamSelectAllLocations": MessageLookupByLibrary.simpleMessage(
      "Seleziona tutto",
    ),
    "teamSelectAllServices": MessageLookupByLibrary.simpleMessage(
      "Seleziona tutto",
    ),
    "teamSelectedServicesButton": MessageLookupByLibrary.simpleMessage(
      "Servizi selezionati",
    ),
    "teamSelectedServicesCount": m29,
    "teamServicesLabel": MessageLookupByLibrary.simpleMessage("Servizi"),
    "teamStaffBookableOnlineLabel": MessageLookupByLibrary.simpleMessage(
      "Abilitato alle prenotazioni online",
    ),
    "teamStaffColorLabel": MessageLookupByLibrary.simpleMessage("Colore"),
    "teamStaffLabel": MessageLookupByLibrary.simpleMessage("Team"),
    "teamStaffLocationsLabel": MessageLookupByLibrary.simpleMessage(
      "Sedi associate",
    ),
    "teamStaffMultiLocationWarning": MessageLookupByLibrary.simpleMessage(
      "Se il membro lavora su pi√π sedi, ricorda di allineare disponibilit√† e orari con le sedi selezionate.",
    ),
    "teamStaffNameLabel": MessageLookupByLibrary.simpleMessage("Nome"),
    "teamStaffSurnameLabel": MessageLookupByLibrary.simpleMessage("Cognome"),
    "validationInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Email non valida",
    ),
    "validationInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Telefono non valido",
    ),
    "validationNameOrLastNameRequired": MessageLookupByLibrary.simpleMessage(
      "Inserire almeno nome o cognome",
    ),
    "validationRequired": MessageLookupByLibrary.simpleMessage("Richiesto"),
    "weeklyScheduleAddShift": MessageLookupByLibrary.simpleMessage(
      "Aggiungi turno",
    ),
    "weeklyScheduleFor": MessageLookupByLibrary.simpleMessage("-"),
    "weeklyScheduleNotWorking": MessageLookupByLibrary.simpleMessage(
      "Non lavora",
    ),
    "weeklyScheduleRemoveShift": MessageLookupByLibrary.simpleMessage(
      "Rimuovi turno",
    ),
    "weeklyScheduleTitle": MessageLookupByLibrary.simpleMessage(
      "Orario settimanale",
    ),
    "weeklyScheduleTotalHours": m30,
  };
}
--- FILE: lib/core/l10n/intl/messages_en.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that provides messages for a en locale. All the
// messages from the main program should be duplicated here with the same
// function name.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:unnecessary_brace_in_string_interps, unnecessary_new
// ignore_for_file:prefer_single_quotes,comment_references, directives_ordering
// ignore_for_file:annotate_overrides,prefer_generic_function_type_aliases
// ignore_for_file:unused_import, file_names, avoid_escaping_inner_quotes
// ignore_for_file:unnecessary_string_interpolations, unnecessary_string_escapes

import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = new MessageLookup();

typedef String MessageIfAbsent(String messageStr, List<dynamic> args);

class MessageLookup extends MessageLookupByLibrary {
  String get localeName => 'en';

  static String m0(count) =>
      "The client will also be associated with the other ${count} appointments in this booking.";

  static String m1(name) => "Availability ‚Äì ${name}";

  static String m2(clientName) => "${clientName}\'s appointments";

  static String m3(hours) => "${hours} hour";

  static String m4(hours, minutes) => "${hours} hour ${minutes} min";

  static String m5(minutes) => "${minutes} min";

  static String m6(id) => "Exception not found: ${id}";

  static String m7(factor) => "No builder available for ${factor}";

  static String m8(path) => "Page not found: ${path}";

  static String m9(count) =>
      "${count} ${Intl.plural(count, one: 'day', other: 'days')}";

  static String m10(dates) => "Some days were not saved: ${dates}.";

  static String m11(details) => "Some days were not saved: ${details}.";

  static String m12(hours) => "${hours}h";

  static String m13(hours, minutes) => "${hours}h ${minutes}m";

  static String m14(date) => "Last visit: ${date}";

  static String m15(newTime, staffName) =>
      "The appointment will be moved to ${newTime} for ${staffName}.";

  static String m16(date) => "Expires on ${date}";

  static String m17(email) => "Invite sent to ${email}";

  static String m18(name) => "Invited by ${name}";

  static String m19(count) => "${count} pending invites";

  static String m20(name) => "Do you want to remove ${name} from the team?";

  static String m21(email) => "Do you want to revoke the invite for ${email}?";

  static String m22(count) => "${count} eligible team members";

  static String m23(count) =>
      "${Intl.plural(count, one: '1 service selected', other: '${count} services selected')}";

  static String m24(dayName) =>
      "Delete the weekly time slot for every ${dayName}";

  static String m25(date) => "Delete only the time slot of ${date}";

  static String m26(dayName) =>
      "Edit the weekly time slot for every ${dayName}";

  static String m27(date) => "Edit only the time slot of ${date}";

  static String m28(count) => "${count} eligible services";

  static String m29(selected, total) => "${selected} of ${total}";

  static String m30(hours) => "${hours} hours total";

  final messages = _notInlinedMessages(_notInlinedMessages);
  static Map<String, Function> _notInlinedMessages(_) => <String, Function>{
    "actionCancel": MessageLookupByLibrary.simpleMessage("Cancel"),
    "actionClose": MessageLookupByLibrary.simpleMessage("Close"),
    "actionConfirm": MessageLookupByLibrary.simpleMessage("Confirm"),
    "actionDelete": MessageLookupByLibrary.simpleMessage("Delete"),
    "actionDeleteBooking": MessageLookupByLibrary.simpleMessage(
      "Delete booking",
    ),
    "actionDiscard": MessageLookupByLibrary.simpleMessage("Cancel"),
    "actionEdit": MessageLookupByLibrary.simpleMessage("Edit"),
    "actionKeepEditing": MessageLookupByLibrary.simpleMessage("Keep editing"),
    "actionSave": MessageLookupByLibrary.simpleMessage("Save"),
    "addClientToAppointment": MessageLookupByLibrary.simpleMessage(
      "Add a client to the appointment",
    ),
    "addService": MessageLookupByLibrary.simpleMessage("Add service"),
    "addServiceTooltip": MessageLookupByLibrary.simpleMessage("Add service"),
    "additionalTimeOptionBlocked": MessageLookupByLibrary.simpleMessage(
      "Blocked time",
    ),
    "additionalTimeOptionProcessing": MessageLookupByLibrary.simpleMessage(
      "Processing time",
    ),
    "additionalTimeSwitch": MessageLookupByLibrary.simpleMessage(
      "Additional time",
    ),
    "agendaAdd": MessageLookupByLibrary.simpleMessage("Add"),
    "agendaAddAppointment": MessageLookupByLibrary.simpleMessage(
      "New appointment",
    ),
    "agendaAddBlock": MessageLookupByLibrary.simpleMessage("New block"),
    "agendaAddTitle": MessageLookupByLibrary.simpleMessage("Add a..."),
    "agendaNextDay": MessageLookupByLibrary.simpleMessage("Next day"),
    "agendaNextMonth": MessageLookupByLibrary.simpleMessage("Next month"),
    "agendaNextWeek": MessageLookupByLibrary.simpleMessage("Next Week"),
    "agendaNoLocations": MessageLookupByLibrary.simpleMessage(
      "No locations available",
    ),
    "agendaNoOnDutyTeamTitle": MessageLookupByLibrary.simpleMessage(
      "No team members on duty today",
    ),
    "agendaNoSelectedTeamTitle": MessageLookupByLibrary.simpleMessage(
      "No selected team members",
    ),
    "agendaPrevDay": MessageLookupByLibrary.simpleMessage("Previous day"),
    "agendaPrevMonth": MessageLookupByLibrary.simpleMessage("Previous month"),
    "agendaPrevWeek": MessageLookupByLibrary.simpleMessage("Previous Week"),
    "agendaSelectLocation": MessageLookupByLibrary.simpleMessage(
      "Select location",
    ),
    "agendaShowAllTeamButton": MessageLookupByLibrary.simpleMessage(
      "View all team",
    ),
    "agendaToday": MessageLookupByLibrary.simpleMessage("Today"),
    "allLocations": MessageLookupByLibrary.simpleMessage("All locations"),
    "appTitle": MessageLookupByLibrary.simpleMessage("Agenda Platform"),
    "applyClientToAllAppointmentsMessage": m0,
    "applyClientToAllAppointmentsTitle": MessageLookupByLibrary.simpleMessage(
      "Apply client to entire booking?",
    ),
    "appointmentDialogTitleEdit": MessageLookupByLibrary.simpleMessage(
      "Edit appointment",
    ),
    "appointmentDialogTitleNew": MessageLookupByLibrary.simpleMessage(
      "New appointment",
    ),
    "appointmentNoteLabel": MessageLookupByLibrary.simpleMessage(
      "Appointment note",
    ),
    "appointmentNotesTitle": MessageLookupByLibrary.simpleMessage("Notes"),
    "atLeastOneServiceRequired": MessageLookupByLibrary.simpleMessage(
      "Add at least one service",
    ),
    "authEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "authFirstName": MessageLookupByLibrary.simpleMessage("First Name"),
    "authForgotPassword": MessageLookupByLibrary.simpleMessage(
      "Forgot password?",
    ),
    "authForgotPasswordInfo": MessageLookupByLibrary.simpleMessage(
      "Contact the system administrator to reset your password.",
    ),
    "authInvalidEmail": MessageLookupByLibrary.simpleMessage("Invalid email"),
    "authLastName": MessageLookupByLibrary.simpleMessage("Last Name"),
    "authLogin": MessageLookupByLibrary.simpleMessage("Sign In"),
    "authLoginFailed": MessageLookupByLibrary.simpleMessage(
      "Invalid credentials. Please try again.",
    ),
    "authLoginFooter": MessageLookupByLibrary.simpleMessage(
      "Access reserved for authorized operators",
    ),
    "authLoginSubtitle": MessageLookupByLibrary.simpleMessage(
      "Sign in to the management system",
    ),
    "authLogout": MessageLookupByLibrary.simpleMessage("Sign Out"),
    "authPassword": MessageLookupByLibrary.simpleMessage("Password"),
    "authPasswordTooShort": MessageLookupByLibrary.simpleMessage(
      "Password too short",
    ),
    "authPhone": MessageLookupByLibrary.simpleMessage("Phone"),
    "authRememberMe": MessageLookupByLibrary.simpleMessage("Remember me"),
    "authRequiredField": MessageLookupByLibrary.simpleMessage("Required field"),
    "authResetPasswordError": MessageLookupByLibrary.simpleMessage(
      "An error occurred. Please try again later.",
    ),
    "authResetPasswordMessage": MessageLookupByLibrary.simpleMessage(
      "Enter your email. We will send you a link to reset your password.",
    ),
    "authResetPasswordSend": MessageLookupByLibrary.simpleMessage("Send"),
    "authResetPasswordSuccess": MessageLookupByLibrary.simpleMessage(
      "If the email exists in our system, you will receive a password reset link.",
    ),
    "authResetPasswordTitle": MessageLookupByLibrary.simpleMessage(
      "Reset password",
    ),
    "availabilitySave": MessageLookupByLibrary.simpleMessage("Save changes"),
    "availabilityTitle": MessageLookupByLibrary.simpleMessage(
      "Weekly availability",
    ),
    "availabilityTitleFor": m1,
    "blockAllDay": MessageLookupByLibrary.simpleMessage("All day"),
    "blockDialogTitleEdit": MessageLookupByLibrary.simpleMessage("Edit block"),
    "blockDialogTitleNew": MessageLookupByLibrary.simpleMessage("New block"),
    "blockEndTime": MessageLookupByLibrary.simpleMessage("End time"),
    "blockReason": MessageLookupByLibrary.simpleMessage("Reason (optional)"),
    "blockReasonHint": MessageLookupByLibrary.simpleMessage(
      "E.g. Meeting, Break, etc.",
    ),
    "blockSelectStaff": MessageLookupByLibrary.simpleMessage("Select team"),
    "blockSelectStaffError": MessageLookupByLibrary.simpleMessage(
      "Select at least one team member",
    ),
    "blockStartTime": MessageLookupByLibrary.simpleMessage("Start time"),
    "blockTimeError": MessageLookupByLibrary.simpleMessage(
      "End time must be after start time",
    ),
    "bookableOnlineSwitch": MessageLookupByLibrary.simpleMessage(
      "Bookable online",
    ),
    "bookingDetails": MessageLookupByLibrary.simpleMessage("Booking details"),
    "bookingItems": MessageLookupByLibrary.simpleMessage("Services"),
    "bookingNotes": MessageLookupByLibrary.simpleMessage("Booking notes"),
    "bookingStaffNotEligibleWarning": MessageLookupByLibrary.simpleMessage(
      "Warning: the selected team member is not eligible for this service.",
    ),
    "bookingTotal": MessageLookupByLibrary.simpleMessage("Total"),
    "bookingUnavailableTimeWarningAppointment":
        MessageLookupByLibrary.simpleMessage(
          "Warning: the appointment time includes unavailable slots for the chosen team.",
        ),
    "bookingUnavailableTimeWarningService": MessageLookupByLibrary.simpleMessage(
      "Warning: this service time includes unavailable slots for the chosen team.",
    ),
    "cannotDeleteCategoryContent": MessageLookupByLibrary.simpleMessage(
      "This category contains one or more services.",
    ),
    "cannotDeleteTitle": MessageLookupByLibrary.simpleMessage("Cannot delete"),
    "cannotUndoWarning": MessageLookupByLibrary.simpleMessage(
      "This action cannot be undone.",
    ),
    "categoryDuplicateError": MessageLookupByLibrary.simpleMessage(
      "A category with this name already exists",
    ),
    "clientAppointmentsEmpty": MessageLookupByLibrary.simpleMessage(
      "No appointments",
    ),
    "clientAppointmentsPast": MessageLookupByLibrary.simpleMessage("Past"),
    "clientAppointmentsTitle": m2,
    "clientAppointmentsUpcoming": MessageLookupByLibrary.simpleMessage(
      "Upcoming",
    ),
    "clientLockedHint": MessageLookupByLibrary.simpleMessage(
      "Client cannot be changed for this appointment",
    ),
    "clientNoteLabel": MessageLookupByLibrary.simpleMessage("Client note"),
    "clientOptionalHint": MessageLookupByLibrary.simpleMessage(
      "Leave empty if you don\'t want to associate a client with the appointment",
    ),
    "clientsEdit": MessageLookupByLibrary.simpleMessage("Edit client"),
    "clientsEmpty": MessageLookupByLibrary.simpleMessage("No clients"),
    "clientsNew": MessageLookupByLibrary.simpleMessage("New client"),
    "clientsTitle": MessageLookupByLibrary.simpleMessage("Clients List"),
    "createCategoryButtonLabel": MessageLookupByLibrary.simpleMessage(
      "New category",
    ),
    "createNewClient": MessageLookupByLibrary.simpleMessage(
      "Create new client",
    ),
    "currentWeek": MessageLookupByLibrary.simpleMessage("Current week"),
    "dayFridayFull": MessageLookupByLibrary.simpleMessage("Friday"),
    "dayMondayFull": MessageLookupByLibrary.simpleMessage("Monday"),
    "daySaturdayFull": MessageLookupByLibrary.simpleMessage("Saturday"),
    "daySundayFull": MessageLookupByLibrary.simpleMessage("Sunday"),
    "dayThursdayFull": MessageLookupByLibrary.simpleMessage("Thursday"),
    "dayTuesdayFull": MessageLookupByLibrary.simpleMessage("Tuesday"),
    "dayWednesdayFull": MessageLookupByLibrary.simpleMessage("Wednesday"),
    "deleteAppointmentConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "The appointment will be removed. This action cannot be undone.",
    ),
    "deleteAppointmentConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Delete appointment?",
    ),
    "deleteBookingConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "All linked services will be removed. This action cannot be undone.",
    ),
    "deleteBookingConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Delete entire booking?",
    ),
    "deleteClientConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "The client will be permanently deleted. This action cannot be undone.",
    ),
    "deleteClientConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Delete client?",
    ),
    "deleteConfirmationTitle": MessageLookupByLibrary.simpleMessage(
      "Confirm deletion?",
    ),
    "deleteServiceQuestion": MessageLookupByLibrary.simpleMessage(
      "Delete this service?",
    ),
    "discardChangesMessage": MessageLookupByLibrary.simpleMessage(
      "You have unsaved changes. Do you want to discard them?",
    ),
    "discardChangesTitle": MessageLookupByLibrary.simpleMessage(
      "Unsaved changes",
    ),
    "duplicateAction": MessageLookupByLibrary.simpleMessage("Duplicate"),
    "durationHour": m3,
    "durationHourMinute": m4,
    "durationMinute": m5,
    "editCategoryTitle": MessageLookupByLibrary.simpleMessage("Edit category"),
    "editServiceTitle": MessageLookupByLibrary.simpleMessage("Edit service"),
    "emptyCategoriesNotReorderableNote": MessageLookupByLibrary.simpleMessage(
      "Categories without services cannot be reordered and stay at the end.",
    ),
    "errorExceptionNotFound": m6,
    "errorFormFactorBuilderMissing": m7,
    "errorFormFactorBuilderRequired": MessageLookupByLibrary.simpleMessage(
      "Specify at least one builder for form factor",
    ),
    "errorNotFound": m8,
    "errorServiceNotFound": MessageLookupByLibrary.simpleMessage(
      "Service not found",
    ),
    "errorTitle": MessageLookupByLibrary.simpleMessage("Error"),
    "exceptionAllDay": MessageLookupByLibrary.simpleMessage("All day"),
    "exceptionAvailableNoEffect": MessageLookupByLibrary.simpleMessage(
      "Extra availability must add hours beyond the base availability.",
    ),
    "exceptionDateFrom": MessageLookupByLibrary.simpleMessage("Start date"),
    "exceptionDateTo": MessageLookupByLibrary.simpleMessage("End date"),
    "exceptionDeleteMessage": MessageLookupByLibrary.simpleMessage(
      "The exception will be permanently deleted.",
    ),
    "exceptionDeleteShift": MessageLookupByLibrary.simpleMessage(
      "Delete exception",
    ),
    "exceptionDeleteShiftDesc": MessageLookupByLibrary.simpleMessage(
      "Restore base availability",
    ),
    "exceptionDeleteTitle": MessageLookupByLibrary.simpleMessage(
      "Delete exception?",
    ),
    "exceptionDialogTitleEdit": MessageLookupByLibrary.simpleMessage(
      "Edit exception",
    ),
    "exceptionDialogTitleNew": MessageLookupByLibrary.simpleMessage(
      "New exception",
    ),
    "exceptionDuration": MessageLookupByLibrary.simpleMessage(
      "Duration (days)",
    ),
    "exceptionDurationDays": m9,
    "exceptionEditShift": MessageLookupByLibrary.simpleMessage(
      "Edit exception",
    ),
    "exceptionEditShiftDesc": MessageLookupByLibrary.simpleMessage(
      "Edit the times of this exception",
    ),
    "exceptionEndTime": MessageLookupByLibrary.simpleMessage("End time"),
    "exceptionPartialSaveInfo": m10,
    "exceptionPartialSaveInfoDetailed": m11,
    "exceptionPartialSaveMessage": MessageLookupByLibrary.simpleMessage(
      "The days below were not congruent and were not saved:",
    ),
    "exceptionPartialSaveTitle": MessageLookupByLibrary.simpleMessage(
      "Exceptions not saved",
    ),
    "exceptionPeriodDuration": MessageLookupByLibrary.simpleMessage("Duration"),
    "exceptionPeriodMode": MessageLookupByLibrary.simpleMessage("Period"),
    "exceptionPeriodRange": MessageLookupByLibrary.simpleMessage("From - To"),
    "exceptionPeriodSingle": MessageLookupByLibrary.simpleMessage("Single day"),
    "exceptionReason": MessageLookupByLibrary.simpleMessage(
      "Reason (optional)",
    ),
    "exceptionReasonExtraShift": MessageLookupByLibrary.simpleMessage(
      "Extra shift",
    ),
    "exceptionReasonHint": MessageLookupByLibrary.simpleMessage(
      "E.g. Holiday, Medical visit, Extra shift...",
    ),
    "exceptionReasonMedicalVisit": MessageLookupByLibrary.simpleMessage(
      "Medical visit",
    ),
    "exceptionReasonVacation": MessageLookupByLibrary.simpleMessage("Vacation"),
    "exceptionSelectTime": MessageLookupByLibrary.simpleMessage("Select time"),
    "exceptionStartTime": MessageLookupByLibrary.simpleMessage("Start time"),
    "exceptionTimeError": MessageLookupByLibrary.simpleMessage(
      "End time must be after start time",
    ),
    "exceptionType": MessageLookupByLibrary.simpleMessage("Exception type"),
    "exceptionTypeAvailable": MessageLookupByLibrary.simpleMessage("Available"),
    "exceptionTypeUnavailable": MessageLookupByLibrary.simpleMessage(
      "Unavailable",
    ),
    "exceptionUnavailableNoBase": MessageLookupByLibrary.simpleMessage(
      "You can\'t add unavailability on a day with no base availability.",
    ),
    "exceptionUnavailableNoOverlap": MessageLookupByLibrary.simpleMessage(
      "Unavailability must overlap the base availability.",
    ),
    "exceptionsAdd": MessageLookupByLibrary.simpleMessage("Add exception"),
    "exceptionsEmpty": MessageLookupByLibrary.simpleMessage(
      "No exceptions configured",
    ),
    "exceptionsTitle": MessageLookupByLibrary.simpleMessage("Exceptions"),
    "fieldBlockedTimeLabel": MessageLookupByLibrary.simpleMessage(
      "Blocked time",
    ),
    "fieldCategoryRequiredLabel": MessageLookupByLibrary.simpleMessage(
      "Category *",
    ),
    "fieldDescriptionLabel": MessageLookupByLibrary.simpleMessage(
      "Description",
    ),
    "fieldDurationRequiredError": MessageLookupByLibrary.simpleMessage(
      "Please select a duration",
    ),
    "fieldDurationRequiredLabel": MessageLookupByLibrary.simpleMessage(
      "Duration *",
    ),
    "fieldNameRequiredError": MessageLookupByLibrary.simpleMessage(
      "Name is required",
    ),
    "fieldNameRequiredLabel": MessageLookupByLibrary.simpleMessage("Name *"),
    "fieldPriceLabel": MessageLookupByLibrary.simpleMessage("Price"),
    "fieldProcessingTimeLabel": MessageLookupByLibrary.simpleMessage(
      "Processing time",
    ),
    "filterAll": MessageLookupByLibrary.simpleMessage("All"),
    "filterInactive": MessageLookupByLibrary.simpleMessage("Inactive"),
    "filterNew": MessageLookupByLibrary.simpleMessage("New"),
    "filterVIP": MessageLookupByLibrary.simpleMessage("VIP"),
    "formClient": MessageLookupByLibrary.simpleMessage("Client"),
    "formDate": MessageLookupByLibrary.simpleMessage("Date"),
    "formEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "formFirstName": MessageLookupByLibrary.simpleMessage("First name"),
    "formLastName": MessageLookupByLibrary.simpleMessage("Last name"),
    "formNotes": MessageLookupByLibrary.simpleMessage(
      "Notes (not visible to client)",
    ),
    "formPhone": MessageLookupByLibrary.simpleMessage("Phone"),
    "formService": MessageLookupByLibrary.simpleMessage("Service"),
    "formServices": MessageLookupByLibrary.simpleMessage("Services"),
    "formStaff": MessageLookupByLibrary.simpleMessage("Team"),
    "freeLabel": MessageLookupByLibrary.simpleMessage("Free"),
    "freeServiceSwitch": MessageLookupByLibrary.simpleMessage("Free service"),
    "hoursHoursOnly": m12,
    "hoursMinutesCompact": m13,
    "labelSelect": MessageLookupByLibrary.simpleMessage("Select"),
    "labelStaff": MessageLookupByLibrary.simpleMessage("Team:"),
    "lastVisitLabel": m14,
    "moveAppointmentConfirmMessage": m15,
    "moveAppointmentConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Confirm move?",
    ),
    "navAgenda": MessageLookupByLibrary.simpleMessage("Agenda"),
    "navClients": MessageLookupByLibrary.simpleMessage("Clients"),
    "navProfile": MessageLookupByLibrary.simpleMessage("Profile"),
    "navServices": MessageLookupByLibrary.simpleMessage("Services"),
    "navStaff": MessageLookupByLibrary.simpleMessage("Team"),
    "newCategoryTitle": MessageLookupByLibrary.simpleMessage("New category"),
    "newServiceTitle": MessageLookupByLibrary.simpleMessage("New service"),
    "noClientForAppointment": MessageLookupByLibrary.simpleMessage(
      "No client for the appointment",
    ),
    "noServicesAdded": MessageLookupByLibrary.simpleMessage(
      "No services added",
    ),
    "noServicesInCategory": MessageLookupByLibrary.simpleMessage(
      "No services in this category",
    ),
    "noStaffAvailable": MessageLookupByLibrary.simpleMessage(
      "No team available",
    ),
    "notBookableOnline": MessageLookupByLibrary.simpleMessage(
      "Not bookable online",
    ),
    "notesPlaceholder": MessageLookupByLibrary.simpleMessage(
      "Notes about the appointment...",
    ),
    "operatorsEditRole": MessageLookupByLibrary.simpleMessage("Edit role"),
    "operatorsEmpty": MessageLookupByLibrary.simpleMessage(
      "No operators configured",
    ),
    "operatorsExpires": m16,
    "operatorsInviteCopied": MessageLookupByLibrary.simpleMessage(
      "Invite link copied",
    ),
    "operatorsInviteEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "operatorsInviteRole": MessageLookupByLibrary.simpleMessage("Role"),
    "operatorsInviteSend": MessageLookupByLibrary.simpleMessage("Send invite"),
    "operatorsInviteSubtitle": MessageLookupByLibrary.simpleMessage(
      "Send an invite via email",
    ),
    "operatorsInviteSuccess": m17,
    "operatorsInviteTitle": MessageLookupByLibrary.simpleMessage(
      "Invite operator",
    ),
    "operatorsInvitedBy": m18,
    "operatorsPendingInvites": MessageLookupByLibrary.simpleMessage(
      "Pending invites",
    ),
    "operatorsPendingInvitesCount": m19,
    "operatorsRemove": MessageLookupByLibrary.simpleMessage("Remove operator"),
    "operatorsRemoveConfirm": m20,
    "operatorsRemoveSuccess": MessageLookupByLibrary.simpleMessage(
      "Operator removed",
    ),
    "operatorsRevokeInvite": MessageLookupByLibrary.simpleMessage(
      "Revoke invite",
    ),
    "operatorsRevokeInviteConfirm": m21,
    "operatorsRoleAdmin": MessageLookupByLibrary.simpleMessage("Administrator"),
    "operatorsRoleDescription": MessageLookupByLibrary.simpleMessage(
      "Select access level",
    ),
    "operatorsRoleManager": MessageLookupByLibrary.simpleMessage("Manager"),
    "operatorsRoleOwner": MessageLookupByLibrary.simpleMessage("Owner"),
    "operatorsRoleStaff": MessageLookupByLibrary.simpleMessage("Staff"),
    "operatorsSubtitle": MessageLookupByLibrary.simpleMessage(
      "Manage who can access the platform",
    ),
    "operatorsTitle": MessageLookupByLibrary.simpleMessage("Operators"),
    "operatorsYou": MessageLookupByLibrary.simpleMessage("You"),
    "priceNotAvailable": MessageLookupByLibrary.simpleMessage("N/A"),
    "priceStartingFromPrefix": MessageLookupByLibrary.simpleMessage(
      "starting from",
    ),
    "priceStartingFromSwitch": MessageLookupByLibrary.simpleMessage(
      "Price ‚Äústarting from‚Äù",
    ),
    "profileTitle": MessageLookupByLibrary.simpleMessage("Profile"),
    "removeClient": MessageLookupByLibrary.simpleMessage("Remove client"),
    "reorderCategoriesLabel": MessageLookupByLibrary.simpleMessage(
      "Categories",
    ),
    "reorderHelpDescription": MessageLookupByLibrary.simpleMessage(
      "Reorder categories and services by dragging them: the same order will be applied to online booking. Select whether to sort categories or services.",
    ),
    "reorderServicesLabel": MessageLookupByLibrary.simpleMessage("Services"),
    "reorderTitle": MessageLookupByLibrary.simpleMessage("Reorder"),
    "searchClientPlaceholder": MessageLookupByLibrary.simpleMessage(
      "Search client...",
    ),
    "selectClientTitle": MessageLookupByLibrary.simpleMessage("Select client"),
    "selectService": MessageLookupByLibrary.simpleMessage("Select service"),
    "selectStaffTitle": MessageLookupByLibrary.simpleMessage("Select team"),
    "serviceColorLabel": MessageLookupByLibrary.simpleMessage("Service color"),
    "serviceDuplicateCopyWord": MessageLookupByLibrary.simpleMessage("Copy"),
    "serviceDuplicateError": MessageLookupByLibrary.simpleMessage(
      "A service with this name already exists",
    ),
    "serviceEligibleStaffCount": m22,
    "serviceEligibleStaffNone": MessageLookupByLibrary.simpleMessage(
      "No eligible team members",
    ),
    "serviceSeedCategoryBodyDescription": MessageLookupByLibrary.simpleMessage(
      "Services dedicated to body wellness",
    ),
    "serviceSeedCategoryBodyName": MessageLookupByLibrary.simpleMessage(
      "Body Treatments",
    ),
    "serviceSeedCategoryFaceDescription": MessageLookupByLibrary.simpleMessage(
      "Aesthetic and rejuvenating care for the face",
    ),
    "serviceSeedCategoryFaceName": MessageLookupByLibrary.simpleMessage(
      "Facial Treatments",
    ),
    "serviceSeedCategorySportsDescription":
        MessageLookupByLibrary.simpleMessage(
          "Programs designed for athletes and active people",
        ),
    "serviceSeedCategorySportsName": MessageLookupByLibrary.simpleMessage(
      "Sports Treatments",
    ),
    "serviceSeedServiceFaceDescription": MessageLookupByLibrary.simpleMessage(
      "Cleansing and illuminating treatment",
    ),
    "serviceSeedServiceFaceName": MessageLookupByLibrary.simpleMessage(
      "Facial Treatment",
    ),
    "serviceSeedServiceRelaxDescription": MessageLookupByLibrary.simpleMessage(
      "Relaxing 30-minute treatment",
    ),
    "serviceSeedServiceRelaxName": MessageLookupByLibrary.simpleMessage(
      "Relax Massage",
    ),
    "serviceSeedServiceSportDescription": MessageLookupByLibrary.simpleMessage(
      "Intensive decontracting treatment",
    ),
    "serviceSeedServiceSportName": MessageLookupByLibrary.simpleMessage(
      "Sports Massage",
    ),
    "servicesNewServiceMenu": MessageLookupByLibrary.simpleMessage(
      "New service",
    ),
    "servicesSelectedCount": m23,
    "setPriceToEnable": MessageLookupByLibrary.simpleMessage(
      "Set a price to enable this option",
    ),
    "shiftDeleteAll": MessageLookupByLibrary.simpleMessage(
      "Delete all these shifts",
    ),
    "shiftDeleteAllDesc": m24,
    "shiftDeleteThisOnly": MessageLookupByLibrary.simpleMessage(
      "Delete only this shift",
    ),
    "shiftDeleteThisOnlyDesc": m25,
    "shiftEditAll": MessageLookupByLibrary.simpleMessage(
      "Edit all these shifts",
    ),
    "shiftEditAllDesc": m26,
    "shiftEditThisOnly": MessageLookupByLibrary.simpleMessage(
      "Edit only this shift",
    ),
    "shiftEditThisOnlyDesc": m27,
    "shiftEditTitle": MessageLookupByLibrary.simpleMessage("Edit shift"),
    "shiftEndTime": MessageLookupByLibrary.simpleMessage("End time"),
    "shiftStartTime": MessageLookupByLibrary.simpleMessage("Start time"),
    "sortByCreatedAtAsc": MessageLookupByLibrary.simpleMessage(
      "Created (oldest)",
    ),
    "sortByCreatedAtDesc": MessageLookupByLibrary.simpleMessage(
      "Created (newest)",
    ),
    "sortByLastNameAsc": MessageLookupByLibrary.simpleMessage(
      "Last name (A-Z)",
    ),
    "sortByLastNameDesc": MessageLookupByLibrary.simpleMessage(
      "Last name (Z-A)",
    ),
    "sortByLastVisitAsc": MessageLookupByLibrary.simpleMessage(
      "Last visit (oldest)",
    ),
    "sortByLastVisitDesc": MessageLookupByLibrary.simpleMessage(
      "Last visit (recent)",
    ),
    "sortByNameAsc": MessageLookupByLibrary.simpleMessage("Name (A-Z)"),
    "sortByNameDesc": MessageLookupByLibrary.simpleMessage("Name (Z-A)"),
    "sortByTitle": MessageLookupByLibrary.simpleMessage("Sort by"),
    "staffEditHours": MessageLookupByLibrary.simpleMessage("Edit hours"),
    "staffFilterAllTeam": MessageLookupByLibrary.simpleMessage("All team"),
    "staffFilterOnDuty": MessageLookupByLibrary.simpleMessage("On duty team"),
    "staffFilterSelectMembers": MessageLookupByLibrary.simpleMessage(
      "Select team members",
    ),
    "staffFilterTitle": MessageLookupByLibrary.simpleMessage("Filter team"),
    "staffFilterTooltip": MessageLookupByLibrary.simpleMessage("Filter team"),
    "staffHubAvailabilitySubtitle": MessageLookupByLibrary.simpleMessage(
      "Configure weekly working hours",
    ),
    "staffHubAvailabilityTitle": MessageLookupByLibrary.simpleMessage(
      "Availability",
    ),
    "staffHubNotYetAvailable": MessageLookupByLibrary.simpleMessage(
      "Not yet available",
    ),
    "staffHubStatsSubtitle": MessageLookupByLibrary.simpleMessage(
      "Performance and workloads",
    ),
    "staffHubStatsTitle": MessageLookupByLibrary.simpleMessage("Statistics"),
    "staffHubTeamSubtitle": MessageLookupByLibrary.simpleMessage(
      "Manage members and roles",
    ),
    "staffHubTeamTitle": MessageLookupByLibrary.simpleMessage("Team"),
    "staffNotBookableOnlineMessage": MessageLookupByLibrary.simpleMessage(
      "This team member is not enabled for online bookings. You can change this in the staff edit form.",
    ),
    "staffNotBookableOnlineTitle": MessageLookupByLibrary.simpleMessage(
      "Not bookable online",
    ),
    "staffNotBookableOnlineTooltip": MessageLookupByLibrary.simpleMessage(
      "Not bookable online",
    ),
    "staffScreenPlaceholder": MessageLookupByLibrary.simpleMessage(
      "Team Screen",
    ),
    "switchBusiness": MessageLookupByLibrary.simpleMessage("Switch"),
    "teamAddStaff": MessageLookupByLibrary.simpleMessage("Add team member"),
    "teamChooseLocationSingleButton": MessageLookupByLibrary.simpleMessage(
      "Select location",
    ),
    "teamChooseLocationsButton": MessageLookupByLibrary.simpleMessage(
      "Select locations",
    ),
    "teamDeleteLocationBlockedMessage": MessageLookupByLibrary.simpleMessage(
      "Remove all team members assigned to this location first.",
    ),
    "teamDeleteLocationBlockedTitle": MessageLookupByLibrary.simpleMessage(
      "Cannot delete location",
    ),
    "teamDeleteLocationMessage": MessageLookupByLibrary.simpleMessage(
      "The location will be removed from the team. This action cannot be undone.",
    ),
    "teamDeleteLocationTitle": MessageLookupByLibrary.simpleMessage(
      "Delete location?",
    ),
    "teamDeleteStaffMessage": MessageLookupByLibrary.simpleMessage(
      "The member will be removed from the team. This action cannot be undone.",
    ),
    "teamDeleteStaffTitle": MessageLookupByLibrary.simpleMessage(
      "Delete team member?",
    ),
    "teamEditLocationTitle": MessageLookupByLibrary.simpleMessage(
      "Edit location",
    ),
    "teamEditStaffTitle": MessageLookupByLibrary.simpleMessage(
      "Edit team member",
    ),
    "teamEligibleServicesCount": m28,
    "teamEligibleServicesLabel": MessageLookupByLibrary.simpleMessage(
      "Eligible services",
    ),
    "teamEligibleServicesNone": MessageLookupByLibrary.simpleMessage(
      "No eligible services",
    ),
    "teamEligibleStaffLabel": MessageLookupByLibrary.simpleMessage(
      "Eligible team members",
    ),
    "teamLocationAddressLabel": MessageLookupByLibrary.simpleMessage("Address"),
    "teamLocationEmailHint": MessageLookupByLibrary.simpleMessage(
      "Email for customer notifications",
    ),
    "teamLocationEmailLabel": MessageLookupByLibrary.simpleMessage("Email"),
    "teamLocationIsActiveHint": MessageLookupByLibrary.simpleMessage(
      "If disabled, the location will not be visible to customers",
    ),
    "teamLocationIsActiveLabel": MessageLookupByLibrary.simpleMessage(
      "Location active",
    ),
    "teamLocationLabel": MessageLookupByLibrary.simpleMessage("Location"),
    "teamLocationNameLabel": MessageLookupByLibrary.simpleMessage(
      "Location name",
    ),
    "teamLocationsLabel": MessageLookupByLibrary.simpleMessage("Locations"),
    "teamNewLocationTitle": MessageLookupByLibrary.simpleMessage(
      "New location",
    ),
    "teamNewStaffTitle": MessageLookupByLibrary.simpleMessage(
      "New team member",
    ),
    "teamNoStaffInLocation": MessageLookupByLibrary.simpleMessage(
      "No team members in this location",
    ),
    "teamReorderHelpDescription": MessageLookupByLibrary.simpleMessage(
      "Reorder locations and team members by dragging them. Select whether to sort locations or team. The order will also apply in the agenda section.",
    ),
    "teamSelectAllLocations": MessageLookupByLibrary.simpleMessage(
      "Select all",
    ),
    "teamSelectAllServices": MessageLookupByLibrary.simpleMessage("Select all"),
    "teamSelectedServicesButton": MessageLookupByLibrary.simpleMessage(
      "Selected services",
    ),
    "teamSelectedServicesCount": m29,
    "teamServicesLabel": MessageLookupByLibrary.simpleMessage("Services"),
    "teamStaffBookableOnlineLabel": MessageLookupByLibrary.simpleMessage(
      "Enabled for online bookings",
    ),
    "teamStaffColorLabel": MessageLookupByLibrary.simpleMessage("Color"),
    "teamStaffLabel": MessageLookupByLibrary.simpleMessage("Team"),
    "teamStaffLocationsLabel": MessageLookupByLibrary.simpleMessage(
      "Assigned locations",
    ),
    "teamStaffMultiLocationWarning": MessageLookupByLibrary.simpleMessage(
      "If the member works across multiple locations, make sure availability aligns with the selected locations.",
    ),
    "teamStaffNameLabel": MessageLookupByLibrary.simpleMessage("First name"),
    "teamStaffSurnameLabel": MessageLookupByLibrary.simpleMessage("Last name"),
    "validationInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Invalid email",
    ),
    "validationInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Invalid phone",
    ),
    "validationNameOrLastNameRequired": MessageLookupByLibrary.simpleMessage(
      "Enter at least first name or last name",
    ),
    "validationRequired": MessageLookupByLibrary.simpleMessage("Required"),
    "weeklyScheduleAddShift": MessageLookupByLibrary.simpleMessage("Add shift"),
    "weeklyScheduleFor": MessageLookupByLibrary.simpleMessage("to"),
    "weeklyScheduleNotWorking": MessageLookupByLibrary.simpleMessage(
      "Not working",
    ),
    "weeklyScheduleRemoveShift": MessageLookupByLibrary.simpleMessage(
      "Remove shift",
    ),
    "weeklyScheduleTitle": MessageLookupByLibrary.simpleMessage("Weekly"),
    "weeklyScheduleTotalHours": m30,
  };
}
--- FILE: lib/core/l10n/date_time_formats.dart ---
import 'package:flutter/widgets.dart';
import 'package:intl/intl.dart';

/// Helper centralizzati per formattare date e orari in base alla locale corrente.
class DtFmt {
  DtFmt._();

  /// HH:mm secondo la locale; su it rimane 24h, su en pu√≤ essere 12/24 in base alle impostazioni.
  static String hm(BuildContext context, int hour, int minute) {
    final locale = Intl.getCurrentLocale();
    final dt = DateTime(0, 1, 1, hour, minute);
    // Prefer format 'HH:mm' but respect locale by using DateFormat.Hm
    return DateFormat.Hm(locale).format(dt);
  }

  /// Etichetta ora piena (senza minuti): es. "09:00" o "9 AM" a seconda locale.
  static String hOnly(BuildContext context, int hour) {
    final locale = Intl.getCurrentLocale();
    final dt = DateTime(0, 1, 1, hour, 0);
    return DateFormat.Hm(locale).format(dt);
  }

  /// Giorno breve localizzato per intestazioni (Lun, Mar, ... / Mon, Tue, ...)
  static String weekdayShort(BuildContext context, int weekdayIso) {
    final locale = Intl.getCurrentLocale();
    final now = DateTime.now();
    final base = now.subtract(Duration(days: now.weekday - weekdayIso));
    return DateFormat.E(locale).format(base);
  }

  /// Data compatta per form: "sab 6 dic 25" / "Sat 6 Dec 25"
  static String shortDate(BuildContext context, DateTime date) {
    final locale = Intl.getCurrentLocale();
    // E = giorno settimana abbreviato, d = giorno, MMM = mese abbreviato, yy = anno a 2 cifre
    return DateFormat('E d MMM yy', locale).format(date);
  }
}
--- FILE: lib/core/l10n/l10n.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'intl/messages_all.dart';

// **************************************************************************
// Generator: Flutter Intl IDE plugin
// Made by Localizely
// **************************************************************************

// ignore_for_file: non_constant_identifier_names, lines_longer_than_80_chars
// ignore_for_file: join_return_with_assignment, prefer_final_in_for_each
// ignore_for_file: avoid_redundant_argument_values, avoid_escaping_inner_quotes

class L10n {
  L10n();

  static L10n? _current;

  static L10n get current {
    assert(
      _current != null,
      'No instance of L10n was loaded. Try to initialize the L10n delegate before accessing L10n.current.',
    );
    return _current!;
  }

  static const AppLocalizationDelegate delegate = AppLocalizationDelegate();

  static Future<L10n> load(Locale locale) {
    final name = (locale.countryCode?.isEmpty ?? false)
        ? locale.languageCode
        : locale.toString();
    final localeName = Intl.canonicalizedLocale(name);
    return initializeMessages(localeName).then((_) {
      Intl.defaultLocale = localeName;
      final instance = L10n();
      L10n._current = instance;

      return instance;
    });
  }

  static L10n of(BuildContext context) {
    final instance = L10n.maybeOf(context);
    assert(
      instance != null,
      'No instance of L10n present in the widget tree. Did you add L10n.delegate in localizationsDelegates?',
    );
    return instance!;
  }

  static L10n? maybeOf(BuildContext context) {
    return Localizations.of<L10n>(context, L10n);
  }

  /// `Agenda Platform`
  String get appTitle {
    return Intl.message(
      'Agenda Platform',
      name: 'appTitle',
      desc: '',
      args: [],
    );
  }

  /// `Agenda`
  String get navAgenda {
    return Intl.message('Agenda', name: 'navAgenda', desc: '', args: []);
  }

  /// `Clienti`
  String get navClients {
    return Intl.message('Clienti', name: 'navClients', desc: '', args: []);
  }

  /// `Servizi`
  String get navServices {
    return Intl.message('Servizi', name: 'navServices', desc: '', args: []);
  }

  /// `Team`
  String get navStaff {
    return Intl.message('Team', name: 'navStaff', desc: '', args: []);
  }

  /// `Profilo`
  String get navProfile {
    return Intl.message('Profilo', name: 'navProfile', desc: '', args: []);
  }

  /// `Elenco Clienti`
  String get clientsTitle {
    return Intl.message(
      'Elenco Clienti',
      name: 'clientsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Specificare almeno un builder per form factor`
  String get errorFormFactorBuilderRequired {
    return Intl.message(
      'Specificare almeno un builder per form factor',
      name: 'errorFormFactorBuilderRequired',
      desc: '',
      args: [],
    );
  }

  /// `Nessun builder disponibile per {factor}`
  String errorFormFactorBuilderMissing(String factor) {
    return Intl.message(
      'Nessun builder disponibile per $factor',
      name: 'errorFormFactorBuilderMissing',
      desc: '',
      args: [factor],
    );
  }

  /// `Errore`
  String get errorTitle {
    return Intl.message('Errore', name: 'errorTitle', desc: '', args: []);
  }

  /// `Pagina non trovata: {path}`
  String errorNotFound(String path) {
    return Intl.message(
      'Pagina non trovata: $path',
      name: 'errorNotFound',
      desc: '',
      args: [path],
    );
  }

  /// `Servizio non trovato`
  String get errorServiceNotFound {
    return Intl.message(
      'Servizio non trovato',
      name: 'errorServiceNotFound',
      desc: '',
      args: [],
    );
  }

  /// `Eccezione non trovata: {id}`
  String errorExceptionNotFound(int id) {
    return Intl.message(
      'Eccezione non trovata: $id',
      name: 'errorExceptionNotFound',
      desc: '',
      args: [id],
    );
  }

  /// `Schermata Team`
  String get staffScreenPlaceholder {
    return Intl.message(
      'Schermata Team',
      name: 'staffScreenPlaceholder',
      desc: '',
      args: [],
    );
  }

  /// `Elimina`
  String get actionDelete {
    return Intl.message('Elimina', name: 'actionDelete', desc: '', args: []);
  }

  /// `Annulla`
  String get actionCancel {
    return Intl.message('Annulla', name: 'actionCancel', desc: '', args: []);
  }

  /// `Conferma`
  String get actionConfirm {
    return Intl.message('Conferma', name: 'actionConfirm', desc: '', args: []);
  }

  /// `Conferma`
  String get actionClose {
    return Intl.message('Conferma', name: 'actionClose', desc: '', args: []);
  }

  /// `Confermi l‚Äôeliminazione?`
  String get deleteConfirmationTitle {
    return Intl.message(
      'Confermi l‚Äôeliminazione?',
      name: 'deleteConfirmationTitle',
      desc: '',
      args: [],
    );
  }

  /// `Oggi`
  String get agendaToday {
    return Intl.message('Oggi', name: 'agendaToday', desc: '', args: []);
  }

  /// `Giorno precedente`
  String get agendaPrevDay {
    return Intl.message(
      'Giorno precedente',
      name: 'agendaPrevDay',
      desc: '',
      args: [],
    );
  }

  /// `Giorno successivo`
  String get agendaNextDay {
    return Intl.message(
      'Giorno successivo',
      name: 'agendaNextDay',
      desc: '',
      args: [],
    );
  }

  /// `Settimana precedente`
  String get agendaPrevWeek {
    return Intl.message(
      'Settimana precedente',
      name: 'agendaPrevWeek',
      desc: '',
      args: [],
    );
  }

  /// `Settimana successivo`
  String get agendaNextWeek {
    return Intl.message(
      'Settimana successivo',
      name: 'agendaNextWeek',
      desc: '',
      args: [],
    );
  }

  /// `Mese precedente`
  String get agendaPrevMonth {
    return Intl.message(
      'Mese precedente',
      name: 'agendaPrevMonth',
      desc: '',
      args: [],
    );
  }

  /// `Mese successivo`
  String get agendaNextMonth {
    return Intl.message(
      'Mese successivo',
      name: 'agendaNextMonth',
      desc: '',
      args: [],
    );
  }

  /// `Nessuna sede disponibile`
  String get agendaNoLocations {
    return Intl.message(
      'Nessuna sede disponibile',
      name: 'agendaNoLocations',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona sede`
  String get agendaSelectLocation {
    return Intl.message(
      'Seleziona sede',
      name: 'agendaSelectLocation',
      desc: '',
      args: [],
    );
  }

  /// `Tutte le sedi`
  String get allLocations {
    return Intl.message(
      'Tutte le sedi',
      name: 'allLocations',
      desc: '',
      args: [],
    );
  }

  /// `Disponibilit√† settimanale`
  String get availabilityTitle {
    return Intl.message(
      'Disponibilit√† settimanale',
      name: 'availabilityTitle',
      desc: '',
      args: [],
    );
  }

  /// `Disponibilit√† ‚Äì {name}`
  String availabilityTitleFor(String name) {
    return Intl.message(
      'Disponibilit√† ‚Äì $name',
      name: 'availabilityTitleFor',
      desc: '',
      args: [name],
    );
  }

  /// `Salva modifiche`
  String get availabilitySave {
    return Intl.message(
      'Salva modifiche',
      name: 'availabilitySave',
      desc: '',
      args: [],
    );
  }

  /// `Settimana corrente`
  String get currentWeek {
    return Intl.message(
      'Settimana corrente',
      name: 'currentWeek',
      desc: '',
      args: [],
    );
  }

  /// `{hours}h {minutes}m`
  String hoursMinutesCompact(Object hours, Object minutes) {
    return Intl.message(
      '${hours}h ${minutes}m',
      name: 'hoursMinutesCompact',
      desc: '',
      args: [hours, minutes],
    );
  }

  /// `{hours}h`
  String hoursHoursOnly(Object hours) {
    return Intl.message(
      '${hours}h',
      name: 'hoursHoursOnly',
      desc: '',
      args: [hours],
    );
  }

  /// `Team:`
  String get labelStaff {
    return Intl.message('Team:', name: 'labelStaff', desc: '', args: []);
  }

  /// `Seleziona`
  String get labelSelect {
    return Intl.message('Seleziona', name: 'labelSelect', desc: '', args: []);
  }

  /// `Disponibilit√†`
  String get staffHubAvailabilityTitle {
    return Intl.message(
      'Disponibilit√†',
      name: 'staffHubAvailabilityTitle',
      desc: '',
      args: [],
    );
  }

  /// `Configura gli orari di lavoro settimanali`
  String get staffHubAvailabilitySubtitle {
    return Intl.message(
      'Configura gli orari di lavoro settimanali',
      name: 'staffHubAvailabilitySubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Team`
  String get staffHubTeamTitle {
    return Intl.message('Team', name: 'staffHubTeamTitle', desc: '', args: []);
  }

  /// `Gestione membri e ruoli`
  String get staffHubTeamSubtitle {
    return Intl.message(
      'Gestione membri e ruoli',
      name: 'staffHubTeamSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Statistiche`
  String get staffHubStatsTitle {
    return Intl.message(
      'Statistiche',
      name: 'staffHubStatsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Performance e carichi di lavoro`
  String get staffHubStatsSubtitle {
    return Intl.message(
      'Performance e carichi di lavoro',
      name: 'staffHubStatsSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Non ancora disponibile`
  String get staffHubNotYetAvailable {
    return Intl.message(
      'Non ancora disponibile',
      name: 'staffHubNotYetAvailable',
      desc: '',
      args: [],
    );
  }

  /// `Modifica orari`
  String get staffEditHours {
    return Intl.message(
      'Modifica orari',
      name: 'staffEditHours',
      desc: '',
      args: [],
    );
  }

  /// `Modifica`
  String get actionEdit {
    return Intl.message('Modifica', name: 'actionEdit', desc: '', args: []);
  }

  /// `{minutes} min`
  String durationMinute(Object minutes) {
    return Intl.message(
      '$minutes min',
      name: 'durationMinute',
      desc: '',
      args: [minutes],
    );
  }

  /// `{hours} ora`
  String durationHour(Object hours) {
    return Intl.message(
      '$hours ora',
      name: 'durationHour',
      desc: '',
      args: [hours],
    );
  }

  /// `{hours} ora {minutes} min`
  String durationHourMinute(Object hours, Object minutes) {
    return Intl.message(
      '$hours ora $minutes min',
      name: 'durationHourMinute',
      desc: '',
      args: [hours, minutes],
    );
  }

  /// `Gratis`
  String get freeLabel {
    return Intl.message('Gratis', name: 'freeLabel', desc: '', args: []);
  }

  /// `a partire da`
  String get priceStartingFromPrefix {
    return Intl.message(
      'a partire da',
      name: 'priceStartingFromPrefix',
      desc: '',
      args: [],
    );
  }

  /// `N/D`
  String get priceNotAvailable {
    return Intl.message('N/D', name: 'priceNotAvailable', desc: '', args: []);
  }

  /// `Nuovo cliente`
  String get clientsNew {
    return Intl.message(
      'Nuovo cliente',
      name: 'clientsNew',
      desc: '',
      args: [],
    );
  }

  /// `Modifica cliente`
  String get clientsEdit {
    return Intl.message(
      'Modifica cliente',
      name: 'clientsEdit',
      desc: '',
      args: [],
    );
  }

  /// `Nessun cliente`
  String get clientsEmpty {
    return Intl.message(
      'Nessun cliente',
      name: 'clientsEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Salva`
  String get actionSave {
    return Intl.message('Salva', name: 'actionSave', desc: '', args: []);
  }

  /// `Tutti`
  String get filterAll {
    return Intl.message('Tutti', name: 'filterAll', desc: '', args: []);
  }

  /// `VIP`
  String get filterVIP {
    return Intl.message('VIP', name: 'filterVIP', desc: '', args: []);
  }

  /// `Inattivi`
  String get filterInactive {
    return Intl.message('Inattivi', name: 'filterInactive', desc: '', args: []);
  }

  /// `Nuovi`
  String get filterNew {
    return Intl.message('Nuovi', name: 'filterNew', desc: '', args: []);
  }

  /// `Nome`
  String get formFirstName {
    return Intl.message('Nome', name: 'formFirstName', desc: '', args: []);
  }

  /// `Cognome`
  String get formLastName {
    return Intl.message('Cognome', name: 'formLastName', desc: '', args: []);
  }

  /// `Email`
  String get formEmail {
    return Intl.message('Email', name: 'formEmail', desc: '', args: []);
  }

  /// `Telefono`
  String get formPhone {
    return Intl.message('Telefono', name: 'formPhone', desc: '', args: []);
  }

  /// `Note (non visibili al cliente)`
  String get formNotes {
    return Intl.message(
      'Note (non visibili al cliente)',
      name: 'formNotes',
      desc: '',
      args: [],
    );
  }

  /// `Richiesto`
  String get validationRequired {
    return Intl.message(
      'Richiesto',
      name: 'validationRequired',
      desc: '',
      args: [],
    );
  }

  /// `Email non valida`
  String get validationInvalidEmail {
    return Intl.message(
      'Email non valida',
      name: 'validationInvalidEmail',
      desc: '',
      args: [],
    );
  }

  /// `Telefono non valido`
  String get validationInvalidPhone {
    return Intl.message(
      'Telefono non valido',
      name: 'validationInvalidPhone',
      desc: '',
      args: [],
    );
  }

  /// `Ultima visita: {date}`
  String lastVisitLabel(String date) {
    return Intl.message(
      'Ultima visita: $date',
      name: 'lastVisitLabel',
      desc: '',
      args: [date],
    );
  }

  /// `Inserire almeno nome o cognome`
  String get validationNameOrLastNameRequired {
    return Intl.message(
      'Inserire almeno nome o cognome',
      name: 'validationNameOrLastNameRequired',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi`
  String get agendaAdd {
    return Intl.message('Aggiungi', name: 'agendaAdd', desc: '', args: []);
  }

  /// `Aggiungi un...`
  String get agendaAddTitle {
    return Intl.message(
      'Aggiungi un...',
      name: 'agendaAddTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo appuntamento`
  String get agendaAddAppointment {
    return Intl.message(
      'Nuovo appuntamento',
      name: 'agendaAddAppointment',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo blocco`
  String get agendaAddBlock {
    return Intl.message(
      'Nuovo blocco',
      name: 'agendaAddBlock',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo appuntamento`
  String get appointmentDialogTitleNew {
    return Intl.message(
      'Nuovo appuntamento',
      name: 'appointmentDialogTitleNew',
      desc: '',
      args: [],
    );
  }

  /// `Modifica appuntamento`
  String get appointmentDialogTitleEdit {
    return Intl.message(
      'Modifica appuntamento',
      name: 'appointmentDialogTitleEdit',
      desc: '',
      args: [],
    );
  }

  /// `Data`
  String get formDate {
    return Intl.message('Data', name: 'formDate', desc: '', args: []);
  }

  /// `Servizio`
  String get formService {
    return Intl.message('Servizio', name: 'formService', desc: '', args: []);
  }

  /// `Cliente`
  String get formClient {
    return Intl.message('Cliente', name: 'formClient', desc: '', args: []);
  }

  /// `Team`
  String get formStaff {
    return Intl.message('Team', name: 'formStaff', desc: '', args: []);
  }

  /// `Dettagli prenotazione`
  String get bookingDetails {
    return Intl.message(
      'Dettagli prenotazione',
      name: 'bookingDetails',
      desc: '',
      args: [],
    );
  }

  /// `Note prenotazione`
  String get bookingNotes {
    return Intl.message(
      'Note prenotazione',
      name: 'bookingNotes',
      desc: '',
      args: [],
    );
  }

  /// `Note`
  String get appointmentNotesTitle {
    return Intl.message(
      'Note',
      name: 'appointmentNotesTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nota appuntamento`
  String get appointmentNoteLabel {
    return Intl.message(
      'Nota appuntamento',
      name: 'appointmentNoteLabel',
      desc: '',
      args: [],
    );
  }

  /// `Nota cliente`
  String get clientNoteLabel {
    return Intl.message(
      'Nota cliente',
      name: 'clientNoteLabel',
      desc: '',
      args: [],
    );
  }

  /// `Servizi`
  String get bookingItems {
    return Intl.message('Servizi', name: 'bookingItems', desc: '', args: []);
  }

  /// `Totale`
  String get bookingTotal {
    return Intl.message('Totale', name: 'bookingTotal', desc: '', args: []);
  }

  /// `Attenzione: l‚Äôorario selezionato per l‚Äôappuntamento include fasce non disponibili per il team scelto.`
  String get bookingUnavailableTimeWarningAppointment {
    return Intl.message(
      'Attenzione: l‚Äôorario selezionato per l‚Äôappuntamento include fasce non disponibili per il team scelto.',
      name: 'bookingUnavailableTimeWarningAppointment',
      desc: '',
      args: [],
    );
  }

  /// `Attenzione: l‚Äôorario di questo servizio include fasce non disponibili per il team scelto.`
  String get bookingUnavailableTimeWarningService {
    return Intl.message(
      'Attenzione: l‚Äôorario di questo servizio include fasce non disponibili per il team scelto.',
      name: 'bookingUnavailableTimeWarningService',
      desc: '',
      args: [],
    );
  }

  /// `Attenzione: il membro del team selezionato non √® abilitato per questo servizio.`
  String get bookingStaffNotEligibleWarning {
    return Intl.message(
      'Attenzione: il membro del team selezionato non √® abilitato per questo servizio.',
      name: 'bookingStaffNotEligibleWarning',
      desc: '',
      args: [],
    );
  }

  /// `Elimina prenotazione`
  String get actionDeleteBooking {
    return Intl.message(
      'Elimina prenotazione',
      name: 'actionDeleteBooking',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare l'appuntamento?`
  String get deleteAppointmentConfirmTitle {
    return Intl.message(
      'Eliminare l\'appuntamento?',
      name: 'deleteAppointmentConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `L'appuntamento verr√† rimosso. L'operazione non pu√≤ essere annullata.`
  String get deleteAppointmentConfirmMessage {
    return Intl.message(
      'L\'appuntamento verr√† rimosso. L\'operazione non pu√≤ essere annullata.',
      name: 'deleteAppointmentConfirmMessage',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare l‚Äôintera prenotazione?`
  String get deleteBookingConfirmTitle {
    return Intl.message(
      'Eliminare l‚Äôintera prenotazione?',
      name: 'deleteBookingConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `Verranno rimossi tutti i servizi collegati. L'operazione non pu√≤ essere annullata.`
  String get deleteBookingConfirmMessage {
    return Intl.message(
      'Verranno rimossi tutti i servizi collegati. L\'operazione non pu√≤ essere annullata.',
      name: 'deleteBookingConfirmMessage',
      desc: '',
      args: [],
    );
  }

  /// `Sedi`
  String get teamLocationsLabel {
    return Intl.message('Sedi', name: 'teamLocationsLabel', desc: '', args: []);
  }

  /// `Team`
  String get teamStaffLabel {
    return Intl.message('Team', name: 'teamStaffLabel', desc: '', args: []);
  }

  /// `Aggiungi membro`
  String get teamAddStaff {
    return Intl.message(
      'Aggiungi membro',
      name: 'teamAddStaff',
      desc: '',
      args: [],
    );
  }

  /// `Nessun membro in questa sede`
  String get teamNoStaffInLocation {
    return Intl.message(
      'Nessun membro in questa sede',
      name: 'teamNoStaffInLocation',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile eliminare la sede`
  String get teamDeleteLocationBlockedTitle {
    return Intl.message(
      'Impossibile eliminare la sede',
      name: 'teamDeleteLocationBlockedTitle',
      desc: '',
      args: [],
    );
  }

  /// `Rimuovi prima tutti i membri del team associati.`
  String get teamDeleteLocationBlockedMessage {
    return Intl.message(
      'Rimuovi prima tutti i membri del team associati.',
      name: 'teamDeleteLocationBlockedMessage',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare la sede?`
  String get teamDeleteLocationTitle {
    return Intl.message(
      'Eliminare la sede?',
      name: 'teamDeleteLocationTitle',
      desc: '',
      args: [],
    );
  }

  /// `La sede verr√† rimossa dal team. L'operazione non pu√≤ essere annullata.`
  String get teamDeleteLocationMessage {
    return Intl.message(
      'La sede verr√† rimossa dal team. L\'operazione non pu√≤ essere annullata.',
      name: 'teamDeleteLocationMessage',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare il membro del team?`
  String get teamDeleteStaffTitle {
    return Intl.message(
      'Eliminare il membro del team?',
      name: 'teamDeleteStaffTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il membro verr√† rimosso dal team. L'operazione non pu√≤ essere annullata.`
  String get teamDeleteStaffMessage {
    return Intl.message(
      'Il membro verr√† rimosso dal team. L\'operazione non pu√≤ essere annullata.',
      name: 'teamDeleteStaffMessage',
      desc: '',
      args: [],
    );
  }

  /// `Nuova sede`
  String get teamNewLocationTitle {
    return Intl.message(
      'Nuova sede',
      name: 'teamNewLocationTitle',
      desc: '',
      args: [],
    );
  }

  /// `Modifica sede`
  String get teamEditLocationTitle {
    return Intl.message(
      'Modifica sede',
      name: 'teamEditLocationTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nome sede`
  String get teamLocationNameLabel {
    return Intl.message(
      'Nome sede',
      name: 'teamLocationNameLabel',
      desc: '',
      args: [],
    );
  }

  /// `Indirizzo`
  String get teamLocationAddressLabel {
    return Intl.message(
      'Indirizzo',
      name: 'teamLocationAddressLabel',
      desc: '',
      args: [],
    );
  }

  /// `Email`
  String get teamLocationEmailLabel {
    return Intl.message(
      'Email',
      name: 'teamLocationEmailLabel',
      desc: '',
      args: [],
    );
  }

  /// `Email per notifiche ai clienti`
  String get teamLocationEmailHint {
    return Intl.message(
      'Email per notifiche ai clienti',
      name: 'teamLocationEmailHint',
      desc: '',
      args: [],
    );
  }

  /// `Sede attiva`
  String get teamLocationIsActiveLabel {
    return Intl.message(
      'Sede attiva',
      name: 'teamLocationIsActiveLabel',
      desc: '',
      args: [],
    );
  }

  /// `Se disattivata, la sede non sar√† visibile ai clienti`
  String get teamLocationIsActiveHint {
    return Intl.message(
      'Se disattivata, la sede non sar√† visibile ai clienti',
      name: 'teamLocationIsActiveHint',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo membro del team`
  String get teamNewStaffTitle {
    return Intl.message(
      'Nuovo membro del team',
      name: 'teamNewStaffTitle',
      desc: '',
      args: [],
    );
  }

  /// `Modifica membro del team`
  String get teamEditStaffTitle {
    return Intl.message(
      'Modifica membro del team',
      name: 'teamEditStaffTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nome`
  String get teamStaffNameLabel {
    return Intl.message('Nome', name: 'teamStaffNameLabel', desc: '', args: []);
  }

  /// `Cognome`
  String get teamStaffSurnameLabel {
    return Intl.message(
      'Cognome',
      name: 'teamStaffSurnameLabel',
      desc: '',
      args: [],
    );
  }

  /// `Colore`
  String get teamStaffColorLabel {
    return Intl.message(
      'Colore',
      name: 'teamStaffColorLabel',
      desc: '',
      args: [],
    );
  }

  /// `Sedi associate`
  String get teamStaffLocationsLabel {
    return Intl.message(
      'Sedi associate',
      name: 'teamStaffLocationsLabel',
      desc: '',
      args: [],
    );
  }

  /// `Se il membro lavora su pi√π sedi, ricorda di allineare disponibilit√† e orari con le sedi selezionate.`
  String get teamStaffMultiLocationWarning {
    return Intl.message(
      'Se il membro lavora su pi√π sedi, ricorda di allineare disponibilit√† e orari con le sedi selezionate.',
      name: 'teamStaffMultiLocationWarning',
      desc: '',
      args: [],
    );
  }

  /// `Team abilitato`
  String get teamEligibleStaffLabel {
    return Intl.message(
      'Team abilitato',
      name: 'teamEligibleStaffLabel',
      desc: '',
      args: [],
    );
  }

  /// `Servizi abilitati`
  String get teamEligibleServicesLabel {
    return Intl.message(
      'Servizi abilitati',
      name: 'teamEligibleServicesLabel',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona tutto`
  String get teamSelectAllServices {
    return Intl.message(
      'Seleziona tutto',
      name: 'teamSelectAllServices',
      desc: '',
      args: [],
    );
  }

  /// `{count} servizi abilitati`
  String teamEligibleServicesCount(int count) {
    return Intl.message(
      '$count servizi abilitati',
      name: 'teamEligibleServicesCount',
      desc: '',
      args: [count],
    );
  }

  /// `Nessun servizio abilitato`
  String get teamEligibleServicesNone {
    return Intl.message(
      'Nessun servizio abilitato',
      name: 'teamEligibleServicesNone',
      desc: '',
      args: [],
    );
  }

  /// `Servizi selezionati`
  String get teamSelectedServicesButton {
    return Intl.message(
      'Servizi selezionati',
      name: 'teamSelectedServicesButton',
      desc: '',
      args: [],
    );
  }

  /// `{selected} su {total}`
  String teamSelectedServicesCount(int selected, int total) {
    return Intl.message(
      '$selected su $total',
      name: 'teamSelectedServicesCount',
      desc: '',
      args: [selected, total],
    );
  }

  /// `Servizi`
  String get teamServicesLabel {
    return Intl.message(
      'Servizi',
      name: 'teamServicesLabel',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona sedi`
  String get teamChooseLocationsButton {
    return Intl.message(
      'Seleziona sedi',
      name: 'teamChooseLocationsButton',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona la sede`
  String get teamChooseLocationSingleButton {
    return Intl.message(
      'Seleziona la sede',
      name: 'teamChooseLocationSingleButton',
      desc: '',
      args: [],
    );
  }

  /// `Sede`
  String get teamLocationLabel {
    return Intl.message('Sede', name: 'teamLocationLabel', desc: '', args: []);
  }

  /// `Seleziona tutto`
  String get teamSelectAllLocations {
    return Intl.message(
      'Seleziona tutto',
      name: 'teamSelectAllLocations',
      desc: '',
      args: [],
    );
  }

  /// `Abilitato alle prenotazioni online`
  String get teamStaffBookableOnlineLabel {
    return Intl.message(
      'Abilitato alle prenotazioni online',
      name: 'teamStaffBookableOnlineLabel',
      desc: '',
      args: [],
    );
  }

  /// `Non prenotabile online`
  String get staffNotBookableOnlineTooltip {
    return Intl.message(
      'Non prenotabile online',
      name: 'staffNotBookableOnlineTooltip',
      desc: '',
      args: [],
    );
  }

  /// `Non prenotabile online`
  String get staffNotBookableOnlineTitle {
    return Intl.message(
      'Non prenotabile online',
      name: 'staffNotBookableOnlineTitle',
      desc: '',
      args: [],
    );
  }

  /// `Questo membro del team non √® abilitato alle prenotazioni online. Puoi modificare l‚Äôimpostazione dal form di modifica dello staff.`
  String get staffNotBookableOnlineMessage {
    return Intl.message(
      'Questo membro del team non √® abilitato alle prenotazioni online. Puoi modificare l‚Äôimpostazione dal form di modifica dello staff.',
      name: 'staffNotBookableOnlineMessage',
      desc: '',
      args: [],
    );
  }

  /// `{count} membri abilitati`
  String serviceEligibleStaffCount(int count) {
    return Intl.message(
      '$count membri abilitati',
      name: 'serviceEligibleStaffCount',
      desc: '',
      args: [count],
    );
  }

  /// `Nessun membro abilitato`
  String get serviceEligibleStaffNone {
    return Intl.message(
      'Nessun membro abilitato',
      name: 'serviceEligibleStaffNone',
      desc: '',
      args: [],
    );
  }

  /// `Riordina sedi e membri del team trascinandoli. Seleziona se ordinare sedi o team. L‚Äôordine sar√† lo stesso anche nella sezione agenda.`
  String get teamReorderHelpDescription {
    return Intl.message(
      'Riordina sedi e membri del team trascinandoli. Seleziona se ordinare sedi o team. L‚Äôordine sar√† lo stesso anche nella sezione agenda.',
      name: 'teamReorderHelpDescription',
      desc: '',
      args: [],
    );
  }

  /// `Nuova categoria`
  String get createCategoryButtonLabel {
    return Intl.message(
      'Nuova categoria',
      name: 'createCategoryButtonLabel',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo servizio`
  String get servicesNewServiceMenu {
    return Intl.message(
      'Nuovo servizio',
      name: 'servicesNewServiceMenu',
      desc: '',
      args: [],
    );
  }

  /// `Modifica ordinamento`
  String get reorderTitle {
    return Intl.message(
      'Modifica ordinamento',
      name: 'reorderTitle',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi servizio`
  String get addServiceTooltip {
    return Intl.message(
      'Aggiungi servizio',
      name: 'addServiceTooltip',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile eliminare`
  String get cannotDeleteTitle {
    return Intl.message(
      'Impossibile eliminare',
      name: 'cannotDeleteTitle',
      desc: '',
      args: [],
    );
  }

  /// `La categoria contiene uno o pi√π servizi.`
  String get cannotDeleteCategoryContent {
    return Intl.message(
      'La categoria contiene uno o pi√π servizi.',
      name: 'cannotDeleteCategoryContent',
      desc: '',
      args: [],
    );
  }

  /// `Nessun servizio in questa categoria`
  String get noServicesInCategory {
    return Intl.message(
      'Nessun servizio in questa categoria',
      name: 'noServicesInCategory',
      desc: '',
      args: [],
    );
  }

  /// `Non prenotabile online`
  String get notBookableOnline {
    return Intl.message(
      'Non prenotabile online',
      name: 'notBookableOnline',
      desc: '',
      args: [],
    );
  }

  /// `Duplica`
  String get duplicateAction {
    return Intl.message('Duplica', name: 'duplicateAction', desc: '', args: []);
  }

  /// `Eliminare il servizio?`
  String get deleteServiceQuestion {
    return Intl.message(
      'Eliminare il servizio?',
      name: 'deleteServiceQuestion',
      desc: '',
      args: [],
    );
  }

  /// `Questa azione non pu√≤ essere annullata.`
  String get cannotUndoWarning {
    return Intl.message(
      'Questa azione non pu√≤ essere annullata.',
      name: 'cannotUndoWarning',
      desc: '',
      args: [],
    );
  }

  /// `Nuova categoria`
  String get newCategoryTitle {
    return Intl.message(
      'Nuova categoria',
      name: 'newCategoryTitle',
      desc: '',
      args: [],
    );
  }

  /// `Modifica categoria`
  String get editCategoryTitle {
    return Intl.message(
      'Modifica categoria',
      name: 'editCategoryTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nome *`
  String get fieldNameRequiredLabel {
    return Intl.message(
      'Nome *',
      name: 'fieldNameRequiredLabel',
      desc: '',
      args: [],
    );
  }

  /// `Il nome √® obbligatorio`
  String get fieldNameRequiredError {
    return Intl.message(
      'Il nome √® obbligatorio',
      name: 'fieldNameRequiredError',
      desc: '',
      args: [],
    );
  }

  /// `Esiste gi√† una categoria con questo nome`
  String get categoryDuplicateError {
    return Intl.message(
      'Esiste gi√† una categoria con questo nome',
      name: 'categoryDuplicateError',
      desc: '',
      args: [],
    );
  }

  /// `Descrizione`
  String get fieldDescriptionLabel {
    return Intl.message(
      'Descrizione',
      name: 'fieldDescriptionLabel',
      desc: '',
      args: [],
    );
  }

  /// `Colore servizio`
  String get serviceColorLabel {
    return Intl.message(
      'Colore servizio',
      name: 'serviceColorLabel',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo servizio`
  String get newServiceTitle {
    return Intl.message(
      'Nuovo servizio',
      name: 'newServiceTitle',
      desc: '',
      args: [],
    );
  }

  /// `Modifica servizio`
  String get editServiceTitle {
    return Intl.message(
      'Modifica servizio',
      name: 'editServiceTitle',
      desc: '',
      args: [],
    );
  }

  /// `Categoria *`
  String get fieldCategoryRequiredLabel {
    return Intl.message(
      'Categoria *',
      name: 'fieldCategoryRequiredLabel',
      desc: '',
      args: [],
    );
  }

  /// `Durata *`
  String get fieldDurationRequiredLabel {
    return Intl.message(
      'Durata *',
      name: 'fieldDurationRequiredLabel',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona una durata`
  String get fieldDurationRequiredError {
    return Intl.message(
      'Seleziona una durata',
      name: 'fieldDurationRequiredError',
      desc: '',
      args: [],
    );
  }

  /// `Prezzo`
  String get fieldPriceLabel {
    return Intl.message('Prezzo', name: 'fieldPriceLabel', desc: '', args: []);
  }

  /// `Tempo di lavorazione`
  String get fieldProcessingTimeLabel {
    return Intl.message(
      'Tempo di lavorazione',
      name: 'fieldProcessingTimeLabel',
      desc: '',
      args: [],
    );
  }

  /// `Tempo bloccato`
  String get fieldBlockedTimeLabel {
    return Intl.message(
      'Tempo bloccato',
      name: 'fieldBlockedTimeLabel',
      desc: '',
      args: [],
    );
  }

  /// `Tempo aggiuntivo`
  String get additionalTimeSwitch {
    return Intl.message(
      'Tempo aggiuntivo',
      name: 'additionalTimeSwitch',
      desc: '',
      args: [],
    );
  }

  /// `Tempo di lavorazione`
  String get additionalTimeOptionProcessing {
    return Intl.message(
      'Tempo di lavorazione',
      name: 'additionalTimeOptionProcessing',
      desc: '',
      args: [],
    );
  }

  /// `Tempo bloccato`
  String get additionalTimeOptionBlocked {
    return Intl.message(
      'Tempo bloccato',
      name: 'additionalTimeOptionBlocked',
      desc: '',
      args: [],
    );
  }

  /// `Prenotabile online`
  String get bookableOnlineSwitch {
    return Intl.message(
      'Prenotabile online',
      name: 'bookableOnlineSwitch',
      desc: '',
      args: [],
    );
  }

  /// `Servizio gratuito`
  String get freeServiceSwitch {
    return Intl.message(
      'Servizio gratuito',
      name: 'freeServiceSwitch',
      desc: '',
      args: [],
    );
  }

  /// `Prezzo "a partire da"`
  String get priceStartingFromSwitch {
    return Intl.message(
      'Prezzo "a partire da"',
      name: 'priceStartingFromSwitch',
      desc: '',
      args: [],
    );
  }

  /// `Imposta un prezzo per abilitarlo`
  String get setPriceToEnable {
    return Intl.message(
      'Imposta un prezzo per abilitarlo',
      name: 'setPriceToEnable',
      desc: '',
      args: [],
    );
  }

  /// `Esiste gi√† un servizio con questo nome`
  String get serviceDuplicateError {
    return Intl.message(
      'Esiste gi√† un servizio con questo nome',
      name: 'serviceDuplicateError',
      desc: '',
      args: [],
    );
  }

  /// `Riordina categorie e servizi trascinandoli: l‚Äôordine sar√† lo stesso anche nella prenotazione online. Seleziona se ordinare categorie o servizi.`
  String get reorderHelpDescription {
    return Intl.message(
      'Riordina categorie e servizi trascinandoli: l‚Äôordine sar√† lo stesso anche nella prenotazione online. Seleziona se ordinare categorie o servizi.',
      name: 'reorderHelpDescription',
      desc: '',
      args: [],
    );
  }

  /// `Categorie`
  String get reorderCategoriesLabel {
    return Intl.message(
      'Categorie',
      name: 'reorderCategoriesLabel',
      desc: '',
      args: [],
    );
  }

  /// `Servizi`
  String get reorderServicesLabel {
    return Intl.message(
      'Servizi',
      name: 'reorderServicesLabel',
      desc: '',
      args: [],
    );
  }

  /// `Le categorie senza servizi non sono riordinabili e restano in coda.`
  String get emptyCategoriesNotReorderableNote {
    return Intl.message(
      'Le categorie senza servizi non sono riordinabili e restano in coda.',
      name: 'emptyCategoriesNotReorderableNote',
      desc: '',
      args: [],
    );
  }

  /// `Trattamenti Corpo`
  String get serviceSeedCategoryBodyName {
    return Intl.message(
      'Trattamenti Corpo',
      name: 'serviceSeedCategoryBodyName',
      desc: '',
      args: [],
    );
  }

  /// `Servizi dedicati al benessere del corpo`
  String get serviceSeedCategoryBodyDescription {
    return Intl.message(
      'Servizi dedicati al benessere del corpo',
      name: 'serviceSeedCategoryBodyDescription',
      desc: '',
      args: [],
    );
  }

  /// `Trattamenti Sportivi`
  String get serviceSeedCategorySportsName {
    return Intl.message(
      'Trattamenti Sportivi',
      name: 'serviceSeedCategorySportsName',
      desc: '',
      args: [],
    );
  }

  /// `Percorsi pensati per atleti e persone attive`
  String get serviceSeedCategorySportsDescription {
    return Intl.message(
      'Percorsi pensati per atleti e persone attive',
      name: 'serviceSeedCategorySportsDescription',
      desc: '',
      args: [],
    );
  }

  /// `Trattamenti Viso`
  String get serviceSeedCategoryFaceName {
    return Intl.message(
      'Trattamenti Viso',
      name: 'serviceSeedCategoryFaceName',
      desc: '',
      args: [],
    );
  }

  /// `Cura estetica e rigenerante per il viso`
  String get serviceSeedCategoryFaceDescription {
    return Intl.message(
      'Cura estetica e rigenerante per il viso',
      name: 'serviceSeedCategoryFaceDescription',
      desc: '',
      args: [],
    );
  }

  /// `Massaggio Relax`
  String get serviceSeedServiceRelaxName {
    return Intl.message(
      'Massaggio Relax',
      name: 'serviceSeedServiceRelaxName',
      desc: '',
      args: [],
    );
  }

  /// `Trattamento rilassante da 30 minuti`
  String get serviceSeedServiceRelaxDescription {
    return Intl.message(
      'Trattamento rilassante da 30 minuti',
      name: 'serviceSeedServiceRelaxDescription',
      desc: '',
      args: [],
    );
  }

  /// `Massaggio Sportivo`
  String get serviceSeedServiceSportName {
    return Intl.message(
      'Massaggio Sportivo',
      name: 'serviceSeedServiceSportName',
      desc: '',
      args: [],
    );
  }

  /// `Trattamento decontratturante intensivo`
  String get serviceSeedServiceSportDescription {
    return Intl.message(
      'Trattamento decontratturante intensivo',
      name: 'serviceSeedServiceSportDescription',
      desc: '',
      args: [],
    );
  }

  /// `Trattamento Viso`
  String get serviceSeedServiceFaceName {
    return Intl.message(
      'Trattamento Viso',
      name: 'serviceSeedServiceFaceName',
      desc: '',
      args: [],
    );
  }

  /// `Pulizia e trattamento illuminante`
  String get serviceSeedServiceFaceDescription {
    return Intl.message(
      'Pulizia e trattamento illuminante',
      name: 'serviceSeedServiceFaceDescription',
      desc: '',
      args: [],
    );
  }

  /// `Copia`
  String get serviceDuplicateCopyWord {
    return Intl.message(
      'Copia',
      name: 'serviceDuplicateCopyWord',
      desc: '',
      args: [],
    );
  }

  /// `Confermi lo spostamento?`
  String get moveAppointmentConfirmTitle {
    return Intl.message(
      'Confermi lo spostamento?',
      name: 'moveAppointmentConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `L'appuntamento verr√† spostato alle {newTime} per {staffName}.`
  String moveAppointmentConfirmMessage(String newTime, String staffName) {
    return Intl.message(
      'L\'appuntamento verr√† spostato alle $newTime per $staffName.',
      name: 'moveAppointmentConfirmMessage',
      desc: '',
      args: [newTime, staffName],
    );
  }

  /// `Modifiche non salvate`
  String get discardChangesTitle {
    return Intl.message(
      'Modifiche non salvate',
      name: 'discardChangesTitle',
      desc: '',
      args: [],
    );
  }

  /// `Hai delle modifiche non salvate. Vuoi scartarle?`
  String get discardChangesMessage {
    return Intl.message(
      'Hai delle modifiche non salvate. Vuoi scartarle?',
      name: 'discardChangesMessage',
      desc: '',
      args: [],
    );
  }

  /// `Annulla`
  String get actionDiscard {
    return Intl.message('Annulla', name: 'actionDiscard', desc: '', args: []);
  }

  /// `Continua a modificare`
  String get actionKeepEditing {
    return Intl.message(
      'Continua a modificare',
      name: 'actionKeepEditing',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare il cliente?`
  String get deleteClientConfirmTitle {
    return Intl.message(
      'Eliminare il cliente?',
      name: 'deleteClientConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il cliente verr√† eliminato definitivamente. Questa azione non pu√≤ essere annullata.`
  String get deleteClientConfirmMessage {
    return Intl.message(
      'Il cliente verr√† eliminato definitivamente. Questa azione non pu√≤ essere annullata.',
      name: 'deleteClientConfirmMessage',
      desc: '',
      args: [],
    );
  }

  /// `Nome (A-Z)`
  String get sortByNameAsc {
    return Intl.message(
      'Nome (A-Z)',
      name: 'sortByNameAsc',
      desc: '',
      args: [],
    );
  }

  /// `Nome (Z-A)`
  String get sortByNameDesc {
    return Intl.message(
      'Nome (Z-A)',
      name: 'sortByNameDesc',
      desc: '',
      args: [],
    );
  }

  /// `Cognome (A-Z)`
  String get sortByLastNameAsc {
    return Intl.message(
      'Cognome (A-Z)',
      name: 'sortByLastNameAsc',
      desc: '',
      args: [],
    );
  }

  /// `Cognome (Z-A)`
  String get sortByLastNameDesc {
    return Intl.message(
      'Cognome (Z-A)',
      name: 'sortByLastNameDesc',
      desc: '',
      args: [],
    );
  }

  /// `Ultima visita (recenti)`
  String get sortByLastVisitDesc {
    return Intl.message(
      'Ultima visita (recenti)',
      name: 'sortByLastVisitDesc',
      desc: '',
      args: [],
    );
  }

  /// `Ultima visita (meno recenti)`
  String get sortByLastVisitAsc {
    return Intl.message(
      'Ultima visita (meno recenti)',
      name: 'sortByLastVisitAsc',
      desc: '',
      args: [],
    );
  }

  /// `Data creazione (nuovi)`
  String get sortByCreatedAtDesc {
    return Intl.message(
      'Data creazione (nuovi)',
      name: 'sortByCreatedAtDesc',
      desc: '',
      args: [],
    );
  }

  /// `Data creazione (vecchi)`
  String get sortByCreatedAtAsc {
    return Intl.message(
      'Data creazione (vecchi)',
      name: 'sortByCreatedAtAsc',
      desc: '',
      args: [],
    );
  }

  /// `Appuntamenti di {clientName}`
  String clientAppointmentsTitle(String clientName) {
    return Intl.message(
      'Appuntamenti di $clientName',
      name: 'clientAppointmentsTitle',
      desc: '',
      args: [clientName],
    );
  }

  /// `Prossimi`
  String get clientAppointmentsUpcoming {
    return Intl.message(
      'Prossimi',
      name: 'clientAppointmentsUpcoming',
      desc: '',
      args: [],
    );
  }

  /// `Passati`
  String get clientAppointmentsPast {
    return Intl.message(
      'Passati',
      name: 'clientAppointmentsPast',
      desc: '',
      args: [],
    );
  }

  /// `Nessun appuntamento`
  String get clientAppointmentsEmpty {
    return Intl.message(
      'Nessun appuntamento',
      name: 'clientAppointmentsEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Filtra team`
  String get staffFilterTooltip {
    return Intl.message(
      'Filtra team',
      name: 'staffFilterTooltip',
      desc: '',
      args: [],
    );
  }

  /// `Filtra team`
  String get staffFilterTitle {
    return Intl.message(
      'Filtra team',
      name: 'staffFilterTitle',
      desc: '',
      args: [],
    );
  }

  /// `Tutto il team`
  String get staffFilterAllTeam {
    return Intl.message(
      'Tutto il team',
      name: 'staffFilterAllTeam',
      desc: '',
      args: [],
    );
  }

  /// `Team di turno`
  String get staffFilterOnDuty {
    return Intl.message(
      'Team di turno',
      name: 'staffFilterOnDuty',
      desc: '',
      args: [],
    );
  }

  /// `Nessun membro del team di turno oggi`
  String get agendaNoOnDutyTeamTitle {
    return Intl.message(
      'Nessun membro del team di turno oggi',
      name: 'agendaNoOnDutyTeamTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessun membro del team selezionato`
  String get agendaNoSelectedTeamTitle {
    return Intl.message(
      'Nessun membro del team selezionato',
      name: 'agendaNoSelectedTeamTitle',
      desc: '',
      args: [],
    );
  }

  /// `Visualizza tutto il team`
  String get agendaShowAllTeamButton {
    return Intl.message(
      'Visualizza tutto il team',
      name: 'agendaShowAllTeamButton',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona membri del team`
  String get staffFilterSelectMembers {
    return Intl.message(
      'Seleziona membri del team',
      name: 'staffFilterSelectMembers',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo blocco`
  String get blockDialogTitleNew {
    return Intl.message(
      'Nuovo blocco',
      name: 'blockDialogTitleNew',
      desc: '',
      args: [],
    );
  }

  /// `Modifica blocco`
  String get blockDialogTitleEdit {
    return Intl.message(
      'Modifica blocco',
      name: 'blockDialogTitleEdit',
      desc: '',
      args: [],
    );
  }

  /// `Giornata intera`
  String get blockAllDay {
    return Intl.message(
      'Giornata intera',
      name: 'blockAllDay',
      desc: '',
      args: [],
    );
  }

  /// `Orario inizio`
  String get blockStartTime {
    return Intl.message(
      'Orario inizio',
      name: 'blockStartTime',
      desc: '',
      args: [],
    );
  }

  /// `Orario fine`
  String get blockEndTime {
    return Intl.message(
      'Orario fine',
      name: 'blockEndTime',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona team`
  String get blockSelectStaff {
    return Intl.message(
      'Seleziona team',
      name: 'blockSelectStaff',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona almeno un team`
  String get blockSelectStaffError {
    return Intl.message(
      'Seleziona almeno un team',
      name: 'blockSelectStaffError',
      desc: '',
      args: [],
    );
  }

  /// `L'ora di fine deve essere successiva all'ora di inizio`
  String get blockTimeError {
    return Intl.message(
      'L\'ora di fine deve essere successiva all\'ora di inizio',
      name: 'blockTimeError',
      desc: '',
      args: [],
    );
  }

  /// `Motivo (opzionale)`
  String get blockReason {
    return Intl.message(
      'Motivo (opzionale)',
      name: 'blockReason',
      desc: '',
      args: [],
    );
  }

  /// `Es. Riunione, Pausa, ecc.`
  String get blockReasonHint {
    return Intl.message(
      'Es. Riunione, Pausa, ecc.',
      name: 'blockReasonHint',
      desc: '',
      args: [],
    );
  }

  /// `Ordina per`
  String get sortByTitle {
    return Intl.message('Ordina per', name: 'sortByTitle', desc: '', args: []);
  }

  /// `Seleziona team`
  String get selectStaffTitle {
    return Intl.message(
      'Seleziona team',
      name: 'selectStaffTitle',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi un cliente all'appuntamento`
  String get addClientToAppointment {
    return Intl.message(
      'Aggiungi un cliente all\'appuntamento',
      name: 'addClientToAppointment',
      desc: '',
      args: [],
    );
  }

  /// `Lascia il campo vuoto se non vuoi associare un cliente all'appuntamento`
  String get clientOptionalHint {
    return Intl.message(
      'Lascia il campo vuoto se non vuoi associare un cliente all\'appuntamento',
      name: 'clientOptionalHint',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona cliente`
  String get selectClientTitle {
    return Intl.message(
      'Seleziona cliente',
      name: 'selectClientTitle',
      desc: '',
      args: [],
    );
  }

  /// `Rimuovi cliente`
  String get removeClient {
    return Intl.message(
      'Rimuovi cliente',
      name: 'removeClient',
      desc: '',
      args: [],
    );
  }

  /// `Cerca cliente...`
  String get searchClientPlaceholder {
    return Intl.message(
      'Cerca cliente...',
      name: 'searchClientPlaceholder',
      desc: '',
      args: [],
    );
  }

  /// `Crea nuovo cliente`
  String get createNewClient {
    return Intl.message(
      'Crea nuovo cliente',
      name: 'createNewClient',
      desc: '',
      args: [],
    );
  }

  /// `Nessun cliente per l'appuntamento`
  String get noClientForAppointment {
    return Intl.message(
      'Nessun cliente per l\'appuntamento',
      name: 'noClientForAppointment',
      desc: '',
      args: [],
    );
  }

  /// `Servizi`
  String get formServices {
    return Intl.message('Servizi', name: 'formServices', desc: '', args: []);
  }

  /// `{count, plural, =1{1 servizio selezionato} other{{count} servizi selezionati}}`
  String servicesSelectedCount(int count) {
    return Intl.plural(
      count,
      one: '1 servizio selezionato',
      other: '$count servizi selezionati',
      name: 'servicesSelectedCount',
      desc: '',
      args: [count],
    );
  }

  /// `Aggiungi un servizio`
  String get addService {
    return Intl.message(
      'Aggiungi un servizio',
      name: 'addService',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona un servizio`
  String get selectService {
    return Intl.message(
      'Seleziona un servizio',
      name: 'selectService',
      desc: '',
      args: [],
    );
  }

  /// `Nessun servizio aggiunto`
  String get noServicesAdded {
    return Intl.message(
      'Nessun servizio aggiunto',
      name: 'noServicesAdded',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi almeno un servizio`
  String get atLeastOneServiceRequired {
    return Intl.message(
      'Aggiungi almeno un servizio',
      name: 'atLeastOneServiceRequired',
      desc: '',
      args: [],
    );
  }

  /// `Note sull'appuntamento...`
  String get notesPlaceholder {
    return Intl.message(
      'Note sull\'appuntamento...',
      name: 'notesPlaceholder',
      desc: '',
      args: [],
    );
  }

  /// `Nessun team disponibile`
  String get noStaffAvailable {
    return Intl.message(
      'Nessun team disponibile',
      name: 'noStaffAvailable',
      desc: '',
      args: [],
    );
  }

  /// `Orario settimanale`
  String get weeklyScheduleTitle {
    return Intl.message(
      'Orario settimanale',
      name: 'weeklyScheduleTitle',
      desc: '',
      args: [],
    );
  }

  /// `{hours} ore totale`
  String weeklyScheduleTotalHours(int hours) {
    return Intl.message(
      '$hours ore totale',
      name: 'weeklyScheduleTotalHours',
      desc: '',
      args: [hours],
    );
  }

  /// `Non lavora`
  String get weeklyScheduleNotWorking {
    return Intl.message(
      'Non lavora',
      name: 'weeklyScheduleNotWorking',
      desc: '',
      args: [],
    );
  }

  /// `-`
  String get weeklyScheduleFor {
    return Intl.message('-', name: 'weeklyScheduleFor', desc: '', args: []);
  }

  /// `Aggiungi turno`
  String get weeklyScheduleAddShift {
    return Intl.message(
      'Aggiungi turno',
      name: 'weeklyScheduleAddShift',
      desc: '',
      args: [],
    );
  }

  /// `Rimuovi turno`
  String get weeklyScheduleRemoveShift {
    return Intl.message(
      'Rimuovi turno',
      name: 'weeklyScheduleRemoveShift',
      desc: '',
      args: [],
    );
  }

  /// `luned√¨`
  String get dayMondayFull {
    return Intl.message('luned√¨', name: 'dayMondayFull', desc: '', args: []);
  }

  /// `marted√¨`
  String get dayTuesdayFull {
    return Intl.message('marted√¨', name: 'dayTuesdayFull', desc: '', args: []);
  }

  /// `mercoled√¨`
  String get dayWednesdayFull {
    return Intl.message(
      'mercoled√¨',
      name: 'dayWednesdayFull',
      desc: '',
      args: [],
    );
  }

  /// `gioved√¨`
  String get dayThursdayFull {
    return Intl.message('gioved√¨', name: 'dayThursdayFull', desc: '', args: []);
  }

  /// `venerd√¨`
  String get dayFridayFull {
    return Intl.message('venerd√¨', name: 'dayFridayFull', desc: '', args: []);
  }

  /// `sabato`
  String get daySaturdayFull {
    return Intl.message('sabato', name: 'daySaturdayFull', desc: '', args: []);
  }

  /// `domenica`
  String get daySundayFull {
    return Intl.message('domenica', name: 'daySundayFull', desc: '', args: []);
  }

  /// `Nuova eccezione`
  String get exceptionDialogTitleNew {
    return Intl.message(
      'Nuova eccezione',
      name: 'exceptionDialogTitleNew',
      desc: '',
      args: [],
    );
  }

  /// `Modifica eccezione`
  String get exceptionDialogTitleEdit {
    return Intl.message(
      'Modifica eccezione',
      name: 'exceptionDialogTitleEdit',
      desc: '',
      args: [],
    );
  }

  /// `Tipo eccezione`
  String get exceptionType {
    return Intl.message(
      'Tipo eccezione',
      name: 'exceptionType',
      desc: '',
      args: [],
    );
  }

  /// `Non disponibile`
  String get exceptionTypeUnavailable {
    return Intl.message(
      'Non disponibile',
      name: 'exceptionTypeUnavailable',
      desc: '',
      args: [],
    );
  }

  /// `Disponibile`
  String get exceptionTypeAvailable {
    return Intl.message(
      'Disponibile',
      name: 'exceptionTypeAvailable',
      desc: '',
      args: [],
    );
  }

  /// `Giornata intera`
  String get exceptionAllDay {
    return Intl.message(
      'Giornata intera',
      name: 'exceptionAllDay',
      desc: '',
      args: [],
    );
  }

  /// `Orario inizio`
  String get exceptionStartTime {
    return Intl.message(
      'Orario inizio',
      name: 'exceptionStartTime',
      desc: '',
      args: [],
    );
  }

  /// `Orario fine`
  String get exceptionEndTime {
    return Intl.message(
      'Orario fine',
      name: 'exceptionEndTime',
      desc: '',
      args: [],
    );
  }

  /// `Motivo (opzionale)`
  String get exceptionReason {
    return Intl.message(
      'Motivo (opzionale)',
      name: 'exceptionReason',
      desc: '',
      args: [],
    );
  }

  /// `Ferie`
  String get exceptionReasonVacation {
    return Intl.message(
      'Ferie',
      name: 'exceptionReasonVacation',
      desc: '',
      args: [],
    );
  }

  /// `Turno extra`
  String get exceptionReasonExtraShift {
    return Intl.message(
      'Turno extra',
      name: 'exceptionReasonExtraShift',
      desc: '',
      args: [],
    );
  }

  /// `Visita medica`
  String get exceptionReasonMedicalVisit {
    return Intl.message(
      'Visita medica',
      name: 'exceptionReasonMedicalVisit',
      desc: '',
      args: [],
    );
  }

  /// `Es. Ferie, Visita medica, Turno extra...`
  String get exceptionReasonHint {
    return Intl.message(
      'Es. Ferie, Visita medica, Turno extra...',
      name: 'exceptionReasonHint',
      desc: '',
      args: [],
    );
  }

  /// `L'ora di fine deve essere successiva all'ora di inizio`
  String get exceptionTimeError {
    return Intl.message(
      'L\'ora di fine deve essere successiva all\'ora di inizio',
      name: 'exceptionTimeError',
      desc: '',
      args: [],
    );
  }

  /// `Non puoi aggiungere una non disponibilit√† in un giorno senza disponibilit√† base.`
  String get exceptionUnavailableNoBase {
    return Intl.message(
      'Non puoi aggiungere una non disponibilit√† in un giorno senza disponibilit√† base.',
      name: 'exceptionUnavailableNoBase',
      desc: '',
      args: [],
    );
  }

  /// `La non disponibilit√† deve sovrapporsi alla disponibilit√† base.`
  String get exceptionUnavailableNoOverlap {
    return Intl.message(
      'La non disponibilit√† deve sovrapporsi alla disponibilit√† base.',
      name: 'exceptionUnavailableNoOverlap',
      desc: '',
      args: [],
    );
  }

  /// `La disponibilit√† extra deve aggiungere ore rispetto alla disponibilit√† base.`
  String get exceptionAvailableNoEffect {
    return Intl.message(
      'La disponibilit√† extra deve aggiungere ore rispetto alla disponibilit√† base.',
      name: 'exceptionAvailableNoEffect',
      desc: '',
      args: [],
    );
  }

  /// `Alcuni giorni non sono stati salvati: {dates}.`
  String exceptionPartialSaveInfo(Object dates) {
    return Intl.message(
      'Alcuni giorni non sono stati salvati: $dates.',
      name: 'exceptionPartialSaveInfo',
      desc: '',
      args: [dates],
    );
  }

  /// `Alcuni giorni non sono stati salvati: {details}.`
  String exceptionPartialSaveInfoDetailed(Object details) {
    return Intl.message(
      'Alcuni giorni non sono stati salvati: $details.',
      name: 'exceptionPartialSaveInfoDetailed',
      desc: '',
      args: [details],
    );
  }

  /// `Eccezioni non salvate`
  String get exceptionPartialSaveTitle {
    return Intl.message(
      'Eccezioni non salvate',
      name: 'exceptionPartialSaveTitle',
      desc: '',
      args: [],
    );
  }

  /// `I giorni sotto non erano congruenti e non sono stati salvati:`
  String get exceptionPartialSaveMessage {
    return Intl.message(
      'I giorni sotto non erano congruenti e non sono stati salvati:',
      name: 'exceptionPartialSaveMessage',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare l'eccezione?`
  String get exceptionDeleteTitle {
    return Intl.message(
      'Eliminare l\'eccezione?',
      name: 'exceptionDeleteTitle',
      desc: '',
      args: [],
    );
  }

  /// `L'eccezione verr√† eliminata definitivamente.`
  String get exceptionDeleteMessage {
    return Intl.message(
      'L\'eccezione verr√† eliminata definitivamente.',
      name: 'exceptionDeleteMessage',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona orario`
  String get exceptionSelectTime {
    return Intl.message(
      'Seleziona orario',
      name: 'exceptionSelectTime',
      desc: '',
      args: [],
    );
  }

  /// `Eccezioni`
  String get exceptionsTitle {
    return Intl.message(
      'Eccezioni',
      name: 'exceptionsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessuna eccezione configurata`
  String get exceptionsEmpty {
    return Intl.message(
      'Nessuna eccezione configurata',
      name: 'exceptionsEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi eccezione`
  String get exceptionsAdd {
    return Intl.message(
      'Aggiungi eccezione',
      name: 'exceptionsAdd',
      desc: '',
      args: [],
    );
  }

  /// `Periodo`
  String get exceptionPeriodMode {
    return Intl.message(
      'Periodo',
      name: 'exceptionPeriodMode',
      desc: '',
      args: [],
    );
  }

  /// `Giorno singolo`
  String get exceptionPeriodSingle {
    return Intl.message(
      'Giorno singolo',
      name: 'exceptionPeriodSingle',
      desc: '',
      args: [],
    );
  }

  /// `Da - A`
  String get exceptionPeriodRange {
    return Intl.message(
      'Da - A',
      name: 'exceptionPeriodRange',
      desc: '',
      args: [],
    );
  }

  /// `Durata`
  String get exceptionPeriodDuration {
    return Intl.message(
      'Durata',
      name: 'exceptionPeriodDuration',
      desc: '',
      args: [],
    );
  }

  /// `Data inizio`
  String get exceptionDateFrom {
    return Intl.message(
      'Data inizio',
      name: 'exceptionDateFrom',
      desc: '',
      args: [],
    );
  }

  /// `Data fine`
  String get exceptionDateTo {
    return Intl.message(
      'Data fine',
      name: 'exceptionDateTo',
      desc: '',
      args: [],
    );
  }

  /// `Durata (giorni)`
  String get exceptionDuration {
    return Intl.message(
      'Durata (giorni)',
      name: 'exceptionDuration',
      desc: '',
      args: [],
    );
  }

  /// `{count} {count, plural, =1{giorno} other{giorni}}`
  String exceptionDurationDays(int count) {
    return Intl.message(
      '$count ${Intl.plural(count, one: 'giorno', other: 'giorni')}',
      name: 'exceptionDurationDays',
      desc: '',
      args: [count],
    );
  }

  /// `Elimina solo questo turno`
  String get shiftDeleteThisOnly {
    return Intl.message(
      'Elimina solo questo turno',
      name: 'shiftDeleteThisOnly',
      desc: '',
      args: [],
    );
  }

  /// `Elimina solo la fascia oraria di {date}`
  String shiftDeleteThisOnlyDesc(String date) {
    return Intl.message(
      'Elimina solo la fascia oraria di $date',
      name: 'shiftDeleteThisOnlyDesc',
      desc: '',
      args: [date],
    );
  }

  /// `Elimina tutti questi turni`
  String get shiftDeleteAll {
    return Intl.message(
      'Elimina tutti questi turni',
      name: 'shiftDeleteAll',
      desc: '',
      args: [],
    );
  }

  /// `Elimina la fascia oraria settimanale di ogni {dayName}`
  String shiftDeleteAllDesc(String dayName) {
    return Intl.message(
      'Elimina la fascia oraria settimanale di ogni $dayName',
      name: 'shiftDeleteAllDesc',
      desc: '',
      args: [dayName],
    );
  }

  /// `Modifica solo questo turno`
  String get shiftEditThisOnly {
    return Intl.message(
      'Modifica solo questo turno',
      name: 'shiftEditThisOnly',
      desc: '',
      args: [],
    );
  }

  /// `Modifica solo la fascia oraria di {date}`
  String shiftEditThisOnlyDesc(String date) {
    return Intl.message(
      'Modifica solo la fascia oraria di $date',
      name: 'shiftEditThisOnlyDesc',
      desc: '',
      args: [date],
    );
  }

  /// `Modifica tutti questi turni`
  String get shiftEditAll {
    return Intl.message(
      'Modifica tutti questi turni',
      name: 'shiftEditAll',
      desc: '',
      args: [],
    );
  }

  /// `Modifica la fascia oraria settimanale di ogni {dayName}`
  String shiftEditAllDesc(String dayName) {
    return Intl.message(
      'Modifica la fascia oraria settimanale di ogni $dayName',
      name: 'shiftEditAllDesc',
      desc: '',
      args: [dayName],
    );
  }

  /// `Modifica turno`
  String get shiftEditTitle {
    return Intl.message(
      'Modifica turno',
      name: 'shiftEditTitle',
      desc: '',
      args: [],
    );
  }

  /// `Ora inizio`
  String get shiftStartTime {
    return Intl.message(
      'Ora inizio',
      name: 'shiftStartTime',
      desc: '',
      args: [],
    );
  }

  /// `Ora fine`
  String get shiftEndTime {
    return Intl.message('Ora fine', name: 'shiftEndTime', desc: '', args: []);
  }

  /// `Modifica eccezione`
  String get exceptionEditShift {
    return Intl.message(
      'Modifica eccezione',
      name: 'exceptionEditShift',
      desc: '',
      args: [],
    );
  }

  /// `Modifica gli orari di questa eccezione`
  String get exceptionEditShiftDesc {
    return Intl.message(
      'Modifica gli orari di questa eccezione',
      name: 'exceptionEditShiftDesc',
      desc: '',
      args: [],
    );
  }

  /// `Elimina eccezione`
  String get exceptionDeleteShift {
    return Intl.message(
      'Elimina eccezione',
      name: 'exceptionDeleteShift',
      desc: '',
      args: [],
    );
  }

  /// `Ripristina la disponibilit√† base`
  String get exceptionDeleteShiftDesc {
    return Intl.message(
      'Ripristina la disponibilit√† base',
      name: 'exceptionDeleteShiftDesc',
      desc: '',
      args: [],
    );
  }

  /// `Il cliente non pu√≤ essere modificato per questo appuntamento`
  String get clientLockedHint {
    return Intl.message(
      'Il cliente non pu√≤ essere modificato per questo appuntamento',
      name: 'clientLockedHint',
      desc: '',
      args: [],
    );
  }

  /// `Applicare il cliente a tutta la prenotazione?`
  String get applyClientToAllAppointmentsTitle {
    return Intl.message(
      'Applicare il cliente a tutta la prenotazione?',
      name: 'applyClientToAllAppointmentsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il cliente verr√† associato anche agli altri {count} appuntamenti di questa prenotazione.`
  String applyClientToAllAppointmentsMessage(int count) {
    return Intl.message(
      'Il cliente verr√† associato anche agli altri $count appuntamenti di questa prenotazione.',
      name: 'applyClientToAllAppointmentsMessage',
      desc: '',
      args: [count],
    );
  }

  /// `Operatori`
  String get operatorsTitle {
    return Intl.message(
      'Operatori',
      name: 'operatorsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Gestisci chi pu√≤ accedere al gestionale`
  String get operatorsSubtitle {
    return Intl.message(
      'Gestisci chi pu√≤ accedere al gestionale',
      name: 'operatorsSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessun operatore configurato`
  String get operatorsEmpty {
    return Intl.message(
      'Nessun operatore configurato',
      name: 'operatorsEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Invita operatore`
  String get operatorsInviteTitle {
    return Intl.message(
      'Invita operatore',
      name: 'operatorsInviteTitle',
      desc: '',
      args: [],
    );
  }

  /// `Invia un invito via email`
  String get operatorsInviteSubtitle {
    return Intl.message(
      'Invia un invito via email',
      name: 'operatorsInviteSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Email`
  String get operatorsInviteEmail {
    return Intl.message(
      'Email',
      name: 'operatorsInviteEmail',
      desc: '',
      args: [],
    );
  }

  /// `Ruolo`
  String get operatorsInviteRole {
    return Intl.message(
      'Ruolo',
      name: 'operatorsInviteRole',
      desc: '',
      args: [],
    );
  }

  /// `Invia invito`
  String get operatorsInviteSend {
    return Intl.message(
      'Invia invito',
      name: 'operatorsInviteSend',
      desc: '',
      args: [],
    );
  }

  /// `Invito inviato a {email}`
  String operatorsInviteSuccess(String email) {
    return Intl.message(
      'Invito inviato a $email',
      name: 'operatorsInviteSuccess',
      desc: '',
      args: [email],
    );
  }

  /// `Link di invito copiato`
  String get operatorsInviteCopied {
    return Intl.message(
      'Link di invito copiato',
      name: 'operatorsInviteCopied',
      desc: '',
      args: [],
    );
  }

  /// `Inviti in attesa`
  String get operatorsPendingInvites {
    return Intl.message(
      'Inviti in attesa',
      name: 'operatorsPendingInvites',
      desc: '',
      args: [],
    );
  }

  /// `{count} inviti in attesa`
  String operatorsPendingInvitesCount(int count) {
    return Intl.message(
      '$count inviti in attesa',
      name: 'operatorsPendingInvitesCount',
      desc: '',
      args: [count],
    );
  }

  /// `Revoca invito`
  String get operatorsRevokeInvite {
    return Intl.message(
      'Revoca invito',
      name: 'operatorsRevokeInvite',
      desc: '',
      args: [],
    );
  }

  /// `Vuoi revocare l'invito per {email}?`
  String operatorsRevokeInviteConfirm(String email) {
    return Intl.message(
      'Vuoi revocare l\'invito per $email?',
      name: 'operatorsRevokeInviteConfirm',
      desc: '',
      args: [email],
    );
  }

  /// `Modifica ruolo`
  String get operatorsEditRole {
    return Intl.message(
      'Modifica ruolo',
      name: 'operatorsEditRole',
      desc: '',
      args: [],
    );
  }

  /// `Rimuovi operatore`
  String get operatorsRemove {
    return Intl.message(
      'Rimuovi operatore',
      name: 'operatorsRemove',
      desc: '',
      args: [],
    );
  }

  /// `Vuoi rimuovere {name} dal team?`
  String operatorsRemoveConfirm(String name) {
    return Intl.message(
      'Vuoi rimuovere $name dal team?',
      name: 'operatorsRemoveConfirm',
      desc: '',
      args: [name],
    );
  }

  /// `Operatore rimosso`
  String get operatorsRemoveSuccess {
    return Intl.message(
      'Operatore rimosso',
      name: 'operatorsRemoveSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Proprietario`
  String get operatorsRoleOwner {
    return Intl.message(
      'Proprietario',
      name: 'operatorsRoleOwner',
      desc: '',
      args: [],
    );
  }

  /// `Amministratore`
  String get operatorsRoleAdmin {
    return Intl.message(
      'Amministratore',
      name: 'operatorsRoleAdmin',
      desc: '',
      args: [],
    );
  }

  /// `Manager`
  String get operatorsRoleManager {
    return Intl.message(
      'Manager',
      name: 'operatorsRoleManager',
      desc: '',
      args: [],
    );
  }

  /// `Staff`
  String get operatorsRoleStaff {
    return Intl.message(
      'Staff',
      name: 'operatorsRoleStaff',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona il livello di accesso`
  String get operatorsRoleDescription {
    return Intl.message(
      'Seleziona il livello di accesso',
      name: 'operatorsRoleDescription',
      desc: '',
      args: [],
    );
  }

  /// `Tu`
  String get operatorsYou {
    return Intl.message('Tu', name: 'operatorsYou', desc: '', args: []);
  }

  /// `Invitato da {name}`
  String operatorsInvitedBy(String name) {
    return Intl.message(
      'Invitato da $name',
      name: 'operatorsInvitedBy',
      desc: '',
      args: [name],
    );
  }

  /// `Scade il {date}`
  String operatorsExpires(String date) {
    return Intl.message(
      'Scade il $date',
      name: 'operatorsExpires',
      desc: '',
      args: [date],
    );
  }

  /// `Accedi al gestionale`
  String get authLoginSubtitle {
    return Intl.message(
      'Accedi al gestionale',
      name: 'authLoginSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Email`
  String get authEmail {
    return Intl.message('Email', name: 'authEmail', desc: '', args: []);
  }

  /// `Password`
  String get authPassword {
    return Intl.message('Password', name: 'authPassword', desc: '', args: []);
  }

  /// `Accedi`
  String get authLogin {
    return Intl.message('Accedi', name: 'authLogin', desc: '', args: []);
  }

  /// `Esci`
  String get authLogout {
    return Intl.message('Esci', name: 'authLogout', desc: '', args: []);
  }

  /// `Ricordami`
  String get authRememberMe {
    return Intl.message(
      'Ricordami',
      name: 'authRememberMe',
      desc: '',
      args: [],
    );
  }

  /// `Password dimenticata?`
  String get authForgotPassword {
    return Intl.message(
      'Password dimenticata?',
      name: 'authForgotPassword',
      desc: '',
      args: [],
    );
  }

  /// `Contatta l'amministratore di sistema per reimpostare la password.`
  String get authForgotPasswordInfo {
    return Intl.message(
      'Contatta l\'amministratore di sistema per reimpostare la password.',
      name: 'authForgotPasswordInfo',
      desc: '',
      args: [],
    );
  }

  /// `Recupera password`
  String get authResetPasswordTitle {
    return Intl.message(
      'Recupera password',
      name: 'authResetPasswordTitle',
      desc: '',
      args: [],
    );
  }

  /// `Inserisci la tua email. Ti invieremo un link per reimpostare la password.`
  String get authResetPasswordMessage {
    return Intl.message(
      'Inserisci la tua email. Ti invieremo un link per reimpostare la password.',
      name: 'authResetPasswordMessage',
      desc: '',
      args: [],
    );
  }

  /// `Invia`
  String get authResetPasswordSend {
    return Intl.message(
      'Invia',
      name: 'authResetPasswordSend',
      desc: '',
      args: [],
    );
  }

  /// `Se l'email esiste nel sistema, riceverai un link per reimpostare la password.`
  String get authResetPasswordSuccess {
    return Intl.message(
      'Se l\'email esiste nel sistema, riceverai un link per reimpostare la password.',
      name: 'authResetPasswordSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Si √® verificato un errore. Riprova pi√π tardi.`
  String get authResetPasswordError {
    return Intl.message(
      'Si √® verificato un errore. Riprova pi√π tardi.',
      name: 'authResetPasswordError',
      desc: '',
      args: [],
    );
  }

  /// `Campo obbligatorio`
  String get authRequiredField {
    return Intl.message(
      'Campo obbligatorio',
      name: 'authRequiredField',
      desc: '',
      args: [],
    );
  }

  /// `Email non valida`
  String get authInvalidEmail {
    return Intl.message(
      'Email non valida',
      name: 'authInvalidEmail',
      desc: '',
      args: [],
    );
  }

  /// `Password troppo corta`
  String get authPasswordTooShort {
    return Intl.message(
      'Password troppo corta',
      name: 'authPasswordTooShort',
      desc: '',
      args: [],
    );
  }

  /// `Credenziali non valide. Riprova.`
  String get authLoginFailed {
    return Intl.message(
      'Credenziali non valide. Riprova.',
      name: 'authLoginFailed',
      desc: '',
      args: [],
    );
  }

  /// `Accesso riservato agli operatori autorizzati`
  String get authLoginFooter {
    return Intl.message(
      'Accesso riservato agli operatori autorizzati',
      name: 'authLoginFooter',
      desc: '',
      args: [],
    );
  }

  /// `Nome`
  String get authFirstName {
    return Intl.message('Nome', name: 'authFirstName', desc: '', args: []);
  }

  /// `Cognome`
  String get authLastName {
    return Intl.message('Cognome', name: 'authLastName', desc: '', args: []);
  }

  /// `Telefono`
  String get authPhone {
    return Intl.message('Telefono', name: 'authPhone', desc: '', args: []);
  }

  /// `Cambia`
  String get switchBusiness {
    return Intl.message('Cambia', name: 'switchBusiness', desc: '', args: []);
  }

  /// `Profilo`
  String get profileTitle {
    return Intl.message('Profilo', name: 'profileTitle', desc: '', args: []);
  }
}

class AppLocalizationDelegate extends LocalizationsDelegate<L10n> {
  const AppLocalizationDelegate();

  List<Locale> get supportedLocales {
    return const <Locale>[
      Locale.fromSubtags(languageCode: 'it'),
      Locale.fromSubtags(languageCode: 'en'),
    ];
  }

  @override
  bool isSupported(Locale locale) => _isSupported(locale);
  @override
  Future<L10n> load(Locale locale) => L10n.load(locale);
  @override
  bool shouldReload(AppLocalizationDelegate old) => false;

  bool _isSupported(Locale locale) {
    for (var supportedLocale in supportedLocales) {
      if (supportedLocale.languageCode == locale.languageCode) {
        return true;
      }
    }
    return false;
  }
}
--- FILE: lib/core/network/token_storage_mobile.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

import 'token_storage_interface.dart';

/// Implementazione secure storage per mobile/desktop
class SecureTokenStorage implements TokenStorage {
  static const _refreshTokenKey = 'agenda_backend_refresh_token';

  final FlutterSecureStorage _storage;

  SecureTokenStorage()
    : _storage = const FlutterSecureStorage(
        aOptions: AndroidOptions(encryptedSharedPreferences: true),
        iOptions: IOSOptions(accessibility: KeychainAccessibility.first_unlock),
      );

  @override
  Future<String?> getRefreshToken() async {
    try {
      return await _storage.read(key: _refreshTokenKey);
    } catch (e) {
      debugPrint('TokenStorage: Error reading token: $e');
      return null;
    }
  }

  @override
  Future<void> saveRefreshToken(String token) async {
    try {
      await _storage.write(key: _refreshTokenKey, value: token);
    } catch (e) {
      debugPrint('TokenStorage: Error saving token: $e');
    }
  }

  @override
  Future<void> clearRefreshToken() async {
    try {
      await _storage.delete(key: _refreshTokenKey);
    } catch (e) {
      debugPrint('TokenStorage: Error clearing token: $e');
    }
  }
}

/// Factory per creare storage su mobile/desktop
TokenStorage createTokenStorage() => SecureTokenStorage();
--- FILE: lib/core/network/network_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import 'api_client.dart';
import 'token_storage.dart';

part 'network_providers.g.dart';

/// Provider per TokenStorage (singleton)
@Riverpod(keepAlive: true)
TokenStorage tokenStorage(Ref ref) {
  return createTokenStorage();
}

/// Provider per notificare quando la sessione √® scaduta.
/// I listener (es. AuthNotifier) possono reagire a questo evento.
final sessionExpiredProvider = NotifierProvider<SessionExpiredNotifier, int>(
  SessionExpiredNotifier.new,
);

/// Notifier che incrementa un contatore ogni volta che la sessione scade.
/// Gli observer possono fare ref.listen() su questo provider.
class SessionExpiredNotifier extends Notifier<int> {
  @override
  int build() => 0;

  void trigger() {
    state++;
  }
}

/// Provider per ApiClient (singleton)
@Riverpod(keepAlive: true)
ApiClient apiClient(Ref ref) {
  final storage = ref.watch(tokenStorageProvider);
  final sessionExpired = ref.read(sessionExpiredProvider.notifier);

  return ApiClient(
    tokenStorage: storage,
    onSessionExpired: () => sessionExpired.trigger(),
  );
}
--- FILE: lib/core/network/api_config.dart ---
/// Configurazione API per agenda_backend (gestionale)
class ApiConfig {
  /// Base URL dell'API - configurabile via environment
  static const String baseUrl = String.fromEnvironment(
    'API_BASE_URL',
    defaultValue: 'https://api.romeolab.it',
  );

  /// Location ID di default (per MVP single-location)
  static const int defaultLocationId = 1;

  /// Business ID di default
  static const int defaultBusinessId = 1;

  /// Timeout per le richieste
  static const Duration connectTimeout = Duration(seconds: 10);
  static const Duration receiveTimeout = Duration(seconds: 30);

  // ========== AUTH ENDPOINTS ==========
  static const String authLogin = '/v1/auth/login';
  static const String authRegister = '/v1/auth/register';
  static const String authRefresh = '/v1/auth/refresh';
  static const String authLogout = '/v1/auth/logout';
  static const String authForgotPassword = '/v1/auth/forgot-password';
  static const String authVerifyResetToken = '/v1/auth/verify-reset-token';
  static const String authResetPassword = '/v1/auth/reset-password';
  static const String authChangePassword = '/v1/me/change-password';
  static const String authMe = '/v1/me';

  // ========== PUBLIC BROWSE ENDPOINTS ==========
  static const String services = '/v1/services';
  static const String staff = '/v1/staff';
  static const String availability = '/v1/availability';

  // ========== GESTIONALE ENDPOINTS ==========
  static const String clients = '/v1/clients';

  /// Appointments endpoint con location_id nel path
  static String appointments(int locationId) =>
      '/v1/locations/$locationId/appointments';

  /// Singolo appointment endpoint
  static String appointment(int locationId, int appointmentId) =>
      '/v1/locations/$locationId/appointments/$appointmentId';

  /// Cancel appointment endpoint
  static String appointmentCancel(int locationId, int appointmentId) =>
      '/v1/locations/$locationId/appointments/$appointmentId/cancel';

  /// Add item to existing booking endpoint
  static String bookingItems(int bookingId) => '/v1/bookings/$bookingId/items';

  /// Delete item from booking endpoint
  static String bookingItem(int bookingId, int itemId) =>
      '/v1/bookings/$bookingId/items/$itemId';

  /// Bookings endpoint con location_id nel path
  static String bookings(int locationId) =>
      '/v1/locations/$locationId/bookings';

  /// Singolo booking endpoint
  static String booking(int locationId, int bookingId) =>
      '/v1/locations/$locationId/bookings/$bookingId';

  // ========== BUSINESS USERS (OPERATORS) ENDPOINTS ==========

  /// Lista operatori di un business
  static String businessUsers(int businessId) =>
      '/v1/businesses/$businessId/users';

  /// Singolo operatore
  static String businessUser(int businessId, int userId) =>
      '/v1/businesses/$businessId/users/$userId';

  // ========== BUSINESS INVITATIONS ENDPOINTS ==========

  /// Lista inviti pendenti di un business
  static String businessInvitations(int businessId) =>
      '/v1/businesses/$businessId/invitations';

  /// Singolo invito
  static String businessInvitation(int businessId, int invitationId) =>
      '/v1/businesses/$businessId/invitations/$invitationId';

  /// Dettagli invito pubblico (tramite token)
  static String invitationByToken(String token) => '/v1/invitations/$token';

  /// Accetta invito
  static String acceptInvitation(String token) =>
      '/v1/invitations/$token/accept';

  // ========== STAFF SCHEDULES ENDPOINTS ==========

  /// Lista tutti gli schedules degli staff di un business
  static String staffSchedulesAll(int businessId) =>
      '/v1/businesses/$businessId/staff/schedules';

  /// Schedule di uno staff specifico
  static String staffSchedule(int staffId) => '/v1/staff/$staffId/schedules';

  // ========== STAFF PLANNING ENDPOINTS ==========

  /// Lista tutti i planning di uno staff
  static String staffPlannings(int staffId) => '/v1/staff/$staffId/plannings';

  /// Singolo planning
  static String staffPlanning(int planningId) =>
      '/v1/staff/plannings/$planningId';

  /// Planning valido per una data
  static String staffPlanningForDate(int staffId) =>
      '/v1/staff/$staffId/planning';

  /// Slot disponibili per una data
  static String staffPlanningAvailability(int staffId) =>
      '/v1/staff/$staffId/planning-availability';
}
--- FILE: lib/core/network/network_providers.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'network_providers.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning
/// Provider per TokenStorage (singleton)

@ProviderFor(tokenStorage)
const tokenStorageProvider = TokenStorageProvider._();

/// Provider per TokenStorage (singleton)

final class TokenStorageProvider
    extends $FunctionalProvider<TokenStorage, TokenStorage, TokenStorage>
    with $Provider<TokenStorage> {
  /// Provider per TokenStorage (singleton)
  const TokenStorageProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'tokenStorageProvider',
        isAutoDispose: false,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$tokenStorageHash();

  @$internal
  @override
  $ProviderElement<TokenStorage> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  TokenStorage create(Ref ref) {
    return tokenStorage(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(TokenStorage value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<TokenStorage>(value),
    );
  }
}

String _$tokenStorageHash() => r'70b99b5c3abf97860696bdff48269108bd63321a';

/// Provider per ApiClient (singleton)

@ProviderFor(apiClient)
const apiClientProvider = ApiClientProvider._();

/// Provider per ApiClient (singleton)

final class ApiClientProvider
    extends $FunctionalProvider<ApiClient, ApiClient, ApiClient>
    with $Provider<ApiClient> {
  /// Provider per ApiClient (singleton)
  const ApiClientProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'apiClientProvider',
        isAutoDispose: false,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$apiClientHash();

  @$internal
  @override
  $ProviderElement<ApiClient> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  ApiClient create(Ref ref) {
    return apiClient(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(ApiClient value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<ApiClient>(value),
    );
  }
}

String _$apiClientHash() => r'7b32d09fb99a2585f8d2f97e67636976b66059ae';
--- FILE: lib/core/network/token_storage_web.dart ---
// ignore_for_file: avoid_web_libraries_in_flutter
import 'dart:html' as html;

import 'package:flutter/foundation.dart';

import 'token_storage_interface.dart';

/// Implementazione Web che usa localStorage
/// NOTA: In produzione si dovrebbe preferire cookie httpOnly server-side
class WebTokenStorage implements TokenStorage {
  static const _refreshTokenKey = 'agenda_backend_refresh_token';

  @override
  Future<String?> getRefreshToken() async {
    try {
      return html.window.localStorage[_refreshTokenKey];
    } catch (e) {
      debugPrint('TokenStorage: Error reading token from localStorage: $e');
      return null;
    }
  }

  @override
  Future<void> saveRefreshToken(String token) async {
    try {
      html.window.localStorage[_refreshTokenKey] = token;
    } catch (e) {
      debugPrint('TokenStorage: Error saving token to localStorage: $e');
    }
  }

  @override
  Future<void> clearRefreshToken() async {
    try {
      html.window.localStorage.remove(_refreshTokenKey);
    } catch (e) {
      debugPrint('TokenStorage: Error clearing token from localStorage: $e');
    }
  }
}

/// Factory per creare storage su Web
TokenStorage createTokenStorage() => WebTokenStorage();
--- FILE: lib/core/network/token_storage_interface.dart ---
/// Gestione storage per refresh token
/// - Web: localStorage (con considerazioni di sicurezza per production)
/// - Mobile: secure storage
abstract class TokenStorage {
  Future<String?> getRefreshToken();
  Future<void> saveRefreshToken(String token);
  Future<void> clearRefreshToken();
}
--- FILE: lib/core/network/api_client.dart ---
import 'dart:async';

import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';

import 'api_config.dart';
import 'token_storage.dart';

/// Eccezione API custom
class ApiException implements Exception {
  final String code;
  final String message;
  final int statusCode;
  final dynamic details;

  const ApiException({
    required this.code,
    required this.message,
    required this.statusCode,
    this.details,
  });

  bool get isUnauthorized => statusCode == 401;
  bool get isConflict => statusCode == 409;
  bool get isSlotConflict => code == 'slot_conflict';

  @override
  String toString() => 'ApiException($code): $message';
}

/// Client HTTP per comunicare con agenda_core API
/// Usato dal gestionale (agenda_backend)
class ApiClient {
  final Dio _dio;
  final TokenStorage _tokenStorage;
  final void Function()? onSessionExpired;

  String? _accessToken;
  bool _isRefreshing = false;
  final List<void Function()> _pendingRequests = [];

  ApiClient({
    required TokenStorage tokenStorage,
    Dio? dio,
    this.onSessionExpired,
  }) : _tokenStorage = tokenStorage,
       _dio = dio ?? Dio() {
    _dio.options.baseUrl = ApiConfig.baseUrl;
    _dio.options.connectTimeout = ApiConfig.connectTimeout;
    _dio.options.receiveTimeout = ApiConfig.receiveTimeout;
    _dio.options.headers['Content-Type'] = 'application/json';
    _dio.options.headers['Accept'] = 'application/json';

    // Interceptor per logging SOLO errori in debug
    if (kDebugMode) {
      _dio.interceptors.add(
        InterceptorsWrapper(
          onError: (error, handler) {
            debugPrint('*** DioException ***');
            debugPrint('uri: ${error.requestOptions.uri}');
            debugPrint('statusCode: ${error.response?.statusCode}');
            debugPrint('Response: ${error.response?.data}');
            handler.next(error);
          },
        ),
      );
    }

    // Interceptor per auth token
    _dio.interceptors.add(
      InterceptorsWrapper(
        onRequest: (options, handler) {
          if (_accessToken != null) {
            options.headers['Authorization'] = 'Bearer $_accessToken';
          }
          handler.next(options);
        },
        onError: (error, handler) async {
          // Gestione token expired - auto refresh con single-flight
          if (error.response?.statusCode == 401 &&
              error.response?.data?['error']?['code'] == 'token_expired') {
            try {
              final refreshed = await _refreshTokenWithLock();
              if (refreshed) {
                // Riprova la richiesta originale
                final opts = error.requestOptions;
                opts.headers['Authorization'] = 'Bearer $_accessToken';
                final response = await _dio.fetch(opts);
                return handler.resolve(response);
              } else {
                // Refresh fallito, sessione scaduta
                _triggerSessionExpired();
              }
            } catch (_) {
              // Refresh fallito, sessione scaduta
              _triggerSessionExpired();
            }
          }
          // Gestione 401 generico (token invalid, unauthorized)
          else if (error.response?.statusCode == 401) {
            _triggerSessionExpired();
          }
          handler.next(error);
        },
      ),
    );
  }

  /// Notifica che la sessione √® scaduta
  void _triggerSessionExpired() {
    _accessToken = null;
    _tokenStorage.clearRefreshToken();
    if (onSessionExpired != null) {
      onSessionExpired!();
    }
  }

  /// Imposta access token in memoria
  void setAccessToken(String? token) {
    _accessToken = token;
  }

  /// Verifica se autenticato
  bool get isAuthenticated => _accessToken != null;

  /// Tenta refresh del token con lock per evitare refresh concorrenti
  Future<bool> _refreshTokenWithLock() async {
    if (_isRefreshing) {
      // Aspetta che il refresh in corso finisca
      final completer = Completer<void>();
      _pendingRequests.add(completer.complete);
      await completer.future;
      return _accessToken != null;
    }

    _isRefreshing = true;
    try {
      final success = await _refreshToken();
      // Sblocca le richieste in attesa
      for (final callback in _pendingRequests) {
        callback();
      }
      _pendingRequests.clear();
      return success;
    } finally {
      _isRefreshing = false;
    }
  }

  /// Tenta refresh del token
  Future<bool> _refreshToken() async {
    final refreshToken = await _tokenStorage.getRefreshToken();
    if (refreshToken == null) return false;

    try {
      final response = await _dio.post(
        ApiConfig.authRefresh,
        data: {'refresh_token': refreshToken},
      );

      if (response.data['success'] == true) {
        final data = response.data['data'];
        _accessToken = data['access_token'];
        await _tokenStorage.saveRefreshToken(data['refresh_token']);
        return true;
      }
    } catch (_) {
      // Token non valido, pulisci storage
      await _tokenStorage.clearRefreshToken();
    }
    return false;
  }

  /// Tenta di ripristinare sessione da refresh token
  Future<Map<String, dynamic>?> tryRestoreSession() async {
    final refreshToken = await _tokenStorage.getRefreshToken();
    if (refreshToken == null) return null;

    try {
      final response = await _dio.post(
        ApiConfig.authRefresh,
        data: {'refresh_token': refreshToken},
      );

      if (response.data['success'] == true) {
        final data = response.data['data'];
        _accessToken = data['access_token'];
        await _tokenStorage.saveRefreshToken(data['refresh_token']);

        // Fetch user profile
        return await getMe();
      }
    } catch (e) {
      await _tokenStorage.clearRefreshToken();
    }
    return null;
  }

  /// Esegue richiesta GET
  Future<Map<String, dynamic>> get(
    String path, {
    Map<String, dynamic>? queryParameters,
  }) async {
    try {
      final response = await _dio.get(path, queryParameters: queryParameters);
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Esegue richiesta POST
  Future<Map<String, dynamic>> post(
    String path, {
    Map<String, dynamic>? data,
    Map<String, String>? headers,
  }) async {
    try {
      final response = await _dio.post(
        path,
        data: data,
        options: headers != null ? Options(headers: headers) : null,
      );
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Esegue richiesta PUT
  Future<Map<String, dynamic>> put(
    String path, {
    Map<String, dynamic>? data,
  }) async {
    try {
      final response = await _dio.put(path, data: data);
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Esegue richiesta PATCH
  Future<Map<String, dynamic>> patch(
    String path, {
    Map<String, dynamic>? data,
  }) async {
    try {
      final response = await _dio.patch(path, data: data);
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Esegue richiesta DELETE
  Future<Map<String, dynamic>> delete(String path) async {
    try {
      final response = await _dio.delete(path);
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// Gestisce risposta API
  Map<String, dynamic> _handleResponse(Response response) {
    final body = response.data as Map<String, dynamic>;
    if (body['success'] == true) {
      return body['data'] as Map<String, dynamic>? ?? {};
    }
    throw ApiException(
      code: body['error']?['code'] ?? 'unknown_error',
      message: body['error']?['message'] ?? 'Unknown error',
      statusCode: response.statusCode ?? 500,
      details: body['error']?['details'],
    );
  }

  /// Gestisce errori Dio
  ApiException _handleError(DioException error) {
    final response = error.response;
    if (response != null) {
      final body = response.data;
      if (body is Map<String, dynamic>) {
        return ApiException(
          code: body['error']?['code'] ?? 'api_error',
          message: body['error']?['message'] ?? error.message ?? 'API Error',
          statusCode: response.statusCode ?? 500,
          details: body['error']?['details'],
        );
      }
    }
    return ApiException(
      code: 'network_error',
      message: error.message ?? 'Network error',
      statusCode: error.response?.statusCode ?? 0,
    );
  }

  // ========== AUTH ENDPOINTS ==========

  /// POST /v1/auth/login
  Future<Map<String, dynamic>> login(String email, String password) async {
    final data = await post(
      ApiConfig.authLogin,
      data: {'email': email, 'password': password},
    );

    _accessToken = data['access_token'];
    await _tokenStorage.saveRefreshToken(data['refresh_token']);

    return data;
  }

  /// POST /v1/auth/register
  Future<Map<String, dynamic>> register({
    required String email,
    required String password,
    String? firstName,
    String? lastName,
    String? name,
    String? phone,
  }) async {
    final payload = <String, dynamic>{'email': email, 'password': password};
    if (firstName != null) payload['first_name'] = firstName;
    if (lastName != null) payload['last_name'] = lastName;
    if (name != null) payload['name'] = name;
    if (phone != null) payload['phone'] = phone;

    final data = await post(ApiConfig.authRegister, data: payload);

    _accessToken = data['access_token'];
    await _tokenStorage.saveRefreshToken(data['refresh_token']);

    return data;
  }

  /// POST /v1/auth/forgot-password
  Future<void> forgotPassword(String email) async {
    await post(ApiConfig.authForgotPassword, data: {'email': email});
  }

  /// GET /v1/auth/verify-reset-token/{token}
  /// Verifica se un token di reset √® valido prima di mostrare il form.
  Future<void> verifyResetToken(String token) async {
    await get('${ApiConfig.authVerifyResetToken}/$token');
  }

  /// POST /v1/auth/reset-password
  Future<void> resetPassword({
    required String token,
    required String password,
  }) async {
    await post(
      ApiConfig.authResetPassword,
      data: {'token': token, 'password': password},
    );
  }

  /// POST /v1/me/change-password - Cambia password utente autenticato
  Future<void> changePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    await post(
      ApiConfig.authChangePassword,
      data: {'current_password': currentPassword, 'new_password': newPassword},
    );
  }

  /// POST /v1/auth/logout
  Future<void> logout() async {
    final refreshToken = await _tokenStorage.getRefreshToken();
    try {
      await post(ApiConfig.authLogout, data: {'refresh_token': refreshToken});
    } finally {
      _accessToken = null;
      await _tokenStorage.clearRefreshToken();
    }
  }

  /// GET /v1/me
  Future<Map<String, dynamic>> getMe() async {
    return get(ApiConfig.authMe);
  }

  /// PUT /v1/me - Aggiorna profilo utente
  Future<Map<String, dynamic>> updateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
  }) async {
    final data = <String, dynamic>{};
    if (firstName != null) data['first_name'] = firstName;
    if (lastName != null) data['last_name'] = lastName;
    if (email != null) data['email'] = email;
    if (phone != null) data['phone'] = phone;

    return put(ApiConfig.authMe, data: data);
  }

  // ========== PUBLIC BROWSE ENDPOINTS ==========

  /// GET /v1/services?location_id=X
  Future<Map<String, dynamic>> getServices(int locationId) async {
    return get(
      ApiConfig.services,
      queryParameters: {'location_id': locationId},
    );
  }

  /// GET /v1/staff?location_id=X
  Future<Map<String, dynamic>> getStaff(int locationId) async {
    return get(ApiConfig.staff, queryParameters: {'location_id': locationId});
  }

  /// GET /v1/availability
  Future<Map<String, dynamic>> getAvailability({
    required int locationId,
    required String date,
    required List<int> serviceIds,
    int? staffId,
  }) async {
    final params = <String, dynamic>{
      'location_id': locationId,
      'date': date,
      'service_ids': serviceIds.join(','),
    };
    if (staffId != null) {
      params['staff_id'] = staffId;
    }
    return get(ApiConfig.availability, queryParameters: params);
  }

  // ========== GESTIONALE ENDPOINTS ==========

  /// GET /v1/clients?business_id=X
  Future<Map<String, dynamic>> getClients(int businessId) async {
    return get(ApiConfig.clients, queryParameters: {'business_id': businessId});
  }

  /// GET /v1/locations/{location_id}/appointments?date=YYYY-MM-DD
  Future<Map<String, dynamic>> getAppointments({
    required int locationId,
    required String date,
  }) async {
    return get(
      ApiConfig.appointments(locationId),
      queryParameters: {'date': date},
    );
  }

  /// PATCH /v1/locations/{location_id}/appointments/{id}
  Future<Map<String, dynamic>> updateAppointment({
    required int locationId,
    required int appointmentId,
    String? startTime,
    String? endTime,
    int? staffId,
    int? serviceId,
    int? serviceVariantId,
    String? serviceNameSnapshot,
    int? clientId,
    String? clientName,
    String? clientNameSnapshot,
    int? extraBlockedMinutes,
    int? extraProcessingMinutes,
  }) async {
    final data = <String, dynamic>{};
    if (startTime != null) data['start_time'] = startTime;
    if (endTime != null) data['end_time'] = endTime;
    if (staffId != null) data['staff_id'] = staffId;
    if (serviceId != null) data['service_id'] = serviceId;
    if (serviceVariantId != null) data['service_variant_id'] = serviceVariantId;
    if (serviceNameSnapshot != null) {
      data['service_name_snapshot'] = serviceNameSnapshot;
    }
    if (clientId != null) data['client_id'] = clientId;
    if (clientName != null) data['client_name'] = clientName;
    if (clientNameSnapshot != null) {
      data['client_name_snapshot'] = clientNameSnapshot;
    }
    if (extraBlockedMinutes != null) {
      data['extra_blocked_minutes'] = extraBlockedMinutes;
    }
    if (extraProcessingMinutes != null) {
      data['extra_processing_minutes'] = extraProcessingMinutes;
    }

    try {
      final response = await _dio.patch(
        ApiConfig.appointment(locationId, appointmentId),
        data: data,
      );
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// POST /v1/locations/{location_id}/appointments/{id}/cancel
  Future<void> cancelAppointment({
    required int locationId,
    required int appointmentId,
  }) async {
    await post(ApiConfig.appointmentCancel(locationId, appointmentId));
  }

  /// POST /v1/bookings/{booking_id}/items
  /// Add a new booking item (appointment) to an existing booking
  Future<Map<String, dynamic>> addBookingItem({
    required int bookingId,
    required int locationId,
    required int staffId,
    required int serviceId,
    required int serviceVariantId,
    required String startTime,
    required String endTime,
    String? serviceNameSnapshot,
    String? clientNameSnapshot,
    double? price,
    int? extraBlockedMinutes,
    int? extraProcessingMinutes,
  }) async {
    final data = <String, dynamic>{
      'location_id': locationId,
      'staff_id': staffId,
      'service_id': serviceId,
      'service_variant_id': serviceVariantId,
      'start_time': startTime,
      'end_time': endTime,
    };
    if (serviceNameSnapshot != null) {
      data['service_name_snapshot'] = serviceNameSnapshot;
    }
    if (clientNameSnapshot != null) {
      data['client_name_snapshot'] = clientNameSnapshot;
    }
    if (price != null) data['price'] = price;
    if (extraBlockedMinutes != null) {
      data['extra_blocked_minutes'] = extraBlockedMinutes;
    }
    if (extraProcessingMinutes != null) {
      data['extra_processing_minutes'] = extraProcessingMinutes;
    }

    try {
      final response = await _dio.post(
        ApiConfig.bookingItems(bookingId),
        data: data,
      );
      return _handleResponse(response);
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// DELETE /v1/bookings/{booking_id}/items/{item_id}
  /// Delete a single booking item (appointment) from a booking
  Future<void> deleteBookingItem({
    required int bookingId,
    required int itemId,
  }) async {
    try {
      await _dio.delete(ApiConfig.bookingItem(bookingId, itemId));
    } on DioException catch (e) {
      throw _handleError(e);
    }
  }

  /// GET /v1/locations/{location_id}/bookings?date=YYYY-MM-DD
  Future<Map<String, dynamic>> getBookings({
    required int locationId,
    required String date,
    int? staffId,
  }) async {
    final params = <String, dynamic>{'date': date};
    if (staffId != null) {
      params['staff_id'] = staffId;
    }
    return get(ApiConfig.bookings(locationId), queryParameters: params);
  }

  /// GET /v1/locations/{location_id}/bookings/{booking_id}
  Future<Map<String, dynamic>> getBooking({
    required int locationId,
    required int bookingId,
  }) async {
    return get(ApiConfig.booking(locationId, bookingId));
  }

  /// POST /v1/locations/{location_id}/bookings
  Future<Map<String, dynamic>> createBooking({
    required int locationId,
    required String idempotencyKey,
    required List<int> serviceIds,
    required String startTime,
    int? staffId,
    int? clientId,
    String? notes,
  }) async {
    final data = <String, dynamic>{
      'service_ids': serviceIds,
      'start_time': startTime,
    };
    if (staffId != null) {
      data['staff_id'] = staffId;
    }
    if (clientId != null) {
      data['client_id'] = clientId;
    }
    if (notes != null && notes.isNotEmpty) {
      data['notes'] = notes;
    }

    return post(
      ApiConfig.bookings(locationId),
      data: data,
      headers: {'X-Idempotency-Key': idempotencyKey},
    );
  }

  /// POST /v1/locations/{location_id}/bookings (new items format)
  Future<Map<String, dynamic>> createBookingWithItems({
    required int locationId,
    required String idempotencyKey,
    required List<Map<String, dynamic>> items,
    int? clientId,
    String? notes,
  }) async {
    final data = <String, dynamic>{'items': items};
    if (clientId != null) {
      data['client_id'] = clientId;
    }
    if (notes != null && notes.isNotEmpty) {
      data['notes'] = notes;
    }

    return post(
      ApiConfig.bookings(locationId),
      data: data,
      headers: {'X-Idempotency-Key': idempotencyKey},
    );
  }

  /// PUT /v1/locations/{location_id}/bookings/{booking_id}
  Future<Map<String, dynamic>> updateBooking({
    required int locationId,
    required int bookingId,
    String? status,
    String? notes,
    int? clientId,
    bool clearClient = false,
  }) async {
    final data = <String, dynamic>{};
    if (status != null) {
      data['status'] = status;
    }
    if (notes != null) {
      data['notes'] = notes;
    }
    // clearClient: invia client_id: null per rimuovere il cliente
    // clientId: invia client_id: valore per assegnare un cliente
    if (clearClient) {
      data['client_id'] = null;
    } else if (clientId != null) {
      data['client_id'] = clientId;
    }
    return put(ApiConfig.booking(locationId, bookingId), data: data);
  }

  /// DELETE /v1/locations/{location_id}/bookings/{booking_id}
  Future<void> deleteBooking({
    required int locationId,
    required int bookingId,
  }) async {
    await delete(ApiConfig.booking(locationId, bookingId));
  }

  /// GET /v1/businesses
  Future<List<Map<String, dynamic>>> getBusinesses() async {
    final response = await get('/v1/businesses');
    // API ritorna { data: { data: [...] } } per lista business
    final data = response['data'];
    if (data is List) {
      return data.cast<Map<String, dynamic>>();
    }
    // Se √® un oggetto con chiave 'data' o 'businesses'
    if (data is Map) {
      final list = data['data'] ?? data['businesses'] ?? [];
      return (list as List).cast<Map<String, dynamic>>();
    }
    return [];
  }

  /// GET /v1/admin/businesses
  /// Superadmin only: lista tutti i business.
  Future<List<Map<String, dynamic>>> getAdminBusinesses({
    String? search,
  }) async {
    final queryParameters = <String, dynamic>{};
    if (search != null && search.isNotEmpty) {
      queryParameters['search'] = search;
    }
    final response = await get(
      '/v1/admin/businesses',
      queryParameters: queryParameters.isNotEmpty ? queryParameters : null,
    );
    // _handleResponse ritorna body['data'], quindi response = { businesses: [...], pagination: {...} }
    return (response['businesses'] as List).cast<Map<String, dynamic>>();
  }

  /// POST /v1/admin/businesses
  /// Superadmin only: crea un nuovo business.
  /// Se adminEmail fornito, invia email di benvenuto all'admin con link per impostare password.
  Future<Map<String, dynamic>> createAdminBusiness({
    required String name,
    required String slug,
    String? adminEmail,
    String? email,
    String? phone,
    String timezone = 'Europe/Rome',
    String currency = 'EUR',
    String? adminFirstName,
    String? adminLastName,
  }) async {
    final response = await post(
      '/v1/admin/businesses',
      data: {
        'name': name,
        'slug': slug,
        if (adminEmail != null && adminEmail.isNotEmpty)
          'admin_email': adminEmail,
        if (email != null) 'email': email,
        if (phone != null) 'phone': phone,
        'timezone': timezone,
        'currency': currency,
        if (adminFirstName != null) 'admin_first_name': adminFirstName,
        if (adminLastName != null) 'admin_last_name': adminLastName,
      },
    );
    // _handleResponse gi√† ritorna body['data'], quindi response √à il business
    return response;
  }

  /// PUT /v1/admin/businesses/{id}
  /// Superadmin only: aggiorna un business esistente.
  /// Se adminEmail cambia, trasferisce ownership e invia email al nuovo admin.
  Future<Map<String, dynamic>> updateAdminBusiness({
    required int businessId,
    String? name,
    String? slug,
    String? email,
    String? phone,
    String? timezone,
    String? currency,
    String? adminEmail,
  }) async {
    final response = await put(
      '/v1/admin/businesses/$businessId',
      data: {
        if (name != null) 'name': name,
        if (slug != null) 'slug': slug,
        if (email != null) 'email': email,
        if (phone != null) 'phone': phone,
        if (timezone != null) 'timezone': timezone,
        if (currency != null) 'currency': currency,
        if (adminEmail != null) 'admin_email': adminEmail,
      },
    );
    return response;
  }

  /// POST /v1/admin/businesses/{id}/resend-invite
  /// Superadmin only: reinvia email di invito all'admin.
  Future<void> resendAdminInvite(int businessId) async {
    await post('/v1/admin/businesses/$businessId/resend-invite');
  }

  /// PUT /v1/admin/businesses/{id}/suspend
  /// Superadmin only: sospende un business con messaggio opzionale.
  Future<Map<String, dynamic>> suspendBusiness({
    required int businessId,
    required bool isSuspended,
    String? suspensionMessage,
  }) async {
    final response = await put(
      '/v1/admin/businesses/$businessId',
      data: {
        'is_suspended': isSuspended,
        if (suspensionMessage != null) 'suspension_message': suspensionMessage,
        if (!isSuspended) 'suspension_message': null,
      },
    );
    return response;
  }

  /// DELETE /v1/admin/businesses/{id}
  /// Superadmin only: soft-delete un business (is_active = 0).
  Future<void> deleteAdminBusiness(int businessId) async {
    await delete('/v1/admin/businesses/$businessId');
  }

  // ========== LOCATIONS CRUD ==========

  /// GET /v1/businesses/{business_id}/locations
  Future<List<Map<String, dynamic>>> getLocations(int businessId) async {
    final response = await get('/v1/businesses/$businessId/locations');
    return (response['data'] as List).cast<Map<String, dynamic>>();
  }

  /// POST /v1/businesses/{business_id}/locations
  Future<Map<String, dynamic>> createLocation({
    required int businessId,
    required String name,
    String? address,
    String? phone,
    String? email,
    String? timezone,
    bool? isActive,
  }) async {
    final response = await post(
      '/v1/businesses/$businessId/locations',
      data: {
        'name': name,
        if (address != null && address.isNotEmpty) 'address': address,
        if (phone != null && phone.isNotEmpty) 'phone': phone,
        if (email != null && email.isNotEmpty) 'email': email,
        if (timezone != null && timezone.isNotEmpty) 'timezone': timezone,
        if (isActive != null) 'is_active': isActive,
      },
    );
    return response['location'] as Map<String, dynamic>;
  }

  /// PUT /v1/locations/{id}
  Future<Map<String, dynamic>> updateLocation({
    required int locationId,
    String? name,
    String? address,
    String? phone,
    String? email,
    String? timezone,
    bool? isActive,
  }) async {
    final response = await put(
      '/v1/locations/$locationId',
      data: {
        if (name != null) 'name': name,
        if (address != null) 'address': address,
        if (phone != null) 'phone': phone,
        if (email != null) 'email': email,
        if (timezone != null) 'timezone': timezone,
        if (isActive != null) 'is_active': isActive,
      },
    );
    return response['location'] as Map<String, dynamic>;
  }

  /// DELETE /v1/locations/{id}
  Future<void> deleteLocation(int locationId) async {
    await delete('/v1/locations/$locationId');
  }

  /// POST /v1/locations/reorder - Batch update locations sort_order
  Future<Map<String, dynamic>> reorderLocations({
    required List<Map<String, dynamic>> locations,
  }) async {
    return post('/v1/locations/reorder', data: {'locations': locations});
  }

  // ========== SERVICES CRUD ==========

  /// POST /v1/locations/{location_id}/services
  Future<Map<String, dynamic>> createService({
    required int locationId,
    required String name,
    int? categoryId,
    String? description,
    int durationMinutes = 30,
    double price = 0,
    String? colorHex,
    bool isBookableOnline = true,
    bool isPriceStartingFrom = false,
  }) async {
    final response = await post(
      '/v1/locations/$locationId/services',
      data: {
        'name': name,
        if (categoryId != null) 'category_id': categoryId,
        if (description != null && description.isNotEmpty)
          'description': description,
        'duration_minutes': durationMinutes,
        'price': price,
        if (colorHex != null && colorHex.isNotEmpty) 'color': colorHex,
        'is_bookable_online': isBookableOnline,
        'is_price_starting_from': isPriceStartingFrom,
      },
    );
    return response;
  }

  /// PUT /v1/services/{id}
  Future<Map<String, dynamic>> updateService({
    required int serviceId,
    required int locationId,
    String? name,
    int? categoryId,
    bool setCategoryIdNull = false,
    String? description,
    int? durationMinutes,
    double? price,
    String? colorHex,
    bool? isBookableOnline,
    bool? isPriceStartingFrom,
    int? sortOrder,
  }) async {
    final response = await put(
      '/v1/services/$serviceId',
      data: {
        'location_id': locationId,
        if (name != null) 'name': name,
        if (setCategoryIdNull)
          'category_id': null
        else if (categoryId != null)
          'category_id': categoryId,
        if (description != null) 'description': description,
        if (durationMinutes != null) 'duration_minutes': durationMinutes,
        if (price != null) 'price': price,
        if (colorHex != null) 'color': colorHex,
        if (isBookableOnline != null) 'is_bookable_online': isBookableOnline,
        if (isPriceStartingFrom != null)
          'is_price_starting_from': isPriceStartingFrom,
        if (sortOrder != null) 'sort_order': sortOrder,
      },
    );
    return response;
  }

  /// DELETE /v1/services/{id}
  Future<void> deleteService(int serviceId) async {
    await delete('/v1/services/$serviceId');
  }

  // ========== SERVICE CATEGORIES CRUD ==========

  /// GET /v1/businesses/{business_id}/categories
  Future<Map<String, dynamic>> getServiceCategories(int businessId) async {
    return get('/v1/businesses/$businessId/categories');
  }

  /// POST /v1/businesses/{business_id}/categories
  Future<Map<String, dynamic>> createServiceCategory({
    required int businessId,
    required String name,
    String? description,
  }) async {
    return post(
      '/v1/businesses/$businessId/categories',
      data: {
        'name': name,
        if (description != null && description.isNotEmpty)
          'description': description,
      },
    );
  }

  /// PUT /v1/categories/{id}
  Future<Map<String, dynamic>> updateServiceCategory({
    required int categoryId,
    String? name,
    String? description,
    int? sortOrder,
  }) async {
    return put(
      '/v1/categories/$categoryId',
      data: {
        if (name != null) 'name': name,
        if (description != null) 'description': description,
        if (sortOrder != null) 'sort_order': sortOrder,
      },
    );
  }

  /// DELETE /v1/categories/{id}
  Future<void> deleteServiceCategory(int categoryId) async {
    await delete('/v1/categories/$categoryId');
  }

  /// POST /v1/services/reorder - Batch update services sort_order and category_id
  Future<Map<String, dynamic>> reorderServices({
    required List<Map<String, dynamic>> services,
  }) async {
    return post('/v1/services/reorder', data: {'services': services});
  }

  /// POST /v1/categories/reorder - Batch update categories sort_order
  Future<Map<String, dynamic>> reorderCategories({
    required List<Map<String, dynamic>> categories,
  }) async {
    return post('/v1/categories/reorder', data: {'categories': categories});
  }

  // ========== STAFF CRUD ==========

  /// GET /v1/businesses/{business_id}/staff
  Future<List<Map<String, dynamic>>> getStaffByBusiness(int businessId) async {
    final response = await get('/v1/businesses/$businessId/staff');
    return (response['staff'] as List).cast<Map<String, dynamic>>();
  }

  /// POST /v1/businesses/{business_id}/staff
  Future<Map<String, dynamic>> createStaff({
    required int businessId,
    required String name,
    String? surname,
    String? colorHex,
    String? avatarUrl,
    bool? isBookableOnline,
    List<int>? locationIds,
    List<int>? serviceIds,
  }) async {
    final response = await post(
      '/v1/businesses/$businessId/staff',
      data: {
        'name': name,
        if (surname != null && surname.isNotEmpty) 'surname': surname,
        if (colorHex != null) 'color_hex': colorHex,
        if (avatarUrl != null) 'avatar_url': avatarUrl,
        if (isBookableOnline != null) 'is_bookable_online': isBookableOnline,
        if (locationIds != null && locationIds.isNotEmpty)
          'location_ids': locationIds,
        if (serviceIds != null) 'service_ids': serviceIds,
      },
    );
    return response['staff'] as Map<String, dynamic>;
  }

  /// PUT /v1/staff/{id}
  Future<Map<String, dynamic>> updateStaff({
    required int staffId,
    String? name,
    String? surname,
    String? colorHex,
    String? avatarUrl,
    bool? isBookableOnline,
    int? sortOrder,
    List<int>? locationIds,
    List<int>? serviceIds,
  }) async {
    final response = await put(
      '/v1/staff/$staffId',
      data: {
        if (name != null) 'name': name,
        if (surname != null) 'surname': surname,
        if (colorHex != null) 'color_hex': colorHex,
        if (avatarUrl != null) 'avatar_url': avatarUrl,
        if (isBookableOnline != null) 'is_bookable_online': isBookableOnline,
        if (sortOrder != null) 'sort_order': sortOrder,
        if (locationIds != null) 'location_ids': locationIds,
        if (serviceIds != null) 'service_ids': serviceIds,
      },
    );
    return response['staff'] as Map<String, dynamic>;
  }

  /// DELETE /v1/staff/{id}
  Future<void> deleteStaff(int staffId) async {
    await delete('/v1/staff/$staffId');
  }

  /// POST /v1/staff/reorder - Batch update staff sort_order
  Future<Map<String, dynamic>> reorderStaff({
    required List<Map<String, dynamic>> staff,
  }) async {
    return post('/v1/staff/reorder', data: {'staff': staff});
  }

  // ========== BUSINESS USERS (OPERATORS) ==========

  /// GET /v1/businesses/{business_id}/users
  /// Lista operatori di un business.
  Future<List<Map<String, dynamic>>> getBusinessUsers(int businessId) async {
    final response = await get(ApiConfig.businessUsers(businessId));
    return (response['data']['users'] as List).cast<Map<String, dynamic>>();
  }

  /// POST /v1/businesses/{business_id}/users
  /// Aggiunge un utente esistente al business.
  Future<Map<String, dynamic>> addBusinessUser({
    required int businessId,
    required int userId,
    required String role,
  }) async {
    final response = await post(
      ApiConfig.businessUsers(businessId),
      data: {'user_id': userId, 'role': role},
    );
    return response['data'] as Map<String, dynamic>;
  }

  /// PATCH /v1/businesses/{business_id}/users/{user_id}
  /// Aggiorna il ruolo di un operatore.
  Future<Map<String, dynamic>> updateBusinessUser({
    required int businessId,
    required int userId,
    required String role,
  }) async {
    final response = await patch(
      ApiConfig.businessUser(businessId, userId),
      data: {'role': role},
    );
    return response['data'] as Map<String, dynamic>;
  }

  /// DELETE /v1/businesses/{business_id}/users/{user_id}
  /// Rimuove un operatore dal business.
  Future<void> removeBusinessUser({
    required int businessId,
    required int userId,
  }) async {
    await delete(ApiConfig.businessUser(businessId, userId));
  }

  // ========== BUSINESS INVITATIONS ==========

  /// GET /v1/businesses/{business_id}/invitations
  /// Lista inviti pendenti.
  Future<List<Map<String, dynamic>>> getBusinessInvitations(
    int businessId,
  ) async {
    final response = await get(ApiConfig.businessInvitations(businessId));
    return (response['data']['invitations'] as List)
        .cast<Map<String, dynamic>>();
  }

  /// POST /v1/businesses/{business_id}/invitations
  /// Crea un nuovo invito via email.
  Future<Map<String, dynamic>> createBusinessInvitation({
    required int businessId,
    required String email,
    required String role,
  }) async {
    final response = await post(
      ApiConfig.businessInvitations(businessId),
      data: {'email': email, 'role': role},
    );
    return response['data'] as Map<String, dynamic>;
  }

  /// DELETE /v1/businesses/{business_id}/invitations/{invitation_id}
  /// Revoca un invito pendente.
  Future<void> revokeBusinessInvitation({
    required int businessId,
    required int invitationId,
  }) async {
    await delete(ApiConfig.businessInvitation(businessId, invitationId));
  }

  /// GET /v1/invitations/{token}
  /// Dettagli di un invito (endpoint pubblico).
  Future<Map<String, dynamic>> getInvitationByToken(String token) async {
    final response = await get(ApiConfig.invitationByToken(token));
    return response['data'] as Map<String, dynamic>;
  }

  /// POST /v1/invitations/{token}/accept
  /// Accetta un invito (richiede autenticazione).
  Future<Map<String, dynamic>> acceptInvitation(String token) async {
    final response = await post(ApiConfig.acceptInvitation(token));
    return response['data'] as Map<String, dynamic>;
  }

  // ========== STAFF SCHEDULES ==========

  /// GET /v1/businesses/{business_id}/staff/schedules
  /// Ottiene gli schedules di tutti gli staff di un business.
  /// Ritorna `Map<int, Map<int, List<Map>>>` (staffId -> day -> shifts)
  Future<Map<int, Map<int, List<Map<String, String>>>>> getStaffSchedulesAll(
    int businessId,
  ) async {
    final response = await get(ApiConfig.staffSchedulesAll(businessId));
    // _handleResponse gi√† ritorna body['data'], quindi response = { schedules: {...} }
    final data = response['schedules'] as Map<String, dynamic>;

    final Map<int, Map<int, List<Map<String, String>>>> result = {};
    for (final entry in data.entries) {
      final staffId = int.parse(entry.key);
      final weekData = entry.value as Map<String, dynamic>;

      result[staffId] = {};
      for (final dayEntry in weekData.entries) {
        final day = int.parse(dayEntry.key);
        final shifts = (dayEntry.value as List)
            .map(
              (s) => {
                'start_time': s['start_time'] as String,
                'end_time': s['end_time'] as String,
              },
            )
            .toList();
        result[staffId]![day] = shifts;
      }
    }
    return result;
  }

  /// GET /v1/staff/{id}/schedules
  /// Ottiene lo schedule settimanale di uno staff.
  /// Ritorna `Map<int, List<Map>>` (day -> shifts)
  Future<Map<int, List<Map<String, String>>>> getStaffSchedule(
    int staffId,
  ) async {
    final response = await get(ApiConfig.staffSchedule(staffId));
    // _handleResponse gi√† ritorna body['data'], quindi response = { staff_id: X, schedule: {...} }
    final data = response['schedule'] as Map<String, dynamic>;

    final Map<int, List<Map<String, String>>> result = {};
    for (final entry in data.entries) {
      final day = int.parse(entry.key);
      final shifts = (entry.value as List)
          .map(
            (s) => {
              'start_time': s['start_time'] as String,
              'end_time': s['end_time'] as String,
            },
          )
          .toList();
      result[day] = shifts;
    }
    return result;
  }

  /// PUT /v1/staff/{id}/schedules
  /// Salva lo schedule settimanale di uno staff (sostituisce l'esistente).
  Future<Map<int, List<Map<String, String>>>> saveStaffSchedule({
    required int staffId,
    required Map<int, List<Map<String, String>>> schedule,
  }) async {
    // Converti keys da int a String per JSON
    final scheduleJson = <String, dynamic>{};
    for (final entry in schedule.entries) {
      scheduleJson[entry.key.toString()] = entry.value;
    }

    final response = await put(
      ApiConfig.staffSchedule(staffId),
      data: {'schedule': scheduleJson},
    );

    // _handleResponse gi√† ritorna body['data'], quindi response = { staff_id: X, schedule: {...} }
    final data = response['schedule'] as Map<String, dynamic>;
    final Map<int, List<Map<String, String>>> result = {};
    for (final entry in data.entries) {
      final day = int.parse(entry.key);
      final shifts = (entry.value as List)
          .map(
            (s) => {
              'start_time': s['start_time'] as String,
              'end_time': s['end_time'] as String,
            },
          )
          .toList();
      result[day] = shifts;
    }
    return result;
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Staff Availability Exceptions
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Get all availability exceptions for all staff in a business
  /// GET /v1/businesses/{businessId}/staff/availability-exceptions
  Future<Map<int, List<Map<String, dynamic>>>>
  getStaffAvailabilityExceptionsAll(
    int businessId, {
    String? fromDate,
    String? toDate,
  }) async {
    final queryParams = <String, String>{};
    if (fromDate != null) queryParams['from_date'] = fromDate;
    if (toDate != null) queryParams['to_date'] = toDate;

    final response = await get(
      '/v1/businesses/$businessId/staff/availability-exceptions',
      queryParameters: queryParams,
    );

    // response = { exceptions: { staffId: [...], ... } }
    final exceptionsMap = response['exceptions'] as Map<String, dynamic>;
    final Map<int, List<Map<String, dynamic>>> result = {};

    for (final entry in exceptionsMap.entries) {
      final staffId = int.parse(entry.key);
      final exceptionsList = (entry.value as List)
          .map((e) => Map<String, dynamic>.from(e as Map))
          .toList();
      result[staffId] = exceptionsList;
    }

    return result;
  }

  /// Get availability exceptions for a single staff member
  /// GET /v1/staff/{staffId}/availability-exceptions
  Future<List<Map<String, dynamic>>> getStaffAvailabilityExceptions(
    int staffId, {
    String? fromDate,
    String? toDate,
  }) async {
    final queryParams = <String, String>{};
    if (fromDate != null) queryParams['from_date'] = fromDate;
    if (toDate != null) queryParams['to_date'] = toDate;

    final response = await get(
      '/v1/staff/$staffId/availability-exceptions',
      queryParameters: queryParams,
    );

    // response = { staff_id: X, exceptions: [...] }
    final exceptions = (response['exceptions'] as List)
        .map((e) => Map<String, dynamic>.from(e as Map))
        .toList();
    return exceptions;
  }

  /// Create a new availability exception for a staff member
  /// POST /v1/staff/{staffId}/availability-exceptions
  Future<Map<String, dynamic>> createStaffAvailabilityException({
    required int staffId,
    required String date,
    String? startTime,
    String? endTime,
    String type = 'unavailable',
    String? reasonCode,
    String? reason,
  }) async {
    final data = <String, dynamic>{'date': date, 'type': type};
    if (startTime != null) data['start_time'] = startTime;
    if (endTime != null) data['end_time'] = endTime;
    if (reasonCode != null) data['reason_code'] = reasonCode;
    if (reason != null) data['reason'] = reason;

    final response = await post(
      '/v1/staff/$staffId/availability-exceptions',
      data: data,
    );

    // response = { exception: {...} }
    return Map<String, dynamic>.from(response['exception'] as Map);
  }

  /// Update an existing availability exception
  /// PUT /v1/staff/availability-exceptions/{exceptionId}
  Future<Map<String, dynamic>> updateStaffAvailabilityException({
    required int exceptionId,
    String? date,
    String? startTime,
    String? endTime,
    String? type,
    String? reasonCode,
    String? reason,
  }) async {
    final data = <String, dynamic>{};
    if (date != null) data['date'] = date;
    if (startTime != null) data['start_time'] = startTime;
    if (endTime != null) data['end_time'] = endTime;
    if (type != null) data['type'] = type;
    if (reasonCode != null) data['reason_code'] = reasonCode;
    if (reason != null) data['reason'] = reason;

    final response = await put(
      '/v1/staff/availability-exceptions/$exceptionId',
      data: data,
    );

    // response = { exception: {...} }
    return Map<String, dynamic>.from(response['exception'] as Map);
  }

  /// Delete an availability exception
  /// DELETE /v1/staff/availability-exceptions/{exceptionId}
  Future<void> deleteStaffAvailabilityException(int exceptionId) async {
    await delete('/v1/staff/availability-exceptions/$exceptionId');
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Resources
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Get all resources for a business
  /// GET /v1/businesses/{businessId}/resources
  Future<List<Map<String, dynamic>>> getResourcesByBusiness(
    int businessId,
  ) async {
    final response = await get('/v1/businesses/$businessId/resources');
    return (response['resources'] as List)
        .map((r) => Map<String, dynamic>.from(r as Map))
        .toList();
  }

  /// Get resources for a location
  /// GET /v1/locations/{locationId}/resources
  Future<List<Map<String, dynamic>>> getResourcesByLocation(
    int locationId,
  ) async {
    final response = await get('/v1/locations/$locationId/resources');
    return (response['resources'] as List)
        .map((r) => Map<String, dynamic>.from(r as Map))
        .toList();
  }

  /// Create a new resource
  /// POST /v1/locations/{locationId}/resources
  Future<Map<String, dynamic>> createResource({
    required int locationId,
    required String name,
    String? type,
    int quantity = 1,
    String? note,
    int sortOrder = 0,
  }) async {
    final response = await post(
      '/v1/locations/$locationId/resources',
      data: {
        'name': name,
        if (type != null) 'type': type,
        'quantity': quantity,
        if (note != null) 'note': note,
        'sort_order': sortOrder,
      },
    );
    return Map<String, dynamic>.from(response['resource'] as Map);
  }

  /// Update a resource
  /// PUT /v1/resources/{resourceId}
  Future<Map<String, dynamic>> updateResource({
    required int resourceId,
    String? name,
    String? type,
    int? quantity,
    String? note,
    int? sortOrder,
  }) async {
    final data = <String, dynamic>{};
    if (name != null) data['name'] = name;
    if (type != null) data['type'] = type;
    if (quantity != null) data['quantity'] = quantity;
    if (note != null) data['note'] = note;
    if (sortOrder != null) data['sort_order'] = sortOrder;

    final response = await put('/v1/resources/$resourceId', data: data);
    return Map<String, dynamic>.from(response['resource'] as Map);
  }

  /// Delete a resource
  /// DELETE /v1/resources/{resourceId}
  Future<void> deleteResource(int resourceId) async {
    await delete('/v1/resources/$resourceId');
  }

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Time Blocks
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Get time blocks for a location in a date range
  /// GET /v1/locations/{locationId}/time-blocks
  Future<List<Map<String, dynamic>>> getTimeBlocks(
    int locationId, {
    String? fromDate,
    String? toDate,
  }) async {
    final queryParams = <String, String>{};
    if (fromDate != null) queryParams['from_date'] = fromDate;
    if (toDate != null) queryParams['to_date'] = toDate;

    final response = await get(
      '/v1/locations/$locationId/time-blocks',
      queryParameters: queryParams,
    );
    return (response['time_blocks'] as List)
        .map((b) => Map<String, dynamic>.from(b as Map))
        .toList();
  }

  /// Create a new time block
  /// POST /v1/locations/{locationId}/time-blocks
  Future<Map<String, dynamic>> createTimeBlock({
    required int locationId,
    required String startTime,
    required String endTime,
    required List<int> staffIds,
    bool isAllDay = false,
    String? reason,
  }) async {
    final response = await post(
      '/v1/locations/$locationId/time-blocks',
      data: {
        'start_time': startTime,
        'end_time': endTime,
        'staff_ids': staffIds,
        'is_all_day': isAllDay,
        if (reason != null) 'reason': reason,
      },
    );
    return Map<String, dynamic>.from(response['time_block'] as Map);
  }

  /// Update a time block
  /// PUT /v1/time-blocks/{blockId}
  Future<Map<String, dynamic>> updateTimeBlock({
    required int blockId,
    String? startTime,
    String? endTime,
    List<int>? staffIds,
    bool? isAllDay,
    String? reason,
  }) async {
    final data = <String, dynamic>{};
    if (startTime != null) data['start_time'] = startTime;
    if (endTime != null) data['end_time'] = endTime;
    if (staffIds != null) data['staff_ids'] = staffIds;
    if (isAllDay != null) data['is_all_day'] = isAllDay;
    if (reason != null) data['reason'] = reason;

    final response = await put('/v1/time-blocks/$blockId', data: data);
    return Map<String, dynamic>.from(response['time_block'] as Map);
  }

  /// Delete a time block
  /// DELETE /v1/time-blocks/{blockId}
  Future<void> deleteTimeBlock(int blockId) async {
    await delete('/v1/time-blocks/$blockId');
  }

  // ========== STAFF PLANNING ENDPOINTS ==========

  /// Get all plannings for a staff member
  /// GET /v1/staff/{staffId}/plannings
  Future<List<Map<String, dynamic>>> getStaffPlannings(int staffId) async {
    final response = await get(ApiConfig.staffPlannings(staffId));
    final plannings = response['plannings'] as List<dynamic>? ?? [];
    return plannings.cast<Map<String, dynamic>>();
  }

  /// Get planning valid for a specific date
  /// GET /v1/staff/{staffId}/planning?date=YYYY-MM-DD
  Future<Map<String, dynamic>?> getStaffPlanningForDate({
    required int staffId,
    required String date,
  }) async {
    final response = await get(
      ApiConfig.staffPlanningForDate(staffId),
      queryParameters: {'date': date},
    );
    return response['planning'] as Map<String, dynamic>?;
  }

  /// Get available slots for a staff on a date
  /// GET /v1/staff/{staffId}/planning-availability?date=YYYY-MM-DD
  Future<List<int>> getStaffPlanningAvailability({
    required int staffId,
    required String date,
  }) async {
    final response = await get(
      ApiConfig.staffPlanningAvailability(staffId),
      queryParameters: {'date': date},
    );
    final slots = response['slots'] as List<dynamic>? ?? [];
    return slots.cast<int>();
  }

  /// Create a new staff planning
  /// POST /v1/staff/{staffId}/plannings
  Future<Map<String, dynamic>> createStaffPlanning({
    required int staffId,
    required String type,
    required String validFrom,
    String? validTo,
    required List<Map<String, dynamic>> templates,
  }) async {
    final response = await post(
      ApiConfig.staffPlannings(staffId),
      data: {
        'type': type,
        'valid_from': validFrom,
        if (validTo != null) 'valid_to': validTo,
        'templates': templates,
      },
    );
    return Map<String, dynamic>.from(response['planning'] as Map);
  }

  /// Update an existing staff planning
  /// PUT /v1/staff/plannings/{planningId}
  Future<Map<String, dynamic>> updateStaffPlanning({
    required int planningId,
    String? type,
    String? validFrom,
    String? validTo,
    List<Map<String, dynamic>>? templates,
  }) async {
    final data = <String, dynamic>{};
    if (type != null) data['type'] = type;
    if (validFrom != null) data['valid_from'] = validFrom;
    if (validTo != null) data['valid_to'] = validTo;
    if (templates != null) data['templates'] = templates;

    final response = await put(ApiConfig.staffPlanning(planningId), data: data);
    return Map<String, dynamic>.from(response['planning'] as Map);
  }

  /// Delete a staff planning
  /// DELETE /v1/staff/plannings/{planningId}
  Future<void> deleteStaffPlanning(int planningId) async {
    await delete(ApiConfig.staffPlanning(planningId));
  }
}
--- FILE: lib/core/network/token_storage.dart ---
export 'token_storage_interface.dart';
// Conditional import: web vs mobile/desktop
export 'token_storage_mobile.dart'
    if (dart.library.html) 'token_storage_web.dart';
--- FILE: lib/core/utils/color_utils.dart ---
import 'package:flutter/material.dart';

class ColorUtils {
  /// Restituisce il colore in formato esadecimale '#RRGGBB' (senza alpha)
  static String toHex(Color color) {
    final int argb = color.toARGB32();
    // Prendi solo gli ultimi 6 caratteri (RGB, ignora alpha)
    return '#${argb.toRadixString(16).padLeft(8, '0').substring(2).toUpperCase()}';
  }

  /// Converte una stringa esadecimale '#AARRGGBB' o '#RRGGBB' in un Color
  static Color fromHex(String hexString) {
    final buffer = StringBuffer();
    // Se 6 caratteri (o 7 con #), aggiungi alpha FF
    if (hexString.length == 6 || hexString.length == 7) buffer.write('FF');
    buffer.write(hexString.replaceFirst('#', ''));
    return Color(int.parse(buffer.toString(), radix: 16));
  }
}
--- FILE: lib/core/utils/price_utils.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../features/agenda/providers/business_providers.dart';
import '../../features/agenda/providers/location_providers.dart';
import '../l10n/l10_extension.dart'; // ‚úÖ per usare context.l10n
import '../models/service_variant.dart';

/// Utility per formattazione e parsing dei prezzi, coerente con la valuta
/// effettiva del business o della location.
///
/// üîπ Integra:
/// - Formattazione localizzata tramite [Intl.NumberFormat]
/// - Fallback automatico sul locale corrente
/// - Metodo [parse] per convertire input utente (es. ‚Äú‚Ç¨45,90‚Äù) in `double`
/// - Metodo [formatService] per mostrare prezzo e label standard (‚Äúa partire da‚Ä¶‚Äù)
class PriceFormatter {
  const PriceFormatter._();

  /// Restituisce la valuta effettiva in base a location o business.
  static String effectiveCurrency(WidgetRef ref) {
    final locationCurrency = ref.watch(currentLocationProvider).currency;
    final businessCurrency = ref.watch(currentBusinessProvider).currency;
    return locationCurrency ?? businessCurrency;
  }

  /// Formatta un prezzo numerico [amount] nella valuta indicata.
  ///
  /// Utilizza sempre il simbolo della valuta e rispetta la locale dell'app.
  static String format({
    required BuildContext context,
    required double amount,
    required String currencyCode,
    String? forcedLocale,
  }) {
    // Locale derivata dal contesto o dal parametro forzato
    final localeFromContext = Localizations.localeOf(context).toString();
    final currentLocale = forcedLocale ?? localeFromContext;

    try {
      // Usa simpleCurrency per ottenere il simbolo (‚Ç¨, $, ¬£, ecc.)
      final formatter = NumberFormat.simpleCurrency(
        name: currencyCode,
        locale: currentLocale,
      );
      return formatter.format(amount);
    } catch (_) {
      // Se la locale non √® supportata, prova con la locale dell'app
      try {
        final fallbackFormatter = NumberFormat.simpleCurrency(
          name: currencyCode,
          locale: Intl.getCurrentLocale(),
        );
        return fallbackFormatter.format(amount);
      } catch (_) {
        // Ultimo fallback su 'it_IT' (anzich√© en_US)
        final lastResortFormatter = NumberFormat.simpleCurrency(
          name: currencyCode,
          locale: 'it_IT',
        );
        return lastResortFormatter.format(amount);
      }
    }
  }

  /// Converte una stringa di input (es. ‚Äú‚Ç¨ 45,90‚Äù, ‚Äú45.00‚Äù, ‚ÄúCHF 120‚Äù) in `double`.
  ///
  /// Rimuove simboli e caratteri non numerici, normalizzando la virgola in punto.
  static double? parse(String input) {
    if (input.trim().isEmpty) return null;

    final cleaned = input
        .replaceAll(RegExp(r'[^0-9,.\-]'), '')
        .replaceAll(',', '.');

    return double.tryParse(cleaned);
  }

  /// Formatta un [ServiceVariant] tenendo conto delle impostazioni di valuta e
  /// dei flag `isFree` e `isPriceStartingFrom`.
  static String formatVariant({
    required BuildContext context,
    required WidgetRef ref,
    required ServiceVariant variant,
  }) {
    final currency = variant.currency ?? effectiveCurrency(ref);

    if (variant.isFree) return context.l10n.freeLabel;
    if (variant.price <= 0) return context.l10n.priceNotAvailable;

    final formatted = format(
      context: context,
      amount: variant.price,
      currencyCode: currency,
    );

    return variant.isPriceStartingFrom
        ? '${context.l10n.priceStartingFromPrefix} $formatted'
        : formatted;
  }
}
--- FILE: lib/core/utils/string_utils.dart ---
/// Utility per la manipolazione delle stringhe
class StringUtils {
  const StringUtils._();

  /// Capitalizza la prima lettera di ogni parola (Title Case)
  /// Es: "mario rossi" ‚Üí "Mario Rossi"
  /// Es: "GIOVANNI BIANCHI" ‚Üí "Giovanni Bianchi"
  static String toTitleCase(String raw) {
    final trimmed = raw.trim();
    if (trimmed.isEmpty) return trimmed;

    final parts = trimmed.split(' ');
    return parts
        .map(
          (w) => w.isEmpty
              ? ''
              : '${w[0].toUpperCase()}${w.substring(1).toLowerCase()}',
        )
        .join(' ');
  }

  /// Capitalizza solo la prima lettera della stringa
  /// Es: "mario rossi" ‚Üí "Mario rossi"
  static String capitalize(String raw) {
    final trimmed = raw.trim();
    if (trimmed.isEmpty) return trimmed;
    return '${trimmed[0].toUpperCase()}${trimmed.substring(1).toLowerCase()}';
  }

  /// Capitalizza la prima lettera, mantenendo il resto invariato
  /// Es: "mario ROSSI" ‚Üí "Mario ROSSI"
  static String capitalizeFirst(String raw) {
    final trimmed = raw.trim();
    if (trimmed.isEmpty) return trimmed;
    return '${trimmed[0].toUpperCase()}${trimmed.substring(1)}';
  }
}
--- FILE: lib/core/utils/date_utils.dart ---
--- FILE: lib/core/models/hour_range.dart ---

--- FILE: lib/core/models/appointment.dart ---
enum ExtraMinutesType { processing, blocked }

ExtraMinutesType? _extraMinutesTypeFromJson(Object? value) {
  if (value is String) {
    for (final type in ExtraMinutesType.values) {
      if (type.name == value) {
        return type;
      }
    }
  }
  return null;
}

String? _extraMinutesTypeToJson(ExtraMinutesType? value) {
  return value?.name;
}

class Appointment {
  final int id;
  final int bookingId;
  final int businessId;
  final int locationId;
  final int staffId;
  final int serviceId;
  final int serviceVariantId;
  final int? clientId; // opzionale: collegamento al Client
  final String clientName;
  final String serviceName;
  final DateTime startTime;
  final DateTime endTime;
  final double? price; // prezzo applicato al singolo appuntamento
  // Legacy single extra fields (kept for backward compatibility)
  final int? extraMinutes;
  final ExtraMinutesType? extraMinutesType;
  // New split extras
  final int? extraBlockedMinutes;
  final int? extraProcessingMinutes;

  const Appointment({
    required this.id,
    required this.bookingId,
    required this.businessId,
    required this.locationId,
    required this.staffId,
    required this.serviceId,
    required this.serviceVariantId,
    this.clientId,
    required this.clientName,
    required this.serviceName,
    required this.startTime,
    required this.endTime,
    this.price,
    this.extraMinutes,
    this.extraMinutesType,
    this.extraBlockedMinutes,
    this.extraProcessingMinutes,
  });

  factory Appointment.fromJson(Map<String, dynamic> json) => Appointment(
    id: json['id'] as int,
    bookingId: json['booking_id'] as int,
    businessId: json['business_id'] as int,
    locationId: json['location_id'] as int,
    staffId: json['staff_id'] as int,
    serviceId: json['service_id'] as int,
    serviceVariantId: json['service_variant_id'] as int,
    clientId: json['client_id'] as int?,
    clientName: json['client_name'] as String? ?? '',
    serviceName: json['service_name'] as String? ?? '',
    startTime: DateTime.parse(json['start_time'] as String),
    endTime: DateTime.parse(json['end_time'] as String),
    price: json['price'] != null ? (json['price'] as num).toDouble() : null,
    extraMinutes: json['extra_minutes'] as int?,
    extraMinutesType: _extraMinutesTypeFromJson(
      json['extra_minutes_type'],
    ),
    extraBlockedMinutes: json['extra_blocked_minutes'] as int?,
    extraProcessingMinutes: json['extra_processing_minutes'] as int?,
  );

  Appointment copyWith({
    int? id,
    int? bookingId,
    int? businessId,
    int? locationId,
    int? staffId,
    int? serviceId,
    int? serviceVariantId,
    int? clientId,
    String? clientName,
    String? serviceName,
    DateTime? startTime,
    DateTime? endTime,
    double? price,
    int? extraMinutes,
    ExtraMinutesType? extraMinutesType,
    int? extraBlockedMinutes,
    int? extraProcessingMinutes,
  }) {
    return Appointment(
      id: id ?? this.id,
      bookingId: bookingId ?? this.bookingId,
      businessId: businessId ?? this.businessId,
      locationId: locationId ?? this.locationId,
      staffId: staffId ?? this.staffId,
      serviceId: serviceId ?? this.serviceId,
      serviceVariantId: serviceVariantId ?? this.serviceVariantId,
      clientId: clientId ?? this.clientId,
      clientName: clientName ?? this.clientName,
      serviceName: serviceName ?? this.serviceName,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      price: price ?? this.price,
      extraMinutes: extraMinutes ?? this.extraMinutes,
      extraMinutesType: extraMinutesType ?? this.extraMinutesType,
      extraBlockedMinutes: extraBlockedMinutes ?? this.extraBlockedMinutes,
      extraProcessingMinutes:
          extraProcessingMinutes ?? this.extraProcessingMinutes,
    );
  }

  Map<String, dynamic> toJson() {
    final blocked = blockedExtraMinutes;
    final processing = processingExtraMinutes;
    final legacyType = blocked > 0
        ? ExtraMinutesType.blocked
        : (processing > 0 ? ExtraMinutesType.processing : null);
    final legacyMinutes = legacyType == ExtraMinutesType.blocked
        ? blocked
        : (legacyType == ExtraMinutesType.processing ? processing : null);
    return {
      'id': id,
      'booking_id': bookingId,
      'business_id': businessId,
      'location_id': locationId,
      'staff_id': staffId,
      'service_id': serviceId,
      'service_variant_id': serviceVariantId,
      if (clientId != null) 'client_id': clientId,
      'client_name': clientName,
      'service_name': serviceName,
      'start_time': startTime.toIso8601String(),
      'end_time': endTime.toIso8601String(),
      if (price != null) 'price': price,
      if (legacyMinutes != null) 'extra_minutes': legacyMinutes,
      if (legacyType != null)
        'extra_minutes_type': _extraMinutesTypeToJson(legacyType),
      if (extraBlockedMinutes != null)
        'extra_blocked_minutes': extraBlockedMinutes,
      if (extraProcessingMinutes != null)
        'extra_processing_minutes': extraProcessingMinutes,
    };
  }

  int get blockedExtraMinutes {
    if (extraBlockedMinutes != null) return extraBlockedMinutes!;
    if (extraMinutesType == ExtraMinutesType.blocked) {
      return extraMinutes ?? 0;
    }
    return 0;
  }

  int get processingExtraMinutes {
    if (extraProcessingMinutes != null) return extraProcessingMinutes!;
    if (extraMinutesType == ExtraMinutesType.processing) {
      return extraMinutes ?? 0;
    }
    return 0;
  }

  int get totalDuration => endTime.difference(startTime).inMinutes;

  String get formattedPrice {
    if (price == null || price == 0) return '';
    return '${price!.toStringAsFixed(2)}‚Ç¨';
  }
}
--- FILE: lib/core/models/business_invitation.dart ---
/// Rappresenta un invito pendente per un utente.
class BusinessInvitation {
  final int id;
  final int businessId;
  final String email;
  final String role;
  final String? token;
  final DateTime expiresAt;
  final DateTime createdAt;
  final InviterInfo invitedBy;

  const BusinessInvitation({
    required this.id,
    required this.businessId,
    required this.email,
    required this.role,
    this.token,
    required this.expiresAt,
    required this.createdAt,
    required this.invitedBy,
  });

  /// Verifica se l'invito √® scaduto.
  bool get isExpired => DateTime.now().isAfter(expiresAt);

  /// Etichetta tradotta per il ruolo.
  String get roleLabel => switch (role) {
    'admin' => 'Amministratore',
    'manager' => 'Manager',
    'staff' => 'Staff',
    _ => role,
  };

  BusinessInvitation copyWith({
    int? id,
    int? businessId,
    String? email,
    String? role,
    String? token,
    DateTime? expiresAt,
    DateTime? createdAt,
    InviterInfo? invitedBy,
  }) => BusinessInvitation(
    id: id ?? this.id,
    businessId: businessId ?? this.businessId,
    email: email ?? this.email,
    role: role ?? this.role,
    token: token ?? this.token,
    expiresAt: expiresAt ?? this.expiresAt,
    createdAt: createdAt ?? this.createdAt,
    invitedBy: invitedBy ?? this.invitedBy,
  );

  factory BusinessInvitation.fromJson(Map<String, dynamic> json) {
    final invitedByData = json['invited_by'] as Map<String, dynamic>?;
    return BusinessInvitation(
      id: json['id'] as int,
      businessId: json['business_id'] as int? ?? 0,
      email: json['email'] as String,
      role: json['role'] as String,
      token: json['token'] as String?,
      expiresAt: DateTime.parse(json['expires_at'] as String),
      createdAt: DateTime.parse(json['created_at'] as String),
      invitedBy: invitedByData != null
          ? InviterInfo.fromJson(invitedByData)
          : const InviterInfo(firstName: '', lastName: ''),
    );
  }

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'email': email,
    'role': role,
    if (token != null) 'token': token,
    'expires_at': expiresAt.toIso8601String(),
    'created_at': createdAt.toIso8601String(),
    'invited_by': invitedBy.toJson(),
  };

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BusinessInvitation &&
          runtimeType == other.runtimeType &&
          id == other.id;

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() =>
      'BusinessInvitation(id: $id, email: $email, role: $role)';
}

/// Informazioni sull'utente che ha inviato l'invito.
class InviterInfo {
  final String firstName;
  final String lastName;

  const InviterInfo({required this.firstName, required this.lastName});

  String get fullName => '$firstName $lastName'.trim();

  factory InviterInfo.fromJson(Map<String, dynamic> json) => InviterInfo(
    firstName: json['first_name'] as String? ?? '',
    lastName: json['last_name'] as String? ?? '',
  );

  Map<String, dynamic> toJson() => {
    'first_name': firstName,
    'last_name': lastName,
  };
}
--- FILE: lib/core/models/business_user.dart ---
/// Rappresenta un utente associato a un business (operatore).
class BusinessUser {
  final int id;
  final int userId;
  final int businessId;
  final String role;
  final String email;
  final String firstName;
  final String lastName;
  final String status;
  final DateTime? invitedAt;
  final DateTime? joinedAt;
  final bool isCurrentUser;

  const BusinessUser({
    required this.id,
    required this.userId,
    required this.businessId,
    required this.role,
    required this.email,
    required this.firstName,
    required this.lastName,
    required this.status,
    this.invitedAt,
    this.joinedAt,
    this.isCurrentUser = false,
  });

  /// Nome completo dell'utente.
  String get fullName => '$firstName $lastName'.trim();

  /// Indica se l'utente ha un ruolo admin o superiore.
  bool get isAdmin => role == 'owner' || role == 'admin';

  /// Indica se l'utente pu√≤ gestire altri utenti (owner o admin).
  bool get canManageUsers => role == 'owner' || role == 'admin';

  /// Etichetta tradotta per il ruolo.
  String get roleLabel => switch (role) {
    'owner' => 'Proprietario',
    'admin' => 'Amministratore',
    'manager' => 'Manager',
    'staff' => 'Staff',
    _ => role,
  };

  BusinessUser copyWith({
    int? id,
    int? userId,
    int? businessId,
    String? role,
    String? email,
    String? firstName,
    String? lastName,
    String? status,
    DateTime? invitedAt,
    DateTime? joinedAt,
    bool? isCurrentUser,
  }) => BusinessUser(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    businessId: businessId ?? this.businessId,
    role: role ?? this.role,
    email: email ?? this.email,
    firstName: firstName ?? this.firstName,
    lastName: lastName ?? this.lastName,
    status: status ?? this.status,
    invitedAt: invitedAt ?? this.invitedAt,
    joinedAt: joinedAt ?? this.joinedAt,
    isCurrentUser: isCurrentUser ?? this.isCurrentUser,
  );

  factory BusinessUser.fromJson(Map<String, dynamic> json) => BusinessUser(
    id: json['id'] as int,
    userId: json['user_id'] as int,
    businessId: json['business_id'] as int,
    role: json['role'] as String,
    email: json['email'] as String,
    firstName: json['first_name'] as String? ?? '',
    lastName: json['last_name'] as String? ?? '',
    status: json['status'] as String? ?? 'active',
    invitedAt: json['invited_at'] != null
        ? DateTime.parse(json['invited_at'] as String)
        : null,
    joinedAt: json['joined_at'] != null
        ? DateTime.parse(json['joined_at'] as String)
        : null,
    isCurrentUser: json['is_current_user'] as bool? ?? false,
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'user_id': userId,
    'business_id': businessId,
    'role': role,
    'email': email,
    'first_name': firstName,
    'last_name': lastName,
    'status': status,
    if (invitedAt != null) 'invited_at': invitedAt!.toIso8601String(),
    if (joinedAt != null) 'joined_at': joinedAt!.toIso8601String(),
    'is_current_user': isCurrentUser,
  };

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is BusinessUser &&
          runtimeType == other.runtimeType &&
          id == other.id;

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() => 'BusinessUser(id: $id, email: $email, role: $role)';
}
--- FILE: lib/core/models/service_category.dart ---
class ServiceCategory {
  final int id;
  final int businessId;
  final String name;
  final String? description;
  final int sortOrder; // üîπ ordine di visualizzazione

  const ServiceCategory({
    required this.id,
    required this.businessId,
    required this.name,
    this.description,
    this.sortOrder = 0,
  });

  ServiceCategory copyWith({
    int? id,
    int? businessId,
    String? name,
    String? description,
    int? sortOrder,
  }) => ServiceCategory(
    id: id ?? this.id,
    businessId: businessId ?? this.businessId,
    name: name ?? this.name,
    description: description ?? this.description,
    sortOrder: sortOrder ?? this.sortOrder,
  );

  factory ServiceCategory.fromJson(Map<String, dynamic> json) =>
      ServiceCategory(
        id: json['id'] as int,
        businessId: json['business_id'] as int,
        name: json['name'] as String,
        description: json['description'] as String?,
        sortOrder: json['sort_order'] as int? ?? 0,
      );

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'name': name,
    if (description != null) 'description': description,
    'sort_order': sortOrder,
  };
}
--- FILE: lib/core/models/user.dart ---
/// Modello utente per l'autenticazione.
/// Rappresenta l'utente loggato nel gestionale.
class User {
  final int id;
  final String email;
  final String firstName;
  final String lastName;
  final String? phone;
  final bool isSuperadmin;
  final DateTime createdAt;

  const User({
    required this.id,
    required this.email,
    required this.firstName,
    required this.lastName,
    this.phone,
    this.isSuperadmin = false,
    required this.createdAt,
  });

  /// Nome completo dell'utente.
  String get fullName => '$firstName $lastName';

  /// Iniziali dell'utente (per avatar).
  String get initials {
    final first = firstName.isNotEmpty ? firstName[0].toUpperCase() : '';
    final last = lastName.isNotEmpty ? lastName[0].toUpperCase() : '';
    return '$first$last';
  }

  User copyWith({
    int? id,
    String? email,
    String? firstName,
    String? lastName,
    String? phone,
    bool? isSuperadmin,
    DateTime? createdAt,
  }) => User(
    id: id ?? this.id,
    email: email ?? this.email,
    firstName: firstName ?? this.firstName,
    lastName: lastName ?? this.lastName,
    phone: phone ?? this.phone,
    isSuperadmin: isSuperadmin ?? this.isSuperadmin,
    createdAt: createdAt ?? this.createdAt,
  );

  factory User.fromJson(Map<String, dynamic> json) => User(
    id: json['id'] as int,
    email: json['email'] as String,
    firstName: json['first_name'] as String,
    lastName: json['last_name'] as String,
    phone: json['phone'] as String?,
    isSuperadmin: json['is_superadmin'] == true || json['is_superadmin'] == 1,
    createdAt: json['created_at'] != null
        ? DateTime.parse(json['created_at'] as String)
        : DateTime.now(),
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'email': email,
    'first_name': firstName,
    'last_name': lastName,
    if (phone != null) 'phone': phone,
    'is_superadmin': isSuperadmin,
    'created_at': createdAt.toIso8601String(),
  };
}
--- FILE: lib/core/models/time_block.dart ---
/// Rappresenta un blocco di non disponibilit√† nell'agenda.
///
/// Un blocco pu√≤ essere assegnato a uno o pi√π membri dello staff
/// per una fascia oraria specifica.
class TimeBlock {
  final int id;
  final int businessId;
  final int locationId;

  /// Lista degli ID degli staff a cui √® assegnato il blocco.
  final List<int> staffIds;

  /// Inizio del blocco.
  final DateTime startTime;

  /// Fine del blocco.
  final DateTime endTime;

  /// Motivo opzionale del blocco (es. "Riunione", "Pausa pranzo", ecc.).
  final String? reason;

  /// Se true, il blocco copre l'intera giornata lavorativa.
  final bool isAllDay;

  const TimeBlock({
    required this.id,
    required this.businessId,
    required this.locationId,
    required this.staffIds,
    required this.startTime,
    required this.endTime,
    this.reason,
    this.isAllDay = false,
  });

  factory TimeBlock.fromJson(Map<String, dynamic> json) => TimeBlock(
    id: json['id'] as int,
    businessId: json['business_id'] as int,
    locationId: json['location_id'] as int,
    staffIds: (json['staff_ids'] as List<dynamic>)
        .map((id) => id as int)
        .toList(),
    startTime: DateTime.parse(json['start_time'] as String),
    endTime: DateTime.parse(json['end_time'] as String),
    reason: json['reason'] as String?,
    isAllDay: json['is_all_day'] as bool? ?? false,
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'location_id': locationId,
    'staff_ids': staffIds,
    'start_time': startTime.toIso8601String(),
    'end_time': endTime.toIso8601String(),
    if (reason != null) 'reason': reason,
    'is_all_day': isAllDay,
  };

  TimeBlock copyWith({
    int? id,
    int? businessId,
    int? locationId,
    List<int>? staffIds,
    DateTime? startTime,
    DateTime? endTime,
    String? reason,
    bool? isAllDay,
  }) {
    return TimeBlock(
      id: id ?? this.id,
      businessId: businessId ?? this.businessId,
      locationId: locationId ?? this.locationId,
      staffIds: staffIds ?? this.staffIds,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      reason: reason ?? this.reason,
      isAllDay: isAllDay ?? this.isAllDay,
    );
  }

  /// Durata del blocco in minuti.
  int get durationMinutes => endTime.difference(startTime).inMinutes;

  /// Verifica se il blocco include uno specifico staff.
  bool includesStaff(int staffId) => staffIds.contains(staffId);

  /// Verifica se il blocco si sovrappone a un intervallo di tempo.
  bool overlaps(DateTime start, DateTime end) {
    return startTime.isBefore(end) && endTime.isAfter(start);
  }

  /// Verifica se il blocco √® nella stessa data.
  bool isOnDate(DateTime date) {
    final blockDate = DateTime(startTime.year, startTime.month, startTime.day);
    final targetDate = DateTime(date.year, date.month, date.day);
    return blockDate == targetDate;
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TimeBlock && runtimeType == other.runtimeType && id == other.id;

  @override
  int get hashCode => id.hashCode;
}
--- FILE: lib/core/models/booking.dart ---
class Booking {
  final int id;
  final int businessId;
  final int locationId;
  final int? clientId;
  final String? clientName;
  final String? notes;

  const Booking({
    required this.id,
    required this.businessId,
    required this.locationId,
    this.clientId,
    this.clientName,
    this.notes,
  });

  Booking copyWith({
    int? id,
    int? businessId,
    int? locationId,
    int? clientId,
    String? clientName,
    String? notes,
  }) {
    return Booking(
      id: id ?? this.id,
      businessId: businessId ?? this.businessId,
      locationId: locationId ?? this.locationId,
      clientId: clientId ?? this.clientId,
      clientName: clientName ?? this.clientName,
      notes: notes ?? this.notes,
    );
  }

  factory Booking.fromJson(Map<String, dynamic> json) => Booking(
    id: json['id'] as int,
    businessId: json['business_id'] as int,
    locationId: json['location_id'] as int,
    clientId: json['client_id'] as int?,
    clientName: json['client_name'] as String? ?? '',
    notes: json['notes'] as String?,
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'location_id': locationId,
    if (clientId != null) 'client_id': clientId,
    'client_name': clientName,
    if (notes != null) 'notes': notes,
  };
}
--- FILE: lib/core/models/resource.dart ---
class Resource {
  final int id;
  final int locationId;
  final String name;
  final int quantity;
  final String? type;
  final String? note;

  const Resource({
    required this.id,
    required this.locationId,
    required this.name,
    required this.quantity,
    this.type,
    this.note,
  });

  Resource copyWith({
    int? id,
    int? locationId,
    String? name,
    int? quantity,
    String? type,
    String? note,
  }) {
    return Resource(
      id: id ?? this.id,
      locationId: locationId ?? this.locationId,
      name: name ?? this.name,
      quantity: quantity ?? this.quantity,
      type: type ?? this.type,
      note: note ?? this.note,
    );
  }

  factory Resource.fromJson(Map<String, dynamic> json) {
    return Resource(
      id: json['id'] as int,
      locationId: json['location_id'] as int,
      name: json['name'] as String,
      quantity: json['quantity'] as int,
      type: json['type'] as String?,
      note: json['note'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'location_id': locationId,
      'name': name,
      'quantity': quantity,
      if (type != null) 'type': type,
      if (note != null) 'note': note,
    };
  }
}

--- FILE: lib/core/models/service.dart ---
class Service {
  final int id;
  final int businessId;
  final int categoryId;
  final String name;
  final String? description;
  final int sortOrder; // üîπ posizione nella categoria
  final int? durationMinutes; // da API
  final double? price; // da API
  final String? color; // da API
  final bool isPriceStartingFrom; // "a partire da" flag
  final int? serviceVariantId; // ID della variante per location (da API)

  const Service({
    required this.id,
    required this.businessId,
    required this.categoryId,
    required this.name,
    this.description,
    this.sortOrder = 0,
    this.durationMinutes,
    this.price,
    this.color,
    this.isPriceStartingFrom = false,
    this.serviceVariantId,
  });

  Service copyWith({
    int? id,
    int? businessId,
    int? categoryId,
    String? name,
    String? description,
    int? sortOrder,
    int? durationMinutes,
    double? price,
    String? color,
    bool? isPriceStartingFrom,
    int? serviceVariantId,
  }) => Service(
    id: id ?? this.id,
    businessId: businessId ?? this.businessId,
    categoryId: categoryId ?? this.categoryId,
    name: name ?? this.name,
    description: description ?? this.description,
    sortOrder: sortOrder ?? this.sortOrder,
    durationMinutes: durationMinutes ?? this.durationMinutes,
    price: price ?? this.price,
    color: color ?? this.color,
    isPriceStartingFrom: isPriceStartingFrom ?? this.isPriceStartingFrom,
    serviceVariantId: serviceVariantId ?? this.serviceVariantId,
  );

  factory Service.fromJson(Map<String, dynamic> json) => Service(
    id: json['id'] as int,
    businessId: json['business_id'] as int? ?? 1,
    categoryId: json['category_id'] as int? ?? 0,
    name: json['name'] as String,
    description: json['description'] as String?,
    sortOrder: json['sort_order'] as int? ?? 0,
    durationMinutes: json['duration_minutes'] as int?,
    price: (json['price'] as num?)?.toDouble(),
    color: json['color'] as String?,
    isPriceStartingFrom: json['is_price_starting_from'] as bool? ?? false,
    serviceVariantId: json['service_variant_id'] as int?,
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'category_id': categoryId,
    'name': name,
    if (description != null) 'description': description,
    'sort_order': sortOrder,
    if (durationMinutes != null) 'duration_minutes': durationMinutes,
    if (price != null) 'price': price,
    if (color != null) 'color': color,
    'is_price_starting_from': isPriceStartingFrom,
    if (serviceVariantId != null) 'service_variant_id': serviceVariantId,
  };
}
--- FILE: lib/core/models/availability_exception.dart ---
import 'package:flutter/material.dart';

/// Tipo di eccezione alla disponibilit√† settimanale.
enum AvailabilityExceptionType {
  /// Lo staff √® DISPONIBILE in questa fascia (aggiunge disponibilit√†).
  available,

  /// Lo staff NON √® DISPONIBILE in questa fascia (rimuove disponibilit√†).
  unavailable,
}

/// Rappresenta un'eccezione alla disponibilit√† settimanale di uno staff.
///
/// A differenza del template settimanale che definisce gli orari ricorrenti,
/// le eccezioni permettono di:
/// - Aggiungere disponibilit√† extra in giorni/fasce specifiche
/// - Rimuovere disponibilit√† in giorni/fasce specifiche (ferie, malattia, ecc.)
///
/// Esempio:
/// - Template: Lun-Ven 09:00-18:00
/// - Eccezione "available": Sabato 14/12 dalle 10:00 alle 14:00 (lavoro extra)
/// - Eccezione "unavailable": Mercoled√¨ 18/12 tutto il giorno (ferie)
class AvailabilityException {
  final int id;
  final int staffId;

  /// Data specifica dell'eccezione.
  final DateTime date;

  /// Orario di inizio. Se null insieme a [endTime], l'eccezione copre l'intera giornata.
  final TimeOfDay? startTime;

  /// Orario di fine. Se null insieme a [startTime], l'eccezione copre l'intera giornata.
  final TimeOfDay? endTime;

  /// Tipo di eccezione: disponibile o non disponibile.
  final AvailabilityExceptionType type;

  /// Codice motivo opzionale (es. "vacation", "medical_visit", "extra_shift").
  final String? reasonCode;

  /// Motivo opzionale (es. "Ferie", "Visita medica", "Turno extra").
  final String? reason;

  const AvailabilityException({
    required this.id,
    required this.staffId,
    required this.date,
    this.startTime,
    this.endTime,
    required this.type,
    this.reasonCode,
    this.reason,
  });

  /// Se true, l'eccezione copre l'intera giornata.
  bool get isAllDay => startTime == null && endTime == null;

  /// Crea un'eccezione per l'intera giornata.
  factory AvailabilityException.allDay({
    required int id,
    required int staffId,
    required DateTime date,
    required AvailabilityExceptionType type,
    String? reasonCode,
    String? reason,
  }) {
    return AvailabilityException(
      id: id,
      staffId: staffId,
      date: DateUtils.dateOnly(date),
      startTime: null,
      endTime: null,
      type: type,
      reasonCode: reasonCode,
      reason: reason,
    );
  }

  /// Crea un'eccezione per una fascia oraria specifica.
  factory AvailabilityException.timeRange({
    required int id,
    required int staffId,
    required DateTime date,
    required TimeOfDay startTime,
    required TimeOfDay endTime,
    required AvailabilityExceptionType type,
    String? reasonCode,
    String? reason,
  }) {
    return AvailabilityException(
      id: id,
      staffId: staffId,
      date: DateUtils.dateOnly(date),
      startTime: startTime,
      endTime: endTime,
      type: type,
      reasonCode: reasonCode,
      reason: reason,
    );
  }

  AvailabilityException copyWith({
    int? id,
    int? staffId,
    DateTime? date,
    TimeOfDay? startTime,
    TimeOfDay? endTime,
    AvailabilityExceptionType? type,
    String? reasonCode,
    String? reason,
    bool clearStartTime = false,
    bool clearEndTime = false,
    bool clearReasonCode = false,
    bool clearReason = false,
  }) {
    return AvailabilityException(
      id: id ?? this.id,
      staffId: staffId ?? this.staffId,
      date: date ?? this.date,
      startTime: clearStartTime ? null : (startTime ?? this.startTime),
      endTime: clearEndTime ? null : (endTime ?? this.endTime),
      type: type ?? this.type,
      reasonCode: clearReasonCode ? null : (reasonCode ?? this.reasonCode),
      reason: clearReason ? null : (reason ?? this.reason),
    );
  }

  factory AvailabilityException.fromJson(Map<String, dynamic> json) {
    return AvailabilityException(
      id: json['id'] as int,
      staffId: json['staff_id'] as int,
      date: DateTime.parse(json['date'] as String),
      startTime: json['start_time'] != null
          ? _timeOfDayFromString(json['start_time'] as String)
          : null,
      endTime: json['end_time'] != null
          ? _timeOfDayFromString(json['end_time'] as String)
          : null,
      type: AvailabilityExceptionType.values.firstWhere(
        (e) => e.name == json['type'],
        orElse: () => AvailabilityExceptionType.unavailable,
      ),
      reasonCode: json['reason_code'] as String?,
      reason: json['reason'] as String?,
    );
  }

  Map<String, dynamic> toJson() => {
    'id': id,
    'staff_id': staffId,
    'date': date.toIso8601String().split('T').first,
    if (startTime != null) 'start_time': _timeOfDayToString(startTime!),
    if (endTime != null) 'end_time': _timeOfDayToString(endTime!),
    'type': type.name,
    if (reasonCode != null) 'reason_code': reasonCode,
    if (reason != null) 'reason': reason,
  };

  static TimeOfDay _timeOfDayFromString(String time) {
    final parts = time.split(':');
    return TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1]));
  }

  static String _timeOfDayToString(TimeOfDay time) {
    return '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';
  }

  /// Verifica se l'eccezione √® per una data specifica.
  bool isOnDate(DateTime targetDate) {
    final target = DateUtils.dateOnly(targetDate);
    final excDate = DateUtils.dateOnly(date);
    return excDate == target;
  }

  /// Converte l'eccezione in un set di slot index.
  /// [minutesPerSlot] √® tipicamente 15.
  /// Per eccezioni "all day", copre tutti gli slot della giornata.
  Set<int> toSlotIndices({
    required int minutesPerSlot,
    required int totalSlotsPerDay,
  }) {
    if (isAllDay) {
      // Tutti gli slot della giornata
      return {for (int i = 0; i < totalSlotsPerDay; i++) i};
    }

    final startMinutes = startTime!.hour * 60 + startTime!.minute;
    final endMinutes = endTime!.hour * 60 + endTime!.minute;

    final startSlot = startMinutes ~/ minutesPerSlot;
    final endSlot = endMinutes ~/ minutesPerSlot;

    return {for (int i = startSlot; i < endSlot; i++) i};
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AvailabilityException &&
          runtimeType == other.runtimeType &&
          id == other.id;

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() {
    final timeStr = isAllDay
        ? 'all day'
        : '${_timeOfDayToString(startTime!)}-${_timeOfDayToString(endTime!)}';
    return 'AvailabilityException(id: $id, staffId: $staffId, date: ${date.toIso8601String().split('T').first}, $timeStr, type: ${type.name}, reasonCode: $reasonCode, reason: $reason)';
  }
}
--- FILE: lib/core/models/location.dart ---
class Location {
  final int id;
  final int businessId;
  final String name;
  final String? address;
  final String? city;
  final String? region;
  final String? country;
  final String? phone;
  final String? email;
  final double? latitude;
  final double? longitude;
  final String? currency;
  final bool isDefault;
  final bool isActive;
  final int sortOrder;

  const Location({
    required this.id,
    required this.businessId,
    required this.name,
    this.address,
    this.city,
    this.region,
    this.country,
    this.phone,
    this.email,
    this.latitude,
    this.longitude,
    this.currency,
    this.isDefault = false,
    this.isActive = true,
    this.sortOrder = 0,
  });

  Location copyWith({
    int? id,
    int? businessId,
    String? name,
    String? address,
    String? city,
    String? region,
    String? country,
    String? phone,
    String? email,
    double? latitude,
    double? longitude,
    String? currency,
    bool? isDefault,
    bool? isActive,
    int? sortOrder,
  }) {
    return Location(
      id: id ?? this.id,
      businessId: businessId ?? this.businessId,
      name: name ?? this.name,
      address: address ?? this.address,
      city: city ?? this.city,
      region: region ?? this.region,
      country: country ?? this.country,
      phone: phone ?? this.phone,
      email: email ?? this.email,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      currency: currency ?? this.currency,
      isDefault: isDefault ?? this.isDefault,
      isActive: isActive ?? this.isActive,
      sortOrder: sortOrder ?? this.sortOrder,
    );
  }

  factory Location.fromJson(Map<String, dynamic> json) {
    return Location(
      id: json['id'] as int,
      businessId: json['business_id'] as int,
      name: json['name'] as String,
      address: json['address'] as String?,
      city: json['city'] as String?,
      region: json['region'] as String?,
      country: json['country'] as String?,
      phone: json['phone'] as String?,
      email: json['email'] as String?,
      latitude: (json['latitude'] as num?)?.toDouble(),
      longitude: (json['longitude'] as num?)?.toDouble(),
      currency: json['currency'] as String?,
      isDefault: json['is_default'] as bool? ?? false,
      isActive: json['is_active'] as bool? ?? true,
      sortOrder: json['sort_order'] as int? ?? 0,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'business_id': businessId,
      'name': name,
      if (address != null) 'address': address,
      if (city != null) 'city': city,
      if (region != null) 'region': region,
      if (country != null) 'country': country,
      if (phone != null) 'phone': phone,
      if (email != null) 'email': email,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (currency != null) 'currency': currency,
      'is_default': isDefault,
      'is_active': isActive,
    };
  }
}
--- FILE: lib/core/models/staff.dart ---
import 'package:flutter/material.dart';

import '../utils/color_utils.dart';

class Staff {
  final int id;
  final int businessId;
  final String name;
  final String surname;
  final Color color;
  final List<int> locationIds;
  final List<int> serviceIds;
  final int sortOrder; // üîπ ordine in agenda
  final bool isDefault; // üîπ staff predefinito
  final bool isBookableOnline; // üîπ abilitato alle prenotazioni online

  const Staff({
    required this.id,
    required this.businessId,
    required this.name,
    required this.surname,
    required this.color,
    required this.locationIds,
    this.serviceIds = const [],
    this.sortOrder = 0,
    this.isDefault = false,
    this.isBookableOnline = true,
  });

  Staff copyWith({
    int? id,
    int? businessId,
    String? name,
    String? surname,
    Color? color,
    List<int>? locationIds,
    List<int>? serviceIds,
    int? sortOrder,
    bool? isDefault,
    bool? isBookableOnline,
  }) => Staff(
    id: id ?? this.id,
    businessId: businessId ?? this.businessId,
    name: name ?? this.name,
    surname: surname ?? this.surname,
    color: color ?? this.color,
    locationIds: locationIds ?? this.locationIds,
    serviceIds: serviceIds ?? this.serviceIds,
    sortOrder: sortOrder ?? this.sortOrder,
    isDefault: isDefault ?? this.isDefault,
    isBookableOnline: isBookableOnline ?? this.isBookableOnline,
  );

  factory Staff.fromJson(Map<String, dynamic> json) => Staff(
    id: json['id'] as int,
    businessId: json['business_id'] as int,
    name: json['name'] as String,
    surname: json['surname'] as String? ?? '',
    color: json['color_hex'] != null
        ? ColorUtils.fromHex(json['color_hex'] as String)
        : ColorUtils.fromHex('#FFD700'),
    locationIds: (json['location_ids'] as List<dynamic>? ?? [])
        .map((id) => id as int)
        .toList(),
    serviceIds: (json['service_ids'] as List<dynamic>? ?? [])
        .map((id) => id as int)
        .toList(),
    sortOrder: json['sort_order'] as int? ?? 0,
    isDefault: json['is_default'] as bool? ?? false,
    isBookableOnline: json['is_bookable_online'] as bool? ?? true,
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'name': name,
    'surname': surname,
    'color_hex': ColorUtils.toHex(color),
    'location_ids': locationIds,
    'service_ids': serviceIds,
    'sort_order': sortOrder,
    'is_default': isDefault,
    'is_bookable_online': isBookableOnline,
  };

  bool worksAtLocation(int locationId) =>
      locationIds.isEmpty || locationIds.contains(locationId);

  String get displayName {
    if (surname.isEmpty) return name;
    return '$name $surname';
  }

  String get initials {
    final nameInitial = name.isNotEmpty
        ? name.trim().split(RegExp(r'\s+')).first[0].toUpperCase()
        : '';

    final surnameParts = surname.trim().split(RegExp(r'\s+'))
      ..removeWhere((p) => p.isEmpty);

    if (nameInitial.isEmpty && surnameParts.isEmpty) {
      return '';
    }

    var initials = nameInitial;

    if (surnameParts.isNotEmpty) {
      for (final part in surnameParts) {
        initials += part[0].toUpperCase();
        if (initials.length >= 3) break;
      }
    }

    if (initials.length < 3 && surnameParts.isEmpty) {
      final nameParts = name.trim().split(RegExp(r'\s+'))
        ..removeWhere((p) => p.isEmpty);
      if (nameParts.length > 1) {
        for (int i = 1; i < nameParts.length; i++) {
          initials += nameParts[i][0].toUpperCase();
          if (initials.length >= 3) break;
        }
      } else if (name.length > 1) {
        initials += name[1].toUpperCase();
      }
    }

    final endIndex = initials.length.clamp(1, 3).toInt();
    return initials.substring(0, endIndex);
  }
}
--- FILE: lib/core/models/service_staff_eligibility.dart ---
class ServiceStaffEligibility {
  final int serviceId;
  final int staffId;
  final int? locationId; // null => valido per tutte le location del servizio

  const ServiceStaffEligibility({
    required this.serviceId,
    required this.staffId,
    this.locationId,
  });
}

--- FILE: lib/core/models/staff_planning.dart ---
import 'package:flutter/foundation.dart';

/// Tipo di pianificazione settimanale.
enum StaffPlanningType {
  /// Pianificazione settimanale standard (template A).
  weekly,

  /// Pianificazione bisettimanale (template A/B alternati).
  biweekly,
}

/// Label della settimana per biweekly.
enum WeekLabel {
  /// Prima settimana del ciclo.
  a,

  /// Seconda settimana del ciclo.
  b,
}

/// Rappresenta una pianificazione settimanale o bisettimanale di uno staff.
///
/// Una pianificazione ha un intervallo di validit√† [validFrom, validTo]
/// dove validTo pu√≤ essere null per indicare "senza scadenza".
///
/// Per uno staff, in una data D esiste al massimo un planning valido
/// (nessuna sovrapposizione di intervalli).
@immutable
class StaffPlanning {
  final int id;
  final int staffId;
  final StaffPlanningType type;

  /// Data di inizio validit√† (inclusa).
  final DateTime validFrom;

  /// Data di fine validit√† (inclusa). Se null, la pianificazione non ha scadenza.
  final DateTime? validTo;

  /// Template settimanali. Per weekly contiene solo weekLabel=A.
  /// Per biweekly contiene sia A che B.
  final List<StaffPlanningWeekTemplate> templates;

  final DateTime createdAt;
  final DateTime? updatedAt;

  const StaffPlanning({
    required this.id,
    required this.staffId,
    required this.type,
    required this.validFrom,
    this.validTo,
    required this.templates,
    required this.createdAt,
    this.updatedAt,
  });

  /// Se true, la pianificazione √® valida indefinitamente.
  bool get isOpenEnded => validTo == null;

  /// Verifica se la pianificazione √® valida per una data D.
  /// Usa intervalli chiusi-chiusi: [validFrom, validTo].
  bool isValidForDate(DateTime date) {
    final d = DateUtils.dateOnly(date);
    final from = DateUtils.dateOnly(validFrom);

    if (d.isBefore(from)) return false;
    if (validTo == null) return true;

    final to = DateUtils.dateOnly(validTo!);
    return !d.isAfter(to);
  }

  /// Ottiene il template per la settimana A.
  StaffPlanningWeekTemplate? get templateA =>
      templates.where((t) => t.weekLabel == WeekLabel.a).firstOrNull;

  /// Ottiene il template per la settimana B.
  StaffPlanningWeekTemplate? get templateB =>
      templates.where((t) => t.weekLabel == WeekLabel.b).firstOrNull;

  /// Ottiene il template da usare per una data specifica.
  /// Per weekly restituisce sempre template A.
  /// Per biweekly calcola se siamo in settimana A o B.
  StaffPlanningWeekTemplate? getTemplateForDate(DateTime date) {
    if (type == StaffPlanningType.weekly) {
      return templateA;
    }

    final weekLabel = computeWeekLabel(date);
    return weekLabel == WeekLabel.a ? templateA : templateB;
  }

  /// Calcola la label della settimana (A/B) per una data.
  /// Per weekly ritorna sempre A.
  WeekLabel computeWeekLabel(DateTime date) {
    if (type == StaffPlanningType.weekly) return WeekLabel.a;

    final d = DateUtils.dateOnly(date);
    final from = DateUtils.dateOnly(validFrom);

    // delta_days = D - valid_from
    final deltaDays = d.difference(from).inDays;

    // week_index = floor(delta_days / 7)
    final weekIndex = deltaDays ~/ 7;

    // pari ‚Üí A, dispari ‚Üí B
    return weekIndex.isEven ? WeekLabel.a : WeekLabel.b;
  }

  StaffPlanning copyWith({
    int? id,
    int? staffId,
    StaffPlanningType? type,
    DateTime? validFrom,
    DateTime? Function()? validTo,
    List<StaffPlanningWeekTemplate>? templates,
    DateTime? createdAt,
    DateTime? Function()? updatedAt,
  }) {
    return StaffPlanning(
      id: id ?? this.id,
      staffId: staffId ?? this.staffId,
      type: type ?? this.type,
      validFrom: validFrom ?? this.validFrom,
      validTo: validTo != null ? validTo() : this.validTo,
      templates: templates ?? this.templates,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt != null ? updatedAt() : this.updatedAt,
    );
  }

  factory StaffPlanning.fromJson(Map<String, dynamic> json) {
    return StaffPlanning(
      id: json['id'] as int,
      staffId: json['staff_id'] as int,
      type: StaffPlanningType.values.firstWhere(
        (t) => t.name == json['type'],
        orElse: () => StaffPlanningType.weekly,
      ),
      validFrom: DateTime.parse(json['valid_from'] as String),
      validTo: json['valid_to'] != null
          ? DateTime.parse(json['valid_to'] as String)
          : null,
      templates: (json['templates'] as List<dynamic>? ?? [])
          .map(
            (t) =>
                StaffPlanningWeekTemplate.fromJson(t as Map<String, dynamic>),
          )
          .toList(),
      createdAt: json['created_at'] != null
          ? DateTime.parse(json['created_at'] as String)
          : DateTime.now(),
      updatedAt: json['updated_at'] != null
          ? DateTime.parse(json['updated_at'] as String)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'staff_id': staffId,
      'type': type.name,
      'valid_from': _dateToIso(validFrom),
      'valid_to': validTo != null ? _dateToIso(validTo!) : null,
      'templates': templates.map((t) => t.toJson()).toList(),
      'created_at': createdAt.toIso8601String(),
      'updated_at': updatedAt?.toIso8601String(),
    };
  }

  static String _dateToIso(DateTime d) =>
      '${d.year.toString().padLeft(4, '0')}-'
      '${d.month.toString().padLeft(2, '0')}-'
      '${d.day.toString().padLeft(2, '0')}';

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StaffPlanning &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          staffId == other.staffId &&
          type == other.type &&
          validFrom == other.validFrom &&
          validTo == other.validTo;

  @override
  int get hashCode => Object.hash(id, staffId, type, validFrom, validTo);

  @override
  String toString() =>
      'StaffPlanning(id: $id, staffId: $staffId, type: $type, '
      'validFrom: ${_dateToIso(validFrom)}, '
      'validTo: ${validTo != null ? _dateToIso(validTo!) : 'null'})';
}

/// Template di una settimana con gli slot per ogni giorno.
///
/// Per ogni giorno della settimana (1-7, Mon-Sun) contiene gli slot disponibili
/// come `Set<int>` dove ogni int √® l'indice dello slot (es. 36 = 09:00 con slot da 15 min).
@immutable
class StaffPlanningWeekTemplate {
  final int id;
  final int staffPlanningId;
  final WeekLabel weekLabel;

  /// Mappa: day_of_week (1-7) -> Set di slot index.
  /// 1 = Monday, 7 = Sunday.
  /// Slot vuoto o assente = giorno non disponibile.
  final Map<int, Set<int>> daySlots;

  const StaffPlanningWeekTemplate({
    required this.id,
    required this.staffPlanningId,
    required this.weekLabel,
    required this.daySlots,
  });

  /// Verifica se il giorno ha slot definiti.
  bool hasSlots(int dayOfWeek) {
    final slots = daySlots[dayOfWeek];
    return slots != null && slots.isNotEmpty;
  }

  /// Ottiene gli slot per un giorno specifico.
  Set<int> getSlotsForDay(int dayOfWeek) => daySlots[dayOfWeek] ?? const {};

  /// Calcola le ore totali settimanali (approssimate, basate su 15 min/slot).
  double get totalWeeklyHours {
    int totalSlots = 0;
    for (final slots in daySlots.values) {
      totalSlots += slots.length;
    }
    return totalSlots * 15 / 60; // 15 min per slot
  }

  StaffPlanningWeekTemplate copyWith({
    int? id,
    int? staffPlanningId,
    WeekLabel? weekLabel,
    Map<int, Set<int>>? daySlots,
  }) {
    return StaffPlanningWeekTemplate(
      id: id ?? this.id,
      staffPlanningId: staffPlanningId ?? this.staffPlanningId,
      weekLabel: weekLabel ?? this.weekLabel,
      daySlots: daySlots ?? this.daySlots,
    );
  }

  factory StaffPlanningWeekTemplate.fromJson(Map<String, dynamic> json) {
    // Parse day_slots: pu√≤ essere array di {day_of_week, slots} o mappa diretta
    final Map<int, Set<int>> daySlots = {};

    final rawSlots = json['day_slots'] ?? json['slots'];
    if (rawSlots is List) {
      // Formato: [{day_of_week: 1, slots: [36, 37, ...]}, ...]
      for (final item in rawSlots) {
        if (item is Map<String, dynamic>) {
          final day = item['day_of_week'] as int;
          final slots = (item['slots'] as List<dynamic>? ?? [])
              .map((s) => s as int)
              .toSet();
          daySlots[day] = slots;
        }
      }
    } else if (rawSlots is Map) {
      // Formato: {"1": [36, 37, ...], "2": [...], ...}
      rawSlots.forEach((key, value) {
        final day = int.tryParse(key.toString()) ?? 0;
        if (day >= 1 && day <= 7 && value is List) {
          daySlots[day] = value.map((s) => s as int).toSet();
        }
      });
    }

    return StaffPlanningWeekTemplate(
      id: json['id'] as int? ?? 0,
      staffPlanningId: json['staff_planning_id'] as int? ?? 0,
      weekLabel: WeekLabel.values.firstWhere(
        (l) => l.name == (json['week_label'] as String?)?.toLowerCase(),
        orElse: () => WeekLabel.a,
      ),
      daySlots: daySlots,
    );
  }

  Map<String, dynamic> toJson() {
    // Converti daySlots in formato lista per JSON
    final List<Map<String, dynamic>> slotsJson = [];
    for (int day = 1; day <= 7; day++) {
      final slots = daySlots[day];
      if (slots != null) {
        slotsJson.add({'day_of_week': day, 'slots': slots.toList()..sort()});
      }
    }

    return {
      'id': id,
      'staff_planning_id': staffPlanningId,
      'week_label': weekLabel.name.toUpperCase(),
      'day_slots': slotsJson,
    };
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is StaffPlanningWeekTemplate &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          staffPlanningId == other.staffPlanningId &&
          weekLabel == other.weekLabel &&
          mapEquals(daySlots, other.daySlots);

  @override
  int get hashCode => Object.hash(id, staffPlanningId, weekLabel);

  @override
  String toString() =>
      'StaffPlanningWeekTemplate(id: $id, weekLabel: ${weekLabel.name}, '
      'days: ${daySlots.keys.toList()..sort()})';
}

/// Estensione helper per DateUtils.
extension DateUtils on DateTime {
  /// Ritorna la data senza componente oraria (mezzanotte).
  static DateTime dateOnly(DateTime date) =>
      DateTime(date.year, date.month, date.day);
}
--- FILE: lib/core/models/service_variant.dart ---
import 'service_variant_resource_requirement.dart';

class ServiceVariant {
  final int id;
  final int serviceId;
  final int locationId;
  final int durationMinutes;
  final int? processingTime; // minuti opzionali post-lavorazione
  final int? blockedTime; // minuti opzionali bloccati
  final double price;
  final String? colorHex;
  final String? currency; // üîπ Valuta specifica (es. "EUR", "USD")
  final bool isBookableOnline;
  final bool isFree;
  final bool isPriceStartingFrom;
  final List<ServiceVariantResourceRequirement> resourceRequirements;

  const ServiceVariant({
    required this.id,
    required this.serviceId,
    required this.locationId,
    required this.durationMinutes,
    this.processingTime,
    this.blockedTime,
    required this.price,
    this.colorHex,
    this.currency,
    this.isBookableOnline = true,
    this.isFree = false,
    this.isPriceStartingFrom = false,
    this.resourceRequirements = const [],
  });

  ServiceVariant copyWith({
    int? id,
    int? serviceId,
    int? locationId,
    int? durationMinutes,
    int? processingTime,
    int? blockedTime,
    double? price,
    String? colorHex,
    String? currency,
    bool? isBookableOnline,
    bool? isFree,
    bool? isPriceStartingFrom,
    List<ServiceVariantResourceRequirement>? resourceRequirements,
  }) {
    return ServiceVariant(
      id: id ?? this.id,
      serviceId: serviceId ?? this.serviceId,
      locationId: locationId ?? this.locationId,
      durationMinutes: durationMinutes ?? this.durationMinutes,
      processingTime: processingTime ?? this.processingTime,
      blockedTime: blockedTime ?? this.blockedTime,
      price: price ?? this.price,
      colorHex: colorHex ?? this.colorHex,
      currency: currency ?? this.currency,
      isBookableOnline: isBookableOnline ?? this.isBookableOnline,
      isFree: isFree ?? this.isFree,
      isPriceStartingFrom: isPriceStartingFrom ?? this.isPriceStartingFrom,
      resourceRequirements:
          resourceRequirements ?? this.resourceRequirements,
    );
  }

  factory ServiceVariant.fromJson(Map<String, dynamic> json) {
    return ServiceVariant(
      id: json['id'] as int,
      serviceId: json['service_id'] as int,
      locationId: json['location_id'] as int,
      durationMinutes: json['duration_minutes'] as int,
      processingTime: json['processing_time'] as int?,
      blockedTime: json['blocked_time'] as int?,
      price: (json['price'] as num).toDouble(),
      colorHex: json['color_hex'] as String?,
      currency: json['currency'] as String?,
      isBookableOnline: json['is_bookable_online'] as bool? ?? true,
      isFree: json['is_free'] as bool? ?? false,
      isPriceStartingFrom: json['is_price_starting_from'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'service_id': serviceId,
      'location_id': locationId,
      'duration_minutes': durationMinutes,
      if (processingTime != null) 'processing_time': processingTime,
      if (blockedTime != null) 'blocked_time': blockedTime,
      'price': price,
      if (colorHex != null) 'color_hex': colorHex,
      if (currency != null) 'currency': currency,
      'is_bookable_online': isBookableOnline,
      'is_free': isFree,
      'is_price_starting_from': isPriceStartingFrom,
    };
  }
}
--- FILE: lib/core/models/service_variant_resource_requirement.dart ---
class ServiceVariantResourceRequirement {
  final int id;
  final int serviceVariantId;
  final int resourceId;
  final int unitsRequired;

  const ServiceVariantResourceRequirement({
    required this.id,
    required this.serviceVariantId,
    required this.resourceId,
    required this.unitsRequired,
  });

  ServiceVariantResourceRequirement copyWith({
    int? id,
    int? serviceVariantId,
    int? resourceId,
    int? unitsRequired,
  }) {
    return ServiceVariantResourceRequirement(
      id: id ?? this.id,
      serviceVariantId: serviceVariantId ?? this.serviceVariantId,
      resourceId: resourceId ?? this.resourceId,
      unitsRequired: unitsRequired ?? this.unitsRequired,
    );
  }

  factory ServiceVariantResourceRequirement.fromJson(
    Map<String, dynamic> json,
  ) {
    return ServiceVariantResourceRequirement(
      id: json['id'] as int,
      serviceVariantId: json['service_variant_id'] as int,
      resourceId: json['resource_id'] as int,
      unitsRequired: json['units_required'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'service_variant_id': serviceVariantId,
      'resource_id': resourceId,
      'units_required': unitsRequired,
    };
  }
}

--- FILE: lib/core/models/business.dart ---
class Business {
  final int id;
  final String name;
  final String? slug;
  final String? email;
  final String? phone;
  final String? timezone;
  final DateTime createdAt;
  final String currency;
  final String defaultPhonePrefix;
  final String? adminEmail; // Email dell'admin proprietario
  final bool isSuspended; // Business sospeso (visibile ma non operativo)
  final String? suspensionMessage; // Messaggio da mostrare quando sospeso

  const Business({
    required this.id,
    required this.name,
    this.slug,
    this.email,
    this.phone,
    this.timezone,
    required this.createdAt,
    this.currency = 'EUR',
    this.defaultPhonePrefix = '+39',
    this.adminEmail,
    this.isSuspended = false,
    this.suspensionMessage,
  });

  Business copyWith({
    int? id,
    String? name,
    String? slug,
    String? email,
    String? phone,
    String? timezone,
    DateTime? createdAt,
    String? currency,
    String? defaultPhonePrefix,
    String? adminEmail,
    bool? isSuspended,
    String? suspensionMessage,
  }) {
    return Business(
      id: id ?? this.id,
      name: name ?? this.name,
      slug: slug ?? this.slug,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      timezone: timezone ?? this.timezone,
      createdAt: createdAt ?? this.createdAt,
      currency: currency ?? this.currency,
      defaultPhonePrefix: defaultPhonePrefix ?? this.defaultPhonePrefix,
      adminEmail: adminEmail ?? this.adminEmail,
      isSuspended: isSuspended ?? this.isSuspended,
      suspensionMessage: suspensionMessage ?? this.suspensionMessage,
    );
  }

  factory Business.fromJson(Map<String, dynamic> json) {
    return Business(
      id: json['id'] as int,
      name: json['name'] as String,
      slug: json['slug'] as String?,
      email: json['email'] as String?,
      phone: json['phone'] as String?,
      timezone: json['timezone'] as String?,
      createdAt: json['created_at'] != null
          ? DateTime.parse(json['created_at'] as String)
          : DateTime.now(),
      currency: json['currency'] as String? ?? 'EUR',
      defaultPhonePrefix: json['default_phone_prefix'] as String? ?? '+39',
      adminEmail: json['admin_email'] as String?,
      isSuspended: json['is_suspended'] == true || json['is_suspended'] == 1,
      suspensionMessage: json['suspension_message'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'slug': slug,
      'email': email,
      'phone': phone,
      'timezone': timezone,
      'created_at': createdAt.toIso8601String(),
      'currency': currency,
      'default_phone_prefix': defaultPhonePrefix,
      'admin_email': adminEmail,
      'is_suspended': isSuspended,
      'suspension_message': suspensionMessage,
    };
  }
}
--- FILE: lib/core/services/preferences_service.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

/// Provider per SharedPreferences (inizializzato in main.dart)
final sharedPreferencesProvider = Provider<SharedPreferences>((ref) {
  throw UnimplementedError(
    'sharedPreferencesProvider must be overridden in ProviderScope',
  );
});

/// Chiavi per le preferenze salvate.
/// Le preferenze sono salvate per business_id per supportare superadmin
/// che gestiscono pi√π business.
class PrefsKeys {
  /// Genera la chiave per staff filter mode per un business specifico
  static String staffFilterMode(int businessId) =>
      'staff_filter_mode_$businessId';

  /// Genera la chiave per selected staff IDs per un business specifico
  static String selectedStaffIds(int businessId) =>
      'selected_staff_ids_$businessId';

  /// Genera la chiave per current location ID per un business specifico
  static String currentLocationId(int businessId) =>
      'current_location_id_$businessId';

  /// Chiave per ultimo business visitato dal superadmin
  static const superadminLastBusinessId = 'superadmin_last_business_id';

  /// Chiave legacy (senza business_id) per migrazione
  static const legacyStaffFilterMode = 'staff_filter_mode';
  static const legacySelectedStaffIds = 'selected_staff_ids';
  static const legacyCurrentLocationId = 'current_location_id';
}

/// Service per gestire le preferenze utente.
/// Le preferenze sono salvate per business per supportare operatori
/// che lavorano su pi√π business (superadmin).
class PreferencesService {
  final SharedPreferences _prefs;

  PreferencesService(this._prefs);

  // ============================================
  // Staff Filter Mode
  // ============================================

  /// Ottiene il filtro staff salvato per il business.
  /// Cerca prima la chiave per business, poi fallback su legacy.
  String? getStaffFilterMode(int businessId) {
    // Prima prova chiave per business
    var value = _prefs.getString(PrefsKeys.staffFilterMode(businessId));
    if (value != null) return value;

    // Fallback su chiave legacy (migrazione)
    value = _prefs.getString(PrefsKeys.legacyStaffFilterMode);
    if (value != null) {
      // Migra alla nuova chiave
      setStaffFilterMode(businessId, value);
      _prefs.remove(PrefsKeys.legacyStaffFilterMode);
    }
    return value;
  }

  Future<void> setStaffFilterMode(int businessId, String mode) async {
    await _prefs.setString(PrefsKeys.staffFilterMode(businessId), mode);
  }

  // ============================================
  // Selected Staff IDs
  // ============================================

  /// Ottiene gli ID staff selezionati per il business.
  /// Gli ID vengono validati: ID <= 0 sono filtrati.
  List<int> getSelectedStaffIds(int businessId) {
    // Prima prova chiave per business
    var json = _prefs.getString(PrefsKeys.selectedStaffIds(businessId));

    // Fallback su chiave legacy
    if (json == null) {
      json = _prefs.getString(PrefsKeys.legacySelectedStaffIds);
      if (json != null) {
        // Migra alla nuova chiave
        _prefs.setString(PrefsKeys.selectedStaffIds(businessId), json);
        _prefs.remove(PrefsKeys.legacySelectedStaffIds);
      }
    }

    if (json == null || json.isEmpty) return [];

    // Parse sicuro: ignora valori non validi
    return json
        .split(',')
        .map((s) => int.tryParse(s.trim()) ?? 0)
        .where((id) => id > 0)
        .toList();
  }

  Future<void> setSelectedStaffIds(int businessId, Set<int> ids) async {
    if (ids.isEmpty) {
      // Rimuovi la chiave se vuota per risparmiare spazio
      await _prefs.remove(PrefsKeys.selectedStaffIds(businessId));
    } else {
      await _prefs.setString(
        PrefsKeys.selectedStaffIds(businessId),
        ids.join(','),
      );
    }
  }

  // ============================================
  // Current Location ID
  // ============================================

  /// Ottiene la location corrente salvata per il business.
  int? getCurrentLocationId(int businessId) {
    // Prima prova chiave per business
    var value = _prefs.getInt(PrefsKeys.currentLocationId(businessId));
    if (value != null) return value;

    // Fallback su chiave legacy
    value = _prefs.getInt(PrefsKeys.legacyCurrentLocationId);
    if (value != null) {
      // Migra alla nuova chiave
      setCurrentLocationId(businessId, value);
      _prefs.remove(PrefsKeys.legacyCurrentLocationId);
    }
    return value;
  }

  Future<void> setCurrentLocationId(int businessId, int id) async {
    await _prefs.setInt(PrefsKeys.currentLocationId(businessId), id);
  }

  // ============================================
  // Superadmin Last Business ID
  // ============================================

  /// Ottiene l'ultimo business visitato dal superadmin.
  int? getSuperadminLastBusinessId() {
    return _prefs.getInt(PrefsKeys.superadminLastBusinessId);
  }

  /// Salva l'ultimo business visitato dal superadmin.
  Future<void> setSuperadminLastBusinessId(int businessId) async {
    await _prefs.setInt(PrefsKeys.superadminLastBusinessId, businessId);
  }

  /// Rimuove l'ultimo business salvato (es. se il business viene eliminato).
  Future<void> clearSuperadminLastBusinessId() async {
    await _prefs.remove(PrefsKeys.superadminLastBusinessId);
  }

  // ============================================
  // Clear / Cleanup
  // ============================================

  /// Pulisce le preferenze per un business specifico.
  /// Utile quando il superadmin esce da un business.
  Future<void> clearForBusiness(int businessId) async {
    await _prefs.remove(PrefsKeys.staffFilterMode(businessId));
    await _prefs.remove(PrefsKeys.selectedStaffIds(businessId));
    await _prefs.remove(PrefsKeys.currentLocationId(businessId));
  }

  /// Pulisce tutte le preferenze (logout completo).
  Future<void> clearAll() async {
    // Rimuovi tutte le chiavi che iniziano con i nostri prefix
    final keys = _prefs.getKeys();
    for (final key in keys) {
      if (key.startsWith('staff_filter_mode') ||
          key.startsWith('selected_staff_ids') ||
          key.startsWith('current_location_id')) {
        await _prefs.remove(key);
      }
    }
  }
}

/// Provider per PreferencesService
final preferencesServiceProvider = Provider<PreferencesService>((ref) {
  final prefs = ref.watch(sharedPreferencesProvider);
  return PreferencesService(prefs);
});
--- FILE: lib/core/services/staff_planning_selector.dart ---
import '../models/staff_planning.dart';

/// Risultato della ricerca di un planning valido per una data.
sealed class PlanningLookupResult {
  const PlanningLookupResult();
}

/// Nessun planning trovato per la data.
/// Staff non disponibile in quella data.
class NoPlanningFound extends PlanningLookupResult {
  const NoPlanningFound();

  @override
  String toString() => 'NoPlanningFound()';
}

/// Planning valido trovato.
class PlanningFound extends PlanningLookupResult {
  final StaffPlanning planning;
  final WeekLabel weekLabel;
  final StaffPlanningWeekTemplate template;

  const PlanningFound({
    required this.planning,
    required this.weekLabel,
    required this.template,
  });

  @override
  String toString() =>
      'PlanningFound(planning: ${planning.id}, weekLabel: ${weekLabel.name})';
}

/// Errore: trovati pi√π planning validi (inconsistenza dati).
class MultiplePlanningsFound extends PlanningLookupResult {
  final List<StaffPlanning> plannings;
  final String message;

  const MultiplePlanningsFound({
    required this.plannings,
    required this.message,
  });

  @override
  String toString() => 'MultiplePlanningsFound(count: ${plannings.length})';
}

/// Servizio per la selezione del planning valido per una data.
///
/// Implementa le regole di STAFF_PLANNING_MODEL.md:
/// - Filtra planning con valid_from ‚â§ D ‚â§ valid_to (o valid_to null)
/// - Nessun planning ‚Üí staff non disponibile
/// - Pi√π di uno ‚Üí errore di consistenza
class StaffPlanningSelector {
  /// Trova il planning valido per uno staff in una data specifica.
  ///
  /// [staffId] ID dello staff.
  /// [date] Data per cui cercare il planning.
  /// [allPlannings] Tutti i planning disponibili (gi√† filtrati per staff se desiderato).
  ///
  /// Ritorna:
  /// - [NoPlanningFound] se non esiste planning valido per la data
  /// - [PlanningFound] se esiste esattamente un planning valido
  /// - [MultiplePlanningsFound] se esistono pi√π planning validi (errore dati)
  PlanningLookupResult findPlanningForDate({
    required int staffId,
    required DateTime date,
    required List<StaffPlanning> allPlannings,
  }) {
    // Filtra i planning per questo staff
    final staffPlannings = allPlannings
        .where((p) => p.staffId == staffId)
        .toList();

    // Filtra i planning validi per la data
    final validPlannings = staffPlannings
        .where((p) => p.isValidForDate(date))
        .toList();

    // Caso 1: nessun planning ‚Üí staff non disponibile
    if (validPlannings.isEmpty) {
      return const NoPlanningFound();
    }

    // Caso 2: pi√π di uno ‚Üí errore di consistenza
    if (validPlannings.length > 1) {
      return MultiplePlanningsFound(
        plannings: validPlannings,
        message:
            'Trovati ${validPlannings.length} planning validi per staff $staffId '
            'alla data ${_formatDate(date)}. '
            'Questo indica un errore nei dati (intervalli sovrapposti).',
      );
    }

    // Caso 3: esattamente un planning
    final planning = validPlannings.first;
    final weekLabel = planning.computeWeekLabel(date);
    final template = planning.getTemplateForDate(date);

    // Verifica che il template esista
    if (template == null) {
      // Questo non dovrebbe accadere se la validazione √® corretta,
      // ma gestiamo il caso per robustezza
      return const NoPlanningFound();
    }

    return PlanningFound(
      planning: planning,
      weekLabel: weekLabel,
      template: template,
    );
  }

  /// Ottiene gli slot disponibili per uno staff in una data specifica.
  ///
  /// Ritorna un Set vuoto se:
  /// - Non esiste planning valido per la data
  /// - Il giorno non ha slot configurati nel template
  ///
  /// Ritorna null se c'√® un errore di consistenza (pi√π planning).
  Set<int>? getSlotsForDate({
    required int staffId,
    required DateTime date,
    required List<StaffPlanning> allPlannings,
  }) {
    final result = findPlanningForDate(
      staffId: staffId,
      date: date,
      allPlannings: allPlannings,
    );

    return switch (result) {
      NoPlanningFound() => {},
      PlanningFound(template: final t) => t.getSlotsForDay(date.weekday),
      MultiplePlanningsFound() => null, // Errore, caller deve gestire
    };
  }

  /// Verifica se uno staff √® disponibile in una data.
  ///
  /// Ritorna true se:
  /// - Esiste un planning valido per la data
  /// - Il giorno ha almeno uno slot configurato
  bool isStaffAvailable({
    required int staffId,
    required DateTime date,
    required List<StaffPlanning> allPlannings,
  }) {
    final slots = getSlotsForDate(
      staffId: staffId,
      date: date,
      allPlannings: allPlannings,
    );

    return slots != null && slots.isNotEmpty;
  }

  /// Trova tutti i planning validi in un range di date per uno staff.
  ///
  /// Utile per visualizzare la pianificazione in un calendario.
  /// Ritorna una mappa: data ‚Üí PlanningLookupResult
  Map<DateTime, PlanningLookupResult> findPlanningsForRange({
    required int staffId,
    required DateTime startDate,
    required DateTime endDate,
    required List<StaffPlanning> allPlannings,
  }) {
    final results = <DateTime, PlanningLookupResult>{};

    var current = DateUtils.dateOnly(startDate);
    final end = DateUtils.dateOnly(endDate);

    while (!current.isAfter(end)) {
      results[current] = findPlanningForDate(
        staffId: staffId,
        date: current,
        allPlannings: allPlannings,
      );
      current = current.add(const Duration(days: 1));
    }

    return results;
  }

  /// Trova il prossimo planning valido dopo una data.
  ///
  /// Utile per mostrare quando uno staff diventer√† disponibile.
  /// Ritorna null se non esiste un planning futuro.
  StaffPlanning? findNextPlanning({
    required int staffId,
    required DateTime afterDate,
    required List<StaffPlanning> allPlannings,
  }) {
    final date = DateUtils.dateOnly(afterDate);

    // Filtra i planning per questo staff che iniziano dopo la data
    final futurePlannings = allPlannings
        .where((p) => p.staffId == staffId)
        .where((p) => DateUtils.dateOnly(p.validFrom).isAfter(date))
        .toList();

    if (futurePlannings.isEmpty) return null;

    // Ordina per validFrom e prendi il primo
    futurePlannings.sort((a, b) => a.validFrom.compareTo(b.validFrom));
    return futurePlannings.first;
  }

  String _formatDate(DateTime d) =>
      '${d.year.toString().padLeft(4, '0')}-'
      '${d.month.toString().padLeft(2, '0')}-'
      '${d.day.toString().padLeft(2, '0')}';
}
--- FILE: lib/core/widgets/app_bottom_sheet.dart ---
import 'dart:math' as math;

import 'package:flutter/material.dart';

/// Helper to show a modal bottom sheet with the app's default styling.
class AppBottomSheet {
  AppBottomSheet._();

  /// Altezza predefinita di tutti i bottom sheet (80% dello schermo).
  static const double defaultHeightFactor = 0.95;

  static Future<T?> show<T>({
    required BuildContext context,
    required WidgetBuilder builder,
    bool isScrollControlled = true,
    bool useSafeArea = true,
    bool useRootNavigator = true,
    EdgeInsetsGeometry? padding,

    /// Fraction of screen height (0.0 to 1.0). If provided, the bottom sheet
    /// will have a minimum height of this fraction of the screen.
    double? heightFactor = defaultHeightFactor,
  }) {
    final effectivePadding =
        padding ?? const EdgeInsets.symmetric(horizontal: 20, vertical: 16);
    return showModalBottomSheet<T>(
      context: context,
      isScrollControlled: isScrollControlled,
      backgroundColor: Colors.white,
      useSafeArea: useSafeArea,
      useRootNavigator: useRootNavigator,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (ctx) => AppBottomSheetContainer(
        padding: effectivePadding,
        heightFactor: heightFactor,
        child: builder(ctx),
      ),
    );
  }
}

/// Provides consistent padding, animation and handle for bottom sheet content.
class AppBottomSheetContainer extends StatelessWidget {
  const AppBottomSheetContainer({
    super.key,
    required this.child,
    this.padding = const EdgeInsets.symmetric(horizontal: 20, vertical: 16),
    this.showHandle = true,
    this.heightFactor,
  });

  final Widget child;
  final EdgeInsetsGeometry padding;
  final bool showHandle;

  /// If provided, the container will have a minimum height of this fraction
  /// of the screen height (0.0 to 1.0).
  final double? heightFactor;

  @override
  Widget build(BuildContext context) {
    final keyboardInset = MediaQuery.of(context).viewInsets.bottom;
    Widget content;

    // Apply height constraint if heightFactor is provided
    // Use SizedBox (not ConstrainedBox) to provide a finite height
    // so that Expanded children inside Column can work properly
    if (heightFactor != null) {
      // Ensure bottom padding is at least 50.0 to leave space above
      // system UI / controls and provide consistent spacing across sheets.
      final resolved = padding.resolve(Directionality.of(context));
      final effectivePadding = resolved.copyWith(
        bottom: math.max(resolved.bottom, 50.0),
      );
      final screenHeight = MediaQuery.of(context).size.height;
      final height = screenHeight * heightFactor!;
      content = SizedBox(
        height: height,
        child: Padding(padding: effectivePadding, child: child),
      );
    } else {
      // Quando heightFactor √® null, il contenuto si adatta all'altezza naturale
      // Usa solo il padding fornito senza forzare altezza minima
      content = Padding(padding: padding, child: child);
    }

    final body = showHandle
        ? Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const SizedBox(height: 8),
              Center(
                child: Container(
                  width: 40,
                  height: 4,
                  decoration: BoxDecoration(
                    color: Colors.grey.shade300,
                    borderRadius: BorderRadius.circular(4),
                  ),
                ),
              ),
              const SizedBox(height: 12),
              // Flexible permette al contenuto di adattarsi senza forzare
              // l'altezza massima della bottom sheet.
              Flexible(child: content),
            ],
          )
        : content;

    return AnimatedPadding(
      padding: EdgeInsets.only(bottom: keyboardInset),
      duration: const Duration(milliseconds: 180),
      curve: Curves.easeOut,
      child: body,
    );
  }
}
--- FILE: lib/core/widgets/reorder_toggle_button.dart ---
import 'package:flutter/material.dart';

/// Pulsante testuale con icona che riflette uno stato (attivo/inattivo).
class ReorderToggleButton extends StatelessWidget {
  final bool isActive;
  final VoidCallback onPressed;
  final String activeLabel;
  final String inactiveLabel;
  final IconData activeIcon;
  final IconData inactiveIcon;

  const ReorderToggleButton({
    super.key,
    required this.isActive,
    required this.onPressed,
    required this.activeLabel,
    required this.inactiveLabel,
    required this.activeIcon,
    required this.inactiveIcon,
  });

  @override
  Widget build(BuildContext context) {
    final icon = isActive ? activeIcon : inactiveIcon;
    final label = isActive ? activeLabel : inactiveLabel;

    return TextButton.icon(
      onPressed: onPressed,
      icon: Icon(icon),
      label: Text(label),
    );
  }
}
--- FILE: lib/core/widgets/no_scrollbar_behavior.dart ---
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';

/// Comportamento di scroll personalizzato per l‚Äôapp Agenda.
///
/// - Rimuove glow e scrollbar visibili.
/// - Mantiene la compatibilit√† con mouse, touch e trackpad.
/// - Usa una fisica permissiva che evita conflitti con PageView
///   e altri scroll orizzontali annidati.
///
/// Questo risolve i casi in cui il PageView esterno non riceve
/// mai il gesto perch√© la scroll view interna lo cattura completamente.
class NoScrollbarBehavior extends ScrollBehavior {
  const NoScrollbarBehavior();

  /// üîπ Disabilita completamente la scrollbar visiva.
  @override
  Widget buildScrollbar(
    BuildContext context,
    Widget child,
    ScrollableDetails details,
  ) {
    return child;
  }

  /// üîπ Abilita lo scroll con tutti i tipi di input
  /// (touch, mouse, trackpad, ecc.)
  @override
  Set<PointerDeviceKind> get dragDevices => {
    PointerDeviceKind.touch,
    PointerDeviceKind.mouse,
    PointerDeviceKind.trackpad,
  };

  /// üîπ Fisica dello scroll:
  /// - `BouncingScrollPhysics` ‚Üí effetto ‚Äúelastic‚Äù ai bordi (mobile-like).
  /// - `AlwaysScrollableScrollPhysics` ‚Üí consente lo scroll anche
  ///   quando non c‚Äô√® overflow, cos√¨ i gesti possono passare
  ///   al PageView esterno.
  ///
  /// Risultato: scroll fluido, niente blocchi, compatibile con nested scroll.
  @override
  ScrollPhysics getScrollPhysics(BuildContext context) =>
      const BouncingScrollPhysics(parent: AlwaysScrollableScrollPhysics());
}
--- FILE: lib/core/widgets/staff_picker_sheet.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/staff.dart';
import 'package:agenda_backend/core/widgets/app_dividers.dart';
import 'package:agenda_backend/core/widgets/app_bottom_sheet.dart';
import 'package:flutter/material.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Mostra un picker per la selezione dello staff.
/// Su mobile usa un bottom sheet, su desktop un dialog.
Future<int?> showStaffPickerSheet({
  required BuildContext context,
  required WidgetRef ref,
  required List<Staff> staff,
  required int? selectedId,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final l10n = context.l10n;

  if (formFactor != AppFormFactor.desktop) {
    return AppBottomSheet.show<int>(
      context: context,
      padding: EdgeInsets.zero,
      builder: (ctx) => SafeArea(
        child: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Padding(
                padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                child: Text(
                  l10n.selectStaffTitle,
                  style: Theme.of(
                    ctx,
                  ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600),
                ),
              ),
              const AppBottomSheetDivider(),
              StaffPickerContent(
                staff: staff,
                selectedId: selectedId,
                onSelected: (staffId) => Navigator.of(ctx).pop(staffId),
              ),
              const SizedBox(height: 8),
            ],
          ),
        ),
      ),
    );
  } else {
    return showDialog<int>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.selectStaffTitle),
        content: SizedBox(
          width: 300,
          child: ConstrainedBox(
            constraints: BoxConstraints(
              maxHeight: MediaQuery.of(ctx).size.height * 0.5,
            ),
            child: SingleChildScrollView(
              child: StaffPickerContent(
                staff: staff,
                selectedId: selectedId,
                onSelected: (staffId) => Navigator.of(ctx).pop(staffId),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

/// Content widget per la selezione dello staff (riutilizzabile)
class StaffPickerContent extends StatelessWidget {
  const StaffPickerContent({
    super.key,
    required this.staff,
    required this.selectedId,
    required this.onSelected,
  });

  final List<Staff> staff;
  final int? selectedId;
  final ValueChanged<int> onSelected;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    if (staff.isEmpty) {
      return Padding(
        padding: const EdgeInsets.all(24),
        child: Center(
          child: Text(
            l10n.noStaffAvailable,
            style: theme.textTheme.bodyMedium?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
        ),
      );
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        for (final member in staff)
          ListTile(
            leading: StaffCircleAvatar(
              height: 36,
              color: member.color,
              isHighlighted: member.id == selectedId,
              initials: member.initials,
            ),
            title: Text('${member.name} ${member.surname}'.trim()),
            trailing: member.id == selectedId
                ? Icon(Icons.check, color: theme.colorScheme.primary)
                : null,
            selected: member.id == selectedId,
            onTap: () => onSelected(member.id),
          ),
      ],
    );
  }
}
--- FILE: lib/core/widgets/app_buttons.dart ---
import 'package:flutter/material.dart';

/// Centralizes button styling so we can reuse consistent widgets across the app.
class AppButtonStyles {
  static const BorderRadiusGeometry defaultBorderRadius = BorderRadius.all(
    Radius.circular(10),
  );

  static const EdgeInsetsGeometry defaultPadding = EdgeInsets.symmetric(
    vertical: 14,
    horizontal: 16,
  );

  /// Larghezza standard per i pulsanti nei dialog (es. Annulla, Salva).
  static const double dialogButtonWidth = 120.0;

  /// Padding standard per i pulsanti nei dialog.
  static const EdgeInsetsGeometry dialogButtonPadding = EdgeInsets.symmetric(
    vertical: 12,
    horizontal: 16,
  );

  static ButtonStyle filled(
    BuildContext context, {
    Color? backgroundColor,
    Color? foregroundColor,
    EdgeInsetsGeometry? padding,
    BorderRadiusGeometry? borderRadius,
  }) {
    final colorScheme = Theme.of(context).colorScheme;
    return ElevatedButton.styleFrom(
      backgroundColor: backgroundColor ?? colorScheme.primary,
      foregroundColor: foregroundColor ?? colorScheme.onPrimary,
      padding: padding ?? defaultPadding,
      shape: RoundedRectangleBorder(
        borderRadius: borderRadius ?? defaultBorderRadius,
      ),
      textStyle: const TextStyle(fontWeight: FontWeight.w600),
    );
  }

  static ButtonStyle outlined(
    BuildContext context, {
    Color? borderColor,
    Color? foregroundColor,
    EdgeInsetsGeometry? padding,
    BorderRadiusGeometry? borderRadius,
  }) {
    final colorScheme = Theme.of(context).colorScheme;
    final resolvedBorderColor = borderColor ?? colorScheme.primary;
    return OutlinedButton.styleFrom(
      foregroundColor: foregroundColor ?? resolvedBorderColor,
      side: BorderSide(color: resolvedBorderColor, width: 1.4),
      padding: padding ?? defaultPadding,
      shape: RoundedRectangleBorder(
        borderRadius: borderRadius ?? defaultBorderRadius,
      ),
      textStyle: const TextStyle(fontWeight: FontWeight.w600),
    );
  }
}

class AppFilledButton extends StatelessWidget {
  const AppFilledButton({
    super.key,
    required this.onPressed,
    required this.child,
    this.backgroundColor,
    this.foregroundColor,
    this.padding,
    this.borderRadius,
    this.expand = false,
  });

  final VoidCallback? onPressed;
  final Widget child;
  final Color? backgroundColor;
  final Color? foregroundColor;
  final EdgeInsetsGeometry? padding;
  final BorderRadiusGeometry? borderRadius;
  final bool expand;

  @override
  Widget build(BuildContext context) {
    final button = ElevatedButton(
      onPressed: onPressed,
      style: AppButtonStyles.filled(
        context,
        backgroundColor: backgroundColor,
        foregroundColor: foregroundColor,
        padding: padding,
        borderRadius: borderRadius,
      ),
      child: child,
    );

    if (expand) {
      return SizedBox(width: double.infinity, child: button);
    }
    return button;
  }
}

class AppDangerButton extends StatelessWidget {
  const AppDangerButton({
    super.key,
    required this.onPressed,
    required this.child,
    this.expand = false,
    this.padding,
    this.borderRadius,
    this.backgroundColor,
  });

  final VoidCallback? onPressed;
  final Widget child;
  final bool expand;
  final EdgeInsetsGeometry? padding;
  final BorderRadiusGeometry? borderRadius;
  final Color? backgroundColor;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    return AppFilledButton(
      onPressed: onPressed,
      expand: expand,
      padding: padding,
      borderRadius: borderRadius,
      backgroundColor: backgroundColor ?? colorScheme.error,
      foregroundColor: colorScheme.onError,
      child: child,
    );
  }
}

class AppOutlinedActionButton extends StatelessWidget {
  const AppOutlinedActionButton({
    super.key,
    required this.onPressed,
    required this.child,
    this.borderColor,
    this.foregroundColor,
    this.padding,
    this.borderRadius,
    this.expand = false,
  });

  final VoidCallback? onPressed;
  final Widget child;
  final Color? borderColor;
  final Color? foregroundColor;
  final EdgeInsetsGeometry? padding;
  final BorderRadiusGeometry? borderRadius;
  final bool expand;

  @override
  Widget build(BuildContext context) {
    final button = OutlinedButton(
      onPressed: onPressed,
      style: AppButtonStyles.outlined(
        context,
        borderColor: borderColor,
        foregroundColor: foregroundColor,
        padding: padding,
        borderRadius: borderRadius,
      ),
      child: child,
    );

    if (expand) {
      return SizedBox(width: double.infinity, child: button);
    }
    return button;
  }
}
--- FILE: lib/core/widgets/app_dialogs.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

/// App-level dialog scaffolds to ensure consistent layout across features.
class AppFormDialog extends StatelessWidget {
  const AppFormDialog({
    super.key,
    required this.title,
    required this.content,
    required this.actions,
    this.contentPadding = const EdgeInsets.only(top: 8),
  });

  final Widget title;
  final Widget content;
  final List<Widget> actions;
  final EdgeInsetsGeometry contentPadding;

  @override
  Widget build(BuildContext context) {
    final base = Theme.of(context);
    final dialogTheme = base.copyWith(
      splashColor: Colors.transparent,
      highlightColor: Colors.transparent,
      splashFactory: NoSplash.splashFactory,
      switchTheme: base.switchTheme.copyWith(
        overlayColor: MaterialStateProperty.all(Colors.transparent),
        thumbColor: MaterialStateProperty.resolveWith((states) {
          if (states.contains(MaterialState.selected)) {
            return base.colorScheme.primary;
          }
          return null;
        }),
        trackColor: MaterialStateProperty.resolveWith((states) {
          if (states.contains(MaterialState.selected)) {
            return base.colorScheme.primary.withOpacity(0.35);
          }
          return null;
        }),
      ),
      radioTheme: base.radioTheme.copyWith(
        overlayColor: MaterialStateProperty.all(Colors.transparent),
        fillColor: MaterialStateProperty.resolveWith((states) {
          if (states.contains(MaterialState.selected)) {
            return base.colorScheme.primary;
          }
          return null;
        }),
      ),
    );
    return Theme(
      data: dialogTheme,
      child: CallbackShortcuts(
        bindings: <ShortcutActivator, VoidCallback>{
          SingleActivator(LogicalKeyboardKey.escape): () =>
              Navigator.of(context, rootNavigator: true).pop(),
        },
        child: Focus(
          autofocus: true,
          child: AlertDialog(
            title: title,
            content: SingleChildScrollView(
              padding: contentPadding,
              child: content,
            ),
            actions: actions,
          ),
        ),
      ),
    );
  }
}

Future<void> showAppConfirmDialog(
  BuildContext context, {
  required Widget title,
  Widget? content,
  required String confirmLabel,
  required VoidCallback onConfirm,
  String? cancelLabel,
  bool danger = false,
}) async {
  final colorScheme = Theme.of(context).colorScheme;
  return showDialog(
    context: context,
    builder: (_) {
      final base = Theme.of(context);
      final dialogTheme = base.copyWith(
        splashColor: Colors.transparent,
        highlightColor: Colors.transparent,
        splashFactory: NoSplash.splashFactory,
        switchTheme: base.switchTheme.copyWith(
          overlayColor: MaterialStateProperty.all(Colors.transparent),
          thumbColor: MaterialStateProperty.resolveWith((states) {
            if (states.contains(MaterialState.selected)) {
              return base.colorScheme.primary;
            }
            return null;
          }),
          trackColor: MaterialStateProperty.resolveWith((states) {
            if (states.contains(MaterialState.selected)) {
              return base.colorScheme.primary.withOpacity(0.35);
            }
            return null;
          }),
        ),
        radioTheme: base.radioTheme.copyWith(
          overlayColor: MaterialStateProperty.all(Colors.transparent),
        ),
      );
      return Theme(
        data: dialogTheme,
        child: CallbackShortcuts(
          bindings: <ShortcutActivator, VoidCallback>{
            SingleActivator(LogicalKeyboardKey.escape): () =>
                Navigator.of(context, rootNavigator: true).pop(),
            SingleActivator(LogicalKeyboardKey.enter): () {
              onConfirm();
              Navigator.of(context, rootNavigator: true).pop();
            },
          },
          child: Focus(
            autofocus: true,
            child: AlertDialog(
              title: title,
              content: content,
              actions: [
                TextButton(
                  onPressed: () =>
                      Navigator.of(context, rootNavigator: true).pop(),
                  child: Text(cancelLabel ?? 'Annulla'),
                ),
                ElevatedButton(
                  onPressed: () {
                    onConfirm();
                    Navigator.of(context, rootNavigator: true).pop();
                  },
                  style: danger
                      ? ElevatedButton.styleFrom(
                          backgroundColor: colorScheme.error,
                        )
                      : null,
                  child: Text(confirmLabel),
                ),
              ],
            ),
          ),
        ),
      );
    },
  );
}

Future<void> showAppInfoDialog(
  BuildContext context, {
  required Widget title,
  Widget? content,
  String? closeLabel,
}) {
  return showDialog(
    context: context,
    builder: (_) {
      final base = Theme.of(context);
      final dialogTheme = base.copyWith(
        splashColor: Colors.transparent,
        highlightColor: Colors.transparent,
        splashFactory: NoSplash.splashFactory,
        switchTheme: base.switchTheme.copyWith(
          overlayColor: MaterialStateProperty.all(Colors.transparent),
          thumbColor: MaterialStateProperty.resolveWith((states) {
            if (states.contains(MaterialState.selected)) {
              return base.colorScheme.primary;
            }
            return null;
          }),
          trackColor: MaterialStateProperty.resolveWith((states) {
            if (states.contains(MaterialState.selected)) {
              return base.colorScheme.primary.withOpacity(0.35);
            }
            return null;
          }),
        ),
        radioTheme: base.radioTheme.copyWith(
          overlayColor: MaterialStateProperty.all(Colors.transparent),
        ),
      );
      return Theme(
        data: dialogTheme,
        child: CallbackShortcuts(
          bindings: <ShortcutActivator, VoidCallback>{
            SingleActivator(LogicalKeyboardKey.escape): () =>
                Navigator.of(context, rootNavigator: true).pop(),
            SingleActivator(LogicalKeyboardKey.enter): () =>
                Navigator.of(context, rootNavigator: true).pop(),
          },
          child: Focus(
            autofocus: true,
            child: AlertDialog(
              title: title,
              content: content,
              actions: [
                TextButton(
                  onPressed: () =>
                      Navigator.of(context, rootNavigator: true).pop(),
                  child: Text(closeLabel ?? 'Chiudi'),
                ),
              ],
            ),
          ),
        ),
      );
    },
  );
}

/// Mostra un dialog di conferma e ritorna true se confermato, false altrimenti.
/// Utile per operazioni che richiedono conferma esplicita prima di procedere.
Future<bool> showConfirmDialog(
  BuildContext context, {
  required Widget title,
  Widget? content,
  required String confirmLabel,
  String? cancelLabel,
  bool danger = false,
}) async {
  final colorScheme = Theme.of(context).colorScheme;
  final result = await showDialog<bool>(
    context: context,
    barrierDismissible: false,
    builder: (_) {
      final base = Theme.of(context);
      final dialogTheme = base.copyWith(
        splashColor: Colors.transparent,
        highlightColor: Colors.transparent,
        splashFactory: NoSplash.splashFactory,
      );
      return Theme(
        data: dialogTheme,
        child: CallbackShortcuts(
          bindings: <ShortcutActivator, VoidCallback>{
            SingleActivator(LogicalKeyboardKey.escape): () =>
                Navigator.of(context, rootNavigator: true).pop(false),
          },
          child: Focus(
            autofocus: true,
            child: AlertDialog(
              title: title,
              content: content,
              actions: [
                TextButton(
                  onPressed: () =>
                      Navigator.of(context, rootNavigator: true).pop(false),
                  child: Text(cancelLabel ?? 'Annulla'),
                ),
                ElevatedButton(
                  onPressed: () =>
                      Navigator.of(context, rootNavigator: true).pop(true),
                  style: danger
                      ? ElevatedButton.styleFrom(
                          backgroundColor: colorScheme.error,
                        )
                      : null,
                  child: Text(confirmLabel),
                ),
              ],
            ),
          ),
        ),
      );
    },
  );
  return result ?? false;
}

/// Wrapper per dialog che gestisce automaticamente la chiusura con ESC.
/// Wrappa qualsiasi widget dialog per aggiungere supporto ESC.
class DismissibleDialog extends StatelessWidget {
  const DismissibleDialog({super.key, required this.child});

  final Widget child;

  @override
  Widget build(BuildContext context) {
    return CallbackShortcuts(
      bindings: <ShortcutActivator, VoidCallback>{
        SingleActivator(LogicalKeyboardKey.escape): () =>
            Navigator.of(context, rootNavigator: true).pop(),
      },
      child: Focus(autofocus: true, child: child),
    );
  }
}
--- FILE: lib/core/widgets/layout_config_auto_listener.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// 1. Importa il nuovo provider globale
import '../../app/providers/form_factor_provider.dart';
import '../../features/agenda/providers/layout_config_provider.dart';

class LayoutConfigAutoListener extends ConsumerStatefulWidget {
  final Widget child;

  const LayoutConfigAutoListener({super.key, required this.child});

  @override
  ConsumerState<LayoutConfigAutoListener> createState() =>
      _LayoutConfigAutoListenerState();
}

class _LayoutConfigAutoListenerState
    extends ConsumerState<LayoutConfigAutoListener>
    with WidgetsBindingObserver {
  Size? _lastSize;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);

    // üîπ FIX SAFARI DESKTOP: attendi un frame + piccolo delay
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      await Future.delayed(const Duration(milliseconds: 150));
      _updateLayoutConfig();
    });
  }

  @override
  void didChangeMetrics() {
    super.didChangeMetrics();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final newSize = MediaQuery.of(context).size;
      if (_lastSize == null || newSize != _lastSize) {
        _lastSize = newSize;
        _updateLayoutConfig();
      }
    });
  }

  void _updateLayoutConfig() {
    final size = MediaQuery.of(context).size;
    final screenWidth = size.width;
    final screenHeight = size.height;

    // üß© FIX: evita aggiornamenti con MediaQuery ancora non pronta
    if (screenWidth < 100 || screenHeight < 100) {
      return;
    }

    // üîπ Aggiorna layout per l‚Äôagenda
    ref.read(layoutConfigProvider.notifier).updateFromContext(context);

    // üîπ Aggiorna form factor globale (usato dalla shell)
    ref.read(formFactorProvider.notifier).update(screenWidth);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return widget.child;
  }
}
--- FILE: lib/core/widgets/adaptive_dropdown.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/core/widgets/app_bottom_sheet.dart';
import 'package:agenda_backend/core/widgets/desktop_popup_container.dart';
import 'dart:math' as math;

import 'package:flutter/material.dart';

import 'app_dividers.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// A dropdown item with a value and display widget.
class AdaptiveDropdownItem<T> {
  const AdaptiveDropdownItem({
    required this.value,
    required this.child,
    this.enabled = true,
  });

  final T value;
  final Widget child;
  final bool enabled;
}

/// Alignment for the desktop popup relative to the trigger.
enum AdaptiveDropdownAlignment { left, right }

/// Vertical position for the popup relative to the trigger.
enum AdaptiveDropdownVerticalPosition { below, above }

/// Adaptive dropdown that shows:
/// - A modal bottom sheet on mobile/tablet
/// - An anchored popup on desktop
class AdaptiveDropdown<T> extends ConsumerStatefulWidget {
  const AdaptiveDropdown({
    super.key,
    required this.items,
    required this.onSelected,
    required this.child,
    this.selectedValue,
    this.alignment = AdaptiveDropdownAlignment.left,
    this.verticalPosition = AdaptiveDropdownVerticalPosition.below,
    this.modalTitle,
    this.popupWidth,
    this.popupMaxHeight = 300,
    this.popupBorderRadius = 12.0,
    this.onOpened,
    this.onClosed,
    this.useRootNavigator = true,
    this.forcePopup = false,
    this.hideTriggerWhenOpen = false,
  });

  /// The list of items to display in the dropdown.
  final List<AdaptiveDropdownItem<T>> items;

  /// Called when an item is selected.
  final ValueChanged<T> onSelected;

  /// The trigger widget (typically a button or styled container).
  final Widget child;

  /// The currently selected value (for highlighting in the list).
  final T? selectedValue;

  /// Alignment of the popup on desktop (left or right).
  final AdaptiveDropdownAlignment alignment;

  /// Vertical position of the popup (above or below the trigger).
  final AdaptiveDropdownVerticalPosition verticalPosition;

  /// Optional title for the modal sheet on mobile/tablet.
  final String? modalTitle;

  /// Width of the popup on desktop. If null, matches the trigger width.
  final double? popupWidth;

  /// Maximum height of the popup on desktop.
  final double popupMaxHeight;

  /// Border radius of the popup on desktop.
  final double popupBorderRadius;

  /// Called when the dropdown is opened.
  final VoidCallback? onOpened;

  /// Called when the dropdown is closed.
  final VoidCallback? onClosed;

  /// Whether to push the mobile bottom sheet on the root navigator.
  final bool useRootNavigator;

  /// If true, always show popup instead of bottom sheet on mobile/tablet.
  final bool forcePopup;

  /// If true, hides the trigger widget when the popup is open.
  final bool hideTriggerWhenOpen;

  @override
  ConsumerState<AdaptiveDropdown<T>> createState() =>
      _AdaptiveDropdownState<T>();
}

class _AdaptiveDropdownState<T> extends ConsumerState<AdaptiveDropdown<T>> {
  final LayerLink _layerLink = LayerLink();
  OverlayEntry? _overlayEntry;
  bool _isOpen = false;

  @override
  void dispose() {
    _removeOverlay();
    super.dispose();
  }

  void _removeOverlay() {
    _overlayEntry?.remove();
    _overlayEntry = null;
    if (_isOpen) {
      _isOpen = false;
      widget.onClosed?.call();
      if (widget.hideTriggerWhenOpen) {
        setState(() {});
      }
    }
  }

  void _handleTap() {
    final formFactor = ref.read(formFactorProvider);

    if (widget.forcePopup || formFactor == AppFormFactor.desktop) {
      _showDesktopPopup();
    } else {
      _showMobileSheet();
    }
  }

  Future<void> _showMobileSheet() async {
    widget.onOpened?.call();
    _isOpen = true;

    final result = await AppBottomSheet.show<T>(
      context: context,
      heightFactor: null,
      builder: (ctx) => _MobileSheetContent<T>(
        items: widget.items,
        selectedValue: widget.selectedValue,
        title: widget.modalTitle,
        onSelected: (value) {
          Navigator.of(ctx).pop(value);
        },
      ),
      useRootNavigator: widget.useRootNavigator,
      padding: EdgeInsets.zero,
    );

    _isOpen = false;
    widget.onClosed?.call();

    if (result != null) {
      widget.onSelected(result);
    }
  }

  void _showDesktopPopup() {
    if (_overlayEntry != null) {
      _removeOverlay();
      return;
    }

    widget.onOpened?.call();
    _isOpen = true;
    if (widget.hideTriggerWhenOpen) {
      setState(() {});
    }

    final renderBox = context.findRenderObject() as RenderBox;
    final triggerSize = renderBox.size;

    _overlayEntry = OverlayEntry(
      builder: (overlayContext) => DesktopPopupContainer(
        link: _layerLink,
        triggerWidth: triggerSize.width,
        triggerHeight: triggerSize.height,
        popupWidth: widget.popupWidth,
        maxHeight: widget.popupMaxHeight,
        borderRadius: widget.popupBorderRadius,
        alignment: widget.alignment == AdaptiveDropdownAlignment.right
            ? PopupAlignment.right
            : PopupAlignment.left,
        verticalPosition:
            widget.verticalPosition == AdaptiveDropdownVerticalPosition.above
            ? PopupVerticalPosition.above
            : PopupVerticalPosition.below,
        onDismiss: _removeOverlay,
        child: _DesktopDropdownContent<T>(
          items: widget.items,
          selectedValue: widget.selectedValue,
          title: widget.modalTitle,
          onSelected: (value) {
            _removeOverlay();
            widget.onSelected(value);
          },
        ),
      ),
    );

    Overlay.of(context).insert(_overlayEntry!);
  }

  @override
  Widget build(BuildContext context) {
    return CompositedTransformTarget(
      link: _layerLink,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: _handleTap,
        child: Visibility(
          visible: !(widget.hideTriggerWhenOpen && _isOpen),
          maintainSize: true,
          maintainAnimation: true,
          maintainState: true,
          child: widget.child,
        ),
      ),
    );
  }
}

/// Mobile/tablet modal sheet content.
class _MobileSheetContent<T> extends StatelessWidget {
  const _MobileSheetContent({
    required this.items,
    required this.onSelected,
    this.selectedValue,
    this.title,
  });

  final List<AdaptiveDropdownItem<T>> items;
  final ValueChanged<T> onSelected;
  final T? selectedValue;
  final String? title;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        if (title != null) ...[
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 16, 16, 12),
            child: Text(
              title!,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          const AppBottomSheetDivider(),
        ],
        ...items.map((item) {
          final isSelected = item.value == selectedValue;
          return InkWell(
            onTap: item.enabled ? () => onSelected(item.value) : null,
            splashColor: Colors.transparent,
            highlightColor: Colors.transparent,
            child: Container(
              padding: const EdgeInsets.symmetric(vertical: 14, horizontal: 16),
              color: isSelected
                  ? colorScheme.primary.withOpacity(0.08)
                  : Colors.transparent,
              child: Row(
                children: [
                  Expanded(
                    child: DefaultTextStyle.merge(
                      style: TextStyle(
                        color: item.enabled
                            ? colorScheme.onSurface
                            : colorScheme.onSurface.withOpacity(0.38),
                        fontWeight: isSelected
                            ? FontWeight.w600
                            : FontWeight.normal,
                      ),
                      child: item.child,
                    ),
                  ),
                  if (isSelected)
                    Icon(Icons.check, size: 20, color: colorScheme.primary),
                ],
              ),
            ),
          );
        }),
        // Safe area padding for bottom with minimum inset
        SizedBox(
          height: math.max(MediaQuery.of(context).viewPadding.bottom, 15),
        ),
      ],
    );
  }
}

/// Content for the desktop dropdown popup.
class _DesktopDropdownContent<T> extends StatelessWidget {
  const _DesktopDropdownContent({
    required this.items,
    required this.onSelected,
    this.selectedValue,
    this.title,
    this.borderRadius = 12.0,
  });

  final List<AdaptiveDropdownItem<T>> items;
  final T? selectedValue;
  final String? title;
  final ValueChanged<T> onSelected;
  final double borderRadius;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        if (title != null) ...[
          Padding(
            padding: const EdgeInsets.fromLTRB(12, 10, 12, 6),
            child: Text(
              title!,
              style: theme.textTheme.labelMedium?.copyWith(
                color: colorScheme.onSurfaceVariant,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          const AppBottomSheetDivider(),
        ],
        Flexible(
          child: SingleChildScrollView(
            padding: EdgeInsets.only(top: title == null ? 4 : 0),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                for (int i = 0; i < items.length; i++)
                  _DesktopPopupItem<T>(
                    item: items[i],
                    isSelected: items[i].value == selectedValue,
                    isLast: i == items.length - 1,
                    borderRadius: borderRadius,
                    onTap: () => onSelected(items[i].value),
                  ),
              ],
            ),
          ),
        ),
      ],
    );
  }
}

/// Individual item in the desktop popup.
class _DesktopPopupItem<T> extends StatefulWidget {
  const _DesktopPopupItem({
    required this.item,
    required this.isSelected,
    required this.onTap,
    this.isLast = false,
    this.borderRadius = 12.0,
  });

  final AdaptiveDropdownItem<T> item;
  final bool isSelected;
  final VoidCallback onTap;
  final bool isLast;
  final double borderRadius;

  @override
  State<_DesktopPopupItem<T>> createState() => _DesktopPopupItemState<T>();
}

class _DesktopPopupItemState<T> extends State<_DesktopPopupItem<T>> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    final backgroundColor = widget.isSelected
        ? colorScheme.primary.withOpacity(0.08)
        : _isHovered
        ? colorScheme.primary.withOpacity(0.04)
        : Colors.transparent;

    final borderRadius = widget.isLast
        ? BorderRadius.only(
            bottomLeft: Radius.circular(widget.borderRadius),
            bottomRight: Radius.circular(widget.borderRadius),
          )
        : BorderRadius.zero;

    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      cursor: widget.item.enabled
          ? SystemMouseCursors.click
          : SystemMouseCursors.basic,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: widget.item.enabled ? widget.onTap : null,
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 100),
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
          decoration: BoxDecoration(
            color: backgroundColor,
            borderRadius: borderRadius,
          ),
          child: Row(
            children: [
              Expanded(
                child: DefaultTextStyle.merge(
                  style: TextStyle(
                    color: widget.item.enabled
                        ? colorScheme.onSurface
                        : colorScheme.onSurface.withOpacity(0.38),
                    fontWeight: widget.isSelected
                        ? FontWeight.w600
                        : FontWeight.normal,
                  ),
                  child: widget.item.child,
                ),
              ),
              if (widget.isSelected)
                Icon(Icons.check, size: 18, color: colorScheme.primary),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/core/widgets/app_switch.dart ---
import 'package:flutter/material.dart';

class AppSwitch extends StatelessWidget {
  const AppSwitch({super.key, required this.value, this.onChanged});

  final bool value;
  final ValueChanged<bool>? onChanged;

  @override
  Widget build(BuildContext context) {
    return Switch.adaptive(
      value: value,
      onChanged: onChanged,
      activeColor: Theme.of(context).colorScheme.primary,
    );
  }
}
--- FILE: lib/core/widgets/session_expired_listener.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../features/auth/providers/auth_provider.dart';
import '../network/network_providers.dart';
import 'app_dialogs.dart';

/// Widget che ascolta il provider sessionExpiredProvider e
/// esegue logout automatico quando la sessione scade.
class SessionExpiredListener extends ConsumerWidget {
  const SessionExpiredListener({super.key, required this.child});

  final Widget child;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    ref.listen<int>(sessionExpiredProvider, (previous, next) {
      if (previous != null && next > previous) {
        _handleSessionExpired(context, ref);
      }
    });

    return child;
  }

  void _handleSessionExpired(BuildContext context, WidgetRef ref) {
    // Esegui logout silenzioso (senza chiamata API, sessione gi√† scaduta)
    ref.read(authProvider.notifier).logout(silent: true);

    // Mostra dialog informativo
    if (context.mounted) {
      showAppInfoDialog(
        context,
        title: const Text('Sessione scaduta'),
        content: const Text(
          'La tua sessione √® scaduta. Effettua nuovamente il login per continuare.',
        ),
        closeLabel: 'OK',
      ).then((_) {
        // Redirect a login dopo chiusura dialog
        if (context.mounted) {
          context.go('/login');
        }
      });
    }
  }
}
--- FILE: lib/core/widgets/labeled_form_field.dart ---
import 'package:flutter/material.dart';

/// Widget che mostra una label sopra un campo form.
/// Usato per uniformare il layout dei form in tutta l'app.
class LabeledFormField extends StatelessWidget {
  const LabeledFormField({
    super.key,
    required this.label,
    required this.child,
    this.labelSpacing = 6.0,
  });

  /// Label del campo.
  final String label;

  /// Widget figlio (es. TextFormField, DropdownButtonFormField, ecc.).
  final Widget child;

  /// Spacing tra label e campo. Default 6.0.
  final double labelSpacing;

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(label, style: const TextStyle(fontWeight: FontWeight.w600)),
        SizedBox(height: labelSpacing),
        child,
      ],
    );
  }
}
--- FILE: lib/core/widgets/desktop_popup_container.dart ---
import 'package:flutter/material.dart';

/// Alignment for the desktop popup relative to the trigger.
enum PopupAlignment { left, right }

/// Vertical position for the popup relative to the trigger.
enum PopupVerticalPosition { below, above }

/// A reusable container for desktop anchored popups with consistent styling.
/// Provides: dismiss layer, animation, border, positioning.
class DesktopPopupContainer extends StatefulWidget {
  const DesktopPopupContainer({
    super.key,
    required this.link,
    required this.triggerWidth,
    required this.triggerHeight,
    required this.onDismiss,
    required this.child,
    this.popupWidth,
    this.maxHeight = 300,
    this.borderRadius = 12.0,
    this.alignment = PopupAlignment.left,
    this.verticalPosition = PopupVerticalPosition.below,
  });

  /// The layer link to anchor the popup to the trigger.
  final LayerLink link;

  /// The width of the trigger widget.
  final double triggerWidth;

  /// The height of the trigger widget.
  final double triggerHeight;

  /// Called when the popup should be dismissed.
  final VoidCallback onDismiss;

  /// The content of the popup.
  final Widget child;

  /// Width of the popup. If null, matches the trigger width.
  final double? popupWidth;

  /// Maximum height of the popup.
  final double maxHeight;

  /// Border radius of the popup.
  final double borderRadius;

  /// Alignment of the popup relative to the trigger.
  final PopupAlignment alignment;

  /// Vertical position of the popup (above or below the trigger).
  final PopupVerticalPosition verticalPosition;

  @override
  State<DesktopPopupContainer> createState() => _DesktopPopupContainerState();
}

class _DesktopPopupContainerState extends State<DesktopPopupContainer>
    with SingleTickerProviderStateMixin {
  late final AnimationController _animationController;
  late final Animation<double> _fadeAnimation;
  late final Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 150),
      vsync: this,
    );
    _fadeAnimation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeOut,
    );
    _scaleAnimation = Tween<double>(begin: 0.95, end: 1.0).animate(
      CurvedAnimation(parent: _animationController, curve: Curves.easeOut),
    );
    _animationController.forward();
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final effectiveWidth = widget.popupWidth ?? widget.triggerWidth;
    final isAbove = widget.verticalPosition == PopupVerticalPosition.above;

    // Horizontal offset based on alignment
    final horizontalOffset = widget.alignment == PopupAlignment.right
        ? widget.triggerWidth - effectiveWidth
        : 0.0;

    // Vertical offset and anchors based on position
    final Alignment targetAnchor;
    final Alignment followerAnchor;
    final EdgeInsets padding;

    if (isAbove) {
      // Popup appears above the trigger, growing downward
      targetAnchor = Alignment.topLeft;
      followerAnchor = Alignment.topLeft;
      padding = const EdgeInsets.only(bottom: 4);
    } else {
      targetAnchor = Alignment.bottomLeft;
      followerAnchor = Alignment.topLeft;
      padding = const EdgeInsets.only(top: 4);
    }

    final offset = Offset(horizontalOffset, 0);

    // Scale alignment for animation
    final scaleAlignment = isAbove
        ? (widget.alignment == PopupAlignment.right
              ? Alignment.bottomRight
              : Alignment.bottomLeft)
        : (widget.alignment == PopupAlignment.right
              ? Alignment.topRight
              : Alignment.topLeft);

    return Stack(
      children: [
        // Dismiss layer
        Positioned.fill(
          child: GestureDetector(
            behavior: HitTestBehavior.translucent,
            onTap: widget.onDismiss,
            child: const ColoredBox(color: Colors.transparent),
          ),
        ),
        // Popup
        CompositedTransformFollower(
          link: widget.link,
          showWhenUnlinked: false,
          offset: offset,
          targetAnchor: targetAnchor,
          followerAnchor: followerAnchor,
          child: FadeTransition(
            opacity: _fadeAnimation,
            child: ScaleTransition(
              scale: _scaleAnimation,
              alignment: scaleAlignment,
              child: Padding(
                padding: padding,
                child: Material(
                  elevation: 8,
                  color: colorScheme.surface,
                  borderRadius: BorderRadius.circular(widget.borderRadius),
                  clipBehavior: Clip.antiAlias,
                  child: Container(
                    width: effectiveWidth,
                    constraints: BoxConstraints(maxHeight: widget.maxHeight),
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(widget.borderRadius),
                      border: Border.all(color: Colors.grey.withOpacity(0.35)),
                    ),
                    child: widget.child,
                  ),
                ),
              ),
            ),
          ),
        ),
      ],
    );
  }
}
--- FILE: lib/core/widgets/phone_input_field.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../l10n/l10_extension.dart';
/// Lista dei prefissi telefonici pi√π comuni
const kPhonePrefixes = <PhonePrefix>[
  PhonePrefix('+39', 'IT', 'üáÆüáπ'),
  PhonePrefix('+1', 'US', 'üá∫üá∏'),
  PhonePrefix('+44', 'GB', 'üá¨üáß'),
  PhonePrefix('+49', 'DE', 'üá©üá™'),
  PhonePrefix('+33', 'FR', 'üá´üá∑'),
  PhonePrefix('+34', 'ES', 'üá™üá∏'),
  PhonePrefix('+41', 'CH', 'üá®üá≠'),
  PhonePrefix('+43', 'AT', 'üá¶üáπ'),
  PhonePrefix('+31', 'NL', 'üá≥üá±'),
  PhonePrefix('+32', 'BE', 'üáßüá™'),
  PhonePrefix('+351', 'PT', 'üáµüáπ'),
  PhonePrefix('+48', 'PL', 'üáµüá±'),
  PhonePrefix('+420', 'CZ', 'üá®üáø'),
  PhonePrefix('+385', 'HR', 'üá≠üá∑'),
  PhonePrefix('+386', 'SI', 'üá∏üáÆ'),
  PhonePrefix('+40', 'RO', 'üá∑üá¥'),
  PhonePrefix('+30', 'GR', 'üá¨üá∑'),
  PhonePrefix('+7', 'RU', 'üá∑üá∫'),
  PhonePrefix('+86', 'CN', 'üá®üá≥'),
  PhonePrefix('+81', 'JP', 'üáØüáµ'),
  PhonePrefix('+82', 'KR', 'üá∞üá∑'),
  PhonePrefix('+91', 'IN', 'üáÆüá≥'),
  PhonePrefix('+61', 'AU', 'üá¶üá∫'),
  PhonePrefix('+55', 'BR', 'üáßüá∑'),
  PhonePrefix('+52', 'MX', 'üá≤üáΩ'),
  PhonePrefix('+54', 'AR', 'üá¶üá∑'),
];

/// Modello per un prefisso telefonico
class PhonePrefix {
  final String code;
  final String countryCode;
  final String flag;

  const PhonePrefix(this.code, this.countryCode, this.flag);

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PhonePrefix &&
          runtimeType == other.runtimeType &&
          code == other.code;

  @override
  int get hashCode => code.hashCode;
}

/// Estrae prefisso e numero da un telefono completo
/// Ritorna (prefix, number)
(String prefix, String number) parsePhoneWithPrefix(
  String? phone, {
  String defaultPrefix = '+39',
}) {
  if (phone == null || phone.isEmpty) {
    return (defaultPrefix, '');
  }

  final cleaned = phone.replaceAll(RegExp(r'\s+'), '');

  // Cerca un prefisso conosciuto
  for (final p in kPhonePrefixes) {
    if (cleaned.startsWith(p.code)) {
      return (p.code, cleaned.substring(p.code.length));
    }
  }

  // Prova a estrarre un prefisso generico +XX o +XXX
  if (cleaned.startsWith('+')) {
    final match = RegExp(r'^\+\d{1,3}').firstMatch(cleaned);
    if (match != null) {
      return (match.group(0)!, cleaned.substring(match.end));
    }
  }

  // Nessun prefisso trovato, usa il default
  return (defaultPrefix, phone);
}

/// Combina prefisso e numero in un formato standard
String formatPhoneWithPrefix(String prefix, String number) {
  final cleanNumber = number.replaceAll(RegExp(r'\s+'), '');
  if (cleanNumber.isEmpty) return '';
  return '$prefix $cleanNumber';
}

/// Widget per input telefono con prefisso selezionabile
class PhoneInputField extends StatefulWidget {
  const PhoneInputField({
    super.key,
    this.labelText,
    required this.defaultPrefix,
    this.initialPhone,
    this.onChanged,
    this.validator,
    this.textInputAction = TextInputAction.next,
    this.isDense = false,
    this.useOutlineBorder = false,
  });

  /// Label opzionale. Se null, il campo non mostra label interna.
  final String? labelText;
  final String defaultPrefix;
  final String? initialPhone;
  final ValueChanged<String>? onChanged;
  final FormFieldValidator<String>? validator;
  final TextInputAction textInputAction;

  /// Se true, usa InputDecoration.isDense = true.
  final bool isDense;

  /// Se true, usa OutlineInputBorder invece del default UnderlineInputBorder.
  final bool useOutlineBorder;

  @override
  State<PhoneInputField> createState() => PhoneInputFieldState();
}

class PhoneInputFieldState extends State<PhoneInputField> {
  late String _selectedPrefix;
  late final TextEditingController _controller;

  @override
  void initState() {
    super.initState();
    final (prefix, number) = parsePhoneWithPrefix(
      widget.initialPhone,
      defaultPrefix: widget.defaultPrefix,
    );
    _selectedPrefix = prefix;
    _controller = TextEditingController(text: _formatNumber(number));
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  /// Ritorna il numero di telefono completo (prefisso + numero)
  String get fullPhone {
    final number = _controller.text.replaceAll(RegExp(r'\s+'), '');
    if (number.isEmpty) return '';
    return '$_selectedPrefix $number';
  }

  /// Ritorna solo il numero senza prefisso
  String get numberOnly => _controller.text.replaceAll(RegExp(r'\s+'), '');

  /// Ritorna il prefisso selezionato
  String get prefix => _selectedPrefix;

  String _formatNumber(String number) {
    final digits = number.replaceAll(RegExp(r'\s+'), '');
    if (digits.isEmpty) return '';

    final buffer = StringBuffer();
    for (var i = 0; i < digits.length; i++) {
      if (i == 3 || i == 6) {
        buffer.write(' ');
      }
      buffer.write(digits[i]);
    }
    return buffer.toString();
  }

  void _notifyChange() {
    widget.onChanged?.call(fullPhone);
  }

  @override
  Widget build(BuildContext context) {
    return TextFormField(
      controller: _controller,
      decoration: InputDecoration(
        labelText: widget.labelText,
        isDense: widget.isDense,
        border: widget.useOutlineBorder ? const OutlineInputBorder() : null,
        prefixIcon: _PrefixDropdown(
          selectedPrefix: _selectedPrefix,
          onChanged: (newPrefix) {
            setState(() => _selectedPrefix = newPrefix);
            _notifyChange();
          },
        ),
      ),
      keyboardType: TextInputType.phone,
      textInputAction: widget.textInputAction,
      inputFormatters: [
        FilteringTextInputFormatter.allow(RegExp(r'[0-9\s]')),
        _PhoneNumberFormatter(),
      ],
      onChanged: (_) => _notifyChange(),
      validator:
          widget.validator ??
          (v) {
            final t = v?.trim().replaceAll(RegExp(r'\s+'), '') ?? '';
            if (t.isEmpty) return null; // optional
            if (!RegExp(r'^\d{6,15}$').hasMatch(t)) {
              return context.l10n.validationInvalidPhone;
            }
            return null;
          },
    );
  }
}

/// Dropdown per selezionare il prefisso
class _PrefixDropdown extends StatelessWidget {
  const _PrefixDropdown({
    required this.selectedPrefix,
    required this.onChanged,
  });

  final String selectedPrefix;
  final ValueChanged<String> onChanged;

  @override
  Widget build(BuildContext context) {
    // Trova il prefisso corrente nella lista, altrimenti usa il primo
    final currentPrefix = kPhonePrefixes.firstWhere(
      (p) => p.code == selectedPrefix,
      orElse: () => kPhonePrefixes.first,
    );

    return Padding(
      padding: const EdgeInsets.only(left: 12),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: currentPrefix.code,
          isDense: true,
          items: kPhonePrefixes.map((p) {
            return DropdownMenuItem<String>(
              value: p.code,
              child: Text(
                '${p.flag} ${p.code}',
                style: const TextStyle(fontSize: 14),
              ),
            );
          }).toList(),
          onChanged: (value) {
            if (value != null) {
              onChanged(value);
            }
          },
          selectedItemBuilder: (context) {
            return kPhonePrefixes.map((p) {
              return Center(
                child: Text(
                  '${p.flag} ${p.code}',
                  style: const TextStyle(fontSize: 14),
                ),
              );
            }).toList();
          },
        ),
      ),
    );
  }
}

/// Formatta il numero di telefono aggiungendo spazi per leggibilit√†
class _PhoneNumberFormatter extends TextInputFormatter {
  @override
  TextEditingValue formatEditUpdate(
    TextEditingValue oldValue,
    TextEditingValue newValue,
  ) {
    final digitsOnly = newValue.text.replaceAll(RegExp(r'\s+'), '');

    if (digitsOnly.isEmpty) {
      return newValue.copyWith(text: '');
    }

    final buffer = StringBuffer();
    for (var i = 0; i < digitsOnly.length; i++) {
      if (i == 3 || i == 6) {
        buffer.write(' ');
      }
      buffer.write(digitsOnly[i]);
    }

    final formatted = buffer.toString();

    return TextEditingValue(
      text: formatted,
      selection: TextSelection.collapsed(offset: formatted.length),
    );
  }
}
--- FILE: lib/core/widgets/app_dividers.dart ---
import 'package:flutter/material.dart';

/// Divider standard per bottom sheet (stile coerente con creazione appuntamento).
class AppBottomSheetDivider extends StatelessWidget {
  const AppBottomSheetDivider({super.key});

  @override
  Widget build(BuildContext context) {
    return const Divider(height: 1, thickness: 0.5, color: Color(0x1F000000));
  }
}
--- FILE: lib/core/widgets/reorder_toggle_panel.dart ---
import 'package:flutter/material.dart';

/// Container che dispone una serie di widget con spacing orizzontale e wrap
/// automatico per evitare overflow su schermi stretti.
class ReorderTogglePanel extends StatelessWidget {
  final bool isWide;
  final List<Widget> children;

  const ReorderTogglePanel({
    super.key,
    required this.isWide,
    required this.children,
  });

  @override
  Widget build(BuildContext context) {
    return Wrap(spacing: 8, runSpacing: 8, children: children);
  }
}
--- FILE: lib/core/validation/staff_planning_validator.dart ---
import '../models/staff_planning.dart';

/// Risultato della validazione di uno StaffPlanning.
class StaffPlanningValidationResult {
  final bool isValid;
  final List<String> errors;
  final List<String> warnings;

  const StaffPlanningValidationResult({
    required this.isValid,
    this.errors = const [],
    this.warnings = const [],
  });

  factory StaffPlanningValidationResult.valid({
    List<String> warnings = const [],
  }) => StaffPlanningValidationResult(isValid: true, warnings: warnings);

  factory StaffPlanningValidationResult.invalid(
    List<String> errors, {
    List<String> warnings = const [],
  }) => StaffPlanningValidationResult(
    isValid: false,
    errors: errors,
    warnings: warnings,
  );
}

/// Validatore per StaffPlanning.
///
/// Implementa le regole definite in STAFF_PLANNING_MODEL.md:
/// - Obbligatori: valid_from, type, template A (e B se biweekly)
/// - valid_to ‚â• valid_from quando presente
/// - Non sovrapposizione intervalli per stesso staff
/// - Template coerenti con type
class StaffPlanningValidator {
  /// Valida un planning per creazione.
  ///
  /// [planning] il nuovo planning da validare.
  /// [existingPlannings] tutti i planning esistenti per lo stesso staff.
  StaffPlanningValidationResult validateForCreate(
    StaffPlanning planning,
    List<StaffPlanning> existingPlannings,
  ) {
    final errors = <String>[];
    final warnings = <String>[];

    // 1. Validazioni base
    _validateBasicRules(planning, errors, warnings);

    // 2. Validazioni template
    _validateTemplates(planning, errors);

    // 3. Validazione non sovrapposizione con planning esistenti
    _validateNoOverlap(planning, existingPlannings, null, errors);

    return errors.isEmpty
        ? StaffPlanningValidationResult.valid(warnings: warnings)
        : StaffPlanningValidationResult.invalid(errors, warnings: warnings);
  }

  /// Valida un planning per aggiornamento.
  ///
  /// [planning] il planning modificato.
  /// [existingPlannings] tutti i planning esistenti per lo stesso staff.
  /// [originalPlanning] il planning originale prima delle modifiche.
  StaffPlanningValidationResult validateForUpdate(
    StaffPlanning planning,
    List<StaffPlanning> existingPlannings,
    StaffPlanning originalPlanning,
  ) {
    final errors = <String>[];
    final warnings = <String>[];

    // 1. Validazioni base
    _validateBasicRules(planning, errors, warnings);

    // 2. Validazioni template
    _validateTemplates(planning, errors);

    // 3. Validazione non sovrapposizione (escludendo s√© stesso)
    _validateNoOverlap(
      planning,
      existingPlannings,
      originalPlanning.id,
      errors,
    );

    // 4. Warning per cambio type senza adeguare template
    if (originalPlanning.type != planning.type) {
      if (planning.type == StaffPlanningType.biweekly &&
          planning.templateB == null) {
        errors.add('Cambio a biweekly richiede template B');
      }
    }

    // 5. Warning per shift validFrom in biweekly (altera parit√† A/B)
    if (planning.type == StaffPlanningType.biweekly &&
        originalPlanning.validFrom != planning.validFrom) {
      warnings.add(
        'Spostare valid_from in un planning biweekly altera la parit√† del ciclo A/B '
        'per tutto l\'intervallo',
      );
    }

    return errors.isEmpty
        ? StaffPlanningValidationResult.valid(warnings: warnings)
        : StaffPlanningValidationResult.invalid(errors, warnings: warnings);
  }

  /// Validazioni base comuni.
  void _validateBasicRules(
    StaffPlanning planning,
    List<String> errors,
    List<String> warnings,
  ) {
    // valid_to ‚â• valid_from quando presente
    if (planning.validTo != null) {
      final from = DateUtils.dateOnly(planning.validFrom);
      final to = DateUtils.dateOnly(planning.validTo!);
      if (to.isBefore(from)) {
        errors.add('valid_to non pu√≤ essere precedente a valid_from');
      }
    }
  }

  /// Validazioni sui template.
  void _validateTemplates(StaffPlanning planning, List<String> errors) {
    // Template A obbligatorio
    if (planning.templateA == null) {
      errors.add('Template A √® obbligatorio');
      return;
    }

    // Per biweekly, template B obbligatorio
    if (planning.type == StaffPlanningType.biweekly &&
        planning.templateB == null) {
      errors.add('Template B √® obbligatorio per pianificazione biweekly');
    }

    // Validazione formato slot in ogni template
    for (final template in planning.templates) {
      _validateTemplateSlots(template, errors);
    }
  }

  /// Validazione slot di un template.
  void _validateTemplateSlots(
    StaffPlanningWeekTemplate template,
    List<String> errors,
  ) {
    for (final entry in template.daySlots.entries) {
      final day = entry.key;
      final slots = entry.value;

      // day_of_week deve essere 1-7
      if (day < 1 || day > 7) {
        errors.add('day_of_week invalido: $day (deve essere 1-7)');
      }

      // Slot devono essere indici validi (0-95 per slot da 15 min in 24h)
      for (final slot in slots) {
        if (slot < 0 || slot > 95) {
          errors.add(
            'Slot index invalido: $slot nel giorno $day '
            '(deve essere 0-95 per slot da 15 minuti)',
          );
        }
      }
    }
  }

  /// Validazione non sovrapposizione intervalli.
  ///
  /// [planning] planning da validare.
  /// [existingPlannings] planning esistenti per lo stesso staff.
  /// [excludeId] ID da escludere (per update).
  void _validateNoOverlap(
    StaffPlanning planning,
    List<StaffPlanning> existingPlannings,
    int? excludeId,
    List<String> errors,
  ) {
    for (final existing in existingPlannings) {
      // Salta s√© stesso in caso di update
      if (excludeId != null && existing.id == excludeId) continue;

      // Salta planning di altri staff
      if (existing.staffId != planning.staffId) continue;

      if (_intervalsOverlap(planning, existing)) {
        final existingRange = _formatDateRange(existing);
        errors.add('Sovrapposizione con planning esistente: $existingRange');
      }
    }
  }

  /// Verifica se due intervalli si sovrappongono.
  ///
  /// Usa intervalli chiusi-chiusi: [validFrom, validTo].
  /// Due planning con valid_to = X e valid_from = X sono sovrapposti.
  /// Contiguit√† ammessa solo se new.valid_from = existing.valid_to + 1.
  bool _intervalsOverlap(StaffPlanning a, StaffPlanning b) {
    final aFrom = DateUtils.dateOnly(a.validFrom);
    final aTo = a.validTo != null ? DateUtils.dateOnly(a.validTo!) : null;

    final bFrom = DateUtils.dateOnly(b.validFrom);
    final bTo = b.validTo != null ? DateUtils.dateOnly(b.validTo!) : null;

    // Caso 1: entrambi hanno valid_to
    if (aTo != null && bTo != null) {
      // Non sovrapposti se uno finisce prima che l'altro inizi
      // MA: dato che sono chiusi-chiusi, aTo deve essere PRIMA di bFrom (non uguale)
      // Contiguit√†: aTo + 1 giorno = bFrom ‚Üí OK, non overlap
      return !_isBefore(aTo, bFrom) && !_isBefore(bTo, aFrom);
    }

    // Caso 2: a √® open-ended (aTo = null)
    if (aTo == null && bTo != null) {
      // a parte da aFrom e va all'infinito
      // overlap se bTo >= aFrom
      return !bTo.isBefore(aFrom);
    }

    // Caso 3: b √® open-ended (bTo = null)
    if (aTo != null && bTo == null) {
      // b parte da bFrom e va all'infinito
      // overlap se aTo >= bFrom
      return !aTo.isBefore(bFrom);
    }

    // Caso 4: entrambi open-ended ‚Üí sempre overlap (se stesso staff)
    return true;
  }

  /// Verifica se a √® strettamente prima di b (non contiguit√†).
  ///
  /// Per intervalli chiusi-chiusi:
  /// - a finisce il giorno X, b inizia il giorno X ‚Üí OVERLAP
  /// - a finisce il giorno X, b inizia il giorno X+1 ‚Üí NO OVERLAP (contigui)
  bool _isBefore(DateTime aEnd, DateTime bStart) {
    // aEnd deve essere almeno 1 giorno prima di bStart per non overlap
    final nextDay = aEnd.add(const Duration(days: 1));
    return !nextDay.isAfter(bStart);
  }

  String _formatDateRange(StaffPlanning planning) {
    final from = _formatDate(planning.validFrom);
    final to = planning.validTo != null ? _formatDate(planning.validTo!) : '‚àû';
    return '[$from, $to]';
  }

  String _formatDate(DateTime d) =>
      '${d.year.toString().padLeft(4, '0')}-'
      '${d.month.toString().padLeft(2, '0')}-'
      '${d.day.toString().padLeft(2, '0')}';
}
--- FILE: lib/app/app_constants.dart ---
/// Flag applicativo per controllare se lo staff pu√≤ essere associato a pi√π
/// sedi contemporaneamente. Quando √® `false`, il form di creazione/modifica
/// consente una sola sede per membro del team e forza la selezione singola.
const bool kAllowStaffMultiLocationSelection = false;
--- FILE: lib/app/router.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../core/l10n/l10_extension.dart';
// Importa le nuove schermate
import '../features/agenda/presentation/agenda_screen.dart';
import '../features/auth/presentation/profile_screen.dart';
import '../features/auth/presentation/reset_password_screen.dart';
import '../features/clients/presentation/clients_screen.dart';
import '../features/services/presentation/services_screen.dart';
import '../features/staff/presentation/staff_week_overview_screen.dart';
import '../features/staff/presentation/team_screen.dart';
// Importa la nostra "Shell"
import 'scaffold_with_navigation.dart';

// 1. Definiamo una chiave globale per la nostra Shell (necessaria)
final _rootNavigatorKey = GlobalKey<NavigatorState>();

/// üîπ Router globale dell‚Äôapp
final GoRouter appRouter = GoRouter(
  initialLocation: '/agenda',
  navigatorKey: _rootNavigatorKey,

  debugLogDiagnostics: kDebugMode,

  errorBuilder: (context, state) => Scaffold(
    appBar: AppBar(title: Text(context.l10n.errorTitle)),
    body: Center(
      child: Text(
        context.l10n.errorNotFound(state.uri.path),
        style: const TextStyle(color: Colors.redAccent),
      ),
    ),
  ),

  // 2. Definiamo la nostra navigazione con `StatefulShellRoute`
  routes: [
    StatefulShellRoute.indexedStack(
      builder: (context, state, navigationShell) {
        return ScaffoldWithNavigation(navigationShell: navigationShell);
      },

      branches: [
        // --- Ramo 0: Agenda ---
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/agenda',
              name: 'agenda',
              builder: (BuildContext context, GoRouterState state) {
                final q = state.uri.queryParameters['clientId'];
                final initialClientId = q == null ? null : int.tryParse(q);
                return AgendaScreen(initialClientId: initialClientId);
              },
            ),
          ],
        ),

        // --- Ramo 1: Clienti ---
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/clienti',
              name: 'clienti',
              builder: (BuildContext context, GoRouterState state) =>
                  const ClientsScreen(),
            ),
          ],
        ),

        // --- Ramo 2: Servizi ---
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/servizi',
              name: 'servizi',
              builder: (BuildContext context, GoRouterState state) =>
                  const ServicesScreen(),
            ),
          ],
        ),

        // --- Ramo 3: Staff ---
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/staff',
              name: 'staff',
              builder: (BuildContext context, GoRouterState state) =>
                  const TeamScreen(),
            ),
          ],
        ),
      ],
    ),
    GoRoute(
      path: '/staff-availability',
      name: 'staff-availability',
      parentNavigatorKey: _rootNavigatorKey,
      builder: (BuildContext context, GoRouterState state) =>
          const StaffWeekOverviewScreen(),
    ),
    // Route per profilo utente
    GoRoute(
      path: '/profilo',
      name: 'profilo',
      parentNavigatorKey: _rootNavigatorKey,
      builder: (BuildContext context, GoRouterState state) =>
          const ProfileScreen(),
    ),
    // Route per reset password (da email invito)
    GoRoute(
      path: '/reset-password/:token',
      name: 'reset-password',
      parentNavigatorKey: _rootNavigatorKey,
      builder: (BuildContext context, GoRouterState state) {
        final token = state.pathParameters['token']!;
        return ResetPasswordScreen(token: token);
      },
    ),
  ],
);
--- FILE: lib/app/scaffold_with_navigation.dart ---
// Cleaned duplicate header
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/widgets/agenda_control_components.dart';
import 'package:agenda_backend/app/widgets/agenda_staff_filter_selector.dart';
import 'package:agenda_backend/app/widgets/top_controls.dart';
import 'package:agenda_backend/app/widgets/user_menu_button.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/widgets/agenda_dividers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:intl/intl.dart';

import '../core/l10n/l10_extension.dart';
import '../core/models/location.dart';
import '../core/widgets/adaptive_dropdown.dart';
import '../core/widgets/app_bottom_sheet.dart';
import '../core/widgets/app_buttons.dart';
import '../features/agenda/presentation/dialogs/add_block_dialog.dart';
import '../features/agenda/presentation/widgets/agenda_top_controls.dart';
import '../features/agenda/presentation/widgets/booking_dialog.dart';
import '../features/agenda/providers/date_range_provider.dart';
import '../features/agenda/providers/layout_config_provider.dart';
import '../features/agenda/providers/location_providers.dart';
import '../features/auth/providers/auth_provider.dart';
import '../features/business/presentation/business_list_screen.dart';
import '../features/clients/presentation/dialogs/client_edit_dialog.dart';
import '../features/clients/providers/clients_providers.dart';
import '../features/services/presentation/dialogs/category_dialog.dart';
import '../features/services/presentation/dialogs/service_dialog.dart';
import '../features/services/providers/services_provider.dart';
import '../features/services/providers/services_reorder_provider.dart';
import '../features/staff/presentation/dialogs/location_dialog.dart';
import '../features/staff/presentation/dialogs/staff_dialog.dart';
import '../features/staff/providers/staff_providers.dart';
import '../features/staff/providers/staff_reorder_provider.dart';

Widget _buildAddButtonContent({
  required bool showLabelEffective,
  required bool compact,
  required String label,
  required Color onContainer,
}) {
  if (compact) {
    return showLabelEffective
        ? Text(
            label,
            style: TextStyle(color: onContainer, fontWeight: FontWeight.w600),
          )
        : Icon(Icons.add_outlined, size: 22, color: onContainer);
  }
  if (!showLabelEffective) {
    return Icon(Icons.add_outlined, size: 22, color: onContainer);
  }
  return Row(
    mainAxisSize: MainAxisSize.min,
    children: [
      Icon(Icons.add_outlined, size: 22, color: onContainer),
      const SizedBox(width: 8),
      Text(
        label,
        style: TextStyle(color: onContainer, fontWeight: FontWeight.w600),
      ),
    ],
  );
}

class ScaffoldWithNavigation extends ConsumerWidget {
  const ScaffoldWithNavigation({super.key, required this.navigationShell});

  final StatefulNavigationShell navigationShell;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final formFactor = ref.watch(formFactorProvider);
    final isAgenda = navigationShell.currentIndex == 0;
    final isClients = navigationShell.currentIndex == 1;
    final isServices = navigationShell.currentIndex == 2;
    final isStaff = navigationShell.currentIndex == 3;
    final agendaDate = ref.watch(agendaDateProvider);
    final today = DateUtils.dateOnly(DateTime.now());
    final isToday = DateUtils.isSameDay(agendaDate, today);
    final isPast = agendaDate.isBefore(today);
    final user = ref.watch(authProvider).user;
    final isSuperadmin = user?.isSuperadmin ?? false;

    final destinations = _ScaffoldWithNavigationHelpers.getDestinations(
      context,
      isSuperadmin: isSuperadmin,
    );

    // Quando non siamo su oggi, mostra freccia per tornare a oggi
    // Freccia destra se nel passato (vai avanti), sinistra se nel futuro (torna indietro)
    final resolvedDestinations = isAgenda && !isToday
        ? [
            NavigationDestination(
              iconData: isPast ? Icons.arrow_forward : Icons.arrow_back,
              selectedIconData: isPast ? Icons.arrow_forward : Icons.arrow_back,
              label: context.l10n.agendaToday,
            ),
            ...destinations.skip(1),
          ]
        : destinations;

    if (formFactor == AppFormFactor.desktop) {
      final layoutConfig = ref.watch(layoutConfigProvider);
      final dividerColor = Theme.of(context).dividerColor;
      const dividerThickness = 1.0;
      final railDestinations =
          _ScaffoldWithNavigationHelpers.toRailDestinations(
            resolvedDestinations,
          );

      final isTablet = formFactor == AppFormFactor.tablet;

      // Azioni specifiche per tab (menu utente √® nella rail)
      List<Widget> buildActions() {
        final List<Widget> actions = [];
        if (isAgenda) {
          actions.add(const _AgendaAddAction());
        } else if (isServices) {
          actions.add(const _ServicesAddAction());
        } else if (isClients) {
          actions.add(const _ClientsAddAction());
        } else if (isStaff) {
          actions.add(const _TeamAddAction());
        }
        return actions;
      }

      return Scaffold(
        appBar: AppBar(
          titleSpacing: isTablet && isAgenda
              ? 4
              : NavigationToolbar.kMiddleSpacing,
          title: isAgenda ? const AgendaTopControls() : const SizedBox.shrink(),
          centerTitle: false,
          toolbarHeight: 76,
          actionsPadding: const EdgeInsets.only(right: 6),
          actions: buildActions(),
        ),
        body: Row(
          children: [
            Theme(
              data: Theme.of(context).copyWith(
                splashColor: Colors.transparent,
                highlightColor: Colors.transparent,
                hoverColor: Colors.transparent,
              ),
              child: NavigationRail(
                selectedIndex: navigationShell.currentIndex,
                onDestinationSelected: (index) =>
                    _handleNavTap(context, index, ref),
                labelType: NavigationRailLabelType.none,
                useIndicator: false, // disattiva highlight di sistema su tap
                // BusinessSelector rimosso - superadmin usa /businesses
                destinations: railDestinations,
              ),
            ),
            _RailDivider(
              topInset: layoutConfig.headerHeight,
              color: dividerColor,
              thickness: dividerThickness,
            ),
            Expanded(child: navigationShell),
          ],
        ),
      );
    }

    final isTablet = formFactor == AppFormFactor.tablet;
    final isMobile = formFactor == AppFormFactor.mobile;
    // Su mobile e tablet il date switcher √® in basso, non nell'AppBar
    final showBottomDateSwitcher = isAgenda && (isTablet || isMobile);
    final bottomNavColor =
        Theme.of(context).bottomNavigationBarTheme.backgroundColor ??
        Theme.of(context).colorScheme.surface;

    // Azioni specifiche per tab (menu utente √® nella BNB)
    List<Widget> buildMobileActions() {
      final List<Widget> actions = [];
      if (isAgenda) {
        if (formFactor == AppFormFactor.mobile) {
          actions.add(
            const _AgendaFilterActions(padding: EdgeInsets.only(left: 8)),
          );
        }
        actions.add(const _AgendaAddAction(compact: true));
      } else if (isServices) {
        actions.add(const _ServicesAddAction(compact: true));
      } else if (isClients) {
        actions.add(const _ClientsAddAction(compact: true));
      } else if (isStaff) {
        actions.add(const _TeamAddAction(compact: true));
      }
      return actions;
    }

    return Scaffold(
      appBar: AppBar(
        toolbarHeight: isTablet ? 76 : 64,
        titleSpacing: isAgenda ? 4 : NavigationToolbar.kMiddleSpacing,
        title: isAgenda
            ? const AgendaTopControls(compact: true)
            : const SizedBox.shrink(),
        centerTitle: false,
        actionsPadding: const EdgeInsets.only(right: 6),
        actions: buildMobileActions(),
      ),
      body: navigationShell,
      bottomNavigationBar: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (showBottomDateSwitcher) ...[
            const AgendaHorizontalDivider(),
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 8.0),
              child: const _MobileAgendaDateSwitcher(),
            ),
          ],
          ColoredBox(
            color: bottomNavColor,
            child: SafeArea(
              top: false,
              left: false,
              right: false,
              minimum: const EdgeInsets.only(bottom: 15),
              child: BottomNavigationBar(
                currentIndex: navigationShell.currentIndex,
                onTap: (index) => _handleNavTap(context, index, ref),
                type: BottomNavigationBarType.fixed,
                items: resolvedDestinations
                    .map(
                      (d) => BottomNavigationBarItem(
                        icon: Icon(d.iconData),
                        activeIcon: Icon(d.selectedIconData),
                        label: d.label,
                      ),
                    )
                    .toList(),
              ),
            ),
          ),
        ],
      ),
    );
  }

  void _goBranch(int index, WidgetRef ref) {
    if (index == 0 && navigationShell.currentIndex == 0) {
      final selectedDate = ref.read(agendaDateProvider);
      final today = DateUtils.dateOnly(DateTime.now());
      if (!DateUtils.isSameDay(selectedDate, today)) {
        ref.read(agendaDateProvider.notifier).setToday();
      }
    }

    // Ricarica i provider quando si cambia tab per forzare il refresh dei dati
    if (index != navigationShell.currentIndex) {
      _refreshProvidersForTab(index, ref);
    }

    navigationShell.goBranch(
      index,
      initialLocation: index == navigationShell.currentIndex,
    );
  }

  /// Ricarica i provider relativi alla tab selezionata
  void _refreshProvidersForTab(int index, WidgetRef ref) {
    switch (index) {
      case 1: // Clienti
        ref.read(clientSearchQueryProvider.notifier).clear();
        ref.read(clientsProvider.notifier).refresh();
        break;
      case 2: // Servizi
        ref.read(servicesProvider.notifier).refresh();
        break;
      case 3: // Staff
        ref.read(allStaffProvider.notifier).refresh();
        ref.read(locationsProvider.notifier).refresh();
        break;
    }
  }

  /// Gestisce tap su navigation: se √® index 4, mostra menu utente
  void _handleNavTap(BuildContext context, int index, WidgetRef ref) {
    if (index == 4) {
      _showUserMenu(context, ref);
    } else {
      _goBranch(index, ref);
    }
  }

  /// Mostra il menu utente (profilo, cambia password, logout)
  void _showUserMenu(BuildContext context, WidgetRef ref) {
    final user = ref.read(authProvider).user;
    if (user == null) return;

    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final menuItems = UserMenuButton.buildMenuItems(
      context,
      theme,
      colorScheme,
      user,
    );

    showMenu<String>(
      context: context,
      position: RelativeRect.fromLTRB(
        MediaQuery.of(context).size.width - 200,
        MediaQuery.of(context).size.height - 250,
        16,
        16,
      ),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      items: menuItems,
    ).then((value) {
      if (value == null || !context.mounted) return;
      if (value == 'logout') {
        UserMenuButton.handleLogout(context, ref);
      } else if (value == 'profile') {
        context.push('/profilo');
      } else if (value == 'change_password') {
        context.push('/change-password');
      } else if (value == 'switch_business') {
        ref.read(superadminSelectedBusinessProvider.notifier).clear();
        context.go('/businesses');
      }
    });
  }
}

class _AgendaAddAction extends ConsumerWidget {
  const _AgendaAddAction({this.compact = false});
  final bool compact;
  static const double _actionButtonHeight = 40;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final agendaDate = ref.watch(agendaDateProvider);
    final scheme = Theme.of(context).colorScheme;
    final onContainer = scheme.onSecondaryContainer;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective =
        showLabel ||
        formFactor == AppFormFactor.tablet ||
        formFactor == AppFormFactor.desktop;
    const iconOnlyWidth = 46.0;
    final bool isIconOnly = !showLabelEffective;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: AdaptiveDropdown<String>(
        modalTitle: l10n.agendaAddTitle,
        alignment: AdaptiveDropdownAlignment.right,
        verticalPosition: AdaptiveDropdownVerticalPosition.above,
        forcePopup: true,
        hideTriggerWhenOpen: true,
        popupWidth: 200,
        items: [
          AdaptiveDropdownItem(
            value: 'appointment',
            child: Text(l10n.agendaAddAppointment),
          ),
          AdaptiveDropdownItem(
            value: 'block',
            child: Text(l10n.agendaAddBlock),
          ),
        ],
        onSelected: (value) {
          if (value == 'appointment') {
            showBookingDialog(
              context,
              ref,
              date: agendaDate,
              autoOpenDatePicker: true,
            );
          } else if (value == 'block') {
            showAddBlockDialog(context, ref, date: agendaDate);
          }
        },
        child: Material(
          elevation: 0,
          color: scheme.secondaryContainer,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
          clipBehavior: Clip.antiAlias,
          child: SizedBox(
            height: _actionButtonHeight,
            width: isIconOnly ? iconOnlyWidth : null,
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              child: _buildAddButtonContent(
                showLabelEffective: showLabelEffective,
                compact: compact,
                label: l10n.agendaAdd,
                onContainer: onContainer,
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class _AgendaFilterActions extends ConsumerWidget {
  const _AgendaFilterActions({
    this.padding = const EdgeInsets.symmetric(horizontal: 8),
  });

  static const double _actionButtonHeight = 40;
  static const double _iconOnlyWidth = 46;
  static const double _spacing = 8;
  final EdgeInsetsGeometry padding;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final scheme = Theme.of(context).colorScheme;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective =
        showLabel ||
        formFactor == AppFormFactor.tablet ||
        formFactor == AppFormFactor.desktop;
    final staffCount = ref.watch(staffForCurrentLocationProvider).length;
    final locations = ref.watch(locationsProvider);
    final currentLocationId = ref.watch(currentLocationIdProvider);
    final showStaffSelector = staffCount > 1;
    final showLocationSelector = locations.length > 1;

    if (!showStaffSelector && !showLocationSelector) {
      return const SizedBox.shrink();
    }

    Widget buildActionLabel(IconData icon, String label) {
      return showLabelEffective
          ? Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(icon, size: 22),
                const SizedBox(width: 8),
                Text(label),
              ],
            )
          : Icon(icon, size: 22);
    }

    return Padding(
      padding: padding,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (showStaffSelector)
            AgendaStaffFilterSelector(
              compactBuilder: (context, onPressed, tooltip) {
                return Tooltip(
                  message: tooltip,
                  child: SizedBox(
                    height: _actionButtonHeight,
                    width: showLabelEffective ? null : _iconOnlyWidth,
                    child: AppOutlinedActionButton(
                      onPressed: onPressed,
                      padding: const EdgeInsets.symmetric(
                        horizontal: 12,
                        vertical: 8,
                      ),
                      borderRadius: BorderRadius.circular(8),
                      borderColor: scheme.primary,
                      foregroundColor: scheme.primary,
                      child: buildActionLabel(
                        Icons.badge_outlined,
                        l10n.staffFilterTitle,
                      ),
                    ),
                  ),
                );
              },
            ),
          if (showStaffSelector && showLocationSelector)
            const SizedBox(width: _spacing),
          if (showLocationSelector)
            Tooltip(
              message: l10n.agendaSelectLocation,
              child: SizedBox(
                height: _actionButtonHeight,
                width: showLabelEffective ? null : _iconOnlyWidth,
                child: AppOutlinedActionButton(
                  onPressed: () => _showLocationSheet(
                    context,
                    ref,
                    locations,
                    currentLocationId,
                    l10n.agendaSelectLocation,
                  ),
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  borderRadius: BorderRadius.circular(8),
                  borderColor: scheme.primary,
                  foregroundColor: scheme.primary,
                  child: buildActionLabel(
                    Icons.place_outlined,
                    l10n.agendaSelectLocation,
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }

  Future<void> _showLocationSheet(
    BuildContext context,
    WidgetRef ref,
    List<Location> locations,
    int currentLocationId,
    String title,
  ) async {
    final result = await AppBottomSheet.show<int?>(
      context: context,
      builder: (ctx) => LocationSheetContent(
        locations: locations,
        currentLocationId: currentLocationId,
        title: title,
        onSelected: (id) => Navigator.of(ctx).pop(id),
      ),
      useRootNavigator: true,
      padding: EdgeInsets.zero,
    );

    if (result != null) {
      ref.read(currentLocationIdProvider.notifier).set(result);
    }
  }
}

class _ServicesAddAction extends ConsumerWidget {
  const _ServicesAddAction({this.compact = false});
  final bool compact;
  static const double _actionButtonHeight = 40;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final scheme = Theme.of(context).colorScheme;
    final onContainer = scheme.onSecondaryContainer;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective =
        showLabel ||
        formFactor == AppFormFactor.tablet ||
        formFactor == AppFormFactor.desktop;
    const iconOnlyWidth = 46.0;
    final bool isIconOnly = !showLabelEffective;
    Widget buildActionLabel(IconData icon, String label) {
      return showLabelEffective
          ? Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(icon, size: 22),
                const SizedBox(width: 8),
                Text(label),
              ],
            )
          : Icon(icon, size: 22);
    }

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Tooltip(
            message: l10n.reorderTitle,
            child: SizedBox(
              height: _actionButtonHeight,
              width: isIconOnly ? iconOnlyWidth : null,
              child: AppOutlinedActionButton(
                onPressed: () {
                  ref.read(servicesReorderPanelProvider.notifier).toggle();
                },
                padding: const EdgeInsets.symmetric(
                  horizontal: 12,
                  vertical: 8,
                ),
                borderRadius: BorderRadius.circular(8),
                borderColor: scheme.primary,
                foregroundColor: scheme.primary,
                child: buildActionLabel(Icons.sort, l10n.reorderTitle),
              ),
            ),
          ),
          const SizedBox(width: 8),
          AdaptiveDropdown<String>(
            modalTitle: l10n.agendaAdd,
            alignment: AdaptiveDropdownAlignment.right,
            verticalPosition: AdaptiveDropdownVerticalPosition.above,
            forcePopup: true,
            hideTriggerWhenOpen: true,
            popupWidth: 200,
            items: [
              AdaptiveDropdownItem(
                value: 'category',
                child: Text(l10n.createCategoryButtonLabel),
              ),
              AdaptiveDropdownItem(
                value: 'service',
                child: Text(l10n.servicesNewServiceMenu),
              ),
            ],
            onSelected: (value) {
              if (value == 'category') {
                showCategoryDialog(context, ref);
              } else if (value == 'service') {
                showServiceDialog(context, ref, requireCategorySelection: true);
              }
            },
            child: Material(
              elevation: 0,
              color: scheme.secondaryContainer,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
              clipBehavior: Clip.antiAlias,
              child: SizedBox(
                height: _actionButtonHeight,
                width: isIconOnly ? iconOnlyWidth : null,
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  child: _buildAddButtonContent(
                    showLabelEffective: showLabelEffective,
                    compact: compact,
                    label: l10n.agendaAdd,
                    onContainer: onContainer,
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _TeamAddAction extends ConsumerWidget {
  const _TeamAddAction({this.compact = false});
  final bool compact;
  static const double _actionButtonHeight = 40;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final scheme = Theme.of(context).colorScheme;
    final onContainer = scheme.onSecondaryContainer;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective = showLabel || formFactor != AppFormFactor.mobile;
    const iconOnlyWidth = 46.0;
    final bool isIconOnly = !showLabelEffective;

    // Controlla se ci sono staff e locations per determinare visibilit√† pulsanti
    final staffAsync = ref.watch(allStaffProvider);
    final staffCount = staffAsync.value?.length ?? 0;
    final locations = ref.watch(locationsProvider);
    final locationCount = locations.length;

    Widget buildActionLabel(IconData icon, String label) {
      return showLabelEffective
          ? Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(icon, size: 22),
                const SizedBox(width: 8),
                Text(label),
              ],
            )
          : Icon(icon, size: 22);
    }

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Pulsante Disponibilit√†: visibile solo se almeno 1 staff
          if (staffCount >= 1) ...[
            Tooltip(
              message: l10n.staffHubAvailabilityTitle,
              child: SizedBox(
                height: _actionButtonHeight,
                width: isIconOnly ? iconOnlyWidth : null,
                child: AppOutlinedActionButton(
                  onPressed: () => context.pushNamed('staff-availability'),
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  borderRadius: BorderRadius.circular(8),
                  borderColor: scheme.primary,
                  foregroundColor: scheme.primary,
                  child: buildActionLabel(
                    Icons.schedule_outlined,
                    l10n.staffHubAvailabilityTitle,
                  ),
                ),
              ),
            ),
            const SizedBox(width: 8),
          ],
          // Pulsante Modifica ordinamento: visibile solo se almeno 2 staff o 2 locations
          if (staffCount >= 2 || locationCount >= 2) ...[
            Tooltip(
              message: l10n.reorderTitle,
              child: SizedBox(
                height: _actionButtonHeight,
                width: isIconOnly ? iconOnlyWidth : null,
                child: AppOutlinedActionButton(
                  onPressed: () {
                    ref.read(teamReorderPanelProvider.notifier).toggle();
                  },
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  borderRadius: BorderRadius.circular(8),
                  borderColor: scheme.primary,
                  foregroundColor: scheme.primary,
                  child: buildActionLabel(Icons.sort, l10n.reorderTitle),
                ),
              ),
            ),
            const SizedBox(width: 8),
          ],
          AdaptiveDropdown<String>(
            modalTitle: l10n.agendaAdd,
            alignment: AdaptiveDropdownAlignment.right,
            verticalPosition: AdaptiveDropdownVerticalPosition.above,
            forcePopup: true,
            hideTriggerWhenOpen: true,
            popupWidth: 220,
            items: [
              AdaptiveDropdownItem(
                value: 'location',
                child: Text(l10n.teamNewLocationTitle),
              ),
              AdaptiveDropdownItem(
                value: 'staff',
                child: Text(l10n.teamNewStaffTitle),
              ),
            ],
            onSelected: (value) {
              if (value == 'location') {
                showLocationDialog(context, ref);
              } else if (value == 'staff') {
                showStaffDialog(context, ref);
              }
            },
            child: Material(
              elevation: 0,
              color: scheme.secondaryContainer,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
              clipBehavior: Clip.antiAlias,
              child: SizedBox(
                height: _actionButtonHeight,
                width: isIconOnly ? iconOnlyWidth : null,
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  child: _buildAddButtonContent(
                    showLabelEffective: showLabelEffective,
                    compact: compact,
                    label: l10n.agendaAdd,
                    onContainer: onContainer,
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _ClientsAddAction extends ConsumerWidget {
  const _ClientsAddAction({this.compact = false});
  final bool compact;
  static const double _actionButtonHeight = 40;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective = showLabel || formFactor != AppFormFactor.mobile;
    const iconOnlyWidth = 46.0;
    final bool isIconOnly = !showLabelEffective;
    if (compact) {
      return Padding(
        padding: const EdgeInsets.symmetric(horizontal: 8),
        child: GestureDetector(
          onTap: () async {
            await showClientEditDialog(context, ref);
          },
          child: Builder(
            builder: (buttonContext) {
              final scheme = Theme.of(buttonContext).colorScheme;
              final onContainer = scheme.onSecondaryContainer;
              return Material(
                elevation: 0,
                color: scheme.secondaryContainer,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
                clipBehavior: Clip.antiAlias,
                child: SizedBox(
                  height: _actionButtonHeight,
                  width: isIconOnly ? iconOnlyWidth : null,
                  child: Padding(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 8,
                    ),
                    child: _buildAddButtonContent(
                      showLabelEffective: showLabelEffective,
                      compact: compact,
                      label: l10n.agendaAdd,
                      onContainer: onContainer,
                    ),
                  ),
                ),
              );
            },
          ),
        ),
      );
    }
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: GestureDetector(
        onTap: () async {
          await showClientEditDialog(context, ref);
        },
        child: Builder(
          builder: (buttonContext) {
            final scheme = Theme.of(buttonContext).colorScheme;
            final onContainer = scheme.onSecondaryContainer;
            return Material(
              elevation: 0,
              color: scheme.secondaryContainer,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
              clipBehavior: Clip.antiAlias,
              child: SizedBox(
                height: _actionButtonHeight,
                width: isIconOnly ? iconOnlyWidth : null,
                child: Padding(
                  padding: const EdgeInsets.fromLTRB(12, 8, 28, 8),
                  child: _buildAddButtonContent(
                    showLabelEffective: showLabelEffective,
                    compact: compact,
                    label: l10n.agendaAdd,
                    onContainer: onContainer,
                  ),
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}

class _MobileAgendaDateSwitcher extends ConsumerWidget {
  const _MobileAgendaDateSwitcher();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final agendaDate = ref.watch(agendaDateProvider);
    final dateController = ref.read(agendaDateProvider.notifier);
    final localeTag = Localizations.localeOf(context).toLanguageTag();
    final label = DateFormat('EEE d MMM', localeTag).format(agendaDate);

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: AgendaDateSwitcher(
        label: label,
        selectedDate: agendaDate,
        onPrevious: dateController.previousDay,
        onNext: dateController.nextDay,
        onPreviousWeek: dateController.previousWeek,
        onNextWeek: dateController.nextWeek,
        onPreviousMonth: dateController.previousMonth,
        onNextMonth: dateController.nextMonth,
        onSelectDate: (date) {
          dateController.set(DateUtils.dateOnly(date));
        },
        isCompact: true,
      ),
    );
  }
}

class _ScaffoldWithNavigationHelpers {
  static List<NavigationDestination> getDestinations(
    BuildContext context, {
    bool isSuperadmin = false,
  }) {
    final l10n = context.l10n;
    return [
      NavigationDestination(
        iconData: Icons.calendar_month_outlined,
        selectedIconData: Icons.calendar_month,
        label: l10n.navAgenda,
      ),
      NavigationDestination(
        iconData: Icons.people_outline,
        selectedIconData: Icons.people,
        label: l10n.navClients,
      ),
      NavigationDestination(
        iconData: Icons.category_outlined,
        selectedIconData: Icons.cut,
        label: l10n.navServices,
      ),
      NavigationDestination(
        iconData: Icons.badge_outlined,
        selectedIconData: Icons.badge,
        label: l10n.navStaff,
      ),
      NavigationDestination(
        iconData: Icons.account_circle_outlined,
        selectedIconData: Icons.account_circle,
        label: l10n.navProfile,
      ),
    ];
  }

  static List<NavigationRailDestination> toRailDestinations(
    List<NavigationDestination> destinations,
  ) {
    return destinations
        .map(
          (d) => NavigationRailDestination(
            icon: _NavIcon(icon: d.iconData, label: d.label),
            selectedIcon: _NavIcon(
              icon: d.selectedIconData,
              label: d.label,
              selected: true,
            ),
            label: Text(d.label),
          ),
        )
        .toList();
  }
}

class _RailDivider extends StatelessWidget {
  const _RailDivider({
    required this.topInset,
    required this.color,
    required this.thickness,
  });

  final double topInset;
  final Color color;
  final double thickness;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: thickness,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final availableHeight = constraints.maxHeight;
          final inset = topInset.clamp(0.0, availableHeight);

          return Column(
            children: [
              SizedBox(height: inset),
              Expanded(child: Container(color: color)),
            ],
          );
        },
      ),
    );
  }
}

class _NavIcon extends StatefulWidget {
  const _NavIcon({
    required this.icon,
    required this.label,
    this.selected = false,
  });

  final IconData icon;
  final String label;
  final bool selected;

  @override
  State<_NavIcon> createState() => _NavIconState();
}

class _NavIconState extends State<_NavIcon> {
  static const double _size = 52;
  static const double _iconSize = 24;

  bool _hovering = false;

  void _handleHover(bool hovering) {
    if (_hovering == hovering) return;
    setState(() => _hovering = hovering);
  }

  @override
  Widget build(BuildContext context) {
    final scheme = Theme.of(context).colorScheme;

    final iconColor = scheme.onSecondary.withOpacity(
      widget.selected ? 0.95 : 0.7,
    );

    final labelColor = scheme.onSecondary.withOpacity(
      widget.selected ? 0.95 : 0.65,
    );

    Color backgroundColor = Colors.transparent;

    if (widget.selected || _hovering) {
      // effetto "selected" o "hover": fill leggero
      backgroundColor = scheme.onSecondary.withOpacity(
        widget.selected ? 0.11 : 0.08,
      );
    }

    final baseTheme = Theme.of(context);

    return MouseRegion(
      onEnter: (_) => _handleHover(true),
      onExit: (_) => _handleHover(false),
      child: Theme(
        // disattiva splash / highlight di sistema su tap/long-press
        data: baseTheme.copyWith(
          splashColor: Colors.transparent,
          highlightColor: Colors.transparent,
          hoverColor: Colors.transparent,
        ),
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          curve: Curves.easeInOut,
          width: _size,
          height: _size + 16, // Altezza extra per la label
          decoration: BoxDecoration(
            color: backgroundColor,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(widget.icon, color: iconColor, size: _iconSize),
              const SizedBox(height: 2),
              Text(
                widget.label,
                style: TextStyle(
                  color: labelColor,
                  fontSize: 10,
                  fontWeight: widget.selected
                      ? FontWeight.w600
                      : FontWeight.w500,
                ),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class NavigationDestination {
  const NavigationDestination({
    required this.iconData,
    required this.selectedIconData,
    required this.label,
  });
  final IconData iconData;
  final IconData selectedIconData;
  final String label;
}
--- FILE: lib/app/providers/form_factor_provider.dart ---
import 'dart:ui' as ui;

import 'package:flutter/widgets.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'form_factor_provider.g.dart';

// Definiamo i tre layout che ci interessano
enum AppFormFactor { mobile, tablet, desktop }

AppFormFactor _formFactorForWidth(double width) {
  if (width >= 1024) return AppFormFactor.desktop;
  if (width >= 600) return AppFormFactor.tablet;
  return AppFormFactor.mobile;
}

@riverpod
class FormFactorNotifier extends _$FormFactorNotifier {
  @override
  AppFormFactor build() {
    final binding = WidgetsFlutterBinding.ensureInitialized();
    final dispatcher = binding.platformDispatcher;
    final ui.FlutterView? view = dispatcher.views.isNotEmpty
        ? dispatcher.views.first
        : dispatcher.implicitView;

    if (view != null) {
      final logicalSize = view.physicalSize / view.devicePixelRatio;
      return _formFactorForWidth(logicalSize.width);
    }

    return AppFormFactor.mobile;
  }

  /// Aggiorna il form factor in base alla larghezza dello schermo.
  /// Usa lo stesso breakpoint di 600px che usi nel resto dell'app.
  void update(double screenWidth) {
    final newFactor = _formFactorForWidth(screenWidth);

    // Aggiorna lo stato solo se il form factor cambia
    if (state != newFactor) {
      state = newFactor;
    }
  }
}
--- FILE: lib/app/providers/form_factor_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'form_factor_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(FormFactorNotifier)
const formFactorProvider = FormFactorNotifierProvider._();

final class FormFactorNotifierProvider
    extends $NotifierProvider<FormFactorNotifier, AppFormFactor> {
  const FormFactorNotifierProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'formFactorProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$formFactorNotifierHash();

  @$internal
  @override
  FormFactorNotifier create() => FormFactorNotifier();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AppFormFactor value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AppFormFactor>(value),
    );
  }
}

String _$formFactorNotifierHash() =>
    r'c2d345138b8b938ff84a110cd4b6bf3dda7a605e';

abstract class _$FormFactorNotifier extends $Notifier<AppFormFactor> {
  AppFormFactor build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<AppFormFactor, AppFormFactor>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AppFormFactor, AppFormFactor>,
              AppFormFactor,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/app/theme/extensions.dart ---
import 'package:flutter/material.dart';

class AppInteractionColors extends ThemeExtension<AppInteractionColors> {
  const AppInteractionColors({
    required this.hoverFill,
    required this.pressedFill,
    required this.alternatingRowFill,
  });

  final Color hoverFill;
  final Color pressedFill;

  /// Colore di sfondo per righe alternate (es. liste, tabelle)
  final Color alternatingRowFill;

  @override
  AppInteractionColors copyWith({
    Color? hoverFill,
    Color? pressedFill,
    Color? alternatingRowFill,
  }) {
    return AppInteractionColors(
      hoverFill: hoverFill ?? this.hoverFill,
      pressedFill: pressedFill ?? this.pressedFill,
      alternatingRowFill: alternatingRowFill ?? this.alternatingRowFill,
    );
  }

  @override
  AppInteractionColors lerp(AppInteractionColors? other, double t) {
    if (other == null) return this;
    return AppInteractionColors(
      hoverFill: Color.lerp(hoverFill, other.hoverFill, t) ?? hoverFill,
      pressedFill: Color.lerp(pressedFill, other.pressedFill, t) ?? pressedFill,
      alternatingRowFill:
          Color.lerp(alternatingRowFill, other.alternatingRowFill, t) ??
          alternatingRowFill,
    );
  }

  @override
  int get hashCode => Object.hash(hoverFill, pressedFill, alternatingRowFill);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is AppInteractionColors &&
        other.hoverFill == hoverFill &&
        other.pressedFill == pressedFill &&
        other.alternatingRowFill == alternatingRowFill;
  }
}
--- FILE: lib/app/theme/app_spacing.dart ---
/// Costanti di spacing configurabili a livello applicativo.
/// Modifica questi valori per cambiare lo spacing in tutta l'app.
abstract class AppSpacing {
  AppSpacing._();
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // General spacing
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Spacing piccolo generico.
  static const double small = 8.0;

  /// Spacing medio generico.
  static const double medium = 12.0;

  /// Spacing grande generico.
  static const double large = 24.0;

  /// Spacing extra large generico.
  static const double xLarge = 60.0;

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Form spacing
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  /// Spacing verticale tra la prima riga dei form e il titolo.
  static const double formFirstRowSpacing = large;

  /// Spacing verticale tra le righe dei form (es. tra data/ora e servizio).
  static const double formRowSpacing = xLarge;

  /// Spacing orizzontale tra i campi sulla stessa riga (es. tra data e ora).
  static const double formFieldSpacing = medium;

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Bottom sheet spacing
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Spacing tra il contenuto del form e i pulsanti azioni.
  static const double formToActionsSpacing = xLarge;

  /// Spacing tra i pulsanti azioni.
  static const double actionButtonSpacing = small;
}
--- FILE: lib/app/theme/theme_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'theme.dart';
import 'theme_config.dart';

/// üîπ Notifier moderno per gestire il tema dinamico
class ThemeNotifier extends Notifier<AppThemeConfig> {
  @override
  AppThemeConfig build() => const AppThemeConfig(
    seedColor: colorPrimary1,
    brightness: Brightness.light,
  );

  /// Cambia il colore principale (seed color)
  void updateSeed(Color color) {
    state = state.copyWith(seedColor: color);
  }

  /// Inverte la modalit√† chiara/scura
  void toggleBrightness() {
    if (state.brightness != Brightness.light) {
      state = state.copyWith(brightness: Brightness.light);
    }
  }
}

/// üîπ Provider globale per il tema (versione Notifier)
final themeNotifierProvider = NotifierProvider<ThemeNotifier, AppThemeConfig>(
  ThemeNotifier.new,
);
--- FILE: lib/app/theme/theme_config.dart ---
import 'package:flutter/material.dart';

class AppThemeConfig {
  final Color seedColor;
  final Brightness brightness;

  const AppThemeConfig({
    required this.seedColor,
    this.brightness = Brightness.dark,
  });

  AppThemeConfig copyWith({Color? seedColor, Brightness? brightness}) {
    return AppThemeConfig(
      seedColor: seedColor ?? this.seedColor,
      brightness: brightness ?? this.brightness,
    );
  }
}
--- FILE: lib/app/theme/theme.dart ---
import 'package:flutter/material.dart';

import 'extensions.dart';
import 'theme_config.dart';

const colorPrimary1 = Color(0xFF141414); // colore base scuro
const colorPrimary2 = Color(0xFFFEFEFE); // colore contrasto chiaro

/// Crea un tema coerente partendo dal seed definito in [AppThemeConfig].
ThemeData buildTheme(AppThemeConfig _, Brightness brightness) {
  final isDark = brightness == Brightness.dark;

  //const colorPrimary3 = Color(0xFFE5B24F); // accento caldo

  final background = isDark ? colorPrimary1 : colorPrimary2;
  final surface = background;
  final primary = colorPrimary1;
  final onPrimary = colorPrimary2;
  final onBackground = isDark ? colorPrimary2 : colorPrimary1;

  final colorScheme = ColorScheme(
    brightness: brightness,
    primary: primary,
    onPrimary: onPrimary,
    secondary: primary,
    onSecondary: onPrimary,
    error: Colors.red,
    onError: colorPrimary2,
    background: background,
    onBackground: onBackground,
    surface: surface,
    onSurface: onBackground,
  );

  final base = ThemeData(
    useMaterial3: true,
    colorScheme: colorScheme,
    brightness: brightness,
    scaffoldBackgroundColor: background,
    canvasColor: surface,
  );

  final titleStyle =
      base.textTheme.titleLarge ??
      const TextStyle(fontSize: 18, fontWeight: FontWeight.w600);

  final hoverFill = isDark
      ? colorPrimary2.withOpacity(0.12)
      : colorPrimary1.withOpacity(0.01);
  final pressedFill = isDark
      ? colorPrimary2.withOpacity(0.18)
      : colorPrimary1.withOpacity(0.1);
  final alternatingRowFill = isDark
      ? colorPrimary2.withOpacity(0.05)
      : colorPrimary1.withOpacity(0.03);

  final themeWithPalette = base.copyWith(
    appBarTheme: AppBarTheme(
      backgroundColor: colorPrimary2,
      foregroundColor: colorPrimary1,
      centerTitle: true,
      surfaceTintColor: Colors.transparent,
      elevation: 0,
      iconTheme: const IconThemeData(color: colorPrimary1),
      titleTextStyle: titleStyle.copyWith(color: colorPrimary1),
    ),
    cardTheme: CardThemeData(
      color: surface,
      surfaceTintColor: Colors.transparent,
      elevation: 0,
      margin: const EdgeInsets.all(8),
      shape: RoundedRectangleBorder(
        borderRadius: const BorderRadius.all(Radius.circular(12)),
        side: BorderSide(color: onBackground.withOpacity(0.1), width: 0.5),
      ),
    ),
    textTheme: base.textTheme.apply(
      bodyColor: onBackground,
      displayColor: onBackground,
    ),
    iconTheme: IconThemeData(color: onBackground),
    dividerColor: onBackground.withOpacity(0.12),
    floatingActionButtonTheme: FloatingActionButtonThemeData(
      backgroundColor: primary,
      foregroundColor: onPrimary,
    ),
    navigationRailTheme: NavigationRailThemeData(
      backgroundColor: colorPrimary1,
      selectedIconTheme: const IconThemeData(color: colorPrimary2, size: 32),
      unselectedIconTheme: const IconThemeData(color: colorPrimary2, size: 32),
      selectedLabelTextStyle: const TextStyle(
        color: colorPrimary2,
        fontWeight: FontWeight.w600,
      ),
      unselectedLabelTextStyle: const TextStyle(color: colorPrimary2),
      minWidth: 80,
      indicatorColor: Colors.transparent,
    ),
    bottomNavigationBarTheme: BottomNavigationBarThemeData(
      backgroundColor: colorPrimary1,
      selectedItemColor: colorPrimary2,
      unselectedItemColor: colorPrimary2.withOpacity(0.5),
      selectedIconTheme: const IconThemeData(color: colorPrimary2, size: 26),
      unselectedIconTheme: IconThemeData(color: colorPrimary2.withOpacity(0.5)),
      selectedLabelStyle: const TextStyle(
        fontWeight: FontWeight.w600,
        fontSize: 12,
      ),
      unselectedLabelStyle: const TextStyle(
        fontWeight: FontWeight.w400,
        fontSize: 11,
      ),
      showUnselectedLabels: true,
      type: BottomNavigationBarType.fixed,
    ),
    // Colori ON globali per Switch/Radio in linea con il primary dell'app
    switchTheme: base.switchTheme.copyWith(
      overlayColor: MaterialStateProperty.all(Colors.transparent),
      thumbColor: MaterialStateProperty.resolveWith(
        (states) => states.contains(MaterialState.selected)
            ? colorScheme.primary
            : null,
      ),
      trackColor: MaterialStateProperty.resolveWith(
        (states) => states.contains(MaterialState.selected)
            ? colorScheme.primary.withOpacity(0.35)
            : null,
      ),
    ),
    radioTheme: base.radioTheme.copyWith(
      overlayColor: MaterialStateProperty.all(Colors.transparent),
      fillColor: MaterialStateProperty.resolveWith(
        (states) => states.contains(MaterialState.selected)
            ? colorScheme.primary
            : null,
      ),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        backgroundColor: primary,
        foregroundColor: onPrimary,
        textStyle: const TextStyle(fontWeight: FontWeight.w600),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
      ),
    ),
  );

  return themeWithPalette.copyWith(
    extensions: <ThemeExtension<dynamic>>[
      AppInteractionColors(
        hoverFill: hoverFill,
        pressedFill: pressedFill,
        alternatingRowFill: alternatingRowFill,
      ),
    ],
  );
}
--- FILE: lib/app/router_provider.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../core/l10n/l10_extension.dart';
import '../features/agenda/presentation/agenda_screen.dart';
import '../features/auth/domain/auth_state.dart';
import '../features/auth/presentation/change_password_screen.dart';
import '../features/auth/presentation/login_screen.dart';
import '../features/auth/presentation/reset_password_screen.dart';
import '../features/auth/providers/auth_provider.dart';
import '../features/business/presentation/business_list_screen.dart';
import '../features/clients/presentation/clients_screen.dart';
import '../features/services/presentation/services_screen.dart';
import '../features/staff/presentation/staff_week_overview_screen.dart';
import '../features/staff/presentation/team_screen.dart';
import 'scaffold_with_navigation.dart';

final _rootNavigatorKey = GlobalKey<NavigatorState>();

/// Provider derivato che cambia SOLO quando cambia l'autenticazione effettiva
/// NON quando cambia solo l'errorMessage (evita rebuild inutili del router)
final _routerAuthStateProvider =
    Provider<
      ({bool isAuthenticated, bool isSuperadmin, bool isInitialOrLoading})
    >((ref) {
      final authState = ref.watch(authProvider);
      return (
        isAuthenticated: authState.isAuthenticated,
        isSuperadmin: authState.user?.isSuperadmin ?? false,
        isInitialOrLoading:
            authState.status == AuthStatus.initial ||
            authState.status == AuthStatus.loading,
      );
    });

/// Provider per il router con supporto autenticazione.
final routerProvider = Provider<GoRouter>((ref) {
  // Usa il provider derivato per evitare rebuild quando cambia solo errorMessage
  final authInfo = ref.watch(_routerAuthStateProvider);
  final isAuthenticated = authInfo.isAuthenticated;
  final isSuperadmin = authInfo.isSuperadmin;
  final isInitialOrLoading = authInfo.isInitialOrLoading;

  final superadminSelectedBusiness = ref.watch(
    superadminSelectedBusinessProvider,
  );

  return GoRouter(
    navigatorKey: _rootNavigatorKey,
    initialLocation: '/login',
    debugLogDiagnostics: kDebugMode,

    // Refresh router quando cambia lo stato auth
    refreshListenable: _AuthNotifier(ref),

    redirect: (context, state) {
      final isLoggingIn = state.matchedLocation == '/login';
      final isOnBusinessList = state.matchedLocation == '/businesses';

      // Durante il caricamento iniziale, non fare redirect
      if (isInitialOrLoading) {
        return null;
      }

      // Pagine pubbliche che non richiedono autenticazione
      final isPublicPage =
          isLoggingIn || state.matchedLocation.startsWith('/reset-password');

      // Se non loggato e non su pagina pubblica, vai al login
      if (!isAuthenticated && !isPublicPage) {
        return '/login';
      }

      // Se loggato e sulla pagina login
      if (isAuthenticated && isLoggingIn) {
        // Se superadmin senza business selezionato, vai alla lista business
        if (isSuperadmin && superadminSelectedBusiness == null) {
          return '/businesses';
        }
        return '/agenda';
      }

      // Se superadmin tenta di accedere all'agenda senza aver selezionato un business
      if (isAuthenticated &&
          isSuperadmin &&
          superadminSelectedBusiness == null &&
          !isOnBusinessList &&
          !isLoggingIn) {
        return '/businesses';
      }

      return null;
    },

    errorBuilder: (context, state) => Scaffold(
      appBar: AppBar(title: Text(context.l10n.errorTitle)),
      body: Center(
        child: Text(
          context.l10n.errorNotFound(state.uri.path),
          style: const TextStyle(color: Colors.redAccent),
        ),
      ),
    ),

    routes: [
      // Route login (fuori dalla shell)
      GoRoute(
        path: '/login',
        name: 'login',
        builder: (context, state) => const LoginScreen(),
      ),

      // Route reset password (fuori dalla shell, pubblica)
      GoRoute(
        path: '/reset-password/:token',
        name: 'reset-password',
        builder: (context, state) {
          final token = state.pathParameters['token']!;
          return ResetPasswordScreen(token: token);
        },
      ),

      // Route lista business per superadmin (fuori dalla shell)
      GoRoute(
        path: '/businesses',
        name: 'businesses',
        builder: (context, state) => const BusinessListScreen(),
      ),

      // Shell con navigazione principale
      StatefulShellRoute.indexedStack(
        builder: (context, state, navigationShell) {
          return ScaffoldWithNavigation(navigationShell: navigationShell);
        },
        branches: [
          // --- Ramo 0: Agenda ---
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/agenda',
                name: 'agenda',
                builder: (BuildContext context, GoRouterState state) {
                  final q = state.uri.queryParameters['clientId'];
                  final initialClientId = q == null ? null : int.tryParse(q);
                  return AgendaScreen(initialClientId: initialClientId);
                },
              ),
            ],
          ),

          // --- Ramo 1: Clienti ---
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/clienti',
                name: 'clienti',
                builder: (BuildContext context, GoRouterState state) =>
                    const ClientsScreen(),
              ),
            ],
          ),

          // --- Ramo 2: Servizi ---
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/servizi',
                name: 'servizi',
                builder: (BuildContext context, GoRouterState state) =>
                    const ServicesScreen(),
              ),
            ],
          ),

          // --- Ramo 3: Staff ---
          StatefulShellBranch(
            routes: [
              GoRoute(
                path: '/staff',
                name: 'staff',
                builder: (BuildContext context, GoRouterState state) =>
                    const TeamScreen(),
              ),
            ],
          ),
        ],
      ),

      // Route esterne alla shell
      GoRoute(
        path: '/staff-availability',
        name: 'staff-availability',
        parentNavigatorKey: _rootNavigatorKey,
        builder: (BuildContext context, GoRouterState state) =>
            const StaffWeekOverviewScreen(),
      ),

      // Route cambio password
      GoRoute(
        path: '/change-password',
        name: 'change-password',
        parentNavigatorKey: _rootNavigatorKey,
        builder: (BuildContext context, GoRouterState state) =>
            const ChangePasswordScreen(),
      ),
    ],
  );
});

/// Notifier per aggiornare il router quando cambia l'auth state.
class _AuthNotifier extends ChangeNotifier {
  _AuthNotifier(this._ref) {
    _ref.listen(authProvider, (previous, next) {
      // Se l'utente si disconnette, resetta la selezione business del superadmin
      if (previous?.isAuthenticated == true && !next.isAuthenticated) {
        _ref.read(superadminSelectedBusinessProvider.notifier).clear();
      }
      notifyListeners();
    });
  }

  final Ref _ref;
}
--- FILE: lib/app/app.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/l10n/l10_extension.dart';
import '/core/l10n/l10n.dart';
import '../core/widgets/layout_config_auto_listener.dart';
import '../core/widgets/session_expired_listener.dart';
import 'router_provider.dart';
import 'theme/theme.dart';
import 'theme/theme_provider.dart';

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeConfig = ref.watch(themeNotifierProvider);
    final router = ref.watch(routerProvider);
    return MaterialApp.router(
      debugShowCheckedModeBanner: false,
      title: 'Agenda Platform',
      routerConfig: router,
      themeMode: ThemeMode.light,
      theme: buildTheme(themeConfig, Brightness.light),
      localizationsDelegates: const [
        L10n.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: L10n.delegate.supportedLocales,
      locale: const Locale('it'),

      // 2. SPOSTA IL LISTENER QUI
      builder: (context, child) {
        final localizedTitle = context.l10n.appTitle;
        return Title(
          title: localizedTitle,
          color: Theme.of(context).scaffoldBackgroundColor,
          // Questo widget ora aggiorner√† i provider globali
          // prima che qualsiasi schermata venga costruita.
          child: SessionExpiredListener(
            child: LayoutConfigAutoListener(
              child: child ?? const SizedBox.shrink(),
            ),
          ),
        );
      },
    );
  }
}
--- FILE: lib/app/widgets/business_selector.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../core/models/business.dart';
import '../../features/agenda/providers/business_providers.dart';
import '../../features/auth/providers/auth_provider.dart';

/// Selettore business per superadmin.
/// Mostra nel leading della NavigationRail.
class BusinessSelector extends ConsumerWidget {
  const BusinessSelector({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authProvider);
    final isSuperadmin = authState.user?.isSuperadmin ?? false;

    // Solo superadmin vede il selettore
    if (!isSuperadmin) return const SizedBox.shrink();

    final businessesAsync = ref.watch(businessesProvider);
    final currentBusinessId = ref.watch(currentBusinessIdProvider);

    return businessesAsync.when(
      data: (businesses) => _BusinessDropdown(
        businesses: businesses,
        currentBusinessId: currentBusinessId,
        onChanged: (id) {
          ref.read(currentBusinessIdProvider.notifier).set(id);
        },
      ),
      loading: () => const Padding(
        padding: EdgeInsets.all(12),
        child: SizedBox(
          width: 24,
          height: 24,
          child: CircularProgressIndicator(strokeWidth: 2),
        ),
      ),
      error: (_, __) => const SizedBox.shrink(),
    );
  }
}

class _BusinessDropdown extends StatelessWidget {
  const _BusinessDropdown({
    required this.businesses,
    required this.currentBusinessId,
    required this.onChanged,
  });

  final List<Business> businesses;
  final int currentBusinessId;
  final void Function(int) onChanged;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    if (businesses.isEmpty) {
      return const SizedBox.shrink();
    }

    final currentBusiness = businesses.firstWhere(
      (b) => b.id == currentBusinessId,
      orElse: () => businesses.first,
    );

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 12),
      child: PopupMenuButton<int>(
        offset: const Offset(56, 0),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        tooltip: 'Seleziona business',
        onSelected: onChanged,
        itemBuilder: (context) => businesses.map((b) {
          final isSelected = b.id == currentBusinessId;
          return PopupMenuItem<int>(
            value: b.id,
            child: Row(
              children: [
                CircleAvatar(
                  radius: 14,
                  backgroundColor: isSelected
                      ? colorScheme.primaryContainer
                      : colorScheme.surfaceContainerHighest,
                  child: Text(
                    b.name.isNotEmpty ? b.name[0].toUpperCase() : '?',
                    style: TextStyle(
                      fontSize: 12,
                      fontWeight: FontWeight.w600,
                      color: isSelected
                          ? colorScheme.onPrimaryContainer
                          : colorScheme.onSurfaceVariant,
                    ),
                  ),
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                    b.name,
                    style: TextStyle(
                      fontWeight: isSelected
                          ? FontWeight.w600
                          : FontWeight.normal,
                    ),
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                if (isSelected)
                  Icon(Icons.check, size: 18, color: colorScheme.primary),
              ],
            ),
          );
        }).toList(),
        child: Container(
          width: 40,
          height: 40,
          decoration: BoxDecoration(
            color: colorScheme.primaryContainer,
            borderRadius: BorderRadius.circular(8),
          ),
          child: Center(
            child: Text(
              currentBusiness.name.isNotEmpty
                  ? currentBusiness.name[0].toUpperCase()
                  : '?',
              style: TextStyle(
                fontSize: 16,
                fontWeight: FontWeight.w700,
                color: colorScheme.onPrimaryContainer,
              ),
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/app/widgets/agenda_staff_filter_selector.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/extensions.dart';
import 'package:agenda_backend/app/widgets/agenda_control_components.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/staff.dart';
import 'package:agenda_backend/core/widgets/app_dividers.dart';
import 'package:agenda_backend/core/widgets/desktop_popup_container.dart';
import 'package:agenda_backend/features/agenda/domain/staff_filter_mode.dart';
import 'package:agenda_backend/features/agenda/providers/staff_filter_providers.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Selector per filtrare lo staff visualizzato nell'agenda.
/// [isCompact] = true: solo icona (mobile/tablet)
/// [isCompact] = false: pill con icona + label + freccia (desktop)
class AgendaStaffFilterSelector extends ConsumerStatefulWidget {
  const AgendaStaffFilterSelector({
    super.key,
    this.isCompact = true,
    this.compactBuilder,
  });

  final bool isCompact;
  final Widget Function(
    BuildContext context,
    VoidCallback onPressed,
    String tooltip,
  )?
  compactBuilder;

  @override
  ConsumerState<AgendaStaffFilterSelector> createState() =>
      _AgendaStaffFilterSelectorState();
}

class _AgendaStaffFilterSelectorState
    extends ConsumerState<AgendaStaffFilterSelector> {
  bool _isHovered = false;
  final LayerLink _layerLink = LayerLink();
  OverlayEntry? _overlayEntry;
  bool _isOpen = false;

  @override
  void dispose() {
    _removeOverlay();
    super.dispose();
  }

  void _removeOverlay() {
    _overlayEntry?.remove();
    _overlayEntry = null;
    if (_isOpen) {
      _isOpen = false;
      setState(() => _isHovered = false);
    }
  }

  void _handleTap() {
    final formFactor = ref.read(formFactorProvider);

    if (formFactor == AppFormFactor.desktop) {
      _showDesktopPopup();
    } else {
      _showMobileSheet(context);
    }
  }

  void _showDesktopPopup() {
    if (_overlayEntry != null) {
      _removeOverlay();
      return;
    }

    setState(() => _isHovered = true);
    _isOpen = true;

    final renderBox = context.findRenderObject() as RenderBox;
    final triggerSize = renderBox.size;

    _overlayEntry = OverlayEntry(
      builder: (overlayContext) => DesktopPopupContainer(
        link: _layerLink,
        triggerWidth: triggerSize.width,
        triggerHeight: triggerSize.height,
        popupWidth: 280,
        maxHeight: 400,
        onDismiss: _removeOverlay,
        child: _StaffFilterPopupContent(onDismiss: _removeOverlay),
      ),
    );

    Overlay.of(context).insert(_overlayEntry!);
  }

  Future<void> _showMobileSheet(BuildContext context) async {
    setState(() => _isHovered = true);
    await showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      useRootNavigator: true,
      builder: (_) => const _StaffFilterSheet(),
    );
    setState(() => _isHovered = false);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final formFactor = ref.watch(formFactorProvider);
    if (widget.isCompact) {
      Future<void> onPressed() => _showMobileSheet(context);
      if (widget.compactBuilder != null) {
        return widget.compactBuilder!(
          context,
          onPressed,
          l10n.staffFilterTooltip,
        );
      }
      return IconButton(
        tooltip: l10n.staffFilterTooltip,
        icon: const Icon(Icons.badge_outlined),
        iconSize: formFactor == AppFormFactor.mobile ? 22 : 33,
        onPressed: onPressed,
      );
    }

    // Desktop mode: pill style like AgendaLocationSelector
    final colorScheme = Theme.of(context).colorScheme;
    final interactions = Theme.of(context).extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = _isHovered
        ? Color.alphaBlend(hoverFill, colorScheme.surface)
        : colorScheme.surface;

    final mode = ref.watch(staffFilterModeProvider);
    final label = _getModeLabel(l10n, mode);

    return CompositedTransformTarget(
      link: _layerLink,
      child: MouseRegion(
        onEnter: (_) {
          if (!_isHovered && !_isOpen) setState(() => _isHovered = true);
        },
        onExit: (_) {
          if (_isHovered && !_isOpen) setState(() => _isHovered = false);
        },
        child: GestureDetector(
          onTap: _handleTap,
          child: Semantics(
            button: true,
            label: l10n.staffFilterTooltip,
            child: ClipRRect(
              borderRadius: kAgendaPillRadius,
              child: Container(
                height: kAgendaControlHeight,
                decoration: BoxDecoration(
                  borderRadius: kAgendaPillRadius,
                  border: Border.all(color: Colors.grey.withOpacity(0.35)),
                  color: backgroundColor,
                ),
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: kAgendaControlHorizontalPadding,
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Flexible(
                        child: Text(label, overflow: TextOverflow.ellipsis),
                      ),
                      const SizedBox(width: 8),
                      const Icon(Icons.keyboard_arrow_down_rounded, size: 20),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  String _getModeLabel(dynamic l10n, StaffFilterMode mode) {
    switch (mode) {
      case StaffFilterMode.allTeam:
        return l10n.staffFilterAllTeam;
      case StaffFilterMode.onDutyTeam:
        return l10n.staffFilterOnDuty;
      case StaffFilterMode.custom:
        final selectedIds = ref.read(selectedStaffIdsProvider);
        final count = selectedIds.length;
        if (count == 0) return l10n.staffFilterAllTeam;
        return '$count';
    }
  }
}

/// Content widget for the staff filter desktop popup.
class _StaffFilterPopupContent extends ConsumerWidget {
  const _StaffFilterPopupContent({required this.onDismiss});

  final VoidCallback onDismiss;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final mode = ref.watch(staffFilterModeProvider);
    final allStaff = ref.watch(staffForCurrentLocationProvider);
    final selectedIds = ref.watch(selectedStaffIdsProvider);
    final onDutyIds = ref.watch(onDutyStaffIdsProvider);

    return SingleChildScrollView(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Padding(
            padding: const EdgeInsets.fromLTRB(12, 10, 12, 6),
            child: Text(
              l10n.staffFilterTitle,
              style: theme.textTheme.labelMedium?.copyWith(
                color: colorScheme.onSurfaceVariant,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          const AppBottomSheetDivider(),

          // Opzione: Tutto il team
          _DesktopFilterOptionTile(
            title: l10n.staffFilterAllTeam,
            isSelected: mode == StaffFilterMode.allTeam,
            onTap: () {
              ref
                  .read(staffFilterModeProvider.notifier)
                  .set(StaffFilterMode.allTeam);
              onDismiss();
            },
          ),

          // Opzione: Team di turno
          _DesktopFilterOptionTile(
            title: l10n.staffFilterOnDuty,
            isSelected: mode == StaffFilterMode.onDutyTeam,
            onTap: () {
              ref
                  .read(staffFilterModeProvider.notifier)
                  .set(StaffFilterMode.onDutyTeam);
              onDismiss();
            },
          ),

          // Divider
          const AppBottomSheetDivider(),

          // Header staff
          Padding(
            padding: const EdgeInsets.fromLTRB(12, 8, 12, 4),
            child: Text(
              l10n.staffFilterSelectMembers,
              style: theme.textTheme.bodySmall?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
          ),

          // Lista staff con checkbox
          for (final staff in allStaff)
            _DesktopStaffMemberTile(
              staff: staff,
              isSelected: _isStaffSelected(
                mode,
                selectedIds,
                onDutyIds,
                staff.id,
              ),
              onChanged: (selected) {
                if (mode != StaffFilterMode.custom) {
                  final ids = mode == StaffFilterMode.onDutyTeam
                      ? onDutyIds.toList()
                      : allStaff.map((s) => s.id).toList();
                  ref.read(selectedStaffIdsProvider.notifier).setFromList(ids);
                  ref
                      .read(staffFilterModeProvider.notifier)
                      .set(StaffFilterMode.custom);
                }
                ref.read(selectedStaffIdsProvider.notifier).toggle(staff.id);
              },
            ),

          const SizedBox(height: 8),
        ],
      ),
    );
  }

  bool _isStaffSelected(
    StaffFilterMode mode,
    Set<int> selectedIds,
    Set<int> onDutyIds,
    int staffId,
  ) {
    switch (mode) {
      case StaffFilterMode.allTeam:
        return true;
      case StaffFilterMode.onDutyTeam:
        return onDutyIds.contains(staffId);
      case StaffFilterMode.custom:
        return selectedIds.contains(staffId);
    }
  }
}

class _DesktopFilterOptionTile extends StatefulWidget {
  const _DesktopFilterOptionTile({
    required this.title,
    required this.isSelected,
    required this.onTap,
  });

  final String title;
  final bool isSelected;
  final VoidCallback onTap;

  @override
  State<_DesktopFilterOptionTile> createState() =>
      _DesktopFilterOptionTileState();
}

class _DesktopFilterOptionTileState extends State<_DesktopFilterOptionTile> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      cursor: SystemMouseCursors.click,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: widget.onTap,
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 100),
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
          color: widget.isSelected
              ? colorScheme.primary.withOpacity(0.08)
              : _isHovered
              ? colorScheme.primary.withOpacity(0.04)
              : Colors.transparent,
          child: Row(
            children: [
              Icon(
                widget.isSelected
                    ? Icons.radio_button_checked
                    : Icons.radio_button_unchecked,
                color: widget.isSelected ? colorScheme.primary : null,
                size: 20,
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  widget.title,
                  style: TextStyle(
                    fontWeight: widget.isSelected
                        ? FontWeight.w600
                        : FontWeight.normal,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _DesktopStaffMemberTile extends StatefulWidget {
  const _DesktopStaffMemberTile({
    required this.staff,
    required this.isSelected,
    required this.onChanged,
  });

  final Staff staff;
  final bool isSelected;
  final ValueChanged<bool> onChanged;

  @override
  State<_DesktopStaffMemberTile> createState() =>
      _DesktopStaffMemberTileState();
}

class _DesktopStaffMemberTileState extends State<_DesktopStaffMemberTile> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      cursor: SystemMouseCursors.click,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: () => widget.onChanged(!widget.isSelected),
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 100),
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
          color: _isHovered
              ? colorScheme.primary.withOpacity(0.04)
              : Colors.transparent,
          child: Row(
            children: [
              StaffCircleAvatar(
                height: 28,
                color: widget.staff.color,
                isHighlighted: widget.isSelected,
                initials: widget.staff.initials,
              ),
              const SizedBox(width: 12),
              Expanded(child: Text(widget.staff.displayName)),
              Checkbox(
                value: widget.isSelected,
                onChanged: (value) => widget.onChanged(value ?? false),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// Mobile/tablet bottom sheet for staff filter.
class _StaffFilterSheet extends ConsumerWidget {
  const _StaffFilterSheet();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final mode = ref.watch(staffFilterModeProvider);
    final allStaff = ref.watch(staffForCurrentLocationProvider);
    final selectedIds = ref.watch(selectedStaffIdsProvider);
    final onDutyIds = ref.watch(onDutyStaffIdsProvider);

    return SafeArea(
      child: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Handle
            const SizedBox(height: 8),
            Center(
              child: Container(
                width: 40,
                height: 4,
                decoration: BoxDecoration(
                  color: Colors.grey.shade300,
                  borderRadius: BorderRadius.circular(4),
                ),
              ),
            ),
            const SizedBox(height: 12),

            // Header
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 8, 16, 8),
              child: Text(
                l10n.staffFilterTitle,
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
            const AppBottomSheetDivider(),

            // Opzione: Tutto il team
            _MobileFilterOptionTile(
              title: l10n.staffFilterAllTeam,
              isSelected: mode == StaffFilterMode.allTeam,
              onTap: () {
                ref
                    .read(staffFilterModeProvider.notifier)
                    .set(StaffFilterMode.allTeam);
                Navigator.of(context).pop();
              },
            ),

            // Opzione: Team di turno
            _MobileFilterOptionTile(
              title: l10n.staffFilterOnDuty,
              isSelected: mode == StaffFilterMode.onDutyTeam,
              onTap: () {
                ref
                    .read(staffFilterModeProvider.notifier)
                    .set(StaffFilterMode.onDutyTeam);
                Navigator.of(context).pop();
              },
            ),

            // Divider
            const AppBottomSheetDivider(),

            // Header staff
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 12, 16, 4),
              child: Text(
                l10n.staffFilterSelectMembers,
                style: theme.textTheme.bodySmall?.copyWith(
                  color: theme.colorScheme.onSurfaceVariant,
                ),
              ),
            ),

            // Lista staff con checkbox
            for (final staff in allStaff)
              _MobileStaffMemberTile(
                staff: staff,
                isSelected: _isStaffSelected(
                  mode,
                  selectedIds,
                  onDutyIds,
                  staff.id,
                ),
                onChanged: (selected) {
                  if (mode != StaffFilterMode.custom) {
                    final ids = mode == StaffFilterMode.onDutyTeam
                        ? onDutyIds.toList()
                        : allStaff.map((s) => s.id).toList();
                    ref
                        .read(selectedStaffIdsProvider.notifier)
                        .setFromList(ids);
                    ref
                        .read(staffFilterModeProvider.notifier)
                        .set(StaffFilterMode.custom);
                  }
                  ref.read(selectedStaffIdsProvider.notifier).toggle(staff.id);
                },
              ),

            const SizedBox(height: 16),
          ],
        ),
      ),
    );
  }

  bool _isStaffSelected(
    StaffFilterMode mode,
    Set<int> selectedIds,
    Set<int> onDutyIds,
    int staffId,
  ) {
    switch (mode) {
      case StaffFilterMode.allTeam:
        return true;
      case StaffFilterMode.onDutyTeam:
        return onDutyIds.contains(staffId);
      case StaffFilterMode.custom:
        return selectedIds.contains(staffId);
    }
  }
}

class _MobileFilterOptionTile extends StatelessWidget {
  const _MobileFilterOptionTile({
    required this.title,
    required this.isSelected,
    required this.onTap,
  });

  final String title;
  final bool isSelected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return ListTile(
      title: Text(title),
      leading: Icon(
        isSelected ? Icons.radio_button_checked : Icons.radio_button_unchecked,
        color: isSelected ? theme.colorScheme.primary : null,
      ),
      onTap: onTap,
    );
  }
}

class _MobileStaffMemberTile extends StatelessWidget {
  const _MobileStaffMemberTile({
    required this.staff,
    required this.isSelected,
    required this.onChanged,
  });

  final Staff staff;
  final bool isSelected;
  final ValueChanged<bool> onChanged;

  @override
  Widget build(BuildContext context) {
    return ListTile(
      leading: StaffCircleAvatar(
        height: 32,
        color: staff.color,
        isHighlighted: isSelected,
        initials: staff.initials,
      ),
      title: Text(staff.displayName),
      trailing: Checkbox(
        value: isSelected,
        onChanged: (value) => onChanged(value ?? false),
      ),
      onTap: () => onChanged(!isSelected),
    );
  }
}
--- FILE: lib/app/widgets/user_menu_button.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../core/l10n/l10_extension.dart';
import '../../core/models/user.dart';
import '../../features/auth/providers/auth_provider.dart';
import '../../features/business/presentation/business_list_screen.dart';

/// Avatar utente riutilizzabile.
class UserAvatar extends StatelessWidget {
  const UserAvatar({super.key, required this.user, this.radius = 16});

  final User user;
  final double radius;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    return CircleAvatar(
      radius: radius,
      backgroundColor: colorScheme.primaryContainer,
      child: Text(
        user.initials,
        style: TextStyle(
          fontSize: radius * 0.75,
          fontWeight: FontWeight.w600,
          color: colorScheme.onPrimaryContainer,
        ),
      ),
    );
  }
}

/// Widget per mostrare il menu utente nell'AppBar.
/// Mostra avatar con iniziali e menu con logout.
class UserMenuButton extends ConsumerWidget {
  const UserMenuButton({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authState = ref.watch(authProvider);
    final user = authState.user;

    if (user == null) return const SizedBox.shrink();

    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return PopupMenuButton<String>(
      offset: const Offset(0, 48),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 8),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            UserAvatar(user: user, radius: 16),
            const SizedBox(width: 8),
            Icon(Icons.arrow_drop_down, color: colorScheme.onSurfaceVariant),
          ],
        ),
      ),
      itemBuilder: (context) =>
          buildMenuItems(context, theme, colorScheme, user),
      onSelected: (value) {
        if (value == 'logout') {
          handleLogout(context, ref);
        } else if (value == 'profile') {
          context.push('/profilo');
        } else if (value == 'change_password') {
          context.push('/change-password');
        } else if (value == 'switch_business') {
          // Reset selected business e torna alla lista
          ref.read(superadminSelectedBusinessProvider.notifier).clear();
          context.go('/businesses');
        }
      },
    );
  }

  static List<PopupMenuEntry<String>> buildMenuItems(
    BuildContext context,
    ThemeData theme,
    ColorScheme colorScheme,
    User user,
  ) {
    return [
      PopupMenuItem<String>(
        enabled: false,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              user.fullName,
              style: theme.textTheme.titleSmall?.copyWith(
                fontWeight: FontWeight.w600,
              ),
            ),
            const SizedBox(height: 2),
            Text(
              user.email,
              style: theme.textTheme.bodySmall?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
            if (user.isSuperadmin) ...[
              const SizedBox(height: 4),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
                decoration: BoxDecoration(
                  color: colorScheme.tertiaryContainer,
                  borderRadius: BorderRadius.circular(4),
                ),
                child: Text(
                  'Superadmin',
                  style: TextStyle(
                    fontSize: 10,
                    fontWeight: FontWeight.w600,
                    color: colorScheme.onTertiaryContainer,
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
      const PopupMenuDivider(),
      // Cambia password
      PopupMenuItem<String>(
        value: 'change_password',
        child: Row(
          children: [
            Icon(Icons.lock_outline, size: 20, color: colorScheme.primary),
            const SizedBox(width: 12),
            const Text('Cambia password'),
          ],
        ),
      ),
      // Cambia Business per superadmin
      if (user.isSuperadmin)
        PopupMenuItem<String>(
          value: 'switch_business',
          child: Row(
            children: [
              Icon(Icons.business, size: 20, color: colorScheme.primary),
              const SizedBox(width: 12),
              Text('Cambia Business'),
            ],
          ),
        ),
      PopupMenuItem<String>(
        value: 'logout',
        child: Row(
          children: [
            Icon(Icons.logout, size: 20, color: colorScheme.error),
            const SizedBox(width: 12),
            Text(
              context.l10n.authLogout,
              style: TextStyle(color: colorScheme.error),
            ),
          ],
        ),
      ),
    ];
  }

  static void handleLogout(BuildContext context, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(context.l10n.authLogout),
        content: const Text('Vuoi uscire dal gestionale?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text(context.l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () {
              Navigator.of(context).pop();
              // NON pulisce le preferenze: l'ultimo business viene ricordato
              ref.read(authProvider.notifier).logout();
            },
            child: Text(context.l10n.authLogout),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/app/widgets/top_controls.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/widgets/agenda_control_components.dart';
import 'package:agenda_backend/app/widgets/agenda_staff_filter_selector.dart';
import 'package:agenda_backend/app/widgets/top_controls_scaffold.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/location.dart';
import 'package:agenda_backend/core/widgets/app_dividers.dart';
import 'package:agenda_backend/core/widgets/no_scrollbar_behavior.dart';
import 'package:agenda_backend/features/agenda/providers/layout_config_provider.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

enum TopControlsMode { agenda, staff }

class TopControls extends ConsumerWidget {
  const TopControls.agenda({super.key, this.compact = false})
    : mode = TopControlsMode.agenda,
      todayLabel = null,
      labelOverride = null;

  const TopControls.staff({
    super.key,
    this.todayLabel,
    this.labelOverride,
    this.compact = false,
  }) : mode = TopControlsMode.staff;

  final TopControlsMode mode;

  final bool compact;
  final String? todayLabel;
  final String? labelOverride;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final formFactor = ref.watch(formFactorProvider);

    return TopControlsScaffold(
      applyLayoutInset: formFactor == AppFormFactor.desktop,
      builder: TopControlsBuilder.adaptive(
        mobile: (context, data) => _buildMobile(context, data, ref),
        tablet: (context, data) => _buildTablet(context, data, ref),
        desktop: (context, data) => _buildDesktop(context, data, ref),
      ),
    );
  }

  Widget _buildMobile(
    BuildContext context,
    TopControlsData data,
    WidgetRef ref,
  ) {
    // Su mobile per agenda, il date picker √® in basso (come tablet)
    // Mostra solo il selettore location se ce ne sono pi√π di una
    if (mode == TopControlsMode.agenda) {
      if (data.locations.length > 1) {
        return Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Align(
              alignment: AlignmentDirectional.centerStart,
              child: AgendaLocationSelector(
                locations: data.locations,
                current: data.currentLocation,
                onSelected: data.locationController.set,
                iconOnly: true,
              ),
            ),
          ],
        );
      }
      return const SizedBox.shrink();
    }

    // Per staff, mostra il date switcher settimanale
    final weekMeta = _resolveWeekMeta(data);
    final label = weekMeta.label;
    final selectedDate = weekMeta.effectivePickerDate;

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        AgendaDateSwitcher(
          label: label,
          selectedDate: selectedDate,
          onPrevious: null,
          onNext: null,
          onPreviousWeek: data.dateController.previousWeek,
          onNextWeek: data.dateController.nextWeek,
          onPreviousMonth: null,
          onNextMonth: null,
          onSelectDate: (date) {
            data.dateController.set(DateUtils.dateOnly(date));
          },
          useWeekRangePicker: true,
          isCompact: compact,
        ),
        const SizedBox(width: 8),
        if (data.locations.length > 1) ...[
          const SizedBox(width: 16),
          Align(
            alignment: AlignmentDirectional.centerStart,
            child: AgendaLocationSelector(
              locations: data.locations,
              current: data.currentLocation,
              onSelected: data.locationController.set,
              iconOnly: true,
            ),
          ),
        ],
      ],
    );
  }

  Widget _buildTablet(
    BuildContext context,
    TopControlsData data,
    WidgetRef ref,
  ) {
    _StaffWeekMeta? weekMeta;
    String label;
    DateTime selectedDate;
    if (mode == TopControlsMode.agenda) {
      label = _formatSingleDate(data);
      selectedDate = data.agendaDate;
    } else {
      weekMeta = _resolveWeekMeta(data);
      label = weekMeta.label;
      selectedDate = weekMeta.effectivePickerDate;
    }
    final showTopDateSwitcher =
        mode != TopControlsMode.agenda &&
        !(mode == TopControlsMode.staff &&
            data.formFactor == AppFormFactor.mobile);

    final layoutConfig = ref.watch(layoutConfigProvider);

    return Row(
      mainAxisSize: MainAxisSize.max,
      children: [
        if (showTopDateSwitcher) ...[
          Flexible(
            child: AgendaDateSwitcher(
              label: label,
              selectedDate: selectedDate,
              onPreviousWeek: mode == TopControlsMode.staff
                  ? data.dateController.previousWeek
                  : null,
              onNextWeek: mode == TopControlsMode.staff
                  ? data.dateController.nextWeek
                  : null,
              onSelectDate: (date) {
                data.dateController.set(DateUtils.dateOnly(date));
              },
              useWeekRangePicker: mode == TopControlsMode.staff,
              isCompact: compact,
            ),
          ),
        ],
        if (mode == TopControlsMode.agenda)
          SizedBox(width: layoutConfig.hourColumnWidth),
        if (mode == TopControlsMode.agenda &&
            ref.watch(staffForCurrentLocationProvider).length > 1) ...[
          const Align(
            alignment: AlignmentDirectional.centerStart,
            child: AgendaStaffFilterSelector(isCompact: false),
          ),
        ],
        if (data.locations.length > 1) ...[
          const SizedBox(width: 16),
          Align(
            alignment: AlignmentDirectional.centerStart,
            child: AgendaLocationSelector(
              locations: data.locations,
              current: data.currentLocation,
              onSelected: data.locationController.set,
            ),
          ),
        ],
      ],
    );
  }

  Widget _buildDesktop(
    BuildContext context,
    TopControlsData data,
    WidgetRef ref,
  ) {
    _StaffWeekMeta? weekMeta;
    String label;
    DateTime selectedDate;
    if (mode == TopControlsMode.agenda) {
      label = _formatSingleDate(data);
      selectedDate = data.agendaDate;
    } else {
      weekMeta = _resolveWeekMeta(data);
      label = weekMeta.label;
      selectedDate = weekMeta.effectivePickerDate;
    }
    final showStaffSelector =
        mode == TopControlsMode.agenda &&
        ref.watch(staffForCurrentLocationProvider).length > 1;
    final showLocationSelector = data.locations.length > 1;

    List<Widget> buildChildren({required bool allowFlex}) {
      return [
        if (allowFlex)
          Flexible(
            child: AgendaDateSwitcher(
              label: label,
              selectedDate: selectedDate,
              onPrevious: mode == TopControlsMode.agenda
                  ? data.dateController.previousDay
                  : null,
              onNext: mode == TopControlsMode.agenda
                  ? data.dateController.nextDay
                  : null,
              onPreviousWeek:
                  mode == TopControlsMode.agenda ||
                      mode == TopControlsMode.staff
                  ? data.dateController.previousWeek
                  : null,
              onNextWeek:
                  mode == TopControlsMode.agenda ||
                      mode == TopControlsMode.staff
                  ? data.dateController.nextWeek
                  : null,
              onPreviousMonth: mode == TopControlsMode.agenda
                  ? data.dateController.previousMonth
                  : null,
              onNextMonth: mode == TopControlsMode.agenda
                  ? data.dateController.nextMonth
                  : null,
              onSelectDate: (date) {
                data.dateController.set(DateUtils.dateOnly(date));
              },
              useWeekRangePicker: mode == TopControlsMode.staff,
            ),
          )
        else
          AgendaDateSwitcher(
            label: label,
            selectedDate: selectedDate,
            onPrevious: mode == TopControlsMode.agenda
                ? data.dateController.previousDay
                : null,
            onNext: mode == TopControlsMode.agenda
                ? data.dateController.nextDay
                : null,
            onPreviousWeek:
                mode == TopControlsMode.agenda || mode == TopControlsMode.staff
                ? data.dateController.previousWeek
                : null,
            onNextWeek:
                mode == TopControlsMode.agenda || mode == TopControlsMode.staff
                ? data.dateController.nextWeek
                : null,
            onPreviousMonth: mode == TopControlsMode.agenda
                ? data.dateController.previousMonth
                : null,
            onNextMonth: mode == TopControlsMode.agenda
                ? data.dateController.nextMonth
                : null,
            onSelectDate: (date) {
              data.dateController.set(DateUtils.dateOnly(date));
            },
            useWeekRangePicker: mode == TopControlsMode.staff,
          ),
        if (showStaffSelector) const SizedBox(width: 16),
        if (showStaffSelector)
          const Align(
            alignment: AlignmentDirectional.centerStart,
            child: AgendaStaffFilterSelector(isCompact: false),
          ),
        if (showLocationSelector) ...[
          const SizedBox(width: 16),
          if (mode == TopControlsMode.staff)
            Align(
              alignment: AlignmentDirectional.centerStart,
              child: StaffLocationSelector(
                locations: data.locations,
                currentLocationId: ref.watch(staffSectionLocationIdProvider),
                onSelected: ref
                    .read(staffSectionLocationIdProvider.notifier)
                    .set,
              ),
            )
          else
            Align(
              alignment: AlignmentDirectional.centerStart,
              child: AgendaLocationSelector(
                locations: data.locations,
                current: data.currentLocation,
                onSelected: data.locationController.set,
              ),
            ),
        ],
      ];
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        final useScrollFallback =
            constraints.hasBoundedWidth && constraints.maxWidth < 420;
        if (useScrollFallback) {
          return ScrollConfiguration(
            behavior: const NoScrollbarBehavior(),
            child: SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: buildChildren(allowFlex: false),
              ),
            ),
          );
        }
        return Row(children: buildChildren(allowFlex: true));
      },
    );
  }

  String _formatSingleDate(TopControlsData data) {
    final localeTag = data.locale.toLanguageTag();
    return DateFormat('EEE d MMM', localeTag).format(data.agendaDate);
  }

  _StaffWeekMeta _resolveWeekMeta(TopControlsData data) {
    final agendaDate = data.agendaDate;
    final locale = Intl.canonicalizedLocale(data.locale.toString());

    String buildWeekRangeLabel(DateTime start, DateTime end, String localeTag) {
      final sameYear = start.year == end.year;
      final sameMonth = sameYear && start.month == end.month;
      if (sameMonth) {
        final d1 = DateFormat('d', localeTag).format(start);
        final d2m = DateFormat('d MMM', localeTag).format(end);
        return '$d1‚Äì$d2m';
      }
      if (sameYear) {
        final s = DateFormat('d MMM', localeTag).format(start);
        final e = DateFormat('d MMM', localeTag).format(end);
        return '$s ‚Äì $e';
      }
      final s = DateFormat('d MMM y', localeTag).format(start);
      final e = DateFormat('d MMM y', localeTag).format(end);
      return '$s ‚Äì $e';
    }

    final deltaToMonday = (agendaDate.weekday - DateTime.monday) % 7;
    final pickerInitialDate = DateUtils.dateOnly(
      agendaDate.subtract(Duration(days: deltaToMonday)),
    );
    final todayDate = DateUtils.dateOnly(DateTime.now());
    final weekStart = pickerInitialDate;
    final weekEnd = weekStart.add(const Duration(days: 6));
    final defaultLabel = buildWeekRangeLabel(weekStart, weekEnd, locale);
    final formattedDate = labelOverride ?? defaultLabel;
    final isTodayInWeek =
        !todayDate.isBefore(weekStart) && !todayDate.isAfter(weekEnd);
    final effectivePickerDate = isTodayInWeek ? todayDate : weekEnd;

    return _StaffWeekMeta(
      label: formattedDate,
      effectivePickerDate: effectivePickerDate,
    );
  }
}

class _StaffWeekMeta {
  const _StaffWeekMeta({
    required this.label,
    required this.effectivePickerDate,
  });

  final String label;
  final DateTime effectivePickerDate;
}

/// Content widget for the location bottom sheet, consistent with other dropdowns.
class LocationSheetContent extends StatelessWidget {
  const LocationSheetContent({
    super.key,
    required this.locations,
    required this.currentLocationId,
    required this.title,
    required this.onSelected,
    this.showAllLocationsOption = false,
    this.allLocationsLabel,
  });

  final List<Location> locations;
  final int?
  currentLocationId; // null = "Tutte le sedi" se showAllLocationsOption
  final String title;
  final ValueChanged<int?> onSelected;
  final bool showAllLocationsOption;
  final String? allLocationsLabel;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    final maxHeight = MediaQuery.of(context).size.height * 0.8;
    final itemCount = locations.length + (showAllLocationsOption ? 1 : 0);

    return ConstrainedBox(
      constraints: BoxConstraints(maxHeight: maxHeight),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 16, 16, 12),
            child: Text(
              title,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          const AppBottomSheetDivider(),
          Expanded(
            child: ListView.builder(
              itemCount: itemCount,
              itemBuilder: (ctx, index) {
                // Prima voce: "Tutte le sedi" se abilitato
                if (showAllLocationsOption && index == 0) {
                  final isSelected = currentLocationId == null;
                  return InkWell(
                    onTap: () => onSelected(null),
                    splashColor: Colors.transparent,
                    highlightColor: Colors.transparent,
                    child: Container(
                      padding: const EdgeInsets.symmetric(
                        vertical: 14,
                        horizontal: 16,
                      ),
                      color: isSelected
                          ? colorScheme.primary.withOpacity(0.08)
                          : Colors.transparent,
                      child: Row(
                        children: [
                          Expanded(
                            child: Text(
                              allLocationsLabel ?? context.l10n.allLocations,
                              style: TextStyle(
                                color: colorScheme.onSurface,
                                fontWeight: isSelected
                                    ? FontWeight.w600
                                    : FontWeight.normal,
                              ),
                            ),
                          ),
                          if (isSelected)
                            Icon(
                              Icons.check,
                              size: 20,
                              color: colorScheme.primary,
                            ),
                        ],
                      ),
                    ),
                  );
                }

                final locationIndex = showAllLocationsOption
                    ? index - 1
                    : index;
                final loc = locations[locationIndex];
                final isSelected = loc.id == currentLocationId;
                return InkWell(
                  onTap: () => onSelected(loc.id),
                  splashColor: Colors.transparent,
                  highlightColor: Colors.transparent,
                  child: Container(
                    padding: const EdgeInsets.symmetric(
                      vertical: 14,
                      horizontal: 16,
                    ),
                    color: isSelected
                        ? colorScheme.primary.withOpacity(0.08)
                        : Colors.transparent,
                    child: Row(
                      children: [
                        Expanded(
                          child: Text(
                            loc.name,
                            style: TextStyle(
                              color: colorScheme.onSurface,
                              fontWeight: isSelected
                                  ? FontWeight.w600
                                  : FontWeight.normal,
                            ),
                          ),
                        ),
                        if (isSelected)
                          Icon(
                            Icons.check,
                            size: 20,
                            color: colorScheme.primary,
                          ),
                      ],
                    ),
                  ),
                );
              },
            ),
          ),
          SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
        ],
      ),
    );
  }
}
--- FILE: lib/app/widgets/agenda_control_components.dart ---
import 'package:agenda_backend/app/theme/extensions.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/location.dart';
import 'package:agenda_backend/core/widgets/adaptive_dropdown.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

const double kAgendaControlHeight = 40;
const double kAgendaControlHorizontalPadding = 20;
const double kAgendaMinDateLabelWidth = 120;
const BorderRadius kAgendaPillRadius = BorderRadius.all(Radius.circular(999));
const double kAgendaDividerWidth = 1;

class AgendaRoundedButton extends StatelessWidget {
  const AgendaRoundedButton({super.key, required this.label, this.onTap});

  final String label;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final interactions = Theme.of(context).extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final pressedFill =
        interactions?.pressedFill ?? colorScheme.primary.withOpacity(0.1);
    final disabledFill = colorScheme.surface.withOpacity(0.6);
    final disabledForeground = colorScheme.onSurface.withOpacity(0.38);
    final enabledText = colorScheme.onSurface;
    final disabledBorder = colorScheme.onSurface.withOpacity(0.12);
    final enabledBorder = Colors.grey.withOpacity(0.35);

    return SizedBox(
      height: kAgendaControlHeight,
      child: OutlinedButton(
        style:
            OutlinedButton.styleFrom(
              shape: const RoundedRectangleBorder(
                borderRadius: kAgendaPillRadius,
              ),
              padding: const EdgeInsets.symmetric(
                horizontal: kAgendaControlHorizontalPadding,
              ),
              side: BorderSide(color: enabledBorder),
            ).copyWith(
              backgroundColor: MaterialStateProperty.resolveWith((states) {
                if (states.contains(MaterialState.disabled)) {
                  return disabledFill;
                }
                if (states.contains(MaterialState.pressed)) return pressedFill;
                if (states.contains(MaterialState.hovered)) return hoverFill;
                return colorScheme.surface;
              }),
              foregroundColor: MaterialStateProperty.resolveWith((states) {
                if (states.contains(MaterialState.disabled)) {
                  return disabledForeground;
                }
                return enabledText;
              }),
              overlayColor: MaterialStateProperty.all(Colors.transparent),
              elevation: MaterialStateProperty.resolveWith(
                (states) =>
                    states.contains(MaterialState.hovered) &&
                        !states.contains(MaterialState.disabled)
                    ? 6
                    : 0,
              ),
              shadowColor: MaterialStateProperty.all(
                Colors.black.withOpacity(0.08),
              ),
              side: MaterialStateProperty.resolveWith(
                (states) => BorderSide(
                  color: states.contains(MaterialState.disabled)
                      ? disabledBorder
                      : enabledBorder,
                ),
              ),
            ),
        onPressed: onTap,
        child: Text(label),
      ),
    );
  }
}

class AgendaDateSwitcher extends StatefulWidget {
  const AgendaDateSwitcher({
    super.key,
    required this.label,
    required this.selectedDate,
    this.useWeekRangePicker = false,
    this.isCompact = false,
    this.onPrevious,
    this.onPreviousWeek,
    this.onNext,
    this.onNextWeek,
    this.onPreviousMonth,
    this.onNextMonth,
    required this.onSelectDate,
  });

  final String label;
  final DateTime selectedDate;
  // When true, tapping the label opens a DateRangePicker pre-filled with the
  // week (Mon-Sun) containing selectedDate, and normalizes user choice to that week.
  final bool useWeekRangePicker;

  /// Variante compatta: disegna solo il bottone testo+icona senza frecce laterali.
  final bool isCompact;
  final VoidCallback? onPrevious;
  final VoidCallback? onPreviousWeek;
  final VoidCallback? onNext;
  final VoidCallback? onNextWeek;
  final VoidCallback? onPreviousMonth;
  final VoidCallback? onNextMonth;
  final ValueChanged<DateTime> onSelectDate;

  @override
  State<AgendaDateSwitcher> createState() => _AgendaDateSwitcherState();
}

class _AgendaDateSwitcherState extends State<AgendaDateSwitcher> {
  Future<void> _handleTap(BuildContext context) async {
    final initialDate = widget.selectedDate;
    final firstDate = DateTime(initialDate.year - 3);
    final lastDate = DateTime(initialDate.year + 3);

    if (widget.useWeekRangePicker) {
      // Custom lightweight week picker: tap qualsiasi giorno -> settimana Mon-Dom
      final selectedMonday = await _showWeekPickerDialog(
        context: context,
        anchor: initialDate,
        firstDate: firstDate,
        lastDate: lastDate,
      );
      if (selectedMonday != null &&
          !DateUtils.isSameDay(selectedMonday, widget.selectedDate)) {
        widget.onSelectDate(selectedMonday);
      }
      return;
    }

    // Default single-date dialog
    final picked = await showGeneralDialog<DateTime>(
      context: context,
      barrierDismissible: true,
      barrierColor: Colors.black.withOpacity(0.12),
      barrierLabel: MaterialLocalizations.of(context).modalBarrierDismissLabel,
      transitionDuration: const Duration(milliseconds: 180),
      transitionBuilder: (context, animation, secondaryAnimation, child) {
        final curved = CurvedAnimation(
          parent: animation,
          curve: Curves.easeOut,
        );
        return FadeTransition(
          opacity: curved,
          child: ScaleTransition(
            scale: Tween<double>(begin: 0.96, end: 1).animate(curved),
            child: child,
          ),
        );
      },
      pageBuilder: (dialogContext, _, __) {
        final theme = Theme.of(dialogContext);
        final localizations = MaterialLocalizations.of(dialogContext);
        final borderColor = theme.dividerColor.withOpacity(0.24);
        final baseHeadline =
            theme.datePickerTheme.headerHeadlineStyle ??
            theme.textTheme.titleLarge ??
            const TextStyle(fontSize: 18);
        final datePickerTheme = theme.datePickerTheme.copyWith(
          headerHeadlineStyle: baseHeadline.copyWith(
            fontWeight: FontWeight.w700,
          ),
        );

        return Center(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
            child: Material(
              elevation: 12,
              color: theme.colorScheme.surface,
              borderRadius: const BorderRadius.all(Radius.circular(12)),
              child: ConstrainedBox(
                constraints: const BoxConstraints(minWidth: 280, maxWidth: 360),
                child: DecoratedBox(
                  decoration: BoxDecoration(
                    borderRadius: const BorderRadius.all(Radius.circular(12)),
                    border: Border.all(color: borderColor, width: 1),
                  ),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Theme(
                        data: theme.copyWith(datePickerTheme: datePickerTheme),
                        child: CalendarDatePicker(
                          initialDate: initialDate,
                          firstDate: firstDate,
                          lastDate: lastDate,
                          onDateChanged: (selected) {
                            Navigator.of(
                              dialogContext,
                            ).pop(DateUtils.dateOnly(selected));
                          },
                        ),
                      ),
                      Align(
                        alignment: Alignment.centerRight,
                        child: Padding(
                          padding: const EdgeInsets.fromLTRB(0, 0, 8, 8),
                          child: TextButton(
                            onPressed: () => Navigator.of(dialogContext).pop(),
                            child: Text(localizations.cancelButtonLabel),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        );
      },
    );

    if (picked != null && !DateUtils.isSameDay(picked, widget.selectedDate)) {
      widget.onSelectDate(picked);
    }
  }

  @override
  Widget build(BuildContext context) {
    /*if (widget.isCompact) {
      return _CompactDateSwitcher(
        label: widget.label,
        onTap: () => _handleTap(context),
      );
    }*/
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    final interactions = Theme.of(context).extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = colorScheme.surface;
    final l10n = context.l10n;
    final borderColor = Colors.grey.withOpacity(0.35);

    const double dividerWidth = kAgendaDividerWidth;
    final double arrowExtent = kAgendaControlHeight;
    final double navIconSize = arrowExtent <= 32 ? 16.0 : 18.0;
    const BorderRadius leftRadius = BorderRadius.only(
      topLeft: Radius.circular(999),
      bottomLeft: Radius.circular(999),
    );
    const BorderRadius rightRadius = BorderRadius.only(
      topRight: Radius.circular(999),
      bottomRight: Radius.circular(999),
    );

    return Container(
      height: kAgendaControlHeight,
      decoration: BoxDecoration(
        borderRadius: kAgendaPillRadius,
        border: Border.all(color: borderColor),
        color: backgroundColor,
      ),
      child: LayoutBuilder(
        builder: (context, constraints) {
          final maxWidth = constraints.maxWidth;
          const compactBreakpoint = 330.0;
          final isCompact =
              maxWidth.isFinite && maxWidth > 0 && maxWidth < compactBreakpoint;
          final horizontalPadding = isCompact
              ? 12.0
              : kAgendaControlHorizontalPadding;
          final labelSemantics = MaterialLocalizations.of(
            context,
          ).datePickerHelpText;

          Widget buildDivider(VoidCallback onTap) => GestureDetector(
            behavior: HitTestBehavior.opaque,
            onTap: onTap,
            child: SizedBox(
              width: dividerWidth,
              height: kAgendaControlHeight,
              child: DecoratedBox(
                decoration: BoxDecoration(color: borderColor.withOpacity(0.5)),
              ),
            ),
          );

          Widget buildStaticDivider() => SizedBox(
            width: dividerWidth,
            height: kAgendaControlHeight,
            child: DecoratedBox(
              decoration: BoxDecoration(color: borderColor.withOpacity(0.5)),
            ),
          );

          Widget buildArrowButton(
            _NavButtonSpec spec,
            BorderRadius borderRadius,
          ) {
            return _HoverableRegion(
              onTap: spec.onTap,
              semanticsLabel: spec.semanticsLabel,
              hoverColor: hoverFill,
              width: arrowExtent,
              borderRadius: borderRadius,
              child: Center(
                child: spec.iconWidget ?? Icon(spec.icon, size: navIconSize),
              ),
            );
          }

          Widget buildLabelRegion() => _HoverableRegion(
            onTap: () => _handleTap(context),
            semanticsLabel: labelSemantics,
            hoverColor: hoverFill,
            minWidth: kAgendaMinDateLabelWidth,
            padding: EdgeInsets.symmetric(horizontal: horizontalPadding),
            child: Align(
              alignment: Alignment.center,
              child: Text(
                widget.label,
                style: textTheme.titleMedium,
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
          );

          List<Widget> buildNavButtons(
            List<_NavButtonSpec> specs, {
            BorderRadius? firstRadius,
            BorderRadius? lastRadius,
          }) {
            final widgets = <Widget>[];
            for (var i = 0; i < specs.length; i++) {
              if (i > 0) {
                widgets.add(buildStaticDivider());
              }
              final spec = specs[i];
              BorderRadius buttonRadius = BorderRadius.zero;
              if (i == 0 && firstRadius != null) {
                buttonRadius = firstRadius;
              }
              if (i == specs.length - 1 && lastRadius != null) {
                buttonRadius = lastRadius;
              }
              widgets.add(buildArrowButton(spec, buttonRadius));
            }
            return widgets;
          }

          final leadingSpecs = <_NavButtonSpec>[];
          if (widget.onPreviousMonth != null) {
            leadingSpecs.add(
              _NavButtonSpec(
                iconWidget: widget.onPrevious != null
                    ? _TripleArrowIcons(
                        icon: Icons.keyboard_arrow_left,
                        iconSize: navIconSize,
                        width: arrowExtent,
                      )
                    : null,

                icon: widget.onPrevious == null
                    ? Icons.keyboard_double_arrow_left
                    : null,
                onTap: widget.onPreviousMonth!,
                semanticsLabel: l10n.agendaPrevMonth,
              ),
            );
          }
          if (widget.onPreviousWeek != null) {
            leadingSpecs.add(
              _NavButtonSpec(
                icon: widget.onPrevious != null
                    ? Icons.keyboard_double_arrow_left
                    : Icons.keyboard_arrow_left,
                onTap: widget.onPreviousWeek!,
                semanticsLabel: l10n.agendaPrevWeek,
              ),
            );
          }
          if (widget.onPrevious != null) {
            leadingSpecs.add(
              _NavButtonSpec(
                icon: Icons.keyboard_arrow_left,
                onTap: widget.onPrevious ?? () {},
                semanticsLabel: l10n.agendaPrevDay,
              ),
            );
          }

          final trailingSpecs = <_NavButtonSpec>[];
          if (widget.onNext != null) {
            trailingSpecs.add(
              _NavButtonSpec(
                icon: Icons.keyboard_arrow_right,
                onTap: widget.onNext ?? () {},
                semanticsLabel: l10n.agendaNextDay,
              ),
            );
          }
          if (widget.onNextWeek != null) {
            trailingSpecs.add(
              _NavButtonSpec(
                icon: widget.onNext != null
                    ? Icons.keyboard_double_arrow_right
                    : Icons.keyboard_arrow_right,
                onTap: widget.onNextWeek!,
                semanticsLabel: l10n.agendaNextWeek,
              ),
            );
          }
          if (widget.onNextMonth != null) {
            trailingSpecs.add(
              _NavButtonSpec(
                iconWidget: widget.onNext != null
                    ? _TripleArrowIcons(
                        icon: Icons.keyboard_arrow_right,
                        iconSize: navIconSize,
                        width: arrowExtent,
                      )
                    : null,
                icon: widget.onNext == null
                    ? Icons.keyboard_double_arrow_right
                    : null,
                onTap: widget.onNextMonth!,
                semanticsLabel: l10n.agendaNextMonth,
              ),
            );
          }

          final labelRegion = buildLabelRegion();
          final children = <Widget>[
            ...buildNavButtons(
              leadingSpecs,
              firstRadius: leadingSpecs.isNotEmpty ? leftRadius : null,
            ),
            buildDivider(() => _handleTap(context)),
          ];

          if (isCompact) {
            children.add(Expanded(child: labelRegion));
          } else {
            children.add(labelRegion);
          }

          children.addAll([
            buildDivider(() => _handleTap(context)),
            ...buildNavButtons(
              trailingSpecs,
              lastRadius: trailingSpecs.isNotEmpty ? rightRadius : null,
            ),
          ]);

          return Row(
            mainAxisSize: isCompact ? MainAxisSize.max : MainAxisSize.min,
            children: children,
          );
        },
      ),
    );
  }
}

/// Shows a simple dialog with a month grid. Selecting any day returns the Monday
/// of that week. Month navigation supported. Highlights the whole week.
Future<DateTime?> _showWeekPickerDialog({
  required BuildContext context,
  required DateTime anchor,
  required DateTime firstDate,
  required DateTime lastDate,
}) async {
  return showGeneralDialog<DateTime>(
    context: context,
    barrierDismissible: true,
    barrierColor: Colors.black.withOpacity(0.12),
    barrierLabel: MaterialLocalizations.of(context).modalBarrierDismissLabel,
    transitionDuration: const Duration(milliseconds: 180),
    transitionBuilder: (context, animation, secondary, child) {
      final curved = CurvedAnimation(parent: animation, curve: Curves.easeOut);
      return FadeTransition(
        opacity: curved,
        child: ScaleTransition(
          scale: Tween<double>(begin: 0.96, end: 1).animate(curved),
          child: child,
        ),
      );
    },
    pageBuilder: (dialogContext, _, __) {
      return _WeekPickerContent(
        anchor: anchor,
        firstDate: firstDate,
        lastDate: lastDate,
      );
    },
  );
}

class _WeekPickerContent extends StatefulWidget {
  const _WeekPickerContent({
    required this.anchor,
    required this.firstDate,
    required this.lastDate,
  });
  final DateTime anchor;
  final DateTime firstDate;
  final DateTime lastDate;

  @override
  State<_WeekPickerContent> createState() => _WeekPickerContentState();
}

class _NavButtonSpec {
  const _NavButtonSpec({
    this.icon,
    this.iconWidget,
    required this.onTap,
    required this.semanticsLabel,
  }) : assert(icon != null || iconWidget != null);

  final IconData? icon;
  final Widget? iconWidget;
  final VoidCallback onTap;
  final String semanticsLabel;
}

class _TripleArrowIcons extends StatelessWidget {
  const _TripleArrowIcons({
    required this.icon,
    required this.iconSize,
    required this.width,
  });

  final IconData icon;
  final double iconSize;
  final double width;

  @override
  Widget build(BuildContext context) {
    final color = Theme.of(context).iconTheme.color;
    return SizedBox(
      width: width,
      height: iconSize,
      child: Stack(
        clipBehavior: Clip.none,
        children: List.generate(3, (index) {
          final spacing = iconSize * 0.3;
          return Positioned(
            left: (width - iconSize) / 2 + (index - 1) * spacing,
            child: Icon(icon, size: iconSize, color: color),
          );
        }),
      ),
    );
  }
}

class _WeekPickerContentState extends State<_WeekPickerContent> {
  late DateTime _focusedMonth; // first day of focused month
  DateTime? _hoverDay;
  late DateTime _selectedMonday;

  @override
  void initState() {
    super.initState();
    _focusedMonth = DateTime(widget.anchor.year, widget.anchor.month, 1);
    _selectedMonday = _mondayOf(widget.anchor);
  }

  DateTime _mondayOf(DateTime d) =>
      d.subtract(Duration(days: d.weekday - DateTime.monday));

  bool _inSameWeek(DateTime day, DateTime monday) {
    final diff = day.difference(monday).inDays;
    return diff >= 0 && diff < 7;
  }

  void _changeMonth(int delta) {
    setState(() {
      _focusedMonth = DateTime(
        _focusedMonth.year,
        _focusedMonth.month + delta,
        1,
      );
    });
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final locale = Localizations.localeOf(context).toString();
    final monthLabel = DateFormat('MMMM y', locale).format(_focusedMonth);
    final localizations = MaterialLocalizations.of(context);
    final firstGridDay = _mondayOf(_focusedMonth);
    // 6 weeks grid
    final days = List.generate(42, (i) => firstGridDay.add(Duration(days: i)));
    final hoveredWeekMonday = _hoverDay != null ? _mondayOf(_hoverDay!) : null;

    Color weekBg(bool inSelected, bool inHovered) {
      final base = theme.colorScheme.primary;
      if (inSelected) return base.withOpacity(0.18);
      if (inHovered) return base.withOpacity(0.10);
      return Colors.transparent;
    }

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Material(
          elevation: 12,
          color: theme.colorScheme.surface,
          borderRadius: const BorderRadius.all(Radius.circular(12)),
          child: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 320, maxWidth: 360),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                // Header
                Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  child: Row(
                    children: [
                      IconButton(
                        tooltip: localizations.previousMonthTooltip,
                        onPressed: () => _changeMonth(-1),
                        icon: const Icon(Icons.chevron_left),
                      ),
                      Expanded(
                        child: Center(
                          child: Text(
                            monthLabel,
                            style: theme.textTheme.titleMedium?.copyWith(
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ),
                      ),
                      IconButton(
                        tooltip: localizations.nextMonthTooltip,
                        onPressed: () => _changeMonth(1),
                        icon: const Icon(Icons.chevron_right),
                      ),
                    ],
                  ),
                ),
                const Divider(height: 1),
                // Weekday headers (Mon-Sun)
                Padding(
                  padding: const EdgeInsets.only(top: 8, left: 8, right: 8),
                  child: Row(
                    children: [
                      // Use MaterialLocalizations (shortWeekdays) starting from Monday.
                      // MaterialLocalizations non espone shortWeekdays; generiamo abbreviazioni
                      // localizzate usando DateFormat('E'). Partiamo dal luned√¨.
                      for (int i = 0; i < 7; i++)
                        Expanded(
                          child: Center(
                            child: Text(
                              DateFormat('E', locale).format(
                                _mondayOf(_focusedMonth).add(Duration(days: i)),
                              ),
                              style: theme.textTheme.labelSmall?.copyWith(
                                fontWeight: FontWeight.w600,
                              ),
                            ),
                          ),
                        ),
                      // end weekday headers
                    ],
                  ),
                ),
                const SizedBox(height: 4),
                // Grid
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 8),
                  child: Column(
                    children: [
                      for (int w = 0; w < 6; w++) ...[
                        Row(
                          children: [
                            for (int d = 0; d < 7; d++) ...[
                              Builder(
                                builder: (context) {
                                  final day = days[w * 7 + d];
                                  // final mondayOfDay = _mondayOf(day); // not needed after normalization on tap
                                  final inSelectedWeek = _inSameWeek(
                                    day,
                                    _selectedMonday,
                                  );
                                  final inHoveredWeek =
                                      hoveredWeekMonday != null &&
                                      _inSameWeek(day, hoveredWeekMonday);
                                  final isOutOfRange =
                                      day.isBefore(widget.firstDate) ||
                                      day.isAfter(widget.lastDate);
                                  final isCurrentMonth =
                                      day.month == _focusedMonth.month;

                                  return Expanded(
                                    child: GestureDetector(
                                      onTap: isOutOfRange
                                          ? null
                                          : () {
                                              final newMonday = _mondayOf(day);
                                              Navigator.of(context).pop(
                                                DateUtils.dateOnly(newMonday),
                                              );
                                            },
                                      child: MouseRegion(
                                        onEnter: (_) =>
                                            setState(() => _hoverDay = day),
                                        onExit: (_) =>
                                            setState(() => _hoverDay = null),
                                        child: AnimatedContainer(
                                          duration: const Duration(
                                            milliseconds: 120,
                                          ),
                                          margin: const EdgeInsets.symmetric(
                                            vertical: 2,
                                            horizontal: 2,
                                          ),
                                          decoration: BoxDecoration(
                                            color: weekBg(
                                              inSelectedWeek,
                                              inHoveredWeek,
                                            ),
                                            borderRadius: BorderRadius.circular(
                                              8,
                                            ),
                                          ),
                                          height: 40,
                                          alignment: Alignment.center,
                                          child: Text(
                                            '${day.day}',
                                            style: theme.textTheme.bodySmall
                                                ?.copyWith(
                                                  fontWeight: FontWeight.w500,
                                                  color: isOutOfRange
                                                      ? theme.disabledColor
                                                      : (isCurrentMonth
                                                            ? theme
                                                                  .colorScheme
                                                                  .onSurface
                                                            : theme
                                                                  .colorScheme
                                                                  .onSurface
                                                                  .withOpacity(
                                                                    0.45,
                                                                  )),
                                                ),
                                          ),
                                        ),
                                      ),
                                    ),
                                  );
                                },
                              ),
                            ],
                          ],
                        ),
                      ],
                    ],
                  ),
                ),
                const SizedBox(height: 8),
                Padding(
                  padding: const EdgeInsets.fromLTRB(12, 0, 12, 12),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      TextButton(
                        onPressed: () => Navigator.of(context).pop(),
                        child: Text(localizations.cancelButtonLabel),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class _HoverableRegion extends StatefulWidget {
  const _HoverableRegion({
    required this.onTap,
    required this.semanticsLabel,
    required this.hoverColor,
    required this.child,
    this.width,
    this.minWidth,
    this.padding,
    this.borderRadius = BorderRadius.zero,
  });

  final VoidCallback onTap;
  final String semanticsLabel;
  final Color hoverColor;
  final Widget child;
  final double? width;
  final double? minWidth;
  final EdgeInsetsGeometry? padding;
  final BorderRadius borderRadius;

  @override
  State<_HoverableRegion> createState() => _HoverableRegionState();
}

class _HoverableRegionState extends State<_HoverableRegion> {
  bool _hovered = false;

  @override
  Widget build(BuildContext context) {
    final constraints = widget.minWidth != null
        ? BoxConstraints(minWidth: widget.minWidth!)
        : const BoxConstraints();

    Widget content = widget.child;
    if (widget.padding != null) {
      content = Padding(padding: widget.padding!, child: content);
    }

    return Semantics(
      button: true,
      label: widget.semanticsLabel,
      child: MouseRegion(
        cursor: SystemMouseCursors.click,
        onEnter: (_) => setState(() => _hovered = true),
        onExit: (_) => setState(() => _hovered = false),
        child: GestureDetector(
          behavior: HitTestBehavior.opaque,
          onTap: widget.onTap,
          child: ClipRRect(
            borderRadius: widget.borderRadius,
            child: AnimatedContainer(
              duration: const Duration(milliseconds: 120),
              curve: Curves.easeOut,
              width: widget.width,
              constraints: constraints,
              height: kAgendaControlHeight,
              color: _hovered ? widget.hoverColor : Colors.transparent,
              child: content,
            ),
          ),
        ),
      ),
    );
  }
}

/// Versione compact del date switcher con stile pill.
class _CompactDateSwitcher extends StatefulWidget {
  const _CompactDateSwitcher({required this.label, required this.onTap});

  final String label;
  final VoidCallback onTap;

  @override
  State<_CompactDateSwitcher> createState() => _CompactDateSwitcherState();
}

class _CompactDateSwitcherState extends State<_CompactDateSwitcher> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final interactions = Theme.of(context).extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = _isHovered
        ? Color.alphaBlend(hoverFill, colorScheme.surface)
        : colorScheme.surface;

    return InkWell(
      onHover: (hovering) {
        if (hovering != _isHovered) {
          setState(() => _isHovered = hovering);
        }
      },
      onTap: widget.onTap,
      highlightColor: Colors.transparent,
      borderRadius: kAgendaPillRadius,
      child: ClipRRect(
        borderRadius: kAgendaPillRadius,
        child: Container(
          height: kAgendaControlHeight,
          decoration: BoxDecoration(
            borderRadius: kAgendaPillRadius,
            border: Border.all(color: Colors.grey.withOpacity(0.35)),
            color: backgroundColor,
          ),
          child: Padding(
            padding: const EdgeInsets.symmetric(
              horizontal: kAgendaControlHorizontalPadding,
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  Icons.calendar_today_outlined,
                  size: 18,
                  color: colorScheme.onSurface,
                ),
                const SizedBox(width: 8),
                Flexible(
                  child: Text(widget.label, overflow: TextOverflow.ellipsis),
                ),
                const SizedBox(width: 8),
                const Icon(Icons.keyboard_arrow_down_rounded, size: 20),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class AgendaLocationSelector extends ConsumerStatefulWidget {
  const AgendaLocationSelector({
    super.key,
    required this.locations,
    required this.current,
    required this.onSelected,
    this.iconOnly = false,
  });

  final List<Location> locations;
  final Location current;
  final void Function(int id) onSelected;
  final bool iconOnly;

  @override
  ConsumerState<AgendaLocationSelector> createState() =>
      _AgendaLocationSelectorState();
}

class _AgendaLocationSelectorState
    extends ConsumerState<AgendaLocationSelector> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final interactions = Theme.of(context).extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = _isHovered
        ? Color.alphaBlend(hoverFill, colorScheme.surface)
        : colorScheme.surface;
    final l10n = context.l10n;

    return AdaptiveDropdown<int>(
      items: [
        for (final location in widget.locations)
          AdaptiveDropdownItem<int>(
            value: location.id,
            child: Text(location.name),
          ),
      ],
      selectedValue: widget.current.id,
      onSelected: widget.onSelected,
      modalTitle: l10n.agendaSelectLocation,
      popupWidth: 200,
      useRootNavigator: true,
      onOpened: () => setState(() => _isHovered = true),
      onClosed: () => setState(() => _isHovered = false),
      child: MouseRegion(
        onEnter: (_) {
          if (!_isHovered) setState(() => _isHovered = true);
        },
        onExit: (_) {
          if (_isHovered) setState(() => _isHovered = false);
        },
        child: Semantics(
          button: true,
          label: l10n.agendaSelectLocation,
          child: widget.iconOnly
              ? Tooltip(
                  message: l10n.agendaSelectLocation,
                  child: Container(
                    height: kAgendaControlHeight,
                    width: kAgendaControlHeight,
                    alignment: Alignment.center,
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(
                        kAgendaControlHeight / 2,
                      ),
                      color: backgroundColor,
                    ),
                    child: Icon(
                      Icons.place_outlined,
                      size: 30,
                      color: colorScheme.onSurfaceVariant,
                    ),
                  ),
                )
              : ClipRRect(
                  borderRadius: kAgendaPillRadius,
                  child: Container(
                    height: kAgendaControlHeight,
                    decoration: BoxDecoration(
                      borderRadius: kAgendaPillRadius,
                      border: Border.all(color: Colors.grey.withOpacity(0.35)),
                      color: backgroundColor,
                    ),
                    child: LayoutBuilder(
                      builder: (context, constraints) {
                        const compactBreakpoint = 220.0;
                        final maxWidth = constraints.maxWidth;
                        final isCompact =
                            maxWidth.isFinite &&
                            maxWidth > 0 &&
                            maxWidth < compactBreakpoint;
                        final horizontalPadding = isCompact
                            ? 12.0
                            : kAgendaControlHorizontalPadding;

                        if (maxWidth.isFinite &&
                            maxWidth < kAgendaControlHeight) {
                          return const SizedBox.shrink();
                        }

                        return Padding(
                          padding: EdgeInsets.symmetric(
                            horizontal: horizontalPadding,
                          ),
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Flexible(
                                child: Text(
                                  widget.current.name,
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                              const SizedBox(width: 8),
                              const Icon(
                                Icons.keyboard_arrow_down_rounded,
                                size: 20,
                              ),
                            ],
                          ),
                        );
                      },
                    ),
                  ),
                ),
        ),
      ),
    );
  }
}

/// Selettore di location per la sezione Staff.
/// Include l'opzione "Tutte le sedi" come valore di default (null).
class StaffLocationSelector extends ConsumerStatefulWidget {
  const StaffLocationSelector({
    super.key,
    required this.locations,
    required this.currentLocationId,
    required this.onSelected,
  });

  final List<Location> locations;
  final int? currentLocationId; // null = "Tutte le sedi"
  final void Function(int? id) onSelected;

  @override
  ConsumerState<StaffLocationSelector> createState() =>
      _StaffLocationSelectorState();
}

class _StaffLocationSelectorState extends ConsumerState<StaffLocationSelector> {
  bool _isHovered = false;

  String _getDisplayName(BuildContext context) {
    if (widget.currentLocationId == null) {
      return context.l10n.allLocations;
    }
    final location = widget.locations.firstWhere(
      (l) => l.id == widget.currentLocationId,
      orElse: () => widget.locations.first,
    );
    return location.name;
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final interactions = Theme.of(context).extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = _isHovered
        ? Color.alphaBlend(hoverFill, colorScheme.surface)
        : colorScheme.surface;
    final l10n = context.l10n;

    return AdaptiveDropdown<int?>(
      items: [
        // Opzione "Tutte le sedi" come prima voce
        AdaptiveDropdownItem<int?>(value: null, child: Text(l10n.allLocations)),
        // Separator
        for (final location in widget.locations)
          AdaptiveDropdownItem<int?>(
            value: location.id,
            child: Text(location.name),
          ),
      ],
      selectedValue: widget.currentLocationId,
      onSelected: widget.onSelected,
      modalTitle: l10n.agendaSelectLocation,
      popupWidth: 200,
      useRootNavigator: true,
      onOpened: () => setState(() => _isHovered = true),
      onClosed: () => setState(() => _isHovered = false),
      child: MouseRegion(
        onEnter: (_) {
          if (!_isHovered) setState(() => _isHovered = true);
        },
        onExit: (_) {
          if (_isHovered) setState(() => _isHovered = false);
        },
        child: Semantics(
          button: true,
          label: l10n.agendaSelectLocation,
          child: ClipRRect(
            borderRadius: kAgendaPillRadius,
            child: Container(
              height: kAgendaControlHeight,
              decoration: BoxDecoration(
                borderRadius: kAgendaPillRadius,
                border: Border.all(color: Colors.grey.withOpacity(0.35)),
                color: backgroundColor,
              ),
              child: LayoutBuilder(
                builder: (context, constraints) {
                  const compactBreakpoint = 220.0;
                  final maxWidth = constraints.maxWidth;
                  final isCompact =
                      maxWidth.isFinite &&
                      maxWidth > 0 &&
                      maxWidth < compactBreakpoint;
                  final horizontalPadding = isCompact
                      ? 12.0
                      : kAgendaControlHorizontalPadding;

                  return Padding(
                    padding: EdgeInsets.symmetric(
                      horizontal: horizontalPadding,
                    ),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Flexible(
                          child: Text(
                            _getDisplayName(context),
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        const SizedBox(width: 8),
                        const Icon(Icons.keyboard_arrow_down_rounded, size: 20),
                      ],
                    ),
                  );
                },
              ),
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/app/widgets/staff_circle_avatar.dart ---
import 'package:flutter/material.dart';

String initialsFromName(String name, {int maxChars = 3}) {
  final trimmed = name.trim();
  if (trimmed.isEmpty) return '';
  final parts = trimmed.split(RegExp(r'\s+')).where((p) => p.isNotEmpty).toList();
  var initials = '';
  if (parts.isNotEmpty) {
    initials += parts.first[0].toUpperCase();
  }
  for (int i = 1; i < parts.length && initials.length < maxChars; i++) {
    initials += parts[i][0].toUpperCase();
  }
  if (parts.length == 1 && initials.length < maxChars && trimmed.length > 1) {
    initials += trimmed[1].toUpperCase();
  }
  final end = initials.length.clamp(1, maxChars);
  return initials.substring(0, end);
}

class StaffCircleAvatar extends StatelessWidget {
  final double height;
  final Color color;
  final bool isHighlighted;
  final String initials;
  final Widget? child;

  const StaffCircleAvatar({
    super.key,
    required this.height,
    required this.color,
    required this.isHighlighted,
    required this.initials,
    this.child,
  });

  @override
  Widget build(BuildContext context) {
    final hasThreeLetterInitials = initials.length == 3;
    final initialsFontSize = height * (hasThreeLetterInitials ? 0.30 : 0.35);
    return Container(
      width: height,
      height: height,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: Border.all(
          color: isHighlighted ? color : color.withOpacity(0.35),
          width: isHighlighted ? 2 : 1,
        ),
      ),
      alignment: Alignment.center,
      child: Container(
        margin: const EdgeInsets.all(2),
        decoration: BoxDecoration(
          shape: BoxShape.circle,
          color: color.withOpacity(0.18),
        ),
        alignment: Alignment.center,
        child: Padding(
          padding: EdgeInsets.all(height * 0.06),
          child: FittedBox(
            fit: BoxFit.scaleDown,
            child: child ??
                Text(
                  initials,
                  style: TextStyle(
                    color: color,
                    fontWeight: FontWeight.w600,
                    fontSize: initialsFontSize,
                  ),
                ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/app/widgets/top_controls_scaffold.dart ---
import 'dart:math' as math;

import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/l10n/l10n.dart';
import 'package:agenda_backend/core/models/location.dart';
import 'package:agenda_backend/features/agenda/domain/config/layout_config.dart';
import 'package:agenda_backend/features/agenda/providers/date_range_provider.dart';
import 'package:agenda_backend/features/agenda/providers/layout_config_provider.dart';
import 'package:agenda_backend/features/agenda/providers/location_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

typedef TopControlsBuilderFn =
    Widget Function(BuildContext context, TopControlsData data);

class TopControlsBuilder {
  TopControlsBuilder.single(TopControlsBuilderFn builder)
    : _single = builder,
      mobile = null,
      tablet = null,
      desktop = null;

  TopControlsBuilder.adaptive({this.mobile, this.tablet, this.desktop})
    : _single = null,
      assert(
        mobile != null || tablet != null || desktop != null,
        L10n.current.errorFormFactorBuilderRequired,
      );

  final TopControlsBuilderFn? _single;
  final TopControlsBuilderFn? mobile;
  final TopControlsBuilderFn? tablet;
  final TopControlsBuilderFn? desktop;

  Widget build(BuildContext context, TopControlsData data) {
    if (_single != null) {
      return _single(context, data);
    }
    final builder = _resolve(data.formFactor);
    return builder(context, data);
  }

  TopControlsBuilderFn _resolve(AppFormFactor factor) {
    TopControlsBuilderFn? resolved;
    switch (factor) {
      case AppFormFactor.mobile:
        resolved = mobile ?? tablet ?? desktop;
        break;
      case AppFormFactor.tablet:
        resolved = tablet ?? desktop ?? mobile;
        break;
      case AppFormFactor.desktop:
        resolved = desktop ?? tablet ?? mobile;
        break;
    }
    if (resolved == null) {
      throw StateError(L10n.current.errorFormFactorBuilderMissing(factor.name));
    }
    return resolved;
  }
}

class TopControlsData {
  const TopControlsData({
    required this.l10n,
    required this.locale,
    required this.agendaDate,
    required this.layoutConfig,
    required this.formFactor,
    required this.locations,
    required this.currentLocation,
    required this.dateController,
    required this.locationController,
  });

  final L10n l10n;
  final Locale locale;
  final DateTime agendaDate;
  final LayoutConfig layoutConfig;
  final AppFormFactor formFactor;
  final List<Location> locations;
  final Location currentLocation;
  final AgendaDateNotifier dateController;
  final CurrentLocationId locationController;

  bool get isToday => DateUtils.isSameDay(agendaDate, DateTime.now());
}

/// Widget wrapper riutilizzabile per i controlli superiori dell'agenda/staff.
///
/// Si occupa di:
/// - leggere i provider condivisi (data corrente, locations, ecc.)
/// - calcolare gli offset comuni (hour column + navigation rail)
/// - mostrare automaticamente il fallback se non ci sono locations
class TopControlsScaffold extends ConsumerWidget {
  const TopControlsScaffold({
    super.key,
    required this.builder,
    this.alignment = AlignmentDirectional.centerStart,
    this.padding = EdgeInsets.zero,
    this.applyLayoutInset = true,
  });

  final TopControlsBuilder builder;
  final AlignmentGeometry alignment;
  final EdgeInsetsGeometry padding;
  // Permette di applicare l'offset calcolato per allineare ai contenuti
  // principali (hour column + navigation rail). Disattivato di default per
  // far partire i controlli esattamente a sinistra nell'app bar.
  final bool applyLayoutInset;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final locations = ref.watch(locationsProvider);
    if (locations.isEmpty) {
      return const SizedBox.shrink();
    }

    final agendaDate = ref.watch(agendaDateProvider);
    final currentLocation = ref.watch(currentLocationProvider);

    final data = TopControlsData(
      l10n: l10n,
      locale: Localizations.localeOf(context),
      agendaDate: agendaDate,
      layoutConfig: layoutConfig,
      formFactor: formFactor,
      locations: locations,
      currentLocation: currentLocation,
      dateController: ref.read(agendaDateProvider.notifier),
      locationController: ref.read(currentLocationIdProvider.notifier),
    );

    final leftInset = applyLayoutInset
        ? _computeLeftInset(context, layoutConfig, formFactor)
        : 0.0;
    Widget child = LayoutBuilder(
      builder: (context, constraints) {
        return builder.build(context, data);
      },
    );

    return Align(
      alignment: alignment,
      child: Padding(
        padding: EdgeInsetsDirectional.only(start: leftInset).add(padding),
        child: child,
      ),
    );
  }

  double _computeLeftInset(
    BuildContext context,
    LayoutConfig layoutConfig,
    AppFormFactor formFactor,
  ) {
    final railTheme = NavigationRailTheme.of(context);
    final railWidth = railTheme.minWidth ?? 72.0;
    const railDividerWidth = 1.0;
    final baseInset =
        layoutConfig.hourColumnWidth - NavigationToolbar.kMiddleSpacing;
    final railInset = formFactor != AppFormFactor.mobile
        ? railWidth + railDividerWidth
        : 0.0;

    return math.max(0.0, baseInset + railInset);
  }
}
--- FILE: lib/features/clients/providers/clients_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/appointment.dart';
import '../../../core/network/network_providers.dart';
import '../../agenda/providers/appointment_providers.dart';
import '../../agenda/providers/business_providers.dart';
import '../../auth/providers/auth_provider.dart';
import '../data/clients_repository.dart';
import '../domain/client_sort_option.dart';
import '../domain/clients.dart';

// Repository provider con ApiClient
final clientsRepositoryProvider = Provider<ClientsRepository>((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return ClientsRepository(apiClient: apiClient);
});

/// AsyncNotifier per caricare i clienti dall'API
class ClientsNotifier extends AsyncNotifier<List<Client>> {
  @override
  Future<List<Client>> build() async {
    // Verifica autenticazione
    final authState = ref.watch(authProvider);
    if (!authState.isAuthenticated) {
      return [];
    }

    final business = ref.watch(currentBusinessProvider);
    if (business.id <= 0) {
      return [];
    }

    final repository = ref.watch(clientsRepositoryProvider);
    final clients = await repository.getAll(business.id);
    return clients;
  }

  /// Ricarica i clienti dall'API
  Future<void> refresh() async {
    // Verifica autenticazione prima di chiamare API
    final authState = ref.read(authProvider);
    if (!authState.isAuthenticated) {
      return;
    }

    final business = ref.read(currentBusinessProvider);
    if (business.id <= 0) {
      return;
    }

    state = const AsyncValue.loading();
    state = await AsyncValue.guard(() async {
      final repository = ref.read(clientsRepositoryProvider);
      final clients = await repository.getAll(business.id);
      return clients;
    });
  }

  /// Aggiunge un nuovo cliente via API e aggiorna lo state locale
  Future<Client> addClient(Client client) async {
    final repository = ref.read(clientsRepositoryProvider);
    final newClient = await repository.add(client);
    state = AsyncValue.data([...state.value ?? [], newClient]);
    return newClient;
  }

  /// Aggiorna un cliente via API e aggiorna lo state locale
  Future<void> updateClient(Client client) async {
    final repository = ref.read(clientsRepositoryProvider);
    final updated = await repository.save(client);
    state = AsyncValue.data([
      for (final c in state.value ?? [])
        if (c.id == updated.id) updated else c,
    ]);
  }

  /// Soft delete - imposta isArchived = true
  Future<void> deleteClient(int id) async {
    final current = state.value?.firstWhere((c) => c.id == id);
    if (current == null) return;
    final archived = current.copyWith(isArchived: true);
    await updateClient(archived);
  }
}

final clientsProvider = AsyncNotifierProvider<ClientsNotifier, List<Client>>(
  ClientsNotifier.new,
);

// Indicizzazione rapida per id (restituisce mappa vuota se ancora in caricamento)
final clientsByIdProvider = Provider<Map<int, Client>>((ref) {
  final asyncClients = ref.watch(clientsProvider);
  final list = asyncClients.value ?? [];
  return {for (final c in list) c.id: c};
});

/// Notifier per il criterio di ordinamento corrente
class ClientSortOptionNotifier extends Notifier<ClientSortOption> {
  @override
  ClientSortOption build() => ClientSortOption.nameAsc;

  void set(ClientSortOption option) => state = option;
}

final clientSortOptionProvider =
    NotifierProvider<ClientSortOptionNotifier, ClientSortOption>(
      ClientSortOptionNotifier.new,
    );

/// Provider per la query di ricerca clienti (persistente tra cambi tab)
class ClientSearchQueryNotifier extends Notifier<String> {
  @override
  String build() => '';

  void set(String query) => state = query;

  void clear() => state = '';
}

final clientSearchQueryProvider =
    NotifierProvider<ClientSearchQueryNotifier, String>(
      ClientSearchQueryNotifier.new,
    );

/// Ordina una lista di clienti secondo il criterio specificato
List<Client> _sortClients(List<Client> clients, ClientSortOption sort) {
  final sorted = List<Client>.from(clients);

  switch (sort) {
    case ClientSortOption.nameAsc:
      sorted.sort(
        (a, b) => (a.firstName ?? '').toLowerCase().compareTo(
          (b.firstName ?? '').toLowerCase(),
        ),
      );
    case ClientSortOption.nameDesc:
      sorted.sort(
        (a, b) => (b.firstName ?? '').toLowerCase().compareTo(
          (a.firstName ?? '').toLowerCase(),
        ),
      );
    case ClientSortOption.lastNameAsc:
      sorted.sort(
        (a, b) => (a.lastName ?? '').toLowerCase().compareTo(
          (b.lastName ?? '').toLowerCase(),
        ),
      );
    case ClientSortOption.lastNameDesc:
      sorted.sort(
        (a, b) => (b.lastName ?? '').toLowerCase().compareTo(
          (a.lastName ?? '').toLowerCase(),
        ),
      );
    case ClientSortOption.lastVisitDesc:
      sorted.sort((a, b) {
        if (a.lastVisit == null && b.lastVisit == null) return 0;
        if (a.lastVisit == null) return 1;
        if (b.lastVisit == null) return -1;
        return b.lastVisit!.compareTo(a.lastVisit!);
      });
    case ClientSortOption.lastVisitAsc:
      sorted.sort((a, b) {
        if (a.lastVisit == null && b.lastVisit == null) return 0;
        if (a.lastVisit == null) return 1;
        if (b.lastVisit == null) return -1;
        return a.lastVisit!.compareTo(b.lastVisit!);
      });
    case ClientSortOption.createdAtDesc:
      sorted.sort((a, b) => b.createdAt.compareTo(a.createdAt));
    case ClientSortOption.createdAtAsc:
      sorted.sort((a, b) => a.createdAt.compareTo(b.createdAt));
  }

  return sorted;
}

/// Provider che restituisce la lista clienti ordinata secondo il criterio corrente
/// Esclude i clienti archiviati (isArchived = true)
final sortedClientsProvider = Provider<List<Client>>((ref) {
  final asyncClients = ref.watch(clientsProvider);
  final clients = (asyncClients.value ?? [])
      .where((c) => !c.isArchived)
      .toList();
  final sortOption = ref.watch(clientSortOptionProvider);
  return _sortClients(clients, sortOption);
});

// Ricerca base (case-insensitive su name + email + phone) con ordinamento
// Esclude i clienti archiviati (isArchived = true)
final clientsSearchProvider = Provider.family<List<Client>, String>((ref, q) {
  final sortOption = ref.watch(clientSortOptionProvider);
  final query = q.trim().toLowerCase();
  final asyncClients = ref.watch(clientsProvider);
  final allClients = asyncClients.value ?? [];

  List<Client> result;
  if (query.isEmpty) {
    result = allClients.where((c) => !c.isArchived).toList();
  } else {
    result = allClients
        .where(
          (c) =>
              !c.isArchived &&
              (c.name.toLowerCase().contains(query) ||
                  (c.email?.toLowerCase().contains(query) ?? false) ||
                  (c.phone?.toLowerCase().contains(query) ?? false)),
        )
        .toList();
  }

  return _sortClients(result, sortOption);
});

/// Provider che restituisce i clienti filtrati usando clientSearchQueryProvider
/// Questo √® il provider principale da usare nella UI
final filteredClientsProvider = Provider<List<Client>>((ref) {
  final query = ref.watch(clientSearchQueryProvider);
  return ref.watch(clientsSearchProvider(query));
});

/// Provider che restituisce il conteggio totale dei clienti (non archiviati)
final totalClientsCountProvider = Provider<int>((ref) {
  final asyncClients = ref.watch(clientsProvider);
  final allClients = asyncClients.value ?? [];
  return allClients.where((c) => !c.isArchived).length;
});

// Segmenti
const _kInactiveDays = 90;
const _kNewDays = 45;
const _kFrequentThreshold = 10; // placeholder (in futuro basato su bookings)

DateTime _now() => DateTime.now();

final inactiveClientsProvider = Provider<List<Client>>((ref) {
  final limit = _now().subtract(const Duration(days: _kInactiveDays));
  final asyncClients = ref.watch(clientsProvider);
  return (asyncClients.value ?? [])
      .where(
        (c) =>
            !c.isArchived &&
            (c.lastVisit == null || c.lastVisit!.isBefore(limit)),
      )
      .toList();
});

final newClientsProvider = Provider<List<Client>>((ref) {
  final limit = _now().subtract(const Duration(days: _kNewDays));
  final asyncClients = ref.watch(clientsProvider);
  return (asyncClients.value ?? [])
      .where((c) => !c.isArchived && c.createdAt.isAfter(limit))
      .toList();
});

final vipClientsProvider = Provider<List<Client>>((ref) {
  final asyncClients = ref.watch(clientsProvider);
  return (asyncClients.value ?? [])
      .where((c) => !c.isArchived && (c.tags?.contains('VIP') ?? false))
      .toList();
});

final frequentClientsProvider = Provider<List<Client>>((ref) {
  final asyncClients = ref.watch(clientsProvider);
  // Placeholder: usa loyaltyPoints come proxy delle visite
  return (asyncClients.value ?? [])
      .where(
        (c) => !c.isArchived && (c.loyaltyPoints ?? 0) >= _kFrequentThreshold,
      )
      .toList();
});

// Collegamenti Booking <-> Client (stub per futura integrazione bookings reali)
final clientWithAppointmentsProvider = Provider.family<List<Appointment>, int>((
  ref,
  clientId,
) {
  final all = ref.watch(appointmentsProvider).value ?? [];
  return all.where((a) => a.clientId == clientId).toList();
});

final bookingIdsByClientProvider = Provider.family<Set<int>, int>((
  ref,
  clientId,
) {
  final appointments = ref.watch(clientWithAppointmentsProvider(clientId));
  return appointments.map((a) => a.bookingId).toSet();
});
--- FILE: lib/features/clients/utils/client_validators.dart ---
// Intenzionalmente vuoto: placeholder per futuri validator dei clients.
--- FILE: lib/features/clients/utils/client_formatters.dart ---
// Intenzionalmente vuoto: placeholder per futuri formatter dei clients.
--- FILE: lib/features/clients/controllers/clients_search_controller.dart ---
// Intenzionalmente vuoto: placeholder per un eventuale controller di ricerca clients (Riverpod).
--- FILE: lib/features/clients/data/clients_api.dart ---
import '../../../core/network/api_client.dart';
import '../../../core/network/api_config.dart';
import '../domain/clients.dart';

/// API layer per Clients - chiamate reali a agenda_core
class ClientsApi {
  final ApiClient _apiClient;

  ClientsApi({required ApiClient apiClient}) : _apiClient = apiClient;

  /// GET /v1/clients?business_id=X
  Future<List<Client>> fetchClients(int businessId) async {
    final data = await _apiClient.getClients(businessId);
    final List<dynamic> items = data['clients'] ?? [];
    return items.map((json) => _clientFromJson(json)).toList();
  }

  /// POST /v1/clients
  Future<Client> createClient(Client client) async {
    final data = await _apiClient.post(
      ApiConfig.clients,
      data: _clientToJson(client),
    );
    return _clientFromJson(data);
  }

  /// PUT /v1/clients/{id}
  Future<Client> updateClient(Client client) async {
    final data = await _apiClient.put(
      '${ApiConfig.clients}/${client.id}',
      data: _clientToJson(client),
    );
    return _clientFromJson(data);
  }

  /// DELETE /v1/clients/{id}
  Future<void> deleteClient(int clientId) async {
    await _apiClient.delete('${ApiConfig.clients}/$clientId');
  }

  /// Converte JSON snake_case in Client
  Client _clientFromJson(Map<String, dynamic> json) {
    return Client(
      id: json['id'] as int,
      businessId: json['business_id'] as int,
      firstName: json['first_name'] as String?,
      lastName: json['last_name'] as String?,
      email: json['email'] as String?,
      phone: json['phone'] as String?,
      gender: json['gender'] as String?,
      birthDate: json['birth_date'] != null
          ? DateTime.parse(json['birth_date'] as String)
          : null,
      city: json['city'] as String?,
      notes: json['notes'] as String?,
      createdAt: DateTime.parse(json['created_at'] as String),
      lastVisit: json['last_visit'] != null
          ? DateTime.parse(json['last_visit'] as String)
          : null,
      loyaltyPoints: json['loyalty_points'] as int?,
      tags: json['tags'] != null
          ? List<String>.from(json['tags'] as List)
          : null,
      isArchived: json['is_archived'] as bool? ?? false,
    );
  }

  /// Converte Client in JSON snake_case
  /// I campi nullable vengono sempre inviati per permettere la rimozione del valore
  Map<String, dynamic> _clientToJson(Client client) {
    return {
      'business_id': client.businessId,
      'first_name': client.firstName,
      'last_name': client.lastName,
      'email': client.email,
      'phone': client.phone,
      'gender': client.gender,
      'birth_date': client.birthDate?.toIso8601String().split('T')[0],
      'city': client.city,
      'notes': client.notes,
      'tags': client.tags,
      'is_archived': client.isArchived,
    };
  }
}
--- FILE: lib/features/clients/data/clients_repository.dart ---
import '../../../core/network/api_client.dart';
import '../domain/clients.dart';
import 'clients_api.dart';

class ClientsRepository {
  ClientsRepository({required ApiClient apiClient})
    : _api = ClientsApi(apiClient: apiClient);

  final ClientsApi _api;

  Future<List<Client>> getAll(int businessId) => _api.fetchClients(businessId);
  Future<Client> add(Client client) => _api.createClient(client);
  Future<Client> save(Client client) => _api.updateClient(client);
  Future<void> delete(int clientId) => _api.deleteClient(clientId);
}
--- FILE: lib/features/clients/domain/client_sort_option.dart ---
/// Criteri di ordinamento per la lista clienti
enum ClientSortOption {
  /// Ordina per nome (A-Z)
  nameAsc,

  /// Ordina per nome (Z-A)
  nameDesc,

  /// Ordina per cognome (A-Z)
  lastNameAsc,

  /// Ordina per cognome (Z-A)
  lastNameDesc,

  /// Ordina per ultima visita (pi√π recenti prima)
  lastVisitDesc,

  /// Ordina per ultima visita (meno recenti prima)
  lastVisitAsc,

  /// Ordina per data creazione (nuovi prima)
  createdAtDesc,

  /// Ordina per data creazione (vecchi prima)
  createdAtAsc,
}
--- FILE: lib/features/clients/domain/clients.dart ---
class Client {
  final int id;
  final int businessId;
  final String? firstName;
  final String? lastName;
  final String? email;
  final String? phone;
  final String? gender;
  final DateTime? birthDate;
  final String? city;
  final String? notes;
  final DateTime createdAt;
  final DateTime? lastVisit;
  final int? loyaltyPoints;
  final List<String>? tags;
  final bool isArchived;

  const Client({
    required this.id,
    required this.businessId,
    this.firstName,
    this.lastName,
    this.email,
    this.phone,
    this.gender,
    this.birthDate,
    this.city,
    this.notes,
    required this.createdAt,
    this.lastVisit,
    this.loyaltyPoints,
    this.tags,
    this.isArchived = false,
  });

  /// Nome completo (firstName + lastName)
  String get name {
    final parts = <String>[];
    if (firstName != null && firstName!.isNotEmpty) parts.add(firstName!);
    if (lastName != null && lastName!.isNotEmpty) parts.add(lastName!);
    return parts.join(' ');
  }

  /// Prefissi comuni nei cognomi italiani (e alcune varianti internazionali)
  static const _lastNamePrefixes = {
    // Italiani
    'de', 'di', 'da', 'del', 'della', 'delle', 'dei', 'degli',
    'dall', "dall'", 'dalla', 'dallo', 'dalle', 'dagli',
    'la', 'lo', 'li', 'le',
    // Internazionali comuni
    'van', 'von', 'den', 'der', 'ter', 'ten',
    'mc', 'mac', "o'", 'al', 'el', 'ben', 'bin',
  };

  /// Crea un Client a partire da un nome completo, separando automaticamente
  /// nome e cognome. Riconosce cognomi composti con prefissi (es. "La Rosa", "De Luca").
  static ({String? firstName, String? lastName}) splitFullName(
    String fullName,
  ) {
    final trimmed = fullName.trim();
    if (trimmed.isEmpty) {
      return (firstName: null, lastName: null);
    }

    final parts = trimmed.split(RegExp(r'\s+'));
    if (parts.length == 1) {
      // Solo una parola: la consideriamo come firstName
      return (firstName: parts.first, lastName: null);
    }

    if (parts.length == 2) {
      // Due parole: firstName + lastName
      return (firstName: parts[0], lastName: parts[1]);
    }

    // 3+ parole: cerchiamo un prefisso di cognome
    // Partiamo dalla penultima parola e vediamo se √® un prefisso
    int lastNameStartIndex = parts.length - 1;

    for (int i = parts.length - 2; i >= 1; i--) {
      final word = parts[i].toLowerCase().replaceAll("'", "'");
      if (_lastNamePrefixes.contains(word)) {
        lastNameStartIndex = i;
      } else {
        // Se troviamo una parola che non √® un prefisso, ci fermiamo
        break;
      }
    }

    final firstName = parts.sublist(0, lastNameStartIndex).join(' ');
    final lastName = parts.sublist(lastNameStartIndex).join(' ');

    return (firstName: firstName, lastName: lastName);
  }

  Client copyWith({
    int? id,
    int? businessId,
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
    String? gender,
    DateTime? birthDate,
    String? city,
    String? notes,
    DateTime? createdAt,
    DateTime? lastVisit,
    int? loyaltyPoints,
    List<String>? tags,
    bool? isArchived,
  }) {
    return Client(
      id: id ?? this.id,
      businessId: businessId ?? this.businessId,
      firstName: firstName ?? this.firstName,
      lastName: lastName ?? this.lastName,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      gender: gender ?? this.gender,
      birthDate: birthDate ?? this.birthDate,
      city: city ?? this.city,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      lastVisit: lastVisit ?? this.lastVisit,
      loyaltyPoints: loyaltyPoints ?? this.loyaltyPoints,
      tags: tags ?? this.tags,
      isArchived: isArchived ?? this.isArchived,
    );
  }
}
--- FILE: lib/features/clients/presentation/dialogs/client_appointments_dialog.dart ---
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/appointment.dart';
import '../../domain/clients.dart';
import '../../providers/clients_providers.dart';

/// Mostra il dialog con la cronologia appuntamenti del cliente.
Future<void> showClientAppointmentsDialog(
  BuildContext context,
  WidgetRef ref, {
  required Client client,
}) async {
  await showDialog(
    context: context,
    builder: (_) => ClientAppointmentsDialog(client: client),
  );
}

class ClientAppointmentsDialog extends ConsumerWidget {
  const ClientAppointmentsDialog({super.key, required this.client});

  final Client client;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final appointments = ref.watch(clientWithAppointmentsProvider(client.id));
    final now = DateTime.now();

    // Dividi in passati e futuri
    final upcoming =
        appointments.where((a) => a.startTime.isAfter(now)).toList()
          ..sort((a, b) => a.startTime.compareTo(b.startTime));
    final past =
        appointments
            .where((a) => a.startTime.isBefore(now) || a.startTime == now)
            .toList()
          ..sort(
            (a, b) => b.startTime.compareTo(a.startTime),
          ); // pi√π recenti prima

    final screenWidth = MediaQuery.of(context).size.width;
    final dialogWidth = screenWidth < 600 ? screenWidth * 0.95 : 500.0;

    return CallbackShortcuts(
      bindings: <ShortcutActivator, VoidCallback>{
        SingleActivator(LogicalKeyboardKey.escape): () =>
            Navigator.of(context, rootNavigator: true).pop(),
      },
      child: Focus(
        autofocus: true,
        child: AlertDialog(
          title: Text(l10n.clientAppointmentsTitle(client.name)),
          content: SizedBox(
            width: dialogWidth,
            height: 400,
            child: DefaultTabController(
              length: 2,
              child: Column(
                children: [
                  TabBar(
                    tabs: [
                      Tab(
                        text:
                            '${l10n.clientAppointmentsUpcoming} (${upcoming.length})',
                      ),
                      Tab(
                        text: '${l10n.clientAppointmentsPast} (${past.length})',
                      ),
                    ],
                    labelColor: theme.colorScheme.primary,
                    unselectedLabelColor: theme.colorScheme.onSurfaceVariant,
                    indicatorColor: theme.colorScheme.primary,
                  ),
                  const SizedBox(height: 8),
                  Expanded(
                    child: TabBarView(
                      children: [
                        _AppointmentList(
                          appointments: upcoming,
                          emptyMessage: l10n.clientAppointmentsEmpty,
                        ),
                        _AppointmentList(
                          appointments: past,
                          emptyMessage: l10n.clientAppointmentsEmpty,
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: Text(l10n.actionClose),
            ),
          ],
        ),
      ),
    );
  }
}

class _AppointmentList extends ConsumerWidget {
  const _AppointmentList({
    required this.appointments,
    required this.emptyMessage,
  });

  final List<Appointment> appointments;
  final String emptyMessage;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    if (appointments.isEmpty) {
      return Center(
        child: Text(
          emptyMessage,
          style: Theme.of(context).textTheme.bodyMedium?.copyWith(
            color: Theme.of(context).colorScheme.onSurfaceVariant,
          ),
        ),
      );
    }

    return ListView.separated(
      itemCount: appointments.length,
      separatorBuilder: (_, __) => const Divider(height: 1),
      itemBuilder: (context, index) {
        final appointment = appointments[index];
        return _AppointmentTile(appointment: appointment);
      },
    );
  }
}

class _AppointmentTile extends ConsumerWidget {
  const _AppointmentTile({required this.appointment});

  final Appointment appointment;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final locale = Localizations.localeOf(context).toLanguageTag();

    // Recupera staff
    final allStaff = ref.watch(sortedAllStaffProvider);
    final staff = allStaff
        .where((s) => s.id == appointment.staffId)
        .firstOrNull;

    final dateFormat = DateFormat('EEE d MMM', locale);
    final timeFormat = DateFormat('HH:mm', locale);

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Data e ora
          SizedBox(
            width: 90,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  dateFormat.format(appointment.startTime),
                  style: theme.textTheme.bodyMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                Text(
                  timeFormat.format(appointment.startTime),
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(width: 12),
          // Servizio e staff
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  appointment.serviceName,
                  style: theme.textTheme.bodyMedium,
                ),
                if (staff != null)
                  Text(
                    staff.name,
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
              ],
            ),
          ),
          // Durata
          Text(
            '${appointment.totalDuration} min',
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/clients/presentation/dialogs/client_edit_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../app/theme/app_spacing.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../domain/clients.dart';
import '../../providers/clients_providers.dart';
import '../widgets/client_form.dart';

/// Mostra il dialog per creare o modificare un cliente.
/// Su mobile usa un modal bottom sheet full-screen, su tablet/desktop un dialog.
/// Ritorna il [Client] salvato (creato o modificato), oppure null se annullato.
///
/// Se [client] ha un id <= 0, il dialog sar√† in modalit√† creazione.
/// Se [client] ha un id > 0, il dialog sar√† in modalit√† modifica.
Future<Client?> showClientEditDialog(
  BuildContext context,
  WidgetRef ref, {
  Client? client,
}) async {
  final formFactor = ref.read(formFactorProvider);

  if (formFactor == AppFormFactor.desktop) {
    return await showDialog<Client>(
      context: context,
      barrierDismissible: false,
      builder: (_) => ClientEditDialog(initial: client),
    );
  } else {
    return await AppBottomSheet.show<Client>(
      context: context,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      heightFactor: AppBottomSheet.defaultHeightFactor,
      builder: (_) => ClientEditBottomSheet(initial: client),
    );
  }
}

class ClientEditDialog extends ConsumerStatefulWidget {
  const ClientEditDialog({super.key, this.initial});

  final Client? initial;

  /// Un cliente con id > 0 √® esistente (modifica), altrimenti √® nuovo (creazione).
  bool get isExistingClient => (initial?.id ?? 0) > 0;

  @override
  ConsumerState<ClientEditDialog> createState() => _ClientEditDialogState();
}

class _ClientEditDialogState extends ConsumerState<ClientEditDialog> {
  final _form = GlobalKey<ClientFormState>();
  bool _hasChanges = false;

  @override
  Widget build(BuildContext context) {
    final isEditing = widget.isExistingClient;
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return DismissibleDialog(
      child: Dialog(
        insetPadding: const EdgeInsets.symmetric(horizontal: 32, vertical: 24),
        child: ConstrainedBox(
          constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
          child: Padding(
            padding: const EdgeInsets.all(20),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Text(
                  isEditing ? l10n.clientsEdit : l10n.clientsNew,
                  style: theme.textTheme.headlineSmall,
                ),
                const SizedBox(height: 16),
                Flexible(
                  child: SingleChildScrollView(
                    child: ClientForm(
                      key: _form,
                      initial: widget.initial,
                      onChanged: () {
                        if (!_hasChanges) setState(() => _hasChanges = true);
                      },
                    ),
                  ),
                ),
                const SizedBox(height: 24),
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    if (isEditing) ...[
                      SizedBox(
                        width: AppButtonStyles.dialogButtonWidth,
                        child: AppDangerButton(
                          onPressed: _onDelete,
                          padding: AppButtonStyles.dialogButtonPadding,
                          child: Text(l10n.actionDelete),
                        ),
                      ),
                      const Spacer(),
                    ],
                    SizedBox(
                      width: AppButtonStyles.dialogButtonWidth,
                      child: AppOutlinedActionButton(
                        onPressed: () => _onCancel(context),
                        padding: AppButtonStyles.dialogButtonPadding,
                        child: Text(l10n.actionCancel),
                      ),
                    ),
                    const SizedBox(width: 8),
                    SizedBox(
                      width: AppButtonStyles.dialogButtonWidth,
                      child: AppFilledButton(
                        onPressed: _onSave,
                        padding: AppButtonStyles.dialogButtonPadding,
                        child: Text(l10n.actionSave),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _onCancel(BuildContext context) async {
    if (_hasChanges) {
      final confirm = await showConfirmDialog(
        context,
        title: Text(context.l10n.discardChangesTitle),
        content: Text(context.l10n.discardChangesMessage),
        confirmLabel: context.l10n.actionDiscard,
        cancelLabel: context.l10n.actionKeepEditing,
      );
      if (!confirm) return;
    }
    if (context.mounted) Navigator.of(context).pop();
  }

  Future<void> _onDelete() async {
    final client = widget.initial;
    if (client == null) return;

    final confirm = await showConfirmDialog(
      context,
      title: Text(context.l10n.deleteClientConfirmTitle),
      content: Text(context.l10n.deleteClientConfirmMessage),
      confirmLabel: context.l10n.actionDelete,
      danger: true,
    );
    if (!confirm) return;

    await ref.read(clientsProvider.notifier).deleteClient(client.id);
    if (mounted) Navigator.of(context).pop();
  }

  Future<void> _onSave() async {
    final formState = _form.currentState;
    if (formState == null) return;
    if (!formState.validate()) return;

    final client = formState.buildClient();
    Client savedClient;
    if (widget.isExistingClient) {
      await ref.read(clientsProvider.notifier).updateClient(client);
      savedClient = client;
    } else {
      savedClient = await ref.read(clientsProvider.notifier).addClient(client);
    }
    if (mounted) Navigator.of(context).pop(savedClient);
  }
}

/// Bottom sheet per modifica/creazione cliente su mobile.
/// Usa lo stesso layout degli altri bottom sheet dell'app.
class ClientEditBottomSheet extends ConsumerStatefulWidget {
  const ClientEditBottomSheet({super.key, this.initial});

  final Client? initial;

  /// Un cliente con id > 0 √® esistente (modifica), altrimenti √® nuovo (creazione).
  bool get isExistingClient => (initial?.id ?? 0) > 0;

  @override
  ConsumerState<ClientEditBottomSheet> createState() =>
      _ClientEditBottomSheetState();
}

class _ClientEditBottomSheetState extends ConsumerState<ClientEditBottomSheet> {
  final _form = GlobalKey<ClientFormState>();
  bool _hasChanges = false;

  @override
  Widget build(BuildContext context) {
    final isEditing = widget.isExistingClient;
    final l10n = context.l10n;
    final theme = Theme.of(context);

    final title = isEditing ? l10n.clientsEdit : l10n.clientsNew;

    // Azioni in basso - stesso stile di appointment_dialog
    final actions = <Widget>[
      if (isEditing)
        AppDangerButton(
          onPressed: _onDelete,
          padding: AppButtonStyles.dialogButtonPadding,
          child: Text(l10n.actionDelete),
        ),
      AppOutlinedActionButton(
        onPressed: () => _onCancel(context),
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppFilledButton(
        onPressed: _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionSave),
      ),
    ];

    // Usa le stesse dimensioni dei bottoni del dialog appuntamento per
    // mantenere coerenza visiva tra i form.
    final bottomActions = actions
        .map(
          (a) => SizedBox(width: AppButtonStyles.dialogButtonWidth, child: a),
        )
        .toList();

    return SafeArea(
      top: false,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final isKeyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
          return SizedBox(
            height: constraints.maxHeight,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Expanded(
                  child: SingleChildScrollView(
                    padding: EdgeInsets.only(bottom: 0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Padding(
                          padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Padding(
                                padding: const EdgeInsets.only(bottom: 12),
                                child: Text(
                                  title,
                                  style: theme.textTheme.titleLarge,
                                ),
                              ),
                              ClientForm(
                                key: _form,
                                initial: widget.initial,
                                onChanged: () {
                                  if (!_hasChanges) {
                                    setState(() => _hasChanges = true);
                                  }
                                },
                              ),
                              const SizedBox(height: 24),
                              const SizedBox(height: AppSpacing.formRowSpacing),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                if (!isKeyboardOpen) ...[
                  const AppBottomSheetDivider(),
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                    child: Align(
                      alignment: bottomActions.length == 3
                          ? Alignment.center
                          : Alignment.centerRight,
                      child: Wrap(
                        alignment: bottomActions.length == 3
                            ? WrapAlignment.center
                            : WrapAlignment.end,
                        spacing: 8,
                        runSpacing: 8,
                        children: bottomActions,
                      ),
                    ),
                  ),
                ],
                SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
              ],
            ),
          );
        },
      ),
    );
  }

  Future<void> _onCancel(BuildContext context) async {
    if (_hasChanges) {
      final confirm = await showConfirmDialog(
        context,
        title: Text(context.l10n.discardChangesTitle),
        content: Text(context.l10n.discardChangesMessage),
        confirmLabel: context.l10n.actionDiscard,
        cancelLabel: context.l10n.actionKeepEditing,
      );
      if (!confirm) return;
    }
    if (context.mounted) Navigator.of(context).pop();
  }

  Future<void> _onDelete() async {
    final client = widget.initial;
    if (client == null) return;

    final confirm = await showConfirmDialog(
      context,
      title: Text(context.l10n.deleteClientConfirmTitle),
      content: Text(context.l10n.deleteClientConfirmMessage),
      confirmLabel: context.l10n.actionDelete,
      danger: true,
    );
    if (!confirm) return;

    await ref.read(clientsProvider.notifier).deleteClient(client.id);
    if (mounted) Navigator.of(context).pop();
  }

  Future<void> _onSave() async {
    final formState = _form.currentState;
    if (formState == null) return;
    if (!formState.validate()) return;

    final client = formState.buildClient();
    Client savedClient;
    if (widget.isExistingClient) {
      await ref.read(clientsProvider.notifier).updateClient(client);
      savedClient = client;
    } else {
      savedClient = await ref.read(clientsProvider.notifier).addClient(client);
    }
    if (mounted) Navigator.of(context).pop(savedClient);
  }
}
--- FILE: lib/features/clients/presentation/clients_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/l10n/l10_extension.dart'; // üåç
import '../providers/clients_providers.dart';
import 'widgets/client_list.dart';
import 'widgets/clients_search_field.dart';
import 'widgets/clients_sort_dropdown.dart';

class ClientsScreen extends ConsumerWidget {
  const ClientsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final sortOption = ref.watch(clientSortOptionProvider);
    final clientsAsync = ref.watch(clientsProvider);
    final bottomPadding = MediaQuery.of(context).padding.bottom;
    final searchQuery = ref.watch(clientSearchQueryProvider);

    return Scaffold(
      body: clientsAsync.when(
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (e, _) => Center(child: Text('Errore: $e')),
        data: (_) {
          final filteredClients = ref.watch(filteredClientsProvider);
          final totalClients = ref.watch(totalClientsCountProvider);
          final hasSearch = searchQuery.trim().isNotEmpty;

          return Padding(
            padding: EdgeInsets.fromLTRB(16, 0, 16, 16 + bottomPadding),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                ClientsSearchField(
                  hintText: context.l10n.clientsTitle,
                  initialValue: searchQuery,
                  onChanged: (v) =>
                      ref.read(clientSearchQueryProvider.notifier).set(v),
                ),
                const SizedBox(height: 8),
                Row(
                  children: [
                    ClientsSortDropdown(
                      value: sortOption,
                      onChanged: (v) =>
                          ref.read(clientSortOptionProvider.notifier).set(v),
                    ),
                    const Spacer(),
                    Padding(
                      padding: const EdgeInsets.only(right: 8),
                      child: Text(
                        hasSearch
                            ? '${filteredClients.length}/$totalClients ${context.l10n.navClients.toLowerCase()}'
                            : '$totalClients ${context.l10n.navClients.toLowerCase()}',
                        style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                          color: Theme.of(context).colorScheme.outline,
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                const Expanded(child: ClientList()),
              ],
            ),
          );
        },
      ),
    );
  }
}
--- FILE: lib/features/clients/presentation/widgets/clients_filter_chips.dart ---
import 'package:flutter/material.dart';

class ClientsFilterChips extends StatelessWidget {
  final int selectedIndex; // 0=all,1=VIP,2=Inactive,3=New
  final ValueChanged<int> onSelectedIndex;
  final String labelAll;
  final String labelVIP;
  final String labelInactive;
  final String labelNew;

  const ClientsFilterChips({
    super.key,
    required this.selectedIndex,
    required this.onSelectedIndex,
    required this.labelAll,
    required this.labelVIP,
    required this.labelInactive,
    required this.labelNew,
  });

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: Wrap(
        spacing: 8,
        children: [
          ChoiceChip(
            label: Text(labelAll),
            selected: selectedIndex == 0,
            onSelected: (_) => onSelectedIndex(0),
          ),
          ChoiceChip(
            label: Text(labelVIP),
            selected: selectedIndex == 1,
            onSelected: (_) => onSelectedIndex(1),
          ),
          ChoiceChip(
            label: Text(labelInactive),
            selected: selectedIndex == 2,
            onSelected: (_) => onSelectedIndex(2),
          ),
          ChoiceChip(
            label: Text(labelNew),
            selected: selectedIndex == 3,
            onSelected: (_) => onSelectedIndex(3),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/clients/presentation/widgets/clients_sort_dropdown.dart ---
import 'package:agenda_backend/app/theme/extensions.dart';
import 'package:agenda_backend/core/widgets/adaptive_dropdown.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../domain/client_sort_option.dart';

/// Dropdown per selezionare il criterio di ordinamento della lista clienti.
class ClientsSortDropdown extends ConsumerStatefulWidget {
  const ClientsSortDropdown({
    super.key,
    required this.value,
    required this.onChanged,
  });

  final ClientSortOption value;
  final ValueChanged<ClientSortOption> onChanged;

  @override
  ConsumerState<ClientsSortDropdown> createState() =>
      _ClientsSortDropdownState();
}

class _ClientsSortDropdownState extends ConsumerState<ClientsSortDropdown> {
  bool _isHovered = false;

  String _getLabel(ClientSortOption option) {
    final l10n = context.l10n;
    switch (option) {
      case ClientSortOption.nameAsc:
        return l10n.sortByNameAsc;
      case ClientSortOption.nameDesc:
        return l10n.sortByNameDesc;
      case ClientSortOption.lastNameAsc:
        return l10n.sortByLastNameAsc;
      case ClientSortOption.lastNameDesc:
        return l10n.sortByLastNameDesc;
      case ClientSortOption.lastVisitDesc:
        return l10n.sortByLastVisitDesc;
      case ClientSortOption.lastVisitAsc:
        return l10n.sortByLastVisitAsc;
      case ClientSortOption.createdAtDesc:
        return l10n.sortByCreatedAtDesc;
      case ClientSortOption.createdAtAsc:
        return l10n.sortByCreatedAtAsc;
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final interactions = theme.extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = _isHovered
        ? Color.alphaBlend(hoverFill, colorScheme.surface)
        : colorScheme.surface;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      child: AdaptiveDropdown<ClientSortOption>(
        items: [
          AdaptiveDropdownItem(
            value: ClientSortOption.nameAsc,
            child: Text(l10n.sortByNameAsc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.nameDesc,
            child: Text(l10n.sortByNameDesc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.lastNameAsc,
            child: Text(l10n.sortByLastNameAsc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.lastNameDesc,
            child: Text(l10n.sortByLastNameDesc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.lastVisitDesc,
            child: Text(l10n.sortByLastVisitDesc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.lastVisitAsc,
            child: Text(l10n.sortByLastVisitAsc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.createdAtDesc,
            child: Text(l10n.sortByCreatedAtDesc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.createdAtAsc,
            child: Text(l10n.sortByCreatedAtAsc),
          ),
        ],
        selectedValue: widget.value,
        onSelected: widget.onChanged,
        modalTitle: l10n.sortByTitle,
        useRootNavigator: true,
        onOpened: () => setState(() => _isHovered = true),
        onClosed: () => setState(() => _isHovered = false),
        popupWidth: 220,
        child: MouseRegion(
          onEnter: (_) {
            if (!_isHovered) setState(() => _isHovered = true);
          },
          onExit: (_) {
            if (_isHovered) setState(() => _isHovered = false);
          },
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            decoration: BoxDecoration(
              color: backgroundColor,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: colorScheme.outline.withOpacity(0.2)),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(Icons.sort, size: 18, color: colorScheme.onSurfaceVariant),
                const SizedBox(width: 8),
                Flexible(
                  child: Text(
                    _getLabel(widget.value),
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: colorScheme.onSurface,
                    ),
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                const SizedBox(width: 8),
                Icon(
                  Icons.keyboard_arrow_down,
                  size: 20,
                  color: colorScheme.onSurfaceVariant,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/clients/presentation/widgets/client_form.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../app/theme/app_spacing.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/utils/string_utils.dart';
import '../../../../core/widgets/labeled_form_field.dart';
import '../../../../core/widgets/phone_input_field.dart';
import '../../../agenda/providers/business_providers.dart';
import '../../domain/clients.dart';

class ClientForm extends ConsumerStatefulWidget {
  const ClientForm({super.key, this.initial, this.onChanged});

  final Client? initial;
  final VoidCallback? onChanged;

  @override
  ConsumerState<ClientForm> createState() => ClientFormState();
}

class ClientFormState extends ConsumerState<ClientForm> {
  final _formKey = GlobalKey<FormState>();
  final _phoneFieldKey = GlobalKey<PhoneInputFieldState>();

  late final TextEditingController _firstName = TextEditingController(
    text: widget.initial?.firstName ?? '',
  );
  late final TextEditingController _lastName = TextEditingController(
    text: widget.initial?.lastName ?? '',
  );
  late final TextEditingController _email = TextEditingController(
    text: widget.initial?.email ?? '',
  );
  late final TextEditingController _notes = TextEditingController(
    text: widget.initial?.notes ?? '',
  );

  @override
  void dispose() {
    _firstName.dispose();
    _lastName.dispose();
    _email.dispose();
    _notes.dispose();
    super.dispose();
  }

  bool validate() => _formKey.currentState?.validate() ?? false;

  Client buildClient() {
    final base = widget.initial;
    final now = DateTime.now();
    final phoneState = _phoneFieldKey.currentState;
    final fullPhone = phoneState?.fullPhone;

    final firstName = _firstName.text.trim();
    final lastName = _lastName.text.trim();

    return Client(
      id: base?.id ?? -1,
      businessId: base?.businessId ?? ref.read(currentBusinessProvider).id,
      firstName: firstName.isEmpty ? null : StringUtils.toTitleCase(firstName),
      lastName: lastName.isEmpty ? null : StringUtils.toTitleCase(lastName),
      email: _email.text.trim().isEmpty ? null : _email.text.trim(),
      phone: (fullPhone == null || fullPhone.isEmpty) ? null : fullPhone,
      notes: _notes.text.trim().isEmpty ? null : _notes.text.trim(),
      createdAt: base?.createdAt ?? now,
      lastVisit: base?.lastVisit,
      loyaltyPoints: base?.loyaltyPoints,
      tags: base?.tags,
      isArchived: base?.isArchived ?? false,
    );
  }

  @override
  Widget build(BuildContext context) {
    final business = ref.watch(currentBusinessProvider);
    final l10n = context.l10n;
    final formFactor = ref.watch(formFactorProvider);
    final isSingleColumn = formFactor != AppFormFactor.desktop;

    final firstNameField = LabeledFormField(
      label: l10n.formFirstName,
      child: TextFormField(
        controller: _firstName,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        textInputAction: TextInputAction.next,
        textCapitalization: TextCapitalization.words,
        onChanged: (_) {
          _formKey.currentState?.validate();
          widget.onChanged?.call();
        },
        validator: (v) {
          final firstName = v?.trim() ?? '';
          final lastName = _lastName.text.trim();
          if (firstName.isEmpty && lastName.isEmpty) {
            return l10n.validationNameOrLastNameRequired;
          }
          return null;
        },
      ),
    );

    final lastNameField = LabeledFormField(
      label: l10n.formLastName,
      child: TextFormField(
        controller: _lastName,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        textInputAction: TextInputAction.next,
        textCapitalization: TextCapitalization.words,
        onChanged: (_) {
          _formKey.currentState?.validate();
          widget.onChanged?.call();
        },
        validator: (v) {
          final lastName = v?.trim() ?? '';
          final firstName = _firstName.text.trim();
          if (firstName.isEmpty && lastName.isEmpty) {
            return l10n.validationNameOrLastNameRequired;
          }
          return null;
        },
      ),
    );

    final emailField = LabeledFormField(
      label: l10n.formEmail,
      child: TextFormField(
        controller: _email,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        keyboardType: TextInputType.emailAddress,
        textInputAction: TextInputAction.next,
        onChanged: (_) => widget.onChanged?.call(),
        validator: (v) {
          final t = v?.trim() ?? '';
          if (t.isEmpty) return null;
          final emailRegex = RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$');
          if (!emailRegex.hasMatch(t)) {
            return l10n.validationInvalidEmail;
          }
          return null;
        },
      ),
    );

    final phoneField = LabeledFormField(
      label: l10n.formPhone,
      child: PhoneInputField(
        key: _phoneFieldKey,
        defaultPrefix: business.defaultPhonePrefix,
        initialPhone: widget.initial?.phone,
        isDense: true,
        useOutlineBorder: true,
        onChanged: (_) => widget.onChanged?.call(),
        validator: (v) {
          final t = v?.trim().replaceAll(RegExp(r'\s+'), '') ?? '';
          if (t.isEmpty) return null;
          if (!RegExp(r'^\d{6,15}$').hasMatch(t)) {
            return l10n.validationInvalidPhone;
          }
          return null;
        },
      ),
    );

    final notesField = LabeledFormField(
      label: l10n.formNotes,
      child: TextFormField(
        controller: _notes,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        maxLines: 3,
        onChanged: (_) => widget.onChanged?.call(),
      ),
    );

    return Form(
      key: _formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        mainAxisSize: MainAxisSize.min,
        children: [
          if (isSingleColumn) ...[
            firstNameField,
            const SizedBox(height: AppSpacing.formRowSpacing),
            lastNameField,
            const SizedBox(height: AppSpacing.formRowSpacing),
            emailField,
            const SizedBox(height: AppSpacing.formRowSpacing),
            phoneField,
            const SizedBox(height: AppSpacing.formRowSpacing),
            notesField,
          ] else ...[
            // Riga 1: Nome + Cognome
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(child: firstNameField),
                const SizedBox(width: AppSpacing.formFieldSpacing),
                Expanded(child: lastNameField),
              ],
            ),
            const SizedBox(height: AppSpacing.formRowSpacing),

            // Riga 2: Email + Telefono
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(child: emailField),
                const SizedBox(width: AppSpacing.formFieldSpacing),
                Expanded(child: phoneField),
              ],
            ),
            const SizedBox(height: AppSpacing.formRowSpacing),

            // Riga 3: Note (sempre full width)
            notesField,
          ],
        ],
      ),
    );
  }
}
--- FILE: lib/features/clients/presentation/widgets/clients_search_field.dart ---
import 'package:flutter/material.dart';

class ClientsSearchField extends StatefulWidget {
  final String hintText;
  final String initialValue;
  final ValueChanged<String> onChanged;

  const ClientsSearchField({
    super.key,
    required this.hintText,
    this.initialValue = '',
    required this.onChanged,
  });

  @override
  State<ClientsSearchField> createState() => _ClientsSearchFieldState();
}

class _ClientsSearchFieldState extends State<ClientsSearchField> {
  late final TextEditingController _controller;

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController(text: widget.initialValue);
  }

  @override
  void didUpdateWidget(covariant ClientsSearchField oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Sincronizza il controller se il valore iniziale cambia dall'esterno
    if (widget.initialValue != oldWidget.initialValue &&
        widget.initialValue != _controller.text) {
      _controller.text = widget.initialValue;
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return TextField(
      controller: _controller,
      decoration: InputDecoration(
        prefixIcon: const Icon(Icons.search),
        hintText: widget.hintText,
        border: const OutlineInputBorder(),
        suffixIcon: _controller.text.isNotEmpty
            ? IconButton(
                icon: const Icon(Icons.clear),
                onPressed: () {
                  _controller.clear();
                  widget.onChanged('');
                  setState(() {});
                },
              )
            : null,
      ),
      onChanged: (value) {
        widget.onChanged(value);
        setState(() {});
      },
    );
  }
}
--- FILE: lib/features/clients/presentation/widgets/client_list.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../providers/clients_providers.dart';
import '../dialogs/client_edit_dialog.dart';
import 'client_card.dart';

class ClientList extends ConsumerWidget {
  const ClientList({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final clients = ref.watch(filteredClientsProvider);

    if (clients.isEmpty) {
      return Center(child: Text(context.l10n.clientsEmpty));
    }

    final isWide = MediaQuery.of(context).size.width >= 900;
    if (isWide) {
      // Griglia responsive
      return LayoutBuilder(
        builder: (context, constraints) {
          final width = constraints.maxWidth;
          final crossAxisCount = (width / 280).floor().clamp(2, 6);
          return GridView.builder(
            padding: const EdgeInsets.all(12),
            gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: crossAxisCount,
              mainAxisSpacing: 12,
              crossAxisSpacing: 12,
              childAspectRatio: 1.6,
            ),
            itemCount: clients.length,
            itemBuilder: (_, i) {
              final c = clients[i];
              return ClientCard(
                client: c,
                onTap: () => showClientEditDialog(context, ref, client: c),
              );
            },
          );
        },
      );
    }

    // Lista verticale
    return ListView.separated(
      padding: const EdgeInsets.all(12),
      itemBuilder: (_, i) {
        final c = clients[i];
        return ClientCard(
          client: c,
          onTap: () => showClientEditDialog(context, ref, client: c),
        );
      },
      separatorBuilder: (_, __) => const SizedBox(height: 8),
      itemCount: clients.length,
    );
  }
}
--- FILE: lib/features/clients/presentation/widgets/client_card.dart ---
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:url_launcher/url_launcher.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../domain/clients.dart';
import '../../providers/clients_providers.dart';
import '../dialogs/client_appointments_dialog.dart';

class ClientCard extends ConsumerWidget {
  const ClientCard({super.key, required this.client, this.onTap});

  final Client client;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final scheme = theme.colorScheme;
    //final tags = client.tags ?? const [];
    final email = client.email;
    final phone = client.phone;
    final isEmailValid = email != null && _isValidEmail(email);
    final isPhoneValid = phone != null && _isValidPhone(phone);
    final emailTap = isEmailValid ? () => _openEmail(email) : null;
    final phoneTap = isPhoneValid ? () => _openPhone(phone) : null;
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: theme.cardColor,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: theme.dividerColor.withOpacity(0.4)),
        ),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Colonna sinistra: contenuto principale
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Row(
                    children: [
                      StaffCircleAvatar(
                        height: 36,
                        color: scheme.primary,
                        isHighlighted: false,
                        initials: client.name.isNotEmpty
                            ? initialsFromName(client.name, maxChars: 2)
                            : '?',
                      ),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Text(
                          client.name,
                          style: theme.textTheme.titleMedium,
                        ),
                      ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  if (email != null)
                    _LinkText(
                      text: email,
                      onTap: emailTap,
                      style: theme.textTheme.bodySmall,
                      linkColor: scheme.primary,
                    ),
                  if (client.email != null && client.phone != null)
                    const SizedBox(height: 12),
                  if (phone != null)
                    _LinkText(
                      text: phone,
                      onTap: phoneTap,
                      style: theme.textTheme.bodySmall,
                      linkColor: scheme.primary,
                    ),
                  if (client.lastVisit != null)
                    Padding(
                      padding: const EdgeInsets.only(top: 12),
                      child: Text(
                        _buildLastVisitLabel(context, client.lastVisit!),
                        style: theme.textTheme.labelSmall,
                      ),
                    ),
                ],
              ),
            ),
            // Colonna destra: icone allineate verticalmente
            Column(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                _DeleteButton(client: client),
                const SizedBox(height: 8),
                _AppointmentsButton(client: client),
              ],
            ),
          ],
        ),
      ),
    );
  }

  String _buildLastVisitLabel(BuildContext context, DateTime date) {
    final locale = Localizations.localeOf(context).toLanguageTag();
    // Esempio coerente con altre parti dell'app (e.g. staff widgets): d MMM y
    final formatted = DateFormat('d MMM y', locale).format(date);
    return context.l10n.lastVisitLabel(formatted);
  }
}

class _LinkText extends StatelessWidget {
  const _LinkText({
    required this.text,
    required this.onTap,
    required this.style,
    required this.linkColor,
  });

  final String text;
  final VoidCallback? onTap;
  final TextStyle? style;
  final Color linkColor;

  @override
  Widget build(BuildContext context) {
    final effectiveStyle = onTap == null
        ? style
        : style?.copyWith(
                color: linkColor,
                decoration: TextDecoration.underline,
                decorationColor: linkColor,
              ) ??
              TextStyle(
                color: linkColor,
                decoration: TextDecoration.underline,
                decorationColor: linkColor,
              );
    return InkWell(
      onTap: onTap,
      child: Text(text, style: effectiveStyle),
    );
  }
}

bool _isValidEmail(String email) {
  final trimmed = email.trim();
  if (trimmed.isEmpty) return false;
  final emailRegex = RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$');
  return emailRegex.hasMatch(trimmed);
}

bool _isValidPhone(String phone) {
  final trimmed = phone.trim();
  if (trimmed.isEmpty) return false;
  final normalized = trimmed.replaceAll(RegExp(r'\s+'), '');
  final phoneRegex = RegExp(r'^\+?\d{6,15}$');
  return phoneRegex.hasMatch(normalized);
}

Future<void> _openEmail(String email) async {
  final uri = Uri(scheme: 'mailto', path: email.trim());
  await launchUrl(uri, mode: LaunchMode.externalApplication);
}

Future<void> _openPhone(String phone) async {
  final normalized = phone.trim().replaceAll(RegExp(r'\s+'), '');
  final uri = Uri(scheme: 'tel', path: normalized);
  await launchUrl(uri, mode: LaunchMode.externalApplication);
}

class _AppointmentsButton extends ConsumerWidget {
  const _AppointmentsButton({required this.client});

  final Client client;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final appointments = ref.watch(clientWithAppointmentsProvider(client.id));
    final now = DateTime.now();

    final upcoming = appointments.where((a) => a.startTime.isAfter(now)).length;
    final past = appointments.length - upcoming;
    final total = appointments.length;

    return InkWell(
      onTap: () => showClientAppointmentsDialog(context, ref, client: client),
      borderRadius: BorderRadius.circular(8),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.calendar_month_outlined,
              size: 18,
              color: theme.colorScheme.primary.withOpacity(0.7),
            ),
            if (total > 0) ...[
              const SizedBox(width: 6),
              // Badge appuntamenti futuri (verde)
              if (upcoming > 0)
                _AppointmentBadge(
                  count: upcoming,
                  color: Colors.green,
                  icon: Icons.arrow_upward,
                ),
              if (upcoming > 0 && past > 0) const SizedBox(width: 4),
              // Badge appuntamenti passati (grigio)
              if (past > 0)
                _AppointmentBadge(
                  count: past,
                  color: theme.colorScheme.onSurfaceVariant,
                  icon: Icons.arrow_downward,
                ),
            ],
          ],
        ),
      ),
    );
  }
}

class _AppointmentBadge extends StatelessWidget {
  const _AppointmentBadge({
    required this.count,
    required this.color,
    required this.icon,
  });

  final int count;
  final Color color;
  final IconData icon;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 1),
      decoration: BoxDecoration(
        color: color.withOpacity(0.15),
        borderRadius: BorderRadius.circular(4),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 10, color: color),
          const SizedBox(width: 2),
          Text(
            count.toString(),
            style: TextStyle(
              fontSize: 10,
              fontWeight: FontWeight.w600,
              color: color,
            ),
          ),
        ],
      ),
    );
  }
}

class _DeleteButton extends ConsumerWidget {
  const _DeleteButton({required this.client});

  final Client client;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);

    return SizedBox(
      width: 32,
      height: 32,
      child: IconButton(
        padding: EdgeInsets.zero,
        iconSize: 18,
        icon: Icon(
          Icons.delete_outline,
          color: theme.colorScheme.error.withOpacity(0.7),
        ),
        onPressed: () => _onDelete(context, ref),
      ),
    );
  }

  Future<void> _onDelete(BuildContext context, WidgetRef ref) async {
    final confirm = await showConfirmDialog(
      context,
      title: Text(context.l10n.deleteClientConfirmTitle),
      content: Text(context.l10n.deleteClientConfirmMessage),
      confirmLabel: context.l10n.actionDelete,
      danger: true,
    );
    if (!confirm) return;

    ref.read(clientsProvider.notifier).deleteClient(client.id);
  }
}
--- FILE: lib/features/auth/providers/auth_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/user.dart';
import '../../../core/network/api_client.dart';
import '../../../core/network/network_providers.dart';
import '../../../core/services/preferences_service.dart';
import '../data/auth_repository.dart';
import '../domain/auth_state.dart';

/// Provider per il repository di autenticazione.
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  final apiClient = ref.watch(apiClientProvider);
  return AuthRepository(apiClient);
});

/// Provider per lo stato di autenticazione.
/// Gestisce il ciclo di vita dell'autenticazione nel gestionale.
final authProvider = NotifierProvider<AuthNotifier, AuthState>(
  AuthNotifier.new,
);

/// Notifier per la gestione dell'autenticazione.
class AuthNotifier extends Notifier<AuthState> {
  static bool _sessionRestored = false;
  static AuthState? _lastState;

  @override
  AuthState build() {
    // Se abbiamo gi√† uno stato salvato (es. errore), mantienilo
    if (_lastState != null && _lastState!.status == AuthStatus.error) {
      final savedState = _lastState!;
      _lastState = null; // Consuma lo stato salvato
      return savedState;
    }

    // Tenta ripristino sessione solo al primo avvio dell'app
    if (!_sessionRestored) {
      _sessionRestored = true;
      _tryRestoreSession();
    }
    return AuthState.initial();
  }

  /// Reset per testing o logout completo
  static void resetSessionFlag() {
    _sessionRestored = false;
    _lastState = null;
  }

  AuthRepository get _repository => ref.read(authRepositoryProvider);

  /// Tenta di ripristinare la sessione da refresh token salvato.
  Future<void> _tryRestoreSession() async {
    state = AuthState.loading();
    try {
      final user = await _repository.tryRestoreSession();
      if (user != null) {
        state = AuthState.authenticated(user);
      } else {
        state = AuthState.unauthenticated();
      }
    } catch (e) {
      state = AuthState.unauthenticated();
    }
  }

  /// Login con email e password.
  /// Ritorna true se il login ha successo, false altrimenti.
  Future<bool> login({required String email, required String password}) async {
    state = AuthState.loading();
    try {
      final user = await _repository.login(email: email, password: password);
      state = AuthState.authenticated(user);
      return true;
    } on ApiException catch (e) {
      state = AuthState.error(e.message);
      return false;
    } catch (e) {
      state = AuthState.error(e.toString());
      return false;
    }
  }

  /// Logout dell'utente corrente.
  /// Se silent=true, non fa chiamata API (per sessione gi√† scaduta)
  /// Se clearPreferences=true, pulisce tutte le preferenze salvate
  Future<void> logout({
    bool silent = false,
    bool clearPreferences = false,
  }) async {
    if (!silent) {
      try {
        await _repository.logout();
      } catch (_) {
        // Ignora errori durante logout (es. token gi√† invalido)
      }
    }

    // Pulisce le preferenze se richiesto
    if (clearPreferences) {
      try {
        await ref.read(preferencesServiceProvider).clearAll();
      } catch (_) {
        // Ignora errori durante pulizia preferenze
      }
    }

    state = AuthState.unauthenticated();
  }

  /// Pulisce l'errore corrente.
  void clearError() {
    state = state.copyWith(clearError: true);
  }

  /// Verifica se l'utente √® autenticato.
  bool get isAuthenticated => state.isAuthenticated;

  /// Ritorna l'utente corrente (se autenticato).
  User? get currentUser => state.user as User?;

  /// Aggiorna il profilo dell'utente corrente.
  Future<void> updateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
  }) async {
    final updatedUser = await _repository.updateProfile(
      firstName: firstName,
      lastName: lastName,
      email: email,
      phone: phone,
    );
    state = AuthState.authenticated(updatedUser);
  }

  /// Verifica se un token di reset √® valido.
  /// Lancia eccezione se il token √® invalido o scaduto.
  Future<void> verifyResetToken(String token) async {
    await _repository.verifyResetToken(token);
  }

  /// Richiede il reset della password (invia email con link).
  /// Ritorna sempre true per non rivelare se l'email esiste.
  Future<bool> forgotPassword({required String email}) async {
    try {
      await _repository.forgotPassword(email: email);
      return true;
    } catch (e) {
      // Anche in caso di errore, ritorna true per sicurezza
      return true;
    }
  }

  /// Reset password con token (da email di invito/reset).
  Future<void> resetPasswordWithToken({
    required String token,
    required String newPassword,
  }) async {
    await _repository.resetPasswordWithToken(
      token: token,
      newPassword: newPassword,
    );
  }

  /// Cambia password utente autenticato.
  /// Ritorna true se successo, false se errore.
  Future<bool> changePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    try {
      await _repository.changePassword(
        currentPassword: currentPassword,
        newPassword: newPassword,
      );
      return true;
    } catch (e) {
      return false;
    }
  }
}
--- FILE: lib/features/auth/data/auth_repository.dart ---
import '../../../core/models/user.dart';
import '../../../core/network/api_client.dart';

/// Repository per l'autenticazione nel gestionale.
/// Gestisce login, logout e recupero profilo utente.
class AuthRepository {
  final ApiClient _apiClient;

  AuthRepository(this._apiClient);

  /// Login utente con email e password.
  /// Ritorna l'utente autenticato.
  Future<User> login({required String email, required String password}) async {
    final data = await _apiClient.login(email, password);
    return User.fromJson(data['user'] as Map<String, dynamic>);
  }

  /// Logout utente corrente.
  /// Invalida la sessione e pulisce i token.
  Future<void> logout() async {
    await _apiClient.logout();
  }

  /// Recupera il profilo dell'utente corrente.
  Future<User> getCurrentUser() async {
    final data = await _apiClient.getMe();
    return User.fromJson(data);
  }

  /// Tenta di ripristinare la sessione da refresh token.
  /// Ritorna l'utente se la sessione √® valida, null altrimenti.
  Future<User?> tryRestoreSession() async {
    final data = await _apiClient.tryRestoreSession();
    if (data != null) {
      return User.fromJson(data);
    }
    return null;
  }

  /// Aggiorna il profilo dell'utente corrente.
  Future<User> updateProfile({
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
  }) async {
    final data = await _apiClient.updateProfile(
      firstName: firstName,
      lastName: lastName,
      email: email,
      phone: phone,
    );
    return User.fromJson(data);
  }

  /// Verifica se un token di reset √® valido.
  /// Lancia eccezione se il token √® invalido o scaduto.
  Future<void> verifyResetToken(String token) async {
    await _apiClient.verifyResetToken(token);
  }

  /// Richiede il reset della password (invia email con link).
  /// L'API ritorna sempre successo per non rivelare se l'email esiste.
  Future<void> forgotPassword({required String email}) async {
    await _apiClient.forgotPassword(email);
  }

  /// Reset password con token (da email di invito/reset).
  Future<void> resetPasswordWithToken({
    required String token,
    required String newPassword,
  }) async {
    await _apiClient.resetPassword(token: token, password: newPassword);
  }

  /// Cambia password utente autenticato.
  Future<void> changePassword({
    required String currentPassword,
    required String newPassword,
  }) async {
    await _apiClient.changePassword(
      currentPassword: currentPassword,
      newPassword: newPassword,
    );
  }
}
--- FILE: lib/features/auth/domain/auth_state.dart ---
/// Stati possibili dell'autenticazione.
enum AuthStatus {
  /// Stato iniziale, verifica sessione in corso.
  initial,

  /// Operazione di login/logout in corso.
  loading,

  /// Utente autenticato.
  authenticated,

  /// Utente non autenticato.
  unauthenticated,

  /// Errore durante autenticazione.
  error,
}

/// Stato dell'autenticazione nel gestionale.
class AuthState {
  final AuthStatus status;
  final dynamic user;
  final String? errorMessage;

  const AuthState({
    this.status = AuthStatus.initial,
    this.user,
    this.errorMessage,
  });

  /// Verifica se l'utente √® autenticato.
  bool get isAuthenticated =>
      status == AuthStatus.authenticated && user != null;

  /// Verifica se √® in corso un'operazione.
  bool get isLoading => status == AuthStatus.loading;

  /// Verifica se √® nello stato iniziale.
  bool get isInitial => status == AuthStatus.initial;

  AuthState copyWith({
    AuthStatus? status,
    dynamic user,
    String? errorMessage,
    bool clearUser = false,
    bool clearError = false,
  }) => AuthState(
    status: status ?? this.status,
    user: clearUser ? null : (user ?? this.user),
    errorMessage: clearError ? null : (errorMessage ?? this.errorMessage),
  );

  factory AuthState.initial() => const AuthState(status: AuthStatus.initial);

  factory AuthState.loading() => const AuthState(status: AuthStatus.loading);

  factory AuthState.authenticated(dynamic user) =>
      AuthState(status: AuthStatus.authenticated, user: user);

  factory AuthState.unauthenticated() =>
      const AuthState(status: AuthStatus.unauthenticated);

  factory AuthState.error(String message) =>
      AuthState(status: AuthStatus.error, errorMessage: message);
}
--- FILE: lib/features/auth/presentation/profile_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/l10n/l10_extension.dart';
import '../../../core/network/api_client.dart';
import '../providers/auth_provider.dart';

/// Schermata profilo utente.
/// Permette di visualizzare e modificare i propri dati (nome, cognome, email, telefono).
class ProfileScreen extends ConsumerStatefulWidget {
  const ProfileScreen({super.key});

  @override
  ConsumerState<ProfileScreen> createState() => _ProfileScreenState();
}

class _ProfileScreenState extends ConsumerState<ProfileScreen> {
  final _formKey = GlobalKey<FormState>();
  late final TextEditingController _firstNameController;
  late final TextEditingController _lastNameController;
  late final TextEditingController _emailController;
  late final TextEditingController _phoneController;

  bool _isLoading = false;
  bool _isEditing = false;
  String? _error;
  String? _success;

  @override
  void initState() {
    super.initState();
    final user = ref.read(authProvider).user;
    _firstNameController = TextEditingController(text: user?.firstName ?? '');
    _lastNameController = TextEditingController(text: user?.lastName ?? '');
    _emailController = TextEditingController(text: user?.email ?? '');
    _phoneController = TextEditingController(text: user?.phone ?? '');
  }

  @override
  void dispose() {
    _firstNameController.dispose();
    _lastNameController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    super.dispose();
  }

  Future<void> _saveChanges() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _error = null;
      _success = null;
    });

    try {
      await ref
          .read(authProvider.notifier)
          .updateProfile(
            firstName: _firstNameController.text.trim(),
            lastName: _lastNameController.text.trim(),
            email: _emailController.text.trim(),
            phone: _phoneController.text.trim().isEmpty
                ? null
                : _phoneController.text.trim(),
          );

      if (mounted) {
        setState(() {
          _isEditing = false;
          _success = 'Profilo aggiornato con successo';
          _isLoading = false;
        });
      }
    } on ApiException catch (e) {
      setState(() {
        _error = e.message;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  void _cancelEditing() {
    final user = ref.read(authProvider).user;
    setState(() {
      _firstNameController.text = user?.firstName ?? '';
      _lastNameController.text = user?.lastName ?? '';
      _emailController.text = user?.email ?? '';
      _phoneController.text = user?.phone ?? '';
      _isEditing = false;
      _error = null;
    });
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final authState = ref.watch(authProvider);
    final user = authState.user;

    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.profileTitle),
        actions: [
          if (!_isEditing)
            IconButton(
              icon: const Icon(Icons.edit),
              tooltip: 'Modifica',
              onPressed: () => setState(() => _isEditing = true),
            ),
        ],
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(24),
        child: Center(
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 500),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // Avatar
                Center(
                  child: CircleAvatar(
                    radius: 50,
                    backgroundColor: colorScheme.primaryContainer,
                    child: Text(
                      _getInitials(user?.firstName, user?.lastName),
                      style: TextStyle(
                        fontSize: 32,
                        fontWeight: FontWeight.bold,
                        color: colorScheme.onPrimaryContainer,
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: 24),

                // Messaggi
                if (_success != null) ...[
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: colorScheme.primaryContainer,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Row(
                      children: [
                        Icon(
                          Icons.check_circle,
                          color: colorScheme.onPrimaryContainer,
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            _success!,
                            style: TextStyle(
                              color: colorScheme.onPrimaryContainer,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 16),
                ],

                if (_error != null) ...[
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: colorScheme.errorContainer,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Row(
                      children: [
                        Icon(
                          Icons.error_outline,
                          color: colorScheme.onErrorContainer,
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            _error!,
                            style: TextStyle(
                              color: colorScheme.onErrorContainer,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 16),
                ],

                // Form
                Form(
                  key: _formKey,
                  child: Column(
                    children: [
                      // Nome
                      TextFormField(
                        controller: _firstNameController,
                        enabled: _isEditing,
                        decoration: InputDecoration(
                          labelText: l10n.authFirstName,
                          prefixIcon: const Icon(Icons.person_outline),
                        ),
                        textCapitalization: TextCapitalization.words,
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return l10n.authRequiredField;
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),

                      // Cognome
                      TextFormField(
                        controller: _lastNameController,
                        enabled: _isEditing,
                        decoration: InputDecoration(
                          labelText: l10n.authLastName,
                          prefixIcon: const Icon(Icons.person_outline),
                        ),
                        textCapitalization: TextCapitalization.words,
                      ),
                      const SizedBox(height: 16),

                      // Email
                      TextFormField(
                        controller: _emailController,
                        enabled: _isEditing,
                        decoration: InputDecoration(
                          labelText: l10n.authEmail,
                          prefixIcon: const Icon(Icons.email_outlined),
                          helperText: _isEditing
                              ? 'Attenzione: cambiando email dovrai usarla per il login'
                              : null,
                        ),
                        keyboardType: TextInputType.emailAddress,
                        validator: (value) {
                          if (value == null || value.trim().isEmpty) {
                            return l10n.authRequiredField;
                          }
                          final emailRegex = RegExp(
                            r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                          );
                          if (!emailRegex.hasMatch(value.trim())) {
                            return l10n.authInvalidEmail;
                          }
                          return null;
                        },
                      ),
                      const SizedBox(height: 16),

                      // Telefono
                      TextFormField(
                        controller: _phoneController,
                        enabled: _isEditing,
                        decoration: InputDecoration(
                          labelText: l10n.authPhone,
                          prefixIcon: const Icon(Icons.phone_outlined),
                        ),
                        keyboardType: TextInputType.phone,
                      ),
                    ],
                  ),
                ),
                const SizedBox(height: 32),

                // Bottoni
                if (_isEditing) ...[
                  Row(
                    children: [
                      Expanded(
                        child: OutlinedButton(
                          onPressed: _isLoading ? null : _cancelEditing,
                          child: Text(l10n.actionCancel),
                        ),
                      ),
                      const SizedBox(width: 16),
                      Expanded(
                        child: FilledButton(
                          onPressed: _isLoading ? null : _saveChanges,
                          child: _isLoading
                              ? const SizedBox(
                                  width: 20,
                                  height: 20,
                                  child: CircularProgressIndicator(
                                    strokeWidth: 2,
                                  ),
                                )
                              : Text(l10n.actionSave),
                        ),
                      ),
                    ],
                  ),
                ],

                const SizedBox(height: 24),
                const Divider(),
                const SizedBox(height: 16),

                // Info account
                if (user?.isSuperadmin == true)
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: colorScheme.tertiaryContainer,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Row(
                      children: [
                        Icon(
                          Icons.admin_panel_settings,
                          color: colorScheme.onTertiaryContainer,
                        ),
                        const SizedBox(width: 8),
                        Text(
                          'Account Superadmin',
                          style: TextStyle(
                            color: colorScheme.onTertiaryContainer,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      ],
                    ),
                  ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  String _getInitials(String? firstName, String? lastName) {
    final first = firstName?.isNotEmpty == true ? firstName![0] : '';
    final last = lastName?.isNotEmpty == true ? lastName![0] : '';
    return '$first$last'.toUpperCase();
  }
}
--- FILE: lib/features/auth/presentation/change_password_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/l10_extension.dart';
import '../providers/auth_provider.dart';

/// Schermata per cambiare la password dell'utente autenticato.
class ChangePasswordScreen extends ConsumerStatefulWidget {
  const ChangePasswordScreen({super.key});

  @override
  ConsumerState<ChangePasswordScreen> createState() =>
      _ChangePasswordScreenState();
}

class _ChangePasswordScreenState extends ConsumerState<ChangePasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final _currentPasswordController = TextEditingController();
  final _newPasswordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  bool _obscureCurrentPassword = true;
  bool _obscureNewPassword = true;
  bool _obscureConfirmPassword = true;
  bool _isLoading = false;

  @override
  void dispose() {
    _currentPasswordController.dispose();
    _newPasswordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  Future<void> _handleChangePassword() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    final success = await ref.read(authProvider.notifier).changePassword(
          currentPassword: _currentPasswordController.text,
          newPassword: _newPasswordController.text,
        );

    setState(() => _isLoading = false);

    if (mounted) {
      if (success) {
        await showDialog<void>(
          context: context,
          builder: (ctx) => AlertDialog(
            title: const Text('Password modificata'),
            content: const Text(
              'La tua password √® stata modificata con successo.',
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(ctx).pop(),
                child: const Text('OK'),
              ),
            ],
          ),
        );
        if (mounted) {
          context.pop();
        }
      } else {
        await showDialog<void>(
          context: context,
          builder: (ctx) => AlertDialog(
            title: const Text('Errore'),
            content: const Text(
              'La password attuale non √® corretta.',
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(ctx).pop(),
                child: const Text('OK'),
              ),
            ],
          ),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.pop(),
        ),
        title: const Text('Cambia password'),
      ),
      body: SafeArea(
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24),
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 400),
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    // Icon
                    Icon(
                      Icons.lock_reset,
                      size: 64,
                      color: theme.colorScheme.primary,
                    ),
                    const SizedBox(height: 32),

                    // Current password
                    TextFormField(
                      controller: _currentPasswordController,
                      obscureText: _obscureCurrentPassword,
                      textInputAction: TextInputAction.next,
                      decoration: InputDecoration(
                        labelText: 'Password attuale',
                        prefixIcon: const Icon(Icons.lock_outlined),
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscureCurrentPassword
                                ? Icons.visibility_outlined
                                : Icons.visibility_off_outlined,
                          ),
                          onPressed: () {
                            setState(
                              () => _obscureCurrentPassword =
                                  !_obscureCurrentPassword,
                            );
                          },
                        ),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return l10n.authRequiredField;
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),

                    // New password
                    TextFormField(
                      controller: _newPasswordController,
                      obscureText: _obscureNewPassword,
                      textInputAction: TextInputAction.next,
                      decoration: InputDecoration(
                        labelText: 'Nuova password',
                        prefixIcon: const Icon(Icons.lock_outlined),
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscureNewPassword
                                ? Icons.visibility_outlined
                                : Icons.visibility_off_outlined,
                          ),
                          onPressed: () {
                            setState(
                              () =>
                                  _obscureNewPassword = !_obscureNewPassword,
                            );
                          },
                        ),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return l10n.authRequiredField;
                        }
                        if (value.length < 8) {
                          return 'La password deve avere almeno 8 caratteri';
                        }
                        if (!RegExp(r'[A-Z]').hasMatch(value) ||
                            !RegExp(r'[a-z]').hasMatch(value) ||
                            !RegExp(r'[0-9]').hasMatch(value)) {
                          return 'Deve contenere maiuscole, minuscole e numeri';
                        }
                        if (value == _currentPasswordController.text) {
                          return 'La nuova password deve essere diversa';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),

                    // Confirm password
                    TextFormField(
                      controller: _confirmPasswordController,
                      obscureText: _obscureConfirmPassword,
                      textInputAction: TextInputAction.done,
                      decoration: InputDecoration(
                        labelText: 'Conferma nuova password',
                        prefixIcon: const Icon(Icons.lock_outlined),
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscureConfirmPassword
                                ? Icons.visibility_outlined
                                : Icons.visibility_off_outlined,
                          ),
                          onPressed: () {
                            setState(
                              () => _obscureConfirmPassword =
                                  !_obscureConfirmPassword,
                            );
                          },
                        ),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return l10n.authRequiredField;
                        }
                        if (value != _newPasswordController.text) {
                          return 'Le password non corrispondono';
                        }
                        return null;
                      },
                      onFieldSubmitted: (_) => _handleChangePassword(),
                    ),
                    const SizedBox(height: 32),

                    // Submit button
                    FilledButton(
                      onPressed: _isLoading ? null : _handleChangePassword,
                      child: _isLoading
                          ? const SizedBox(
                              height: 20,
                              width: 20,
                              child: CircularProgressIndicator(strokeWidth: 2),
                            )
                          : Text(l10n.actionConfirm),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/auth/presentation/login_screen.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/l10_extension.dart';
import '../providers/auth_provider.dart';

/// Schermata di login per il gestionale.
/// Richiede autenticazione per accedere al sistema.
class LoginScreen extends ConsumerStatefulWidget {
  const LoginScreen({super.key});

  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends ConsumerState<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController(
    text: kDebugMode ? 'dariolarosa@hotmail.com' : null,
  );
  final _passwordController = TextEditingController(
    text: kDebugMode ? 'Abc123@@' : null,
  );
  bool _obscurePassword = true;
  bool _rememberMe = true;
  bool _isLoading = false;
  String? _errorMessage;

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _handleLogin() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final success = await ref
          .read(authProvider.notifier)
          .login(
            email: _emailController.text.trim(),
            password: _passwordController.text,
          );

      if (!mounted) return;

      if (success) {
        // Segnala al browser che l'autofill √® completato con successo
        // Questo triggera la richiesta di salvataggio credenziali
        TextInput.finishAutofillContext();
        context.go('/agenda');
      } else {
        setState(() {
          _errorMessage = context.l10n.authLoginFailed;
          _isLoading = false;
        });
      }
    } catch (e) {
      if (!mounted) return;
      setState(() {
        _errorMessage = context.l10n.authLoginFailed;
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    // Osserva solo per redirect se autenticato
    ref.listen(authProvider, (prev, next) {
      if (next.isAuthenticated && mounted) {
        context.go('/agenda');
      }
    });

    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Scaffold(
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 400),
            child: AutofillGroup(
              child: Form(
                key: _formKey,
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    // Logo e titolo
                    Icon(
                      Icons.calendar_month_rounded,
                      size: 72,
                      color: colorScheme.primary,
                    ),
                    const SizedBox(height: 16),
                    Text(
                      l10n.appTitle,
                      style: theme.textTheme.headlineMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                        color: colorScheme.primary,
                      ),
                      textAlign: TextAlign.center,
                    ),
                    const SizedBox(height: 8),
                    Text(
                      l10n.authLoginSubtitle,
                      style: theme.textTheme.bodyLarge?.copyWith(
                        color: colorScheme.onSurfaceVariant,
                      ),
                      textAlign: TextAlign.center,
                    ),
                    const SizedBox(height: 48),

                    // Email
                    TextFormField(
                      controller: _emailController,
                      keyboardType: TextInputType.emailAddress,
                      textInputAction: TextInputAction.next,
                      autofocus:
                          true, // Aiuta Safari mobile a riconoscere il form
                      autocorrect: false,
                      enableSuggestions: true,
                      autofillHints: const [
                        AutofillHints.username,
                        AutofillHints.email,
                      ],
                      decoration: InputDecoration(
                        labelText: l10n.authEmail,
                        prefixIcon: const Icon(Icons.email_outlined),
                        border: const OutlineInputBorder(),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return l10n.authRequiredField;
                        }
                        if (!value.contains('@')) {
                          return l10n.authInvalidEmail;
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),

                    // Password
                    TextFormField(
                      controller: _passwordController,
                      obscureText: _obscurePassword,
                      textInputAction: TextInputAction.done,
                      enableSuggestions: false,
                      autocorrect: false,
                      autofillHints: const [AutofillHints.password],
                      onFieldSubmitted: (_) => _handleLogin(),
                      decoration: InputDecoration(
                        labelText: l10n.authPassword,
                        prefixIcon: const Icon(Icons.lock_outlined),
                        border: const OutlineInputBorder(),
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscurePassword
                                ? Icons.visibility_outlined
                                : Icons.visibility_off_outlined,
                          ),
                          onPressed: () {
                            setState(
                              () => _obscurePassword = !_obscurePassword,
                            );
                          },
                        ),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return l10n.authRequiredField;
                        }
                        if (value.length < 6) {
                          return l10n.authPasswordTooShort;
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 8),

                    // Remember me e forgot password
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Checkbox(
                              value: _rememberMe,
                              onChanged: (value) {
                                setState(() => _rememberMe = value ?? true);
                              },
                            ),
                            Text(
                              l10n.authRememberMe,
                              style: theme.textTheme.bodyMedium,
                            ),
                          ],
                        ),
                        TextButton(
                          onPressed: () => _showForgotPasswordInfo(context),
                          child: Text(l10n.authForgotPassword),
                        ),
                      ],
                    ),
                    const SizedBox(height: 24),

                    // Errore
                    if (_errorMessage != null) ...[
                      Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: colorScheme.error.withOpacity(0.1),
                          borderRadius: BorderRadius.circular(8),
                          border: Border.all(
                            color: colorScheme.error.withOpacity(0.3),
                          ),
                        ),
                        child: Row(
                          children: [
                            Icon(
                              Icons.error_outline,
                              color: colorScheme.error,
                              size: 20,
                            ),
                            const SizedBox(width: 12),
                            Expanded(
                              child: Text(
                                _errorMessage!,
                                style: TextStyle(color: colorScheme.error),
                              ),
                            ),
                          ],
                        ),
                      ),
                      const SizedBox(height: 16),
                    ],

                    // Bottone Login
                    FilledButton(
                      onPressed: _isLoading ? null : _handleLogin,
                      style: FilledButton.styleFrom(
                        padding: const EdgeInsets.symmetric(vertical: 16),
                      ),
                      child: _isLoading
                          ? const SizedBox(
                              height: 20,
                              width: 20,
                              child: CircularProgressIndicator(
                                strokeWidth: 2,
                                color: Colors.white,
                              ),
                            )
                          : Text(l10n.authLogin),
                    ),
                    const SizedBox(height: 32),

                    // Footer
                    Text(
                      l10n.authLoginFooter,
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: colorScheme.onSurfaceVariant,
                      ),
                      textAlign: TextAlign.center,
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  void _showForgotPasswordInfo(BuildContext context) {
    final l10n = context.l10n;
    final emailController = TextEditingController();

    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: Text(l10n.authResetPasswordTitle),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(l10n.authResetPasswordMessage),
            const SizedBox(height: 16),
            TextField(
              controller: emailController,
              keyboardType: TextInputType.emailAddress,
              autofocus: true,
              decoration: InputDecoration(
                labelText: l10n.authEmail,
                prefixIcon: const Icon(Icons.email_outlined),
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(dialogContext).pop(),
            child: Text(l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () async {
              final email = emailController.text.trim();
              if (email.isEmpty) return;

              // Salva riferimento al ScaffoldMessenger prima dell'async gap
              final scaffoldMessenger = ScaffoldMessenger.of(context);

              // Chiudi il dialog prima di fare la chiamata
              Navigator.of(dialogContext).pop();

              // Mostra indicatore di caricamento
              if (mounted) {
                scaffoldMessenger.showSnackBar(
                  const SnackBar(
                    content: Row(
                      children: [
                        SizedBox(
                          width: 20,
                          height: 20,
                          child: CircularProgressIndicator(strokeWidth: 2),
                        ),
                        SizedBox(width: 16),
                        Text('Invio email in corso...'),
                      ],
                    ),
                    duration: Duration(seconds: 2),
                  ),
                );
              }

              final success = await ref
                  .read(authProvider.notifier)
                  .forgotPassword(email: email);

              if (mounted) {
                // Nascondi snackbar precedente
                scaffoldMessenger.hideCurrentSnackBar();

                scaffoldMessenger.showSnackBar(
                  SnackBar(
                    content: Text(
                      success
                          ? l10n.authResetPasswordSuccess
                          : l10n.authResetPasswordError,
                    ),
                    backgroundColor: success ? Colors.green : Colors.red,
                  ),
                );
              }
            },
            child: Text(l10n.authResetPasswordSend),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/auth/presentation/reset_password_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/l10_extension.dart';
import '../providers/auth_provider.dart';

/// Schermata per impostare nuova password da link email.
/// Usata per inviti admin e reset password dimenticata.
class ResetPasswordScreen extends ConsumerStatefulWidget {
  final String token;

  const ResetPasswordScreen({required this.token, super.key});

  @override
  ConsumerState<ResetPasswordScreen> createState() =>
      _ResetPasswordScreenState();
}

class _ResetPasswordScreenState extends ConsumerState<ResetPasswordScreen> {
  final _formKey = GlobalKey<FormState>();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  bool _obscurePassword = true;
  bool _obscureConfirmPassword = true;
  bool _isLoading = false;

  // Stato per la verifica iniziale del token
  bool _isVerifyingToken = true;
  bool _tokenValid = false;

  @override
  void initState() {
    super.initState();
    _verifyToken();
  }

  Future<void> _verifyToken() async {
    try {
      await ref.read(authProvider.notifier).verifyResetToken(widget.token);
      if (mounted) {
        setState(() {
          _isVerifyingToken = false;
          _tokenValid = true;
        });
      }
    } catch (e) {
      if (mounted) {
        setState(() {
          _isVerifyingToken = false;
          _tokenValid = false;
        });
        // Mostra dialog bloccante e poi redirect
        await showDialog<void>(
          context: context,
          barrierDismissible: false,
          builder: (ctx) => AlertDialog(
            title: const Text('Link non valido'),
            content: const Text(
              'Il link √® scaduto o √® gi√† stato utilizzato.\n\n'
              'Richiedi un nuovo invito al superadmin.',
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(ctx).pop(),
                child: const Text('Vai al login'),
              ),
            ],
          ),
        );
        if (mounted) {
          context.go('/login');
        }
      }
    }
  }

  @override
  void dispose() {
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  Future<void> _handleResetPassword() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    try {
      await ref
          .read(authProvider.notifier)
          .resetPasswordWithToken(
            token: widget.token,
            newPassword: _passwordController.text,
          );

      if (mounted) {
        await showDialog<void>(
          context: context,
          barrierDismissible: false,
          builder: (ctx) => AlertDialog(
            title: const Text('Password impostata'),
            content: const Text(
              'La tua password √® stata impostata con successo.\nOra puoi effettuare il login.',
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(ctx).pop(),
                child: const Text('OK'),
              ),
            ],
          ),
        );
        if (mounted) {
          context.go('/login');
        }
      }
    } catch (e) {
      if (mounted) {
        await showDialog<void>(
          context: context,
          builder: (ctx) => AlertDialog(
            title: const Text('Errore'),
            content: const Text(
              'Il link √® scaduto o non valido.\nRichiedi un nuovo invito al superadmin.',
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(ctx).pop(),
                child: const Text('OK'),
              ),
            ],
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() => _isLoading = false);
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    // Mostra loading mentre verifica il token
    if (_isVerifyingToken) {
      return Scaffold(
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const CircularProgressIndicator(),
              const SizedBox(height: 16),
              Text(
                'Verifica link in corso...',
                style: theme.textTheme.bodyLarge,
              ),
            ],
          ),
        ),
      );
    }

    // Se il token non √® valido, mostra schermata vuota (il dialog far√† redirect)
    if (!_tokenValid) {
      return const Scaffold(body: SizedBox.shrink());
    }

    // Token valido: mostra il form
    return Scaffold(
      body: SafeArea(
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24),
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 400),
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    // Icon
                    Icon(
                      Icons.lock_reset,
                      size: 64,
                      color: theme.colorScheme.primary,
                    ),
                    const SizedBox(height: 16),

                    // Title
                    Text(
                      'Imposta la tua password',
                      style: theme.textTheme.headlineSmall,
                      textAlign: TextAlign.center,
                    ),
                    const SizedBox(height: 8),

                    // Message
                    Text(
                      'Scegli una password sicura per accedere al tuo gestionale.',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                      textAlign: TextAlign.center,
                    ),
                    const SizedBox(height: 32),

                    // New password
                    TextFormField(
                      controller: _passwordController,
                      obscureText: _obscurePassword,
                      textInputAction: TextInputAction.next,
                      decoration: InputDecoration(
                        labelText: 'Nuova password',
                        prefixIcon: const Icon(Icons.lock_outlined),
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscurePassword
                                ? Icons.visibility_outlined
                                : Icons.visibility_off_outlined,
                          ),
                          onPressed: () {
                            setState(
                              () => _obscurePassword = !_obscurePassword,
                            );
                          },
                        ),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return l10n.authRequiredField;
                        }
                        if (value.length < 8) {
                          return 'La password deve avere almeno 8 caratteri';
                        }
                        if (!RegExp(r'[A-Z]').hasMatch(value) ||
                            !RegExp(r'[a-z]').hasMatch(value) ||
                            !RegExp(r'[0-9]').hasMatch(value)) {
                          return 'Deve contenere maiuscole, minuscole e numeri';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),

                    // Confirm password
                    TextFormField(
                      controller: _confirmPasswordController,
                      obscureText: _obscureConfirmPassword,
                      textInputAction: TextInputAction.done,
                      decoration: InputDecoration(
                        labelText: 'Conferma password',
                        prefixIcon: const Icon(Icons.lock_outlined),
                        suffixIcon: IconButton(
                          icon: Icon(
                            _obscureConfirmPassword
                                ? Icons.visibility_outlined
                                : Icons.visibility_off_outlined,
                          ),
                          onPressed: () {
                            setState(
                              () => _obscureConfirmPassword =
                                  !_obscureConfirmPassword,
                            );
                          },
                        ),
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return l10n.authRequiredField;
                        }
                        if (value != _passwordController.text) {
                          return 'Le password non corrispondono';
                        }
                        return null;
                      },
                      onFieldSubmitted: (_) => _handleResetPassword(),
                    ),
                    const SizedBox(height: 32),

                    // Submit button
                    FilledButton(
                      onPressed: _isLoading ? null : _handleResetPassword,
                      child: _isLoading
                          ? const SizedBox(
                              height: 20,
                              width: 20,
                              child: CircularProgressIndicator(strokeWidth: 2),
                            )
                          : const Text('Imposta password'),
                    ),

                    const SizedBox(height: 16),

                    // Back to login
                    TextButton(
                      onPressed: () => context.go('/login'),
                      child: const Text('Torna al login'),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/business/providers/business_users_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'business_users_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning
/// Provider per il repository degli operatori.

@ProviderFor(businessUsersRepository)
const businessUsersRepositoryProvider = BusinessUsersRepositoryProvider._();

/// Provider per il repository degli operatori.

final class BusinessUsersRepositoryProvider
    extends
        $FunctionalProvider<
          BusinessUsersRepository,
          BusinessUsersRepository,
          BusinessUsersRepository
        >
    with $Provider<BusinessUsersRepository> {
  /// Provider per il repository degli operatori.
  const BusinessUsersRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'businessUsersRepositoryProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$businessUsersRepositoryHash();

  @$internal
  @override
  $ProviderElement<BusinessUsersRepository> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  BusinessUsersRepository create(Ref ref) {
    return businessUsersRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(BusinessUsersRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<BusinessUsersRepository>(value),
    );
  }
}

String _$businessUsersRepositoryHash() =>
    r'9f3d9ab7572fd99339bb7c1cf46784915cd0faf8';

/// Notifier per gestire gli operatori di un business.

@ProviderFor(BusinessUsersNotifier)
const businessUsersProvider = BusinessUsersNotifierFamily._();

/// Notifier per gestire gli operatori di un business.
final class BusinessUsersNotifierProvider
    extends $NotifierProvider<BusinessUsersNotifier, BusinessUsersState> {
  /// Notifier per gestire gli operatori di un business.
  const BusinessUsersNotifierProvider._({
    required BusinessUsersNotifierFamily super.from,
    required int super.argument,
  }) : super(
         retry: null,
         name: r'businessUsersProvider',
         isAutoDispose: true,
         dependencies: null,
         $allTransitiveDependencies: null,
       );

  @override
  String debugGetCreateSourceHash() => _$businessUsersNotifierHash();

  @override
  String toString() {
    return r'businessUsersProvider'
        ''
        '($argument)';
  }

  @$internal
  @override
  BusinessUsersNotifier create() => BusinessUsersNotifier();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(BusinessUsersState value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<BusinessUsersState>(value),
    );
  }

  @override
  bool operator ==(Object other) {
    return other is BusinessUsersNotifierProvider && other.argument == argument;
  }

  @override
  int get hashCode {
    return argument.hashCode;
  }
}

String _$businessUsersNotifierHash() =>
    r'38239228d01aa3d90273d07122559b5b6ecab0be';

/// Notifier per gestire gli operatori di un business.

final class BusinessUsersNotifierFamily extends $Family
    with
        $ClassFamilyOverride<
          BusinessUsersNotifier,
          BusinessUsersState,
          BusinessUsersState,
          BusinessUsersState,
          int
        > {
  const BusinessUsersNotifierFamily._()
    : super(
        retry: null,
        name: r'businessUsersProvider',
        dependencies: null,
        $allTransitiveDependencies: null,
        isAutoDispose: true,
      );

  /// Notifier per gestire gli operatori di un business.

  BusinessUsersNotifierProvider call(int businessId) =>
      BusinessUsersNotifierProvider._(argument: businessId, from: this);

  @override
  String toString() => r'businessUsersProvider';
}

/// Notifier per gestire gli operatori di un business.

abstract class _$BusinessUsersNotifier extends $Notifier<BusinessUsersState> {
  late final _$args = ref.$arg as int;
  int get businessId => _$args;

  BusinessUsersState build(int businessId);
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build(_$args);
    final ref = this.ref as $Ref<BusinessUsersState, BusinessUsersState>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<BusinessUsersState, BusinessUsersState>,
              BusinessUsersState,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/features/business/providers/locations_providers.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../core/network/network_providers.dart';
import '../data/locations_repository.dart';

part 'locations_providers.g.dart';

@riverpod
LocationsRepository locationsRepository(Ref ref) {
  return LocationsRepository(apiClient: ref.watch(apiClientProvider));
}
--- FILE: lib/features/business/providers/business_providers.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../core/network/network_providers.dart';
import '../data/business_repository.dart';

part 'business_providers.g.dart';

@riverpod
BusinessRepository businessRepository(Ref ref) {
  return BusinessRepository(apiClient: ref.watch(apiClientProvider));
}
--- FILE: lib/features/business/providers/business_users_provider.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../core/models/business_invitation.dart';
import '../../../core/models/business_user.dart';
import '../../../core/network/network_providers.dart';
import '../data/business_users_repository.dart';

part 'business_users_provider.g.dart';

/// Provider per il repository degli operatori.
@riverpod
BusinessUsersRepository businessUsersRepository(Ref ref) {
  return BusinessUsersRepository(apiClient: ref.watch(apiClientProvider));
}

/// Stato per la gestione degli operatori di un business.
class BusinessUsersState {
  final List<BusinessUser> users;
  final List<BusinessInvitation> invitations;
  final bool isLoading;
  final String? error;

  const BusinessUsersState({
    this.users = const [],
    this.invitations = const [],
    this.isLoading = false,
    this.error,
  });

  BusinessUsersState copyWith({
    List<BusinessUser>? users,
    List<BusinessInvitation>? invitations,
    bool? isLoading,
    String? error,
  }) => BusinessUsersState(
    users: users ?? this.users,
    invitations: invitations ?? this.invitations,
    isLoading: isLoading ?? this.isLoading,
    error: error,
  );

  /// Utenti attivi (escluso l'utente corrente).
  List<BusinessUser> get activeUsers =>
      users.where((u) => u.status == 'active').toList();

  /// Numero totale di membri (utenti attivi + inviti pendenti).
  int get totalMembers => activeUsers.length + invitations.length;
}

/// Notifier per gestire gli operatori di un business.
@riverpod
class BusinessUsersNotifier extends _$BusinessUsersNotifier {
  @override
  BusinessUsersState build(int businessId) {
    _loadData();
    return const BusinessUsersState(isLoading: true);
  }

  BusinessUsersRepository get _repository =>
      ref.read(businessUsersRepositoryProvider);

  /// Carica operatori e inviti.
  Future<void> _loadData() async {
    state = state.copyWith(isLoading: true, error: null);
    try {
      final results = await Future.wait([
        _repository.getUsers(businessId),
        _repository.getInvitations(businessId),
      ]);
      state = state.copyWith(
        users: results[0] as List<BusinessUser>,
        invitations: results[1] as List<BusinessInvitation>,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
    }
  }

  /// Ricarica i dati.
  Future<void> refresh() => _loadData();

  /// Aggiorna il ruolo di un operatore.
  Future<bool> updateUserRole(int userId, String newRole) async {
    try {
      final updated = await _repository.updateUserRole(
        businessId: businessId,
        userId: userId,
        role: newRole,
      );
      state = state.copyWith(
        users: state.users
            .map((u) => u.userId == userId ? updated : u)
            .toList(),
      );
      return true;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return false;
    }
  }

  /// Rimuove un operatore.
  Future<bool> removeUser(int userId) async {
    try {
      await _repository.removeUser(businessId: businessId, userId: userId);
      state = state.copyWith(
        users: state.users.where((u) => u.userId != userId).toList(),
      );
      return true;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return false;
    }
  }

  /// Crea un nuovo invito.
  Future<BusinessInvitation?> createInvitation({
    required String email,
    required String role,
  }) async {
    try {
      final invitation = await _repository.createInvitation(
        businessId: businessId,
        email: email,
        role: role,
      );
      state = state.copyWith(invitations: [...state.invitations, invitation]);
      return invitation;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return null;
    }
  }

  /// Revoca un invito.
  Future<bool> revokeInvitation(int invitationId) async {
    try {
      await _repository.revokeInvitation(
        businessId: businessId,
        invitationId: invitationId,
      );
      state = state.copyWith(
        invitations: state.invitations
            .where((i) => i.id != invitationId)
            .toList(),
      );
      return true;
    } catch (e) {
      state = state.copyWith(error: e.toString());
      return false;
    }
  }

  /// Pulisce l'errore.
  void clearError() {
    state = state.copyWith(error: null);
  }
}
--- FILE: lib/features/business/providers/business_providers.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'business_providers.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(businessRepository)
const businessRepositoryProvider = BusinessRepositoryProvider._();

final class BusinessRepositoryProvider
    extends
        $FunctionalProvider<
          BusinessRepository,
          BusinessRepository,
          BusinessRepository
        >
    with $Provider<BusinessRepository> {
  const BusinessRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'businessRepositoryProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$businessRepositoryHash();

  @$internal
  @override
  $ProviderElement<BusinessRepository> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  BusinessRepository create(Ref ref) {
    return businessRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(BusinessRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<BusinessRepository>(value),
    );
  }
}

String _$businessRepositoryHash() =>
    r'55bef82ae40b071dbb11c1e495f81fb044151b99';
--- FILE: lib/features/business/providers/locations_providers.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'locations_providers.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(locationsRepository)
const locationsRepositoryProvider = LocationsRepositoryProvider._();

final class LocationsRepositoryProvider
    extends
        $FunctionalProvider<
          LocationsRepository,
          LocationsRepository,
          LocationsRepository
        >
    with $Provider<LocationsRepository> {
  const LocationsRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'locationsRepositoryProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$locationsRepositoryHash();

  @$internal
  @override
  $ProviderElement<LocationsRepository> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  LocationsRepository create(Ref ref) {
    return locationsRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(LocationsRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<LocationsRepository>(value),
    );
  }
}

String _$locationsRepositoryHash() =>
    r'b7c903cb21a57814102a5236a124d97353234b6d';
--- FILE: lib/features/business/data/business_api.dart ---
--- FILE: lib/features/business/data/locations_repository.dart ---
import '../../../core/models/location.dart';
import '../../../core/network/api_client.dart';

class LocationsRepository {
  LocationsRepository({required ApiClient apiClient}) : _apiClient = apiClient;

  final ApiClient _apiClient;

  Future<List<Location>> getByBusinessId(int businessId) async {
    final data = await _apiClient.getLocations(businessId);
    return data.map((json) => Location.fromJson(json)).toList();
  }

  Future<Location> create({
    required int businessId,
    required String name,
    String? address,
    String? phone,
    String? email,
    String? timezone,
    bool? isActive,
  }) async {
    final data = await _apiClient.createLocation(
      businessId: businessId,
      name: name,
      address: address,
      phone: phone,
      email: email,
      timezone: timezone,
      isActive: isActive,
    );
    return Location.fromJson(data);
  }

  Future<Location> update({
    required int locationId,
    String? name,
    String? address,
    String? phone,
    String? email,
    String? timezone,
    bool? isActive,
  }) async {
    final data = await _apiClient.updateLocation(
      locationId: locationId,
      name: name,
      address: address,
      phone: phone,
      email: email,
      timezone: timezone,
      isActive: isActive,
    );
    return Location.fromJson(data);
  }

  Future<void> delete(int locationId) async {
    await _apiClient.deleteLocation(locationId);
  }
}
--- FILE: lib/features/business/data/business_repository.dart ---
import '../../../core/models/business.dart';
import '../../../core/network/api_client.dart';

class BusinessRepository {
  BusinessRepository({required ApiClient apiClient}) : _apiClient = apiClient;

  final ApiClient _apiClient;

  Future<List<Business>> getAll() async {
    final data = await _apiClient.getBusinesses();
    return data.map((json) => Business.fromJson(json)).toList();
  }

  /// Superadmin: lista tutti i business.
  Future<List<Business>> getAllAdmin({String? search}) async {
    final data = await _apiClient.getAdminBusinesses(search: search);
    return data.map((json) => Business.fromJson(json)).toList();
  }

  /// Superadmin: crea un nuovo business.
  /// Se adminEmail fornito, invia email di benvenuto all'admin.
  Future<Business> createBusiness({
    required String name,
    required String slug,
    String? adminEmail,
    String? email,
    String? phone,
    String timezone = 'Europe/Rome',
    String currency = 'EUR',
    String? adminFirstName,
    String? adminLastName,
  }) async {
    final data = await _apiClient.createAdminBusiness(
      name: name,
      slug: slug,
      adminEmail: adminEmail,
      email: email,
      phone: phone,
      timezone: timezone,
      currency: currency,
      adminFirstName: adminFirstName,
      adminLastName: adminLastName,
    );
    // API ritorna { business: {...}, ... }
    final businessJson = data['business'] as Map<String, dynamic>? ?? data;
    return Business.fromJson(businessJson);
  }

  /// Superadmin: aggiorna un business esistente.
  /// Se adminEmail cambia, trasferisce ownership e invia email al nuovo admin.
  Future<Business> updateBusiness({
    required int businessId,
    String? name,
    String? slug,
    String? email,
    String? phone,
    String? timezone,
    String? currency,
    String? adminEmail,
  }) async {
    final data = await _apiClient.updateAdminBusiness(
      businessId: businessId,
      name: name,
      slug: slug,
      email: email,
      phone: phone,
      timezone: timezone,
      currency: currency,
      adminEmail: adminEmail,
    );
    // API ritorna { business: {...} }
    final businessJson = data['business'] as Map<String, dynamic>? ?? data;
    return Business.fromJson(businessJson);
  }

  /// Superadmin: reinvia email di invito all'admin.
  Future<void> resendAdminInvite(int businessId) async {
    await _apiClient.resendAdminInvite(businessId);
  }

  /// Superadmin: sospende/riattiva un business.
  /// Se isSuspended = true, il business mostra un messaggio agli operatori e ai clienti.
  Future<Business> suspendBusiness({
    required int businessId,
    required bool isSuspended,
    String? suspensionMessage,
  }) async {
    final data = await _apiClient.suspendBusiness(
      businessId: businessId,
      isSuspended: isSuspended,
      suspensionMessage: suspensionMessage,
    );
    final businessJson = data['business'] as Map<String, dynamic>? ?? data;
    return Business.fromJson(businessJson);
  }

  /// Superadmin: elimina (soft delete) un business.
  Future<void> deleteBusiness(int businessId) async {
    await _apiClient.deleteAdminBusiness(businessId);
  }
}
--- FILE: lib/features/business/data/business_users_repository.dart ---
import '../../../core/models/business_invitation.dart';
import '../../../core/models/business_user.dart';
import '../../../core/network/api_client.dart';

/// Repository per gestire operatori e inviti di un business.
class BusinessUsersRepository {
  BusinessUsersRepository({required ApiClient apiClient}) : _apiClient = apiClient;

  final ApiClient _apiClient;

  // ========== OPERATORI ==========

  /// Recupera tutti gli operatori di un business.
  Future<List<BusinessUser>> getUsers(int businessId) async {
    final data = await _apiClient.getBusinessUsers(businessId);
    return data.map((json) => BusinessUser.fromJson(json)).toList();
  }

  /// Aggiorna il ruolo di un operatore.
  Future<BusinessUser> updateUserRole({
    required int businessId,
    required int userId,
    required String role,
  }) async {
    final data = await _apiClient.updateBusinessUser(
      businessId: businessId,
      userId: userId,
      role: role,
    );
    return BusinessUser.fromJson(data);
  }

  /// Rimuove un operatore dal business.
  Future<void> removeUser({
    required int businessId,
    required int userId,
  }) async {
    await _apiClient.removeBusinessUser(
      businessId: businessId,
      userId: userId,
    );
  }

  // ========== INVITI ==========

  /// Recupera tutti gli inviti pendenti di un business.
  Future<List<BusinessInvitation>> getInvitations(int businessId) async {
    final data = await _apiClient.getBusinessInvitations(businessId);
    return data.map((json) => BusinessInvitation.fromJson(json)).toList();
  }

  /// Crea un nuovo invito.
  Future<BusinessInvitation> createInvitation({
    required int businessId,
    required String email,
    required String role,
  }) async {
    final data = await _apiClient.createBusinessInvitation(
      businessId: businessId,
      email: email,
      role: role,
    );
    return BusinessInvitation.fromJson(data);
  }

  /// Revoca un invito pendente.
  Future<void> revokeInvitation({
    required int businessId,
    required int invitationId,
  }) async {
    await _apiClient.revokeBusinessInvitation(
      businessId: businessId,
      invitationId: invitationId,
    );
  }

  /// Recupera i dettagli di un invito tramite token.
  Future<Map<String, dynamic>> getInvitationByToken(String token) async {
    return _apiClient.getInvitationByToken(token);
  }

  /// Accetta un invito.
  Future<void> acceptInvitation(String token) async {
    await _apiClient.acceptInvitation(token);
  }
}
--- FILE: lib/features/business/domain/business.dart ---
--- FILE: lib/features/business/presentation/operators_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:intl/intl.dart';

import '../../../app/providers/form_factor_provider.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../../core/models/business_invitation.dart';
import '../../../core/models/business_user.dart';
import '../../../core/widgets/app_bottom_sheet.dart';
import '../../../core/widgets/app_dialogs.dart';
import '../providers/business_users_provider.dart';
import 'dialogs/invite_operator_dialog.dart';
import 'dialogs/role_selection_dialog.dart';

/// Schermata per la gestione degli operatori di un business.
class OperatorsScreen extends ConsumerWidget {
  const OperatorsScreen({super.key, required this.businessId});

  final int businessId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(businessUsersProvider(businessId));
    final l10n = context.l10n;

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.pop(),
        ),
        title: Text(l10n.operatorsTitle),
      ),
      body: _buildBody(context, ref, state, l10n),
    );
  }

  Widget _buildBody(
    BuildContext context,
    WidgetRef ref,
    BusinessUsersState state,
    dynamic l10n,
  ) {
    if (state.isLoading && state.users.isEmpty) {
      return const Center(child: CircularProgressIndicator());
    }

    if (state.error != null && state.users.isEmpty) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Text(state.error!),
            const SizedBox(height: 16),
            FilledButton(
              onPressed: () => ref
                  .read(businessUsersProvider(businessId).notifier)
                  .refresh(),
              child: Text(l10n.actionConfirm),
            ),
          ],
        ),
      );
    }

    return RefreshIndicator(
      onRefresh: () =>
          ref.read(businessUsersProvider(businessId).notifier).refresh(),
      child: CustomScrollView(
        slivers: [
          // Header con sottotitolo e pulsante aggiungi
          SliverToBoxAdapter(
            child: Padding(
              padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
              child: Row(
                children: [
                  Expanded(
                    child: Text(
                      l10n.operatorsSubtitle,
                      style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Theme.of(context).colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ),
                  FilledButton.icon(
                    onPressed: () => _showInviteDialog(context, ref),
                    icon: const Icon(Icons.person_add, size: 18),
                    label: Text(l10n.operatorsInviteTitle),
                  ),
                ],
              ),
            ),
          ),

          // Sezione inviti pendenti
          if (state.invitations.isNotEmpty) ...[
            SliverToBoxAdapter(
              child: Padding(
                padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                child: Row(
                  children: [
                    Icon(
                      Icons.mail_outline,
                      size: 18,
                      color: Theme.of(context).colorScheme.primary,
                    ),
                    const SizedBox(width: 8),
                    Text(
                      l10n.operatorsPendingInvitesCount(
                        state.invitations.length,
                      ),
                      style: Theme.of(context).textTheme.titleSmall?.copyWith(
                        color: Theme.of(context).colorScheme.primary,
                      ),
                    ),
                  ],
                ),
              ),
            ),
            SliverList(
              delegate: SliverChildBuilderDelegate(
                (context, index) => _InvitationTile(
                  invitation: state.invitations[index],
                  businessId: businessId,
                ),
                childCount: state.invitations.length,
              ),
            ),
            const SliverToBoxAdapter(
              child: Divider(height: 32, indent: 16, endIndent: 16),
            ),
          ],

          // Lista operatori attivi
          if (state.users.isEmpty)
            SliverFillRemaining(
              hasScrollBody: false,
              child: Center(
                child: Text(
                  l10n.operatorsEmpty,
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                    color: Theme.of(context).colorScheme.onSurfaceVariant,
                  ),
                ),
              ),
            )
          else
            SliverList(
              delegate: SliverChildBuilderDelegate(
                (context, index) =>
                    _UserTile(user: state.users[index], businessId: businessId),
                childCount: state.users.length,
              ),
            ),

          // Padding finale
          const SliverToBoxAdapter(child: SizedBox(height: 80)),
        ],
      ),
    );
  }

  void _showInviteDialog(BuildContext context, WidgetRef ref) {
    final formFactor = ref.read(formFactorProvider);

    if (formFactor == AppFormFactor.mobile ||
        formFactor == AppFormFactor.tablet) {
      AppBottomSheet.show(
        context: context,
        builder: (ctx) => InviteOperatorSheet(businessId: businessId),
      );
    } else {
      showDialog(
        context: context,
        builder: (ctx) => InviteOperatorDialog(businessId: businessId),
      );
    }
  }
}

/// Tile per visualizzare un invito pendente.
class _InvitationTile extends ConsumerWidget {
  const _InvitationTile({required this.invitation, required this.businessId});

  final BusinessInvitation invitation;
  final int businessId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;
    final dateFormat = DateFormat.yMd();

    return ListTile(
      leading: CircleAvatar(
        backgroundColor: colorScheme.primaryContainer,
        child: Icon(Icons.mail_outline, color: colorScheme.onPrimaryContainer),
      ),
      title: Text(invitation.email),
      subtitle: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            invitation.roleLabel,
            style: TextStyle(color: colorScheme.onSurfaceVariant),
          ),
          Text(
            l10n.operatorsExpires(dateFormat.format(invitation.expiresAt)),
            style: Theme.of(context).textTheme.bodySmall?.copyWith(
              color: invitation.isExpired
                  ? colorScheme.error
                  : colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
      isThreeLine: true,
      trailing: PopupMenuButton<String>(
        onSelected: (value) async {
          if (value == 'revoke') {
            _confirmRevoke(context, ref);
          } else if (value == 'copy' && invitation.token != null) {
            _copyInviteLink(context, invitation.token!);
          }
        },
        itemBuilder: (context) => [
          if (invitation.token != null)
            PopupMenuItem(
              value: 'copy',
              child: Row(
                children: [
                  const Icon(Icons.copy, size: 20),
                  const SizedBox(width: 12),
                  Text(l10n.operatorsInviteCopied),
                ],
              ),
            ),
          PopupMenuItem(
            value: 'revoke',
            child: Row(
              children: [
                Icon(Icons.cancel_outlined, size: 20, color: colorScheme.error),
                const SizedBox(width: 12),
                Text(
                  l10n.operatorsRevokeInvite,
                  style: TextStyle(color: colorScheme.error),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  void _confirmRevoke(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    showAppConfirmDialog(
      context,
      title: Text(l10n.operatorsRevokeInvite),
      content: Text(l10n.operatorsRevokeInviteConfirm(invitation.email)),
      confirmLabel: l10n.actionConfirm,
      danger: true,
      onConfirm: () {
        ref
            .read(businessUsersProvider(businessId).notifier)
            .revokeInvitation(invitation.id);
      },
    );
  }

  void _copyInviteLink(BuildContext context, String token) {
    final url = 'https://agenda.example.com/invite/$token';
    Clipboard.setData(ClipboardData(text: url));
    ScaffoldMessenger.of(
      context,
    ).showSnackBar(SnackBar(content: Text(context.l10n.operatorsInviteCopied)));
  }
}

/// Tile per visualizzare un operatore attivo.
class _UserTile extends ConsumerWidget {
  const _UserTile({required this.user, required this.businessId});

  final BusinessUser user;
  final int businessId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;

    return ListTile(
      leading: CircleAvatar(
        backgroundColor: colorScheme.secondaryContainer,
        child: Text(
          _getInitials(user),
          style: TextStyle(
            color: colorScheme.onSecondaryContainer,
            fontWeight: FontWeight.w600,
          ),
        ),
      ),
      title: Row(
        children: [
          Flexible(child: Text(user.fullName)),
          if (user.isCurrentUser) ...[
            const SizedBox(width: 8),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
              decoration: BoxDecoration(
                color: colorScheme.primaryContainer,
                borderRadius: BorderRadius.circular(12),
              ),
              child: Text(
                l10n.operatorsYou,
                style: Theme.of(context).textTheme.labelSmall?.copyWith(
                  color: colorScheme.onPrimaryContainer,
                ),
              ),
            ),
          ],
        ],
      ),
      subtitle: Text(
        _getRoleLabel(user.role, l10n),
        style: TextStyle(color: colorScheme.onSurfaceVariant),
      ),
      trailing: user.isCurrentUser || user.role == 'owner'
          ? null
          : PopupMenuButton<String>(
              onSelected: (value) {
                if (value == 'edit') {
                  _showEditRoleDialog(context, ref);
                } else if (value == 'remove') {
                  _confirmRemove(context, ref);
                }
              },
              itemBuilder: (context) => [
                PopupMenuItem(
                  value: 'edit',
                  child: Row(
                    children: [
                      const Icon(Icons.edit_outlined, size: 20),
                      const SizedBox(width: 12),
                      Text(l10n.operatorsEditRole),
                    ],
                  ),
                ),
                PopupMenuItem(
                  value: 'remove',
                  child: Row(
                    children: [
                      Icon(
                        Icons.person_remove,
                        size: 20,
                        color: colorScheme.error,
                      ),
                      const SizedBox(width: 12),
                      Text(
                        l10n.operatorsRemove,
                        style: TextStyle(color: colorScheme.error),
                      ),
                    ],
                  ),
                ),
              ],
            ),
    );
  }

  String _getInitials(BusinessUser user) {
    final first = user.firstName.isNotEmpty ? user.firstName[0] : '';
    final last = user.lastName.isNotEmpty ? user.lastName[0] : '';
    if (first.isEmpty && last.isEmpty) {
      return user.email.isNotEmpty ? user.email[0].toUpperCase() : '?';
    }
    return '$first$last'.toUpperCase();
  }

  String _getRoleLabel(String role, dynamic l10n) {
    return switch (role) {
      'owner' => l10n.operatorsRoleOwner,
      'admin' => l10n.operatorsRoleAdmin,
      'manager' => l10n.operatorsRoleManager,
      'staff' => l10n.operatorsRoleStaff,
      _ => role,
    };
  }

  void _showEditRoleDialog(BuildContext context, WidgetRef ref) {
    final formFactor = ref.read(formFactorProvider);

    if (formFactor == AppFormFactor.mobile ||
        formFactor == AppFormFactor.tablet) {
      AppBottomSheet.show(
        context: context,
        heightFactor: null,
        builder: (ctx) => RoleSelectionSheet(
          currentRole: user.role,
          userName: user.fullName,
          onRoleSelected: (newRole) async {
            Navigator.of(ctx).pop();
            if (newRole != user.role) {
              await ref
                  .read(businessUsersProvider(businessId).notifier)
                  .updateUserRole(user.userId, newRole);
            }
          },
        ),
      );
    } else {
      showDialog(
        context: context,
        builder: (ctx) => RoleSelectionDialog(
          currentRole: user.role,
          userName: user.fullName,
          onRoleSelected: (newRole) async {
            Navigator.of(ctx).pop();
            if (newRole != user.role) {
              await ref
                  .read(businessUsersProvider(businessId).notifier)
                  .updateUserRole(user.userId, newRole);
            }
          },
        ),
      );
    }
  }

  void _confirmRemove(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    showAppConfirmDialog(
      context,
      title: Text(l10n.operatorsRemove),
      content: Text(l10n.operatorsRemoveConfirm(user.fullName)),
      confirmLabel: l10n.actionConfirm,
      danger: true,
      onConfirm: () {
        ref
            .read(businessUsersProvider(businessId).notifier)
            .removeUser(user.userId);
      },
    );
  }
}
--- FILE: lib/features/business/presentation/business_list_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../app/widgets/user_menu_button.dart';
import '../../../core/l10n/l10_extension.dart';
import '../../../core/models/business.dart';
import '../../../core/network/api_client.dart';
import '../../../core/services/preferences_service.dart';
import '../../agenda/providers/agenda_scroll_provider.dart';
import '../../agenda/providers/appointment_providers.dart';
import '../../agenda/providers/bookings_provider.dart';
import '../../agenda/providers/business_providers.dart';
import '../../agenda/providers/date_range_provider.dart';
import '../../agenda/providers/drag_session_provider.dart';
import '../../agenda/providers/dragged_appointment_provider.dart';
import '../../agenda/providers/dragged_base_range_provider.dart';
import '../../agenda/providers/initial_scroll_provider.dart';
import '../../agenda/providers/layout_config_provider.dart';
import '../../agenda/providers/location_providers.dart';
import '../../agenda/providers/pending_drop_provider.dart';
import '../../agenda/providers/resizing_provider.dart';
import '../../agenda/providers/resource_providers.dart';
import '../../agenda/providers/selected_appointment_provider.dart';
import '../../agenda/providers/staff_filter_providers.dart';
import '../../agenda/providers/temp_drag_time_provider.dart';
import '../../agenda/providers/time_blocks_provider.dart';
import '../../clients/providers/clients_providers.dart';
import '../../services/providers/service_categories_provider.dart';
import '../../services/providers/services_provider.dart';
import '../../staff/providers/availability_exceptions_provider.dart';
import '../../staff/providers/staff_providers.dart';
import '../providers/business_providers.dart';
import 'dialogs/create_business_dialog.dart';
import 'dialogs/edit_business_dialog.dart';

/// Notifier per tracciare se il superadmin ha selezionato un business.
/// Quando √® null, mostra la lista business.
/// Salva l'ultimo business visitato nelle preferenze per accesso rapido.
class SuperadminSelectedBusinessNotifier extends Notifier<int?> {
  @override
  int? build() {
    // Carica l'ultimo business salvato dalle preferenze
    final prefs = ref.read(preferencesServiceProvider);
    return prefs.getSuperadminLastBusinessId();
  }

  void select(int businessId) {
    state = businessId;
    // Salva nelle preferenze per accesso rapido al prossimo login
    ref
        .read(preferencesServiceProvider)
        .setSuperadminLastBusinessId(businessId);
  }

  /// Pulisce la selezione e invalida tutti i provider relativi al business.
  void clear() {
    state = null;
    // NON rimuoviamo dalle preferenze: l'utente pu√≤ tornare con "Cambia Business"
    // ma al prossimo login verr√† comunque portato all'ultimo business

    // Invalida tutti i provider business-specific per forzare ricaricamento
    _invalidateBusinessProviders();
  }

  /// Pulisce completamente la selezione, anche dalle preferenze.
  /// Da usare al logout o se il business viene eliminato.
  void clearCompletely() {
    state = null;
    ref.read(preferencesServiceProvider).clearSuperadminLastBusinessId();
    _invalidateBusinessProviders();
  }

  /// Invalida tutti i provider che contengono dati specifici del business.
  void _invalidateBusinessProviders() {
    // Staff
    ref.invalidate(allStaffProvider);

    // Locations
    ref.invalidate(locationsProvider);
    ref.invalidate(currentLocationProvider);

    // Services
    ref.invalidate(servicesProvider);
    ref.invalidate(serviceCategoriesProvider);
    ref.invalidate(serviceStaffEligibilityProvider);

    // Clients
    ref.invalidate(clientsProvider);

    // Appointments
    ref.invalidate(appointmentsProvider);

    // Bookings (prenotazioni con note/clientName)
    ref.invalidate(bookingsProvider);

    // Resources
    ref.invalidate(resourcesProvider);

    // Time Blocks
    ref.invalidate(timeBlocksProvider);

    // Availability Exceptions
    ref.invalidate(availabilityExceptionsProvider);

    // UI State legato al business (contiene ID di entit√† business-specific)
    ref.invalidate(selectedStaffIdsProvider);
    ref.invalidate(staffFilterModeProvider);
    ref.invalidate(selectedAppointmentProvider);
    ref.invalidate(dragSessionProvider);
    ref.invalidate(draggedAppointmentIdProvider);
    ref.invalidate(draggedBaseRangeProvider);
    ref.invalidate(tempDragTimeProvider);
    ref.invalidate(resizingProvider);
    ref.invalidate(pendingDropProvider);

    // Business ID corrente (currentBusinessProvider √® derivato, si aggiorna da solo)
    ref.invalidate(currentBusinessIdProvider);

    // Layout e UI state (per sicurezza, anche se sembrano UI-only)
    ref.invalidate(layoutConfigProvider);
    ref.invalidate(agendaDateProvider);
    ref.invalidate(agendaScrollProvider);
    ref.invalidate(initialScrollDoneProvider);
    ref.invalidate(agendaVerticalOffsetProvider);
  }
}

final superadminSelectedBusinessProvider =
    NotifierProvider<SuperadminSelectedBusinessNotifier, int?>(
      SuperadminSelectedBusinessNotifier.new,
    );

/// Schermata lista business per superadmin.
/// Mostra tutti i business con possibilit√† di selezionarne uno o crearne uno nuovo.
class BusinessListScreen extends ConsumerWidget {
  const BusinessListScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final businessesAsync = ref.watch(businessesProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Seleziona Business'),
        centerTitle: true,
        actions: [
          // Menu utente (profilo, cambia password, logout)
          const UserMenuButton(),
          const SizedBox(width: 8),
        ],
      ),
      body: businessesAsync.when(
        data: (businesses) => _BusinessList(
          businesses: businesses,
          onSelect: (business) => _selectBusiness(context, ref, business),
          onEdit: (business) => _showEditBusinessDialog(context, ref, business),
          onResendInvite: (business) =>
              _showResendInviteDialog(context, ref, business),
          onSuspend: (business) => _showSuspendDialog(context, ref, business),
          onDelete: (business) => _showDeleteDialog(context, ref, business),
        ),
        loading: () => const Center(child: CircularProgressIndicator()),
        error: (error, _) => Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.error_outline, size: 48, color: colorScheme.error),
              const SizedBox(height: 16),
              Text(
                'Errore nel caricamento',
                style: theme.textTheme.titleMedium,
              ),
              const SizedBox(height: 8),
              Text(
                error.toString(),
                style: theme.textTheme.bodySmall?.copyWith(
                  color: colorScheme.onSurfaceVariant,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              FilledButton.tonal(
                onPressed: () => ref.invalidate(businessesProvider),
                child: const Text('Riprova'),
              ),
            ],
          ),
        ),
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _showCreateBusinessDialog(context, ref),
        icon: const Icon(Icons.add),
        label: const Text('Aggiungi'),
      ),
    );
  }

  void _selectBusiness(BuildContext context, WidgetRef ref, Business business) {
    // Imposta il business corrente
    ref.read(currentBusinessIdProvider.notifier).set(business.id);
    // Segna che il superadmin ha selezionato un business
    ref.read(superadminSelectedBusinessProvider.notifier).select(business.id);
    // Naviga all'agenda
    context.go('/agenda');
  }

  Future<void> _showCreateBusinessDialog(
    BuildContext context,
    WidgetRef ref,
  ) async {
    final created = await showCreateBusinessDialog(context);
    if (created == true) {
      // Forza il refresh della lista
      ref.read(businessesRefreshProvider.notifier).refresh();
    }
  }

  Future<void> _showEditBusinessDialog(
    BuildContext context,
    WidgetRef ref,
    Business business,
  ) async {
    final updated = await showEditBusinessDialog(context, business);
    if (updated == true) {
      // Forza il refresh della lista
      ref.read(businessesRefreshProvider.notifier).refresh();
    }
  }

  Future<void> _showResendInviteDialog(
    BuildContext context,
    WidgetRef ref,
    Business business,
  ) async {
    final l10n = context.l10n;
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Reinvia invito'),
        content: Text(
          business.adminEmail != null
              ? 'Vuoi reinviare l\'email di invito a ${business.adminEmail}?'
              : 'Questo business non ha un admin email configurato.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: Text(l10n.actionCancel),
          ),
          if (business.adminEmail != null)
            FilledButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: const Text('Invia'),
            ),
        ],
      ),
    );

    if (confirmed == true && context.mounted) {
      try {
        final repository = ref.read(businessRepositoryProvider);
        await repository.resendAdminInvite(business.id);

        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Invito inviato a ${business.adminEmail}'),
              backgroundColor: Theme.of(context).colorScheme.primary,
            ),
          );
        }
      } on ApiException catch (e) {
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Errore: ${e.message}'),
              backgroundColor: Theme.of(context).colorScheme.error,
            ),
          );
        }
      } catch (e) {
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Errore: $e'),
              backgroundColor: Theme.of(context).colorScheme.error,
            ),
          );
        }
      }
    }
  }

  /// Mostra dialog per sospendere/riattivare un business
  Future<void> _showSuspendDialog(
    BuildContext context,
    WidgetRef ref,
    Business business,
  ) async {
    final l10n = context.l10n;
    final isSuspended = business.isSuspended;

    // Se √® gi√† sospeso, mostra dialog per riattivare
    if (isSuspended) {
      final confirmed = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('Riattiva Business'),
          content: Text(
            'Vuoi riattivare "${business.name}"?\n\n'
            'Gli operatori e i clienti potranno accedere normalmente.',
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: Text(l10n.actionCancel),
            ),
            FilledButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: const Text('Riattiva'),
            ),
          ],
        ),
      );

      if (confirmed == true && context.mounted) {
        await _executeSuspend(context, ref, business, false, null);
      }
      return;
    }

    // Dialog per sospendere con messaggio
    final messageController = TextEditingController();
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Sospendi Business'),
        content: SizedBox(
          width: 400,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                'Sospendendo "${business.name}" gli operatori vedranno un avviso '
                'e i clienti non potranno effettuare prenotazioni online.',
              ),
              const SizedBox(height: 16),
              TextField(
                controller: messageController,
                decoration: const InputDecoration(
                  labelText: 'Messaggio di sospensione (opzionale)',
                  hintText: 'Es: Chiuso per ferie fino al 15 gennaio',
                  border: OutlineInputBorder(),
                ),
                maxLines: 2,
              ),
            ],
          ),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: Text(l10n.actionCancel),
          ),
          FilledButton(
            style: FilledButton.styleFrom(backgroundColor: Colors.orange),
            onPressed: () => Navigator.of(context).pop(true),
            child: const Text('Sospendi'),
          ),
        ],
      ),
    );

    if (confirmed == true && context.mounted) {
      final message = messageController.text.trim().isEmpty
          ? null
          : messageController.text.trim();
      await _executeSuspend(context, ref, business, true, message);
    }
  }

  Future<void> _executeSuspend(
    BuildContext context,
    WidgetRef ref,
    Business business,
    bool isSuspended,
    String? message,
  ) async {
    try {
      final repository = ref.read(businessRepositoryProvider);
      await repository.suspendBusiness(
        businessId: business.id,
        isSuspended: isSuspended,
        suspensionMessage: message,
      );

      if (context.mounted) {
        final snackMessage = isSuspended
            ? '${business.name} sospeso'
            : '${business.name} riattivato';
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(snackMessage),
            backgroundColor: isSuspended
                ? Colors.orange
                : Theme.of(context).colorScheme.primary,
          ),
        );
        // Refresh lista
        ref.read(businessesRefreshProvider.notifier).refresh();
      }
    } on ApiException catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Errore: ${e.message}'),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Errore: $e'),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    }
  }

  /// Mostra dialog per eliminare un business
  Future<void> _showDeleteDialog(
    BuildContext context,
    WidgetRef ref,
    Business business,
  ) async {
    final l10n = context.l10n;

    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Elimina Business'),
        content: Text(
          'Sei sicuro di voler eliminare "${business.name}"?\n\n'
          '‚ö†Ô∏è Questa azione nasconder√† il business dalla lista. '
          'I dati non verranno cancellati definitivamente.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: Text(l10n.actionCancel),
          ),
          FilledButton(
            style: FilledButton.styleFrom(
              backgroundColor: Theme.of(context).colorScheme.error,
            ),
            onPressed: () => Navigator.of(context).pop(true),
            child: Text(l10n.actionDelete),
          ),
        ],
      ),
    );

    if (confirmed == true && context.mounted) {
      try {
        final repository = ref.read(businessRepositoryProvider);
        await repository.deleteBusiness(business.id);

        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('${business.name} eliminato'),
              backgroundColor: Theme.of(context).colorScheme.primary,
            ),
          );
          // Refresh lista
          ref.read(businessesRefreshProvider.notifier).refresh();
        }
      } on ApiException catch (e) {
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Errore: ${e.message}'),
              backgroundColor: Theme.of(context).colorScheme.error,
            ),
          );
        }
      } catch (e) {
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(
              content: Text('Errore: $e'),
              backgroundColor: Theme.of(context).colorScheme.error,
            ),
          );
        }
      }
    }
  }
}

class _BusinessList extends StatelessWidget {
  const _BusinessList({
    required this.businesses,
    required this.onSelect,
    required this.onEdit,
    required this.onResendInvite,
    required this.onSuspend,
    required this.onDelete,
  });

  final List<Business> businesses;
  final void Function(Business) onSelect;
  final void Function(Business) onEdit;
  final void Function(Business) onResendInvite;
  final void Function(Business) onSuspend;
  final void Function(Business) onDelete;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    if (businesses.isEmpty) {
      return Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.business_outlined,
              size: 64,
              color: colorScheme.onSurfaceVariant.withValues(alpha: 0.5),
            ),
            const SizedBox(height: 16),
            Text(
              'Nessun business',
              style: theme.textTheme.titleLarge?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              'Crea il tuo primo business per iniziare',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ),
      );
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        // Responsive grid
        final crossAxisCount = constraints.maxWidth > 900
            ? 3
            : constraints.maxWidth > 600
            ? 2
            : 1;

        return GridView.builder(
          padding: const EdgeInsets.all(24),
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: crossAxisCount,
            childAspectRatio: 2.5,
            crossAxisSpacing: 16,
            mainAxisSpacing: 16,
          ),
          itemCount: businesses.length,
          itemBuilder: (context, index) {
            final business = businesses[index];
            return _BusinessCard(
              business: business,
              onTap: () => onSelect(business),
              onEdit: () => onEdit(business),
              onResendInvite: () => onResendInvite(business),
              onSuspend: () => onSuspend(business),
              onDelete: () => onDelete(business),
            );
          },
        );
      },
    );
  }
}

class _BusinessCard extends StatelessWidget {
  const _BusinessCard({
    required this.business,
    required this.onTap,
    required this.onEdit,
    required this.onResendInvite,
    required this.onSuspend,
    required this.onDelete,
  });

  final Business business;
  final VoidCallback onTap;
  final VoidCallback onEdit;
  final VoidCallback onResendInvite;
  final VoidCallback onSuspend;
  final VoidCallback onDelete;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final screenWidth = MediaQuery.sizeOf(context).width;
    final isCompact = screenWidth < 400;

    return Card(
      clipBehavior: Clip.antiAlias,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: EdgeInsets.all(isCompact ? 10 : 16),
          child: Row(
            children: [
              // Avatar con iniziale
              CircleAvatar(
                radius: isCompact ? 18 : 24,
                backgroundColor: colorScheme.primaryContainer,
                child: Text(
                  business.name.isNotEmpty
                      ? business.name[0].toUpperCase()
                      : '?',
                  style: TextStyle(
                    fontSize: isCompact ? 14 : 20,
                    fontWeight: FontWeight.bold,
                    color: colorScheme.onPrimaryContainer,
                  ),
                ),
              ),
              SizedBox(width: isCompact ? 10 : 14),
              // Info business
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisAlignment: MainAxisAlignment.center,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Row(
                      children: [
                        Expanded(
                          child: Text(
                            business.name,
                            style:
                                (isCompact
                                        ? theme.textTheme.bodyMedium
                                        : theme.textTheme.titleMedium)
                                    ?.copyWith(fontWeight: FontWeight.w600),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        const SizedBox(width: 6),
                        // Badge sospeso
                        if (business.isSuspended) ...[
                          Container(
                            padding: EdgeInsets.symmetric(
                              horizontal: isCompact ? 4 : 6,
                              vertical: 1,
                            ),
                            decoration: BoxDecoration(
                              color: Colors.orange.withValues(alpha: 0.2),
                              borderRadius: BorderRadius.circular(4),
                            ),
                            child: Row(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Icon(
                                  Icons.pause_circle,
                                  size: isCompact ? 10 : 12,
                                  color: Colors.orange.shade700,
                                ),
                                SizedBox(width: isCompact ? 2 : 4),
                                Text(
                                  'Sospeso',
                                  style: theme.textTheme.labelSmall?.copyWith(
                                    color: Colors.orange.shade700,
                                    fontWeight: FontWeight.w600,
                                    fontSize: isCompact ? 9 : 11,
                                  ),
                                ),
                              ],
                            ),
                          ),
                          const SizedBox(width: 6),
                        ],
                        // Badge ID
                        Container(
                          padding: EdgeInsets.symmetric(
                            horizontal: isCompact ? 4 : 6,
                            vertical: 1,
                          ),
                          decoration: BoxDecoration(
                            color: colorScheme.surfaceContainerHighest,
                            borderRadius: BorderRadius.circular(4),
                          ),
                          child: Text(
                            'ID: ${business.id}',
                            style: theme.textTheme.labelSmall?.copyWith(
                              color: colorScheme.onSurfaceVariant,
                              fontFamily: 'monospace',
                              fontSize: isCompact ? 9 : 11,
                            ),
                          ),
                        ),
                      ],
                    ),
                    // Slug (sempre) e admin email (solo desktop)
                    if (business.slug != null ||
                        (!isCompact && business.adminEmail != null))
                      SizedBox(height: isCompact ? 2 : 4),
                    if (business.slug != null ||
                        (!isCompact && business.adminEmail != null))
                      Text(
                        [
                          if (business.slug != null) business.slug!,
                          if (!isCompact && business.adminEmail != null)
                            business.adminEmail!,
                        ].join(' ‚Ä¢ '),
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: colorScheme.onSurfaceVariant,
                          fontSize: isCompact ? 11 : null,
                        ),
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                  ],
                ),
              ),
              // Menu azioni
              PopupMenuButton<String>(
                onSelected: (value) {
                  switch (value) {
                    case 'edit':
                      onEdit();
                    case 'resend':
                      onResendInvite();
                    case 'suspend':
                      onSuspend();
                    case 'delete':
                      onDelete();
                  }
                },
                itemBuilder: (context) => [
                  const PopupMenuItem(
                    value: 'edit',
                    child: ListTile(
                      leading: Icon(Icons.edit_outlined),
                      title: Text('Modifica'),
                      contentPadding: EdgeInsets.zero,
                      dense: true,
                    ),
                  ),
                  const PopupMenuItem(
                    value: 'resend',
                    child: ListTile(
                      leading: Icon(Icons.email_outlined),
                      title: Text('Reinvia invito'),
                      contentPadding: EdgeInsets.zero,
                      dense: true,
                    ),
                  ),
                  PopupMenuItem(
                    value: 'suspend',
                    child: ListTile(
                      leading: Icon(
                        business.isSuspended
                            ? Icons.play_circle_outline
                            : Icons.pause_circle_outline,
                        color: business.isSuspended
                            ? Colors.green
                            : Colors.orange,
                      ),
                      title: Text(
                        business.isSuspended ? 'Riattiva' : 'Sospendi',
                      ),
                      contentPadding: EdgeInsets.zero,
                      dense: true,
                    ),
                  ),
                  const PopupMenuDivider(),
                  PopupMenuItem(
                    value: 'delete',
                    child: ListTile(
                      leading: Icon(
                        Icons.delete_outline,
                        color: Theme.of(context).colorScheme.error,
                      ),
                      title: Text(
                        'Elimina',
                        style: TextStyle(
                          color: Theme.of(context).colorScheme.error,
                        ),
                      ),
                      contentPadding: EdgeInsets.zero,
                      dense: true,
                    ),
                  ),
                ],
                icon: const Icon(Icons.more_vert),
              ),
              // Freccia per entrare (solo su schermi non compatti)
              if (!isCompact) ...[
                const SizedBox(width: 4),
                Icon(
                  Icons.arrow_forward_ios,
                  size: 16,
                  color: colorScheme.onSurfaceVariant,
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/business/presentation/business_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/l10_extension.dart';
import '../../agenda/providers/business_providers.dart';

/// Schermata impostazioni business.
///
/// Permette di accedere alle impostazioni del business corrente:
/// - Gestione operatori
/// - Altre impostazioni future...
class BusinessScreen extends ConsumerWidget {
  const BusinessScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final business = ref.watch(currentBusinessProvider);
    final l10n = context.l10n;

    return Scaffold(
      appBar: AppBar(title: Text(business.name)),
      body: ListView(
        children: [
          // Gestione Operatori
          ListTile(
            leading: const Icon(Icons.supervisor_account_outlined),
            title: Text(l10n.operatorsTitle),
            subtitle: Text(l10n.operatorsSubtitle),
            trailing: const Icon(Icons.chevron_right),
            onTap: () => context.push('/operatori/${business.id}'),
          ),
          const Divider(),
          // Placeholder per future impostazioni
          // ListTile(
          //   leading: const Icon(Icons.settings_outlined),
          //   title: Text('Impostazioni'),
          //   trailing: const Icon(Icons.chevron_right),
          //   onTap: () {},
          // ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/business/presentation/dialogs/create_business_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/network/api_client.dart';
import '../../../agenda/providers/business_providers.dart';
import '../../providers/business_providers.dart';

/// Dialog per creare un nuovo business (solo superadmin).
/// Richiede l'email dell'admin che ricever√† una mail di benvenuto.
class CreateBusinessDialog extends ConsumerStatefulWidget {
  const CreateBusinessDialog({super.key});

  @override
  ConsumerState<CreateBusinessDialog> createState() =>
      _CreateBusinessDialogState();
}

class _CreateBusinessDialogState extends ConsumerState<CreateBusinessDialog> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _slugController = TextEditingController();
  final _adminEmailController = TextEditingController();
  final _emailController = TextEditingController();
  final _phoneController = TextEditingController();

  bool _isLoading = false;
  String? _error;
  bool _autoGenerateSlug = true;

  @override
  void initState() {
    super.initState();
    _nameController.addListener(_onNameChanged);
  }

  @override
  void dispose() {
    _nameController.removeListener(_onNameChanged);
    _nameController.dispose();
    _slugController.dispose();
    _adminEmailController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    super.dispose();
  }

  void _onNameChanged() {
    if (_autoGenerateSlug) {
      _slugController.text = _generateSlug(_nameController.text);
    }
  }

  String _generateSlug(String name) {
    return name
        .toLowerCase()
        .replaceAll(RegExp(r'[√†√°√¢√£√§√•]'), 'a')
        .replaceAll(RegExp(r'[√®√©√™√´]'), 'e')
        .replaceAll(RegExp(r'[√¨√≠√Æ√Ø]'), 'i')
        .replaceAll(RegExp(r'[√≤√≥√¥√µ√∂]'), 'o')
        .replaceAll(RegExp(r'[√π√∫√ª√º]'), 'u')
        .replaceAll(RegExp(r'[^a-z0-9\s-]'), '')
        .replaceAll(RegExp(r'\s+'), '-')
        .replaceAll(RegExp(r'-+'), '-')
        .replaceAll(RegExp(r'^-|-$'), '');
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      final repository = ref.read(businessRepositoryProvider);

      await repository.createBusiness(
        name: _nameController.text.trim(),
        slug: _slugController.text.trim(),
        adminEmail: _adminEmailController.text.trim().isEmpty
            ? null
            : _adminEmailController.text.trim(),
        email: _emailController.text.trim().isEmpty
            ? null
            : _emailController.text.trim(),
        phone: _phoneController.text.trim().isEmpty
            ? null
            : _phoneController.text.trim(),
      );

      // Invalida il provider per ricaricare la lista
      ref.invalidate(businessesProvider);

      // Attendi un frame per permettere al provider di invalidarsi
      await Future.delayed(Duration.zero);

      if (mounted) {
        Navigator.of(context).pop(true);
      }
    } on ApiException catch (e) {
      setState(() {
        _error = e.message;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return AlertDialog(
      title: const Text('Nuovo Business'),
      content: SizedBox(
        width: 400,
        child: Form(
          key: _formKey,
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                if (_error != null) ...[
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: colorScheme.errorContainer,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Row(
                      children: [
                        Icon(
                          Icons.error_outline,
                          color: colorScheme.onErrorContainer,
                          size: 20,
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            _error!,
                            style: TextStyle(
                              color: colorScheme.onErrorContainer,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 16),
                ],
                // Nome
                TextFormField(
                  controller: _nameController,
                  decoration: const InputDecoration(
                    labelText: 'Nome *',
                    hintText: 'es. Salone Bellezza',
                    prefixIcon: Icon(Icons.business),
                  ),
                  textCapitalization: TextCapitalization.words,
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return 'Il nome √® obbligatorio';
                    }
                    if (value.trim().length < 2) {
                      return 'Il nome deve avere almeno 2 caratteri';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                // Slug
                TextFormField(
                  controller: _slugController,
                  decoration: InputDecoration(
                    labelText: 'Slug URL *',
                    hintText: 'es. salone-bellezza',
                    prefixIcon: const Icon(Icons.link),
                    helperText: 'Usato per URL: prenota.romeolab.it/slug',
                    suffixIcon: _autoGenerateSlug
                        ? IconButton(
                            icon: const Icon(Icons.edit),
                            tooltip: 'Modifica manualmente',
                            onPressed: () {
                              setState(() => _autoGenerateSlug = false);
                            },
                          )
                        : IconButton(
                            icon: const Icon(Icons.auto_fix_high),
                            tooltip: 'Genera automaticamente',
                            onPressed: () {
                              setState(() {
                                _autoGenerateSlug = true;
                                _slugController.text = _generateSlug(
                                  _nameController.text,
                                );
                              });
                            },
                          ),
                  ),
                  onChanged: (_) {
                    if (_autoGenerateSlug) {
                      setState(() => _autoGenerateSlug = false);
                    }
                  },
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return 'Lo slug √® obbligatorio';
                    }
                    if (!RegExp(r'^[a-z0-9-]+$').hasMatch(value)) {
                      return 'Solo lettere minuscole, numeri e trattini';
                    }
                    if (value.length < 3) {
                      return 'Lo slug deve avere almeno 3 caratteri';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                // Email Admin (opzionale - pu√≤ essere assegnato dopo)
                TextFormField(
                  controller: _adminEmailController,
                  decoration: const InputDecoration(
                    labelText: 'Email Amministratore',
                    hintText: 'es. mario.rossi@email.it',
                    prefixIcon: Icon(Icons.admin_panel_settings),
                    helperText:
                        'Opzionale: ricever√† email per configurare account',
                  ),
                  keyboardType: TextInputType.emailAddress,
                  validator: (value) {
                    // Solo valida se inserito
                    if (value != null && value.trim().isNotEmpty) {
                      if (!RegExp(
                        r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                      ).hasMatch(value)) {
                        return 'Email non valida';
                      }
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                // Email Business (opzionale)
                TextFormField(
                  controller: _emailController,
                  decoration: const InputDecoration(
                    labelText: 'Email Business',
                    hintText: 'es. info@salone.it',
                    prefixIcon: Icon(Icons.email_outlined),
                    helperText: 'Contatto pubblico del business',
                  ),
                  keyboardType: TextInputType.emailAddress,
                  validator: (value) {
                    if (value != null && value.isNotEmpty) {
                      if (!RegExp(
                        r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                      ).hasMatch(value)) {
                        return 'Email non valida';
                      }
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                // Telefono
                TextFormField(
                  controller: _phoneController,
                  decoration: const InputDecoration(
                    labelText: 'Telefono',
                    hintText: 'es. +39 123 456 7890',
                    prefixIcon: Icon(Icons.phone_outlined),
                  ),
                  keyboardType: TextInputType.phone,
                ),
                const SizedBox(height: 8),
                Text(
                  '* Campi obbligatori',
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: colorScheme.onSurfaceVariant,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
          child: Text(l10n.actionCancel),
        ),
        FilledButton(
          onPressed: _isLoading ? null : _submit,
          child: _isLoading
              ? const SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(strokeWidth: 2),
                )
              : const Text('Crea Business'),
        ),
      ],
    );
  }
}

/// Mostra il dialog per creare un nuovo business.
Future<bool?> showCreateBusinessDialog(BuildContext context) {
  return showDialog<bool>(
    context: context,
    builder: (context) => const CreateBusinessDialog(),
  );
}
--- FILE: lib/features/business/presentation/dialogs/invite_operator_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../providers/business_users_provider.dart';

/// Dialog per invitare un nuovo operatore (desktop).
class InviteOperatorDialog extends ConsumerStatefulWidget {
  const InviteOperatorDialog({super.key, required this.businessId});

  final int businessId;

  @override
  ConsumerState<InviteOperatorDialog> createState() =>
      _InviteOperatorDialogState();
}

class _InviteOperatorDialogState extends ConsumerState<InviteOperatorDialog> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  String _selectedRole = 'staff';
  bool _isLoading = false;

  @override
  void dispose() {
    _emailController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;

    return AppFormDialog(
      title: Text(l10n.operatorsInviteTitle),
      content: Form(
        key: _formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              l10n.operatorsInviteSubtitle,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
            const SizedBox(height: 24),
            TextFormField(
              controller: _emailController,
              decoration: InputDecoration(
                labelText: l10n.operatorsInviteEmail,
                border: const OutlineInputBorder(),
                prefixIcon: const Icon(Icons.email_outlined),
              ),
              keyboardType: TextInputType.emailAddress,
              autofocus: true,
              validator: (value) {
                if (value == null || value.isEmpty) {
                  return l10n.validationRequired;
                }
                if (!_isValidEmail(value)) {
                  return l10n.validationInvalidEmail;
                }
                return null;
              },
            ),
            const SizedBox(height: 16),
            Text(
              l10n.operatorsInviteRole,
              style: Theme.of(context).textTheme.titleSmall,
            ),
            const SizedBox(height: 8),
            _RoleSelector(
              selectedRole: _selectedRole,
              onChanged: (role) => setState(() => _selectedRole = role),
            ),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
          child: Text(l10n.actionCancel),
        ),
        FilledButton(
          onPressed: _isLoading ? null : _submit,
          child: _isLoading
              ? const SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(strokeWidth: 2),
                )
              : Text(l10n.operatorsInviteSend),
        ),
      ],
    );
  }

  bool _isValidEmail(String email) {
    return RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(email);
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    final invitation = await ref
        .read(businessUsersProvider(widget.businessId).notifier)
        .createInvitation(
          email: _emailController.text.trim(),
          role: _selectedRole,
        );

    if (!mounted) return;

    setState(() => _isLoading = false);

    if (invitation != null) {
      Navigator.of(context).pop();
      _showSuccessSnackbar(context, invitation.email, invitation.token);
    }
  }

  void _showSuccessSnackbar(BuildContext context, String email, String? token) {
    final l10n = context.l10n;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(l10n.operatorsInviteSuccess(email)),
        action: token != null
            ? SnackBarAction(
                label: 'Copy',
                onPressed: () {
                  final url = 'https://agenda.example.com/invite/$token';
                  Clipboard.setData(ClipboardData(text: url));
                },
              )
            : null,
      ),
    );
  }
}

/// Bottom sheet per invitare un nuovo operatore (mobile/tablet).
class InviteOperatorSheet extends ConsumerStatefulWidget {
  const InviteOperatorSheet({super.key, required this.businessId});

  final int businessId;

  @override
  ConsumerState<InviteOperatorSheet> createState() =>
      _InviteOperatorSheetState();
}

class _InviteOperatorSheetState extends ConsumerState<InviteOperatorSheet> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  String _selectedRole = 'staff';
  bool _isLoading = false;

  @override
  void dispose() {
    _emailController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Header
        Text(
          l10n.operatorsInviteTitle,
          style: Theme.of(context).textTheme.titleLarge,
        ),
        const SizedBox(height: 4),
        Text(
          l10n.operatorsInviteSubtitle,
          style: Theme.of(context).textTheme.bodySmall?.copyWith(
            color: Theme.of(context).colorScheme.onSurfaceVariant,
          ),
        ),
        const SizedBox(height: 24),

        // Form
        Expanded(
          child: Form(
            key: _formKey,
            child: ListView(
              children: [
                TextFormField(
                  controller: _emailController,
                  decoration: InputDecoration(
                    labelText: l10n.operatorsInviteEmail,
                    border: const OutlineInputBorder(),
                    prefixIcon: const Icon(Icons.email_outlined),
                  ),
                  keyboardType: TextInputType.emailAddress,
                  autofocus: true,
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.validationRequired;
                    }
                    if (!_isValidEmail(value)) {
                      return l10n.validationInvalidEmail;
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 24),
                Text(
                  l10n.operatorsInviteRole,
                  style: Theme.of(context).textTheme.titleSmall,
                ),
                const SizedBox(height: 8),
                _RoleSelector(
                  selectedRole: _selectedRole,
                  onChanged: (role) => setState(() => _selectedRole = role),
                ),
              ],
            ),
          ),
        ),

        // Actions
        const SizedBox(height: 16),
        Row(
          children: [
            Expanded(
              child: OutlinedButton(
                onPressed: _isLoading
                    ? null
                    : () => Navigator.of(context).pop(),
                child: Text(l10n.actionCancel),
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: FilledButton(
                onPressed: _isLoading ? null : _submit,
                child: _isLoading
                    ? const SizedBox(
                        width: 20,
                        height: 20,
                        child: CircularProgressIndicator(strokeWidth: 2),
                      )
                    : Text(l10n.operatorsInviteSend),
              ),
            ),
          ],
        ),
      ],
    );
  }

  bool _isValidEmail(String email) {
    return RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$').hasMatch(email);
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _isLoading = true);

    final invitation = await ref
        .read(businessUsersProvider(widget.businessId).notifier)
        .createInvitation(
          email: _emailController.text.trim(),
          role: _selectedRole,
        );

    if (!mounted) return;

    setState(() => _isLoading = false);

    if (invitation != null) {
      Navigator.of(context).pop();
      _showSuccessSnackbar(context, invitation.email, invitation.token);
    }
  }

  void _showSuccessSnackbar(BuildContext context, String email, String? token) {
    final l10n = context.l10n;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(l10n.operatorsInviteSuccess(email)),
        action: token != null
            ? SnackBarAction(
                label: 'Copy',
                onPressed: () {
                  final url = 'https://agenda.example.com/invite/$token';
                  Clipboard.setData(ClipboardData(text: url));
                },
              )
            : null,
      ),
    );
  }
}

/// Widget per selezionare un ruolo.
class _RoleSelector extends StatelessWidget {
  const _RoleSelector({required this.selectedRole, required this.onChanged});

  final String selectedRole;
  final ValueChanged<String> onChanged;

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;

    return Column(
      children: [
        _RoleOption(
          role: 'admin',
          label: l10n.operatorsRoleAdmin,
          description: 'Accesso completo, pu√≤ gestire operatori',
          icon: Icons.admin_panel_settings,
          isSelected: selectedRole == 'admin',
          onTap: () => onChanged('admin'),
        ),
        const SizedBox(height: 8),
        _RoleOption(
          role: 'manager',
          label: l10n.operatorsRoleManager,
          description: 'Gestisce agenda e clienti',
          icon: Icons.manage_accounts,
          isSelected: selectedRole == 'manager',
          onTap: () => onChanged('manager'),
        ),
        const SizedBox(height: 8),
        _RoleOption(
          role: 'staff',
          label: l10n.operatorsRoleStaff,
          description: 'Visualizza e gestisce solo i propri appuntamenti',
          icon: Icons.person,
          isSelected: selectedRole == 'staff',
          onTap: () => onChanged('staff'),
        ),
      ],
    );
  }
}

/// Singola opzione ruolo.
class _RoleOption extends StatelessWidget {
  const _RoleOption({
    required this.role,
    required this.label,
    required this.description,
    required this.icon,
    required this.isSelected,
    required this.onTap,
  });

  final String role;
  final String label;
  final String description;
  final IconData icon;
  final bool isSelected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
          border: Border.all(
            color: isSelected ? colorScheme.primary : colorScheme.outline,
            width: isSelected ? 2 : 1,
          ),
          color: isSelected
              ? colorScheme.primaryContainer.withOpacity(0.3)
              : null,
        ),
        child: Row(
          children: [
            Icon(
              icon,
              color: isSelected
                  ? colorScheme.primary
                  : colorScheme.onSurfaceVariant,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    label,
                    style: Theme.of(context).textTheme.titleSmall?.copyWith(
                      color: isSelected ? colorScheme.primary : null,
                      fontWeight: isSelected ? FontWeight.w600 : null,
                    ),
                  ),
                  Text(
                    description,
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: colorScheme.onSurfaceVariant,
                    ),
                  ),
                ],
              ),
            ),
            if (isSelected)
              Icon(Icons.check_circle, color: colorScheme.primary),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/business/presentation/dialogs/role_selection_dialog.dart ---
import 'package:flutter/material.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/widgets/app_dialogs.dart';

/// Dialog per selezionare un ruolo (desktop).
class RoleSelectionDialog extends StatefulWidget {
  const RoleSelectionDialog({
    super.key,
    required this.currentRole,
    required this.userName,
    required this.onRoleSelected,
  });

  final String currentRole;
  final String userName;
  final ValueChanged<String> onRoleSelected;

  @override
  State<RoleSelectionDialog> createState() => _RoleSelectionDialogState();
}

class _RoleSelectionDialogState extends State<RoleSelectionDialog> {
  late String _selectedRole;

  @override
  void initState() {
    super.initState();
    _selectedRole = widget.currentRole;
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;

    return AppFormDialog(
      title: Text(l10n.operatorsEditRole),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            'Modifica il ruolo di ${widget.userName}',
            style: Theme.of(context).textTheme.bodyMedium?.copyWith(
              color: Theme.of(context).colorScheme.onSurfaceVariant,
            ),
          ),
          const SizedBox(height: 24),
          _RoleRadioList(
            selectedRole: _selectedRole,
            onChanged: (role) => setState(() => _selectedRole = role),
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: Text(l10n.actionCancel),
        ),
        FilledButton(
          onPressed: () => widget.onRoleSelected(_selectedRole),
          child: Text(l10n.actionSave),
        ),
      ],
    );
  }
}

/// Bottom sheet per selezionare un ruolo (mobile/tablet).
class RoleSelectionSheet extends StatefulWidget {
  const RoleSelectionSheet({
    super.key,
    required this.currentRole,
    required this.userName,
    required this.onRoleSelected,
  });

  final String currentRole;
  final String userName;
  final ValueChanged<String> onRoleSelected;

  @override
  State<RoleSelectionSheet> createState() => _RoleSelectionSheetState();
}

class _RoleSelectionSheetState extends State<RoleSelectionSheet> {
  late String _selectedRole;

  @override
  void initState() {
    super.initState();
    _selectedRole = widget.currentRole;
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Header
        Text(
          l10n.operatorsEditRole,
          style: Theme.of(context).textTheme.titleLarge,
        ),
        const SizedBox(height: 4),
        Text(
          'Modifica il ruolo di ${widget.userName}',
          style: Theme.of(context).textTheme.bodySmall?.copyWith(
            color: Theme.of(context).colorScheme.onSurfaceVariant,
          ),
        ),
        const SizedBox(height: 24),

        // Role options
        _RoleRadioList(
          selectedRole: _selectedRole,
          onChanged: (role) => setState(() => _selectedRole = role),
        ),

        // Actions
        const SizedBox(height: 24),
        Row(
          children: [
            Expanded(
              child: OutlinedButton(
                onPressed: () => Navigator.of(context).pop(),
                child: Text(l10n.actionCancel),
              ),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: FilledButton(
                onPressed: () => widget.onRoleSelected(_selectedRole),
                child: Text(l10n.actionSave),
              ),
            ),
          ],
        ),
      ],
    );
  }
}

/// Lista di radio button per la selezione del ruolo.
class _RoleRadioList extends StatelessWidget {
  const _RoleRadioList({required this.selectedRole, required this.onChanged});

  final String selectedRole;
  final ValueChanged<String> onChanged;

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;

    return Column(
      children: [
        _RoleRadioTile(
          value: 'admin',
          groupValue: selectedRole,
          onChanged: onChanged,
          title: l10n.operatorsRoleAdmin,
          subtitle: 'Accesso completo, pu√≤ gestire operatori',
          icon: Icons.admin_panel_settings,
        ),
        _RoleRadioTile(
          value: 'manager',
          groupValue: selectedRole,
          onChanged: onChanged,
          title: l10n.operatorsRoleManager,
          subtitle: 'Gestisce agenda e clienti',
          icon: Icons.manage_accounts,
        ),
        _RoleRadioTile(
          value: 'staff',
          groupValue: selectedRole,
          onChanged: onChanged,
          title: l10n.operatorsRoleStaff,
          subtitle: 'Visualizza e gestisce solo i propri appuntamenti',
          icon: Icons.person,
        ),
      ],
    );
  }
}

/// Singola riga radio per ruolo.
class _RoleRadioTile extends StatelessWidget {
  const _RoleRadioTile({
    required this.value,
    required this.groupValue,
    required this.onChanged,
    required this.title,
    required this.subtitle,
    required this.icon,
  });

  final String value;
  final String groupValue;
  final ValueChanged<String> onChanged;
  final String title;
  final String subtitle;
  final IconData icon;

  @override
  Widget build(BuildContext context) {
    final isSelected = value == groupValue;
    final colorScheme = Theme.of(context).colorScheme;

    return InkWell(
      onTap: () => onChanged(value),
      borderRadius: BorderRadius.circular(8),
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 8),
        child: Row(
          children: [
            Radio<String>(
              value: value,
              groupValue: groupValue,
              onChanged: (v) => onChanged(v!),
            ),
            Icon(
              icon,
              color: isSelected
                  ? colorScheme.primary
                  : colorScheme.onSurfaceVariant,
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    title,
                    style: Theme.of(context).textTheme.titleSmall?.copyWith(
                      fontWeight: isSelected ? FontWeight.w600 : null,
                    ),
                  ),
                  Text(
                    subtitle,
                    style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: colorScheme.onSurfaceVariant,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/business/presentation/dialogs/edit_business_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/business.dart';
import '../../../../core/network/api_client.dart';
import '../../providers/business_providers.dart';

/// Dialog per modificare un business esistente (solo superadmin).
class EditBusinessDialog extends ConsumerStatefulWidget {
  const EditBusinessDialog({super.key, required this.business});

  final Business business;

  @override
  ConsumerState<EditBusinessDialog> createState() => _EditBusinessDialogState();
}

class _EditBusinessDialogState extends ConsumerState<EditBusinessDialog> {
  final _formKey = GlobalKey<FormState>();
  late final TextEditingController _nameController;
  late final TextEditingController _slugController;
  late final TextEditingController _emailController;
  late final TextEditingController _phoneController;
  late final TextEditingController _adminEmailController;

  bool _isLoading = false;
  String? _error;

  @override
  void initState() {
    super.initState();
    _nameController = TextEditingController(text: widget.business.name);
    _slugController = TextEditingController(text: widget.business.slug ?? '');
    _emailController = TextEditingController(text: widget.business.email ?? '');
    _phoneController = TextEditingController(text: widget.business.phone ?? '');
    _adminEmailController = TextEditingController(
      text: widget.business.adminEmail ?? '',
    );
  }

  @override
  void dispose() {
    _nameController.dispose();
    _slugController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    _adminEmailController.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      final repository = ref.read(businessRepositoryProvider);

      // Determina se admin email √® cambiata
      final newAdminEmail = _adminEmailController.text.trim();
      final oldAdminEmail = widget.business.adminEmail ?? '';
      final adminEmailChanged =
          newAdminEmail.isNotEmpty &&
          newAdminEmail.toLowerCase() != oldAdminEmail.toLowerCase();

      await repository.updateBusiness(
        businessId: widget.business.id,
        name: _nameController.text.trim(),
        slug: _slugController.text.trim(),
        email: _emailController.text.trim().isEmpty
            ? null
            : _emailController.text.trim(),
        phone: _phoneController.text.trim().isEmpty
            ? null
            : _phoneController.text.trim(),
        adminEmail: adminEmailChanged ? newAdminEmail : null,
      );

      if (mounted) {
        Navigator.of(context).pop(true);
      }
    } on ApiException catch (e) {
      setState(() {
        _error = e.message;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return AlertDialog(
      title: const Text('Modifica Business'),
      content: SizedBox(
        width: 400,
        child: Form(
          key: _formKey,
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                if (_error != null) ...[
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: colorScheme.errorContainer,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Row(
                      children: [
                        Icon(
                          Icons.error_outline,
                          color: colorScheme.onErrorContainer,
                          size: 20,
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            _error!,
                            style: TextStyle(
                              color: colorScheme.onErrorContainer,
                            ),
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 16),
                ],

                // Nome business
                TextFormField(
                  controller: _nameController,
                  decoration: const InputDecoration(
                    labelText: 'Nome Business *',
                    hintText: 'es. Salone Maria',
                    prefixIcon: Icon(Icons.business),
                  ),
                  textCapitalization: TextCapitalization.words,
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return l10n.authRequiredField;
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // Slug
                TextFormField(
                  controller: _slugController,
                  decoration: const InputDecoration(
                    labelText: 'Slug URL *',
                    hintText: 'es. salone-maria',
                    prefixIcon: Icon(Icons.link),
                    helperText: 'Usato per URL pubblico',
                  ),
                  validator: (value) {
                    if (value == null || value.trim().isEmpty) {
                      return l10n.authRequiredField;
                    }
                    // Validate slug format
                    final slugRegex = RegExp(r'^[a-z0-9-]+$');
                    if (!slugRegex.hasMatch(value.trim())) {
                      return 'Solo lettere minuscole, numeri e trattini';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // Email
                TextFormField(
                  controller: _emailController,
                  decoration: const InputDecoration(
                    labelText: 'Email',
                    hintText: 'es. info@salone.it',
                    prefixIcon: Icon(Icons.email_outlined),
                  ),
                  keyboardType: TextInputType.emailAddress,
                  validator: (value) {
                    if (value != null && value.trim().isNotEmpty) {
                      final emailRegex = RegExp(
                        r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                      );
                      if (!emailRegex.hasMatch(value.trim())) {
                        return l10n.authInvalidEmail;
                      }
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // Telefono
                TextFormField(
                  controller: _phoneController,
                  decoration: const InputDecoration(
                    labelText: 'Telefono',
                    hintText: 'es. +39 333 1234567',
                    prefixIcon: Icon(Icons.phone_outlined),
                  ),
                  keyboardType: TextInputType.phone,
                ),
                const SizedBox(height: 24),

                // Divider e sezione admin
                const Divider(),
                const SizedBox(height: 8),
                Text(
                  'Amministratore',
                  style: theme.textTheme.titleSmall?.copyWith(
                    color: colorScheme.primary,
                  ),
                ),
                const SizedBox(height: 8),
                Text(
                  'Cambiando l\'email admin, verr√† inviato un invito al nuovo amministratore.',
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: colorScheme.onSurfaceVariant,
                  ),
                ),
                const SizedBox(height: 12),

                // Email Admin (opzionale)
                TextFormField(
                  controller: _adminEmailController,
                  decoration: InputDecoration(
                    labelText: 'Email Admin',
                    hintText: 'es. admin@salone.it',
                    prefixIcon: const Icon(Icons.admin_panel_settings),
                    helperText: widget.business.adminEmail != null
                        ? 'Attuale: ${widget.business.adminEmail}'
                        : 'Opzionale: ricever√† email per configurare account',
                  ),
                  keyboardType: TextInputType.emailAddress,
                  validator: (value) {
                    // Solo valida se inserito
                    if (value != null && value.trim().isNotEmpty) {
                      final emailRegex = RegExp(
                        r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$',
                      );
                      if (!emailRegex.hasMatch(value.trim())) {
                        return l10n.authInvalidEmail;
                      }
                    }
                    return null;
                  },
                ),
              ],
            ),
          ),
        ),
      ),
      actions: [
        TextButton(
          onPressed: _isLoading ? null : () => Navigator.of(context).pop(false),
          child: Text(l10n.actionCancel),
        ),
        FilledButton(
          onPressed: _isLoading ? null : _submit,
          child: _isLoading
              ? const SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(strokeWidth: 2),
                )
              : const Text('Salva'),
        ),
      ],
    );
  }
}

/// Mostra il dialog per modificare un business.
/// Ritorna `true` se il business √® stato modificato, `false` altrimenti.
Future<bool?> showEditBusinessDialog(BuildContext context, Business business) {
  return showDialog<bool>(
    context: context,
    builder: (context) => EditBusinessDialog(business: business),
  );
}
--- FILE: lib/features/agenda/providers/dragged_appointment_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Tiene traccia dell‚Äôappuntamento attualmente trascinato.
/// Nessun delay: il fantasma scompare subito al rilascio.
class DraggedAppointmentIdNotifier extends Notifier<int?> {
  @override
  int? build() => null;

  /// Imposta l'ID dell'appuntamento trascinato
  void set(int id) => state = id;

  /// Cancella immediatamente il fantasma
  void clear() => state = null;
}

final draggedAppointmentIdProvider =
    NotifierProvider<DraggedAppointmentIdNotifier, int?>(
      DraggedAppointmentIdNotifier.new,
    );
--- FILE: lib/features/agenda/providers/layout_config_provider.dart ---
import 'dart:async';
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../domain/config/agenda_theme.dart';
import '../domain/config/layout_config.dart';

part 'layout_config_provider.g.dart';

/// Mantiene aggiornata la configurazione del layout agenda (slot/header/hour column).
@riverpod
class LayoutConfigNotifier extends _$LayoutConfigNotifier {
  Timer? _resizeDebounce;

  @override
  LayoutConfig build() {
    ref.onDispose(() {
      _resizeDebounce?.cancel();
    });
    final dispatcher = WidgetsBinding.instance.platformDispatcher;
    final view = dispatcher.implicitView;
    final logicalSize = view != null
        ? Size(
            view.physicalSize.width / view.devicePixelRatio,
            view.physicalSize.height / view.devicePixelRatio,
          )
        : ui.window.physicalSize / ui.window.devicePixelRatio;

    final initialHeaderHeight = logicalSize.width > 0
        ? LayoutConfig.headerHeightForWidth(logicalSize.width)
        : LayoutConfig.defaultHeaderHeight;
    final initialSlotHeight = logicalSize.height > 0
        ? _deriveSlotHeight(logicalSize.height)
        : LayoutConfig.defaultSlotHeight;
    final initialHourWidth = _initialHourColumnWidth();

    return LayoutConfig.initial.copyWith(
      headerHeight: initialHeaderHeight,
      slotHeight: initialSlotHeight,
      hourColumnWidth: initialHourWidth,
    );
  }

  /// Aggiorna dinamicamente l‚Äôaltezza degli slot e dell‚Äôheader
  /// in base alle dimensioni della finestra.
  void updateFromContext(BuildContext context) {
    _resizeDebounce?.cancel();

    final size = MediaQuery.of(context).size;
    final screenWidth = size.width;
    final screenHeight = size.height;

    _resizeDebounce = Timer(const Duration(milliseconds: 100), () {
      final next = state.copyWith(
        slotHeight: _deriveSlotHeight(screenHeight),
        headerHeight: _deriveHeaderHeight(screenWidth),
        hourColumnWidth: _deriveHourColumnWidth(context),
      );

      if (next != state) {
        state = next;
      }
    });
  }

  double _deriveSlotHeight(double screenHeight) {
    if (screenHeight < 700) {
      return LayoutConfig.defaultSlotHeight * 0.8;
    }
    if (screenHeight > 1200) {
      return LayoutConfig.defaultSlotHeight * 1.2;
    }
    return LayoutConfig.defaultSlotHeight;
  }

  double _deriveHeaderHeight(double screenWidth) =>
      LayoutConfig.headerHeightForWidth(screenWidth);

  double _initialHourColumnWidth() {
    const textDirection = TextDirection.ltr;
    const style = AgendaTheme.hourTextStyle;
    return _computeHourColumnWidth(style, textDirection);
  }

  double _deriveHourColumnWidth(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final style = textTheme.bodyMedium ?? AgendaTheme.hourTextStyle;
    final textDirection = Directionality.maybeOf(context) ?? TextDirection.ltr;

    return _computeHourColumnWidth(style, textDirection);
  }

  double _computeHourColumnWidth(TextStyle style, TextDirection textDirection) {
    final painter = TextPainter(
      text: TextSpan(text: '23:59', style: style),
      textDirection: textDirection,
      maxLines: 1,
    )..layout();

    final baseWidth = painter.width;
    const extraPadding = LayoutConfig.horizontalPadding;
    const safety = 6.0; // margine ridotto oltre il testo

    final computed = baseWidth + extraPadding + safety;
    return computed.clamp(48.0, 80.0);
  }

  /// Aggiorna i minuti per slot in base alla scelta utente.
  void setMinutesPerSlot(int minutes) {
    if (!LayoutConfig.isValidSlotDuration(minutes)) {
      return;
    }

    if (state.minutesPerSlot == minutes) {
      return;
    }

    state = state.copyWith(minutesPerSlot: minutes);
  }

  /// Permette di scegliere se usare la larghezza uniforme sul picco di overlap.
  void setUseClusterMaxConcurrency(bool enabled) {
    if (state.useClusterMaxConcurrency == enabled) {
      return;
    }
    state = state.copyWith(useClusterMaxConcurrency: enabled);
  }

  /// Permette di scegliere se usare il colore del servizio per le card.
  void setUseServiceColors(bool enabled) {
    if (state.useServiceColorsForAppointments == enabled) {
      return;
    }
    state = state.copyWith(useServiceColorsForAppointments: enabled);
  }

  /// Permette di mostrare la label del pulsante "Aggiungi" in topbar.
  void setShowTopbarAddLabel(bool enabled) {
    if (state.showTopbarAddLabel == enabled) {
      return;
    }
    state = state.copyWith(showTopbarAddLabel: enabled);
  }
}
--- FILE: lib/features/agenda/providers/highlighted_staff_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Tiene traccia dello staff evidenziato durante il drag
class HighlightedStaffIdNotifier extends Notifier<int?> {
  @override
  int? build() => null;

  void set(int? id) => state = id;
  void clear() => state = null;
}

final highlightedStaffIdProvider =
    NotifierProvider<HighlightedStaffIdNotifier, int?>(
      HighlightedStaffIdNotifier.new,
    );
--- FILE: lib/features/agenda/providers/dragged_last_staff_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Tiene traccia dell'ultima colonna staff attraversata durante il drag.
class DraggedLastStaffNotifier extends Notifier<int?> {
  @override
  int? build() => null;

  void set(int staffId) => state = staffId;
  void clear() => state = null;
}

final draggedLastStaffIdProvider =
    NotifierProvider<DraggedLastStaffNotifier, int?>(
      DraggedLastStaffNotifier.new,
    );
--- FILE: lib/features/agenda/providers/drag_offset_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Distanza verticale (in px) tra il punto di presa e il bordo superiore della card
class DragOffsetNotifier extends Notifier<double?> {
  @override
  double? build() => null;

  void set(double value) => state = value;
  void clear() => state = null;
}

final dragOffsetProvider = NotifierProvider<DragOffsetNotifier, double?>(
  DragOffsetNotifier.new,
);

/// üîπ Distanza orizzontale (in px) tra il punto di presa e il bordo sinistro della card
class DragOffsetXNotifier extends Notifier<double?> {
  @override
  double? build() => null;

  void set(double value) => state = value;
  void clear() => state = null;
}

final dragOffsetXProvider = NotifierProvider<DragOffsetXNotifier, double?>(
  DragOffsetXNotifier.new,
);
--- FILE: lib/features/agenda/providers/layout_config_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'layout_config_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning
/// Mantiene aggiornata la configurazione del layout agenda (slot/header/hour column).

@ProviderFor(LayoutConfigNotifier)
const layoutConfigProvider = LayoutConfigNotifierProvider._();

/// Mantiene aggiornata la configurazione del layout agenda (slot/header/hour column).
final class LayoutConfigNotifierProvider
    extends $NotifierProvider<LayoutConfigNotifier, LayoutConfig> {
  /// Mantiene aggiornata la configurazione del layout agenda (slot/header/hour column).
  const LayoutConfigNotifierProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'layoutConfigProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$layoutConfigNotifierHash();

  @$internal
  @override
  LayoutConfigNotifier create() => LayoutConfigNotifier();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(LayoutConfig value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<LayoutConfig>(value),
    );
  }
}

String _$layoutConfigNotifierHash() =>
    r'a50c2234a17993d2106f79a9dcb393e753f97c9b';

/// Mantiene aggiornata la configurazione del layout agenda (slot/header/hour column).

abstract class _$LayoutConfigNotifier extends $Notifier<LayoutConfig> {
  LayoutConfig build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<LayoutConfig, LayoutConfig>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<LayoutConfig, LayoutConfig>,
              LayoutConfig,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/features/agenda/providers/dragged_card_size_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Tiene la dimensione (Size) della card attualmente trascinata.
/// Serve per calcolare correttamente la percentuale di overlap orizzontale.
class DraggedCardSizeNotifier extends Notifier<Size?> {
  @override
  Size? build() => null;

  void set(Size size) => state = size;
  void clear() => state = null;
}

final draggedCardSizeProvider =
    NotifierProvider<DraggedCardSizeNotifier, Size?>(
      DraggedCardSizeNotifier.new,
    );
--- FILE: lib/features/agenda/providers/drag_session_provider.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

@immutable
class DragSessionState {
  const DragSessionState({
    this.id,
    this.dropHandled = false,
  });

  final int? id;
  final bool dropHandled;

  DragSessionState copyWith({
    int? id,
    bool? dropHandled,
  }) {
    return DragSessionState(
      id: id ?? this.id,
      dropHandled: dropHandled ?? this.dropHandled,
    );
  }
}

class DragSessionNotifier extends Notifier<DragSessionState> {
  int _counter = 0;

  @override
  DragSessionState build() => const DragSessionState();

  int start() {
    final id = ++_counter;
    state = DragSessionState(id: id, dropHandled: false);
    return id;
  }

  void markHandled() {
    if (state.id == null) return;
    state = state.copyWith(dropHandled: true);
  }

  void clear() {
    state = const DragSessionState();
  }
}

final dragSessionProvider =
    NotifierProvider<DragSessionNotifier, DragSessionState>(
  DragSessionNotifier.new,
);
--- FILE: lib/features/agenda/providers/location_providers.dart ---
import 'package:agenda_backend/core/services/preferences_service.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/location.dart';
import '../../../core/network/network_providers.dart';
import '../../agenda/providers/business_providers.dart';
import '../../auth/providers/auth_provider.dart';
import '../../business/presentation/business_list_screen.dart';
import '../../business/providers/locations_providers.dart';

///
/// üîπ ELENCO LOCATIONS (da API)
///
class LocationsNotifier extends Notifier<List<Location>> {
  @override
  List<Location> build() {
    // Ascolta i cambiamenti dell'auth state
    final authState = ref.watch(authProvider);

    // Non caricare se non autenticato
    if (!authState.isAuthenticated) {
      return [];
    }

    // Per superadmin: carica solo se ha selezionato un business
    if (authState.user?.isSuperadmin ?? false) {
      final selectedBusiness = ref.watch(superadminSelectedBusinessProvider);
      if (selectedBusiness == null) {
        // Superadmin nella lista business, non caricare locations
        return [];
      }
    }

    // Verifica che ci sia un business ID valido (> 0) prima di caricare
    final businessId = ref.watch(currentBusinessIdProvider);
    if (businessId <= 0) {
      // Business non ancora caricato, aspetta
      return [];
    }

    // Carica locations per utente normale o superadmin con business selezionato
    _loadLocations();
    return []; // Stato iniziale vuoto
  }

  Future<void> _loadLocations() async {
    // Verifica autenticazione prima di chiamare API
    final authState = ref.read(authProvider);
    if (!authState.isAuthenticated) {
      return;
    }

    try {
      final business = ref.read(currentBusinessProvider);
      final repository = ref.read(locationsRepositoryProvider);
      final locations = await repository.getByBusinessId(business.id);
      // Filtra solo le location attive
      final activeLocations = locations.where((l) => l.isActive).toList();
      state = activeLocations;
    } catch (_) {
      // In caso di errore, mantieni lo stato vuoto
      state = [];
    }
  }

  /// Ricarica le locations dall'API
  Future<void> refresh() async {
    await _loadLocations();
  }

  /// Crea una nuova location tramite API
  Future<Location> create({
    required String name,
    String? address,
    String? phone,
    String? email,
    String? timezone,
    bool? isActive,
  }) async {
    final business = ref.read(currentBusinessProvider);
    final repository = ref.read(locationsRepositoryProvider);
    final location = await repository.create(
      businessId: business.id,
      name: name,
      address: address,
      phone: phone,
      email: email,
      timezone: timezone,
      isActive: isActive,
    );
    state = [...state, location];
    return location;
  }

  /// Aggiorna una location esistente tramite API
  Future<Location> updateLocation({
    required int locationId,
    String? name,
    String? address,
    String? phone,
    String? email,
    String? timezone,
    bool? isActive,
  }) async {
    final repository = ref.read(locationsRepositoryProvider);
    final updated = await repository.update(
      locationId: locationId,
      name: name,
      address: address,
      phone: phone,
      email: email,
      timezone: timezone,
      isActive: isActive,
    );
    state = [
      for (final l in state)
        if (l.id == updated.id) updated else l,
    ];
    return updated;
  }

  /// Elimina una location tramite API
  /// [currentLocationId] deve essere passato dal chiamante per evitare dipendenza circolare
  Future<void> deleteLocation(int id, {required int currentLocationId}) async {
    final repository = ref.read(locationsRepositoryProvider);

    await repository.delete(id);

    final filtered = state.where((l) => l.id != id).toList();
    state = filtered;

    // Se era la location corrente, passa alla prima disponibile
    if (filtered.isNotEmpty && currentLocationId == id) {
      ref.read(currentLocationIdProvider.notifier).set(filtered.first.id);
    }
  }

  // === Metodi locali per UI (senza API) ===

  void add(Location location) {
    state = [...state, location];
  }

  void updateItem(Location updated) {
    state = [
      for (final l in state)
        if (l.id == updated.id) updated else l,
    ];
  }

  void delete(int id, {int? currentLocationId}) {
    final filtered = state.where((l) => l.id != id).toList();
    state = filtered;
    if (filtered.isEmpty) return;
    // Se era la location corrente, passa alla prima disponibile
    if (currentLocationId != null && currentLocationId == id) {
      ref.read(currentLocationIdProvider.notifier).set(filtered.first.id);
    }
  }

  Future<void> reorder(int oldIndex, int newIndex) async {
    if (newIndex > oldIndex) newIndex -= 1;
    final list = [...state];
    final item = list.removeAt(oldIndex);
    list.insert(newIndex, item);

    // Aggiorna sortOrder locale
    final reordered = <Location>[];
    for (int i = 0; i < list.length; i++) {
      reordered.add(list[i].copyWith(sortOrder: i));
    }
    state = reordered;

    // Persist to API
    await _persistLocationsOrder(reordered);
  }

  /// Persiste l'ordine delle locations via API
  Future<void> _persistLocationsOrder(List<Location> locations) async {
    try {
      final apiClient = ref.read(apiClientProvider);
      await apiClient.reorderLocations(
        locations: locations
            .map((l) => {'id': l.id, 'sort_order': l.sortOrder})
            .toList(),
      );
    } catch (_) {
      // Ignora errore - utente pu√≤ riprovare
    }
  }

  int nextId() {
    if (state.isEmpty) return 1;
    final maxId = state.map((l) => l.id).reduce((a, b) => a > b ? a : b);
    return maxId + 1;
  }
}

final locationsProvider = NotifierProvider<LocationsNotifier, List<Location>>(
  LocationsNotifier.new,
);

///
/// üîπ LOCATION CORRENTE
///
class CurrentLocationId extends Notifier<int> {
  @override
  int build() {
    final businessId = ref.watch(currentBusinessIdProvider);

    // Aspetta che locationsProvider carichi i dati
    ref.listen(locationsProvider, (previous, next) {
      if (next.isNotEmpty && state == 0) {
        // Carica da preferenze salvate (solo quando abbiamo businessId valido)
        int? savedId;
        if (businessId > 0) {
          final prefs = ref.read(preferencesServiceProvider);
          savedId = prefs.getCurrentLocationId(businessId);
        }

        // Se c'√® una preferenza salvata e la location esiste ancora, usala
        if (savedId != null && next.any((l) => l.id == savedId)) {
          state = savedId;
        } else {
          // Altrimenti usa la location di default
          final defaultLocation = next.firstWhere(
            (l) => l.isDefault,
            orElse: () => next.first,
          );
          state = defaultLocation.id;

          // Se c'era un savedId non valido, aggiorna le preferenze
          if (savedId != null && businessId > 0) {
            ref
                .read(preferencesServiceProvider)
                .setCurrentLocationId(businessId, state);
          }
        }
      }
    });
    return 0; // Inizializza a 0 per triggare il listen
  }

  void set(int id) {
    state = id;
    // Salva in preferenze
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId > 0) {
      ref.read(preferencesServiceProvider).setCurrentLocationId(businessId, id);
    }
  }
}

final currentLocationIdProvider = NotifierProvider<CurrentLocationId, int>(
  CurrentLocationId.new,
);

final currentLocationProvider = Provider<Location>((ref) {
  final locations = ref.watch(locationsProvider);
  final currentId = ref.watch(currentLocationIdProvider);

  if (locations.isEmpty || currentId == 0) {
    // Ritorna location placeholder mentre carica
    return Location(
      id: 0,
      businessId: 0,
      name: 'Loading...',
      isDefault: false,
      isActive: true,
    );
  }

  return locations.firstWhere(
    (l) => l.id == currentId,
    orElse: () => locations.first,
  );
});

///
/// üîπ VALUTA EFFETTIVA DELLA LOCATION CORRENTE
///
/// Se la location ha una valuta specifica, viene usata.
/// Altrimenti eredita quella del business.
///
final effectiveCurrencyProvider = Provider<String>((ref) {
  final location = ref.watch(currentLocationProvider);
  final business = ref.watch(currentBusinessProvider);
  return location.currency ?? business.currency;
});
--- FILE: lib/features/agenda/providers/business_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/business.dart';
import '../../auth/providers/auth_provider.dart';
import '../../business/providers/business_providers.dart';

/// Notifier per forzare il refresh della lista business
class BusinessesRefreshNotifier extends Notifier<int> {
  @override
  int build() => 0;

  void refresh() => state++;
}

final businessesRefreshProvider =
    NotifierProvider<BusinessesRefreshNotifier, int>(
      BusinessesRefreshNotifier.new,
    );

///
/// üîπ ELENCO BUSINESS (da API)
/// Se l'utente √® superadmin, usa endpoint admin.
///
final businessesProvider = FutureProvider<List<Business>>((ref) async {
  // Watch del refresh provider per forzare il ricaricamento
  ref.watch(businessesRefreshProvider);

  final authState = ref.watch(authProvider);

  // ‚ö†Ô∏è Non fare chiamate API se l'utente non √® autenticato
  if (!authState.isAuthenticated) {
    return [];
  }

  final repository = ref.watch(businessRepositoryProvider);

  if (authState.user?.isSuperadmin ?? false) {
    return repository.getAllAdmin();
  }
  return repository.getAll();
});

///
/// üîπ BUSINESS CORRENTE (ID)
///
class CurrentBusinessId extends Notifier<int> {
  @override
  int build() {
    // ‚úÖ Imposta come default il primo business disponibile
    // Aspetta che businessesProvider carichi i dati
    ref.listen(businessesProvider, (previous, next) {
      next.whenData((businesses) {
        if (businesses.isNotEmpty && state == 0) {
          state = businesses.first.id;
        }
      });
    });
    return 0; // Inizializza a 0 per triggare il listen
  }

  void set(int id) => state = id;
}

final currentBusinessIdProvider = NotifierProvider<CurrentBusinessId, int>(
  CurrentBusinessId.new,
);

///
/// üîπ BUSINESS CORRENTE (oggetto)
///
final currentBusinessProvider = Provider<Business>((ref) {
  final businessesAsync = ref.watch(businessesProvider);
  final currentId = ref.watch(currentBusinessIdProvider);

  return businessesAsync.when(
    data: (businesses) => businesses.firstWhere(
      (b) => b.id == currentId,
      orElse: () => businesses.first,
    ),
    loading: () =>
        Business(id: currentId, name: 'Loading...', createdAt: DateTime.now()),
    error: (_, __) =>
        Business(id: currentId, name: 'Error', createdAt: DateTime.now()),
  );
});
--- FILE: lib/features/agenda/providers/appointment_providers.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';

import '../../../core/models/appointment.dart';
import '../../auth/providers/auth_provider.dart';
import '../../clients/providers/clients_providers.dart';
import '../../services/providers/services_provider.dart';
import 'bookings_provider.dart';
import 'bookings_repository_provider.dart';
import 'business_providers.dart';
import 'date_range_provider.dart';
import 'location_providers.dart';

/// Arrotonda un DateTime ai 5 minuti pi√π vicini.
/// Es: 10:12 ‚Üí 10:10, 10:13 ‚Üí 10:15
DateTime _roundToNearestFiveMinutes(DateTime dt) {
  final minutes = dt.minute;
  final roundedMinutes = ((minutes + 2) ~/ 5) * 5;
  return DateTime(
    dt.year,
    dt.month,
    dt.day,
    dt.hour,
    0,
  ).add(Duration(minutes: roundedMinutes));
}

class AppointmentsNotifier extends AsyncNotifier<List<Appointment>> {
  @override
  Future<List<Appointment>> build() async {
    // Verifica autenticazione
    final authState = ref.watch(authProvider);
    if (!authState.isAuthenticated) {
      return [];
    }

    final repository = ref.watch(bookingsRepositoryProvider);
    final location = ref.watch(currentLocationProvider);
    final business = ref.watch(currentBusinessProvider);
    final date = ref.watch(agendaDateProvider);

    if (location.id <= 0) {
      return [];
    }

    final appointments = await repository.getAppointments(
      locationId: location.id,
      businessId: business.id,
      date: date,
    );
    return appointments;
  }

  /// Restituisce gli appointments associati a un booking specifico,
  /// ordinati per orario di inizio.
  List<Appointment> getByBookingId(int bookingId) {
    final currentList = state.value ?? [];
    return currentList.where((a) => a.bookingId == bookingId).toList()
      ..sort((a, b) => a.startTime.compareTo(b.startTime));
  }

  void moveAppointment({
    required int appointmentId,
    required int newStaffId,
    required DateTime newStart,
    required DateTime newEnd,
  }) async {
    final currentList = state.value;
    if (currentList == null) return;

    // Trova l'appointment originale per calcolare extra blocked
    final originalAppt = currentList.firstWhere(
      (a) => a.id == appointmentId,
      orElse: () => throw Exception('Appointment not found'),
    );

    // Arrotonda gli orari a multipli di 5 minuti
    final roundedStart = _roundToNearestFiveMinutes(newStart);
    final duration = newEnd.difference(newStart);
    final roundedEnd = roundedStart.add(duration);

    // Calcola extra blocked minutes
    final oldTotalMinutes = originalAppt.endTime
        .difference(originalAppt.startTime)
        .inMinutes;
    final newTotalMinutes = roundedEnd.difference(roundedStart).inMinutes;
    final oldBlocked = originalAppt.blockedExtraMinutes;
    final baseMinutes = oldTotalMinutes - oldBlocked;

    int newBlocked = oldBlocked;
    if (newTotalMinutes <= baseMinutes) {
      newBlocked = 0;
    } else {
      newBlocked = newTotalMinutes - baseMinutes;
    }

    final newList = [
      for (final appt in currentList)
        if (appt.id == appointmentId)
          _applyResizeToAppointment(
            appt,
            staffId: newStaffId,
            startTime: roundedStart,
            endTime: roundedEnd,
          )
        else
          appt,
    ];

    state = AsyncData(newList);

    // API update: chiama l'API per reschedule appointment
    final location = ref.read(currentLocationProvider);
    final repository = ref.read(bookingsRepositoryProvider);

    try {
      await repository.updateAppointment(
        locationId: location.id,
        appointmentId: appointmentId,
        startTime: roundedStart,
        endTime: roundedEnd,
        staffId: newStaffId,
        extraBlockedMinutes: newBlocked,
      );
    } catch (_) {
      // Rollback on error
      state = AsyncData(currentList);
    }
  }

  Appointment _applyResizeToAppointment(
    Appointment appt, {
    required int staffId,
    required DateTime startTime,
    required DateTime endTime,
  }) {
    final oldTotalMinutes = appt.endTime.difference(appt.startTime).inMinutes;
    final newTotalMinutes = endTime.difference(startTime).inMinutes;
    final oldBlocked = appt.blockedExtraMinutes;
    final baseMinutes = oldTotalMinutes - oldBlocked;

    int newBlocked = oldBlocked;
    if (newTotalMinutes <= baseMinutes) {
      newBlocked = 0;
    } else {
      newBlocked = newTotalMinutes - baseMinutes;
    }

    final processingMinutes = appt.processingExtraMinutes;
    final extraMinutesType = newBlocked > 0
        ? ExtraMinutesType.blocked
        : (processingMinutes > 0 ? ExtraMinutesType.processing : null);
    final extraMinutes = extraMinutesType == ExtraMinutesType.blocked
        ? newBlocked
        : (extraMinutesType == ExtraMinutesType.processing
              ? processingMinutes
              : null);

    return appt.copyWith(
      staffId: staffId,
      startTime: startTime,
      endTime: endTime,
      extraMinutes: extraMinutes,
      extraMinutesType: extraMinutesType,
      extraBlockedMinutes: newBlocked,
      extraProcessingMinutes: processingMinutes,
    );
  }

  /// Elimina un singolo appuntamento (booking_item).
  /// Usa deleteBookingItem per eliminare solo l'item, non l'intero booking.
  void deleteAppointment(int appointmentId) async {
    final currentList = state.value;
    if (currentList == null) return;

    int? relatedBookingId;
    for (final appt in currentList) {
      if (appt.id == appointmentId) {
        relatedBookingId = appt.bookingId;
        break;
      }
    }

    // Se non troviamo il booking, non possiamo eliminare
    if (relatedBookingId == null) {
      return;
    }

    final newList = [
      for (final appt in currentList)
        if (appt.id != appointmentId) appt,
    ];

    state = AsyncData(newList);

    // Aggiorna lo stato locale dei bookings se vuoto
    ref.read(bookingsProvider.notifier).removeIfEmpty(relatedBookingId);

    // API delete: elimina il singolo booking_item
    final repository = ref.read(bookingsRepositoryProvider);

    try {
      await repository.deleteBookingItem(
        bookingId: relatedBookingId,
        itemId: appointmentId,
      );
    } catch (_) {
      // Rollback on error
      state = AsyncData(currentList);
    }
  }

  /// Aggiunge un nuovo appuntamento chiamando l'API
  /// Se bookingId √® fornito, aggiunge un item a un booking esistente
  /// Altrimenti crea un nuovo booking
  Future<Appointment?> addAppointment({
    int? bookingId,
    required int staffId,
    required int serviceId,
    required int serviceVariantId,
    int? clientId,
    required String clientName,
    required String serviceName,
    required DateTime start,
    required DateTime end,
    double? price,
    int? extraMinutes,
    ExtraMinutesType? extraMinutesType,
    int? extraBlockedMinutes,
    int? extraProcessingMinutes,
  }) async {
    final location = ref.read(currentLocationProvider);
    final repository = ref.read(bookingsRepositoryProvider);

    // Arrotonda gli orari a multipli di 5 minuti
    final roundedStart = _roundToNearestFiveMinutes(start);
    final duration = end.difference(start);
    final roundedEnd = roundedStart.add(duration);

    try {
      // Se bookingId √® fornito, aggiungi un item al booking esistente
      if (bookingId != null) {
        final created = await repository.addBookingItem(
          bookingId: bookingId,
          businessId: location.businessId,
          locationId: location.id,
          staffId: staffId,
          serviceId: serviceId,
          serviceVariantId: serviceVariantId,
          startTime: roundedStart,
          endTime: roundedEnd,
          serviceNameSnapshot: serviceName,
          clientNameSnapshot: clientName,
          price: price,
          extraBlockedMinutes: extraBlockedMinutes,
          extraProcessingMinutes: extraProcessingMinutes,
        );

        // Aggiorna lo state locale con il nuovo appuntamento
        final currentList = state.value ?? [];
        state = AsyncData([...currentList, created]);

        return created;
      }

      // Altrimenti crea un nuovo booking
      final bookingResponse = await repository.createBooking(
        locationId: location.id,
        idempotencyKey: const Uuid().v4(),
        serviceIds: [serviceId], // Assuming single service for now
        startTime: roundedStart.toIso8601String(),
        staffId: staffId,
        clientId: clientId,
        notes: null,
      );

      // Refresh state to get the new appointment with correct ID
      ref.invalidateSelf();
      await future; // Wait for refresh

      // Try to find the newly created appointment
      // Since we don't know the ID, we can look for one that matches the bookingId from response
      final currentList = state.value ?? [];
      final created = currentList.firstWhere(
        (a) => a.bookingId == bookingResponse.id,
        orElse: () => throw Exception('Appointment not found after creation'),
      );

      // Ensure booking metadata exists locally (if needed, but API should handle it)
      ref
          .read(bookingsProvider.notifier)
          .ensureBooking(
            bookingId: bookingResponse.id,
            businessId: bookingResponse.businessId,
            locationId: bookingResponse.locationId,
            clientId: bookingResponse.clientId,
            clientName: bookingResponse.clientName ?? clientName,
          );

      return created;
    } catch (_) {
      return null;
    }
  }

  /// Aggiorna un appuntamento esistente (match per id)
  void updateAppointment(Appointment updated) async {
    final currentList = state.value;
    if (currentList == null) return;

    // Arrotonda gli orari a multipli di 5 minuti
    final roundedStart = _roundToNearestFiveMinutes(updated.startTime);
    final duration = updated.endTime.difference(updated.startTime);
    final roundedEnd = roundedStart.add(duration);
    final roundedAppointment = updated.copyWith(
      startTime: roundedStart,
      endTime: roundedEnd,
    );

    final newList = [
      for (final appt in currentList)
        if (appt.id == updated.id) roundedAppointment else appt,
    ];

    state = AsyncData(newList);

    // API update: chiama l'API per reschedule appointment
    final location = ref.read(currentLocationProvider);
    final repository = ref.read(bookingsRepositoryProvider);

    try {
      await repository.updateAppointment(
        locationId: location.id,
        appointmentId: updated.id,
        startTime: roundedStart,
        endTime: roundedEnd,
        staffId: updated.staffId,
        serviceId: updated.serviceId,
        serviceVariantId: updated.serviceVariantId,
        serviceNameSnapshot: updated.serviceName,
        clientId: updated.clientId,
        clientName: updated.clientName,
        clientNameSnapshot: updated.clientName,
        extraBlockedMinutes: updated.extraBlockedMinutes,
        extraProcessingMinutes: updated.extraProcessingMinutes,
      );
    } catch (_) {
      // Rollback on error
      state = AsyncData(currentList);
    }
  }

  /// Aggiorna il cliente di tutti gli appuntamenti di una prenotazione.
  /// Chiama l'API per persistere la modifica del client_id nel booking.
  Future<void> updateClientForBooking({
    required int bookingId,
    required int? clientId,
    required String clientName,
  }) async {
    final currentList = state.value;
    if (currentList == null) return;

    // Aggiornamento locale immediato per la UI
    final newList = [
      for (final appt in currentList)
        if (appt.bookingId == bookingId)
          appt.copyWith(clientId: clientId, clientName: clientName)
        else
          appt,
    ];

    state = AsyncData(newList);

    // Chiama API per persistere la modifica
    try {
      final repository = ref.read(bookingsRepositoryProvider);
      final location = ref.read(currentLocationProvider);

      await repository.updateBooking(
        locationId: location.id,
        bookingId: bookingId,
        clientId: clientId,
        clearClient: clientId == null, // Se null, rimuovi il cliente
      );

      // Aggiorna anche il booking locale
      ref
          .read(bookingsProvider.notifier)
          .updateClientForBooking(
            bookingId: bookingId,
            clientId: clientId,
            clientName: clientName,
          );
    } catch (e) {
      // Rollback: ripristina lo stato precedente
      state = AsyncData(currentList);
      rethrow; // Propaga l'errore per gestirlo nella UI
    }
  }

  /// Duplica un appuntamento
  Future<Appointment?> duplicateAppointment(
    Appointment original, {
    bool intoSameBooking = true,
  }) async {
    // If intoSameBooking is true, we should add to existing booking.
    // But createBooking creates a NEW booking.
    // The API doesn't seem to support adding item to existing booking yet (store endpoint creates booking).
    // So we can only support creating new booking for now.

    if (intoSameBooking) {
      // Not supported by API yet (need add item to booking endpoint)
      // Fallback to creating new booking or show error?
      // For now, let's create a new booking anyway but maybe warn?
      // Or just implement local duplication if we want to keep UI working without persistence

      // Let's try to create a new booking for now as duplication usually implies new slot
      return addAppointment(
        staffId: original.staffId,
        serviceId: original.serviceId,
        serviceVariantId: original.serviceVariantId,
        clientId: original.clientId,
        clientName: original.clientName,
        serviceName: original.serviceName,
        start: original.startTime, // Should probably be shifted?
        end: original.endTime,
      );
    } else {
      return addAppointment(
        staffId: original.staffId,
        serviceId: original.serviceId,
        serviceVariantId: original.serviceVariantId,
        clientId: original.clientId,
        clientName: original.clientName,
        serviceName: original.serviceName,
        start: original.startTime,
        end: original.endTime,
      );
    }
  }

  /// Cancella tutti gli appuntamenti appartenenti a una prenotazione.
  Future<void> deleteByBooking(int bookingId) async {
    final currentList = state.value;
    if (currentList == null) return;

    final location = ref.read(currentLocationProvider);
    final repository = ref.read(bookingsRepositoryProvider);

    try {
      // Chiama API per cancellare il booking
      await repository.deleteBooking(
        locationId: location.id,
        bookingId: bookingId,
      );

      // Aggiorna lo stato locale
      final newList = [
        for (final appt in currentList)
          if (appt.bookingId != bookingId) appt,
      ];

      state = AsyncData(newList);
    } catch (_) {
      // In caso di errore, mantieni lo stato corrente
    }
  }

  /// Crea rapidamente una prenotazione per un client
  Future<Appointment?> createQuickBookingForClient(int clientId) async {
    final clientsById = ref.read(clientsByIdProvider);
    final client = clientsById[clientId];
    if (client == null) return null;

    final agendaDate = ref.read(agendaDateProvider);
    final variants = ref.read(serviceVariantsProvider).value ?? [];
    if (variants.isEmpty) return null;
    final variant = variants.first;

    // Staff idoneo per il servizio e sede corrente
    final eligibleStaff = ref.read(
      eligibleStaffForServiceProvider(variant.serviceId),
    );
    if (eligibleStaff.isEmpty) return null;
    final staffId = eligibleStaff.first;

    // Orario: prossimo quarto d'ora oggi alle max 18:00
    final now = DateTime.now();
    final dayStart = DateUtils.dateOnly(agendaDate);
    DateTime base = now.isBefore(dayStart) ? dayStart : now;
    // clamp to today end
    final dayEnd = dayStart.add(const Duration(days: 1));
    if (base.isAfter(dayEnd)) base = dayStart.add(const Duration(hours: 10));
    final minutes = base.minute;
    final rounded = minutes % 15 == 0
        ? base
        : base.add(Duration(minutes: 15 - (minutes % 15)));
    final start = DateTime(
      dayStart.year,
      dayStart.month,
      dayStart.day,
      rounded.hour,
      rounded.minute,
    );
    final end = start.add(Duration(minutes: variant.durationMinutes));

    return addAppointment(
      staffId: staffId,
      serviceId: variant.serviceId,
      serviceVariantId: variant.id,
      clientId: client.id,
      clientName: client.name,
      serviceName: '',
      start: start,
      end: end,
      price: variant.price,
    );
  }
}

final appointmentsProvider =
    AsyncNotifierProvider<AppointmentsNotifier, List<Appointment>>(
      AppointmentsNotifier.new,
    );

final appointmentsForCurrentLocationProvider = Provider<List<Appointment>>((
  ref,
) {
  final location = ref.watch(currentLocationProvider);
  final currentDate = ref.watch(agendaDateProvider);
  final dayStart = DateUtils.dateOnly(currentDate);
  final dayEnd = dayStart.add(const Duration(days: 1));
  final appointmentsAsync = ref.watch(appointmentsProvider);
  final appointments = appointmentsAsync.value ?? [];

  return [
    for (final appt in appointments)
      if (appt.locationId == location.id &&
          !appt.endTime.isBefore(dayStart) &&
          appt.startTime.isBefore(dayEnd))
        appt,
  ];
});
--- FILE: lib/features/agenda/providers/date_range_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class AgendaDateNotifier extends Notifier<DateTime> {
  @override
  DateTime build() {
    final initial = DateUtils.dateOnly(DateTime.now());
    return initial;
  }

  void set(DateTime date) {
    final next = DateUtils.dateOnly(date);
    state = next;
  }

  void nextDay() {
    final next = DateUtils.dateOnly(state.add(const Duration(days: 1)));
    state = next;
  }

  void nextWeek() {
    final next = DateUtils.dateOnly(state.add(const Duration(days: 7)));
    state = next;
  }

  void previousDay() {
    final next = DateUtils.dateOnly(state.subtract(const Duration(days: 1)));
    state = next;
  }

  void previousWeek() {
    final next = DateUtils.dateOnly(state.subtract(const Duration(days: 7)));
    state = next;
  }

  void nextMonth() => _shiftMonths(1);

  void previousMonth() => _shiftMonths(-1);

  void _shiftMonths(int delta) {
    final y = state.year;
    final m = state.month;
    final d = state.day;

    // Convert to absolute month index to avoid loop and off-by-one issues
    final abs = y * 12 + (m - 1) + delta;
    final targetYear = abs ~/ 12;
    final targetMonth = (abs % 12) + 1; // back to 1..12

    final dim = DateUtils.getDaysInMonth(targetYear, targetMonth);
    final int safeDay = d <= dim ? d : dim;
    state = DateUtils.dateOnly(DateTime(targetYear, targetMonth, safeDay));
  }

  void setToday() {
    final today = DateUtils.dateOnly(DateTime.now());
    state = today;
  }
}

final agendaDateProvider = NotifierProvider<AgendaDateNotifier, DateTime>(
  AgendaDateNotifier.new,
);
--- FILE: lib/features/agenda/providers/resource_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/appointment.dart';
import '../../../core/models/resource.dart';
import '../../../core/models/service_variant.dart';
import '../../../core/models/service_variant_resource_requirement.dart';
import '../../../core/network/network_providers.dart';
import '../../auth/providers/auth_provider.dart';
import '../../services/providers/services_provider.dart';
import 'appointment_providers.dart';
import 'business_providers.dart';

///
/// RISORSE (caricamento da API)
///
class ResourcesNotifier extends AsyncNotifier<List<Resource>> {
  @override
  Future<List<Resource>> build() async {
    final authState = ref.watch(authProvider);
    if (!authState.isAuthenticated) {
      return [];
    }

    final apiClient = ref.watch(apiClientProvider);
    final business = ref.watch(currentBusinessProvider);

    // Non caricare se business non √® ancora valido
    if (business.id <= 0) {
      return [];
    }

    try {
      final data = await apiClient.getResourcesByBusiness(business.id);
      return data.map(_parseResource).toList();
    } catch (_) {
      return [];
    }
  }

  Resource _parseResource(Map<String, dynamic> json) {
    return Resource(
      id: json['id'] as int,
      locationId: json['location_id'] as int,
      name: json['name'] as String,
      quantity: json['quantity'] as int? ?? 1,
      type: json['type'] as String?,
      note: json['note'] as String?,
    );
  }

  Future<void> refresh() async {
    final authState = ref.read(authProvider);
    if (!authState.isAuthenticated) {
      state = const AsyncData([]);
      return;
    }

    final business = ref.read(currentBusinessProvider);
    if (business.id <= 0) {
      return;
    }

    state = const AsyncLoading();

    try {
      final apiClient = ref.read(apiClientProvider);
      final data = await apiClient.getResourcesByBusiness(business.id);
      state = AsyncData(data.map(_parseResource).toList());
    } catch (e, st) {
      state = AsyncError(e, st);
    }
  }

  Future<Resource> addResource({
    required int locationId,
    required String name,
    String? type,
    int quantity = 1,
    String? note,
  }) async {
    final apiClient = ref.read(apiClientProvider);
    final data = await apiClient.createResource(
      locationId: locationId,
      name: name,
      type: type,
      quantity: quantity,
      note: note,
    );
    final resource = _parseResource(data);
    final current = state.value ?? [];
    state = AsyncData([...current, resource]);
    return resource;
  }

  Future<Resource> updateResource({
    required int resourceId,
    String? name,
    String? type,
    int? quantity,
    String? note,
  }) async {
    final apiClient = ref.read(apiClientProvider);
    final data = await apiClient.updateResource(
      resourceId: resourceId,
      name: name,
      type: type,
      quantity: quantity,
      note: note,
    );
    final updated = _parseResource(data);
    final current = state.value ?? [];
    state = AsyncData([
      for (final r in current)
        if (r.id == updated.id) updated else r,
    ]);
    return updated;
  }

  Future<void> deleteResource(int id) async {
    final apiClient = ref.read(apiClientProvider);
    await apiClient.deleteResource(id);
    final current = state.value ?? [];
    state = AsyncData([
      for (final r in current)
        if (r.id != id) r,
    ]);
  }
}

final resourcesProvider =
    AsyncNotifierProvider<ResourcesNotifier, List<Resource>>(
      ResourcesNotifier.new,
    );

///
/// RISORSE PER LOCATION
///
final locationResourcesProvider = Provider.family<List<Resource>, int>((
  ref,
  locationId,
) {
  final resourcesAsync = ref.watch(resourcesProvider);
  final resources = resourcesAsync.value ?? [];
  return [
    for (final r in resources)
      if (r.locationId == locationId) r,
  ];
});

///
/// REQUISITI RISORSE PER SERVICE VARIANT
///
final serviceVariantResourcesProvider =
    Provider.family<List<ServiceVariantResourceRequirement>, int>((
      ref,
      serviceVariantId,
    ) {
      final variant = ref.watch(serviceVariantByIdProvider(serviceVariantId));
      return variant?.resourceRequirements ?? const [];
    });

typedef ResourceBookingsParams = ({int resourceId, DateTime day});

///
/// APPOINTMENT CHE OCCUPANO UNA RISORSA IN UN GIORNO
///
final resourceBookingsProvider =
    Provider.family<List<Appointment>, ResourceBookingsParams>((ref, params) {
      final resourceId = params.resourceId;
      final day = params.day;

      final dayStart = DateTime(day.year, day.month, day.day);
      final dayEnd = dayStart.add(const Duration(days: 1));

      final appointments = ref.watch(appointmentsProvider).value ?? [];
      final variants = ref.watch(serviceVariantsProvider).value ?? [];

      final variantById = <int, ServiceVariant>{
        for (final v in variants) v.id: v,
      };

      bool usesResource(Appointment appt) {
        final variant = variantById[appt.serviceVariantId];
        if (variant == null) return false;
        for (final req in variant.resourceRequirements) {
          if (req.resourceId == resourceId) return true;
        }
        return false;
      }

      return [
        for (final appt in appointments)
          if (!appt.endTime.isBefore(dayStart) &&
              appt.startTime.isBefore(dayEnd) &&
              usesResource(appt))
            appt,
      ];
    });

typedef ResourceAvailabilityParams = ({
  int serviceVariantId,
  int staffId,
  DateTime start,
  DateTime end,
});

///
/// DISPONIBILIT√Ä RISORSE PER UN NUOVO APPUNTAMENTO
///
final resourceAvailabilityProvider =
    Provider.family<bool, ResourceAvailabilityParams>((ref, params) {
      final serviceVariantId = params.serviceVariantId;
      final start = params.start;
      final end = params.end;

      final variants = ref.watch(serviceVariantsProvider).value ?? [];
      ServiceVariant? currentVariant;
      for (final v in variants) {
        if (v.id == serviceVariantId) {
          currentVariant = v;
          break;
        }
      }

      final requirements = currentVariant?.resourceRequirements ?? const [];
      if (requirements.isEmpty) return true;

      final allResourcesAsync = ref.watch(resourcesProvider);
      final allResources = allResourcesAsync.value ?? [];
      final resourceById = <int, Resource>{
        for (final r in allResources) r.id: r,
      };

      final requirementsByVariantId =
          <int, List<ServiceVariantResourceRequirement>>{
            for (final v in variants) v.id: v.resourceRequirements,
          };

      int unitsForAppointment(int resourceId, Appointment appt) {
        final reqs = requirementsByVariantId[appt.serviceVariantId];
        if (reqs == null) return 0;
        for (final req in reqs) {
          if (req.resourceId == resourceId) {
            return req.unitsRequired;
          }
        }
        return 0;
      }

      for (final req in requirements) {
        final resource = resourceById[req.resourceId];
        if (resource == null) {
          continue;
        }

        final bookings = ref.watch(
          resourceBookingsProvider((resourceId: req.resourceId, day: start)),
        );

        var usedUnits = 0;
        for (final appt in bookings) {
          final hasOverlap =
              appt.endTime.isAfter(start) && appt.startTime.isBefore(end);
          if (!hasOverlap) continue;

          usedUnits += unitsForAppointment(req.resourceId, appt);
        }

        if (usedUnits + req.unitsRequired > resource.quantity) {
          return false;
        }
      }

      return true;
    });
--- FILE: lib/features/agenda/providers/is_resizing_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Provider che tiene traccia se si sta ridimensionando una AppointmentCard.
/// Utilizzato per bloccare lo scroll verticale delle colonne durante il resize.
class IsResizingNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  void start() => state = true;
  void stop() => state = false;
}

final isResizingProvider = NotifierProvider<IsResizingNotifier, bool>(
  IsResizingNotifier.new,
);
--- FILE: lib/features/agenda/providers/time_blocks_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/time_block.dart';
import '../../../core/network/network_providers.dart';
import '../../auth/providers/auth_provider.dart';
import 'date_range_provider.dart';
import 'location_providers.dart';

class TimeBlocksNotifier extends AsyncNotifier<List<TimeBlock>> {
  @override
  Future<List<TimeBlock>> build() async {
    final authState = ref.watch(authProvider);
    if (!authState.isAuthenticated) {
      return [];
    }

    final apiClient = ref.watch(apiClientProvider);
    final location = ref.watch(currentLocationProvider);

    // Non caricare se location non √® ancora valida
    if (location.id <= 0) {
      return [];
    }

    // Carica blocchi per il mese corrente ¬± 1 mese
    final now = DateTime.now();
    final fromDate = DateTime(now.year, now.month - 1, 1);
    final toDate = DateTime(now.year, now.month + 2, 0);

    try {
      final data = await apiClient.getTimeBlocks(
        location.id,
        fromDate: _formatDateTime(fromDate),
        toDate: _formatDateTime(toDate),
      );
      return data.map(_parseTimeBlock).toList();
    } catch (_) {
      return [];
    }
  }

  String _formatDateTime(DateTime dt) {
    return '${dt.year}-${dt.month.toString().padLeft(2, '0')}-${dt.day.toString().padLeft(2, '0')} '
        '${dt.hour.toString().padLeft(2, '0')}:${dt.minute.toString().padLeft(2, '0')}:${dt.second.toString().padLeft(2, '0')}';
  }

  TimeBlock _parseTimeBlock(Map<String, dynamic> json) {
    return TimeBlock(
      id: json['id'] as int,
      businessId: json['business_id'] as int,
      locationId: json['location_id'] as int,
      staffIds: (json['staff_ids'] as List).map((e) => e as int).toList(),
      startTime: DateTime.parse(json['start_time'] as String),
      endTime: DateTime.parse(json['end_time'] as String),
      reason: json['reason'] as String?,
      isAllDay: (json['is_all_day'] as int?) == 1,
    );
  }

  Future<void> refresh() async {
    final authState = ref.read(authProvider);
    if (!authState.isAuthenticated) {
      state = const AsyncData([]);
      return;
    }

    final location = ref.read(currentLocationProvider);
    if (location.id <= 0) {
      return;
    }

    state = const AsyncLoading();

    // Carica blocchi per il mese corrente ¬± 1 mese
    final now = DateTime.now();
    final fromDate = DateTime(now.year, now.month - 1, 1);
    final toDate = DateTime(now.year, now.month + 2, 0);

    try {
      final apiClient = ref.read(apiClientProvider);
      final data = await apiClient.getTimeBlocks(
        location.id,
        fromDate: _formatDateTime(fromDate),
        toDate: _formatDateTime(toDate),
      );
      state = AsyncData(data.map(_parseTimeBlock).toList());
    } catch (e, st) {
      state = AsyncError(e, st);
    }
  }

  /// Aggiunge un nuovo blocco di non disponibilit√†.
  Future<TimeBlock> addBlock({
    required List<int> staffIds,
    required DateTime startTime,
    required DateTime endTime,
    String? reason,
    bool isAllDay = false,
  }) async {
    final apiClient = ref.read(apiClientProvider);
    final location = ref.read(currentLocationProvider);

    final data = await apiClient.createTimeBlock(
      locationId: location.id,
      startTime: _formatDateTime(startTime),
      endTime: _formatDateTime(endTime),
      staffIds: staffIds,
      isAllDay: isAllDay,
      reason: reason,
    );

    final block = _parseTimeBlock(data);
    final current = state.value ?? [];
    state = AsyncData([...current, block]);
    return block;
  }

  /// Aggiorna un blocco esistente.
  Future<void> updateBlock({
    required int blockId,
    DateTime? startTime,
    DateTime? endTime,
    List<int>? staffIds,
    String? reason,
    bool? isAllDay,
  }) async {
    final apiClient = ref.read(apiClientProvider);

    final data = await apiClient.updateTimeBlock(
      blockId: blockId,
      startTime: startTime != null ? _formatDateTime(startTime) : null,
      endTime: endTime != null ? _formatDateTime(endTime) : null,
      staffIds: staffIds,
      isAllDay: isAllDay,
      reason: reason,
    );

    final updated = _parseTimeBlock(data);
    final current = state.value ?? [];
    state = AsyncData([
      for (final block in current)
        if (block.id == updated.id) updated else block,
    ]);
  }

  /// Elimina un blocco per id.
  Future<void> deleteBlock(int blockId) async {
    final apiClient = ref.read(apiClientProvider);
    await apiClient.deleteTimeBlock(blockId);

    final current = state.value ?? [];
    state = AsyncData([
      for (final block in current)
        if (block.id != blockId) block,
    ]);
  }

  /// Sposta un blocco a un nuovo orario.
  Future<void> moveBlock({
    required int blockId,
    required DateTime newStart,
    required DateTime newEnd,
  }) async {
    await updateBlock(blockId: blockId, startTime: newStart, endTime: newEnd);
  }

  /// Modifica gli staff assegnati a un blocco.
  Future<void> updateBlockStaff({
    required int blockId,
    required List<int> staffIds,
  }) async {
    await updateBlock(blockId: blockId, staffIds: staffIds);
  }
}

final timeBlocksProvider =
    AsyncNotifierProvider<TimeBlocksNotifier, List<TimeBlock>>(
      TimeBlocksNotifier.new,
    );

/// Blocchi filtrati per la sede corrente e la data corrente dell'agenda.
final timeBlocksForCurrentLocationProvider = Provider<List<TimeBlock>>((ref) {
  final location = ref.watch(currentLocationProvider);
  final currentDate = ref.watch(agendaDateProvider);
  final dayStart = DateUtils.dateOnly(currentDate);
  final dayEnd = dayStart.add(const Duration(days: 1));
  final blocksAsync = ref.watch(timeBlocksProvider);
  final blocks = blocksAsync.value ?? [];

  return [
    for (final block in blocks)
      if (block.locationId == location.id &&
          !block.endTime.isBefore(dayStart) &&
          block.startTime.isBefore(dayEnd))
        block,
  ];
});

/// Blocchi per uno staff specifico nella data corrente dell'agenda.
final timeBlocksForStaffProvider = Provider.family<List<TimeBlock>, int>((
  ref,
  staffId,
) {
  final blocks = ref.watch(timeBlocksForCurrentLocationProvider);
  return [
    for (final block in blocks)
      if (block.includesStaff(staffId)) block,
  ];
});
--- FILE: lib/features/agenda/providers/resizing_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Dati della sessione di resize per un singolo appuntamento.
class _ResizingEntry {
  final double baseHeightPx;
  final DateTime startTimeInitial;
  final DateTime endTimeInitial;
  final double currentPreviewHeightPx;
  final DateTime provisionalEndTime;

  const _ResizingEntry({
    required this.baseHeightPx,
    required this.startTimeInitial,
    required this.endTimeInitial,
    required this.currentPreviewHeightPx,
    required this.provisionalEndTime,
  });

  _ResizingEntry copyWith({
    double? baseHeightPx,
    DateTime? startTimeInitial,
    DateTime? endTimeInitial,
    double? currentPreviewHeightPx,
    DateTime? provisionalEndTime,
  }) {
    return _ResizingEntry(
      baseHeightPx: baseHeightPx ?? this.baseHeightPx,
      startTimeInitial: startTimeInitial ?? this.startTimeInitial,
      endTimeInitial: endTimeInitial ?? this.endTimeInitial,
      currentPreviewHeightPx:
          currentPreviewHeightPx ?? this.currentPreviewHeightPx,
      provisionalEndTime: provisionalEndTime ?? this.provisionalEndTime,
    );
  }
}

/// Stato globale del resize (pi√π entry contemporanee per staff multipli).
class ResizingState {
  final Map<int, _ResizingEntry> entries;
  final bool isResizing;

  const ResizingState({this.entries = const {}, this.isResizing = false});

  const ResizingState.initial() : entries = const {}, isResizing = false;

  ResizingState copyWith({
    Map<int, _ResizingEntry>? entries,
    bool? isResizing,
  }) {
    return ResizingState(
      entries: entries ?? this.entries,
      isResizing: isResizing ?? this.isResizing,
    );
  }
}

/// Gestore centralizzato dei resize attivi.
class ResizingNotifier extends Notifier<ResizingState> {
  @override
  ResizingState build() => const ResizingState.initial();

  /// Avvia una nuova sessione di resize per una card specifica.
  void startResize({
    required int appointmentId,
    required double currentHeightPx,
    required DateTime startTime,
    required DateTime endTime,
  }) {
    // üîπ Reset completo della base e altezza provvisoria
    final newEntry = _ResizingEntry(
      baseHeightPx: currentHeightPx,
      startTimeInitial: startTime,
      endTimeInitial: endTime,
      currentPreviewHeightPx: currentHeightPx,
      provisionalEndTime: endTime,
    );

    // üîπ Aggiorna solo la entry corrente senza cancellare le altre
    final updated = Map<int, _ResizingEntry>.from(state.entries);
    updated[appointmentId] = newEntry;

    state = state.copyWith(entries: updated, isResizing: true);
  }

  /// Aggiornamento live durante il drag del bordo inferiore.
  void updateDuringResize({
    required int appointmentId,
    required double deltaDy,
    required double pixelsPerMinute,
    required DateTime dayEnd,
    required int minDurationMinutes,
    required int snapMinutes,
  }) {
    final entry = state.entries[appointmentId];
    if (entry == null) return;

    // üîπ Calcola nuova altezza cumulativa a partire dall'altezza corrente
    double proposedHeightPx = entry.currentPreviewHeightPx + deltaDy;

    final minHeightPx = minDurationMinutes * pixelsPerMinute;
    final rawMaxDurationMinutes =
        dayEnd.difference(entry.startTimeInitial).inMinutes;
    final effectiveMaxDurationMinutes = rawMaxDurationMinutes <= 0
        ? minDurationMinutes
        : rawMaxDurationMinutes < minDurationMinutes
            ? minDurationMinutes
            : rawMaxDurationMinutes;
    final maxHeightPx = effectiveMaxDurationMinutes * pixelsPerMinute;

    // üîπ Applica i limiti min/max consentiti
    proposedHeightPx = proposedHeightPx.clamp(minHeightPx, maxHeightPx).toDouble();

    final proposedDurationMinutes = proposedHeightPx / pixelsPerMinute;

    // üîπ Snap ai minuti impostati solo per il calcolo dell'end time
    final lowerBoundMinutes = minDurationMinutes.toDouble();
    final upperBoundMinutes = effectiveMaxDurationMinutes.toDouble();

    final snappedMinutes = _snapToStep(
      proposedDurationMinutes,
      snapMinutes,
    ).clamp(
      lowerBoundMinutes,
      upperBoundMinutes < lowerBoundMinutes
          ? lowerBoundMinutes
          : upperBoundMinutes,
    );

    // üîπ Nuovo end provvisorio (clamp a fine giornata se necessario)
    DateTime candidateEnd = entry.startTimeInitial.add(
      Duration(minutes: snappedMinutes.round()),
    );
    if (candidateEnd.isAfter(dayEnd)) {
      candidateEnd = dayEnd;
    }

    final updatedEntry = entry.copyWith(
      currentPreviewHeightPx: proposedHeightPx,
      provisionalEndTime: candidateEnd,
    );

    final updated = Map<int, _ResizingEntry>.from(state.entries);
    updated[appointmentId] = updatedEntry;

    state = state.copyWith(entries: updated, isResizing: true);
  }

  /// Conclude il resize e restituisce il nuovo endTime definitivo.
  DateTime? commitResizeAndEnd({required int appointmentId}) {
    final entry = state.entries[appointmentId];
    final finalEnd = entry?.provisionalEndTime;
    if (entry == null) return null;

    // üîπ Prima di rimuovere, resetta la preview height alla base originale
    final resetEntry = entry.copyWith(
      currentPreviewHeightPx: entry.baseHeightPx,
    );

    final updated = Map<int, _ResizingEntry>.from(state.entries);
    updated[appointmentId] = resetEntry;
    updated.remove(appointmentId);

    state = state.copyWith(entries: updated, isResizing: updated.isNotEmpty);

    return finalEnd;
  }

  /// Annulla un resize senza commit.
  void cancelResize({required int appointmentId}) {
    final updated = Map<int, _ResizingEntry>.from(state.entries);
    updated.remove(appointmentId);
    state = state.copyWith(entries: updated, isResizing: updated.isNotEmpty);
  }

  /// Accessori utili.
  double? previewHeightFor(int appointmentId) =>
      state.entries[appointmentId]?.currentPreviewHeightPx;

  DateTime? previewEndTimeFor(int appointmentId) =>
      state.entries[appointmentId]?.provisionalEndTime;

  double _snapToStep(double minutes, int step) {
    if (step <= 1) return minutes;
    final m = minutes / step;
    final rounded = m.round();
    return (rounded * step).toDouble();
  }
}

/// Provider principale di stato di resize.
final resizingProvider = NotifierProvider<ResizingNotifier, ResizingState>(
  ResizingNotifier.new,
);

/// Provider per una singola entry di appointment.
final resizingEntryProvider = Provider.family<_ResizingEntry?, int>(
  (ref, appointmentId) => ref.watch(resizingProvider).entries[appointmentId],
);
--- FILE: lib/features/agenda/providers/fully_occupied_slots_provider.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import 'appointment_providers.dart';
import 'date_range_provider.dart';
import 'layout_config_provider.dart';

part 'fully_occupied_slots_provider.g.dart';

/// Calcola gli indici degli slot completamente occupati per un dato staff.
/// Uno slot √® "completamente occupato" quando la somma delle frazioni di larghezza
/// degli appuntamenti che lo coprono raggiunge o supera il 100%.
@riverpod
Set<int> fullyOccupiedSlots(Ref ref, int staffId) {
  final appointments = ref
      .watch(appointmentsForCurrentLocationProvider)
      .where((a) => a.staffId == staffId)
      .toList();

  if (appointments.isEmpty) return const {};

  final layoutConfig = ref.watch(layoutConfigProvider);
  final agendaDate = ref.watch(agendaDateProvider);
  final minutesPerSlot = layoutConfig.minutesPerSlot;
  final totalSlots = layoutConfig.totalSlots;

  // Calcola la geometria degli appuntamenti per determinare le frazioni di larghezza
  final layoutEntries = appointments
      .map((a) => _LayoutEntry(id: a.id, start: a.startTime, end: a.endTime))
      .toList();

  final geometryMap = _computeLayoutGeometry(
    layoutEntries,
    useClusterMaxConcurrency: layoutConfig.useClusterMaxConcurrency,
  );

  // Per ogni slot, calcola la somma delle frazioni di larghezza coperte
  final fullyOccupied = <int>{};

  for (int slotIndex = 0; slotIndex < totalSlots; slotIndex++) {
    final slotStart = agendaDate.add(
      Duration(minutes: slotIndex * minutesPerSlot),
    );
    final slotEnd = slotStart.add(Duration(minutes: minutesPerSlot));

    // Trova tutti gli appuntamenti che coprono questo slot
    double totalWidthFraction = 0.0;

    for (final appt in appointments) {
      // Verifica se l'appuntamento copre lo slot
      if (appt.startTime.isBefore(slotEnd) && appt.endTime.isAfter(slotStart)) {
        final geometry = geometryMap[appt.id];
        if (geometry != null) {
          totalWidthFraction += geometry.widthFraction;
        }
      }
    }

    // Lo slot √® completamente occupato se la somma >= 1.0 (100%)
    if (totalWidthFraction >= 0.999) {
      fullyOccupied.add(slotIndex);
    }
  }

  return fullyOccupied;
}

// ‚îÄ‚îÄ Classi helper per il calcolo della geometria ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class _LayoutEntry {
  const _LayoutEntry({
    required this.id,
    required this.start,
    required this.end,
  });

  final int id;
  final DateTime start;
  final DateTime end;
}

class _EventGeometry {
  const _EventGeometry({
    required this.leftFraction,
    required this.widthFraction,
  });

  final double leftFraction;
  final double widthFraction;
}

/// Versione semplificata del layout geometry helper.
Map<int, _EventGeometry> _computeLayoutGeometry(
  List<_LayoutEntry> entries, {
  bool useClusterMaxConcurrency = false,
}) {
  if (entries.isEmpty) return const {};

  final sorted = entries.toList()..sort((a, b) => a.start.compareTo(b.start));

  final clusters = <List<_LayoutEntry>>[];
  var currentCluster = <_LayoutEntry>[];
  DateTime? currentMaxEnd;

  for (final entry in sorted) {
    if (currentCluster.isEmpty) {
      currentCluster = [entry];
      currentMaxEnd = entry.end;
      continue;
    }

    if (entry.start.isBefore(currentMaxEnd!)) {
      currentCluster.add(entry);
      if (entry.end.isAfter(currentMaxEnd)) {
        currentMaxEnd = entry.end;
      }
    } else {
      clusters.add(List<_LayoutEntry>.from(currentCluster));
      currentCluster = [entry];
      currentMaxEnd = entry.end;
    }
  }

  if (currentCluster.isNotEmpty) {
    clusters.add(List<_LayoutEntry>.from(currentCluster));
  }

  final geometryMap = <int, _EventGeometry>{};

  for (final cluster in clusters) {
    final concurrencyMap = _computeConcurrency(cluster);

    for (final entry in cluster) {
      final concurrency = concurrencyMap[entry.id] ?? 1;
      final widthFraction = 1 / concurrency;
      geometryMap[entry.id] = _EventGeometry(
        leftFraction: 0, // Non ci serve leftFraction per questo calcolo
        widthFraction: widthFraction,
      );
    }
  }

  return geometryMap;
}

Map<int, int> _computeConcurrency(List<_LayoutEntry> cluster) {
  final result = <int, int>{};

  for (final entry in cluster) {
    int count = 0;
    for (final other in cluster) {
      if (entry.start.isBefore(other.end) && entry.end.isAfter(other.start)) {
        count++;
      }
    }
    result[entry.id] = count;
  }

  return result;
}
--- FILE: lib/features/agenda/providers/dragged_base_range_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Mantiene l'intervallo originale (start, end) della card che sta per
/// essere trascinata. Serve per evitare fallback arbitrari durante il ghost.
class DraggedBaseRangeNotifier extends Notifier<(DateTime, DateTime)?> {
  @override
  (DateTime, DateTime)? build() => null;

  void set(DateTime start, DateTime end) => state = (start, end);
  void clear() => state = null;
}

final draggedBaseRangeProvider =
    NotifierProvider<DraggedBaseRangeNotifier, (DateTime, DateTime)?>(
      DraggedBaseRangeNotifier.new,
    );
--- FILE: lib/features/agenda/providers/bookings_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/booking.dart';
import 'appointment_providers.dart';
import 'business_providers.dart';
import 'location_providers.dart';

class BookingSummary {
  final int bookingId;
  final int itemsCount;
  final double totalPrice;
  final DateTime? start;
  final DateTime? end;

  const BookingSummary({
    required this.bookingId,
    required this.itemsCount,
    required this.totalPrice,
    required this.start,
    required this.end,
  });
}

/// Gestisce i metadati delle prenotazioni (note, clientName, ecc.) e
/// coordina le operazioni di alto livello (cancellazione prenotazione intera).
class BookingsNotifier extends Notifier<Map<int, Booking>> {
  int _nextId = 1;

  @override
  Map<int, Booking> build() => <int, Booking>{};

  /// Crea una nuova prenotazione e restituisce il suo ID.
  int createBooking({int? clientId, String? clientName, String? notes}) {
    final business = ref.read(currentBusinessProvider);
    final location = ref.read(currentLocationProvider);

    final bookingId = _nextId++;
    state = {
      ...state,
      bookingId: Booking(
        id: bookingId,
        businessId: business.id,
        locationId: location.id,
        clientId: clientId,
        clientName: clientName,
        notes: notes,
      ),
    };
    return bookingId;
  }

  /// Crea la prenotazione se non esiste gi√† (idempotente).
  void ensureBooking({
    required int bookingId,
    required int businessId,
    required int locationId,
    int? clientId,
    required String clientName,
  }) {
    final current = state;
    if (current.containsKey(bookingId)) return;
    state = {
      ...current,
      bookingId: Booking(
        id: bookingId,
        businessId: businessId,
        locationId: locationId,
        clientId: clientId,
        clientName: clientName,
        notes: null,
      ),
    };
  }

  void setNotes(int bookingId, String? notes) {
    final bk = state[bookingId];
    if (bk == null) return;
    state = {
      for (final e in state.entries)
        e.key: e.key == bookingId
            ? Booking(
                id: bk.id,
                businessId: bk.businessId,
                locationId: bk.locationId,
                clientId: bk.clientId,
                clientName: bk.clientName,
                notes: notes,
              )
            : e.value,
    };
  }

  /// Cancella l'intera prenotazione e tutti i suoi appuntamenti.
  Future<void> deleteBooking(int bookingId) async {
    // Aggiorna appuntamenti in cascata (chiama API)
    await ref.read(appointmentsProvider.notifier).deleteByBooking(bookingId);
    // Rimuovi metadati prenotazione
    final copy = Map<int, Booking>.from(state);
    copy.remove(bookingId);
    state = copy;
  }

  /// Rimuove la prenotazione se non ha pi√π appuntamenti.
  void removeIfEmpty(int bookingId) {
    final appts = ref.read(appointmentsProvider).value ?? [];
    if (appts.any((a) => a.bookingId == bookingId)) return;
    final copy = Map<int, Booking>.from(state);
    copy.remove(bookingId);
    state = copy;
  }

  /// Aggiorna il cliente di un booking locale.
  void updateClientForBooking({
    required int bookingId,
    int? clientId,
    String? clientName,
  }) {
    final bk = state[bookingId];
    if (bk == null) return;
    state = {
      for (final e in state.entries)
        e.key: e.key == bookingId
            ? Booking(
                id: bk.id,
                businessId: bk.businessId,
                locationId: bk.locationId,
                clientId: clientId,
                clientName: clientName ?? bk.clientName,
                notes: bk.notes,
              )
            : e.value,
    };
  }
}

final bookingsProvider = NotifierProvider<BookingsNotifier, Map<int, Booking>>(
  BookingsNotifier.new,
);

/// Riepilogo calcolato su appointment per un booking.
final bookingSummaryProvider = Provider.family<BookingSummary?, int>((ref, id) {
  final appts = (ref.watch(appointmentsProvider).value ?? [])
      .where((a) => a.bookingId == id)
      .toList();
  if (appts.isEmpty) return null;

  appts.sort((a, b) => a.startTime.compareTo(b.startTime));
  final totalPrice = appts.fold<double>(0.0, (sum, a) => sum + (a.price ?? 0));
  return BookingSummary(
    bookingId: id,
    itemsCount: appts.length,
    totalPrice: totalPrice,
    start: appts.first.startTime,
    end: appts.map((a) => a.endTime).reduce((a, b) => a.isAfter(b) ? a : b),
  );
});
--- FILE: lib/features/agenda/providers/agenda_scroll_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/staff.dart';

/// Stato con tutti i controller di scroll sincronizzati
class AgendaScrollState {
  final ScrollController verticalScrollCtrl;
  final ScrollController horizontalScrollCtrl;
  final Map<int, ScrollController> staffScrollCtrls;

  const AgendaScrollState({
    required this.verticalScrollCtrl,
    required this.horizontalScrollCtrl,
    required this.staffScrollCtrls,
  });
}

@immutable
class AgendaScrollKey {
  final Object identity;
  final List<Staff> staff;
  final DateTime date;
  final double initialOffset;

  const AgendaScrollKey({
    required this.identity,
    required this.staff,
    required this.date,
    required this.initialOffset,
  });

  @override
  bool operator ==(Object other) {
    return other is AgendaScrollKey && identical(other.identity, identity);
  }

  @override
  int get hashCode => identity.hashCode;
}

final agendaScrollProvider = Provider.family.autoDispose<AgendaScrollState, AgendaScrollKey>((ref, key) {
  final staffList = key.staff;
  final verticalCtrl = ScrollController(initialScrollOffset: key.initialOffset);
  final horizontalCtrl = ScrollController();
  final Map<int, ScrollController> staffCtrls = {
    for (final s in staffList) s.id: ScrollController(),
  };

  ref.onDispose(() {
    verticalCtrl.dispose();
    horizontalCtrl.dispose();
    for (final controller in staffCtrls.values) {
      controller.dispose();
    }
  });

  return AgendaScrollState(
    verticalScrollCtrl: verticalCtrl,
    horizontalScrollCtrl: horizontalCtrl,
    staffScrollCtrls: staffCtrls,
  );
});
--- FILE: lib/features/agenda/providers/bookings_repository_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'bookings_repository_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(bookingsRepository)
const bookingsRepositoryProvider = BookingsRepositoryProvider._();

final class BookingsRepositoryProvider
    extends
        $FunctionalProvider<
          BookingsRepository,
          BookingsRepository,
          BookingsRepository
        >
    with $Provider<BookingsRepository> {
  const BookingsRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'bookingsRepositoryProvider',
        isAutoDispose: false,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$bookingsRepositoryHash();

  @$internal
  @override
  $ProviderElement<BookingsRepository> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  BookingsRepository create(Ref ref) {
    return bookingsRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(BookingsRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<BookingsRepository>(value),
    );
  }
}

String _$bookingsRepositoryHash() =>
    r'50ae33d4ab0eb3eea9df1a6cfa054ae2ac09cdbb';
--- FILE: lib/features/agenda/providers/agenda_interaction_lock_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'agenda_providers.dart';
import 'is_resizing_provider.dart';
import 'selected_appointment_provider.dart';

/// Stato condiviso che indica se il puntatore √® attualmente sopra una card.
class AgendaCardHoverNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  void setHovering(bool hovering) => state = hovering;

  void enter() => state = true;

  void exit() => state = false;
}

final agendaCardHoverProvider = NotifierProvider<AgendaCardHoverNotifier, bool>(
  AgendaCardHoverNotifier.new,
);

/// Restituisce `true` quando il PageView deve essere disabilitato
/// (drag, resize, hover o card selezionate).
final agendaDayScrollLockProvider = Provider<bool>((ref) {
  final isResizing = ref.watch(isResizingProvider);
  final isDragging = ref.watch(dragPositionProvider) != null;
  final hasSelection = !ref.watch(selectedAppointmentProvider).isEmpty;
  final isHovering = ref.watch(agendaCardHoverProvider);
  return isResizing || isDragging || hasSelection || isHovering;
});
--- FILE: lib/features/agenda/providers/visited_dates_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Provider per tracciare se √® stata effettuata la prima apertura dell'agenda.
/// Lo scroll automatico all'orario corrente avviene SOLO alla prima apertura.
class InitialScrollDoneNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  /// Marca lo scroll iniziale come completato.
  void markDone() {
    state = true;
  }

  /// Reset (usato quando si cambia business).
  void reset() {
    state = false;
  }
}

final initialScrollDoneProvider =
    NotifierProvider<InitialScrollDoneNotifier, bool>(
      InitialScrollDoneNotifier.new,
    );
--- FILE: lib/features/agenda/providers/fully_occupied_slots_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'fully_occupied_slots_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning
/// Calcola gli indici degli slot completamente occupati per un dato staff.
/// Uno slot √® "completamente occupato" quando la somma delle frazioni di larghezza
/// degli appuntamenti che lo coprono raggiunge o supera il 100%.

@ProviderFor(fullyOccupiedSlots)
const fullyOccupiedSlotsProvider = FullyOccupiedSlotsFamily._();

/// Calcola gli indici degli slot completamente occupati per un dato staff.
/// Uno slot √® "completamente occupato" quando la somma delle frazioni di larghezza
/// degli appuntamenti che lo coprono raggiunge o supera il 100%.

final class FullyOccupiedSlotsProvider
    extends $FunctionalProvider<Set<int>, Set<int>, Set<int>>
    with $Provider<Set<int>> {
  /// Calcola gli indici degli slot completamente occupati per un dato staff.
  /// Uno slot √® "completamente occupato" quando la somma delle frazioni di larghezza
  /// degli appuntamenti che lo coprono raggiunge o supera il 100%.
  const FullyOccupiedSlotsProvider._({
    required FullyOccupiedSlotsFamily super.from,
    required int super.argument,
  }) : super(
         retry: null,
         name: r'fullyOccupiedSlotsProvider',
         isAutoDispose: true,
         dependencies: null,
         $allTransitiveDependencies: null,
       );

  @override
  String debugGetCreateSourceHash() => _$fullyOccupiedSlotsHash();

  @override
  String toString() {
    return r'fullyOccupiedSlotsProvider'
        ''
        '($argument)';
  }

  @$internal
  @override
  $ProviderElement<Set<int>> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  Set<int> create(Ref ref) {
    final argument = this.argument as int;
    return fullyOccupiedSlots(ref, argument);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(Set<int> value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<Set<int>>(value),
    );
  }

  @override
  bool operator ==(Object other) {
    return other is FullyOccupiedSlotsProvider && other.argument == argument;
  }

  @override
  int get hashCode {
    return argument.hashCode;
  }
}

String _$fullyOccupiedSlotsHash() =>
    r'cac3293a238229a07421123556e10d4471801e64';

/// Calcola gli indici degli slot completamente occupati per un dato staff.
/// Uno slot √® "completamente occupato" quando la somma delle frazioni di larghezza
/// degli appuntamenti che lo coprono raggiunge o supera il 100%.

final class FullyOccupiedSlotsFamily extends $Family
    with $FunctionalFamilyOverride<Set<int>, int> {
  const FullyOccupiedSlotsFamily._()
    : super(
        retry: null,
        name: r'fullyOccupiedSlotsProvider',
        dependencies: null,
        $allTransitiveDependencies: null,
        isAutoDispose: true,
      );

  /// Calcola gli indici degli slot completamente occupati per un dato staff.
  /// Uno slot √® "completamente occupato" quando la somma delle frazioni di larghezza
  /// degli appuntamenti che lo coprono raggiunge o supera il 100%.

  FullyOccupiedSlotsProvider call(int staffId) =>
      FullyOccupiedSlotsProvider._(argument: staffId, from: this);

  @override
  String toString() => r'fullyOccupiedSlotsProvider';
}
--- FILE: lib/features/agenda/providers/staff_columns_geometry_provider.dart ---
import 'dart:ui';

import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Mappa: staffId -> Rect della colonna in coordinate BODY-LOCAL
class StaffColumnsGeometryNotifier extends Notifier<Map<int, Rect>> {
  @override
  Map<int, Rect> build() => <int, Rect>{};

  void setRect(int staffId, Rect rect) {
    final next = Map<int, Rect>.from(state)..[staffId] = rect;
    state = next;
  }

  void clearFor(int staffId) {
    if (!state.containsKey(staffId)) return;
    final next = Map<int, Rect>.from(state)..remove(staffId);
    state = next;
  }

  void clearAll() => state = <int, Rect>{};
}

final staffColumnsGeometryProvider =
    NotifierProvider<StaffColumnsGeometryNotifier, Map<int, Rect>>(
      StaffColumnsGeometryNotifier.new,
    );
--- FILE: lib/features/agenda/providers/agenda_providers.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Notifier che tiene traccia della posizione globale del drag
class DragPositionNotifier extends Notifier<Offset?> {
  @override
  Offset? build() => null;

  void update(Offset position) => state = position;

  /// ‚úÖ Nuovo metodo pubblico per aggiornare lo stato interpolato
  void set(Offset newValue) => state = newValue;

  void clear() => state = null;
}

final dragPositionProvider = NotifierProvider<DragPositionNotifier, Offset?>(
  DragPositionNotifier.new,
);
--- FILE: lib/features/agenda/providers/bookings_repository_provider.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../core/network/network_providers.dart';
import '../data/bookings_repository.dart';

part 'bookings_repository_provider.g.dart';

@Riverpod(keepAlive: true)
BookingsRepository bookingsRepository(Ref ref) {
  final apiClient = ref.watch(apiClientProvider);
  return BookingsRepository(apiClient: apiClient);
}
--- FILE: lib/features/agenda/providers/selected_appointment_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/appointment.dart';
import 'appointment_providers.dart';

class SelectedAppointmentsState {
  const SelectedAppointmentsState({
    this.bookingId,
    this.appointmentIds = const <int>{},
  });

  final int? bookingId;
  final Set<int> appointmentIds;

  bool contains(int appointmentId) => appointmentIds.contains(appointmentId);
  bool get isEmpty => appointmentIds.isEmpty;
}

/// üîπ Tiene traccia degli appuntamenti selezionati (tutti quelli della stessa prenotazione)
class SelectedAppointmentNotifier extends Notifier<SelectedAppointmentsState> {
  @override
  SelectedAppointmentsState build() => const SelectedAppointmentsState();

  /// Seleziona tutti gli appuntamenti collegati allo stesso booking dell'appuntamento dato.
  /// Se gi√† selezionati, deseleziona tutto.
  void toggleByAppointment(Appointment appointment) {
    final current = state;
    final alreadySelected =
        current.bookingId == appointment.bookingId &&
        current.contains(appointment.id);
    if (alreadySelected) {
      clear();
      return;
    }

    final allAppointments = ref.read(appointmentsProvider).value ?? [];
    final bookingAppointments = allAppointments
        .where((a) => a.bookingId == appointment.bookingId)
        .map((a) => a.id)
        .toSet();

    state = SelectedAppointmentsState(
      bookingId: appointment.bookingId,
      appointmentIds: bookingAppointments,
    );
  }

  /// Deseleziona tutti gli appuntamenti
  void clear() => state = const SelectedAppointmentsState();
}

final selectedAppointmentProvider =
    NotifierProvider<SelectedAppointmentNotifier, SelectedAppointmentsState>(
      SelectedAppointmentNotifier.new,
    );
--- FILE: lib/features/agenda/providers/agenda_scroll_request_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/appointment.dart';

@immutable
class AgendaScrollRequest {
  const AgendaScrollRequest(this.appointment);

  final Appointment appointment;

  DateTime get date => DateUtils.dateOnly(appointment.startTime);
}

class AgendaScrollRequestNotifier extends Notifier<AgendaScrollRequest?> {
  @override
  AgendaScrollRequest? build() => null;

  void request(Appointment appointment) {
    state = AgendaScrollRequest(appointment);
  }

  void clear() => state = null;
}

final agendaScrollRequestProvider =
    NotifierProvider<AgendaScrollRequestNotifier, AgendaScrollRequest?>(
      AgendaScrollRequestNotifier.new,
    );
--- FILE: lib/features/agenda/providers/temp_drag_time_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Mantiene in memoria temporanea l'intervallo orario stimato
/// (start, end) dell'appuntamento durante il drag.
/// Viene aggiornato in tempo reale dalla StaffColumn mentre l'utente trascina
/// e letto da AppointmentCard per mostrare orari live.
class TempDragTimeNotifier extends Notifier<(DateTime, DateTime)?> {
  @override
  (DateTime, DateTime)? build() => null;

  /// Imposta un nuovo intervallo orario (start, end)
  void setTimes(DateTime start, DateTime end) {
    // aggiorna solo se cambia effettivamente lo slot di riferimento
    if (state == null ||
        state!.$1.minute != start.minute ||
        state!.$1.hour != start.hour) {
      state = (start, end);
    }
  }

  /// Resetta lo stato (nessun drag in corso)
  void clear() => state = null;
}

final tempDragTimeProvider =
    NotifierProvider<TempDragTimeNotifier, (DateTime, DateTime)?>(
      TempDragTimeNotifier.new,
    );
--- FILE: lib/features/agenda/providers/pending_drop_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Dati di un drop in attesa di conferma.
@immutable
class PendingDropData {
  final int appointmentId;
  final int originalStaffId;
  final DateTime originalStart;
  final DateTime originalEnd;
  final int newStaffId;
  final DateTime newStart;
  final DateTime newEnd;

  const PendingDropData({
    required this.appointmentId,
    required this.originalStaffId,
    required this.originalStart,
    required this.originalEnd,
    required this.newStaffId,
    required this.newStart,
    required this.newEnd,
  });
}

/// Notifier per gestire lo stato di un drop in attesa di conferma.
class PendingDropNotifier extends Notifier<PendingDropData?> {
  @override
  PendingDropData? build() => null;

  void setPending(PendingDropData data) {
    state = data;
  }

  void clear() {
    state = null;
  }

  bool get hasPending => state != null;
}

/// Provider per lo stato di drop in attesa di conferma.
final pendingDropProvider =
    NotifierProvider<PendingDropNotifier, PendingDropData?>(
      PendingDropNotifier.new,
    );

/// Provider per verificare se un appuntamento specifico ha un drop pendente.
final isAppointmentPendingDropProvider = Provider.family<bool, int>((
  ref,
  appointmentId,
) {
  final pending = ref.watch(pendingDropProvider);
  return pending?.appointmentId == appointmentId;
});
--- FILE: lib/features/agenda/providers/drag_layer_link_provider.dart ---
import 'dart:async';

import 'package:flutter/widgets.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Gestisce il LayerLink del body (ancora per i feedback)
class DragLayerLinkNotifier extends Notifier<LayerLink> {
  @override
  LayerLink build() => LayerLink();

  void reset() => state = LayerLink();
  void resetOnMicrotask() {
    Future.microtask(() => state = LayerLink());
  }
}

final dragLayerLinkProvider =
    NotifierProvider<DragLayerLinkNotifier, LayerLink>(
      DragLayerLinkNotifier.new,
    );

/// üîπ Gestisce il RenderBox del body (area scrollabile dell‚Äôagenda)
class DragBodyBoxNotifier extends Notifier<RenderBox?> {
  @override
  RenderBox? build() => null;

  void set(RenderBox box) => state = box;
  void scheduleClear() {
    Future.microtask(() => state = null);
  }
}

final dragBodyBoxProvider = NotifierProvider<DragBodyBoxNotifier, RenderBox?>(
  DragBodyBoxNotifier.new,
);
--- FILE: lib/features/agenda/providers/initial_scroll_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Provider per tracciare se √® stata effettuata la prima apertura dell'agenda.
/// Lo scroll automatico all'orario corrente avviene SOLO alla prima apertura.
class InitialScrollDoneNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  /// Marca lo scroll iniziale come completato.
  void markDone() {
    state = true;
  }

  /// Reset (usato quando si cambia business).
  void reset() {
    state = false;
  }
}

final initialScrollDoneProvider =
    NotifierProvider<InitialScrollDoneNotifier, bool>(
      InitialScrollDoneNotifier.new,
    );

/// Provider per mantenere l'offset di scroll verticale dell'agenda.
/// Persiste anche quando il widget viene ricreato.
class AgendaVerticalOffsetNotifier extends Notifier<double?> {
  @override
  double? build() => null; // null = usa l'orario corrente

  void set(double offset) {
    state = offset;
  }

  void reset() {
    state = null;
  }
}

final agendaVerticalOffsetProvider =
    NotifierProvider<AgendaVerticalOffsetNotifier, double?>(
      AgendaVerticalOffsetNotifier.new,
    );
--- FILE: lib/features/agenda/providers/staff_slot_availability_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/availability_exception.dart';
import '../../staff/presentation/staff_availability_screen.dart';
import '../../staff/providers/availability_exceptions_provider.dart';
import 'date_range_provider.dart';
import 'layout_config_provider.dart';

/// Provider che fornisce la disponibilit√† degli slot per uno staff specifico
/// in base alla data corrente dell'agenda.
///
/// La disponibilit√† finale √® calcolata come:
/// 1. Base: template settimanale (es. Lun-Ven 09:00-18:00)
/// 2. + Eccezioni "available": aggiungono slot disponibili
/// 3. - Eccezioni "unavailable": rimuovono slot disponibili
///
/// Ritorna un `Set<int>` contenente gli indici degli slot DISPONIBILI.
/// - Set vuoto = nessuna disponibilit√† (staff non lavora quel giorno)
/// - Se non ci sono dati configurati, lo staff √® considerato NON disponibile (comportamento restrittivo)
final staffSlotAvailabilityProvider = Provider.family<Set<int>, int>((
  ref,
  staffId,
) {
  final agendaDate = ref.watch(agendaDateProvider);
  final asyncByStaff = ref.watch(staffAvailabilityByStaffProvider);
  final layoutConfig = ref.watch(layoutConfigProvider);

  // Determina il giorno della settimana (1 = Luned√¨, 7 = Domenica)
  final dayOfWeek = agendaDate.weekday;

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // 1Ô∏è‚É£ BASE: Template settimanale
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  Set<int> baseSlots;

  final allData = asyncByStaff.value;
  if (allData == null) {
    baseSlots = <int>{};
  } else {
    final staffData = allData[staffId];
    if (staffData == null || !staffData.containsKey(dayOfWeek)) {
      baseSlots = <int>{};
    } else {
      baseSlots = Set<int>.from(staffData[dayOfWeek]!);
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // 2Ô∏è‚É£ ECCEZIONI: Applica modifiche per la data specifica
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  final exceptions = ref.watch(
    exceptionsForStaffOnDateProvider((staffId: staffId, date: agendaDate)),
  );

  if (exceptions.isEmpty) {
    return baseSlots;
  }

  // Applica le eccezioni in ordine
  Set<int> finalSlots = Set<int>.from(baseSlots);

  for (final exception in exceptions) {
    final exceptionSlots = exception.toSlotIndices(
      minutesPerSlot: layoutConfig.minutesPerSlot,
      totalSlotsPerDay: layoutConfig.totalSlots,
    );

    if (exception.type == AvailabilityExceptionType.available) {
      // AGGIUNGE disponibilit√† (es. turno extra)
      finalSlots = finalSlots.union(exceptionSlots);
    } else {
      // RIMUOVE disponibilit√† (es. ferie, malattia)
      finalSlots = finalSlots.difference(exceptionSlots);
    }
  }

  return finalSlots;
});

/// Provider che verifica se uno slot specifico √® disponibile.
/// Pi√π efficiente per query puntuali.
final isSlotAvailableProvider =
    Provider.family<bool, ({int staffId, int slotIndex})>((ref, params) {
      final availableSlots = ref.watch(
        staffSlotAvailabilityProvider(params.staffId),
      );

      // Se il set √® vuoto, lo staff non √® disponibile
      if (availableSlots.isEmpty) {
        return false;
      }

      return availableSlots.contains(params.slotIndex);
    });

/// Provider che raggruppa gli slot non disponibili consecutivi
/// per ottimizzare il rendering (un solo widget per range).
///
/// Ritorna una lista di (startIndex, count) per ogni range non disponibile.
final unavailableSlotRangesProvider =
    Provider.family<List<({int startIndex, int count})>, int>((ref, staffId) {
      final availableSlots = ref.watch(staffSlotAvailabilityProvider(staffId));
      final layoutConfig = ref.watch(layoutConfigProvider);
      final totalSlots = layoutConfig.totalSlots;

      // Se il set √® vuoto, l'intera giornata √® non disponibile
      if (availableSlots.isEmpty) {
        return [(startIndex: 0, count: totalSlots)];
      }

      final List<({int startIndex, int count})> ranges = [];
      int? rangeStart;
      int rangeCount = 0;

      for (int i = 0; i < totalSlots; i++) {
        final isAvailable = availableSlots.contains(i);

        if (!isAvailable) {
          // Slot non disponibile
          if (rangeStart == null) {
            rangeStart = i;
            rangeCount = 1;
          } else {
            rangeCount++;
          }
        } else {
          // Slot disponibile: chiudi il range precedente se esiste
          if (rangeStart != null) {
            ranges.add((startIndex: rangeStart, count: rangeCount));
            rangeStart = null;
            rangeCount = 0;
          }
        }
      }

      // Chiudi l'ultimo range se necessario
      if (rangeStart != null) {
        ranges.add((startIndex: rangeStart, count: rangeCount));
      }

      return ranges;
    });
--- FILE: lib/features/agenda/providers/staff_filter_providers.dart ---
import 'package:agenda_backend/core/services/preferences_service.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/staff.dart';
import '../domain/staff_filter_mode.dart';
import 'business_providers.dart';
import 'staff_slot_availability_provider.dart';

/// Provider per la modalit√† di filtro staff corrente.
final staffFilterModeProvider =
    NotifierProvider<StaffFilterModeNotifier, StaffFilterMode>(
      StaffFilterModeNotifier.new,
    );

class StaffFilterModeNotifier extends Notifier<StaffFilterMode> {
  @override
  StaffFilterMode build() {
    final businessId = ref.watch(currentBusinessIdProvider);
    if (businessId <= 0) return StaffFilterMode.allTeam;

    // Carica da preferenze salvate
    final prefs = ref.watch(preferencesServiceProvider);
    final saved = prefs.getStaffFilterMode(businessId);
    if (saved != null) {
      return StaffFilterMode.values.firstWhere(
        (m) => m.name == saved,
        orElse: () => StaffFilterMode.allTeam,
      );
    }
    return StaffFilterMode.allTeam;
  }

  void set(StaffFilterMode mode) {
    state = mode;
    // Salva in preferenze
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId > 0) {
      ref
          .read(preferencesServiceProvider)
          .setStaffFilterMode(businessId, mode.name);
    }
  }
}

/// Provider per gli ID degli staff selezionati manualmente.
final selectedStaffIdsProvider =
    NotifierProvider<SelectedStaffIdsNotifier, Set<int>>(
      SelectedStaffIdsNotifier.new,
    );

class SelectedStaffIdsNotifier extends Notifier<Set<int>> {
  @override
  Set<int> build() {
    final businessId = ref.watch(currentBusinessIdProvider);
    if (businessId <= 0) return {};

    // Carica da preferenze salvate
    final prefs = ref.watch(preferencesServiceProvider);
    final saved = prefs.getSelectedStaffIds(businessId);

    // Valida gli ID contro lo staff esistente nella location corrente
    final allStaff = ref.watch(staffForCurrentLocationProvider);
    final validIds = allStaff.map((s) => s.id).toSet();

    // Filtra solo gli ID che esistono ancora
    final validSavedIds = saved.where((id) => validIds.contains(id)).toSet();

    // Se c'erano ID salvati ma ora sono tutti invalidi, pulisci le preferenze
    if (saved.isNotEmpty && validSavedIds.isEmpty) {
      _saveAsync(businessId, {});
    }

    return validSavedIds;
  }

  void _save() {
    final businessId = ref.read(currentBusinessIdProvider);
    if (businessId > 0) {
      ref
          .read(preferencesServiceProvider)
          .setSelectedStaffIds(businessId, state);
    }
  }

  // Versione async per cleanup
  void _saveAsync(int businessId, Set<int> ids) {
    ref.read(preferencesServiceProvider).setSelectedStaffIds(businessId, ids);
  }

  void toggle(int staffId) {
    if (state.contains(staffId)) {
      state = {...state}..remove(staffId);
    } else {
      state = {...state, staffId};
    }
    _save();
  }

  void selectAll(List<Staff> staff) {
    state = staff.map((s) => s.id).toSet();
    _save();
  }

  void clear() {
    state = {};
    _save();
  }

  void setFromList(List<int> ids) {
    state = ids.toSet();
    _save();
  }
}

/// Provider che restituisce gli ID dello staff di turno per il giorno corrente.
final onDutyStaffIdsProvider = Provider<Set<int>>((ref) {
  final allStaff = ref.watch(staffForCurrentLocationProvider);
  final onDutyIds = <int>{};

  for (final staff in allStaff) {
    final availableSlots = ref.watch(staffSlotAvailabilityProvider(staff.id));
    // Staff √® di turno se ha almeno uno slot disponibile nel giorno,
    // incluse eventuali eccezioni.
    if (availableSlots.isNotEmpty) {
      onDutyIds.add(staff.id);
    }
  }

  return onDutyIds;
});

/// Provider che restituisce lo staff filtrato in base alla modalit√† selezionata.
final filteredStaffProvider = Provider<List<Staff>>((ref) {
  final mode = ref.watch(staffFilterModeProvider);
  final allStaff = ref.watch(staffForCurrentLocationProvider);
  final selectedIds = ref.watch(selectedStaffIdsProvider);
  final onDutyIds = ref.watch(onDutyStaffIdsProvider);

  switch (mode) {
    case StaffFilterMode.allTeam:
      return allStaff;

    case StaffFilterMode.onDutyTeam:
      // Restituisce solo lo staff di turno (anche lista vuota se nessuno √® di turno)
      return allStaff.where((s) => onDutyIds.contains(s.id)).toList();

    case StaffFilterMode.custom:
      // Restituisce solo gli staff selezionati (anche lista vuota se nessuno selezionato)
      return allStaff.where((s) => selectedIds.contains(s.id)).toList();
  }
});
--- FILE: lib/features/agenda/data/bookings_api.dart ---
import '../../../core/network/api_client.dart';
import '../domain/booking_response.dart';

/// Request item per creazione booking con staff/orario per ogni servizio
/// Include campi opzionali per override dei valori di default del servizio
class BookingItemRequest {
  final int serviceId;
  final int staffId;
  final String startTime;
  // Optional overrides (if null, backend uses service defaults)
  final int? serviceVariantId;
  final int? durationMinutes;
  final int? blockedExtraMinutes;
  final int? processingExtraMinutes;
  final double? price;

  const BookingItemRequest({
    required this.serviceId,
    required this.staffId,
    required this.startTime,
    this.serviceVariantId,
    this.durationMinutes,
    this.blockedExtraMinutes,
    this.processingExtraMinutes,
    this.price,
  });

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{
      'service_id': serviceId,
      'staff_id': staffId,
      'start_time': startTime,
    };
    if (serviceVariantId != null) map['service_variant_id'] = serviceVariantId;
    if (durationMinutes != null) map['duration_minutes'] = durationMinutes;
    if (blockedExtraMinutes != null) {
      map['blocked_extra_minutes'] = blockedExtraMinutes;
    }
    if (processingExtraMinutes != null) {
      map['processing_extra_minutes'] = processingExtraMinutes;
    }
    if (price != null) map['price'] = price;
    return map;
  }
}

/// API layer per Bookings - chiamate reali a agenda_core
class BookingsApi {
  final ApiClient _apiClient;

  BookingsApi({required ApiClient apiClient}) : _apiClient = apiClient;

  /// GET /v1/locations/{location_id}/bookings?date=YYYY-MM-DD[&staff_id=X]
  Future<List<BookingResponse>> fetchBookings({
    required int locationId,
    required String date,
    int? staffId,
  }) async {
    final data = await _apiClient.getBookings(
      locationId: locationId,
      date: date,
      staffId: staffId,
    );
    final List<dynamic> items = data['bookings'] ?? [];
    return items
        .map((json) => BookingResponse.fromJson(json as Map<String, dynamic>))
        .toList();
  }

  /// GET /v1/locations/{location_id}/bookings/{booking_id}
  Future<BookingResponse> fetchBooking({
    required int locationId,
    required int bookingId,
  }) async {
    final data = await _apiClient.getBooking(
      locationId: locationId,
      bookingId: bookingId,
    );
    return BookingResponse.fromJson(data);
  }

  /// POST /v1/locations/{location_id}/bookings
  Future<BookingResponse> createBooking({
    required int locationId,
    required String idempotencyKey,
    required List<int> serviceIds,
    required String startTime,
    int? staffId,
    int? clientId,
    String? notes,
  }) async {
    final data = await _apiClient.createBooking(
      locationId: locationId,
      idempotencyKey: idempotencyKey,
      serviceIds: serviceIds,
      startTime: startTime,
      staffId: staffId,
      clientId: clientId,
      notes: notes,
    );
    return BookingResponse.fromJson(data);
  }

  /// POST /v1/locations/{location_id}/bookings (new items format)
  Future<BookingResponse> createBookingWithItems({
    required int locationId,
    required String idempotencyKey,
    required List<BookingItemRequest> items,
    int? clientId,
    String? notes,
  }) async {
    final data = await _apiClient.createBookingWithItems(
      locationId: locationId,
      idempotencyKey: idempotencyKey,
      items: items.map((i) => i.toJson()).toList(),
      clientId: clientId,
      notes: notes,
    );
    return BookingResponse.fromJson(data);
  }

  /// PUT /v1/locations/{location_id}/bookings/{booking_id}
  Future<void> updateBooking({
    required int locationId,
    required int bookingId,
    String? status,
    String? notes,
    int? clientId,
    bool clearClient = false,
  }) async {
    await _apiClient.updateBooking(
      locationId: locationId,
      bookingId: bookingId,
      status: status,
      notes: notes,
      clientId: clientId,
      clearClient: clearClient,
    );
  }

  /// DELETE /v1/locations/{location_id}/bookings/{booking_id}
  Future<void> deleteBooking({
    required int locationId,
    required int bookingId,
  }) async {
    await _apiClient.deleteBooking(
      locationId: locationId,
      bookingId: bookingId,
    );
  }

  /// GET /v1/locations/{location_id}/appointments?date=YYYY-MM-DD
  Future<List<Map<String, dynamic>>> fetchAppointments({
    required int locationId,
    required String date,
  }) async {
    final data = await _apiClient.getAppointments(
      locationId: locationId,
      date: date,
    );
    final List<dynamic> items = data['appointments'] ?? [];
    return items.map((json) => json as Map<String, dynamic>).toList();
  }

  /// PATCH /v1/locations/{location_id}/appointments/{id}
  Future<void> updateAppointment({
    required int locationId,
    required int appointmentId,
    String? startTime,
    String? endTime,
    int? staffId,
    int? serviceId,
    int? serviceVariantId,
    String? serviceNameSnapshot,
    int? clientId,
    String? clientName,
    String? clientNameSnapshot,
    int? extraBlockedMinutes,
    int? extraProcessingMinutes,
  }) async {
    await _apiClient.updateAppointment(
      locationId: locationId,
      appointmentId: appointmentId,
      startTime: startTime,
      endTime: endTime,
      staffId: staffId,
      serviceId: serviceId,
      serviceVariantId: serviceVariantId,
      serviceNameSnapshot: serviceNameSnapshot,
      clientId: clientId,
      clientName: clientName,
      clientNameSnapshot: clientNameSnapshot,
      extraBlockedMinutes: extraBlockedMinutes,
      extraProcessingMinutes: extraProcessingMinutes,
    );
  }

  /// POST /v1/locations/{location_id}/appointments/{id}/cancel
  Future<void> cancelAppointment({
    required int locationId,
    required int appointmentId,
  }) async {
    await _apiClient.cancelAppointment(
      locationId: locationId,
      appointmentId: appointmentId,
    );
  }

  /// POST /v1/bookings/{booking_id}/items
  /// Add a new booking item (appointment) to an existing booking
  Future<Map<String, dynamic>> addBookingItem({
    required int bookingId,
    required int locationId,
    required int staffId,
    required int serviceId,
    required int serviceVariantId,
    required String startTime,
    required String endTime,
    String? serviceNameSnapshot,
    String? clientNameSnapshot,
    double? price,
    int? extraBlockedMinutes,
    int? extraProcessingMinutes,
  }) async {
    return _apiClient.addBookingItem(
      bookingId: bookingId,
      locationId: locationId,
      staffId: staffId,
      serviceId: serviceId,
      serviceVariantId: serviceVariantId,
      startTime: startTime,
      endTime: endTime,
      serviceNameSnapshot: serviceNameSnapshot,
      clientNameSnapshot: clientNameSnapshot,
      price: price,
      extraBlockedMinutes: extraBlockedMinutes,
      extraProcessingMinutes: extraProcessingMinutes,
    );
  }

  /// DELETE /v1/bookings/{booking_id}/items/{item_id}
  /// Delete a single booking item (appointment) from a booking
  Future<void> deleteBookingItem({
    required int bookingId,
    required int itemId,
  }) async {
    await _apiClient.deleteBookingItem(bookingId: bookingId, itemId: itemId);
  }
}
--- FILE: lib/features/agenda/data/bookings_repository.dart ---
import '../../../core/models/appointment.dart';
import '../../../core/network/api_client.dart';
import '../domain/booking_response.dart';
import 'bookings_api.dart';

/// Repository per gestione Bookings
/// Converte BookingResponse API in Appointment per uso interno
class BookingsRepository {
  BookingsRepository({required ApiClient apiClient})
    : _api = BookingsApi(apiClient: apiClient);

  final BookingsApi _api;

  /// Carica gli appuntamenti per una location in una data specifica
  Future<List<Appointment>> getAppointments({
    required int locationId,
    required int businessId,
    required DateTime date,
    int? staffId,
  }) async {
    final dateStr =
        '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';

    // Usa la nuova API appointments che ritorna direttamente gli appointment items
    try {
      final appointments = await _api.fetchAppointments(
        locationId: locationId,
        date: dateStr,
      );

      return appointments
          .map((item) => _appointmentFromJson(item, businessId))
          .toList();
    } catch (e) {
      // Fallback: usa bookings API se appointments non disponibile
      final bookings = await _api.fetchBookings(
        locationId: locationId,
        date: dateStr,
        staffId: staffId,
      );

      final appointments = <Appointment>[];
      for (final booking in bookings) {
        for (final item in booking.items) {
          appointments.add(_toAppointment(booking, item, businessId));
        }
      }
      return appointments;
    }
  }

  /// Crea un nuovo booking (formato legacy con staff singolo per tutti i servizi)
  Future<BookingResponse> createBooking({
    required int locationId,
    required String idempotencyKey,
    required List<int> serviceIds,
    required String startTime,
    int? staffId,
    int? clientId,
    String? notes,
  }) async {
    return _api.createBooking(
      locationId: locationId,
      idempotencyKey: idempotencyKey,
      serviceIds: serviceIds,
      startTime: startTime,
      staffId: staffId,
      clientId: clientId,
      notes: notes,
    );
  }

  /// Crea un nuovo booking con items (staff e orario separati per ogni servizio)
  Future<BookingResponse> createBookingWithItems({
    required int locationId,
    required String idempotencyKey,
    required List<BookingItemRequest> items,
    int? clientId,
    String? notes,
  }) async {
    return _api.createBookingWithItems(
      locationId: locationId,
      idempotencyKey: idempotencyKey,
      items: items,
      clientId: clientId,
      notes: notes,
    );
  }

  /// Aggiorna un booking esistente
  Future<void> updateBooking({
    required int locationId,
    required int bookingId,
    String? status,
    String? notes,
    int? clientId,
    bool clearClient = false,
  }) {
    return _api.updateBooking(
      locationId: locationId,
      bookingId: bookingId,
      status: status,
      notes: notes,
      clientId: clientId,
      clearClient: clearClient,
    );
  }

  /// Cancella un booking
  Future<void> deleteBooking({
    required int locationId,
    required int bookingId,
  }) async {
    return _api.deleteBooking(locationId: locationId, bookingId: bookingId);
  }

  /// Aggiorna un appuntamento (reschedule)
  Future<void> updateAppointment({
    required int locationId,
    required int appointmentId,
    DateTime? startTime,
    DateTime? endTime,
    int? staffId,
    int? serviceId,
    int? serviceVariantId,
    String? serviceNameSnapshot,
    int? clientId,
    String? clientName,
    String? clientNameSnapshot,
    int? extraBlockedMinutes,
    int? extraProcessingMinutes,
  }) async {
    return _api.updateAppointment(
      locationId: locationId,
      appointmentId: appointmentId,
      startTime: startTime?.toIso8601String(),
      endTime: endTime?.toIso8601String(),
      staffId: staffId,
      serviceId: serviceId,
      serviceVariantId: serviceVariantId,
      serviceNameSnapshot: serviceNameSnapshot,
      clientId: clientId,
      clientName: clientName,
      clientNameSnapshot: clientNameSnapshot,
      extraBlockedMinutes: extraBlockedMinutes,
      extraProcessingMinutes: extraProcessingMinutes,
    );
  }

  /// Cancella un appuntamento
  Future<void> cancelAppointment({
    required int locationId,
    required int appointmentId,
  }) async {
    return _api.cancelAppointment(
      locationId: locationId,
      appointmentId: appointmentId,
    );
  }

  /// Aggiunge un nuovo booking item (appointment) a un booking esistente
  Future<Appointment> addBookingItem({
    required int bookingId,
    required int businessId,
    required int locationId,
    required int staffId,
    required int serviceId,
    required int serviceVariantId,
    required DateTime startTime,
    required DateTime endTime,
    String? serviceNameSnapshot,
    String? clientNameSnapshot,
    double? price,
    int? extraBlockedMinutes,
    int? extraProcessingMinutes,
  }) async {
    final json = await _api.addBookingItem(
      bookingId: bookingId,
      locationId: locationId,
      staffId: staffId,
      serviceId: serviceId,
      serviceVariantId: serviceVariantId,
      startTime: startTime.toIso8601String(),
      endTime: endTime.toIso8601String(),
      serviceNameSnapshot: serviceNameSnapshot,
      clientNameSnapshot: clientNameSnapshot,
      price: price,
      extraBlockedMinutes: extraBlockedMinutes,
      extraProcessingMinutes: extraProcessingMinutes,
    );
    return _appointmentFromJson(json, businessId);
  }

  /// Elimina un singolo booking item (appointment) da un booking
  Future<void> deleteBookingItem({
    required int bookingId,
    required int itemId,
  }) async {
    await _api.deleteBookingItem(bookingId: bookingId, itemId: itemId);
  }

  /// Converte JSON appointment API in Appointment interno
  Appointment _appointmentFromJson(Map<String, dynamic> json, int businessId) {
    return Appointment(
      id: json['id'] as int,
      bookingId: json['booking_id'] as int,
      businessId: json['business_id'] as int? ?? businessId,
      locationId: json['location_id'] as int,
      staffId: json['staff_id'] as int,
      serviceId: json['service_id'] as int? ?? 0,
      serviceVariantId: json['service_variant_id'] as int,
      clientId: json['client_id'] as int?,
      clientName: json['client_name'] as String? ?? '',
      serviceName: json['service_name'] as String? ?? 'Servizio',
      startTime: DateTime.parse(json['start_time'] as String),
      endTime: DateTime.parse(json['end_time'] as String),
      price: null, // Non sempre presente
      extraMinutes: json['extra_blocked_minutes'] as int?,
      extraMinutesType:
          (json['extra_blocked_minutes'] as int?) != null &&
              json['extra_blocked_minutes'] > 0
          ? ExtraMinutesType.blocked
          : null,
      extraBlockedMinutes: json['extra_blocked_minutes'] as int? ?? 0,
      extraProcessingMinutes: json['extra_processing_minutes'] as int? ?? 0,
    );
  }

  /// Converte un booking item API in Appointment interno
  Appointment _toAppointment(
    BookingResponse booking,
    BookingItemResponse item,
    int businessId,
  ) {
    return Appointment(
      id: item.id,
      bookingId: booking.id,
      businessId: businessId,
      locationId: booking.locationId,
      staffId: item.staffId,
      serviceId: item.serviceId,
      serviceVariantId: item.serviceVariantId ?? item.serviceId,
      clientId: booking.clientId,
      clientName: booking.clientName ?? '',
      serviceName: item.serviceName ?? 'Service ${item.serviceId}',
      startTime: item.startDateTime,
      endTime: item.endDateTime,
      price: item.price,
    );
  }
}
--- FILE: lib/features/agenda/domain/config/agenda_theme.dart ---
import 'package:flutter/material.dart';

/// Tema visivo centralizzato per l'agenda.
/// Definisce colori, spessori, altezze e stili coerenti
/// per tutti i componenti della vista agenda.
///
/// In futuro potrai adattarlo dinamicamente (dark mode, branding, ecc.)
class AgendaTheme {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üé® COLORI BASE
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Colore principale per i separatori verticali/orizzontali
  static Color get dividerColor => Colors.grey.shade300;

  /// Colore per ombre leggere o bordi di separazione
  static Color get shadowColor => Colors.black.withOpacity(0.5);

  /// Colore di sfondo per lo slot orario
  static const Color backgroundHourSlot = Colors.white;

  /// Colore di sfondo per le intestazioni staff
  static Color staffHeaderBackground(Color base) =>
      base.withValues(alpha: 0.15);

  /// Colore del testo nelle intestazioni staff
  static const Color staffHeaderTextColor = Colors.black87;

  /// Colore del bordo di un appuntamento (card)
  static Color get appointmentBorder => Colors.grey.shade400;

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üíß OMBRE & BORDI
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Ombra leggera usata nei divider verticali
  static BoxShadow get subtleShadow =>
      BoxShadow(color: shadowColor, offset: const Offset(1, 0), blurRadius: 2);

  /// Stile base per i separatori verticali
  static BoxDecoration get verticalDividerDecoration =>
      BoxDecoration(color: dividerColor, boxShadow: [subtleShadow]);

  /// Stile base per i separatori orizzontali
  static BoxDecoration get horizontalDividerDecoration =>
      const BoxDecoration(color: Colors.grey);

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üß± STILI TESTO
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  static const TextStyle staffHeaderTextStyle = TextStyle(
    fontWeight: FontWeight.bold,
    color: staffHeaderTextColor,
  );

  static const TextStyle hourTextStyle = TextStyle(
    fontSize: 13,
    fontWeight: FontWeight.bold,
    color: Colors.black87,
  );

  static const TextStyle appointmentTextStyle = TextStyle(
    fontSize: 14,
    color: Colors.black87,
  );

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üëª EFFETTO DRAG / FANTASMA
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Opacit√† del "fantasma" lasciato dalla card originale durante il drag.
  /// Regola questo valore per rendere il ghost pi√π o meno visibile.
  static const double ghostOpacity = 0.50;

  /// Durata dell'effetto fade-out del fantasma dopo il rilascio.
  /// Aumentala per una dissolvenza pi√π lenta e visibile.
  static const Duration ghostFadeDuration = Duration(milliseconds: 500);

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üö´ SLOT NON DISPONIBILI
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Colore delle linee diagonali per slot non disponibili.
  static Color unavailablePatternColor(ColorScheme scheme) =>
      scheme.onSurface.withOpacity(0.25);

  /// Colore di sfondo per slot non disponibili.
  static Color unavailableBackgroundColor(ColorScheme scheme) =>
      scheme.surfaceContainerHighest.withOpacity(0.6);

  /// Spaziatura tra le linee del pattern (in pixel).
  static const double unavailablePatternSpacing = 6.0;

  /// Spessore delle linee del pattern (in pixel).
  static const double unavailablePatternLineWidth = 1.5;
}
--- FILE: lib/features/agenda/domain/config/layout_config.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:flutter/material.dart';

/// Immutable snapshot of the current layout dimensions used by the agenda.
class LayoutConfig {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üìê Costanti strutturali
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  static const int hoursInDay = 24;
  static const List<int> slotDurationOptions = [15, 30, 60, 120];
  static const int minutesPerSlotConst = 15;

  static const double horizontalPadding = 8;
  static const double verticalPadding = 4;
  static const double columnInnerPadding = 2;
  static const double minColumnWidthMobile = 140;
  static const double minColumnWidthDesktop = 160;
  static const double borderRadius = 8;
  static const double borderWidth = 1;
  static const int maxVisibleStaff = 6;

  /// Larghezza della fascia laterale per il pulsante "+" sugli slot occupati
  static const double addButtonStripWidth = 28;

  static const double defaultHourColumnWidth = 60;
  static const double defaultHeaderHeight = 50;
  static const double defaultSlotHeight = 30;

  static const LayoutConfig initial = LayoutConfig(
    slotHeight: defaultSlotHeight,
    headerHeight: defaultHeaderHeight,
    hourColumnWidth: defaultHourColumnWidth,
    minutesPerSlot: minutesPerSlotConst,
    useClusterMaxConcurrency: true,
    useServiceColorsForAppointments: true,
    enableOccupiedSlotStrip: false,
    showTopbarAddLabel: false,
  );

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üìè Stato dinamico
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  final double slotHeight;
  final double headerHeight;
  final double hourColumnWidth;
  final int minutesPerSlot;
  final bool useClusterMaxConcurrency;
  final bool useServiceColorsForAppointments;

  /// Se true, riserva una fascia laterale quando ci sono slot completamente occupati.
  /// Permette di cliccare sullo spazio libero per creare nuovi appuntamenti.
  final bool enableOccupiedSlotStrip;

  /// Se true, il pulsante "Aggiungi" in topbar mostra anche la label.
  final bool showTopbarAddLabel;

  const LayoutConfig({
    required this.slotHeight,
    required this.headerHeight,
    required this.hourColumnWidth,
    required this.minutesPerSlot,
    required this.useClusterMaxConcurrency,
    required this.useServiceColorsForAppointments,
    required this.enableOccupiedSlotStrip,
    required this.showTopbarAddLabel,
  });

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! LayoutConfig) return false;
    return slotHeight == other.slotHeight &&
        headerHeight == other.headerHeight &&
        hourColumnWidth == other.hourColumnWidth &&
        minutesPerSlot == other.minutesPerSlot &&
        useClusterMaxConcurrency == other.useClusterMaxConcurrency &&
        useServiceColorsForAppointments ==
            other.useServiceColorsForAppointments &&
        enableOccupiedSlotStrip == other.enableOccupiedSlotStrip &&
        showTopbarAddLabel == other.showTopbarAddLabel;
  }

  @override
  int get hashCode => Object.hash(
    slotHeight,
    headerHeight,
    hourColumnWidth,
    minutesPerSlot,
    useClusterMaxConcurrency,
    useServiceColorsForAppointments,
    enableOccupiedSlotStrip,
    showTopbarAddLabel,
  );

  LayoutConfig copyWith({
    double? slotHeight,
    double? headerHeight,
    double? hourColumnWidth,
    int? minutesPerSlot,
    bool? useClusterMaxConcurrency,
    bool? useServiceColorsForAppointments,
    bool? enableOccupiedSlotStrip,
    bool? showTopbarAddLabel,
  }) {
    return LayoutConfig(
      slotHeight: slotHeight ?? this.slotHeight,
      headerHeight: headerHeight ?? this.headerHeight,
      hourColumnWidth: hourColumnWidth ?? this.hourColumnWidth,
      minutesPerSlot: minutesPerSlot ?? this.minutesPerSlot,
      useClusterMaxConcurrency:
          useClusterMaxConcurrency ?? this.useClusterMaxConcurrency,
      useServiceColorsForAppointments:
          useServiceColorsForAppointments ??
          this.useServiceColorsForAppointments,
      enableOccupiedSlotStrip:
          enableOccupiedSlotStrip ?? this.enableOccupiedSlotStrip,
      showTopbarAddLabel: showTopbarAddLabel ?? this.showTopbarAddLabel,
    );
  }

  int get totalSlots => (hoursInDay * 60 ~/ minutesPerSlot);

  double get totalHeight => totalSlots * slotHeight;

  static bool isValidSlotDuration(int minutes) =>
      slotDurationOptions.contains(minutes);

  /// Calcola quanti staff possono essere mostrati in base alla larghezza schermo.
  int computeMaxVisibleStaff(
    double contentWidth, {
    required AppFormFactor formFactor,
  }) {
    final minWidth = formFactor == AppFormFactor.mobile
        ? minColumnWidthMobile
        : minColumnWidthDesktop;

    final usableWidth = contentWidth.clamp(0, double.infinity);
    final maxStaff = (usableWidth / minWidth).floor();
    return maxStaff.clamp(1, maxVisibleStaff);
  }

  /// Calcola dinamicamente la larghezza di ogni colonna staff.
  double computeAdaptiveColumnWidth({
    required double contentWidth,
    required int visibleStaffCount,
    required AppFormFactor formFactor,
  }) {
    final minWidth = formFactor == AppFormFactor.mobile
        ? minColumnWidthMobile
        : minColumnWidthDesktop;

    if (visibleStaffCount <= 0) {
      return minWidth;
    }

    final usableWidth = contentWidth.clamp(0, double.infinity);
    final idealWidth = usableWidth / visibleStaffCount;

    return idealWidth < minWidth ? minWidth : idealWidth;
  }

  /// Altezza header ‚Äúresponsive‚Äù basata sulla larghezza finestra.
  static double headerHeightFor(BuildContext context) {
    final width = MediaQuery.of(context).size.width;
    return headerHeightForWidth(width);
  }

  static double headerHeightForWidth(double width) {
    if (width >= 1024) return 110; // Desktop
    if (width >= 600) return 95; // Tablet
    return 80; // Mobile
  }

  /// Dimensione avatar staff "responsive" basata sulla larghezza finestra.
  static double avatarSizeFor(BuildContext context) {
    final width = MediaQuery.of(context).size.width;
    return avatarSizeForWidth(width);
  }

  static double avatarSizeForWidth(double width) {
    if (width >= 1024) return 65; // Desktop
    if (width >= 600) return 57; // Tablet
    return 52; // Mobile
  }
}
--- FILE: lib/features/agenda/domain/booking_response.dart ---
/// Risposta API per un booking con i suoi items
class BookingResponse {
  final int id;
  final int businessId;
  final int locationId;
  final int? clientId;
  final int? userId;
  final String? clientName;
  final String? notes;
  final String status;
  final String source;
  final double totalPrice;
  final int totalDurationMinutes;
  final String createdAt;
  final String updatedAt;
  final List<BookingItemResponse> items;

  const BookingResponse({
    required this.id,
    required this.businessId,
    required this.locationId,
    this.clientId,
    this.userId,
    this.clientName,
    this.notes,
    required this.status,
    required this.source,
    required this.totalPrice,
    required this.totalDurationMinutes,
    required this.createdAt,
    required this.updatedAt,
    required this.items,
  });

  factory BookingResponse.fromJson(Map<String, dynamic> json) {
    final itemsList = json['items'] as List<dynamic>? ?? [];
    return BookingResponse(
      id: json['id'] as int,
      businessId: json['business_id'] as int,
      locationId: json['location_id'] as int,
      clientId: json['client_id'] as int?,
      userId: json['user_id'] as int?,
      clientName: json['client_name'] as String?,
      notes: json['notes'] as String?,
      status: json['status'] as String? ?? 'pending',
      source: json['source'] as String? ?? 'online',
      totalPrice: (json['total_price'] as num?)?.toDouble() ?? 0.0,
      totalDurationMinutes: json['total_duration_minutes'] as int? ?? 0,
      createdAt: json['created_at'] as String? ?? '',
      updatedAt: json['updated_at'] as String? ?? '',
      items: itemsList
          .map((i) => BookingItemResponse.fromJson(i as Map<String, dynamic>))
          .toList(),
    );
  }
}

/// Singolo item di un booking (un servizio prenotato)
class BookingItemResponse {
  final int id;
  final int? bookingId;
  final int serviceId;
  final int? serviceVariantId;
  final int staffId;
  final String startTime;
  final String endTime;
  final double price;
  final int durationMinutes;
  final String? serviceName;
  final String? staffDisplayName;

  const BookingItemResponse({
    required this.id,
    this.bookingId,
    required this.serviceId,
    this.serviceVariantId,
    required this.staffId,
    required this.startTime,
    required this.endTime,
    required this.price,
    required this.durationMinutes,
    this.serviceName,
    this.staffDisplayName,
  });

  factory BookingItemResponse.fromJson(Map<String, dynamic> json) {
    return BookingItemResponse(
      id: json['id'] as int,
      bookingId: json['booking_id'] as int?,
      serviceId: json['service_id'] as int,
      serviceVariantId: json['service_variant_id'] as int?,
      staffId: json['staff_id'] as int,
      startTime: json['start_time'] as String,
      endTime: json['end_time'] as String,
      price: (json['price'] as num?)?.toDouble() ?? 0.0,
      durationMinutes: json['duration_minutes'] as int? ?? 0,
      serviceName: json['service_name'] as String?,
      staffDisplayName:
          (json['staff_display_name'] ?? json['staff_name']) as String?,
    );
  }

  /// Converte start_time in DateTime
  DateTime get startDateTime => DateTime.parse(startTime);

  /// Converte end_time in DateTime
  DateTime get endDateTime => DateTime.parse(endTime);
}
--- FILE: lib/features/agenda/domain/staff_filter_mode.dart ---
/// Modalit√† di filtro per lo staff nell'agenda.
enum StaffFilterMode {
  /// Mostra tutto il team (tutti gli staff della location).
  allTeam,

  /// Mostra solo il team di turno (staff con disponibilit√† nel giorno selezionato).
  onDutyTeam,

  /// Selezione manuale di uno o pi√π membri dello staff.
  custom,
}
--- FILE: lib/features/agenda/domain/service_item_data.dart ---
import 'package:flutter/material.dart';

/// Rappresenta un singolo servizio in una prenotazione multi-servizio.
/// Usato internamente nel form di creazione/modifica prenotazione.
class ServiceItemData {
  final String key; // Chiave univoca per identificare l'item nella lista
  final int? appointmentId; // ID dell'appuntamento originale (null se nuovo)
  final int? serviceId;
  final int? serviceVariantId;
  final int? staffId;
  final TimeOfDay startTime;
  final int durationMinutes;
  final int blockedExtraMinutes;
  final int processingExtraMinutes;

  const ServiceItemData({
    required this.key,
    this.appointmentId,
    this.serviceId,
    this.serviceVariantId,
    this.staffId,
    required this.startTime,
    this.durationMinutes = 30,
    this.blockedExtraMinutes = 0,
    this.processingExtraMinutes = 0,
  });

  /// Calcola l'orario di fine basato su startTime e durationMinutes
  TimeOfDay get endTime {
    final totalMinutes =
        startTime.hour * 60 + startTime.minute + durationMinutes;
    return TimeOfDay(
      hour: (totalMinutes ~/ 60) % 24,
      minute: totalMinutes % 60,
    );
  }

  /// Calcola l'orario di fine con durata opzionale esterna (es. da variant)
  TimeOfDay getEndTime([int? externalDuration]) {
    final duration = externalDuration ?? durationMinutes;
    final totalMinutes = startTime.hour * 60 + startTime.minute + duration;
    return TimeOfDay(
      hour: (totalMinutes ~/ 60) % 24,
      minute: totalMinutes % 60,
    );
  }

  /// Calcola il prossimo orario di inizio (per il servizio successivo)
  TimeOfDay get nextStartTime => endTime;

  ServiceItemData copyWith({
    String? key,
    int? appointmentId,
    int? serviceId,
    int? serviceVariantId,
    int? staffId,
    TimeOfDay? startTime,
    int? durationMinutes,
    int? blockedExtraMinutes,
    int? processingExtraMinutes,
  }) {
    return ServiceItemData(
      key: key ?? this.key,
      appointmentId: appointmentId ?? this.appointmentId,
      serviceId: serviceId ?? this.serviceId,
      serviceVariantId: serviceVariantId ?? this.serviceVariantId,
      staffId: staffId ?? this.staffId,
      startTime: startTime ?? this.startTime,
      durationMinutes: durationMinutes ?? this.durationMinutes,
      blockedExtraMinutes: blockedExtraMinutes ?? this.blockedExtraMinutes,
      processingExtraMinutes:
          processingExtraMinutes ?? this.processingExtraMinutes,
    );
  }

  /// Crea una copia con serviceId e staffId resettati a null
  ServiceItemData clearService() {
    return ServiceItemData(
      key: key,
      appointmentId: appointmentId,
      serviceId: null,
      serviceVariantId: null,
      staffId: null,
      startTime: startTime,
      durationMinutes: 30,
      blockedExtraMinutes: 0,
      processingExtraMinutes: 0,
    );
  }

  bool get hasBlockedExtra => blockedExtraMinutes > 0;
  bool get hasProcessingExtra => processingExtraMinutes > 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ServiceItemData &&
          runtimeType == other.runtimeType &&
          key == other.key;

  @override
  int get hashCode => key.hashCode;
}
--- FILE: lib/features/agenda/presentation/screens/helper/layout_geometry_helper.dart ---
import 'dart:math' as math;

class LayoutEntry {
  const LayoutEntry({
    required this.id,
    required this.start,
    required this.end,
  });

  final int id;
  final DateTime start;
  final DateTime end;
}

class EventGeometry {
  const EventGeometry({
    required this.leftFraction,
    required this.widthFraction,
  });

  final double leftFraction;
  final double widthFraction;
}

Map<int, EventGeometry> computeLayoutGeometry(
  List<LayoutEntry> entries, {
  bool useClusterMaxConcurrency = false,
}) {
  if (entries.isEmpty) return const {};

  final sorted = entries.toList()
    ..sort((a, b) => a.start.compareTo(b.start));
  final clusters = <List<LayoutEntry>>[];

  var currentCluster = <LayoutEntry>[];
  DateTime? currentMaxEnd;

  for (final entry in sorted) {
    if (currentCluster.isEmpty) {
      currentCluster = [entry];
      currentMaxEnd = entry.end;
      continue;
    }

    if (entry.start.isBefore(currentMaxEnd!)) {
      currentCluster.add(entry);
      if (entry.end.isAfter(currentMaxEnd)) {
        currentMaxEnd = entry.end;
      }
    } else {
      clusters.add(List<LayoutEntry>.from(currentCluster));
      currentCluster = [entry];
      currentMaxEnd = entry.end;
    }
  }

  if (currentCluster.isNotEmpty) {
    clusters.add(List<LayoutEntry>.from(currentCluster));
  }

  final geometryMap = <int, EventGeometry>{};

  for (final cluster in clusters) {
    final columnAssignments = _assignColumns(cluster);
    final concurrencyMap = _computeConcurrency(cluster);

    if (useClusterMaxConcurrency) {
      final clusterMaxConcurrency =
          concurrencyMap.values.fold<int>(1, math.max);
      final totalColumns =
          math.max(clusterMaxConcurrency, 1); // evita divisione per zero

      final columnMap = <int, List<LayoutEntry>>{};
      for (final entry in cluster) {
        final columnIndex = columnAssignments[entry.id] ?? 0;
        columnMap.putIfAbsent(columnIndex, () => []).add(entry);
      }

      for (final entry in cluster) {
        final columnIndex = columnAssignments[entry.id] ?? 0;
        int widthInColumns = 1;

        while (columnIndex + widthInColumns < totalColumns) {
          final candidateColumn = columnIndex + widthInColumns;
          final occupants = columnMap[candidateColumn];
          final hasOverlap = occupants?.any(
                (other) =>
                    _entriesOverlap(entry, other) &&
                    other.id != entry.id,
              ) ??
              false;

          if (hasOverlap) {
            break;
          }

          widthInColumns++;
        }

        for (int col = columnIndex; col < columnIndex + widthInColumns; col++) {
          final list = columnMap.putIfAbsent(col, () => []);
          if (!list.contains(entry)) {
            list.add(entry);
          }
        }

        final widthFraction = widthInColumns / totalColumns;
        final leftFraction = columnIndex / totalColumns;
        geometryMap[entry.id] = EventGeometry(
          leftFraction: leftFraction,
          widthFraction: widthFraction,
        );
      }
    } else {
      for (final entry in cluster) {
        final concurrency = concurrencyMap[entry.id] ?? 1;
        final widthFraction = 1 / concurrency;
        final columnIndex = columnAssignments[entry.id] ?? 0;
        final leftFraction = columnIndex * widthFraction;
        geometryMap[entry.id] = EventGeometry(
          leftFraction: leftFraction,
          widthFraction: widthFraction,
        );
      }
    }
  }

  return geometryMap;
}

bool _entriesOverlap(LayoutEntry a, LayoutEntry b) {
  if (identical(a, b)) return false;
  return a.start.isBefore(b.end) && a.end.isAfter(b.start);
}

Map<int, int> _assignColumns(List<LayoutEntry> cluster) {
  final assignments = <int, int>{};
  final columnEndTimes = <DateTime>[];

  final ordered = cluster.toList()
    ..sort((a, b) {
      final compareStart = a.start.compareTo(b.start);
      if (compareStart != 0) return compareStart;
      return a.end.compareTo(b.end);
    });

  for (final entry in ordered) {
    int assignedColumn = -1;
    for (int i = 0; i < columnEndTimes.length; i++) {
      if (!entry.start.isBefore(columnEndTimes[i])) {
        assignedColumn = i;
        columnEndTimes[i] = entry.end;
        break;
      }
    }

    if (assignedColumn == -1) {
      assignedColumn = columnEndTimes.length;
      columnEndTimes.add(entry.end);
    }

    assignments[entry.id] = assignedColumn;
  }

  return assignments;
}

Map<int, int> _computeConcurrency(List<LayoutEntry> cluster) {
  final concurrencyMap = <int, int>{};

  for (final entry in cluster) {
    final edges = <_Edge>[];

    for (final other in cluster) {
      final overlapStart = entry.start.isAfter(other.start)
          ? entry.start
          : other.start;
      final overlapEnd = entry.end.isBefore(other.end)
          ? entry.end
          : other.end;

      if (overlapStart.isBefore(overlapEnd)) {
        edges.add(_Edge(overlapStart, 1));
        edges.add(_Edge(overlapEnd, -1));
      }
    }

    edges.sort((a, b) {
      final compare = a.instant.compareTo(b.instant);
      if (compare != 0) return compare;
      if (a.delta == b.delta) return 0;
      return a.delta == -1 ? -1 : 1;
    });

    int active = 0;
    int maxActive = 0;
    for (final edge in edges) {
      active += edge.delta;
      if (active > maxActive) {
        maxActive = active;
      }
    }

    concurrencyMap[entry.id] = math.max(maxActive, 1);
  }

  return concurrencyMap;
}

class _Edge {
  const _Edge(this.instant, this.delta);

  final DateTime instant;
  final int delta;
}
--- FILE: lib/features/agenda/presentation/screens/helper/drag_drop_helper.dart ---
import 'package:flutter/material.dart';

import '/core/models/appointment.dart';
import '../../../domain/config/layout_config.dart';

class DropComputationParams {
  const DropComputationParams({
    required this.appointment,
    required this.layoutConfig,
    required this.columnHeight,
    required this.localPointer,
    required this.dragOffsetY,
    required this.draggedCardHeightPx,
    required this.previewTimes,
  });

  final Appointment appointment;
  final LayoutConfig layoutConfig;
  final double columnHeight;
  final Offset localPointer;
  final double dragOffsetY;
  final double draggedCardHeightPx;
  final (DateTime, DateTime)? previewTimes;
}

class DropComputationResult {
  const DropComputationResult({
    required this.newStart,
    required this.newEnd,
  });

  final DateTime newStart;
  final DateTime newEnd;
}

DropComputationResult computeDropResult(DropComputationParams params) {
  final layoutConfig = params.layoutConfig;
  final slotHeight = layoutConfig.slotHeight;
  final minutesPerSlot = layoutConfig.minutesPerSlot;

  final maxYStartPx =
      (params.columnHeight - params.draggedCardHeightPx)
          .clamp(0, params.columnHeight)
          .toDouble();
  final clampedLocalDy =
      params.localPointer.dy.clamp(0.0, params.columnHeight.toDouble());
  final effectiveDy =
      (clampedLocalDy - params.dragOffsetY).clamp(0.0, maxYStartPx).toDouble();

  final rawTop = params.localPointer.dy - params.dragOffsetY;
  final rawBottom = rawTop + params.draggedCardHeightPx;
  final isAboveBounds = rawTop < 0;
  final isBelowBounds = rawBottom > params.columnHeight;

  final appointment = params.appointment;
  final duration = appointment.endTime.difference(appointment.startTime);
  final durationMinutes = duration.inMinutes;

  final baseDate = DateTime(
    appointment.startTime.year,
    appointment.startTime.month,
    appointment.startTime.day,
  );

  DateTime newStart;
  DateTime newEnd;

  final previewTimes = params.previewTimes;
  if (previewTimes != null) {
    newStart = previewTimes.$1;
    newEnd = previewTimes.$2;
  } else {
    final minutesFromTop =
        (effectiveDy / slotHeight) * minutesPerSlot;
    double roundedMinutes = (minutesFromTop / 5).round() * 5;

    const totalMinutes = LayoutConfig.hoursInDay * 60; // 1440
    final maxStartMinutesNum =
        (totalMinutes - durationMinutes).clamp(0, totalMinutes);

    int startMinutes = roundedMinutes.toInt();
    final maxStartMinutes = maxStartMinutesNum.toInt();

    if (startMinutes > maxStartMinutes) startMinutes = maxStartMinutes;
    if (startMinutes < 0) startMinutes = 0;

    final endMinutes =
        (startMinutes + durationMinutes).clamp(0, totalMinutes).toInt();

    newStart = baseDate.add(Duration(minutes: startMinutes));

    final rawEnd = baseDate.add(Duration(minutes: endMinutes));
    final dayBoundary = baseDate.add(const Duration(days: 1));
    newEnd = rawEnd.isAfter(dayBoundary) ? dayBoundary : rawEnd;
  }

  if (isAboveBounds) {
    newStart = baseDate;
    final cappedEnd =
        baseDate.add(Duration(minutes: durationMinutes));
    final dayEnd = baseDate.add(const Duration(days: 1));
    newEnd = cappedEnd.isBefore(dayEnd) ? cappedEnd : dayEnd;
  }

  if (isBelowBounds) {
    final dayEnd = baseDate.add(const Duration(days: 1));
    newEnd = dayEnd;
    final candidateStart =
        dayEnd.subtract(Duration(minutes: durationMinutes));
    newStart = candidateStart.isAfter(baseDate)
        ? candidateStart
        : baseDate;
  }

  return DropComputationResult(
    newStart: newStart,
    newEnd: newEnd,
  );
}
--- FILE: lib/features/agenda/presentation/screens/helper/responsive_layout.dart ---
import 'dart:math' as math;

import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/config/layout_config.dart';

class ResponsiveLayout {
  final double columnWidth;
  final double slotHeight;
  final int maxVisibleStaff;
  final int totalSlots;

  const ResponsiveLayout({
    required this.columnWidth,
    required this.slotHeight,
    required this.maxVisibleStaff,
    required this.totalSlots,
  });

  static ResponsiveLayout of(
    BuildContext context, {
    required int staffCount,
    required LayoutConfig config,
    double? availableWidth,
  }) {
    final screenWidth = availableWidth ?? MediaQuery.of(context).size.width;
    final container = ProviderScope.containerOf(context, listen: false);
    final formFactor = container.read(formFactorProvider);

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // üìê Calcolo larghezza colonne staff
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    final dynamicMaxVisible = formFactor == AppFormFactor.mobile
        ? 2
        : config.computeMaxVisibleStaff(
            screenWidth,
            formFactor: formFactor,
          );
    final visibleStaff = staffCount.clamp(1, dynamicMaxVisible);

    final columnWidth = config.computeAdaptiveColumnWidth(
      contentWidth: screenWidth,
      visibleStaffCount: visibleStaff,
      formFactor: formFactor,
    );
    final devicePixelRatio = MediaQuery.of(context).devicePixelRatio;
    final snappedColumnWidth = devicePixelRatio > 0
        ? (columnWidth * devicePixelRatio).floorToDouble() / devicePixelRatio
        : columnWidth;
    final minWidth = formFactor == AppFormFactor.mobile
        ? LayoutConfig.minColumnWidthMobile
        : LayoutConfig.minColumnWidthDesktop;
    final resolvedColumnWidth = math.max(snappedColumnWidth, minWidth);

    return ResponsiveLayout(
      columnWidth: resolvedColumnWidth,
      slotHeight: config.slotHeight,
      maxVisibleStaff: dynamicMaxVisible,
      totalSlots: config.totalSlots,
    );
  }

  double get totalHeight => totalSlots * slotHeight;
}
--- FILE: lib/features/agenda/presentation/screens/helper/free_duration_helper.dart ---
import 'dart:math' as math;

import '../../../../../core/models/appointment.dart';
import '../../../domain/config/layout_config.dart';

/// Computes the amount of free minutes starting from the given [index] slot.
///
/// Behavior:
/// - If the slot is fully occupied by one or more appointments -> returns 0.
/// - If the slot is partially occupied -> returns only the free minutes
///   inside that slot (no look-ahead aggregation).
/// - If the slot is totally free -> extends over subsequent contiguous
///   free slots until the next busy slot (original behavior).
Duration computeFreeDurationForSlot(
  int index,
  List<Appointment> appointments,
  LayoutConfig layout,
) {
  final slotStart = Duration(minutes: index * layout.minutesPerSlot);
  final slotEnd = Duration(minutes: (index + 1) * layout.minutesPerSlot);
  final slotDurationMinutes = layout.minutesPerSlot;

  // Collect overlaps of appointments within the current slot.
  final overlaps =
      <(int, int)>[]; // intervals [start, end) in minutes relative to slot
  for (final a in appointments) {
    final apptStart = Duration(
      hours: a.startTime.hour,
      minutes: a.startTime.minute,
    );
    final apptEnd = Duration(hours: a.endTime.hour, minutes: a.endTime.minute);
    if (slotStart < apptEnd && slotEnd > apptStart) {
      final overlapStart = apptStart > slotStart ? apptStart : slotStart;
      final overlapEnd = apptEnd < slotEnd ? apptEnd : slotEnd;
      final relativeStart = overlapStart.inMinutes - slotStart.inMinutes;
      final relativeEnd = overlapEnd.inMinutes - slotStart.inMinutes;
      overlaps.add((
        relativeStart.clamp(0, slotDurationMinutes),
        relativeEnd.clamp(0, slotDurationMinutes),
      ));
    }
  }

  if (overlaps.isNotEmpty) {
    // Merge intervals to avoid double counting.
    overlaps.sort((a, b) => a.$1.compareTo(b.$1));
    final merged = <(int, int)>[];
    for (final o in overlaps) {
      if (merged.isEmpty) {
        merged.add(o);
      } else {
        final last = merged.last;
        if (o.$1 <= last.$2) {
          merged[merged.length - 1] = (last.$1, math.max(last.$2, o.$2));
        } else {
          merged.add(o);
        }
      }
    }
    final coveredMinutes = merged.fold<int>(
      0,
      (sum, it) => sum + (it.$2 - it.$1),
    );
    if (coveredMinutes >= slotDurationMinutes) {
      return Duration.zero;
    } else {
      return Duration(minutes: slotDurationMinutes - coveredMinutes);
    }
  }

  // Fully free slot: extend to next busy slot.
  int nextBusy = layout.totalSlots;
  for (int i = index + 1; i < layout.totalSlots; i++) {
    final sStart = Duration(minutes: i * layout.minutesPerSlot);
    final sEnd = Duration(minutes: (i + 1) * layout.minutesPerSlot);
    final isBusy = appointments.any((a) {
      final start = Duration(
        hours: a.startTime.hour,
        minutes: a.startTime.minute,
      );
      final end = Duration(hours: a.endTime.hour, minutes: a.endTime.minute);
      return sStart < end && sEnd > start;
    });
    if (isBusy) {
      nextBusy = i;
      break;
    }
  }

  final freeSlotsCount = nextBusy - index;
  final freeMinutes = freeSlotsCount * layout.minutesPerSlot;
  return Duration(minutes: freeMinutes);
}
--- FILE: lib/features/agenda/presentation/screens/widgets/appointment_card_interactive.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/models/appointment.dart';
import '../../../../../../app/providers/form_factor_provider.dart';
import '../../../../../../core/l10n/l10_extension.dart';
import '../../../../../../core/widgets/app_dialogs.dart';
import '../../../../clients/providers/clients_providers.dart';
import '../../../domain/config/agenda_theme.dart';
import '../../../domain/config/layout_config.dart';
import '../../../providers/agenda_interaction_lock_provider.dart';
import '../../../providers/agenda_providers.dart';
import '../../../providers/appointment_providers.dart';
import '../../../providers/bookings_provider.dart';
import '../../../providers/drag_layer_link_provider.dart';
import '../../../providers/drag_offset_provider.dart';
import '../../../providers/drag_session_provider.dart';
import '../../../providers/dragged_appointment_provider.dart';
import '../../../providers/dragged_base_range_provider.dart';
import '../../../providers/dragged_last_staff_provider.dart';
import '../../../providers/highlighted_staff_provider.dart';
import '../../../providers/is_resizing_provider.dart';
import '../../../providers/layout_config_provider.dart';
import '../../../providers/resizing_provider.dart';
import '../../../providers/selected_appointment_provider.dart';
import '../../../providers/staff_columns_geometry_provider.dart';
import '../../../providers/temp_drag_time_provider.dart';
import '../../widgets/appointment_dialog.dart';

/// üîπ Versione unificata per DESKTOP e MOBILE.
/// Mantiene drag, resize, ghost, select, ma cambia il comportamento del tap:
/// - Desktop ‚Üí seleziona la card.
/// - Mobile ‚Üí apre un bottom sheet con i dettagli.
class AppointmentCardInteractive extends ConsumerStatefulWidget {
  final Appointment appointment;
  final Color color;
  final double? columnWidth;
  final double? columnOffset;
  final double? dragTargetWidth;
  final bool expandToLeft;

  const AppointmentCardInteractive({
    super.key,
    required this.appointment,
    required this.color,
    this.columnWidth,
    this.columnOffset,
    this.dragTargetWidth,
    this.expandToLeft = false,
  });

  @override
  ConsumerState<AppointmentCardInteractive> createState() =>
      _AppointmentCardInteractiveState();
}

class _AppointmentCardInteractiveState
    extends ConsumerState<AppointmentCardInteractive> {
  Size? _lastSize;
  Offset? _lastPointerGlobalPosition;
  bool _isDraggingResize = false;
  bool _blockDragDuringResize = false;
  bool _selectedFromHover = false;
  int? _currentDragSessionId;
  late final AgendaCardHoverNotifier _hoverNotifier;

  static const double _dragBlockZoneHeight = 28.0;
  static const int _minSlotsForDragBlock = 3;

  LayoutConfig get _layoutConfig => ref.read(layoutConfigProvider);

  @override
  void initState() {
    super.initState();
    _hoverNotifier = ref.read(agendaCardHoverProvider.notifier);
  }

  @override
  Widget build(BuildContext context) {
    final selection = ref.watch(selectedAppointmentProvider);
    final draggedId = ref.watch(draggedAppointmentIdProvider);
    final formFactor = ref.watch(formFactorProvider);

    final isSelected = selection.contains(widget.appointment.id);
    final isDragging = draggedId == widget.appointment.id;
    final showThickBorder = isSelected || isDragging;

    return MouseRegion(
      onEnter: (_) {
        _hoverNotifier.enter();
        _selectAppointment(ref, fromHover: true);
      },
      onExit: (_) {
        _hoverNotifier.exit();
        if (_selectedFromHover &&
            ref
                .read(selectedAppointmentProvider)
                .contains(widget.appointment.id) &&
            ref.read(draggedAppointmentIdProvider) != widget.appointment.id &&
            !ref.read(isResizingProvider)) {
          ref.read(selectedAppointmentProvider.notifier).clear();
          _selectedFromHover = false;
        }
      },
      child: LayoutBuilder(
        builder: (context, constraints) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            final size = Size(constraints.maxWidth, constraints.maxHeight);
            if (mounted && (_lastSize == null || _lastSize != size)) {
              setState(() => _lastSize = size);
            }
          });

          return Listener(
            onPointerDown: (e) {
              final cardBox = context.findRenderObject() as RenderBox?;
              if (cardBox != null) {
                _lastPointerGlobalPosition = e.position;
                _evaluateDragBlock(cardBox, e.position);
                ref
                    .read(draggedBaseRangeProvider.notifier)
                    .set(
                      widget.appointment.startTime,
                      widget.appointment.endTime,
                    );
                ref
                    .read(draggedLastStaffIdProvider.notifier)
                    .set(widget.appointment.staffId);

                final bodyBox = ref.read(dragBodyBoxProvider);
                if (bodyBox != null) {
                  final cardTopLeftGlobal = cardBox.localToGlobal(Offset.zero);
                  ref
                      .read(dragOffsetProvider.notifier)
                      .set(e.position.dy - cardTopLeftGlobal.dy);
                  ref
                      .read(dragOffsetXProvider.notifier)
                      .set(e.position.dx - cardTopLeftGlobal.dx);
                  final localStart = bodyBox.globalToLocal(e.position);
                  ref.read(dragPositionProvider.notifier).set(localStart);
                }
              }
            },
            onPointerMove: (e) {
              if (_isDraggingResize) {
                _performResizeUpdate(e);
                return;
              }
              final cardBox = context.findRenderObject() as RenderBox?;
              if (cardBox != null) {
                _evaluateDragBlock(cardBox, e.position);
              }
            },
            onPointerUp: (e) {
              if (_isDraggingResize) {
                _performResizeEnd();
                return;
              }
              if (ref.read(dragPositionProvider) != null) {
                ref.read(dragPositionProvider.notifier).clear();
              }
              _updateDragBlock(false);
              ref.read(draggedBaseRangeProvider.notifier).clear();
              ref.read(draggedLastStaffIdProvider.notifier).clear();
            },
            onPointerCancel: (e) {
              if (_isDraggingResize) {
                _performResizeCancel();
                return;
              }
              if (ref.read(dragPositionProvider) != null) {
                ref.read(dragPositionProvider.notifier).clear();
              }
              _updateDragBlock(false);
              ref.read(draggedBaseRangeProvider.notifier).clear();
              ref.read(draggedLastStaffIdProvider.notifier).clear();
            },
            child: GestureDetector(
              onTap: () {
                if (formFactor == AppFormFactor.mobile) {
                  _handleMobileTap();
                } else {
                  _handleDesktopTap();
                }
              },
              child: LongPressDraggable<Appointment>(
                data: widget.appointment,
                feedback: Consumer(
                  builder: (c, r, _) =>
                      _buildFollowerFeedback(c, r, isSelected),
                ),
                feedbackOffset: Offset.zero,
                dragAnchorStrategy: childDragAnchorStrategy,
                maxSimultaneousDrags: _blockDragDuringResize ? 0 : 1,
                childWhenDragging: _buildCard(
                  isGhost: true,
                  showThickBorder: showThickBorder,
                  isSelected: isSelected,
                ),

                onDragStarted: () {
                  _currentDragSessionId = ref
                      .read(dragSessionProvider.notifier)
                      .start();
                  ref
                      .read(draggedBaseRangeProvider.notifier)
                      .set(
                        widget.appointment.startTime,
                        widget.appointment.endTime,
                      );
                  _selectAppointment(ref);
                  ref
                      .read(draggedAppointmentIdProvider.notifier)
                      .set(widget.appointment.id);

                  final bodyBox = ref.read(dragBodyBoxProvider);
                  if (bodyBox != null && _lastPointerGlobalPosition != null) {
                    final local = bodyBox.globalToLocal(
                      _lastPointerGlobalPosition!,
                    );
                    ref.read(dragPositionProvider.notifier).set(local);
                  }
                },

                onDragUpdate: (details) {
                  final prev = ref.read(dragPositionProvider);
                  final bodyBox = ref.read(dragBodyBoxProvider);
                  if (bodyBox != null) {
                    final local = bodyBox.globalToLocal(details.globalPosition);
                    ref
                        .read(dragPositionProvider.notifier)
                        .set(Offset.lerp(prev, local, 0.85)!);
                  }
                },

                onDragEnd: (details) => _handleDragEnd(ref, details),
                onDragCompleted: () => _handleEnd(ref, keepSelection: true),
                onDraggableCanceled: (_, __) =>
                    _handleEnd(ref, keepSelection: true),

                child: _buildCard(
                  showThickBorder: showThickBorder,
                  isResizingDisabled: isDragging,
                  isSelected: isSelected,
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  @override
  void dispose() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _hoverNotifier.exit();
    });
    super.dispose();
  }

  void _handleEnd(WidgetRef ref, {bool keepSelection = false}) {
    ref.read(dragSessionProvider.notifier).clear();
    _currentDragSessionId = null;
    ref.read(draggedAppointmentIdProvider.notifier).clear();
    ref.read(dragOffsetProvider.notifier).clear();
    ref.read(dragOffsetXProvider.notifier).clear();
    ref.read(dragPositionProvider.notifier).clear();
    ref.read(tempDragTimeProvider.notifier).clear();
    if (keepSelection) {
      _selectAppointment(ref);
    } else {
      ref.read(selectedAppointmentProvider.notifier).clear();
    }
    ref.read(draggedBaseRangeProvider.notifier).clear();
    ref.read(draggedLastStaffIdProvider.notifier).clear();
  }

  void _selectAppointment(WidgetRef ref, {bool fromHover = false}) {
    _selectedFromHover = fromHover;
    final sel = ref.read(selectedAppointmentProvider.notifier);
    sel.toggleByAppointment(widget.appointment);
  }

  void _handleDragEnd(WidgetRef ref, DraggableDetails details) {
    if (details.wasAccepted) {
      _handleEnd(ref, keepSelection: true);
      return;
    }

    final session = ref.read(dragSessionProvider);
    final handledByTarget =
        session.dropHandled &&
        session.id != null &&
        session.id == _currentDragSessionId;
    if (handledByTarget) {
      _handleEnd(ref, keepSelection: true);
      return;
    }

    final bodyBox = ref.read(dragBodyBoxProvider);
    final columns = ref.read(staffColumnsGeometryProvider);
    if (bodyBox == null || columns.isEmpty) {
      _handleEnd(ref, keepSelection: true);
      return;
    }

    final dragPosLocal = ref.read(dragPositionProvider);
    final lastStaffId = ref.read(draggedLastStaffIdProvider);
    final offY = ref.read(dragOffsetProvider) ?? 0;
    final offX = ref.read(dragOffsetXProvider) ?? 0;
    final pointerGlobal = details.offset + Offset(offX, offY);
    final pointerLocal = bodyBox.globalToLocal(pointerGlobal);
    final releaseOffset = dragPosLocal ?? pointerLocal;
    final bodyOffset = pointerLocal;
    const tolerance = 4.0;

    int? targetStaffId;
    Rect? targetRect;
    for (final entry in columns.entries) {
      final rect = entry.value.inflate(tolerance);
      if (releaseOffset.dx >= rect.left && releaseOffset.dx <= rect.right) {
        targetStaffId = entry.key;
        targetRect = rect;
        break;
      }
    }

    if (targetStaffId == null || targetRect == null) {
      for (final entry in columns.entries) {
        final rect = entry.value.inflate(tolerance);
        if (bodyOffset.dx >= rect.left && bodyOffset.dx <= rect.right) {
          targetStaffId = entry.key;
          targetRect = rect;
          break;
        }
      }
    }

    final int dropStaffId =
        targetStaffId ?? lastStaffId ?? widget.appointment.staffId;
    targetRect ??= columns[dropStaffId];

    if (targetRect == null) {
      _handleEnd(ref, keepSelection: true);
      return;
    }

    double localY = releaseOffset.dy - targetRect.top;
    final slotHeight = _layoutConfig.slotHeight;
    final minutesPerSlot = _layoutConfig.minutesPerSlot;
    final totalMinutes = LayoutConfig.hoursInDay * 60;

    final baseDate = DateTime(
      widget.appointment.startTime.year,
      widget.appointment.startTime.month,
      widget.appointment.startTime.day,
    );

    final durationMinutes = widget.appointment.endTime
        .difference(widget.appointment.startTime)
        .inMinutes;

    final rawMaxStart = totalMinutes - durationMinutes;
    final maxStartMinutes = rawMaxStart < 0 ? 0 : rawMaxStart;

    double minutesFromTop = (localY / slotHeight) * minutesPerSlot;
    int roundedMinutes = ((minutesFromTop / 5).round() * 5).toInt();
    if (roundedMinutes < 0) {
      roundedMinutes = 0;
    } else if (roundedMinutes > maxStartMinutes) {
      roundedMinutes = maxStartMinutes;
    }

    final newStart = baseDate.add(Duration(minutes: roundedMinutes));
    var newEnd = newStart.add(Duration(minutes: durationMinutes));
    final dayBoundary = baseDate.add(const Duration(days: 1));
    if (newEnd.isAfter(dayBoundary)) newEnd = dayBoundary;

    ref
        .read(appointmentsProvider.notifier)
        .moveAppointment(
          appointmentId: widget.appointment.id,
          newStaffId: dropStaffId,
          newStart: newStart,
          newEnd: newEnd,
        );

    _handleEnd(ref, keepSelection: true);
  }

  void _evaluateDragBlock(RenderBox cardBox, Offset globalPosition) {
    final selection = ref.read(selectedAppointmentProvider);
    if (!selection.contains(widget.appointment.id)) {
      _updateDragBlock(false);
      return;
    }

    final localPos = cardBox.globalToLocal(globalPosition);
    final cardHeight = cardBox.size.height;
    final distanceFromBottom = cardHeight - localPos.dy;

    final minHeightForBlocking =
        _layoutConfig.slotHeight * _minSlotsForDragBlock;

    final shouldBlock =
        distanceFromBottom >= 0 &&
        distanceFromBottom <= _dragBlockZoneHeight &&
        cardHeight >= minHeightForBlocking;

    _updateDragBlock(shouldBlock);
  }

  void _updateDragBlock(bool value) {
    if (_blockDragDuringResize == value) return;
    if (!mounted) {
      _blockDragDuringResize = value;
      return;
    }
    setState(() => _blockDragDuringResize = value);
  }

  // üîπ Logica per il tap su DESKTOP/TABLET
  void _handleDesktopTap() async {
    final resizingNow = ref.read(isResizingProvider);
    if (resizingNow) return;

    _selectAppointment(ref);

    ref.read(dragOffsetProvider.notifier).clear();
    ref.read(dragOffsetXProvider.notifier).clear();
    ref.read(dragPositionProvider.notifier).clear();
    ref.read(highlightedStaffIdProvider.notifier).clear();

    // Legge l'appuntamento aggiornato dal provider (potrebbe essere stato
    // modificato tramite resize o drag)
    final currentAppointment = ref
        .read(appointmentsProvider)
        .requireValue
        .firstWhere((a) => a.id == widget.appointment.id);

    // Apre direttamente la vista di modifica dell'appuntamento
    await showAppointmentDialog(context, ref, initial: currentAppointment);

    if (!mounted) return;
    ref.read(selectedAppointmentProvider.notifier).clear();
  }

  // üîπ Logica per il tap su MOBILE (apre il dialogo di modifica come prima)
  void _handleMobileTap() async {
    final resizingNow = ref.read(isResizingProvider);
    if (resizingNow) return;

    _selectAppointment(ref);

    // Legge l'appuntamento aggiornato dal provider (potrebbe essere stato
    // modificato tramite resize o drag)
    final currentAppointment = ref
        .read(appointmentsProvider)
        .requireValue
        .firstWhere((a) => a.id == widget.appointment.id);

    // Apre direttamente la vista di modifica dell'appuntamento
    await showAppointmentDialog(context, ref, initial: currentAppointment);

    if (!mounted) return;
    ref.read(selectedAppointmentProvider.notifier).clear();
  }

  Widget _buildCard({
    bool isGhost = false,
    bool forFeedback = false,
    bool showThickBorder = false,
    bool isResizingDisabled = false,
    required bool isSelected,
    DateTime? overrideStart,
    DateTime? overrideEnd,
  }) {
    final resizingEntry = ref.watch(
      resizingEntryProvider(widget.appointment.id),
    );
    final booking = ref.watch(bookingsProvider)[widget.appointment.bookingId];
    final bookingNotes = booking?.notes?.trim();
    final clientNotes = widget.appointment.clientId != null
        ? ref
              .watch(clientsByIdProvider)[widget.appointment.clientId!]
              ?.notes
              ?.trim()
        : null;
    final hasBookingNotes = bookingNotes != null && bookingNotes.isNotEmpty;
    final hasClientNotes = clientNotes != null && clientNotes.isNotEmpty;
    final hasNotes = hasBookingNotes || hasClientNotes;

    final baseColor = widget.color.withOpacity(0.15);
    const r = BorderRadius.all(Radius.circular(6));

    final startTime = overrideStart ?? widget.appointment.startTime;
    final endTime =
        resizingEntry?.provisionalEndTime ??
        overrideEnd ??
        widget.appointment.endTime;

    final start = _formatTime(startTime);
    final formattedEndTime = _formatTime(endTime);
    final client = widget.appointment.clientName;

    final pieces = <String>[];
    if (widget.appointment.serviceName.isNotEmpty) {
      pieces.add(widget.appointment.serviceName);
    }
    if (widget.appointment.formattedPrice.isNotEmpty) {
      pieces.add(widget.appointment.formattedPrice);
    }
    final info = pieces.join(' ‚Äì ');
    final borderWidth = showThickBorder ? 2.5 : 1.0;

    final animationDuration = _isDraggingResize || forFeedback
        ? Duration.zero
        : const Duration(milliseconds: 80);
    final animationCurve = _isDraggingResize || forFeedback
        ? Curves.linear
        : Curves.easeOutQuad;

    return Opacity(
      opacity: isGhost ? AgendaTheme.ghostOpacity : 1,
      child: Material(
        borderRadius: r,
        color: Colors.transparent,
        child: AnimatedContainer(
          duration: animationDuration,
          curve: animationCurve,
          decoration: BoxDecoration(
            color: Color.alphaBlend(baseColor, Colors.white),
            borderRadius: r,
            border: Border.all(color: widget.color, width: borderWidth),
            boxShadow: [
              BoxShadow(
                color: widget.color.withOpacity(showThickBorder ? 0.25 : 0.1),
                blurRadius: showThickBorder ? 8 : 4,
                offset: showThickBorder
                    ? const Offset(2, 3)
                    : const Offset(1, 1),
              ),
            ],
          ),
          child: Stack(
            children: [
              _ExtraMinutesBand(
                ratio: _extraMinutesRatio(startTime, endTime),
                color: widget.color,
              ),

              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 4),
                child: Align(
                  alignment: Alignment.topLeft,
                  child: _buildContent(
                    start,
                    formattedEndTime,
                    client,
                    info,
                    showNotes: hasNotes && !forFeedback,
                    onNotesTap: hasNotes && !forFeedback
                        ? () => _showNotesDialog(
                            bookingNotes: hasBookingNotes ? bookingNotes : null,
                            clientNotes: hasClientNotes ? clientNotes : null,
                          )
                        : null,
                  ),
                ),
              ),
              if (!forFeedback && !isResizingDisabled && isSelected)
                _buildResizeHandle(),
            ],
          ),
        ),
      ),
    );
  }

  String _formatTime(DateTime time) {
    final dayStart = DateTime(
      widget.appointment.startTime.year,
      widget.appointment.startTime.month,
      widget.appointment.startTime.day,
    );

    final dayBoundary = dayStart.add(const Duration(days: 1));
    if (time.isAtSameMomentAs(dayBoundary)) return '24:00';

    final hours = time.hour.toString().padLeft(2, '0');
    final minutes = time.minute.toString().padLeft(2, '0');
    return '$hours:$minutes';
  }

  // Menu contestuale disabilitato su desktop: rimosso

  Widget _buildContent(
    String start,
    String end,
    String client,
    String info, {
    required bool showNotes,
    VoidCallback? onNotesTap,
  }) {
    return ClipRect(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          Flexible(
            child: Row(
              children: [
                Expanded(
                  child: RichText(
                    maxLines: 1,
                    softWrap: false,
                    overflow: TextOverflow.ellipsis,
                    text: TextSpan(
                      children: [
                        TextSpan(
                          text: '$start - $end  ',
                          style: const TextStyle(
                            color: Colors.black87,
                            fontWeight: FontWeight.w700,
                          ),
                        ),
                        TextSpan(
                          text: client,
                          style: const TextStyle(
                            color: Colors.grey,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                if (showNotes)
                  Padding(
                    padding: const EdgeInsets.only(left: 4),
                    child: Tooltip(
                      message: context.l10n.appointmentNotesTitle,
                      child: InkWell(
                        onTap: onNotesTap,
                        borderRadius: BorderRadius.circular(6),
                        child: const Padding(
                          padding: EdgeInsets.all(2),
                          child: Icon(
                            Icons.sticky_note_2_outlined,
                            size: 14,
                            color: Colors.black54,
                          ),
                        ),
                      ),
                    ),
                  ),
              ],
            ),
          ),
          if (info.isNotEmpty)
            Flexible(
              child: Text(
                info,
                maxLines: 1,
                softWrap: false,
                overflow: TextOverflow.ellipsis,
                style: const TextStyle(
                  fontSize: 11,
                  color: Colors.black54,
                  height: 1.1,
                ),
              ),
            ),
        ],
      ),
    );
  }

  void _showNotesDialog({String? bookingNotes, String? clientNotes}) {
    if ((bookingNotes == null || bookingNotes.trim().isEmpty) &&
        (clientNotes == null || clientNotes.trim().isEmpty)) {
      return;
    }
    final l10n = context.l10n;
    final sections = <Widget>[];
    if (clientNotes != null && clientNotes.trim().isNotEmpty) {
      sections.add(
        Text(
          l10n.clientNoteLabel,
          style: Theme.of(context).textTheme.titleSmall,
        ),
      );
      sections.add(const SizedBox(height: 4));
      sections.add(Text(clientNotes.trim()));
    }
    if (bookingNotes != null && bookingNotes.trim().isNotEmpty) {
      if (sections.isNotEmpty) {
        sections.add(const SizedBox(height: 12));
      }
      sections.add(
        Text(
          l10n.appointmentNoteLabel,
          style: Theme.of(context).textTheme.titleSmall,
        ),
      );
      sections.add(const SizedBox(height: 4));
      sections.add(Text(bookingNotes.trim()));
    }
    showAppInfoDialog(
      context,
      title: Text(l10n.appointmentNotesTitle),
      content: ConstrainedBox(
        constraints: const BoxConstraints(maxWidth: 360),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: sections,
        ),
      ),
      closeLabel: l10n.actionClose,
    );
  }

  double _extraMinutesRatio(DateTime start, DateTime end) {
    final totalMinutes = end.difference(start).inMinutes;
    if (totalMinutes <= 0) return 0;
    final extra = _extraMinutesForAppointment();
    if (extra <= 0) return 0;
    final ratio = extra / totalMinutes;
    if (ratio < 0) return 0;
    if (ratio > 1) return 1;
    return ratio;
  }

  int _extraMinutesForAppointment() {
    return widget.appointment.blockedExtraMinutes;
  }

  void _performResizeUpdate(PointerEvent details) {
    if (_lastPointerGlobalPosition == null) return;
    final currentGlobal = details.position;
    final deltaY = currentGlobal.dy - _lastPointerGlobalPosition!.dy;
    _lastPointerGlobalPosition = currentGlobal;

    final minutesPerPixel =
        _layoutConfig.minutesPerSlot / _layoutConfig.slotHeight;
    final pixelsPerMinute = 1 / minutesPerPixel;
    final dayEnd = DateTime(
      widget.appointment.startTime.year,
      widget.appointment.startTime.month,
      widget.appointment.startTime.day,
    ).add(const Duration(days: 1));

    ref
        .read(resizingProvider.notifier)
        .updateDuringResize(
          appointmentId: widget.appointment.id,
          deltaDy: deltaY,
          pixelsPerMinute: pixelsPerMinute,
          dayEnd: dayEnd,
          minDurationMinutes: 5,
          snapMinutes: 5,
        );
  }

  void _performResizeEnd() async {
    final newEnd = ref
        .read(resizingProvider.notifier)
        .commitResizeAndEnd(appointmentId: widget.appointment.id);

    if (newEnd != null) {
      final appt = widget.appointment;
      final minEnd = appt.startTime.add(const Duration(minutes: 5));
      ref
          .read(appointmentsProvider.notifier)
          .moveAppointment(
            appointmentId: appt.id,
            newStaffId: appt.staffId,
            newStart: appt.startTime,
            newEnd: newEnd.isAfter(minEnd) ? newEnd : minEnd,
          );
    }

    await Future.delayed(const Duration(milliseconds: 100));
    if (mounted) setState(() => _isDraggingResize = false);
    _lastPointerGlobalPosition = null;
    _updateDragBlock(false);
    ref.read(isResizingProvider.notifier).stop();
    ref.invalidate(resizingProvider);
    if (ref.read(dragPositionProvider) != null) {
      ref.read(dragPositionProvider.notifier).clear();
    }
  }

  void _performResizeCancel() {
    ref
        .read(resizingProvider.notifier)
        .cancelResize(appointmentId: widget.appointment.id);
    ref.read(isResizingProvider.notifier).stop();

    if (mounted) {
      setState(() => _isDraggingResize = false);
    }
    _updateDragBlock(false);
    if (ref.read(dragPositionProvider) != null) {
      ref.read(dragPositionProvider.notifier).clear();
    }
  }

  // üîπ Resize identico all‚Äôoriginale
  Widget _buildResizeHandle() {
    return Align(
      alignment: Alignment.bottomCenter,
      child: MouseRegion(
        cursor: SystemMouseCursors.resizeUpDown,
        child: GestureDetector(
          behavior: HitTestBehavior.opaque,
          onVerticalDragStart: (details) {
            final renderBox = context.findRenderObject() as RenderBox?;
            final currentHeightPx = renderBox?.size.height ?? 0;
            _lastPointerGlobalPosition = details.globalPosition;
            _updateDragBlock(true);

            ref
                .read(resizingProvider.notifier)
                .startResize(
                  appointmentId: widget.appointment.id,
                  currentHeightPx: currentHeightPx,
                  startTime: widget.appointment.startTime,
                  endTime: widget.appointment.endTime,
                );
            ref.read(isResizingProvider.notifier).start();
            setState(() => _isDraggingResize = true);
          },
          onVerticalDragUpdate: (details) {
            // Gestito da onPointerMove
          },
          onVerticalDragEnd: (_) {
            // Gestito da onPointerUp
          },
          onVerticalDragCancel: () {
            // Gestito da onPointerCancel
          },
          child: Container(
            height: 20,
            width: double.infinity,
            alignment: Alignment.bottomCenter,
            child: const Padding(
              padding: EdgeInsets.only(bottom: 1),
              child: Icon(Icons.drag_indicator, size: 14, color: Colors.grey),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildFollowerFeedback(
    BuildContext context,
    WidgetRef ref,
    bool isSelected,
  ) {
    final layoutConfig = ref.watch(layoutConfigProvider);
    final times = ref.watch(tempDragTimeProvider);
    final start = times?.$1;
    final end = times?.$2;

    final dragPos = ref.watch(dragPositionProvider);
    final offY = ref.watch(dragOffsetProvider) ?? 0;
    final offX = ref.watch(dragOffsetXProvider) ?? 0;
    final link = ref.watch(dragLayerLinkProvider);

    final highlightedId = ref.watch(highlightedStaffIdProvider);
    final columnsRects = ref.watch(staffColumnsGeometryProvider);

    final padding = LayoutConfig.columnInnerPadding;
    final fallbackWidth = widget.columnWidth ?? _lastSize?.width ?? 180.0;
    double effectiveWidth = widget.dragTargetWidth ?? fallbackWidth;
    if (effectiveWidth <= 0) {
      effectiveWidth = fallbackWidth > 0 ? fallbackWidth : 180.0;
    }
    final h = _lastSize?.height ?? 50.0;

    if (dragPos == null) return const SizedBox.shrink();

    final bodyBox = ref.read(dragBodyBoxProvider);
    final totalHeight = bodyBox?.size.height ?? layoutConfig.totalHeight;
    final cardHeight = h;

    final double unconstrainedTop = dragPos.dy - offY;
    double top = unconstrainedTop;
    double translateY = 0;

    double maxTop = totalHeight - cardHeight;
    if (maxTop < 0) maxTop = 0;

    if (unconstrainedTop < 0) {
      translateY = 0;
      top = 0;
    } else if (unconstrainedTop > maxTop) {
      translateY = 0;
      top = maxTop;
    }

    double left;
    final rect = highlightedId != null ? columnsRects[highlightedId] : null;

    // Limitiamo sempre la X minima all'inizio del body (0 + padding),
    // cos√¨ il feedback non entra mai nell'area della colonna oraria.
    final double globalMinLeft = padding;
    double minLeft = rect != null ? rect.left + padding : padding;
    if (minLeft < globalMinLeft) minLeft = globalMinLeft;

    if (rect != null) {
      left = rect.left + padding;
      final availableWidth = rect.width - padding * 2;
      if (availableWidth > 0 && availableWidth < effectiveWidth) {
        effectiveWidth = availableWidth;
      } else if (availableWidth > 0 && widget.dragTargetWidth == null) {
        effectiveWidth = availableWidth;
      }
      if (left < minLeft) left = minLeft;
    } else {
      left = dragPos.dx - offX - padding;
      if (widget.expandToLeft) left -= (effectiveWidth / 2);
      if (left < minLeft) left = minLeft;
    }

    final dpr = MediaQuery.of(context).devicePixelRatio;
    left = (left * dpr).round() / dpr;
    top = (top * dpr).round() / dpr;
    translateY = (translateY * dpr).round() / dpr;

    // üîπ Se non abbiamo ancora il bodyBox, evitiamo di disegnare il feedback
    if (bodyBox == null) {
      return const SizedBox.shrink();
    }

    // üîπ Clip minimo solo verticalmente, manteniamo la larghezza della card.
    return RepaintBoundary(
      child: CompositedTransformFollower(
        link: link,
        showWhenUnlinked: false,
        offset: Offset(left, top),
        child: SizedBox(
          width: effectiveWidth,
          height: h,
          child: ClipRect(
            child: Transform.translate(
              offset: Offset(0, translateY),
              child: Material(
                color: Colors.transparent,
                borderRadius: const BorderRadius.all(Radius.circular(6)),
                clipBehavior: Clip.antiAlias,
                child: _buildCard(
                  forFeedback: true,
                  showThickBorder: true,
                  overrideStart: start,
                  overrideEnd: end,
                  isSelected: isSelected,
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
} // Closing brace for _AppointmentCardInteractiveState

class _ExtraMinutesBand extends StatelessWidget {
  const _ExtraMinutesBand({required this.ratio, required this.color});

  final double ratio;
  final Color color;

  @override
  Widget build(BuildContext context) {
    if (ratio <= 0) return const SizedBox.shrink();
    return Positioned.fill(
      child: Align(
        alignment: Alignment.bottomCenter,
        child: FractionallySizedBox(
          heightFactor: ratio,
          widthFactor: 1,
          child: Container(
            decoration: BoxDecoration(
              color: color.withOpacity(0.18),
              borderRadius: const BorderRadius.vertical(
                bottom: Radius.circular(6),
              ),
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/appointment_card_base.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/models/appointment.dart';
import 'appointment_card_interactive.dart';

/// Wrapper unico che istanzia la versione interattiva
/// per entrambi i form factor (desktop e mobile).
class AppointmentCard extends ConsumerWidget {
  final Appointment appointment;
  final Color color;
  final double? columnWidth;
  final double? columnOffset;
  final double? dragTargetWidth;
  final bool expandToLeft;

  const AppointmentCard({
    super.key,
    required this.appointment,
    required this.color,
    this.columnWidth,
    this.columnOffset,
    this.dragTargetWidth,
    this.expandToLeft = false,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return AppointmentCardInteractive(
      appointment: appointment,
      color: color,
      columnWidth: columnWidth,
      columnOffset: columnOffset,
      dragTargetWidth: dragTargetWidth,
      expandToLeft: expandToLeft,
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/unavailable_slot_pattern.dart ---
import 'package:flutter/material.dart';

import '../../../domain/config/layout_config.dart';

/// Painter leggero che disegna linee diagonali.
/// Usa `isComplex: true` e `willChange: false` per caching automatico.
class _DiagonalPatternPainter extends CustomPainter {
  final Color lineColor;
  final double lineWidth;
  final double spacing;

  const _DiagonalPatternPainter({
    required this.lineColor,
    required this.lineWidth,
    required this.spacing,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = lineColor
      ..strokeWidth = lineWidth
      ..style = PaintingStyle.stroke;

    // Disegna linee diagonali da sinistra-alto a destra-basso
    final double step = spacing;
    final double maxOffset = size.width + size.height;

    for (double offset = -size.height; offset < maxOffset; offset += step) {
      canvas.drawLine(
        Offset(offset, 0),
        Offset(offset + size.height, size.height),
        paint,
      );
    }
  }

  @override
  bool shouldRepaint(covariant _DiagonalPatternPainter oldDelegate) {
    return oldDelegate.lineColor != lineColor ||
        oldDelegate.lineWidth != lineWidth ||
        oldDelegate.spacing != spacing;
  }
}

/// Widget leggero che mostra un pattern a righe diagonali per indicare
/// uno slot non disponibile nell'agenda.
///
/// Ottimizzato per performance:
/// - Nessun state, nessun async
/// - CustomPaint con caching automatico (isComplex + willChange)
/// - RepaintBoundary per isolare i repaint
class UnavailableSlotPattern extends StatelessWidget {
  final double height;
  final Color? patternColor;
  final Color? backgroundColor;
  final double lineWidth;
  final double spacing;
  final BorderRadius? borderRadius;

  const UnavailableSlotPattern({
    super.key,
    required this.height,
    this.patternColor,
    this.backgroundColor,
    this.lineWidth = 1.5,
    this.spacing = 6.0,
    this.borderRadius,
  });

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final effectivePatternColor =
        patternColor ?? colorScheme.onSurface.withOpacity(0.25);
    final effectiveBackgroundColor =
        backgroundColor ?? colorScheme.surfaceContainerHighest.withOpacity(0.6);
    final effectiveBorderRadius = borderRadius ?? BorderRadius.circular(4);

    return DecoratedBox(
      decoration: BoxDecoration(
        color: effectiveBackgroundColor,
        borderRadius: effectiveBorderRadius,
      ),
      child: ClipRRect(
        borderRadius: effectiveBorderRadius,
        child: SizedBox(
          height: height,
          width: double.infinity,
          child: RepaintBoundary(
            child: CustomPaint(
              painter: _DiagonalPatternPainter(
                lineColor: effectivePatternColor,
                lineWidth: lineWidth,
                spacing: spacing,
              ),
              isComplex: true,
              willChange: false,
            ),
          ),
        ),
      ),
    );
  }
}

/// Variante con margini coerenti con le AppointmentCard.
class UnavailableSlotOverlay extends StatelessWidget {
  final double height;
  final double margin;
  final Color? patternColor;
  final Color? backgroundColor;

  const UnavailableSlotOverlay({
    super.key,
    required this.height,
    this.margin = LayoutConfig.columnInnerPadding,
    this.patternColor,
    this.backgroundColor,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: EdgeInsets.all(margin),
      child: UnavailableSlotPattern(
        height: height - (margin * 2),
        patternColor: patternColor,
        backgroundColor: backgroundColor,
      ),
    );
  }
}

/// Widget ottimizzato per coprire un range di slot consecutivi.
class UnavailableSlotRange extends StatelessWidget {
  final int slotCount;
  final double slotHeight;
  final double margin;
  final Color? patternColor;
  final Color? backgroundColor;

  const UnavailableSlotRange({
    super.key,
    required this.slotCount,
    required this.slotHeight,
    this.margin = LayoutConfig.columnInnerPadding,
    this.patternColor,
    this.backgroundColor,
  });

  @override
  Widget build(BuildContext context) {
    final totalHeight = slotCount * slotHeight;
    return Padding(
      padding: EdgeInsets.all(margin),
      child: UnavailableSlotPattern(
        height: totalHeight - (margin * 2),
        patternColor: patternColor,
        backgroundColor: backgroundColor,
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/current_time_line.dart ---
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/config/layout_config.dart';
import '../../../providers/date_range_provider.dart';
import '../../../providers/layout_config_provider.dart';

/// üîπ Linea rossa che indica l'orario corrente.
/// - visibile solo sulla data odierna
/// - sincronizzata minuto per minuto
/// - la posizione verticale effettiva viene corretta con [verticalOffset]
///   passato da AgendaScreen (offset di scroll della giornata).
class CurrentTimeLine extends ConsumerStatefulWidget {
  static const double horizontalMargin = 4.0;

  final double hourColumnWidth;
  final double verticalOffset;
  final double horizontalOffset;

  const CurrentTimeLine({
    super.key,
    required this.hourColumnWidth,
    required this.verticalOffset,
    this.horizontalOffset = 0,
  });

  @override
  ConsumerState<CurrentTimeLine> createState() => _CurrentTimeLineState();
}

class _CurrentTimeLineState extends ConsumerState<CurrentTimeLine> {
  Timer? _minuteTimer;
  double _offset = 0;
  String _label = '';
  late final ProviderSubscription<LayoutConfig> _layoutConfigSub;

  // üîπ Definiamo l'altezza della linea come costante
  static const double _lineHeight = 1.0;
  // üîπ Definiamo il margine/gap che conterr√† la linea
  static const double _lineMargin = CurrentTimeLine.horizontalMargin;

  @override
  void initState() {
    super.initState();

    // Ascolta i cambi di LayoutConfig (slotHeight / minutesPerSlot)
    _layoutConfigSub = ref.listenManual<LayoutConfig>(
      layoutConfigProvider,
      (prev, next) => _updateLine(configOverride: next),
      fireImmediately: true,
    );

    // Aggiornamento minuto per minuto
    _scheduleMinuteSync();
  }

  void _scheduleMinuteSync() {
    final now = DateTime.now();
    final msToNextMinute = 60000 - (now.second * 1000 + now.millisecond);
    _minuteTimer = Timer(Duration(milliseconds: msToNextMinute), () {
      _updateLine();
      _minuteTimer?.cancel();
      _minuteTimer = Timer.periodic(const Duration(minutes: 1), (_) {
        _updateLine();
      });
    });
  }

  void _updateLine({LayoutConfig? configOverride}) {
    final now = DateTime.now();
    final minutesSinceMidnight = now.hour * 60 + now.minute;
    final LayoutConfig config =
        configOverride ?? ref.read(layoutConfigProvider);

    final slotHeight = config.slotHeight;
    final offset = (minutesSinceMidnight / config.minutesPerSlot) * slotHeight;
    final label =
        "${now.hour.toString().padLeft(2, '0')}:${now.minute.toString().padLeft(2, '0')}";

    if (!mounted) return;
    setState(() {
      _offset = offset;
      _label = label;
    });
  }

  @override
  void dispose() {
    _minuteTimer?.cancel();
    _layoutConfigSub.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // Mostra la linea solo se la data visualizzata √® oggi
    final selectedDate = ref.watch(agendaDateProvider);
    final today = DateUtils.dateOnly(DateTime.now());
    final isToday = DateUtils.isSameDay(selectedDate, today);
    if (!isToday) {
      return const SizedBox.shrink();
    }

    final layout = ref.read(layoutConfigProvider);

    // üîπ Calcoliamo la posizione Y del CENTRO della linea
    final lineCenterY = _offset - widget.verticalOffset + layout.headerHeight;
    // üîπ Calcoliamo il 'top' per il Positioned
    final lineTopY = lineCenterY - (_lineHeight / 2);

    return Positioned(
      top: lineTopY,
      left: widget.horizontalOffset,
      right: 0,
      child: Stack(
        clipBehavior: Clip.none,
        children: [
          // --- Linea rossa orizzontale (l'elemento di riferimento) ---
          Row(
            children: [
              // Spazio per la colonna oraria
              SizedBox(width: widget.hourColumnWidth - _lineMargin),
              // Linea dalla fine del box fino al bordo destro
              Container(
                width: _lineMargin,
                height: _lineHeight,
                color: Colors.redAccent,
              ),
              Expanded(
                child: Container(height: _lineHeight, color: Colors.redAccent),
              ),
            ],
          ),
          // --- Box dell'orario (centrato verticalmente sulla linea) ---
          Positioned(
            left: -_lineMargin - 1,
            width: widget.hourColumnWidth,
            top: 0,
            child: FractionalTranslation(
              // Sposta il box del 50% della sua altezza verso l'alto
              // cos√¨ il suo centro si allinea con la linea
              translation: const Offset(0, -0.5),
              child: Align(
                alignment: Alignment.center,
                child: Container(
                  width: double.infinity,
                  decoration: BoxDecoration(
                    color: Colors.redAccent,
                    borderRadius: BorderRadius.circular(4),
                  ),
                  padding: const EdgeInsets.symmetric(vertical: 5),
                  child: Text(
                    _label,
                    textAlign: TextAlign.center,
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 11,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/agenda_dividers.dart ---
import 'package:flutter/material.dart';

/// Divider verticale sottile tra la colonna oraria e le colonne staff
class AgendaVerticalDivider extends StatelessWidget {
  final double height;
  final Color color;
  final double thickness;

  /// Altezza della porzione superiore con sfumatura (es. headerHeight)
  final double? fadeTopHeight;

  const AgendaVerticalDivider({
    super.key,
    required this.height,
    this.color = const Color(0xFFBDBDBD),
    this.thickness = 0.5,
    this.fadeTopHeight,
  });

  @override
  Widget build(BuildContext context) {
    // Se fadeTopHeight √® specificato, usa una Column con gradiente in alto
    if (fadeTopHeight != null && fadeTopHeight! > 0) {
      return SizedBox(
        height: height,
        width: thickness,
        child: Column(
          children: [
            // Parte superiore con gradiente sfumato
            Container(
              height: fadeTopHeight,
              width: thickness,
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                  colors: [color.withOpacity(0.0), color],
                  stops: const [0.0, 0.7],
                ),
              ),
            ),
            // Parte inferiore con colore pieno
            Expanded(
              child: Container(width: thickness, color: color),
            ),
          ],
        ),
      );
    }

    // Comportamento originale senza sfumatura
    return SizedBox(
      height: height,
      width: thickness,
      child: DecoratedBox(decoration: BoxDecoration(color: color)),
    );
  }
}

/// Divider orizzontale usato per le righe orarie
class AgendaHorizontalDivider extends StatelessWidget {
  final double thickness;
  final Color color;

  const AgendaHorizontalDivider({
    super.key,
    this.thickness = 0.5,
    this.color = const Color(0xFFBDBDBD),
  });

  @override
  Widget build(BuildContext context) {
    return Divider(height: thickness, thickness: thickness, color: color);
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/hover_slot.dart ---
import 'package:agenda_backend/core/l10n/date_time_formats.dart';
import 'package:flutter/material.dart';

import '../../../domain/config/layout_config.dart';

/// Slot interattivo che reagisce all'hover del mouse.
/// Usa lo stesso margin, borderRadius e spessore del bordo delle AppointmentCard.
class HoverSlot extends StatefulWidget {
  final DateTime slotTime;
  final double height;
  final Color colorPrimary1;

  const HoverSlot({
    super.key,
    required this.slotTime,
    required this.height,
    required this.colorPrimary1,
  });

  @override
  State<HoverSlot> createState() => _HoverSlotState();
}

class _HoverSlotState extends State<HoverSlot> {
  bool _hovered = false;

  @override
  Widget build(BuildContext context) {
    final timeStr = DtFmt.hm(
      context,
      widget.slotTime.hour,
      widget.slotTime.minute,
    );

    final radius = BorderRadius.circular(4);
    final margin = EdgeInsets.all(LayoutConfig.columnInnerPadding);
    final borderWidth = LayoutConfig.borderWidth;

    return MouseRegion(
      onEnter: (_) => setState(() => _hovered = true),
      onExit: (_) => setState(() => _hovered = false),
      child: Container(
        margin: margin,
        height: widget.height - LayoutConfig.columnInnerPadding * 2,
        width: double.infinity,
        decoration: BoxDecoration(
          color: _hovered
              ? widget.colorPrimary1.withOpacity(0.06)
              : Colors.transparent,
          border: Border.all(
            color: _hovered
                ? widget.colorPrimary1.withOpacity(0.1)
                : Colors.transparent,
            width: _hovered ? borderWidth : 0,
          ),
          borderRadius: radius,
        ),
        child: _hovered
            ? Padding(
                padding: const EdgeInsets.all(2),
                child: Align(
                  alignment: Alignment.centerLeft,
                  child: Text(
                    timeStr,
                    style: TextStyle(
                      fontSize: 11,
                      fontWeight: FontWeight.w600,
                      color: widget.colorPrimary1,
                    ),
                  ),
                ),
              )
            : const SizedBox.expand(),
      ),
    );
  }
}

/// Wrapper that builds [HoverSlot] only when the pointer (mouse) or touch is
/// active on the slot. This avoids constructing the (slightly heavier)
/// hover contents for every slot when not needed.
class LazyHoverSlot extends StatefulWidget {
  final DateTime slotTime;
  final double height;
  final Color colorPrimary1;
  final void Function(DateTime)? onTap;

  const LazyHoverSlot({
    super.key,
    required this.slotTime,
    required this.height,
    required this.colorPrimary1,
    this.onTap,
  });

  @override
  State<LazyHoverSlot> createState() => _LazyHoverSlotState();
}

class _LazyHoverSlotState extends State<LazyHoverSlot> {
  bool _show = false;

  void _onEnter(PointerEvent _) {
    setState(() => _show = true);
  }

  void _onExit(PointerEvent _) {
    setState(() => _show = false);
  }

  void _onTapDown(TapDownDetails _) {
    // On touch devices show the hover content while pressing.
    setState(() => _show = true);
  }

  void _onTapUp(TapUpDetails _) {
    // Hide shortly after release to mimic hover disappearing.
    Future.delayed(const Duration(milliseconds: 250), () {
      if (mounted) setState(() => _show = false);
    });
  }

  void _onTapCancel() {
    setState(() => _show = false);
  }

  @override
  Widget build(BuildContext context) {
    // We keep the same size and margin as HoverSlot so layout doesn't jump.
    return MouseRegion(
      onEnter: _onEnter,
      onExit: _onExit,
      child: GestureDetector(
        behavior: HitTestBehavior.translucent,
        onTap: () => widget.onTap?.call(widget.slotTime),
        onTapDown: _onTapDown,
        onTapUp: _onTapUp,
        onTapCancel: _onTapCancel,
        child: SizedBox(
          height: widget.height,
          width: double.infinity,
          child: _show
              ? HoverSlot(
                  slotTime: widget.slotTime,
                  height: widget.height,
                  colorPrimary1: widget.colorPrimary1,
                )
              : Container(),
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/time_block_widget.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../core/l10n/l10_extension.dart';
import '../../../../../core/models/time_block.dart';
import '../../../domain/config/layout_config.dart';
import '../../dialogs/add_block_dialog.dart';

/// Widget per visualizzare un blocco di non disponibilit√† nell'agenda.
class TimeBlockWidget extends ConsumerWidget {
  final TimeBlock block;
  final double height;
  final double width;

  const TimeBlockWidget({
    super.key,
    required this.block,
    required this.height,
    required this.width,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final colorScheme = Theme.of(context).colorScheme;
    final blockColor = colorScheme.error.withOpacity(0.15);
    final borderColor = colorScheme.error.withOpacity(0.5);

    return GestureDetector(
      onTap: () {
        showAddBlockDialog(context, ref, initial: block);
      },
      child: Container(
        width: width,
        height: height,
        decoration: BoxDecoration(
          color: blockColor,
          borderRadius: BorderRadius.circular(LayoutConfig.borderRadius),
          border: Border.all(color: borderColor, width: 1.5),
        ),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(LayoutConfig.borderRadius - 1),
          child: Stack(
            children: [
              // Pattern diagonale
              CustomPaint(
                size: Size(width, height),
                painter: _DiagonalPatternPainter(
                  color: colorScheme.error.withOpacity(0.1),
                ),
              ),
              // Contenuto
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Row(
                      children: [
                        Icon(Icons.block, size: 14, color: colorScheme.error),
                        const SizedBox(width: 4),
                        Expanded(
                          child: Text(
                            block.reason ?? 'Blocco',
                            style: TextStyle(
                              fontSize: 12,
                              fontWeight: FontWeight.w600,
                              color: colorScheme.error,
                            ),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                      ],
                    ),
                    if (height > 40) ...[
                      const SizedBox(height: 2),
                      Text(
                        _formatTimeRange(context, block),
                        style: TextStyle(
                          fontSize: 10,
                          color: colorScheme.error.withOpacity(0.8),
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _formatTimeRange(BuildContext context, TimeBlock block) {
    if (block.isAllDay) {
      return context.l10n.blockAllDay;
    }
    final start =
        '${block.startTime.hour.toString().padLeft(2, '0')}:${block.startTime.minute.toString().padLeft(2, '0')}';
    final end =
        '${block.endTime.hour.toString().padLeft(2, '0')}:${block.endTime.minute.toString().padLeft(2, '0')}';
    return '$start - $end';
  }
}

/// Painter per il pattern diagonale del blocco.
class _DiagonalPatternPainter extends CustomPainter {
  final Color color;

  _DiagonalPatternPainter({required this.color});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 1.0
      ..style = PaintingStyle.stroke;

    const spacing = 8.0;
    final diagonal = size.width + size.height;

    for (double i = -size.height; i < diagonal; i += spacing) {
      canvas.drawLine(
        Offset(i, 0),
        Offset(i + size.height, size.height),
        paint,
      );
    }
  }

  @override
  bool shouldRepaint(covariant _DiagonalPatternPainter oldDelegate) {
    return oldDelegate.color != color;
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/staff_column.dart ---
import 'dart:async';
import 'dart:math' as math;

import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/core/l10n/date_time_formats.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/service_variant.dart';
import 'package:agenda_backend/core/widgets/app_dialogs.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/widgets/hover_slot.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/widgets/unavailable_slot_pattern.dart';
import 'package:agenda_backend/features/agenda/providers/dragged_card_size_provider.dart';
import 'package:agenda_backend/features/agenda/providers/pending_drop_provider.dart';
import 'package:agenda_backend/features/agenda/providers/staff_slot_availability_provider.dart';
import 'package:agenda_backend/features/services/providers/services_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/models/appointment.dart';
import '/core/models/staff.dart';
import '/core/utils/color_utils.dart';
import '../../../domain/config/agenda_theme.dart';
import '../../../domain/config/layout_config.dart';
import '../../../providers/agenda_providers.dart';
import '../../../providers/appointment_providers.dart';
import '../../../providers/date_range_provider.dart';
import '../../../providers/drag_layer_link_provider.dart';
import '../../../providers/drag_offset_provider.dart';
import '../../../providers/drag_session_provider.dart';
import '../../../providers/dragged_appointment_provider.dart';
import '../../../providers/dragged_base_range_provider.dart';
import '../../../providers/dragged_last_staff_provider.dart';
import '../../../providers/fully_occupied_slots_provider.dart';
import '../../../providers/highlighted_staff_provider.dart';
// Nota: isResizingProvider viene gestito a un livello superiore (MultiStaffDayView),
// non √® necessario importarlo qui.
import '../../../providers/layout_config_provider.dart';
import '../../../providers/resizing_provider.dart';
import '../../../providers/selected_appointment_provider.dart';
import '../../../providers/staff_columns_geometry_provider.dart';
import '../../../providers/temp_drag_time_provider.dart';
import '../../../providers/time_blocks_provider.dart';
import '../../widgets/booking_dialog.dart';
import '../helper/drag_drop_helper.dart';
import '../helper/layout_geometry_helper.dart';
import '../widgets/agenda_dividers.dart';
import '../widgets/appointment_card_base.dart';
import '../widgets/time_block_widget.dart';

class StaffColumn extends ConsumerStatefulWidget {
  final Staff staff;
  final List<Appointment> appointments;
  final double columnWidth;
  final bool showRightBorder;
  final bool isInteractionLocked;

  const StaffColumn({
    super.key,
    required this.staff,
    required this.appointments,
    required this.columnWidth,
    required this.isInteractionLocked,
    this.showRightBorder = true,
  });

  @override
  ConsumerState<StaffColumn> createState() => _StaffColumnState();
}

class _StaffColumnState extends ConsumerState<StaffColumn> {
  bool _isHighlighted = false;
  double? _hoverY;
  late final ProviderSubscription<Offset?> _dragListener;
  late final HighlightedStaffIdNotifier _highlightedNotifier;
  late final StaffColumnsGeometryNotifier _geometryNotifier;
  late final ProviderSubscription<int?> _highlightSubscription;
  int? _latestHighlightedId;

  // 1. Aggiunta sottoscrizione per il layout
  late final ProviderSubscription<LayoutConfig> _layoutConfigSub;

  @override
  void initState() {
    super.initState();

    _highlightedNotifier = ref.read(highlightedStaffIdProvider.notifier);
    _geometryNotifier = ref.read(staffColumnsGeometryProvider.notifier);
    _latestHighlightedId = ref.read(highlightedStaffIdProvider);
    _highlightSubscription = ref.listenManual<int?>(
      highlightedStaffIdProvider,
      (previous, next) => _latestHighlightedId = next,
    );

    // 2. Pianifica l'aggiornamento della geometria dopo il primo frame
    _scheduleGeometryUpdate();

    // 3. Ascolta i cambi di layout per ri-pianificare l'aggiornamento
    _layoutConfigSub = ref.listenManual<LayoutConfig>(layoutConfigProvider, (
      prev,
      next,
    ) {
      // Aggiorna la geometria solo se le dimensioni cambiano
      if (prev == null ||
          prev.slotHeight != next.slotHeight ||
          prev.headerHeight != next.headerHeight) {
        _scheduleGeometryUpdate();
      }
    });

    _dragListener = ref.listenManual<Offset?>(dragPositionProvider, (
      previous,
      next,
    ) {
      if (!mounted) return;

      final tempTimeNotifier = ref.read(tempDragTimeProvider.notifier);

      if (next == null) {
        if (_isHighlighted || _hoverY != null) {
          setState(() {
            _isHighlighted = false;
            _hoverY = null;
          });
        }
        _highlightedNotifier.clear();
        tempTimeNotifier.clear();
        return;
      }

      final box = context.findRenderObject() as RenderBox?;
      final bodyBox = ref.read(dragBodyBoxProvider);
      if (box == null || bodyBox == null) return;

      final columnTopLeftInBody = bodyBox.globalToLocal(
        box.localToGlobal(Offset.zero),
      );

      // ‚úÖ Aggiorna la geometria solo se cambia realmente (scroll o resize)
      final newRect = Rect.fromLTWH(
        columnTopLeftInBody.dx,
        columnTopLeftInBody.dy,
        box.size.width,
        box.size.height,
      );

      if (_lastGeometryRect == null ||
          (newRect.top - _lastGeometryRect!.top).abs() > 0.5 ||
          (newRect.left - _lastGeometryRect!.left).abs() > 0.5 ||
          (newRect.width - _lastGeometryRect!.width).abs() > 0.5 ||
          (newRect.height - _lastGeometryRect!.height).abs() > 0.5) {
        _lastGeometryRect = newRect;
        _geometryNotifier.setRect(widget.staff.id, newRect);
      }

      final localInColumn = Offset(
        next.dx - columnTopLeftInBody.dx,
        next.dy - columnTopLeftInBody.dy,
      );

      final withinHorizontal =
          localInColumn.dx >= 0 && localInColumn.dx <= box.size.width;
      if (withinHorizontal) {
        final dragOffset = ref.read(dragOffsetProvider);
        final layoutConfig = ref.read(layoutConfigProvider);

        // üîπ Altezza effettiva della card trascinata (fallback 50px se non nota)
        final draggedCardHeightPx =
            ref.read(draggedCardSizeProvider)?.height ?? 50.0;

        // üîπ Punto massimo CONSENTITO per l'inizio della card in pixel
        final maxYStartPx = (box.size.height - draggedCardHeightPx)
            .clamp(0, box.size.height)
            .toDouble();

        // üîπ Y effettiva del "top" della card, clampata ai limiti verticali
        final clampedLocalDy = localInColumn.dy.clamp(
          0.0,
          box.size.height.toDouble(),
        );
        final double effectiveY = (clampedLocalDy - (dragOffset ?? 0))
            .clamp(0, maxYStartPx)
            .toDouble();

        setState(() {
          _hoverY = effectiveY;
          _isHighlighted = true;
        });
        _highlightedNotifier.set(widget.staff.id);
        ref.read(draggedLastStaffIdProvider.notifier).set(widget.staff.id);

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // ‚è± Calcolo orario proposto
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        final slotHeight = layoutConfig.slotHeight;

        // minuti dall'inizio giornata (00:00)
        final minutesFromTop =
            (effectiveY / slotHeight) * layoutConfig.minutesPerSlot;

        // arrotondiamo a step di 5 minuti
        double roundedMinutes = (minutesFromTop / 5).round() * 5;

        // durata dell'appuntamento trascinato
        final draggedId = ref.read(draggedAppointmentIdProvider);
        Duration duration;
        DateTime baseDate;
        if (draggedId != null) {
          final appt = ref
              .read(appointmentsProvider)
              .requireValue
              .firstWhere((a) => a.id == draggedId);
          duration = appt.endTime.difference(appt.startTime);
          baseDate = DateTime(
            appt.startTime.year,
            appt.startTime.month,
            appt.startTime.day,
          );
        } else {
          final baseRange = ref.read(draggedBaseRangeProvider);
          if (baseRange != null) {
            final start = baseRange.$1;
            final end = baseRange.$2;
            duration = end.difference(start);
            baseDate = DateTime(start.year, start.month, start.day);
          } else {
            duration = const Duration(minutes: 30);
            final now = DateTime.now();
            baseDate = DateTime(now.year, now.month, now.day);
          }
        }

        final durationMinutes = duration.inMinutes;

        // üîí Limiti nell'arco della giornata
        const totalMinutes = LayoutConfig.hoursInDay * 60; // 1440
        final maxStartMinutesNum = (totalMinutes - durationMinutes).clamp(
          0,
          totalMinutes,
        );

        if (roundedMinutes > maxStartMinutesNum) {
          roundedMinutes = maxStartMinutesNum.toDouble();
        } else if (roundedMinutes < 0) {
          roundedMinutes = 0;
        }

        final startMinutes = roundedMinutes.toInt();
        final endMinutes = (startMinutes + durationMinutes)
            .clamp(0, totalMinutes)
            .toInt();

        final start = baseDate.add(Duration(minutes: startMinutes));
        var end = baseDate.add(Duration(minutes: endMinutes));

        final dayBoundary = baseDate.add(const Duration(days: 1));
        if (end.isAfter(dayBoundary)) end = dayBoundary;

        // aggiorna l'anteprima oraria mostrata nella card fantasma
        tempTimeNotifier.setTimes(start, end);
      } else if (_isHighlighted) {
        final headerHeight = ref.read(layoutConfigProvider).headerHeight;
        final globalY = next.dy;
        if (globalY > headerHeight - 5) return;

        setState(() {
          _isHighlighted = false;
          _hoverY = null;
        });
        _highlightedNotifier.clear();
        tempTimeNotifier.clear();
      }
    }, fireImmediately: false);
  }

  bool _geometryInitialized = false;
  Timer? _geometryDebounce;
  Rect? _lastGeometryRect;

  void _scheduleGeometryUpdate() {
    // Se gi√† inizializzato e debounce attivo, salta
    if (_geometryInitialized && _geometryDebounce != null) return;

    _geometryDebounce?.cancel();
    _geometryDebounce = Timer(const Duration(milliseconds: 220), () {
      if (!mounted) return;
      final box = context.findRenderObject() as RenderBox?;
      final bodyBox = ref.read(dragBodyBoxProvider);
      if (box == null || bodyBox == null) return;
      if (!box.attached || !bodyBox.attached) return;

      final topLeft = bodyBox.globalToLocal(box.localToGlobal(Offset.zero));
      final newRect = Rect.fromLTWH(
        topLeft.dx,
        topLeft.dy,
        box.size.width,
        box.size.height,
      );

      // ignora microvariazioni
      if (_lastGeometryRect != null &&
          (newRect.top - _lastGeometryRect!.top).abs() < 1.0 &&
          (newRect.left - _lastGeometryRect!.left).abs() < 1.0 &&
          (newRect.width - _lastGeometryRect!.width).abs() < 1.0 &&
          (newRect.height - _lastGeometryRect!.height).abs() < 1.0) {
        return;
      }

      _lastGeometryRect = newRect;
      _geometryInitialized = true; // ‚úÖ segna come inizializzato
      _geometryNotifier.setRect(widget.staff.id, newRect);
    });
  }

  @override
  void dispose() {
    _dragListener.close();
    _highlightSubscription.close();
    _layoutConfigSub.close(); // 5. Ricorda di chiudere la sottoscrizione
    final shouldClearHighlight = _latestHighlightedId == widget.staff.id;
    final staffId = widget.staff.id;
    Future.microtask(() {
      if (shouldClearHighlight) {
        _highlightedNotifier.clear();
      }
      _geometryNotifier.clearFor(staffId);
    });
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final allAppointments = ref.watch(appointmentsForCurrentLocationProvider);
    final staffAppointments = allAppointments
        .where((a) => a.staffId == widget.staff.id)
        .toList();

    // 6. RIMOSSO il blocco addPostFrameCallback da qui

    final layoutConfig = ref.watch(layoutConfigProvider);
    final slotHeight = layoutConfig.slotHeight;
    final totalSlots = layoutConfig.totalSlots;
    final appointmentsNotifier = ref.read(appointmentsProvider.notifier);
    final agendaDate = ref.watch(agendaDateProvider);

    // Interaction lock propagated from parent (evaluated once per visible group)
    final isInteractionLocked = widget.isInteractionLocked;

    // üîπ Calcola slot pieni PRIMA del layout (solo desktop e se abilitato)
    final formFactor = ref.watch(formFactorProvider);
    final bool showAddButtonStrip =
        layoutConfig.enableOccupiedSlotStrip &&
        formFactor == AppFormFactor.desktop &&
        !isInteractionLocked;
    final fullyOccupied = showAddButtonStrip
        ? ref.watch(fullyOccupiedSlotsProvider(widget.staff.id))
        : const <int>{};
    final hasFullyOccupiedSlots = fullyOccupied.isNotEmpty;

    // Larghezza disponibile per le card (ridotta se ci sono slot pieni)
    final addButtonWidth = hasFullyOccupiedSlots
        ? LayoutConfig.addButtonStripWidth
        : 0.0;
    final effectiveColumnWidth = widget.columnWidth - addButtonWidth;

    final stackChildren = <Widget>[];

    // üîπ Griglia oraria
    stackChildren.add(
      Column(
        children: List.generate(totalSlots, (index) {
          final slotsPerHour = 60 ~/ layoutConfig.minutesPerSlot;
          final isHourStart = (index + 1) % slotsPerHour == 0;
          return SizedBox(
            height: slotHeight,
            child: Align(
              alignment: Alignment.bottomLeft,
              child: AgendaHorizontalDivider(
                color: Colors.grey.withOpacity(isHourStart ? 0.5 : 0.2),
                thickness: isHourStart ? 1 : 0.5,
              ),
            ),
          );
        }),
      ),
    );

    // üîπ Layer slot non disponibili (texture pattern)
    final unavailableRanges = ref.watch(
      unavailableSlotRangesProvider(widget.staff.id),
    );
    if (unavailableRanges.isNotEmpty) {
      final colorScheme = Theme.of(context).colorScheme;
      final totalHeight = totalSlots * slotHeight;
      stackChildren.add(
        IgnorePointer(
          child: SizedBox(
            height: totalHeight,
            width: double.infinity,
            child: Stack(
              children: [
                for (final range in unavailableRanges)
                  Positioned(
                    top: range.startIndex * slotHeight,
                    left: 0,
                    right: 0,
                    child: UnavailableSlotRange(
                      slotCount: range.count,
                      slotHeight: slotHeight,
                      patternColor: AgendaTheme.unavailablePatternColor(
                        colorScheme,
                      ),
                      backgroundColor: AgendaTheme.unavailableBackgroundColor(
                        colorScheme,
                      ),
                    ),
                  ),
              ],
            ),
          ),
        ),
      );
    }

    // üîπ Layer interattivo HoverSlot (effetto all'hover del mouse)
    stackChildren.add(
      IgnorePointer(
        ignoring: false, // permette l'hover
        child: Column(
          children: List.generate(totalSlots, (index) {
            final slotTime = agendaDate.add(
              Duration(minutes: index * layoutConfig.minutesPerSlot),
            );
            if (!isInteractionLocked) {
              return LazyHoverSlot(
                slotTime: slotTime,
                height: slotHeight,
                colorPrimary1: Theme.of(context).colorScheme.primary,
                onTap: (dt) {
                  showBookingDialog(
                    context,
                    ref,
                    date: DateUtils.dateOnly(dt),
                    time: TimeOfDay(hour: dt.hour, minute: dt.minute),
                    initialStaffId: widget.staff.id,
                  );
                },
              );
            }

            // Mantieni lo spazio vuoto per evitare salti nel layout.
            return SizedBox(height: slotHeight, width: double.infinity);
          }),
        ),
      ),
    );

    // üîπ Appuntamenti (con larghezza ridotta se ci sono slot pieni)
    stackChildren.addAll(
      _buildAppointments(slotHeight, staffAppointments, effectiveColumnWidth),
    );

    // üîπ Blocchi di non disponibilit√†
    stackChildren.addAll(_buildTimeBlocks(slotHeight));

    // La fascia laterale √® gi√† riservata riducendo effectiveColumnWidth,
    // quindi le card si restringono automaticamente lasciando spazio a destra.

    return DragTarget<Appointment>(
      onWillAcceptWithDetails: (_) {
        setState(() => _isHighlighted = true);
        ref.read(highlightedStaffIdProvider.notifier).set(widget.staff.id);
        return true;
      },
      onLeave: (_) {
        setState(() => _isHighlighted = false);
        ref.read(highlightedStaffIdProvider.notifier).clear();
      },
      onAcceptWithDetails: (details) async {
        final previewTimes = ref.read(tempDragTimeProvider);
        setState(() {
          _isHighlighted = false;
          _hoverY = null;
        });
        ref.read(highlightedStaffIdProvider.notifier).clear();
        ref.read(tempDragTimeProvider.notifier).clear();

        final box = context.findRenderObject() as RenderBox?;
        if (box == null) return;

        final dragOffsetY = ref.read(dragOffsetProvider) ?? 0.0;
        final dragOffsetX = ref.read(dragOffsetXProvider) ?? 0.0;
        final pointerGlobal = details.offset + Offset(dragOffsetX, dragOffsetY);
        final localPointer = box.globalToLocal(pointerGlobal);
        final draggedCardHeightPx =
            ref.read(draggedCardSizeProvider)?.height ?? 50.0;

        final dropResult = computeDropResult(
          DropComputationParams(
            appointment: details.data,
            layoutConfig: layoutConfig,
            columnHeight: box.size.height,
            localPointer: localPointer,
            dragOffsetY: dragOffsetY,
            draggedCardHeightPx: draggedCardHeightPx,
            previewTimes: previewTimes,
          ),
        );

        ref.read(dragSessionProvider.notifier).markHandled();

        // Verifica se l'appuntamento √® stato effettivamente spostato
        final hasStaffChanged = details.data.staffId != widget.staff.id;
        final hasTimeChanged =
            details.data.startTime != dropResult.newStart ||
            details.data.endTime != dropResult.newEnd;

        // Se non c'√® stato alcun cambiamento, non mostrare il dialog
        if (!hasStaffChanged && !hasTimeChanged) {
          return;
        }

        // Salva i dati del drop pendente per mostrare la preview
        final pendingData = PendingDropData(
          appointmentId: details.data.id,
          originalStaffId: details.data.staffId,
          originalStart: details.data.startTime,
          originalEnd: details.data.endTime,
          newStaffId: widget.staff.id,
          newStart: dropResult.newStart,
          newEnd: dropResult.newEnd,
        );
        ref.read(pendingDropProvider.notifier).setPending(pendingData);

        // Mostra dialog di conferma prima di applicare lo spostamento
        if (!mounted) {
          ref.read(pendingDropProvider.notifier).clear();
          return;
        }
        final l10n = context.l10n;
        final newTimeStr = DtFmt.hm(
          context,
          dropResult.newStart.hour,
          dropResult.newStart.minute,
        );
        final staffName = widget.staff.displayName;

        final confirmed = await showConfirmDialog(
          context,
          title: Text(l10n.moveAppointmentConfirmTitle),
          content: Text(
            l10n.moveAppointmentConfirmMessage(newTimeStr, staffName),
          ),
          confirmLabel: l10n.actionConfirm,
          cancelLabel: l10n.actionCancel,
        );

        // Pulisci sempre lo stato pendente dopo la decisione
        ref.read(pendingDropProvider.notifier).clear();

        if (confirmed && mounted) {
          appointmentsNotifier.moveAppointment(
            appointmentId: details.data.id,
            newStaffId: widget.staff.id,
            newStart: dropResult.newStart,
            newEnd: dropResult.newEnd,
          );
        }
      },
      builder: (context, candidateData, rejectedData) {
        return GestureDetector(
          onTap: () {
            ref.read(selectedAppointmentProvider.notifier).clear();
          },
          child: SizedBox(
            width: widget.columnWidth,
            child: Container(
              decoration: BoxDecoration(
                color: _isHighlighted
                    ? widget.staff.color.withOpacity(0.01)
                    : Colors.transparent,
                border: widget.showRightBorder
                    ? Border(
                        right: BorderSide(
                          color: Colors.grey.withOpacity(0.5),
                          width: 1.0,
                        ),
                      )
                    : null,
              ),
              child: Stack(children: stackChildren),
            ),
          ),
        );
      },
    );
  }

  List<Widget> _buildAppointments(
    double slotHeight,
    List<Appointment> appointments,
    double columnWidth,
  ) {
    final draggedId = ref.watch(draggedAppointmentIdProvider);
    final layoutConfig = ref.watch(layoutConfigProvider);
    // üîπ Watch fuori dal loop per evitare rebuild multipli
    final pendingDrop = ref.watch(pendingDropProvider);
    final variants = layoutConfig.useServiceColorsForAppointments
        ? (ref.watch(serviceVariantsProvider).value ?? [])
        : <dynamic>[];
    // Pre-calcola la mappa dei colori dei servizi (da varianti)
    final serviceColorMap = <int, Color>{};
    for (final variant in variants) {
      if (variant is ServiceVariant && variant.colorHex != null) {
        serviceColorMap[variant.serviceId] = ColorUtils.fromHex(
          variant.colorHex!,
        );
      }
    }

    final layoutAppointments = appointments.map((appt) {
      final resizingEntry = ref.watch(resizingEntryProvider(appt.id));
      if (resizingEntry != null &&
          resizingEntry.provisionalEndTime != appt.endTime) {
        return appt.copyWith(endTime: resizingEntry.provisionalEndTime);
      }
      return appt;
    }).toList();

    final List<List<Appointment>> overlapGroups = [];
    for (final appt in layoutAppointments) {
      bool added = false;
      for (final group in overlapGroups) {
        if (group.any(
          (g) =>
              appt.startTime.isBefore(g.endTime) &&
              appt.endTime.isAfter(g.startTime),
        )) {
          group.add(appt);
          added = true;
          break;
        }
      }
      if (!added) {
        overlapGroups.add([appt]);
      }
    }

    final positionedAppointments = <Widget>[];

    final originalAppointmentsMap = {for (var a in appointments) a.id: a};
    final layoutEntries = layoutAppointments
        .map((a) => LayoutEntry(id: a.id, start: a.startTime, end: a.endTime))
        .toList();
    final layoutGeometry = computeLayoutGeometry(
      layoutEntries,
      useClusterMaxConcurrency: layoutConfig.useClusterMaxConcurrency,
    );

    for (final group in overlapGroups) {
      final groupWidgets = <Widget>[];
      final groupSize = group.length;
      group.sort((a, b) => a.startTime.compareTo(b.startTime));

      for (int i = 0; i < groupSize; i++) {
        final layoutAppt = group[i];
        final originalAppt = originalAppointmentsMap[layoutAppt.id]!;

        final isDragged = originalAppt.id == draggedId;

        final dayStart = DateTime(
          originalAppt.startTime.year,
          originalAppt.startTime.month,
          originalAppt.startTime.day,
        );

        final startMinutes = originalAppt.startTime
            .difference(dayStart)
            .inMinutes;

        final endMinutes = layoutAppt.endTime.difference(dayStart).inMinutes;

        final double top =
            (startMinutes / layoutConfig.minutesPerSlot) * slotHeight;
        double height =
            ((endMinutes - startMinutes) / layoutConfig.minutesPerSlot) *
            slotHeight;

        final entry = ref.watch(resizingEntryProvider(originalAppt.id));
        if (entry != null) {
          height = entry.currentPreviewHeightPx;
        }

        final geometry =
            layoutGeometry[originalAppt.id] ??
            const EventGeometry(leftFraction: 0, widthFraction: 1);

        // Controlla se questo appuntamento ha un drop pendente (usa variabile pre-calcolata)
        final hasPendingDrop = pendingDrop?.appointmentId == originalAppt.id;
        final isOriginalPosition =
            hasPendingDrop && pendingDrop!.originalStaffId == widget.staff.id;

        double opacity = isDragged ? AgendaTheme.ghostOpacity : 1.0;
        // Se √® la posizione originale durante un drop pendente, mostra semi-trasparente
        if (isOriginalPosition) {
          opacity = AgendaTheme.ghostOpacity;
        }

        // üîπ Costruisci la card (usa columnWidth passato, che √® gi√† ridotto se ci sono slot pieni)
        final padding = LayoutConfig.columnInnerPadding;
        final fullColumnWidth = math.max(columnWidth - padding * 2, 0.0);
        final cardLeft = columnWidth * geometry.leftFraction + padding;
        final cardWidth = math.max(
          columnWidth * geometry.widthFraction - padding * 2,
          0.0,
        );

        Color cardColor = widget.staff.color;
        if (layoutConfig.useServiceColorsForAppointments) {
          // Priorit√†: colore del servizio (configurabile dall'operatore).
          final serviceColor = serviceColorMap[originalAppt.serviceId];
          if (serviceColor != null) {
            cardColor = serviceColor;
          } else {
            final variant = ref.watch(
              serviceVariantByIdProvider(originalAppt.serviceVariantId),
            );
            if (variant != null && variant.colorHex != null) {
              cardColor = ColorUtils.fromHex(variant.colorHex!);
            }
          }
        }

        groupWidgets.add(
          Positioned(
            key: ValueKey(originalAppt.id),
            top: top,
            left: cardLeft,
            width: cardWidth,
            height: height,
            child: Opacity(
              opacity: opacity,
              child: AppointmentCard(
                appointment: originalAppt,
                color: cardColor,
                columnWidth: cardWidth,
                columnOffset: cardLeft,
                dragTargetWidth: fullColumnWidth,
                expandToLeft: i > 0,
              ),
            ),
          ),
        );
      }

      // Posizioniamo i widget del gruppo in ordine inverso, cos√¨ gli
      // appuntamenti che iniziano prima rimangono sopra e non vengono
      // parzialmente coperti da quelli iniziati dopo.
      positionedAppointments.addAll(groupWidgets.reversed);
    }

    // üîπ Aggiungi preview per drop pendente se questa √® la colonna di destinazione
    // (usa la variabile pendingDrop gi√† calcolata all'inizio del metodo)
    if (pendingDrop != null && pendingDrop.newStaffId == widget.staff.id) {
      // Trova l'appuntamento originale nel provider globale
      final allAppointments = ref.watch(appointmentsProvider).value ?? [];
      final originalAppt = allAppointments.cast<Appointment?>().firstWhere(
        (a) => a?.id == pendingDrop.appointmentId,
        orElse: () => null,
      );

      if (originalAppt != null) {
        final dayStart = DateTime(
          pendingDrop.newStart.year,
          pendingDrop.newStart.month,
          pendingDrop.newStart.day,
        );

        final startMinutes = pendingDrop.newStart
            .difference(dayStart)
            .inMinutes;
        final endMinutes = pendingDrop.newEnd.difference(dayStart).inMinutes;

        final double top =
            (startMinutes / layoutConfig.minutesPerSlot) * slotHeight;
        final double height =
            ((endMinutes - startMinutes) / layoutConfig.minutesPerSlot) *
            slotHeight;

        final padding = LayoutConfig.columnInnerPadding;
        final cardWidth = math.max(widget.columnWidth - padding * 2, 0.0);

        Color cardColor = widget.staff.color;
        if (layoutConfig.useServiceColorsForAppointments) {
          // Priorit√†: colore del servizio (configurabile dall'operatore).
          final serviceColor = serviceColorMap[originalAppt.serviceId];
          if (serviceColor != null) {
            cardColor = serviceColor;
          } else {
            final variant = ref.watch(
              serviceVariantByIdProvider(originalAppt.serviceVariantId),
            );
            if (variant != null && variant.colorHex != null) {
              cardColor = ColorUtils.fromHex(variant.colorHex!);
            }
          }
        }

        // Preview card con bordo tratteggiato per indicare la posizione proposta
        positionedAppointments.add(
          Positioned(
            key: const ValueKey('pending_drop_preview'),
            top: top,
            left: padding,
            width: cardWidth,
            height: height,
            child: IgnorePointer(
              child: Container(
                decoration: BoxDecoration(
                  color: cardColor.withOpacity(0.3),
                  borderRadius: BorderRadius.circular(
                    LayoutConfig.borderRadius,
                  ),
                  border: Border.all(
                    color: cardColor,
                    width: 2,
                    strokeAlign: BorderSide.strokeAlignInside,
                  ),
                ),
                child: Center(
                  child: Icon(Icons.arrow_downward, color: cardColor, size: 24),
                ),
              ),
            ),
          ),
        );
      }
    }

    return positionedAppointments;
  }

  /// Costruisce i widget per i blocchi di non disponibilit√† dello staff.
  List<Widget> _buildTimeBlocks(double slotHeight) {
    final blocks = ref.watch(timeBlocksForStaffProvider(widget.staff.id));
    if (blocks.isEmpty) return [];

    final layoutConfig = ref.watch(layoutConfigProvider);
    final agendaDate = ref.watch(agendaDateProvider);
    final dayStart = DateTime(
      agendaDate.year,
      agendaDate.month,
      agendaDate.day,
    );

    final positionedBlocks = <Widget>[];
    final padding = LayoutConfig.columnInnerPadding;
    final cardWidth = math.max(widget.columnWidth - padding * 2, 0.0);

    for (final block in blocks) {
      // Calcola posizione verticale
      final startMinutes = block.startTime.difference(dayStart).inMinutes;
      final endMinutes = block.endTime.difference(dayStart).inMinutes;

      // Clamp ai limiti della giornata visualizzata
      final clampedStartMinutes = startMinutes.clamp(
        0,
        LayoutConfig.hoursInDay * 60,
      );
      final clampedEndMinutes = endMinutes.clamp(
        0,
        LayoutConfig.hoursInDay * 60,
      );

      if (clampedEndMinutes <= clampedStartMinutes) continue;

      final double top =
          (clampedStartMinutes / layoutConfig.minutesPerSlot) * slotHeight;
      final double height =
          ((clampedEndMinutes - clampedStartMinutes) /
              layoutConfig.minutesPerSlot) *
          slotHeight;

      positionedBlocks.add(
        Positioned(
          key: ValueKey('block_${block.id}'),
          top: top,
          left: padding,
          width: cardWidth,
          height: height,
          child: TimeBlockWidget(
            block: block,
            height: height,
            width: cardWidth,
          ),
        ),
      );
    }

    return positionedBlocks;
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/components/hour_column.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../domain/config/agenda_theme.dart';
import '../../../../providers/layout_config_provider.dart';
import '../../widgets/agenda_dividers.dart';

class HourColumn extends ConsumerWidget {
  const HourColumn({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final layoutConfig = ref.watch(layoutConfigProvider);
    final slotHeight = layoutConfig.slotHeight;
    final totalSlots = layoutConfig.totalSlots;
    final slotsPerHour = (60 ~/ layoutConfig.minutesPerSlot);

    return Column(
      children: List.generate(totalSlots, (index) {
        final isHourStart = index % slotsPerHour == 0;
        final isMainLine = (index + 1) % slotsPerHour == 0;
        final hour = (index ~/ slotsPerHour);
        final minutes = (index % slotsPerHour) * layoutConfig.minutesPerSlot;

        return SizedBox(
          height: slotHeight,
          child: Stack(
            children: [
              if (isHourStart)
                Align(
                  alignment: Alignment.center,
                  child: Text(
                    "${hour.toString().padLeft(2, '0')}:${minutes.toString().padLeft(2, '0')}",
                    textAlign: TextAlign.center,
                    style: AgendaTheme.hourTextStyle,
                  ),
                ),
              Align(
                alignment: Alignment.bottomLeft,
                child: AgendaHorizontalDivider(
                  color: Colors.grey.withOpacity(isMainLine ? 0.5 : 0.2),
                  thickness: isMainLine ? 1 : 0.5,
                ),
              ),
            ],
          ),
        );
      }),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/components/agenda_staff_header.dart ---
import 'package:flutter/material.dart';

import '../../../../../../core/models/staff.dart';
import '../../../../../../core/widgets/no_scrollbar_behavior.dart';
import 'staff_header_row.dart';

class AgendaStaffHeader extends StatelessWidget {
  const AgendaStaffHeader({
    super.key,
    required this.staffList,
    required this.hourColumnWidth,
    required this.totalHeight,
    required this.headerHeight,
    required this.columnWidth,
    required this.scrollController,
  });

  final List<Staff> staffList;
  final double hourColumnWidth;
  final double totalHeight;
  final double headerHeight;
  final double columnWidth;
  final ScrollController scrollController;

  @override
  Widget build(BuildContext context) {
    return Material(
      elevation: 8,
      shadowColor: Colors.black.withOpacity(0.3),
      surfaceTintColor: Colors.transparent,
      child: DecoratedBox(
        decoration: const BoxDecoration(
          border: Border(
            bottom: BorderSide(color: Color(0x1F000000), width: 0.5),
          ),
        ),
        child: ScrollConfiguration(
          behavior: const NoScrollbarBehavior(),
          child: SingleChildScrollView(
            controller: scrollController,
            scrollDirection: Axis.horizontal,
            physics: const ClampingScrollPhysics(),
            child: StaffHeaderRow(
              staffList: staffList,
              scrollController: scrollController,
              columnWidth: columnWidth,
              hourColumnWidth: hourColumnWidth,
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/components/staff_header_row.dart ---
import 'dart:math' as math;

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../../app/widgets/staff_circle_avatar.dart';
import '../../../../../../core/l10n/l10_extension.dart';
import '../../../../../../core/models/staff.dart';
import '../../../../../../core/widgets/app_dialogs.dart';
import '../../../../domain/config/layout_config.dart';
import '../../../../providers/highlighted_staff_provider.dart';
import '../../../../providers/layout_config_provider.dart';
import '../../../../../staff/presentation/dialogs/staff_dialog.dart';

class StaffHeaderRow extends ConsumerWidget {
  final List<Staff> staffList;
  final ScrollController
  scrollController; // non usato per scrollare qui, ma utile per offset/read
  final double columnWidth;
  final double hourColumnWidth; // NON usato per lasciare spazio iniziale

  const StaffHeaderRow({
    super.key,
    required this.staffList,
    required this.scrollController,
    required this.columnWidth,
    required this.hourColumnWidth,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final headerHeight = ref.watch(layoutConfigProvider).headerHeight;
    final avatarDefault = LayoutConfig.avatarSizeFor(context);
    // Ensure avatar is not larger than available header space to avoid overflow
    final avatarSize = math.min(avatarDefault, headerHeight * 0.55);
    final highlightedId = ref.watch(highlightedStaffIdProvider);

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        ...staffList.asMap().entries.map((entry) {
          final index = entry.key;
          final staff = entry.value;
          final isLast = index == staffList.length - 1;
          final isHighlighted = highlightedId == staff.id;

          final initials = staff.initials;
          final displayName = staff.displayName;

          return Stack(
            children: [
              Container(
                width: columnWidth,
                height: headerHeight,
                padding: EdgeInsets.symmetric(horizontal: headerHeight * 0.08),
                child: Center(
                  child: _StaffHeaderCell(
                    initials: initials,
                    displayName: displayName,
                    avatarSize: avatarSize,
                    isHighlighted: isHighlighted,
                    isBookableOnline: staff.isBookableOnline,
                    color: staff.color,
                    onEdit: () => showStaffDialog(
                      context,
                      ref,
                      initial: staff,
                    ),
                  ),
                ),
              ),
              if (!isLast)
                Positioned(
                  right: 0,
                  top: 0,
                  bottom: 0,
                  child: Container(
                    width: 1,
                    decoration: BoxDecoration(
                      gradient: LinearGradient(
                        begin: Alignment.topCenter,
                        end: Alignment.bottomCenter,
                        colors: [
                          Colors.grey.withOpacity(0.0),
                          Colors.grey.withOpacity(0.25),
                        ],
                        stops: const [0.0, 0.7],
                      ),
                    ),
                  ),
                ),
            ],
          );
        }),
      ],
    );
  }
}

class _StaffHeaderCell extends StatefulWidget {
  const _StaffHeaderCell({
    required this.initials,
    required this.displayName,
    required this.avatarSize,
    required this.isHighlighted,
    required this.isBookableOnline,
    required this.color,
    required this.onEdit,
  });

  final String initials;
  final String displayName;
  final double avatarSize;
  final bool isHighlighted;
  final bool isBookableOnline;
  final Color color;
  final VoidCallback onEdit;

  @override
  State<_StaffHeaderCell> createState() => _StaffHeaderCellState();
}

class _StaffHeaderCellState extends State<_StaffHeaderCell> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      cursor: SystemMouseCursors.click,
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 4),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
        ),
        child: Material(
          color: Colors.transparent,
          child: InkWell(
            onTap: widget.onEdit,
            splashColor: Colors.transparent,
            hoverColor: Colors.transparent,
            highlightColor: Colors.transparent,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Stack(
                  clipBehavior: Clip.none,
                  children: [
                    StaffCircleAvatar(
                      height: widget.avatarSize,
                      color: widget.color,
                      isHighlighted: widget.isHighlighted || _isHovered,
                      initials: widget.initials,
                    ),
                    if (!widget.isBookableOnline)
                      Positioned.fill(
                        child: Align(
                          alignment: const Alignment(0.78, 0.78),
                          child: Transform.translate(
                            offset: Offset(
                              widget.avatarSize * 0.02,
                              widget.avatarSize * 0.02,
                            ),
                            child: Tooltip(
                              message:
                                  context.l10n.staffNotBookableOnlineTooltip,
                              child: GestureDetector(
                                onTap: () {
                                  showAppInfoDialog(
                                    context,
                                    title: Text(
                                      context.l10n
                                          .staffNotBookableOnlineTitle,
                                    ),
                                    content: Text(
                                      context.l10n
                                          .staffNotBookableOnlineMessage,
                                    ),
                                    closeLabel: context.l10n.actionClose,
                                  );
                                },
                                child: Container(
                                  padding: const EdgeInsets.all(2),
                                  decoration: BoxDecoration(
                                    color:
                                        Theme.of(context).colorScheme.surface,
                                    shape: BoxShape.circle,
                                  ),
                                  child: Icon(
                                    Icons.cloud_off_outlined,
                                    size: 14,
                                    color:
                                        Theme.of(context).colorScheme.primary,
                                  ),
                                ),
                              ),
                            ),
                          ),
                        ),
                      ),
                  ],
                ),
                const SizedBox(height: 4),
                Text(
                  widget.displayName,
                  maxLines: 1,
                  textAlign: TextAlign.center,
                  overflow: TextOverflow.ellipsis,
                  style: const TextStyle(
                    fontWeight: FontWeight.w600,
                    fontSize: 11,
                    color: Colors.black87,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/agenda_staff_body.dart ---
import 'package:flutter/material.dart';

import '../../../../../core/models/appointment.dart';
import '../../../../../core/models/staff.dart';
import '../../../../../core/widgets/no_scrollbar_behavior.dart';
import '../../../domain/config/layout_config.dart';
import '../helper/responsive_layout.dart';
import 'staff_column.dart';

class AgendaStaffBody extends StatelessWidget {
  const AgendaStaffBody({
    super.key,
    required this.verticalController,
    required this.horizontalController,
    required this.staffList,
    required this.appointments,
    required this.layoutConfig,
    required this.availableWidth,
    required this.isResizing,
    required this.dragLayerLink,
    required this.bodyKey,
    required this.isInteractionLocked,
  });

  final ScrollController verticalController;
  final ScrollController horizontalController;
  final List<Staff> staffList;
  final List<Appointment> appointments;
  final LayoutConfig layoutConfig;
  final double availableWidth;
  final bool isResizing;
  final LayerLink? dragLayerLink;
  final GlobalKey bodyKey;
  final bool isInteractionLocked;

  @override
  Widget build(BuildContext context) {
    final layout = ResponsiveLayout.of(
      context,
      staffCount: staffList.length,
      config: layoutConfig,
      availableWidth: availableWidth,
    );

    final totalContentWidth = layout.columnWidth * staffList.length;

    // final hourColumnWidth = layoutConfig.hourColumnWidth;

    Widget content = ScrollConfiguration(
      // mantiene l'assenza di scrollbar come prima
      behavior: const NoScrollbarBehavior(),
      child: SingleChildScrollView(
        controller: verticalController,
        physics: isResizing
            ? const NeverScrollableScrollPhysics()
            : const ClampingScrollPhysics(),
        child: Stack(
          children: [
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(
                  child: SingleChildScrollView(
                    controller: horizontalController,
                    scrollDirection: Axis.horizontal,
                    physics: const ClampingScrollPhysics(),
                    clipBehavior: Clip.hardEdge,
                    child: SizedBox(
                      width: totalContentWidth,
                      child: Stack(
                        children: [
                          // üîπ Colonne staff (come prima)
                          Row(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: staffList.asMap().entries.map((entry) {
                              final index = entry.key;
                              final staff = entry.value;
                              final isLast = index == staffList.length - 1;
                              final staffAppointments = appointments
                                  .where(
                                    (appointment) =>
                                        appointment.staffId == staff.id,
                                  )
                                  .toList();

                              return StaffColumn(
                                staff: staff,
                                appointments: staffAppointments,
                                columnWidth: layout.columnWidth,
                                isInteractionLocked: isInteractionLocked,
                                // Questo flag ora √® ignorato all'interno di StaffColumn,
                                // ma lo manteniamo per compatibilit√†.
                                showRightBorder:
                                    staffList.length > 1 && !isLast,
                              );
                            }).toList(),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
            //CurrentTimeLine(hourColumnWidth: hourColumnWidth),
          ],
        ),
      ),
    );

    if (dragLayerLink != null) {
      content = CompositedTransformTarget(
        key: bodyKey,
        link: dragLayerLink!,
        child: content,
      );
    } else {
      content = KeyedSubtree(key: bodyKey, child: content);
    }

    return content;
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/agenda_day.dart ---
import 'package:agenda_backend/features/agenda/presentation/screens/day_view/multi_staff_day_view.dart';
import 'package:agenda_backend/features/agenda/providers/date_range_provider.dart';
import 'package:agenda_backend/features/agenda/providers/initial_scroll_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../core/models/staff.dart';
import '../../../domain/config/layout_config.dart';
import '../../../providers/layout_config_provider.dart';

class AgendaDayController {
  _AgendaDayState? _state;
  double? _pendingOffset;

  void _attach(_AgendaDayState state) {
    _state = state;
    if (_pendingOffset != null) {
      state._jumpToExternalOffset(_pendingOffset!);
      _pendingOffset = null;
    }
  }

  void _detach(_AgendaDayState state) {
    if (_state == state) _state = null;
  }

  void jumpTo(double offset) {
    final state = _state;
    if (state == null) {
      _pendingOffset = offset;
      return;
    }
    state._jumpToExternalOffset(offset);
  }

  void dispose() {
    _state = null;
    _pendingOffset = null;
  }
}

class AgendaDay extends ConsumerStatefulWidget {
  const AgendaDay({
    super.key,
    required this.staffList,
    this.onVerticalOffsetChanged,
    this.controller,
    required this.hourColumnWidth,
    required this.currentTimeVerticalOffset,
  });

  final List<Staff> staffList;
  final ValueChanged<double>? onVerticalOffsetChanged;
  final AgendaDayController? controller;
  final double hourColumnWidth;
  final double currentTimeVerticalOffset;

  @override
  ConsumerState<AgendaDay> createState() => _AgendaDayState();
}

class _AgendaDayState extends ConsumerState<AgendaDay> {
  ScrollController? _centerVerticalController;

  DateTime? _previousDate;
  bool _slideFromRight = true;

  /// Data attualmente attiva per filtrare eventi da widget in uscita
  DateTime? _activeDate;

  @override
  void initState() {
    super.initState();
    widget.controller?._attach(this);
  }

  @override
  void dispose() {
    widget.controller?._detach(this);
    super.dispose();
  }

  /// Ottiene l'offset corrente (dal provider o calcolato dall'orario attuale)
  double _getCurrentScrollOffset() {
    final savedOffset = ref.read(agendaVerticalOffsetProvider);
    if (savedOffset != null) {
      return savedOffset;
    }
    // Prima apertura: usa l'orario corrente
    final layoutConfig = ref.read(layoutConfigProvider);
    return _timelineOffsetForToday(layoutConfig);
  }

  void _handleCenterVerticalController(ScrollController controller) {
    if (_centerVerticalController == controller) return;
    _centerVerticalController = controller;

    // üîπ Scroll all'orario corrente SOLO alla prima apertura dell'app
    final initialScrollDone = ref.read(initialScrollDoneProvider);

    if (initialScrollDone) {
      // Non √® la prima apertura: sincronizza solo la HourColumn con l'offset corrente
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (!mounted || !controller.hasClients) return;
        // Notifica l'offset corrente per sincronizzare la HourColumn
        widget.onVerticalOffsetChanged?.call(_getCurrentScrollOffset());
      });
      return;
    }

    final layoutConfig = ref.read(layoutConfigProvider);
    final initialOffset = _timelineOffsetForToday(layoutConfig);

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted || !controller.hasClients) return;

      // Marca lo scroll iniziale come completato (dopo il build)
      ref.read(initialScrollDoneProvider.notifier).markDone();

      // Centra la timeline al centro della viewport visibile
      final viewportHeight = controller.position.viewportDimension;
      final target = (initialOffset - viewportHeight / 2)
          .clamp(
            controller.position.minScrollExtent,
            controller.position.maxScrollExtent,
          )
          .toDouble();
      controller.jumpTo(target);
      // Salva nel provider
      ref.read(agendaVerticalOffsetProvider.notifier).set(target);
      widget.onVerticalOffsetChanged?.call(target);
    });
  }

  void _jumpToExternalOffset(double offset) {
    final controller = _centerVerticalController;
    if (controller == null || !controller.hasClients) {
      ref.read(agendaVerticalOffsetProvider.notifier).set(offset);
      return;
    }

    final clamped = offset.clamp(
      controller.position.minScrollExtent,
      controller.position.maxScrollExtent,
    );

    if ((controller.offset - clamped).abs() < 0.5) {
      ref.read(agendaVerticalOffsetProvider.notifier).set(clamped);
      return;
    }

    controller.jumpTo(clamped);
    ref.read(agendaVerticalOffsetProvider.notifier).set(clamped);
    widget.onVerticalOffsetChanged?.call(clamped);
  }

  @override
  Widget build(BuildContext context) {
    final date = ref.watch(agendaDateProvider);
    final currentScrollOffset = _getCurrentScrollOffset();

    // calcola direzione
    if (_previousDate != null && _previousDate != date) {
      _slideFromRight = date.isBefore(_previousDate!);
    }
    _previousDate = date;

    // Aggiorna la data attiva per filtrare callback da widget in uscita
    _activeDate = date;

    // üëá AnimatedSwitcher forza animazione visibile anche se Flutter riusa il widget
    return AnimatedSwitcher(
      duration: const Duration(milliseconds: 400),
      reverseDuration: const Duration(milliseconds: 250),
      layoutBuilder: (currentChild, previousChildren) {
        return Stack(
          clipBehavior: Clip.none,
          children: [
            ...previousChildren,
            if (currentChild != null) currentChild,
          ],
        );
      },
      transitionBuilder: (Widget child, Animation<double> animation) {
        final offsetTween = Tween<Offset>(
          begin: _slideFromRight
              ? const Offset(1.0, 0.0)
              : const Offset(-1.0, 0.0),
          end: Offset.zero,
        ).chain(CurveTween(curve: Curves.easeOutCubic));

        // üëá Fade + Slide combinati per rendere visibile la transizione
        return SlideTransition(
          position: animation.drive(offsetTween),
          child: FadeTransition(
            opacity: animation.drive(CurveTween(curve: Curves.easeInOut)),
            child: child,
          ),
        );
      },
      // üëá chiave unica e realmente diversa a ogni data
      child: _AnimatedDayContainer(
        key: ValueKey('day-${date.toIso8601String()}'),
        date: date,
        staffList: widget.staffList,
        currentScrollOffset: currentScrollOffset,
        onVerticalOffsetChanged: (containerDate, offset) {
          // Ignora callback da widget in uscita (durante animazione)
          if (containerDate == _activeDate) {
            _handleScrollOffsetChanged(offset);
          }
        },
        onVerticalControllerChanged: _handleCenterVerticalController,
        hourColumnWidth: widget.hourColumnWidth,
        currentTimeVerticalOffset: widget.currentTimeVerticalOffset,
      ),
    );
  }

  /// Intercetta l'offset scroll per mantenerlo al cambio data
  void _handleScrollOffsetChanged(double offset) {
    ref.read(agendaVerticalOffsetProvider.notifier).set(offset);
    widget.onVerticalOffsetChanged?.call(offset);
  }

  double _timelineOffsetForToday(LayoutConfig layoutConfig) {
    final now = DateTime.now();
    final minutes = now.hour * 60 + now.minute;
    return (minutes / layoutConfig.minutesPerSlot) * layoutConfig.slotHeight;
  }
}

class _AnimatedDayContainer extends StatelessWidget {
  const _AnimatedDayContainer({
    super.key,
    required this.date,
    required this.staffList,
    required this.currentScrollOffset,
    this.onVerticalOffsetChanged,
    required this.onVerticalControllerChanged,
    required this.hourColumnWidth,
    required this.currentTimeVerticalOffset,
  });

  final DateTime date;
  final List<Staff> staffList;
  final double currentScrollOffset;
  final void Function(DateTime date, double offset)? onVerticalOffsetChanged;
  final ValueChanged<ScrollController> onVerticalControllerChanged;
  final double hourColumnWidth;
  final double currentTimeVerticalOffset;

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        return MultiStaffDayView(
          staffList: staffList,
          initialScrollOffset: currentScrollOffset,
          onScrollOffsetChanged: (offset) {
            onVerticalOffsetChanged?.call(date, offset);
          },
          onVerticalControllerChanged: onVerticalControllerChanged,
          hourColumnWidth: hourColumnWidth,
          currentTimeVerticalOffset: currentTimeVerticalOffset,
        );
      },
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/multi_staff_day_view.dart ---
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../core/models/staff.dart';
import '../../../domain/config/layout_config.dart';
import '../../../providers/agenda_interaction_lock_provider.dart';
import '../../../providers/agenda_providers.dart';
import '../../../providers/agenda_scroll_provider.dart';
import '../../../providers/agenda_scroll_request_provider.dart';
import '../../../providers/appointment_providers.dart';
import '../../../providers/date_range_provider.dart';
import '../../../providers/drag_layer_link_provider.dart';
import '../../../providers/is_resizing_provider.dart';
import '../../../providers/layout_config_provider.dart';
import '../helper/responsive_layout.dart';
import '../widgets/current_time_line.dart';
import 'agenda_staff_body.dart';
import 'components/agenda_staff_header.dart';

class MultiStaffDayView extends ConsumerStatefulWidget {
  final List<Staff> staffList;
  final double initialScrollOffset;
  final ValueChanged<double>? onScrollOffsetChanged;
  final ValueChanged<ScrollController>? onVerticalControllerChanged;
  final double hourColumnWidth;
  final double currentTimeVerticalOffset;

  const MultiStaffDayView({
    super.key,
    required this.staffList,
    required this.initialScrollOffset,
    this.onScrollOffsetChanged,
    this.onVerticalControllerChanged,
    required this.hourColumnWidth,
    required this.currentTimeVerticalOffset,
  });

  @override
  ConsumerState<MultiStaffDayView> createState() => _MultiStaffDayViewState();
}

class _MultiStaffDayViewState extends ConsumerState<MultiStaffDayView> {
  // Auto scroll durante il drag
  Timer? _autoScrollTimer;
  static const double _scrollEdgeMargin = 100;
  static const double _scrollSpeed = 20;
  static const Duration _scrollInterval = Duration(milliseconds: 50);
  static const double _autoScrollActivationThreshold = 16;

  late final ProviderSubscription<Offset?> _dragSub;
  late final ProviderSubscription<LayoutConfig> _layoutSub;
  late final ProviderSubscription<AgendaScrollRequest?> _scrollRequestSub;
  late final ProviderSubscription<DateTime> _dateSub;

  final ScrollController _headerHCtrl = ScrollController();
  bool _isSyncing = false;
  Offset? _initialDragPosition;
  bool _autoScrollArmed = false;

  ScrollController? _bodyHorizontalCtrl;
  ScrollController? _verticalCtrl;
  List<int>? _staffSignature;

  late final DragBodyBoxNotifier _dragBodyNotifier;
  AgendaScrollRequest? _pendingScrollRequest;
  Timer? _scrollRetryTimer;

  Timer? _syncDebounce;

  final GlobalKey _bodyKey = GlobalKey();
  final GlobalKey _headerKey = GlobalKey();

  late final Object _scrollIdentity = Object();
  AgendaScrollKey get _scrollKey => AgendaScrollKey(
    identity: _scrollIdentity,
    staff: widget.staffList,
    date: DateTime.now(),
    initialOffset: widget.initialScrollOffset,
  );

  @override
  void initState() {
    super.initState();
    _dragBodyNotifier = ref.read(dragBodyBoxProvider.notifier);

    // Listener drag ‚Üí auto scroll verticale
    _dragSub = ref.listenManual<Offset?>(dragPositionProvider, (prev, next) {
      if (next != null) {
        if (prev == null) {
          _initialDragPosition = next;
          _autoScrollArmed = false;
        }
        _startAutoScroll();
      } else {
        _initialDragPosition = null;
        _autoScrollArmed = false;
        _stopAutoScroll();
      }
    });

    // Listener layoutConfig ‚Üí solo quando cambiano dimensioni rilevanti
    _layoutSub = ref.listenManual<LayoutConfig>(layoutConfigProvider, (
      prev,
      next,
    ) {
      if (prev == null ||
          prev.headerHeight != next.headerHeight ||
          prev.slotHeight != next.slotHeight ||
          prev.hourColumnWidth != next.hourColumnWidth) {
        _scheduleSyncUpdate();
      }
    });

    _scrollRequestSub = ref.listenManual<AgendaScrollRequest?>(
      agendaScrollRequestProvider,
      (prev, next) {
        if (next == null) return;
        final selectedDate = ref.read(agendaDateProvider);
        if (!DateUtils.isSameDay(selectedDate, next.date)) return;
        _pendingScrollRequest = next;
        _scheduleScrollToPending();
      },
    );

    // üîπ Rimosso: lo scroll automatico al cambio data
    // Lo scroll avviene SOLO:
    // 1. Alla prima apertura dell'app (gestito in AgendaDay._handleCenterVerticalController)
    // 2. Dopo creazione/modifica appuntamento (via agendaScrollRequestProvider)
    _dateSub = ref.listenManual<DateTime>(agendaDateProvider, (prev, next) {
      // No-op: non fare scroll automatico al cambio data
    });

    // Prima inizializzazione
    _scheduleSyncUpdate();
  }

  void _scheduleSyncUpdate() {
    _syncDebounce?.cancel();
    _syncDebounce = Timer(const Duration(milliseconds: 180), () {
      if (!mounted) return;
      _registerBodyBox();
      _setupHorizontalSync(force: true);
    });
  }

  void _scheduleScrollToPending() {
    _scrollRetryTimer?.cancel();
    _scrollRetryTimer = Timer(const Duration(milliseconds: 60), () {
      if (!mounted) return;
      _tryScrollToPending();
    });
  }

  void _tryScrollToPending() {
    final request = _pendingScrollRequest;
    if (request == null) return;

    final selectedDate = ref.read(agendaDateProvider);
    if (!DateUtils.isSameDay(selectedDate, request.date)) return;

    final appointments = ref.read(appointmentsForCurrentLocationProvider);
    final target = appointments
        .where((a) => a.id == request.appointment.id)
        .cast()
        .toList();
    if (target.isEmpty) {
      _scheduleScrollToPending();
      return;
    }

    final appointment = target.first;
    final scrollState = ref.read(agendaScrollProvider(_scrollKey));
    final verticalCtrl = scrollState.verticalScrollCtrl;
    final horizontalCtrl = scrollState.horizontalScrollCtrl;
    if (!verticalCtrl.hasClients || !horizontalCtrl.hasClients) {
      _scheduleScrollToPending();
      return;
    }

    final layoutConfig = ref.read(layoutConfigProvider);
    final bodyBox = _bodyKey.currentContext?.findRenderObject() as RenderBox?;
    final viewportHeight =
        bodyBox?.size.height ?? verticalCtrl.position.viewportDimension;
    final viewportWidth =
        bodyBox?.size.width ?? horizontalCtrl.position.viewportDimension;

    final startMinutes =
        appointment.startTime.hour * 60 + appointment.startTime.minute;
    final startOffset =
        (startMinutes / layoutConfig.minutesPerSlot) * layoutConfig.slotHeight;
    final durationMinutes = appointment.endTime
        .difference(appointment.startTime)
        .inMinutes
        .clamp(layoutConfig.minutesPerSlot, 1440);
    final cardHeight =
        (durationMinutes / layoutConfig.minutesPerSlot) *
        layoutConfig.slotHeight;

    final targetY =
        startOffset -
        (viewportHeight - cardHeight).clamp(0, viewportHeight) / 2;
    final maxY = verticalCtrl.position.maxScrollExtent;
    final clampedY = targetY.clamp(0.0, maxY);

    final staffIndex = widget.staffList.indexWhere(
      (s) => s.id == appointment.staffId,
    );
    if (staffIndex >= 0) {
      final layout = ResponsiveLayout.of(
        context,
        staffCount: widget.staffList.length,
        config: layoutConfig,
        availableWidth: viewportWidth,
      );
      final columnWidth = layout.columnWidth;
      final targetX =
          (staffIndex * columnWidth) - (viewportWidth - columnWidth) / 2;
      final maxX = horizontalCtrl.position.maxScrollExtent;
      final clampedX = targetX.clamp(0.0, maxX);
      if ((horizontalCtrl.offset - clampedX).abs() > 0.5) {
        horizontalCtrl.jumpTo(clampedX);
      }
    }

    if ((verticalCtrl.offset - clampedY).abs() > 0.5) {
      verticalCtrl.jumpTo(clampedY);
    }

    _pendingScrollRequest = null;
    ref.read(agendaScrollRequestProvider.notifier).clear();
  }

  void _registerBodyBox() {
    final box = _bodyKey.currentContext?.findRenderObject() as RenderBox?;
    if (box != null) {
      _dragBodyNotifier.set(box);
    }
  }

  void _clearBodyBox() {
    _dragBodyNotifier.scheduleClear();
  }

  void _setupHorizontalSync({bool force = false}) {
    final newSignature = widget.staffList.map((s) => s.id).toList();
    if (!force &&
        _staffSignature != null &&
        listEquals(_staffSignature, newSignature)) {
      return;
    }
    _staffSignature = newSignature;

    final bodyCtrl = ref
        .read(agendaScrollProvider(_scrollKey))
        .horizontalScrollCtrl;

    if (!force && identical(_bodyHorizontalCtrl, bodyCtrl)) {
      return;
    }

    _bodyHorizontalCtrl?.removeListener(_onBodyHorizontalScroll);
    _headerHCtrl.removeListener(_onHeaderHorizontalScroll);

    _bodyHorizontalCtrl = bodyCtrl;
    _bodyHorizontalCtrl?.addListener(_onBodyHorizontalScroll);
    _headerHCtrl.addListener(_onHeaderHorizontalScroll);

    if (_headerHCtrl.hasClients && _bodyHorizontalCtrl!.hasClients) {
      _headerHCtrl.jumpTo(_bodyHorizontalCtrl!.offset);
    }
  }

  void _onBodyHorizontalScroll() {
    final bodyCtrl = _bodyHorizontalCtrl;
    if (_isSyncing || bodyCtrl == null) return;
    if (!bodyCtrl.hasClients || !_headerHCtrl.hasClients) return;

    _isSyncing = true;
    _headerHCtrl.jumpTo(bodyCtrl.offset);
    _isSyncing = false;
  }

  void _onHeaderHorizontalScroll() {
    final bodyCtrl = _bodyHorizontalCtrl;
    if (_isSyncing || bodyCtrl == null) return;
    if (!bodyCtrl.hasClients || !_headerHCtrl.hasClients) return;

    _isSyncing = true;
    bodyCtrl.jumpTo(_headerHCtrl.offset);
    _isSyncing = false;
  }

  void _onVerticalScrollChanged() {
    final controller = _verticalCtrl;
    if (controller == null) return;
    widget.onScrollOffsetChanged?.call(controller.offset);
  }

  void _startAutoScroll() {
    if (_autoScrollTimer != null) return;
    _autoScrollTimer = Timer.periodic(_scrollInterval, (_) {
      if (!mounted) return;

      // dragPos √® in coordinate BODY-LOCAL (DragBodyBox)
      final dragPos = ref.read(dragPositionProvider);
      if (dragPos == null) {
        _stopAutoScroll();
        return;
      }

      final bodyBox = ref.read(dragBodyBoxProvider);
      if (bodyBox == null || !bodyBox.attached) {
        return;
      }

      if (!_autoScrollArmed && _initialDragPosition != null) {
        final deltaX = (dragPos.dx - _initialDragPosition!.dx).abs();
        final deltaY = (dragPos.dy - _initialDragPosition!.dy).abs();
        final maxDelta = deltaX > deltaY ? deltaX : deltaY;
        if (maxDelta < _autoScrollActivationThreshold) return;
        _autoScrollArmed = true;
      }

      final scrollState = ref.read(agendaScrollProvider(_scrollKey));
      final verticalCtrl = scrollState.verticalScrollCtrl;
      final horizontalCtrl = scrollState.horizontalScrollCtrl;
      if (!verticalCtrl.hasClients && !horizontalCtrl.hasClients) return;

      // dragPos √® gi√† in coordinate locali del bodyBox
      final localPos = dragPos;
      final viewHeight = bodyBox.size.height;
      final viewWidth = bodyBox.size.width;

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Auto scroll verticale (comportamento esistente)
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if (verticalCtrl.hasClients) {
        final maxExtent = verticalCtrl.position.maxScrollExtent;
        final current = verticalCtrl.offset;

        double? newOffset;
        if (localPos.dy < _scrollEdgeMargin && current > 0) {
          newOffset = (current - _scrollSpeed).clamp(0, maxExtent);
        } else if (localPos.dy > viewHeight - _scrollEdgeMargin &&
            current < maxExtent) {
          newOffset = (current + _scrollSpeed).clamp(0, maxExtent);
        }

        if (newOffset != null && newOffset != current) {
          verticalCtrl.jumpTo(newOffset);
        }
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Auto scroll orizzontale per raggiungere colonne nascoste
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if (horizontalCtrl.hasClients) {
        final maxHorizontal = horizontalCtrl.position.maxScrollExtent;
        final currentX = horizontalCtrl.offset;

        // Usiamo una soglia relativa alla larghezza visibile,
        // per renderlo affidabile anche con layout molto larghi.
        const double edgeFraction = 0.18; // ~18% ai lati
        final double leftEdge = viewWidth * edgeFraction;
        final double rightEdge = viewWidth * (1 - edgeFraction);

        double? newOffsetX;
        if (localPos.dx < leftEdge && currentX > 0) {
          newOffsetX = (currentX - _scrollSpeed).clamp(0, maxHorizontal);
        } else if (localPos.dx > rightEdge && currentX < maxHorizontal) {
          newOffsetX = (currentX + _scrollSpeed).clamp(0, maxHorizontal);
        }

        if (newOffsetX != null && newOffsetX != currentX) {
          horizontalCtrl.jumpTo(newOffsetX);
        }
      }
    });
  }

  void _stopAutoScroll() {
    _autoScrollTimer?.cancel();
    _autoScrollTimer = null;
    _initialDragPosition = null;
    _autoScrollArmed = false;
  }

  @override
  void dispose() {
    _dragSub.close();
    _layoutSub.close();
    _scrollRequestSub.close();
    _dateSub.close();
    _stopAutoScroll();
    _syncDebounce?.cancel();
    _scrollRetryTimer?.cancel();

    _bodyHorizontalCtrl?.removeListener(_onBodyHorizontalScroll);
    _headerHCtrl.removeListener(_onHeaderHorizontalScroll);
    _verticalCtrl?.removeListener(_onVerticalScrollChanged);

    _clearBodyBox();

    _headerHCtrl.dispose();
    super.dispose();
  }

  @override
  void didUpdateWidget(MultiStaffDayView oldWidget) {
    super.didUpdateWidget(oldWidget);

    // ogni cambio staffList/date ‚Üí resync orizzontale
    _scheduleSyncUpdate();

    // stesso comportamento di prima per isPrimary
    // quando smette di essere primary: pulisce il body
    _clearBodyBox();
  }

  @override
  Widget build(BuildContext context) {
    final appointments = ref.watch(appointmentsForCurrentLocationProvider);
    final scrollState = ref.watch(agendaScrollProvider(_scrollKey));
    final layoutConfig = ref.watch(layoutConfigProvider);
    // Evaluate the interaction lock once here for the current visible group
    final isInteractionLocked = ref.watch(agendaDayScrollLockProvider);

    final verticalCtrl = scrollState.verticalScrollCtrl;
    if (_verticalCtrl != verticalCtrl) {
      _verticalCtrl?.removeListener(_onVerticalScrollChanged);
      _verticalCtrl = verticalCtrl;
      _verticalCtrl?.addListener(_onVerticalScrollChanged);
      widget.onVerticalControllerChanged?.call(verticalCtrl);
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        final availableWidth =
            constraints.hasBoundedWidth && constraints.maxWidth.isFinite
            ? constraints.maxWidth
            : MediaQuery.of(context).size.width;

        final layout = ResponsiveLayout.of(
          context,
          staffCount: widget.staffList.length,
          config: layoutConfig,
          availableWidth: availableWidth,
        );

        final totalHeight = layoutConfig.totalHeight;
        final hourW = layoutConfig.hourColumnWidth;
        final headerHeight = layoutConfig.headerHeight;
        final LayerLink? link = ref.watch(dragLayerLinkProvider);
        final selectedDate = ref.watch(agendaDateProvider);
        final isToday = DateUtils.isSameDay(
          selectedDate,
          DateUtils.dateOnly(DateTime.now()),
        );

        final isResizing = ref.watch(isResizingProvider);

        return Stack(
          clipBehavior: Clip.none,
          children: [
            // BODY scrollabile
            Positioned.fill(
              top: headerHeight,
              child: AgendaStaffBody(
                verticalController: scrollState.verticalScrollCtrl,
                horizontalController: scrollState.horizontalScrollCtrl,
                staffList: widget.staffList,
                appointments: appointments,
                layoutConfig: layoutConfig,
                availableWidth: availableWidth,
                isResizing: isResizing,
                dragLayerLink: link,
                bodyKey: _bodyKey,
                isInteractionLocked: isInteractionLocked,
              ),
            ),
            // LINEA ORARIO (solo per la data odierna)
            if (isToday)
              CurrentTimeLine(
                hourColumnWidth: widget.hourColumnWidth,
                verticalOffset: widget.currentTimeVerticalOffset,
                horizontalOffset:
                    -widget.hourColumnWidth + CurrentTimeLine.horizontalMargin,
              ),
            // HEADER staff
            Positioned(
              top: 0,
              left: 0,
              right: 0,
              height: headerHeight,
              child: KeyedSubtree(
                key: _headerKey,
                child: AgendaStaffHeader(
                  staffList: widget.staffList,
                  hourColumnWidth: hourW,
                  totalHeight: totalHeight,
                  headerHeight: headerHeight,
                  columnWidth: layout.columnWidth,
                  scrollController: _headerHCtrl,
                ),
              ),
            ),
          ],
        );
      },
    );
  }
}
--- FILE: lib/features/agenda/presentation/agenda_screen.dart ---
import 'dart:async';

import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/widgets/no_scrollbar_behavior.dart';
import 'package:agenda_backend/features/agenda/domain/staff_filter_mode.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/day_view/agenda_day.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/day_view/components/hour_column.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/widgets/agenda_dividers.dart';
import 'package:agenda_backend/features/agenda/providers/appointment_providers.dart';
import 'package:agenda_backend/features/agenda/providers/is_resizing_provider.dart';
import 'package:agenda_backend/features/agenda/providers/layout_config_provider.dart';
import 'package:agenda_backend/features/agenda/providers/staff_filter_providers.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../providers/agenda_scroll_request_provider.dart';
import '../providers/date_range_provider.dart';
import '../providers/location_providers.dart';

class AgendaScreen extends ConsumerStatefulWidget {
  const AgendaScreen({super.key, this.initialClientId});

  /// Se valorizzato, crea automaticamente una prenotazione rapida per il client.
  final int? initialClientId;

  @override
  ConsumerState<AgendaScreen> createState() => _AgendaScreenState();
}

class _AgendaScreenState extends ConsumerState<AgendaScreen> {
  final ScrollController _hourColumnController = ScrollController();
  final AgendaDayController _timelineController = AgendaDayController();
  late final ProviderSubscription<AgendaScrollRequest?> _scrollRequestSub;
  Timer? _pollingTimer;

  /// Intervallo polling: 10 secondi in debug, 5 minuti in produzione
  static const _pollingIntervalDebug = Duration(seconds: 10);
  static const _pollingIntervalProd = Duration(minutes: 5);

  double? _pendingHourOffset;
  bool _pendingApplyScheduled = false;
  bool _quickBookingTriggered = false;

  // üîπ offset verticale "master" della giornata (usato anche dalla CurrentTimeLine)
  double _verticalOffset = 0;

  // üîπ Flag per distinguere polling automatico da altre operazioni
  bool _isPolling = false;

  @override
  void dispose() {
    _pollingTimer?.cancel();
    _scrollRequestSub.close();
    _timelineController.dispose();
    _hourColumnController.dispose();
    super.dispose();
  }

  void _handleMasterScroll(double offset) {
    // aggiorna l'offset usato dalla CurrentTimeLine
    if (mounted) {
      setState(() {
        _verticalOffset = offset;
      });
    }

    // sincronizza lo scroll della colonna oraria con la timeline
    if (!_hourColumnController.hasClients) {
      _pendingHourOffset = offset;
      _schedulePendingApply();
      return;
    }

    final position = _hourColumnController.position;
    final target = offset.clamp(
      position.minScrollExtent,
      position.maxScrollExtent,
    );

    if ((position.pixels - target).abs() < 0.5) {
      return;
    }

    _hourColumnController.jumpTo(target);
  }

  void _applyPendingOffset() {
    if (!mounted || _pendingHourOffset == null) return;

    if (!_hourColumnController.hasClients) {
      _schedulePendingApply();
      return;
    }

    final position = _hourColumnController.position;
    final target = _pendingHourOffset!.clamp(
      position.minScrollExtent,
      position.maxScrollExtent,
    );

    _hourColumnController.jumpTo(target);
    _pendingHourOffset = null;
  }

  void _schedulePendingApply() {
    if (_pendingApplyScheduled) return;
    _pendingApplyScheduled = true;
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _pendingApplyScheduled = false;
      if (!mounted) return;
      _applyPendingOffset();
    });
  }

  @override
  void initState() {
    super.initState();

    // NOTE: Non chiamiamo refresh() qui perch√©:
    // 1. I provider AsyncNotifier caricano i dati automaticamente nel build()
    // 2. Il refresh al cambio tab avviene in _refreshProvidersForTab()

    // Polling automatico per aggiornare gli appuntamenti
    // Debug: ogni 10 secondi, Produzione: ogni 5 minuti
    final interval = kDebugMode ? _pollingIntervalDebug : _pollingIntervalProd;
    _pollingTimer = Timer.periodic(interval, (_) {
      if (!mounted) return;
      // Ricarica solo gli appuntamenti (dati che cambiano pi√π frequentemente)
      _isPolling = true;
      ref.invalidate(appointmentsProvider);
    });

    _scrollRequestSub = ref.listenManual<AgendaScrollRequest?>(
      agendaScrollRequestProvider,
      (prev, next) {
        if (next == null) return;
        final currentDate = ref.read(agendaDateProvider);
        final targetDate = next.date;
        if (!DateUtils.isSameDay(currentDate, targetDate)) {
          ref.read(agendaDateProvider.notifier).set(targetDate);
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (!mounted) return;
            ref
                .read(agendaScrollRequestProvider.notifier)
                .request(next.appointment);
          });
        }
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final ref = this.ref;

    // Controlla se i dati sono ancora in caricamento
    final staffAsync = ref.watch(allStaffProvider);
    final locations = ref.watch(locationsProvider);
    final appointmentsAsync = ref.watch(appointmentsProvider);

    // Ascolta cambi data per resettare il flag polling
    // (se l'utente cambia data durante il polling, deve mostrare loading)
    ref.listen(agendaDateProvider, (prev, next) {
      if (prev != null && !DateUtils.isSameDay(prev, next)) {
        _isPolling = false;
      }
    });

    // Resetta il flag polling quando il caricamento finisce
    if (!appointmentsAsync.isLoading) {
      _isPolling = false;
    }

    // Mostra loading se:
    // 1. Staff in caricamento iniziale (senza dati)
    // 2. Locations vuote
    // 3. Appuntamenti in caricamento E non √® polling automatico
    final isLoading =
        (staffAsync.isLoading && !staffAsync.hasValue) ||
        locations.isEmpty ||
        (appointmentsAsync.isLoading && !_isPolling);

    final staffList = ref.watch(filteredStaffProvider);
    final staffFilterMode = ref.watch(staffFilterModeProvider);
    final hasStaff = staffList.isNotEmpty;
    final isResizing = ref.watch(isResizingProvider);
    final layoutConfig = ref.watch(layoutConfigProvider);

    final hourColumnWidth = layoutConfig.hourColumnWidth;
    final totalHeight = layoutConfig.totalHeight;

    // Se arriviamo con un clientId e non abbiamo ancora creato la prenotazione rapida
    final initialClientId = widget.initialClientId;
    if (initialClientId != null && !_quickBookingTriggered) {
      // Usa addPostFrame per evitare rebuild loop
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (!mounted) return;
        _quickBookingTriggered = true;
        ref
            .read(appointmentsProvider.notifier)
            .createQuickBookingForClient(initialClientId);
      });
    }

    final hourColumnStack = SizedBox(
      width: hourColumnWidth,
      child: Stack(
        clipBehavior: Clip.none,
        children: [
          Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              DecoratedBox(
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.surface,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.12),
                      offset: const Offset(3, 0),
                      blurRadius: 12,
                      spreadRadius: 0,
                    ),
                  ],
                ),
                child: SizedBox(
                  width: hourColumnWidth,
                  height: layoutConfig.headerHeight,
                ),
              ),
              Expanded(
                child: ScrollConfiguration(
                  behavior: const NoScrollbarBehavior(),
                  child: SingleChildScrollView(
                    controller: _hourColumnController,
                    scrollDirection: Axis.vertical,
                    physics: isResizing || hasStaff
                        ? const NeverScrollableScrollPhysics()
                        : null,
                    child: SizedBox(
                      width: hourColumnWidth,
                      child: const HourColumn(),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );

    final mainRow = Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (hasStaff) hourColumnStack,
        if (hasStaff)
          AgendaVerticalDivider(
            height: totalHeight,
            thickness: 1,
            fadeTopHeight: layoutConfig.headerHeight,
          ),
        Expanded(
          child: AgendaDay(
            staffList: staffList,
            onVerticalOffsetChanged: _handleMasterScroll,
            controller: _timelineController,
            hourColumnWidth: hourColumnWidth,
            currentTimeVerticalOffset: _verticalOffset,
          ),
        ),
      ],
    );

    return Stack(
      children: [
        Positioned.fill(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                child: isLoading
                    // Mostra loading indicator durante il caricamento
                    ? const Center(child: CircularProgressIndicator())
                    : hasStaff
                    ? mainRow
                    : Center(
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Text(
                              staffFilterMode == StaffFilterMode.onDutyTeam
                                  ? context.l10n.agendaNoOnDutyTeamTitle
                                  : context.l10n.agendaNoSelectedTeamTitle,
                              style: Theme.of(context).textTheme.titleMedium,
                              textAlign: TextAlign.center,
                            ),
                            const SizedBox(height: 12),
                            ElevatedButton(
                              onPressed: () {
                                ref
                                    .read(staffFilterModeProvider.notifier)
                                    .set(StaffFilterMode.allTeam);
                              },
                              child: Text(context.l10n.agendaShowAllTeamButton),
                            ),
                          ],
                        ),
                      ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}
--- FILE: lib/features/agenda/presentation/dialogs/add_block_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:agenda_backend/core/widgets/app_bottom_sheet.dart';
import 'package:agenda_backend/core/widgets/labeled_form_field.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/date_time_formats.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/time_block.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/app_switch.dart';
import '../../domain/config/layout_config.dart';
import '../../providers/date_range_provider.dart';
import '../../providers/layout_config_provider.dart';
import '../../providers/time_blocks_provider.dart';

/// Mostra il dialog per creare o modificare un blocco di non disponibilit√†.
Future<void> showAddBlockDialog(
  BuildContext context,
  WidgetRef ref, {
  TimeBlock? initial,
  DateTime? date,
  TimeOfDay? time,
  int? initialStaffId,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final isDesktop = formFactor == AppFormFactor.desktop;

  final dialog = _AddBlockDialog(
    initial: initial,
    initialDate: date,
    initialTime: time,
    initialStaffId: initialStaffId,
    presentation: isDesktop
        ? _BlockDialogPresentation.dialog
        : _BlockDialogPresentation.bottomSheet,
  );

  if (isDesktop) {
    await showDialog(context: context, builder: (_) => dialog);
  } else {
    await AppBottomSheet.show(
      context: context,
      useRootNavigator: true,
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 20),
      builder: (_) => dialog,
    );
  }
}

enum _BlockDialogPresentation { dialog, bottomSheet }

class _AddBlockDialog extends ConsumerStatefulWidget {
  const _AddBlockDialog({
    this.initial,
    this.initialDate,
    this.initialTime,
    this.initialStaffId,
    required this.presentation,
  });

  final TimeBlock? initial;
  final DateTime? initialDate;
  final TimeOfDay? initialTime;
  final int? initialStaffId;
  final _BlockDialogPresentation presentation;

  @override
  ConsumerState<_AddBlockDialog> createState() => _AddBlockDialogState();
}

class _AddBlockDialogState extends ConsumerState<_AddBlockDialog> {
  late DateTime _date;
  late TimeOfDay _startTime;
  late TimeOfDay _endTime;
  late Set<int> _selectedStaffIds;
  final _reasonController = TextEditingController();
  final ScrollController _staffScrollController = ScrollController();
  bool _isAllDay = false;
  String? _staffError;
  String? _timeError;

  @override
  void initState() {
    super.initState();
    final agendaDate = ref.read(agendaDateProvider);

    if (widget.initial != null) {
      final block = widget.initial!;
      _date = DateTime(
        block.startTime.year,
        block.startTime.month,
        block.startTime.day,
      );
      _startTime = TimeOfDay(
        hour: block.startTime.hour,
        minute: block.startTime.minute,
      );
      _endTime = TimeOfDay(
        hour: block.endTime.hour,
        minute: block.endTime.minute,
      );
      _selectedStaffIds = Set.from(block.staffIds);
      _reasonController.text = block.reason ?? '';
      _isAllDay = block.isAllDay;
    } else {
      _date = DateUtils.dateOnly(widget.initialDate ?? agendaDate);
      _startTime = widget.initialTime ?? const TimeOfDay(hour: 10, minute: 0);
      _endTime = TimeOfDay(
        hour: _startTime.hour + 1,
        minute: _startTime.minute,
      );
      _selectedStaffIds = widget.initialStaffId != null
          ? {widget.initialStaffId!}
          : {};
    }
  }

  @override
  void dispose() {
    _reasonController.dispose();
    _staffScrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final isEdit = widget.initial != null;
    final staff = ref.watch(staffForCurrentLocationProvider);
    final isDialog = widget.presentation == _BlockDialogPresentation.dialog;

    final title = isEdit ? l10n.blockDialogTitleEdit : l10n.blockDialogTitleNew;
    final content = Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Data
        LabeledFormField(
          label: l10n.formDate,
          child: InkWell(
            onTap: _pickDate,
            child: InputDecorator(
              decoration: const InputDecoration(
                border: OutlineInputBorder(),
                isDense: true,
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    '${_date.day.toString().padLeft(2, '0')}/${_date.month.toString().padLeft(2, '0')}/${_date.year}',
                  ),
                  const Icon(Icons.calendar_today, size: 16),
                ],
              ),
            ),
          ),
        ),
        const SizedBox(height: 12),

        // Giornata intera switch
        Row(
          children: [
            AppSwitch(
              value: _isAllDay,
              onChanged: (v) => setState(() => _isAllDay = v),
            ),
            const SizedBox(width: 8),
            Text(l10n.blockAllDay),
          ],
        ),
        const SizedBox(height: 12),

        // Orari
        if (!_isAllDay) ...[
          Row(
            children: [
              Expanded(
                child: LabeledFormField(
                  label: l10n.blockStartTime,
                  child: InkWell(
                    onTap: () => _pickTime(isStart: true),
                    child: InputDecorator(
                      decoration: InputDecoration(
                        border: const OutlineInputBorder(),
                        isDense: true,
                        errorText: null,
                        enabledBorder: _timeError != null
                            ? OutlineInputBorder(
                                borderSide: BorderSide(
                                  color: Theme.of(context).colorScheme.error,
                                ),
                              )
                            : null,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_startTime.format(context)),
                          const Icon(Icons.schedule, size: 16),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: LabeledFormField(
                  label: l10n.blockEndTime,
                  child: InkWell(
                    onTap: () => _pickTime(isStart: false),
                    child: InputDecorator(
                      decoration: InputDecoration(
                        border: const OutlineInputBorder(),
                        isDense: true,
                        enabledBorder: _timeError != null
                            ? OutlineInputBorder(
                                borderSide: BorderSide(
                                  color: Theme.of(context).colorScheme.error,
                                ),
                              )
                            : null,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_endTime.format(context)),
                          const Icon(Icons.schedule, size: 16),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
          if (_timeError != null)
            Padding(
              padding: const EdgeInsets.only(top: 6, left: 12),
              child: Text(
                _timeError!,
                style: TextStyle(
                  color: Theme.of(context).colorScheme.error,
                  fontSize: 12,
                ),
              ),
            ),
          const SizedBox(height: 12),
        ],

        // Staff selection
        LabeledFormField(
          label: l10n.blockSelectStaff,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(
                decoration: BoxDecoration(
                  border: Border.all(
                    color: _staffError != null
                        ? Theme.of(context).colorScheme.error
                        : Theme.of(context).dividerColor,
                  ),
                  borderRadius: BorderRadius.circular(4),
                ),
                constraints: const BoxConstraints(maxHeight: 200),
                child: Scrollbar(
                  controller: _staffScrollController,
                  thumbVisibility: staff.length * 48.0 > 200,
                  child: ListView.builder(
                    controller: _staffScrollController,
                    shrinkWrap: true,
                    itemCount: staff.length,
                    itemBuilder: (context, index) {
                      final member = staff[index];
                      final isSelected = _selectedStaffIds.contains(member.id);
                      return CheckboxListTile(
                        value: isSelected,
                        onChanged: (v) {
                          setState(() {
                            _staffError = null;
                            if (v == true) {
                              _selectedStaffIds.add(member.id);
                            } else {
                              _selectedStaffIds.remove(member.id);
                            }
                          });
                        },
                        title: Text(member.name),
                        secondary: StaffCircleAvatar(
                          height: 24,
                          color: member.color,
                          isHighlighted: _selectedStaffIds.contains(member.id),
                          initials: member.initials,
                        ),
                        dense: true,
                        controlAffinity: ListTileControlAffinity.leading,
                      );
                    },
                  ),
                ),
              ),
              if (_staffError != null)
                Padding(
                  padding: const EdgeInsets.only(top: 6, left: 12),
                  child: Text(
                    _staffError!,
                    style: TextStyle(
                      color: Theme.of(context).colorScheme.error,
                      fontSize: 12,
                    ),
                  ),
                ),
            ],
          ),
        ),
        const SizedBox(height: 12),

        // Motivo opzionale
        LabeledFormField(
          label: l10n.blockReason,
          child: TextField(
            controller: _reasonController,
            decoration: InputDecoration(
              hintText: l10n.blockReasonHint,
              border: const OutlineInputBorder(),
              isDense: true,
            ),
          ),
        ),
      ],
    );

    final actions = [
      if (isEdit)
        AppDangerButton(
          onPressed: _onDelete,
          padding: AppButtonStyles.dialogButtonPadding,
          child: Text(l10n.actionDelete),
        ),
      AppOutlinedActionButton(
        onPressed: () => Navigator.of(context).pop(),
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppFilledButton(
        onPressed: _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionSave),
      ),
    ];

    final bottomActions = actions
        .map(
          (a) => SizedBox(width: AppButtonStyles.dialogButtonWidth, child: a),
        )
        .toList();

    if (isDialog) {
      return DismissibleDialog(
        child: Dialog(
          insetPadding: const EdgeInsets.symmetric(
            horizontal: 32,
            vertical: 24,
          ),
          child: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text(title, style: Theme.of(context).textTheme.headlineSmall),
                  const SizedBox(height: 16),
                  Flexible(child: SingleChildScrollView(child: content)),
                  const SizedBox(height: 24),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      if (isEdit) ...[
                        bottomActions.first, // Delete button
                        const Spacer(),
                        bottomActions[1], // Cancel button
                      ] else
                        bottomActions[0], // Cancel button
                      const SizedBox(width: 8),
                      bottomActions.last, // Save button
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      );
    }

    return SafeArea(
      top: false,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final isKeyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
          return SizedBox(
            height: constraints.maxHeight,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Expanded(
                  child: SingleChildScrollView(
                    padding: EdgeInsets.only(bottom: 0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Padding(
                          padding: const EdgeInsets.only(bottom: 12),
                          child: Text(
                            title,
                            style: Theme.of(context).textTheme.titleLarge,
                          ),
                        ),
                        content,
                        const SizedBox(height: 24),
                        const SizedBox(height: AppSpacing.formRowSpacing),
                      ],
                    ),
                  ),
                ),
                if (!isKeyboardOpen) ...[
                  const AppBottomSheetDivider(),
                  Padding(
                    padding: const EdgeInsets.fromLTRB(0, 12, 0, 0),
                    child: Align(
                      alignment: bottomActions.length == 3
                          ? Alignment.center
                          : Alignment.centerRight,
                      child: Wrap(
                        alignment: bottomActions.length == 3
                            ? WrapAlignment.center
                            : WrapAlignment.end,
                        spacing: 8,
                        runSpacing: 8,
                        children: bottomActions,
                      ),
                    ),
                  ),
                ],
                SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
              ],
            ),
          );
        },
      ),
    );
  }

  Future<void> _pickDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _date,
      firstDate: DateTime.now().subtract(const Duration(days: 365)),
      lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
    );
    if (picked != null) {
      setState(() => _date = DateUtils.dateOnly(picked));
    }
  }

  Future<void> _pickTime({required bool isStart}) async {
    final step = ref.read(layoutConfigProvider).minutesPerSlot;
    final selected = await AppBottomSheet.show<TimeOfDay>(
      context: context,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      builder: (ctx) {
        final height = MediaQuery.of(ctx).size.height * 0.9;
        return SizedBox(
          height: height,
          child: _TimeGridPicker(
            initial: isStart ? _startTime : _endTime,
            stepMinutes: step,
          ),
        );
      },
    );
    if (selected != null) {
      setState(() {
        _timeError = null; // Reset errore quando l'utente modifica
        if (isStart) {
          _startTime = selected;
          // Aggiusta automaticamente l'end time se necessario
          final startMinutes = _startTime.hour * 60 + _startTime.minute;
          final endMinutes = _endTime.hour * 60 + _endTime.minute;
          if (endMinutes <= startMinutes) {
            _endTime = TimeOfDay(
              hour: (_startTime.hour + 1) % 24,
              minute: _startTime.minute,
            );
          }
        } else {
          _endTime = selected;
        }
      });
    }
  }

  Future<void> _onSave() async {
    final l10n = context.l10n;
    bool hasError = false;

    // Reset errori
    setState(() {
      _staffError = null;
      _timeError = null;
    });

    if (_selectedStaffIds.isEmpty) {
      setState(() => _staffError = l10n.blockSelectStaffError);
      hasError = true;
    }

    // Validazione orari
    if (!_isAllDay) {
      final startMinutes = _startTime.hour * 60 + _startTime.minute;
      final endMinutes = _endTime.hour * 60 + _endTime.minute;
      if (endMinutes <= startMinutes) {
        setState(() => _timeError = l10n.blockTimeError);
        hasError = true;
      }
    }

    if (hasError) return;

    final DateTime startDateTime;
    final DateTime endDateTime;

    if (_isAllDay) {
      // Per blocchi giornata intera, usa l'intera giornata lavorativa
      startDateTime = DateTime(_date.year, _date.month, _date.day, 0, 0);
      endDateTime = DateTime(_date.year, _date.month, _date.day, 23, 59);
    } else {
      startDateTime = DateTime(
        _date.year,
        _date.month,
        _date.day,
        _startTime.hour,
        _startTime.minute,
      );
      endDateTime = DateTime(
        _date.year,
        _date.month,
        _date.day,
        _endTime.hour,
        _endTime.minute,
      );
    }

    final reason = _reasonController.text.trim().isEmpty
        ? null
        : _reasonController.text.trim();

    if (widget.initial == null) {
      // Nuovo blocco
      await ref
          .read(timeBlocksProvider.notifier)
          .addBlock(
            staffIds: _selectedStaffIds.toList(),
            startTime: startDateTime,
            endTime: endDateTime,
            reason: reason,
            isAllDay: _isAllDay,
          );
    } else {
      // Aggiorna blocco esistente
      await ref
          .read(timeBlocksProvider.notifier)
          .updateBlock(
            blockId: widget.initial!.id,
            staffIds: _selectedStaffIds.toList(),
            startTime: startDateTime,
            endTime: endDateTime,
            reason: reason,
            isAllDay: _isAllDay,
          );
    }

    if (!mounted) return;
    Navigator.of(context).pop();
  }

  Future<void> _onDelete() async {
    if (widget.initial != null) {
      await ref
          .read(timeBlocksProvider.notifier)
          .deleteBlock(widget.initial!.id);
      if (!mounted) return;
      Navigator.of(context).pop();
    }
  }
}

class _TimeGridPicker extends StatefulWidget {
  const _TimeGridPicker({required this.initial, required this.stepMinutes});
  final TimeOfDay initial;
  final int stepMinutes;

  @override
  State<_TimeGridPicker> createState() => _TimeGridPickerState();
}

class _TimeGridPickerState extends State<_TimeGridPicker> {
  late final ScrollController _scrollController;
  late final List<TimeOfDay?> _entries;
  late final int _scrollToIndex;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();

    // Genera la lista degli orari con 4 colonne per riga
    _entries = <TimeOfDay?>[];
    for (int m = 0; m < LayoutConfig.hoursInDay * 60; m += widget.stepMinutes) {
      final h = m ~/ 60;
      final mm = m % 60;
      _entries.add(TimeOfDay(hour: h, minute: mm));
    }

    // Verifica se l'orario iniziale √® gi√† nella lista
    int exactIndex = _entries.indexWhere(
      (t) =>
          t != null &&
          t.hour == widget.initial.hour &&
          t.minute == widget.initial.minute,
    );

    if (exactIndex >= 0) {
      // L'orario √® gi√† presente
      _scrollToIndex = exactIndex;
    } else {
      // L'orario non √® presente: inserisci una NUOVA RIGA con l'orario
      // nella colonna corretta e le altre colonne vuote
      final columnsPerRow = 60 ~/ widget.stepMinutes;
      final targetColumn = widget.initial.minute ~/ widget.stepMinutes;
      final baseIndex = (widget.initial.hour + 1) * columnsPerRow;

      // Crea la nuova riga con 4 elementi (solo uno valorizzato)
      final newRow = List<TimeOfDay?>.filled(columnsPerRow, null);
      newRow[targetColumn] = widget.initial;

      // Inserisci la nuova riga
      final insertIndex = baseIndex.clamp(0, _entries.length);
      _entries.insertAll(insertIndex, newRow);

      // L'indice dell'orario selezionato √® la posizione nella nuova riga
      _scrollToIndex = insertIndex + targetColumn;
    }

    // Scroll all'orario dopo il primo frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _scrollToSelected();
    });
  }

  void _scrollToSelected() {
    if (!_scrollController.hasClients) return;

    const crossAxisCount = 4;
    const mainAxisSpacing = 6.0;
    const childAspectRatio = 2.7;
    const padding = 12.0;

    // Usa la larghezza effettiva del context
    final screenWidth = MediaQuery.of(context).size.width;
    final availableWidth = screenWidth - padding * 2;
    final itemWidth =
        (availableWidth - (crossAxisCount - 1) * 6) / crossAxisCount;
    final itemHeight = itemWidth / childAspectRatio;
    final rowHeight = itemHeight + mainAxisSpacing;

    // Calcola la riga dell'elemento target
    final targetRow = _scrollToIndex ~/ crossAxisCount;

    // Calcola l'offset per centrare la riga target
    final viewportHeight = _scrollController.position.viewportDimension;
    // Offset aggiuntivo per centrare meglio (compensa header visivo)
    const headerOffset = 40.0;
    final targetOffset =
        (targetRow * rowHeight) -
        (viewportHeight / 2) +
        (rowHeight / 2) +
        headerOffset;

    // Limita l'offset ai bounds dello scroll
    final maxScroll = _scrollController.position.maxScrollExtent;
    final clampedOffset = targetOffset.clamp(0.0, maxScroll);

    _scrollController.animateTo(
      clampedOffset,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeOut,
    );
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          mainAxisSize: MainAxisSize.max,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Icon(Icons.schedule, size: 18),
                const SizedBox(width: 8),
                Text(
                  MaterialLocalizations.of(context).timePickerHourLabel,
                  style: const TextStyle(fontWeight: FontWeight.w700),
                ),
              ],
            ),
            const SizedBox(height: 10),
            Expanded(
              child: GridView.builder(
                controller: _scrollController,
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 4,
                  mainAxisSpacing: 6,
                  crossAxisSpacing: 6,
                  childAspectRatio: 2.7,
                ),
                itemCount: _entries.length,
                itemBuilder: (context, index) {
                  final t = _entries[index];
                  // Se la cella √® vuota, mostra uno spazio vuoto
                  if (t == null) {
                    return const SizedBox.shrink();
                  }
                  // Evidenzia l'orario selezionato
                  final isSelected = index == _scrollToIndex;
                  return OutlinedButton(
                    style: OutlinedButton.styleFrom(
                      backgroundColor: isSelected
                          ? Theme.of(
                              context,
                            ).colorScheme.primary.withOpacity(0.1)
                          : null,
                      side: BorderSide(
                        color: isSelected
                            ? Theme.of(context).colorScheme.primary
                            : Theme.of(context).dividerColor,
                      ),
                      padding: const EdgeInsets.symmetric(horizontal: 8),
                    ),
                    onPressed: () => Navigator.pop(context, t),
                    child: Text(_format(context, t)),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }

  String _format(BuildContext ctx, TimeOfDay t) {
    return DtFmt.hm(ctx, t.hour, t.minute);
  }
}
--- FILE: lib/features/agenda/presentation/widgets/booking_details_overlay.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../providers/bookings_provider.dart';

Future<void> showBookingDetailsOverlay(
  BuildContext context,
  WidgetRef ref, {
  required int bookingId,
}) async {
  await showModalBottomSheet(
    context: context,
    isScrollControlled: true,
    useRootNavigator: true,
    builder: (_) => _BookingDetailsSheet(bookingId: bookingId),
  );
}

class _BookingDetailsSheet extends ConsumerWidget {
  const _BookingDetailsSheet({required this.bookingId});
  final int bookingId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final summary = ref.watch(bookingSummaryProvider(bookingId));
    final isSingleAppointment = summary?.itemsCount == 1;
    final deleteTitle = isSingleAppointment
        ? l10n.deleteAppointmentConfirmTitle
        : l10n.deleteBookingConfirmTitle;
    final deleteMessage = isSingleAppointment
        ? l10n.deleteAppointmentConfirmMessage
        : l10n.deleteBookingConfirmMessage;
    final bookings = ref.watch(bookingsProvider);
    final booking = bookings[bookingId];

    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  l10n.bookingDetails,
                  style: const TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.w700,
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.close),
                  onPressed: () => Navigator.of(context).pop(),
                ),
              ],
            ),
            const SizedBox(height: 12),
            if (summary != null) ...[
              Row(
                children: [
                  Text('${l10n.bookingItems}: '),
                  Text(
                    '${summary.itemsCount}',
                    style: const TextStyle(fontWeight: FontWeight.w600),
                  ),
                  const SizedBox(width: 16),
                  Text('${l10n.bookingTotal}: '),
                  Text(
                    '${summary.totalPrice.toStringAsFixed(2)}‚Ç¨',
                    style: const TextStyle(fontWeight: FontWeight.w600),
                  ),
                ],
              ),
            ],
            const SizedBox(height: 12),
            Text(
              l10n.bookingNotes,
              style: const TextStyle(fontWeight: FontWeight.w600),
            ),
            const SizedBox(height: 6),
            TextFormField(
              initialValue: booking?.notes ?? '',
              maxLines: 3,
              decoration: const InputDecoration(
                border: OutlineInputBorder(),
                isDense: true,
              ),
              onChanged: (v) => ref
                  .read(bookingsProvider.notifier)
                  .setNotes(bookingId, v.trim().isEmpty ? null : v),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () async {
                      final confirmed = await showDialog<bool>(
                        context: context,
                        builder: (_) => AlertDialog(
                          title: Text(deleteTitle),
                          content: Text(deleteMessage),
                          actions: [
                            TextButton(
                              onPressed: () => Navigator.pop(context, false),
                              child: Text(l10n.actionCancel),
                            ),
                            TextButton(
                              onPressed: () => Navigator.pop(context, true),
                              child: Text(l10n.actionDeleteBooking),
                            ),
                          ],
                        ),
                      );
                      if (confirmed == true) {
                        await ref
                            .read(bookingsProvider.notifier)
                            .deleteBooking(bookingId);
                        if (context.mounted) Navigator.of(context).pop();
                      }
                    },
                    child: Text(l10n.actionDeleteBooking),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 10),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/widgets/service_picker_field.dart ---
import 'package:flutter/material.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../app/theme/extensions.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_dividers.dart';

/// A form field for selecting a service, with services grouped by category.
///
/// On mobile: opens a bottom sheet with grouped services.
/// On desktop: opens a dialog with grouped services.
class ServicePickerField extends StatefulWidget {
  const ServicePickerField({
    super.key,
    required this.services,
    required this.categories,
    required this.formFactor,
    this.value,
    this.onChanged,
    this.onClear,
    this.validator,
    this.autovalidateMode = AutovalidateMode.disabled,
    this.autoOpenPicker = false,
    this.onAutoOpenPickerTriggered,
    this.onAutoOpenPickerCompleted,
  });

  final List<Service> services;
  final List<ServiceCategory> categories;
  final AppFormFactor formFactor;
  final int? value;
  final ValueChanged<int?>? onChanged;

  /// Callback chiamato quando l'utente preme l'icona di rimozione.
  /// Se null, l'icona non viene mostrata.
  final VoidCallback? onClear;
  final FormFieldValidator<int>? validator;
  final bool autoOpenPicker;
  final VoidCallback? onAutoOpenPickerTriggered;
  final VoidCallback? onAutoOpenPickerCompleted;

  /// Modalit√† di autovalidazione. Default: disabled (valida solo su submit).
  final AutovalidateMode autovalidateMode;

  @override
  State<ServicePickerField> createState() => _ServicePickerFieldState();
}

class _ServicePickerFieldState extends State<ServicePickerField> {
  final _formFieldKey = GlobalKey<FormFieldState<int>>();
  bool _autoPickerInvoked = false;
  bool _autoOpenInProgress = false;

  Service? get _selectedService {
    if (widget.value == null) return null;
    return widget.services.where((s) => s.id == widget.value).firstOrNull;
  }

  @override
  void didUpdateWidget(ServicePickerField oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Aggiorna lo stato del FormField quando il valore cambia
    if (oldWidget.value != widget.value) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        final state = _formFieldKey.currentState;
        if (state != null) {
          state.didChange(widget.value);
        }
      });
    }
    if (oldWidget.autoOpenPicker != widget.autoOpenPicker) {
      _autoPickerInvoked = false;
    }
  }

  @override
  Widget build(BuildContext context) {
    return FormField<int>(
      key: _formFieldKey,
      initialValue: widget.value,
      validator: widget.validator,
      autovalidateMode: widget.autovalidateMode,
      builder: (field) {
        final theme = Theme.of(context);
        final hasError = field.hasError;
        final borderColor = hasError
            ? theme.colorScheme.error
            : theme.colorScheme.outline;

        if (widget.autoOpenPicker && !_autoPickerInvoked) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (!mounted || _autoPickerInvoked) return;
            _autoPickerInvoked = true;
            _autoOpenInProgress = true;
            _openPicker(field);
            widget.onAutoOpenPickerTriggered?.call();
          });
        }

        return InkWell(
          onTap: () => _openPicker(field),
          borderRadius: BorderRadius.circular(4),
          child: InputDecorator(
            decoration: InputDecoration(
              labelText: _selectedService != null
                  ? context.l10n.formService
                  : null,
              contentPadding: const EdgeInsets.symmetric(
                horizontal: 12,
                vertical: 16,
              ),
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(4),
                borderSide: BorderSide(color: borderColor),
              ),
              enabledBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(4),
                borderSide: BorderSide(color: borderColor),
              ),
              errorText: field.errorText,
              suffixIcon: _selectedService != null && widget.onClear != null
                  ? IconButton(
                      icon: Icon(
                        Icons.close,
                        color: theme.colorScheme.error,
                        size: 20,
                      ),
                      onPressed: widget.onClear,
                      tooltip: context.l10n.actionDelete,
                    )
                  : const Icon(Icons.arrow_drop_down),
            ),
            child: Text(
              _selectedService?.name ?? context.l10n.selectService,
              style: theme.textTheme.bodyLarge?.copyWith(
                color: _selectedService == null
                    ? theme.colorScheme.onSurfaceVariant.withOpacity(0.7)
                    : null,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        );
      },
    );
  }

  Future<void> _openPicker(FormFieldState<int> field) async {
    if (widget.formFactor == AppFormFactor.desktop) {
      await _openDesktopDialogWithField(field);
    } else {
      await _openBottomSheetWithField(field);
    }
  }

  Future<void> _openBottomSheetWithField(FormFieldState<int> field) async {
    await AppBottomSheet.show<int>(
      context: context,
      heightFactor: AppBottomSheet.defaultHeightFactor,
      padding: EdgeInsets.zero,
      builder: (ctx) => _ServicePickerContent(
        services: widget.services,
        categories: widget.categories,
        selectedId: widget.value,
        onSelected: (id) {
          final wasAutoOpen = _autoOpenInProgress;
          Navigator.of(ctx).pop();
          field.didChange(id);
          field.validate(); // Ri-valida per rimuovere l'errore
          widget.onChanged?.call(id);
          if (wasAutoOpen) {
            _autoOpenInProgress = false;
            widget.onAutoOpenPickerCompleted?.call();
          }
        },
      ),
    );
    _autoOpenInProgress = false;
  }

  Future<void> _openDesktopDialogWithField(FormFieldState<int> field) async {
    await showDialog<int>(
      context: context,
      builder: (ctx) => Dialog(
        insetPadding: const EdgeInsets.symmetric(horizontal: 32, vertical: 24),
        child: ConstrainedBox(
          constraints: const BoxConstraints(
            minWidth: 600,
            maxWidth: 720,
            maxHeight: 500,
          ),
          child: _ServicePickerContent(
            services: widget.services,
            categories: widget.categories,
            selectedId: widget.value,
            onSelected: (id) {
              final wasAutoOpen = _autoOpenInProgress;
              Navigator.of(ctx).pop();
              field.didChange(id);
              field.validate(); // Ri-valida per rimuovere l'errore
              widget.onChanged?.call(id);
              if (wasAutoOpen) {
                _autoOpenInProgress = false;
                widget.onAutoOpenPickerCompleted?.call();
              }
            },
          ),
        ),
      ),
    );
    _autoOpenInProgress = false;
  }
}

/// Content widget for the service picker (used in both bottom sheet and popup).
class _ServicePickerContent extends StatelessWidget {
  const _ServicePickerContent({
    required this.services,
    required this.categories,
    required this.selectedId,
    required this.onSelected,
  });

  final List<Service> services;
  final List<ServiceCategory> categories;
  final int? selectedId;
  final ValueChanged<int?> onSelected;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    final servicesByCategory = <int, List<Service>>{};
    for (final service in services) {
      (servicesByCategory[service.categoryId] ??= []).add(service);
    }

    final hasServicesMap = <int, bool>{
      for (final category in categories)
        category.id: (servicesByCategory[category.id]?.isNotEmpty ?? false),
    };

    // Sort categories like services section:
    // 1) non-empty before empty, 2) sortOrder, 3) name
    final sortedCategories = [...categories]
      ..sort((a, b) {
        final aEmpty = !(hasServicesMap[a.id] ?? false);
        final bEmpty = !(hasServicesMap[b.id] ?? false);
        if (aEmpty != bEmpty) return aEmpty ? 1 : -1;
        final so = a.sortOrder.compareTo(b.sortOrder);
        return so != 0
            ? so
            : a.name.toLowerCase().compareTo(b.name.toLowerCase());
      });

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.fromLTRB(16, 8, 16, 12),
          child: Text(
            l10n.formService,
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.w600,
            ),
          ),
        ),
        const AppBottomSheetDivider(),
        // Service list
        Expanded(
          child: ListView.builder(
            shrinkWrap: true,
            itemCount: sortedCategories.length,
            itemBuilder: (ctx, index) {
              final category = sortedCategories[index];
              final categoryServices =
                  (servicesByCategory[category.id] ?? []).toList()
                    ..sort((a, b) {
                      final so = a.sortOrder.compareTo(b.sortOrder);
                      return so != 0
                          ? so
                          : a.name.toLowerCase().compareTo(b.name.toLowerCase());
                    });

              if (categoryServices.isEmpty) {
                return const SizedBox.shrink();
              }

              return _CategorySection(
                category: category,
                services: categoryServices,
                selectedId: selectedId,
                onSelected: onSelected,
              );
            },
          ),
        ),
      ],
    );
  }
}

/// A section showing a category header and its services.
class _CategorySection extends StatelessWidget {
  const _CategorySection({
    required this.category,
    required this.services,
    required this.selectedId,
    required this.onSelected,
  });

  final ServiceCategory category;
  final List<Service> services;
  final int? selectedId;
  final ValueChanged<int?> onSelected;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    // Colore di sfondo leggero per i servizi con indice pari (even)
    final interactionColors = theme.extension<AppInteractionColors>();
    final evenBackgroundColor =
        interactionColors?.alternatingRowFill ??
        theme.colorScheme.onSurface.withOpacity(0.04);

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Category header with full-width background
        Container(
          width: double.infinity,
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 20),
          color: theme.colorScheme.primary,
          child: Center(
            child: Text(
              category.name.toUpperCase(),
              style: theme.textTheme.labelMedium?.copyWith(
                color: theme.colorScheme.onPrimary,
                fontWeight: FontWeight.bold,
                letterSpacing: 0.5,
              ),
            ),
          ),
        ),
        // Services con sfondo alternato (even)
        for (int i = 0; i < services.length; i++)
          _buildServiceTile(
            context,
            services[i],
            isEven: i.isEven,
            evenBackgroundColor: evenBackgroundColor,
            theme: theme,
          ),
      ],
    );
  }

  Widget _buildServiceTile(
    BuildContext context,
    Service service, {
    required bool isEven,
    required Color evenBackgroundColor,
    required ThemeData theme,
  }) {
    final isSelected = service.id == selectedId;
    return Material(
      color: isEven ? evenBackgroundColor : Colors.transparent,
      child: InkWell(
        onTap: () => onSelected(service.id),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          child: Row(
            children: [
              Expanded(child: Text(service.name)),
              if (isSelected)
                Icon(Icons.check, color: theme.colorScheme.primary, size: 20),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/widgets/appointment_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:agenda_backend/core/l10n/date_time_formats.dart';
import 'package:agenda_backend/core/widgets/no_scrollbar_behavior.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/appointment.dart';
import '../../../../core/models/service_variant.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../clients/domain/clients.dart';
import '../../../clients/presentation/dialogs/client_edit_dialog.dart';
import '../../../clients/providers/clients_providers.dart';
import '../../../services/providers/service_categories_provider.dart';
import '../../../services/providers/services_provider.dart';
import '../../domain/service_item_data.dart';
import '../../providers/agenda_scroll_request_provider.dart';
import '../../providers/appointment_providers.dart';
import '../../providers/bookings_provider.dart';
import '../../providers/layout_config_provider.dart';
import '../../providers/staff_slot_availability_provider.dart';
import 'service_item_card.dart';

/// Show the Appointment dialog for editing an existing appointment.
/// For creating new appointments, use [showBookingDialog] instead.
Future<void> showAppointmentDialog(
  BuildContext context,
  WidgetRef ref, {
  required Appointment initial,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final presentation = formFactor == AppFormFactor.desktop
      ? _AppointmentPresentation.dialog
      : _AppointmentPresentation.bottomSheet;

  final content = _AppointmentDialog(
    initial: initial,
    presentation: presentation,
  );

  if (presentation == _AppointmentPresentation.dialog) {
    await showDialog(context: context, builder: (_) => content);
  } else {
    await AppBottomSheet.show(
      context: context,
      useRootNavigator: true,
      builder: (_) => content,
      padding: const EdgeInsets.symmetric(horizontal: 0, vertical: 16),
      heightFactor: AppBottomSheet.defaultHeightFactor,
    );
  }
}

enum _AppointmentPresentation { dialog, bottomSheet }

class _AppointmentDialog extends ConsumerStatefulWidget {
  const _AppointmentDialog({required this.initial, required this.presentation});

  final Appointment initial;
  final _AppointmentPresentation presentation;

  @override
  ConsumerState<_AppointmentDialog> createState() => _AppointmentDialogState();
}

class _AppointmentDialogState extends ConsumerState<_AppointmentDialog> {
  final _formKey = GlobalKey<FormState>();
  final _notesController = TextEditingController();
  final ScrollController _scrollController = ScrollController();

  late DateTime _date;
  int? _clientId;
  String _clientName = '';
  late final bool _bookingHasSingleAppointment;

  /// Lista di ServiceItemData per i servizi dell'appuntamento
  final List<ServiceItemData> _serviceItems = [];

  /// Contatore per generare chiavi univoche
  int _itemKeyCounter = 0;

  bool _warningDismissed = false;
  int? _autoOpenServicePickerIndex;

  /// Stato iniziale per rilevare modifiche
  late DateTime _initialDate;
  late int? _initialClientId;
  late String _initialClientName;
  late String _initialNotes;
  late List<ServiceItemData> _initialServiceItems;

  @override
  void initState() {
    super.initState();

    final appt = widget.initial;
    _date = DateTime(
      appt.startTime.year,
      appt.startTime.month,
      appt.startTime.day,
    );
    _clientId = appt.clientId;
    _clientName = appt.clientName;
    Future.microtask(() {
      if (!mounted) return;
      ref
          .read(bookingsProvider.notifier)
          .ensureBooking(
            bookingId: appt.bookingId,
            businessId: appt.businessId,
            locationId: appt.locationId,
            clientId: appt.clientId,
            clientName: appt.clientName,
          );
    });
    // Leggi le note dalla Booking associata
    final booking = ref.read(bookingsProvider)[appt.bookingId];
    _notesController.text = booking?.notes ?? '';

    // Carica tutti gli appuntamenti della stessa prenotazione
    final bookingAppointments = ref
        .read(appointmentsProvider.notifier)
        .getByBookingId(appt.bookingId);
    _bookingHasSingleAppointment = bookingAppointments.length <= 1;

    for (final appointment in bookingAppointments) {
      // Skip appuntamenti con serviceId corrotto (0 o nullo)
      // Questi verranno eliminati quando si salva
      if (appointment.serviceId == 0) {
        continue;
      }

      final baseDuration = _baseDurationFromAppointment(appointment);
      final blockedExtraMinutes = appointment.blockedExtraMinutes;
      final processingExtraMinutes = appointment.processingExtraMinutes;
      _serviceItems.add(
        ServiceItemData(
          key: _nextItemKey(),
          appointmentId: appointment.id, // Traccia l'ID originale
          startTime: TimeOfDay.fromDateTime(appointment.startTime),
          staffId: appointment.staffId,
          serviceId: appointment.serviceId,
          serviceVariantId: appointment.serviceVariantId,
          durationMinutes: baseDuration,
          blockedExtraMinutes: blockedExtraMinutes,
          processingExtraMinutes: processingExtraMinutes,
        ),
      );
    }

    // Se non ci sono appointments (caso raro), aggiungi un item vuoto
    if (_serviceItems.isEmpty) {
      final initialTime = TimeOfDay.fromDateTime(appt.startTime);
      _serviceItems.add(
        ServiceItemData(
          key: _nextItemKey(),
          startTime: initialTime,
          staffId: appt.staffId,
        ),
      );
    }

    // Salva stato iniziale per rilevare modifiche
    _initialDate = _date;
    _initialClientId = _clientId;
    _initialClientName = _clientName;
    _initialNotes = _notesController.text;
    // Copia profonda dei servizi per confronto
    _initialServiceItems = _serviceItems
        .map(
          (s) => ServiceItemData(
            key: s.key,
            appointmentId: s.appointmentId,
            startTime: s.startTime,
            staffId: s.staffId,
            serviceId: s.serviceId,
            serviceVariantId: s.serviceVariantId,
            durationMinutes: s.durationMinutes,
            blockedExtraMinutes: s.blockedExtraMinutes,
            processingExtraMinutes: s.processingExtraMinutes,
          ),
        )
        .toList();
  }

  @override
  void dispose() {
    _notesController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  String _nextItemKey() => 'item_${_itemKeyCounter++}';

  int _baseDurationFromAppointment(Appointment appointment) {
    final totalMinutes = appointment.endTime
        .difference(appointment.startTime)
        .inMinutes;
    final extraMinutes = appointment.blockedExtraMinutes;
    final base = totalMinutes - extraMinutes;
    return base > 0 ? base : 0;
  }

  /// Verifica se ci sono modifiche non salvate
  bool get _hasUnsavedChanges {
    if (_date != _initialDate) return true;
    if (_clientId != _initialClientId) return true;
    if (_clientName != _initialClientName) return true;
    if (_notesController.text != _initialNotes) return true;
    if (_serviceItems.length != _initialServiceItems.length) return true;

    // Confronto dettagliato dei servizi
    for (int i = 0; i < _serviceItems.length; i++) {
      final current = _serviceItems[i];
      final initial = _initialServiceItems[i];
      if (current.serviceId != initial.serviceId) return true;
      if (current.staffId != initial.staffId) return true;
      if (current.startTime != initial.startTime) return true;
      if (current.durationMinutes != initial.durationMinutes) return true;
      if (current.blockedExtraMinutes != initial.blockedExtraMinutes) {
        return true;
      }
      if (current.processingExtraMinutes != initial.processingExtraMinutes) {
        return true;
      }
    }

    return false;
  }

  /// Gestisce la chiusura del dialog con controllo modifiche
  Future<void> _handleClose() async {
    if (_hasUnsavedChanges) {
      final l10n = context.l10n;
      final confirmed = await showDialog<bool>(
        context: context,
        builder: (_) => AlertDialog(
          title: Text(l10n.discardChangesTitle),
          content: Text(l10n.discardChangesMessage),
          actions: [
            AppOutlinedActionButton(
              onPressed: () => Navigator.pop(context, false),
              child: Text(l10n.actionKeepEditing),
            ),
            AppDangerButton(
              onPressed: () => Navigator.pop(context, true),
              child: Text(l10n.actionDiscard),
            ),
          ],
        ),
      );
      if (confirmed != true) return;
    }
    if (mounted) Navigator.of(context).pop();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final isDialog = widget.presentation == _AppointmentPresentation.dialog;

    final formFactor = ref.watch(formFactorProvider);
    final services = ref.watch(servicesProvider).value ?? [];
    final serviceCategories = ref.watch(serviceCategoriesProvider);
    final variants = ref.watch(serviceVariantsProvider).value ?? [];
    final asyncClients = ref.watch(clientsProvider);
    final clients = asyncClients.value ?? [];
    final staff = ref.watch(staffForCurrentLocationProvider);

    final title = l10n.appointmentDialogTitleEdit;

    // Il campo cliente √® bloccato se l'appuntamento
    // aveva gi√† un cliente associato (clientId != null)
    final isClientLocked = widget.initial.clientId != null;

    final conflictFlags = _serviceConflictFlags();
    final eligibleIndices = <int>[];
    for (int i = 0; i < _serviceItems.length; i++) {
      if (_isWarningEligible(_serviceItems[i])) {
        eligibleIndices.add(i);
      }
    }
    final allEligibleConflict =
        eligibleIndices.isNotEmpty &&
        eligibleIndices.every((i) => conflictFlags[i]);
    final showAppointmentWarning =
        eligibleIndices.length > 1 && allEligibleConflict;
    final showServiceWarnings = !showAppointmentWarning;

    final content = ScrollConfiguration(
      behavior: const NoScrollbarBehavior(),
      child: SingleChildScrollView(
        controller: _scrollController,
        child: Form(
          key: _formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const SizedBox(height: AppSpacing.formFirstRowSpacing),
              // Client selection (first)
              _ClientSelectionField(
                clientId: _clientId,
                clientName: _clientName,
                clients: clients,
                isLocked: isClientLocked,
                onClientSelected: (id, name) {
                  setState(() {
                    _clientId = id;
                    _clientName = name;
                  });
                },
                onClientRemoved: () {
                  setState(() {
                    _clientId = null;
                    _clientName = '';
                  });
                },
              ),
              const SizedBox(height: AppSpacing.formRowSpacing),
              // Date
              InkWell(
                onTap: _pickDate,
                borderRadius: BorderRadius.circular(4),
                child: InputDecorator(
                  decoration: InputDecoration(
                    labelText: l10n.formDate,
                    contentPadding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 12,
                    ),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(4),
                    ),
                    isDense: true,
                  ),
                  child: Text(DtFmt.shortDate(context, _date)),
                ),
              ),
              const SizedBox(height: AppSpacing.formRowSpacing),
              // Services list
              ..._buildServiceItems(
                services: services,
                categories: serviceCategories,
                variants: variants,
                allStaff: staff,
                formFactor: formFactor,
                conflictFlags: conflictFlags,
                showServiceWarnings: showServiceWarnings,
                serviceWarningMessage:
                    l10n.bookingUnavailableTimeWarningService,
              ),
              const SizedBox(height: AppSpacing.formRowSpacing),
              // Notes field
              TextFormField(
                controller: _notesController,
                decoration: InputDecoration(
                  labelText: l10n.formNotes,
                  alignLabelWithHint: true,
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(4),
                  ),
                ),
                maxLines: 3,
                minLines: 2,
              ),
              const SizedBox(height: AppSpacing.formRowSpacing),
            ],
          ),
        ),
      ),
    );

    final actions = [
      AppDangerButton(
        onPressed: () async {
          final deleteTitle = _bookingHasSingleAppointment
              ? l10n.deleteAppointmentConfirmTitle
              : l10n.deleteBookingConfirmTitle;
          final deleteMessage = _bookingHasSingleAppointment
              ? l10n.deleteAppointmentConfirmMessage
              : l10n.deleteBookingConfirmMessage;
          final confirmed = await showDialog<bool>(
            context: context,
            builder: (_) => AlertDialog(
              title: Text(deleteTitle),
              content: Text(deleteMessage),
              actions: [
                AppOutlinedActionButton(
                  onPressed: () => Navigator.pop(context, false),
                  child: Text(l10n.actionCancel),
                ),
                AppDangerButton(
                  onPressed: () => Navigator.pop(context, true),
                  child: Text(l10n.actionDelete),
                ),
              ],
            ),
          );
          if (confirmed == true) {
            await ref
                .read(bookingsProvider.notifier)
                .deleteBooking(widget.initial.bookingId);
            if (context.mounted) Navigator.of(context).pop();
          }
        },
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionDelete),
      ),
      AppOutlinedActionButton(
        onPressed: _handleClose,
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppFilledButton(
        onPressed: _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionSave),
      ),
    ];

    if (isDialog) {
      return PopScope(
        canPop: false,
        onPopInvokedWithResult: (didPop, _) async {
          if (didPop) return;
          await _handleClose();
        },
        child: Dialog(
          insetPadding: const EdgeInsets.symmetric(
            horizontal: 32,
            vertical: 24,
          ),
          child: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text(title, style: Theme.of(context).textTheme.headlineSmall),
                  const SizedBox(height: 8),
                  Flexible(child: content),
                  const SizedBox(height: AppSpacing.formToActionsSpacing),
                  Padding(
                    padding: const EdgeInsets.only(
                      bottom: AppSpacing.formFirstRowSpacing,
                    ),
                    child: _warningBanner(
                      8,
                      showAppointmentWarning,
                      l10n.bookingUnavailableTimeWarningAppointment,
                    ),
                  ),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      for (int i = 0; i < actions.length; i++) ...[
                        if (i > 0) const SizedBox(width: 8),
                        SizedBox(
                          width: AppButtonStyles.dialogButtonWidth,
                          child: actions[i],
                        ),
                      ],
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      );
    }
    const horizontalPadding = 20.0;
    final isKeyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
    return PopScope(
      canPop: false,
      onPopInvokedWithResult: (didPop, _) async {
        if (didPop) return;
        await _handleClose();
      },
      child: SafeArea(
        top: false,
        left: false,
        right: false,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          mainAxisSize: MainAxisSize.min,
          children: [
            Padding(
              padding: EdgeInsets.fromLTRB(
                horizontalPadding,
                0,
                horizontalPadding,
                12,
              ),
              child: Text(title, style: Theme.of(context).textTheme.titleLarge),
            ),
            Expanded(
              child: Padding(
                padding: EdgeInsets.symmetric(horizontal: horizontalPadding),
                child: content,
              ),
            ),
            _warningBanner(
              horizontalPadding,
              showAppointmentWarning,
              l10n.bookingUnavailableTimeWarningAppointment,
            ),
            if (!isKeyboardOpen) ...[
              const AppBottomSheetDivider(),
              Padding(
                padding: EdgeInsets.fromLTRB(
                  horizontalPadding,
                  AppSpacing.formFirstRowSpacing,
                  horizontalPadding,
                  0,
                ),
                child: Row(
                  mainAxisAlignment: actions.length == 3
                      ? MainAxisAlignment.center
                      : MainAxisAlignment.end,
                  children: [
                    for (int i = 0; i < actions.length; i++) ...[
                      if (i > 0) const SizedBox(width: 8),
                      SizedBox(
                        width: AppButtonStyles.dialogButtonWidth,
                        child: actions[i],
                      ),
                    ],
                  ],
                ),
              ),
            ],
            SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
          ],
        ),
      ),
    );
  }

  Future<void> _pickDate() async {
    final picked = await showDialog<DateTime>(
      context: context,
      builder: (context) {
        return Dialog(
          child: CalendarDatePicker(
            initialDate: _date,
            firstDate: DateTime.now().subtract(const Duration(days: 365)),
            lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
            onDateChanged: (value) => Navigator.of(context).pop(value),
          ),
        );
      },
    );
    if (picked != null) {
      setState(() => _date = DateUtils.dateOnly(picked));
    }
  }

  void _scrollFormToBottom() {
    if (!_scrollController.hasClients) return;
    _scrollController.animateTo(
      _scrollController.position.maxScrollExtent,
      duration: const Duration(milliseconds: 250),
      curve: Curves.easeOut,
    );
  }

  List<Widget> _buildServiceItems({
    required List<dynamic> services,
    required List<dynamic> categories,
    required List<dynamic> variants,
    required List<dynamic> allStaff,
    required AppFormFactor formFactor,
    required List<bool> conflictFlags,
    required bool showServiceWarnings,
    required String serviceWarningMessage,
  }) {
    final widgets = <Widget>[];

    // Conta servizi effettivamente selezionati
    final selectedCount = _serviceItems
        .where((s) => s.serviceId != null)
        .length;

    for (int i = 0; i < _serviceItems.length; i++) {
      final item = _serviceItems[i];
      final TimeOfDay? suggestedStartTime = i > 0
          ? _resolveServiceEndTime(_serviceItems[i - 1], variants.cast())
          : null;
      final variant = item.serviceId != null
          ? variants.cast<ServiceVariant?>().firstWhere(
              (v) => v?.serviceId == item.serviceId,
              orElse: () => null,
            )
          : null;
      final defaultProcessing = variant?.processingTime ?? 0;
      final defaultBlocked = variant?.blockedTime ?? 0;
      final defaultExtraType = defaultBlocked > 0
          ? ExtraMinutesType.blocked
          : (defaultProcessing > 0 ? ExtraMinutesType.processing : null);
      final hasBlockedExtra = item.blockedExtraMinutes > 0;
      final hasProcessingExtra = item.processingExtraMinutes > 0;
      final canAddDefaultExtra = defaultExtraType == ExtraMinutesType.blocked
          ? !hasBlockedExtra
          : (defaultExtraType == ExtraMinutesType.processing
                ? !hasProcessingExtra
                : false);
      final showWarning =
          showServiceWarnings &&
          _isWarningEligible(item) &&
          i < conflictFlags.length &&
          conflictFlags[i];

      // Get eligible staff for this service
      final eligibleStaffIds = item.serviceId != null
          ? ref.watch(eligibleStaffForServiceProvider(item.serviceId!))
          : <int>[];
      final isStaffIneligible =
          item.serviceId != null &&
          item.staffId != null &&
          !eligibleStaffIds.contains(item.staffId);

      final isFirst = i == 0;
      final isLast = i == _serviceItems.length - 1;
      widgets.add(
        Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            if (isFirst) ...[
              Row(
                children: [
                  Text(
                    selectedCount > 0
                        ? context.l10n.servicesSelectedCount(selectedCount)
                        : context.l10n.formServices,
                    style: const TextStyle(fontWeight: FontWeight.w600),
                  ),
                ],
              ),
              const SizedBox(height: 8),
            ],
            Padding(
              padding: const EdgeInsets.only(bottom: 12),
              child: ServiceItemCard(
                index: i,
                item: item,
                services: services.cast(),
                categories: categories.cast(),
                variants: variants.cast(),
                eligibleStaff: eligibleStaffIds,
                allStaff: allStaff.cast(),
                formFactor: formFactor,
                canRemove: _serviceItems.length > 1,
                // Obbligatorio solo se non ci sono altri servizi selezionati
                isServiceRequired: selectedCount == 0,
                onChanged: (updated) => _updateServiceItem(i, updated),
                onRemove: () => _removeServiceItem(i),
                onStartTimeChanged: (time) => _updateServiceStartTime(i, time),
                onEndTimeChanged: (time) => _updateServiceEndTime(i, time),
                onDurationChanged: (duration) =>
                    _updateServiceDuration(i, duration),
                suggestedStartTime: suggestedStartTime,
                autoOpenServicePicker: _autoOpenServicePickerIndex == i,
                onServicePickerAutoOpened: _autoOpenServicePickerIndex == i
                    ? () => _onServicePickerAutoOpenedForIndex(i)
                    : null,
                onServicePickerAutoCompleted: _scrollFormToBottom,
                onAutoOpenStaffPickerCompleted: _scrollFormToBottom,
                availabilityWarningMessage: showWarning
                    ? serviceWarningMessage
                    : null,
                staffEligibilityWarningMessage: isStaffIneligible
                    ? context.l10n.bookingStaffNotEligibleWarning
                    : null,
              ),
            ),
            if (canAddDefaultExtra) ...[
              if (isLast && item.serviceId != null)
                Row(
                  children: [
                    AppOutlinedActionButton(
                      onPressed: () {
                        setState(() {
                          _serviceItems[i] =
                              defaultExtraType == ExtraMinutesType.blocked
                              ? _serviceItems[i].copyWith(
                                  blockedExtraMinutes: defaultBlocked,
                                )
                              : _serviceItems[i].copyWith(
                                  processingExtraMinutes: defaultProcessing,
                                );
                          _recalculateTimesFrom(i + 1, variants.cast());
                        });
                      },
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.add, size: 18),
                          const SizedBox(width: 8),
                          Text(context.l10n.additionalTimeSwitch),
                        ],
                      ),
                    ),
                    const Spacer(),
                    AppOutlinedActionButton(
                      onPressed: _addService,
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.add, size: 18),
                          const SizedBox(width: 8),
                          Text(context.l10n.addService),
                        ],
                      ),
                    ),
                  ],
                )
              else
                Align(
                  alignment: Alignment.centerRight,
                  child: AppOutlinedActionButton(
                    onPressed: () {
                      setState(() {
                        _serviceItems[i] =
                            defaultExtraType == ExtraMinutesType.blocked
                            ? _serviceItems[i].copyWith(
                                blockedExtraMinutes: defaultBlocked,
                              )
                            : _serviceItems[i].copyWith(
                                processingExtraMinutes: defaultProcessing,
                              );
                        _recalculateTimesFrom(i + 1, variants.cast());
                      });
                    },
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const Icon(Icons.add, size: 18),
                        const SizedBox(width: 8),
                        Text(context.l10n.additionalTimeSwitch),
                      ],
                    ),
                  ),
                ),
              const SizedBox(height: 24),
            ],
            if (hasBlockedExtra) ...[
              ExtraTimeCard(
                title: context.l10n.fieldBlockedTimeLabel,
                startTime: _baseEndTime(item, variants.cast()),
                durationMinutes: item.blockedExtraMinutes,
                formFactor: formFactor,
                onStartTimeChanged: (_) {},
                onDurationChanged: (duration) {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      blockedExtraMinutes: duration,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                  });
                },
                onRemove: () {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      blockedExtraMinutes: 0,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                  });
                },
              ),
              const SizedBox(height: 8),
            ],
            if (hasProcessingExtra) ...[
              ExtraTimeCard(
                title: context.l10n.fieldProcessingTimeLabel,
                startTime: _addMinutes(
                  _baseEndTime(item, variants.cast()),
                  item.blockedExtraMinutes,
                ),
                durationMinutes: item.processingExtraMinutes,
                formFactor: formFactor,
                onStartTimeChanged: (_) {},
                onDurationChanged: (duration) {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      processingExtraMinutes: duration,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                  });
                },
                onRemove: () {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      processingExtraMinutes: 0,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                  });
                },
              ),
              const SizedBox(height: 8),
            ],
            if (isLast && item.serviceId != null && !canAddDefaultExtra) ...[
              Align(
                alignment: Alignment.centerRight,
                child: AppOutlinedActionButton(
                  onPressed: _addService,
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      const Icon(Icons.add, size: 18),
                      const SizedBox(width: 8),
                      Text(context.l10n.addService),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 8),
            ],
          ],
        ),
      );
    }

    if (_serviceItems.isEmpty) {
      widgets.add(
        Container(
          padding: const EdgeInsets.all(24),
          decoration: BoxDecoration(
            border: Border.all(color: Theme.of(context).colorScheme.outline),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Center(
            child: Text(
              context.l10n.noServicesAdded,
              style: TextStyle(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ),
        ),
      );
    }

    return widgets;
  }

  Widget _warningBanner(
    double horizontalPadding,
    bool hasConflicts,
    String message,
  ) {
    if (!hasConflicts || _warningDismissed) return const SizedBox.shrink();
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.amber.withOpacity(0.18),
        borderRadius: BorderRadius.circular(8),
      ),
      padding: EdgeInsets.fromLTRB(
        horizontalPadding,
        12,
        horizontalPadding,
        12,
      ),
      child: Row(
        children: [
          const Icon(
            Icons.warning_amber_rounded,
            color: Colors.amber,
            size: 20,
          ),
          const SizedBox(width: 10),
          Expanded(
            child: Text(
              message,
              style: const TextStyle(
                color: Color(0xFF8A4D00),
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          IconButton(
            icon: const Icon(Icons.close, size: 18),
            color: const Color(0xFF8A4D00),
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints.tightFor(width: 32, height: 32),
            onPressed: () {
              setState(() => _warningDismissed = true);
            },
          ),
        ],
      ),
    );
  }

  bool _isWarningEligible(ServiceItemData item) {
    return item.serviceId != null && item.staffId != null;
  }

  List<bool> _serviceConflictFlags() {
    final layout = ref.watch(layoutConfigProvider);
    final Map<int, Set<int>> cache = {};
    final flags = <bool>[];

    for (final item in _serviceItems) {
      final staffId = item.staffId;
      if (staffId == null || item.serviceId == null) {
        flags.add(false);
        continue;
      }

      final available = cache.putIfAbsent(
        staffId,
        () => ref.watch(staffSlotAvailabilityProvider(staffId)),
      );

      if (available.isEmpty) {
        flags.add(true);
        continue;
      }

      final startMinutes = item.startTime.hour * 60 + item.startTime.minute;
      final endMinutes = startMinutes + item.durationMinutes;
      final startSlot = startMinutes ~/ layout.minutesPerSlot;
      final endSlot = (endMinutes / layout.minutesPerSlot).ceil();

      var hasConflict = false;
      for (int slot = startSlot; slot < endSlot; slot++) {
        if (!available.contains(slot)) {
          hasConflict = true;
          break;
        }
      }
      flags.add(hasConflict);
    }
    return flags;
  }

  void _addService() {
    final variants = ref.read(serviceVariantsProvider).value ?? [];
    // Calcola l'orario di inizio per il nuovo servizio
    TimeOfDay nextStart;
    if (_serviceItems.isEmpty) {
      // Caso raro: usa l'orario dell'appuntamento originale
      nextStart = TimeOfDay.fromDateTime(widget.initial.startTime);
    } else {
      // Prendi l'ultimo servizio e calcola il suo orario di fine
      final lastItem = _serviceItems.last;
      nextStart = _resolveServiceEndTime(lastItem, variants);
    }

    // Smart staff selection: usa lo staff dell'ultimo servizio aggiunto
    int? smartStaffId = _serviceItems.isNotEmpty
        ? _serviceItems.last.staffId
        : widget.initial.staffId;

    final newIndex = _serviceItems.length;
    setState(() {
      _serviceItems.add(
        ServiceItemData(
          key: _nextItemKey(),
          startTime: nextStart,
          staffId: smartStaffId,
        ),
      );
      _autoOpenServicePickerIndex = newIndex;
    });
  }

  void _onServicePickerAutoOpenedForIndex(int index) {
    if (_autoOpenServicePickerIndex != index) return;
    setState(() {
      _autoOpenServicePickerIndex = null;
    });
  }

  void _removeServiceItem(int index) {
    if (_serviceItems.length <= 1) return;

    final variants = ref.read(serviceVariantsProvider).value ?? [];

    setState(() {
      _serviceItems.removeAt(index);

      // Ricalcola gli orari per i servizi successivi
      _recalculateTimesFrom(index, variants);
    });
  }

  void _updateServiceItem(int index, ServiceItemData updated) {
    final variants = ref.read(serviceVariantsProvider).value ?? [];

    setState(() {
      _serviceItems[index] = updated;

      // Se cambia il servizio, potremmo dover aggiornare lo staff
      // e ricalcolare gli orari successivi
      _recalculateTimesFrom(index + 1, variants);

      // Se lo staff √® ancora null, seleziona automaticamente un eligible
      if (updated.serviceId != null && updated.staffId == null) {
        final newStaffId = _findBestStaff(updated.serviceId!);
        _serviceItems[index] = updated.copyWith(staffId: newStaffId);
      }
    });
  }

  void _updateServiceStartTime(int index, TimeOfDay newTime) {
    final variants = ref.read(serviceVariantsProvider).value ?? [];

    setState(() {
      final updated = _serviceItems[index].copyWith(startTime: newTime);
      _serviceItems[index] = _applyAutoExtraStart(updated, variants);

      // Ricalcola gli orari per i servizi successivi
      _recalculateTimesFrom(index + 1, variants);
    });
  }

  void _updateServiceEndTime(int index, TimeOfDay newEndTime) {
    setState(() {
      final item = _serviceItems[index];

      // Calcola la nuova durata basata sulla differenza tra end e start
      final startMinutes = item.startTime.hour * 60 + item.startTime.minute;
      final endMinutes = newEndTime.hour * 60 + newEndTime.minute;
      var newDuration = endMinutes - startMinutes;

      // Se la durata √® negativa o zero, imposta un minimo di 15 minuti
      if (newDuration <= 0) {
        newDuration = 15;
      }

      _serviceItems[index] = item.copyWith(durationMinutes: newDuration);

      // Ricalcola gli orari per i servizi successivi
      final variants = ref.read(serviceVariantsProvider).value ?? [];
      _serviceItems[index] = _applyAutoExtraStart(
        _serviceItems[index],
        variants,
      );
      _recalculateTimesFrom(index + 1, variants);
    });
  }

  void _updateServiceDuration(int index, int newDuration) {
    setState(() {
      _serviceItems[index] = _serviceItems[index].copyWith(
        durationMinutes: newDuration,
      );

      // Ricalcola gli orari per i servizi successivi
      final variants = ref.read(serviceVariantsProvider).value ?? [];
      _serviceItems[index] = _applyAutoExtraStart(
        _serviceItems[index],
        variants,
      );
      _recalculateTimesFrom(index + 1, variants);
    });
  }

  void _recalculateTimesFrom(int fromIndex, List<ServiceVariant> variants) {
    if (fromIndex <= 0 || fromIndex >= _serviceItems.length) return;

    for (int i = fromIndex; i < _serviceItems.length; i++) {
      final prevItem = _serviceItems[i - 1];
      final prevEnd = _resolveServiceEndTime(prevItem, variants);
      final updated = _serviceItems[i].copyWith(startTime: prevEnd);
      _serviceItems[i] = _applyAutoExtraStart(updated, variants);
    }
  }

  TimeOfDay _resolveServiceEndTime(
    ServiceItemData item,
    List<ServiceVariant> variants,
  ) {
    final baseEnd = _baseEndTime(item, variants);
    if (item.blockedExtraMinutes <= 0) {
      return baseEnd;
    }
    return _addMinutes(baseEnd, item.blockedExtraMinutes);
  }

  ServiceItemData _applyAutoExtraStart(
    ServiceItemData item,
    List<ServiceVariant> variants,
  ) {
    return item;
  }

  TimeOfDay _baseEndTime(ServiceItemData item, List<ServiceVariant> variants) {
    final variant = _variantForItem(item, variants);
    final baseDuration = item.durationMinutes > 0
        ? item.durationMinutes
        : (variant?.durationMinutes ?? 30);
    return item.getEndTime(baseDuration);
  }

  ServiceVariant? _variantForItem(
    ServiceItemData item,
    List<ServiceVariant> variants,
  ) {
    if (item.serviceVariantId != null) {
      for (final v in variants) {
        if (v.id == item.serviceVariantId) return v;
      }
    }
    if (item.serviceId != null) {
      for (final v in variants) {
        if (v.serviceId == item.serviceId) return v;
      }
    }
    return null;
  }

  TimeOfDay _addMinutes(TimeOfDay time, int minutes) {
    final totalMinutes = time.hour * 60 + time.minute + minutes;
    return TimeOfDay(
      hour: (totalMinutes ~/ 60) % 24,
      minute: totalMinutes % 60,
    );
  }

  /// Trova lo staff migliore per un servizio:
  /// 1. Primo staff eligible disponibile
  /// 2. null per selezione manuale
  int? _findBestStaff(int serviceId) {
    final eligibleIds = ref.read(eligibleStaffForServiceProvider(serviceId));
    if (eligibleIds.isEmpty) return null;
    return eligibleIds.first;
  }

  void _onSave() async {
    final l10n = context.l10n;
    if (!_formKey.currentState!.validate()) return;

    // Verifica che ci sia almeno un servizio selezionato
    // Filtra anche serviceId == 0 (dati corrotti nel DB)
    final validItems = _serviceItems
        .where(
          (item) =>
              item.serviceId != null &&
              item.serviceId! > 0 &&
              item.staffId != null,
        )
        .toList();

    if (validItems.isEmpty) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text(l10n.validationRequired)));
      return;
    }

    final variants = ref.read(serviceVariantsProvider).value ?? [];
    final services = ref.read(servicesProvider).value ?? [];

    // Client info (pu√≤ essere null se nessun cliente √® associato)
    final int? clientId = _clientId;
    final String clientName = _clientName.trim();
    final String? notes = _notesController.text.trim().isEmpty
        ? null
        : _notesController.text.trim();

    // Modifica appuntamento esistente
    final bookingId = widget.initial.bookingId;

    // Ottieni gli appuntamenti esistenti per questa prenotazione
    final existingAppointments = ref
        .read(appointmentsProvider.notifier)
        .getByBookingId(bookingId);

    // Verifica se il cliente √® cambiato (aggiunto, rimosso, o sostituito)
    final initialClientId = widget.initial.clientId;
    final clientChanged = initialClientId != clientId;

    // Se il cliente √® cambiato, aggiorna il booking
    if (clientChanged) {
      // Se ci sono altri appuntamenti, chiedi conferma
      if (existingAppointments.length > 1 && mounted) {
        final confirmed = await showDialog<bool>(
          context: context,
          builder: (_) => AlertDialog(
            title: Text(l10n.applyClientToAllAppointmentsTitle),
            content: Text(
              l10n.applyClientToAllAppointmentsMessage(
                existingAppointments.length - 1,
              ),
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context, false),
                child: Text(l10n.actionCancel),
              ),
              TextButton(
                onPressed: () => Navigator.pop(context, true),
                child: Text(l10n.actionConfirm),
              ),
            ],
          ),
        );

        if (confirmed != true) {
          // Utente ha annullato, non salvare
          return;
        }
      }

      // Aggiorna il cliente su tutti gli appuntamenti della prenotazione
      try {
        await ref
            .read(appointmentsProvider.notifier)
            .updateClientForBooking(
              bookingId: bookingId,
              clientId: clientId,
              clientName: clientName,
            );
      } catch (e) {
        if (mounted) {
          ScaffoldMessenger.of(
            context,
          ).showSnackBar(SnackBar(content: Text(l10n.errorTitle)));
        }
        return;
      }
    }

    // Aggiorna tutti i servizi
    final existingIds = existingAppointments.map((a) => a.id).toSet();
    final processedIds = <int>{};
    Appointment? scrollTarget;

    for (int i = 0; i < validItems.length; i++) {
      final item = validItems[i];

      final selectedVariant = variants.firstWhere(
        (v) => v.serviceId == item.serviceId,
      );
      final service = services.firstWhere((s) => s.id == item.serviceId);
      final serviceName = service.name;
      final serviceId = service.id;

      final blockedExtraMinutes = item.blockedExtraMinutes;
      final processingExtraMinutes = item.processingExtraMinutes;
      final extraMinutesType = blockedExtraMinutes > 0
          ? ExtraMinutesType.blocked
          : (processingExtraMinutes > 0 ? ExtraMinutesType.processing : null);
      final extraMinutes = extraMinutesType == ExtraMinutesType.blocked
          ? blockedExtraMinutes
          : (extraMinutesType == ExtraMinutesType.processing
                ? processingExtraMinutes
                : 0);
      final effectivePrice = selectedVariant.isFree
          ? null
          : selectedVariant.price;

      final start = DateTime(
        _date.year,
        _date.month,
        _date.day,
        item.startTime.hour,
        item.startTime.minute,
      );

      final baseDuration = item.durationMinutes > 0
          ? item.durationMinutes
          : selectedVariant.durationMinutes;
      final duration =
          baseDuration + (blockedExtraMinutes > 0 ? blockedExtraMinutes : 0);
      final end = start.add(Duration(minutes: duration));

      // Usa appointmentId per determinare se aggiornare o creare
      if (item.appointmentId != null) {
        // Aggiorna appuntamento esistente usando l'ID memorizzato
        final existing = existingAppointments.firstWhere(
          (a) => a.id == item.appointmentId,
        );
        processedIds.add(existing.id);

        final updated = existing.copyWith(
          staffId: item.staffId!,
          serviceId: serviceId,
          serviceVariantId: selectedVariant.id,
          clientId: clientId,
          clientName: clientName,
          serviceName: serviceName,
          startTime: start,
          endTime: end,
          price: effectivePrice,
          extraMinutes: extraMinutes,
          extraMinutesType: extraMinutesType,
          extraBlockedMinutes: blockedExtraMinutes,
          extraProcessingMinutes: processingExtraMinutes,
        );
        ref.read(appointmentsProvider.notifier).updateAppointment(updated);
        scrollTarget ??= updated;
      } else {
        // Crea nuovo appuntamento (aggiunto durante la modifica)
        final created = await ref
            .read(appointmentsProvider.notifier)
            .addAppointment(
              bookingId: bookingId,
              staffId: item.staffId!,
              serviceId: serviceId,
              serviceVariantId: selectedVariant.id,
              clientId: clientId,
              clientName: clientName,
              serviceName: serviceName,
              start: start,
              end: end,
              price: effectivePrice,
              extraMinutes: extraMinutes,
              extraMinutesType: extraMinutesType,
              extraBlockedMinutes: blockedExtraMinutes,
              extraProcessingMinutes: processingExtraMinutes,
            );
        scrollTarget ??= created;
      }
    }

    // Elimina appuntamenti rimossi (quelli in existingIds ma non in processedIds)
    for (final id in existingIds.difference(processedIds)) {
      ref.read(appointmentsProvider.notifier).deleteAppointment(id);
    }

    // Aggiorna le note nella booking associata
    ref.read(bookingsProvider.notifier).setNotes(bookingId, notes);

    // Rimuovi la booking se vuota
    ref.read(bookingsProvider.notifier).removeIfEmpty(bookingId);

    if (scrollTarget != null) {
      ref.read(agendaScrollRequestProvider.notifier).request(scrollTarget);
    }
    if (mounted) {
      Navigator.of(context).pop();
    }
  }
}

class _ClientItem {
  final int id;
  final String name;
  const _ClientItem(this.id, this.name);
}

/// Widget per la selezione del cliente con link cliccabile e hint
class _ClientSelectionField extends ConsumerWidget {
  const _ClientSelectionField({
    required this.clientId,
    required this.clientName,
    required this.clients,
    required this.onClientSelected,
    required this.onClientRemoved,
    this.isLocked = false,
  });

  final int? clientId;
  final String clientName;
  final List<Client> clients;
  final void Function(int? id, String name) onClientSelected;
  final VoidCallback onClientRemoved;
  final bool isLocked;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final hasClient = clientId != null || clientName.isNotEmpty;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          l10n.formClient,
          style: const TextStyle(fontWeight: FontWeight.w600),
        ),
        const SizedBox(height: 6),
        if (hasClient)
          _SelectedClientTile(
            clientName: clientName,
            onTap: isLocked ? null : () => _showClientPicker(context, ref),
            onRemove: isLocked ? null : onClientRemoved,
          )
        else
          InkWell(
            onTap: isLocked ? null : () => _showClientPicker(context, ref),
            borderRadius: BorderRadius.circular(8),
            child: Container(
              width: double.infinity,
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 14),
              decoration: BoxDecoration(
                border: Border.all(
                  color: isLocked
                      ? theme.colorScheme.outline.withOpacity(0.5)
                      : theme.colorScheme.outline,
                ),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.person_add_outlined,
                    size: 20,
                    color: isLocked
                        ? theme.colorScheme.onSurfaceVariant
                        : theme.colorScheme.primary,
                  ),
                  const SizedBox(width: 8),
                  Text(
                    l10n.addClientToAppointment,
                    style: TextStyle(
                      color: isLocked
                          ? theme.colorScheme.onSurfaceVariant
                          : theme.colorScheme.primary,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            ),
          ),
        const SizedBox(height: 6),
        Text(
          isLocked ? l10n.clientLockedHint : l10n.clientOptionalHint,
          style: theme.textTheme.bodySmall?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
      ],
    );
  }

  Future<void> _showClientPicker(BuildContext context, WidgetRef ref) async {
    while (true) {
      final result = await AppBottomSheet.show<_ClientItem?>(
        context: context,
        useRootNavigator: true,
        padding: EdgeInsets.zero,
        heightFactor: AppBottomSheet.defaultHeightFactor,
        builder: (ctx) =>
            _ClientPickerSheet(clients: clients, selectedClientId: clientId),
      );
      if (result == null) {
        // Sheet dismissed without selection, do nothing
        return;
      }
      if (result.id == -2) {
        // "Create new client" was selected
        // result.name contains the search query to pre-populate the form
        if (context.mounted) {
          Client? initialClient;
          if (result.name.isNotEmpty) {
            // Split the search query into first name and last name
            final nameParts = Client.splitFullName(result.name);
            initialClient = Client(
              id: 0,
              businessId: 0,
              firstName: nameParts.firstName,
              lastName: nameParts.lastName,
              createdAt: DateTime.now(),
            );
          }
          final newClient = await showClientEditDialog(
            context,
            ref,
            client: initialClient,
          );
          if (newClient != null) {
            // Client saved, select it and return to appointment form
            onClientSelected(newClient.id, newClient.name);
            return;
          }
          // Client creation cancelled, loop back to show picker again
          continue;
        }
        return;
      } else if (result.id == -1) {
        // "No client for appointment" was selected
        onClientRemoved();
        return;
      } else {
        onClientSelected(result.id, result.name);
        return;
      }
    }
  }
}

/// Tile che mostra il cliente selezionato con opzione per rimuoverlo
class _SelectedClientTile extends StatelessWidget {
  const _SelectedClientTile({
    required this.clientName,
    this.onTap,
    this.onRemove,
  });

  final String clientName;
  final VoidCallback? onTap;
  final VoidCallback? onRemove;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isLocked = onTap == null && onRemove == null;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
        decoration: BoxDecoration(
          border: Border.all(
            color: isLocked
                ? theme.colorScheme.outline.withOpacity(0.5)
                : theme.colorScheme.outline,
          ),
          borderRadius: BorderRadius.circular(8),
          color: isLocked ? theme.colorScheme.surfaceContainerLow : null,
        ),
        child: Row(
          children: [
            StaffCircleAvatar(
              height: 32,
              color: theme.colorScheme.primary,
              isHighlighted: false,
              initials: clientName.isNotEmpty
                  ? initialsFromName(clientName, maxChars: 2)
                  : '?',
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
                clientName,
                style: TextStyle(
                  fontWeight: FontWeight.w500,
                  color: isLocked ? theme.colorScheme.onSurfaceVariant : null,
                ),
              ),
            ),
            if (onRemove != null)
              IconButton(
                icon: Icon(
                  Icons.close,
                  size: 20,
                  color: theme.colorScheme.error,
                ),
                onPressed: onRemove,
                tooltip: context.l10n.removeClient,
                padding: EdgeInsets.zero,
                constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
              )
            else if (isLocked)
              Icon(
                Icons.lock_outline,
                size: 18,
                color: theme.colorScheme.onSurfaceVariant.withOpacity(0.6),
              ),
          ],
        ),
      ),
    );
  }
}

/// Bottom sheet per la selezione del cliente
class _ClientPickerSheet extends ConsumerStatefulWidget {
  const _ClientPickerSheet({required this.clients, this.selectedClientId});

  final List<Client> clients;
  final int? selectedClientId;

  @override
  ConsumerState<_ClientPickerSheet> createState() => _ClientPickerSheetState();
}

class _ClientPickerSheetState extends ConsumerState<_ClientPickerSheet> {
  final _searchController = TextEditingController();
  String _searchQuery = '';

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  List<Client> get _filteredClients {
    // Use live clients from provider to get updates after creation
    final asyncClients = ref.watch(clientsProvider);
    final clients = asyncClients.value ?? [];
    if (_searchQuery.isEmpty) return clients;
    final q = _searchQuery.toLowerCase();
    return clients.where((c) => c.name.toLowerCase().contains(q)).toList();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return SafeArea(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 16, 16, 12),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  l10n.selectClientTitle,
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: AppSpacing.formFirstRowSpacing),
                // Search field
                TextField(
                  controller: _searchController,
                  decoration: InputDecoration(
                    hintText: l10n.searchClientPlaceholder,
                    prefixIcon: const Icon(Icons.search, size: 20),
                    border: const OutlineInputBorder(),
                    isDense: true,
                    contentPadding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 10,
                    ),
                  ),
                  onChanged: (value) {
                    setState(() => _searchQuery = value.trim());
                  },
                ),
              ],
            ),
          ),
          const AppBottomSheetDivider(),
          // Quick actions: Create new client / No client
          ListTile(
            leading: StaffCircleAvatar(
              height: 32,
              color: theme.colorScheme.onSurfaceVariant,
              isHighlighted: false,
              initials: '',
              child: Icon(
                Icons.person_add_outlined,
                color: theme.colorScheme.onSurface,
                size: 18,
              ),
            ),
            title: Text(l10n.createNewClient),
            onTap: () {
              // Use special marker with id = -2 to indicate "create new client"
              // Pass search query in name field to pre-populate the form
              Navigator.of(context).pop(_ClientItem(-2, _searchQuery));
            },
          ),
          ListTile(
            leading: StaffCircleAvatar(
              height: 32,
              color: theme.colorScheme.onSurfaceVariant,
              isHighlighted: false,
              initials: '',
              child: Icon(
                Icons.person_off_outlined,
                color: theme.colorScheme.onSurface,
                size: 18,
              ),
            ),
            title: Text(l10n.noClientForAppointment),
            onTap: () {
              // Use special marker with id = -1 to indicate "no client"
              Navigator.of(context).pop(const _ClientItem(-1, ''));
            },
          ),
          const AppBottomSheetDivider(),
          // Client list
          Expanded(
            child: _filteredClients.isEmpty
                ? Center(
                    child: Text(
                      l10n.clientsEmpty,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                  )
                : ListView.builder(
                    padding: const EdgeInsets.only(bottom: 8),
                    itemCount: _filteredClients.length,
                    itemBuilder: (context, index) {
                      final client = _filteredClients[index];
                      final isSelected = client.id == widget.selectedClientId;
                      return ListTile(
                        leading: StaffCircleAvatar(
                          height: 32,
                          color: theme.colorScheme.primary,
                          isHighlighted: isSelected,
                          initials: client.name.isNotEmpty
                              ? initialsFromName(client.name, maxChars: 2)
                              : '?',
                        ),
                        title: Text(client.name),
                        subtitle: client.phone != null
                            ? Text(
                                client.phone!,
                                style: theme.textTheme.bodySmall,
                              )
                            : null,
                        trailing: isSelected
                            ? Icon(
                                Icons.check_circle,
                                color: theme.colorScheme.primary,
                              )
                            : null,
                        onTap: () {
                          Navigator.of(
                            context,
                          ).pop(_ClientItem(client.id, client.name));
                        },
                      );
                    },
                  ),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/widgets/service_item_card.dart ---
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../core/l10n/date_time_formats.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';
import '../../../../core/models/service_variant.dart';
import '../../../../core/models/staff.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../domain/config/layout_config.dart';
import '../../domain/service_item_data.dart';
import 'service_picker_field.dart';

String _formatExtraDuration(int minutes) {
  if (minutes < 60) {
    return '$minutes min';
  }
  final hours = minutes ~/ 60;
  final mins = minutes % 60;
  if (mins == 0) {
    return '$hours h';
  }
  return '$hours h $mins min';
}

/// Card per visualizzare e modificare un singolo servizio nella prenotazione.
class ServiceItemCard extends ConsumerStatefulWidget {
  const ServiceItemCard({
    super.key,
    required this.item,
    required this.index,
    required this.services,
    required this.categories,
    required this.variants,
    required this.eligibleStaff,
    required this.allStaff,
    required this.formFactor,
    required this.onChanged,
    required this.onRemove,
    required this.onStartTimeChanged,
    required this.onEndTimeChanged,
    required this.onDurationChanged,
    this.suggestedStartTime,
    this.canRemove = true,
    this.isServiceRequired = true,
    this.autoOpenServicePicker = false,
    this.onServicePickerAutoOpened,
    this.onServicePickerAutoCompleted,
    this.onAutoOpenStaffPickerCompleted,
    this.availabilityWarningMessage,
    this.staffEligibilityWarningMessage,
  });

  final ServiceItemData item;
  final int index;
  final List<Service> services;
  final List<ServiceCategory> categories;
  final List<ServiceVariant> variants;
  final List<int> eligibleStaff; // Staff IDs abilitati per il servizio corrente
  final List<Staff> allStaff;
  final AppFormFactor formFactor;
  final ValueChanged<ServiceItemData> onChanged;
  final VoidCallback onRemove;
  final ValueChanged<TimeOfDay> onStartTimeChanged;
  final ValueChanged<TimeOfDay> onEndTimeChanged;
  final ValueChanged<int> onDurationChanged;
  final TimeOfDay? suggestedStartTime;
  final bool canRemove;

  /// Se true, la selezione del servizio √® obbligatoria (mostra errore di validazione).
  final bool isServiceRequired;
  final bool autoOpenServicePicker;
  final VoidCallback? onServicePickerAutoOpened;
  final VoidCallback? onServicePickerAutoCompleted;
  final VoidCallback? onAutoOpenStaffPickerCompleted;
  final String? availabilityWarningMessage;
  final String? staffEligibilityWarningMessage;

  @override
  ConsumerState<ServiceItemCard> createState() => _ServiceItemCardState();
}

class _ServiceItemCardState extends ConsumerState<ServiceItemCard> {
  bool _autoOpenStaffRequested = false;
  bool _shouldAutoOpenStaff = false;

  ServiceItemData get item => widget.item;
  int get index => widget.index;
  List<Service> get services => widget.services;
  List<ServiceCategory> get categories => widget.categories;
  List<ServiceVariant> get variants => widget.variants;
  List<int> get eligibleStaff => widget.eligibleStaff;
  List<Staff> get allStaff => widget.allStaff;
  AppFormFactor get formFactor => widget.formFactor;
  ValueChanged<ServiceItemData> get onChanged => widget.onChanged;
  VoidCallback get onRemove => widget.onRemove;
  ValueChanged<TimeOfDay> get onStartTimeChanged => widget.onStartTimeChanged;
  ValueChanged<TimeOfDay> get onEndTimeChanged => widget.onEndTimeChanged;
  ValueChanged<int> get onDurationChanged => widget.onDurationChanged;
  TimeOfDay? get suggestedStartTime => widget.suggestedStartTime;
  bool get canRemove => widget.canRemove;
  bool get isServiceRequired => widget.isServiceRequired;
  bool get autoOpenServicePicker => widget.autoOpenServicePicker;
  VoidCallback? get onServicePickerAutoOpened =>
      widget.onServicePickerAutoOpened;
  VoidCallback? get onServicePickerAutoCompleted =>
      widget.onServicePickerAutoCompleted;
  VoidCallback? get onAutoOpenStaffPickerCompleted =>
      widget.onAutoOpenStaffPickerCompleted;
  String? get availabilityWarningMessage => widget.availabilityWarningMessage;
  String? get staffEligibilityWarningMessage =>
      widget.staffEligibilityWarningMessage;

  @override
  void didUpdateWidget(covariant ServiceItemCard oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.item.serviceId != widget.item.serviceId) {
      _autoOpenStaffRequested = false;
      _shouldAutoOpenStaff =
          widget.item.serviceId != null && widget.item.staffId == null;
    }
    if (widget.item.staffId != null) {
      _autoOpenStaffRequested = false;
      _shouldAutoOpenStaff = false;
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    final selectedService = item.serviceId != null
        ? services.where((s) => s.id == item.serviceId).firstOrNull
        : null;

    final selectedStaff = item.staffId != null
        ? allStaff.where((s) => s.id == item.staffId).firstOrNull
        : null;

    // Staff disponibili per la selezione: sempre tutto lo staff della location
    // eligibleStaff serve solo per la selezione automatica, non per filtrare la lista
    final availableStaff = allStaff;

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: theme.colorScheme.outlineVariant),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Servizio
            _buildServiceSelector(context, l10n, selectedService),

            const SizedBox(height: 12),

            // Staff
            _buildStaffSelector(
              context,
              l10n,
              selectedStaff,
              availableStaff,
              theme,
            ),

            const SizedBox(height: 12),

            // Orario
            _buildTimeSelector(context, l10n, theme),

            if (availabilityWarningMessage != null) ...[
              const SizedBox(height: 12),
              _buildAvailabilityWarning(availabilityWarningMessage!),
            ],
            if (staffEligibilityWarningMessage != null) ...[
              const SizedBox(height: 12),
              _buildAvailabilityWarning(staffEligibilityWarningMessage!),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildServiceSelector(
    BuildContext context,
    dynamic l10n,
    Service? selectedService,
  ) {
    return ServicePickerField(
      services: services,
      categories: categories,
      formFactor: formFactor,
      value: item.serviceId,
      onChanged: (serviceId) {
        if (serviceId != null) {
          // Trova la variante di default per il servizio
          final variant = variants
              .where((v) => v.serviceId == serviceId)
              .firstOrNull;
          final duration = variant?.durationMinutes ?? 30;
          onChanged(
            item.copyWith(
              serviceId: serviceId,
              serviceVariantId: variant?.id,
              durationMinutes: duration,
              // Mantieni lo staff selezionato se presente
              staffId: item.staffId,
              blockedExtraMinutes: variant?.blockedTime ?? 0,
              processingExtraMinutes: variant?.processingTime ?? 0,
            ),
          );
        }
      },
      // Mostra icona rimuovi solo se canRemove e servizio selezionato
      onClear: canRemove && item.serviceId != null ? onRemove : null,
      validator: isServiceRequired
          ? (v) => v == null ? l10n.validationRequired : null
          : null,
      autoOpenPicker: autoOpenServicePicker,
      onAutoOpenPickerTriggered: onServicePickerAutoOpened,
      onAutoOpenPickerCompleted: onServicePickerAutoCompleted,
    );
  }

  Widget _buildAvailabilityWarning(String message) {
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.amber.withOpacity(0.18),
        borderRadius: BorderRadius.circular(8),
      ),
      padding: const EdgeInsets.all(12),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Icon(
            Icons.warning_amber_rounded,
            color: Colors.amber,
            size: 18,
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              message,
              style: const TextStyle(
                color: Color(0xFF8A4D00),
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStaffSelector(
    BuildContext context,
    dynamic l10n,
    Staff? selectedStaff,
    List<Staff> availableStaff,
    ThemeData theme,
  ) {
    // Staff √® obbligatorio se c'√® un servizio selezionato in questa card
    final isStaffRequired = item.serviceId != null;

    return FormField<int>(
      initialValue: item.staffId,
      validator: isStaffRequired
          ? (v) => v == null ? l10n.validationRequired : null
          : null,
      builder: (field) {
        if (_shouldAutoOpenStaff && !_autoOpenStaffRequested) {
          _autoOpenStaffRequested = true;
          _shouldAutoOpenStaff = false;
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (!mounted) return;
            _showStaffPicker(context, availableStaff, field).whenComplete(() {
              if (!mounted) return;
              onAutoOpenStaffPickerCompleted?.call();
            });
          });
        }

        final hasError = field.hasError;
        final borderColor = hasError
            ? theme.colorScheme.error
            : theme.colorScheme.outline;

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            InkWell(
              onTap: () => _showStaffPicker(context, availableStaff, field),
              borderRadius: BorderRadius.circular(4),
              child: InputDecorator(
                decoration: InputDecoration(
                  labelText: l10n.formStaff,
                  contentPadding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 12,
                  ),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(4),
                    borderSide: BorderSide(color: borderColor),
                  ),
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(4),
                    borderSide: BorderSide(color: borderColor),
                  ),
                  suffixIcon: const Icon(Icons.arrow_drop_down),
                  enabled: true,
                ),
                child: Row(
                  children: [
                    if (selectedStaff != null) ...[
                      StaffCircleAvatar(
                        height: 32,
                        color: selectedStaff.color,
                        isHighlighted: false,
                        initials: selectedStaff.initials,
                      ),
                      const SizedBox(width: 8),
                    ],
                    Expanded(
                      child: Text(
                        selectedStaff?.name ?? l10n.selectStaffTitle,
                        style: theme.textTheme.bodyLarge,
                      ),
                    ),
                  ],
                ),
              ),
            ),
            if (field.hasError && field.errorText != null)
              Padding(
                padding: const EdgeInsets.only(left: 12, top: 8),
                child: Text(
                  field.errorText!,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.error,
                  ),
                ),
              ),
          ],
        );
      },
    );
  }

  Widget _buildTimeSelector(
    BuildContext context,
    dynamic l10n,
    ThemeData theme,
  ) {
    final selectedService = item.serviceId != null
        ? services.where((s) => s.id == item.serviceId).firstOrNull
        : null;
    // Usa la durata dalla variante solo se item.durationMinutes non √® impostato
    final variant = item.serviceVariantId != null
        ? variants.where((v) => v.id == item.serviceVariantId).firstOrNull
        : (item.serviceId != null
              ? variants.where((v) => v.serviceId == item.serviceId).firstOrNull
              : null);
    // Priorit√†: item.durationMinutes > variant.durationMinutes > 30
    final baseDuration = item.durationMinutes > 0
        ? item.durationMinutes
        : (variant?.durationMinutes ?? 30);
    final endTime = item.getEndTime(baseDuration);

    // Costruiamo sempre tre colonne (Start, End, Duration) in modo che
    // l'elemento "Start" assuma sempre le dimensioni che avrebbe quando
    // End e Duration sono visibili. Quando il servizio non √® selezionato,
    // gli ultimi due vengono resi invisibili e non interattivi, ma mantengono
    // lo spazio.
    Widget buildInvisibleIfNoService(Widget w) {
      if (selectedService != null) return w;
      return IgnorePointer(child: Opacity(opacity: 0.0, child: w));
    }

    return Row(
      children: [
        // Start - sempre visibile
        Expanded(
          child: _TimeField(
            label: l10n.blockStartTime,
            time: item.startTime,
            onTap: () => _showStartTimePicker(context),
            theme: theme,
          ),
        ),
        const SizedBox(width: 8),

        // End - visibile solo se servizio selezionato (non modificabile, si calcola dalla durata)
        Expanded(
          child: buildInvisibleIfNoService(
            _TimeField(
              label: l10n.blockEndTime,
              time: endTime,
              onTap:
                  null, // Disabilitato: l'orario di fine si calcola da inizio + durata
              theme: theme,
            ),
          ),
        ),
        const SizedBox(width: 8),

        // Duration - visibile/interattivo solo se servizio selezionato
        Expanded(
          child: buildInvisibleIfNoService(
            _DurationField(
              label: l10n.fieldDurationRequiredLabel.replaceAll(' *', ''),
              durationMinutes: baseDuration,
              onTap: () => _showDurationPicker(context, baseDuration),
              theme: theme,
            ),
          ),
        ),
      ],
    );
  }

  void _showStartTimePicker(BuildContext context) async {
    final l10n = context.l10n;

    if (formFactor != AppFormFactor.desktop) {
      final picked = await AppBottomSheet.show<TimeOfDay>(
        context: context,
        padding: EdgeInsets.zero,
        heightFactor: AppBottomSheet.defaultHeightFactor,
        builder: (ctx) => _TimeGridPicker(
          initial: item.startTime,
          includeTime: suggestedStartTime,
          stepMinutes: 15,
          title: l10n.blockStartTime,
        ),
      );

      if (picked != null) {
        onStartTimeChanged(picked);
      }
    } else {
      final picked = await showDialog<TimeOfDay>(
        context: context,
        builder: (ctx) => Dialog(
          insetPadding: const EdgeInsets.symmetric(
            horizontal: 32,
            vertical: 24,
          ),
          child: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: _TimeGridPicker(
                initial: item.startTime,
                includeTime: suggestedStartTime,
                stepMinutes: 15,
                title: l10n.blockStartTime,
                useSafeArea: false,
              ),
            ),
          ),
        ),
      );

      if (picked != null) {
        onStartTimeChanged(picked);
      }
    }
  }

  void _showDurationPicker(BuildContext context, int currentDuration) {
    final l10n = context.l10n;

    // Calcola i minuti disponibili fino a mezzanotte (24:00)
    final startMinutes = item.startTime.hour * 60 + item.startTime.minute;
    final maxMinutesAvailable = (24 * 60) - startMinutes;

    // Durate comuni in minuti: fino a 60 con step variabili, dopo 60 con step di 15 min
    final allDurations = <int>[
      5, 10, 15, 30, 45, 60,
      // Dopo 60 minuti, incrementi di 15 fino a 6 ore (360 min)
      for (int m = 75; m <= 360; m += 15) m,
    ];
    final durations = allDurations
        .where((d) => d <= maxMinutesAvailable)
        .toList();

    // Se la durata corrente non √® nella lista ma √® valida, aggiungila
    if (currentDuration > 0 &&
        currentDuration <= maxMinutesAvailable &&
        !durations.contains(currentDuration)) {
      durations.add(currentDuration);
      durations.sort();
    }

    if (formFactor != AppFormFactor.desktop) {
      AppBottomSheet.show(
        context: context,
        padding: EdgeInsets.zero,
        builder: (ctx) => SafeArea(
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Padding(
                  padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                  child: Text(
                    l10n.fieldDurationRequiredLabel.replaceAll(' *', ''),
                    style: Theme.of(ctx).textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
                const Divider(height: 1),
                ...durations.map(
                  (d) => ListTile(
                    title: Text(_formatExtraDuration(d)),
                    trailing: d == currentDuration
                        ? Icon(
                            Icons.check,
                            color: Theme.of(ctx).colorScheme.primary,
                          )
                        : null,
                    onTap: () {
                      Navigator.of(ctx).pop();
                      onDurationChanged(d);
                    },
                  ),
                ),
                const SizedBox(height: 8),
              ],
            ),
          ),
        ),
      );
    } else {
      showDialog(
        context: context,
        builder: (ctx) => AlertDialog(
          title: Text(l10n.fieldDurationRequiredLabel.replaceAll(' *', '')),
          content: SizedBox(
            width: 300,
            child: ConstrainedBox(
              constraints: BoxConstraints(
                maxHeight: MediaQuery.of(ctx).size.height * 0.5,
              ),
              child: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: durations
                      .map(
                        (d) => ListTile(
                          title: Text(_formatDuration(d)),
                          trailing: d == currentDuration
                              ? Icon(
                                  Icons.check,
                                  color: Theme.of(ctx).colorScheme.primary,
                                )
                              : null,
                          onTap: () {
                            Navigator.of(ctx).pop();
                            onDurationChanged(d);
                          },
                        ),
                      )
                      .toList(),
                ),
              ),
            ),
          ),
        ),
      );
    }
  }

  String _formatDuration(int minutes) {
    if (minutes < 60) {
      return '$minutes min';
    }
    final hours = minutes ~/ 60;
    final mins = minutes % 60;
    if (mins == 0) {
      return '$hours h';
    }
    return '$hours h $mins min';
  }

  Future<void> _showStaffPicker(
    BuildContext context,
    List<Staff> availableStaff,
    FormFieldState<int> field,
  ) async {
    final l10n = context.l10n;

    if (formFactor != AppFormFactor.desktop) {
      await AppBottomSheet.show(
        context: context,
        padding: EdgeInsets.zero,
        builder: (ctx) => SafeArea(
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Padding(
                  padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                  child: Text(
                    l10n.selectStaffTitle,
                    style: Theme.of(ctx).textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
                const Divider(height: 1),
                _StaffPickerContent(
                  staff: availableStaff,
                  selectedId: item.staffId,
                  onSelected: (staffId) {
                    Navigator.of(ctx).pop();
                    field.didChange(staffId);
                    field.validate();
                    onChanged(item.copyWith(staffId: staffId));
                  },
                ),
                const SizedBox(height: 8),
              ],
            ),
          ),
        ),
      );
    } else {
      // Per desktop, usa un dialog semplice con scroll
      await showDialog(
        context: context,
        builder: (ctx) => AlertDialog(
          title: Text(l10n.selectStaffTitle),
          content: SizedBox(
            width: 300,
            child: ConstrainedBox(
              constraints: BoxConstraints(
                maxHeight: MediaQuery.of(ctx).size.height * 0.5,
              ),
              child: SingleChildScrollView(
                child: _StaffPickerContent(
                  staff: availableStaff,
                  selectedId: item.staffId,
                  onSelected: (staffId) {
                    Navigator.of(ctx).pop();
                    field.didChange(staffId);
                    field.validate();
                    onChanged(item.copyWith(staffId: staffId));
                  },
                ),
              ),
            ),
          ),
        ),
      );
    }
  }
}

/// Widget per mostrare un campo orario cliccabile
class _TimeField extends StatelessWidget {
  const _TimeField({
    required this.label,
    required this.time,
    required this.onTap,
    required this.theme,
  });

  final String label;
  final TimeOfDay time;
  final VoidCallback? onTap;
  final ThemeData theme;

  @override
  Widget build(BuildContext context) {
    final hour = time.hour.toString().padLeft(2, '0');
    final minute = time.minute.toString().padLeft(2, '0');
    final isDisabled = onTap == null;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(4),
      child: InputDecorator(
        decoration: InputDecoration(
          labelText: label,
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 10,
            vertical: 10,
          ),
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(4)),
          isDense: true,
          enabled: !isDisabled,
        ),
        child: Text(
          '$hour:$minute',
          style: theme.textTheme.bodyMedium?.copyWith(
            color: isDisabled
                ? theme.colorScheme.onSurface.withOpacity(0.5)
                : null,
          ),
        ),
      ),
    );
  }
}

class ExtraTimeCard extends StatefulWidget {
  const ExtraTimeCard({
    super.key,
    required this.title,
    required this.startTime,
    required this.durationMinutes,
    required this.onStartTimeChanged,
    required this.onDurationChanged,
    required this.onRemove,
    required this.formFactor,
  });

  final String title;
  final TimeOfDay startTime;
  final int durationMinutes;
  final ValueChanged<TimeOfDay> onStartTimeChanged;
  final ValueChanged<int> onDurationChanged;
  final VoidCallback onRemove;
  final AppFormFactor formFactor;

  @override
  State<ExtraTimeCard> createState() => _ExtraTimeCardState();
}

class _ExtraTimeCardState extends State<ExtraTimeCard> {
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final endTime = _addMinutes(widget.startTime, widget.durationMinutes);

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: theme.colorScheme.outlineVariant),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Expanded(
                  child: Text(
                    widget.title,
                    style: theme.textTheme.bodyMedium?.copyWith(
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                ),
                IconButton(
                  tooltip: l10n.actionClose,
                  icon: const Icon(Icons.close, size: 18),
                  onPressed: widget.onRemove,
                ),
              ],
            ),
            const SizedBox(height: 8),
            Row(
              children: [
                Expanded(
                  child: _TimeField(
                    label: l10n.blockStartTime,
                    time: widget.startTime,
                    onTap: null,
                    theme: theme,
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: _TimeField(
                    label: l10n.blockEndTime,
                    time: endTime,
                    onTap: null,
                    theme: theme,
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: _DurationField(
                    label: l10n.fieldDurationRequiredLabel.replaceAll(' *', ''),
                    durationMinutes: widget.durationMinutes,
                    onTap: () =>
                        _showDurationPicker(context, widget.durationMinutes),
                    theme: theme,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  TimeOfDay _addMinutes(TimeOfDay time, int minutes) {
    final totalMinutes = time.hour * 60 + time.minute + minutes;
    return TimeOfDay(
      hour: (totalMinutes ~/ 60) % 24,
      minute: totalMinutes % 60,
    );
  }

  void _showDurationPicker(BuildContext context, int currentDuration) {
    final l10n = context.l10n;

    // Calcola i minuti disponibili fino a mezzanotte (24:00)
    final startMinutes = widget.startTime.hour * 60 + widget.startTime.minute;
    final maxMinutesAvailable = (24 * 60) - startMinutes;

    // Durate comuni in minuti: fino a 60 con step variabili, dopo 60 con step di 15 min
    final allDurations = <int>[
      5,
      10,
      15,
      30,
      45,
      60,
      for (int m = 75; m <= 360; m += 15) m,
    ];
    final durations = allDurations
        .where((d) => d <= maxMinutesAvailable)
        .toList();

    if (currentDuration > 0 &&
        currentDuration <= maxMinutesAvailable &&
        !durations.contains(currentDuration)) {
      durations.add(currentDuration);
      durations.sort();
    }

    if (widget.formFactor != AppFormFactor.desktop) {
      AppBottomSheet.show(
        context: context,
        padding: EdgeInsets.zero,
        builder: (ctx) => SafeArea(
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Padding(
                  padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                  child: Text(
                    l10n.fieldDurationRequiredLabel.replaceAll(' *', ''),
                    style: Theme.of(ctx).textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
                const Divider(height: 1),
                ...durations.map(
                  (d) => ListTile(
                    title: Text(_formatExtraDuration(d)),
                    trailing: d == currentDuration
                        ? Icon(
                            Icons.check,
                            color: Theme.of(ctx).colorScheme.primary,
                          )
                        : null,
                    onTap: () {
                      Navigator.of(ctx).pop();
                      widget.onDurationChanged(d);
                    },
                  ),
                ),
              ],
            ),
          ),
        ),
      );
    } else {
      showDialog<void>(
        context: context,
        builder: (ctx) => AlertDialog(
          title: Text(l10n.fieldDurationRequiredLabel.replaceAll(' *', '')),
          content: SizedBox(
            width: 320,
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: durations.length,
              itemBuilder: (_, index) {
                final d = durations[index];
                return ListTile(
                  title: Text(_formatExtraDuration(d)),
                  trailing: d == currentDuration
                      ? Icon(
                          Icons.check,
                          color: Theme.of(ctx).colorScheme.primary,
                        )
                      : null,
                  onTap: () {
                    Navigator.of(ctx).pop();
                    widget.onDurationChanged(d);
                  },
                );
              },
            ),
          ),
        ),
      );
    }
  }
}

/// Widget per mostrare un campo durata cliccabile
class _DurationField extends StatelessWidget {
  const _DurationField({
    required this.label,
    required this.durationMinutes,
    required this.onTap,
    required this.theme,
  });

  final String label;
  final int durationMinutes;
  final VoidCallback? onTap;
  final ThemeData theme;

  @override
  Widget build(BuildContext context) {
    String formatted;
    if (durationMinutes < 60) {
      formatted = '$durationMinutes min';
    } else {
      final hours = durationMinutes ~/ 60;
      final mins = durationMinutes % 60;
      if (mins == 0) {
        formatted = '${hours}h';
      } else {
        formatted = '${hours}h ${mins}m';
      }
    }

    final isDisabled = onTap == null;
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(4),
      child: InputDecorator(
        decoration: InputDecoration(
          labelText: label,
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 10,
            vertical: 10,
          ),
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(4)),
          isDense: true,
          enabled: !isDisabled,
        ),
        child: Text(
          formatted,
          style: theme.textTheme.bodyMedium?.copyWith(
            color: isDisabled
                ? theme.colorScheme.onSurface.withOpacity(0.5)
                : null,
          ),
        ),
      ),
    );
  }
}

class _TimeGridPicker extends StatefulWidget {
  const _TimeGridPicker({
    required this.initial,
    this.includeTime,
    required this.stepMinutes,
    required this.title,
    this.useSafeArea = true,
  });

  final TimeOfDay initial;
  final TimeOfDay? includeTime;
  final int stepMinutes;
  final String title;
  final bool useSafeArea;

  @override
  State<_TimeGridPicker> createState() => _TimeGridPickerState();
}

class _TimeGridPickerState extends State<_TimeGridPicker> {
  late final ScrollController _scrollController;
  late final List<TimeOfDay?> _entries;
  late final int _scrollToIndex;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();

    _entries = <TimeOfDay?>[];
    for (int m = 0; m < LayoutConfig.hoursInDay * 60; m += widget.stepMinutes) {
      final h = m ~/ 60;
      final mm = m % 60;
      _entries.add(TimeOfDay(hour: h, minute: mm));
    }

    _scrollToIndex = _ensureTimeInEntries(widget.initial);
    if (widget.includeTime != null &&
        !_isSameTime(widget.includeTime!, widget.initial)) {
      _ensureTimeInEntries(widget.includeTime!);
    }

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _scrollToSelected();
    });
  }

  bool _isSameTime(TimeOfDay a, TimeOfDay b) =>
      a.hour == b.hour && a.minute == b.minute;

  int _ensureTimeInEntries(TimeOfDay time) {
    final existingIndex = _entries.indexWhere(
      (t) => t != null && _isSameTime(t, time),
    );
    if (existingIndex >= 0) {
      return existingIndex;
    }

    final columnsPerRow = 60 ~/ widget.stepMinutes;
    final targetColumn = time.minute ~/ widget.stepMinutes;
    final baseIndex = (time.hour + 1) * columnsPerRow;

    final newRow = List<TimeOfDay?>.filled(columnsPerRow, null);
    newRow[targetColumn] = time;

    final insertIndex = baseIndex.clamp(0, _entries.length);
    _entries.insertAll(insertIndex, newRow);
    return insertIndex + targetColumn;
  }

  void _scrollToSelected() {
    if (!_scrollController.hasClients) return;

    const crossAxisCount = 4;
    const mainAxisSpacing = 6.0;
    const childAspectRatio = 2.7;
    const padding = 12.0;

    final screenWidth = MediaQuery.of(context).size.width;
    final availableWidth = screenWidth - padding * 2;
    final itemWidth =
        (availableWidth - (crossAxisCount - 1) * 6) / crossAxisCount;
    final itemHeight = itemWidth / childAspectRatio;
    final rowHeight = itemHeight + mainAxisSpacing;

    final targetRow = _scrollToIndex ~/ crossAxisCount;

    final viewportHeight = _scrollController.position.viewportDimension;
    const headerOffset = 40.0;
    final targetOffset =
        (targetRow * rowHeight) -
        (viewportHeight / 2) +
        (rowHeight / 2) +
        headerOffset;

    final maxScroll = _scrollController.position.maxScrollExtent;
    final clampedOffset = targetOffset.clamp(0.0, maxScroll);

    _scrollController.animateTo(
      clampedOffset,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeOut,
    );
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final content = Padding(
      padding: const EdgeInsets.all(12),
      child: Column(
        mainAxisSize: MainAxisSize.max,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              const Icon(Icons.schedule, size: 18),
              const SizedBox(width: 8),
              Text(
                widget.title,
                style: const TextStyle(fontWeight: FontWeight.w700),
              ),
            ],
          ),
          const SizedBox(height: 10),
          Expanded(
            child: GridView.builder(
              controller: _scrollController,
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 4,
                mainAxisSpacing: 6,
                crossAxisSpacing: 6,
                childAspectRatio: 2.7,
              ),
              itemCount: _entries.length,
              itemBuilder: (context, index) {
                final t = _entries[index];
                if (t == null) {
                  return const SizedBox.shrink();
                }
                final isSelected = index == _scrollToIndex;
                return OutlinedButton(
                  style: OutlinedButton.styleFrom(
                    backgroundColor: isSelected
                        ? Theme.of(context).colorScheme.primary.withOpacity(0.1)
                        : null,
                    side: BorderSide(
                      color: isSelected
                          ? Theme.of(context).colorScheme.primary
                          : Theme.of(context).dividerColor,
                    ),
                    padding: const EdgeInsets.symmetric(horizontal: 8),
                  ),
                  onPressed: () => Navigator.pop(context, t),
                  child: Text(DtFmt.hm(context, t.hour, t.minute)),
                );
              },
            ),
          ),
        ],
      ),
    );

    if (!widget.useSafeArea) {
      return content;
    }
    return SafeArea(child: content);
  }
}

class _StaffPickerContent extends StatelessWidget {
  const _StaffPickerContent({
    required this.staff,
    required this.selectedId,
    required this.onSelected,
  });

  final List<Staff> staff;
  final int? selectedId;
  final ValueChanged<int> onSelected;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    if (staff.isEmpty) {
      return Padding(
        padding: const EdgeInsets.all(24),
        child: Center(
          child: Text(
            l10n.noStaffAvailable,
            style: theme.textTheme.bodyMedium?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
        ),
      );
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        for (final member in staff)
          ListTile(
            leading: StaffCircleAvatar(
              height: 36,
              color: member.color,
              isHighlighted: member.id == selectedId,
              initials: member.initials,
            ),
            title: Text('${member.name} ${member.surname}'.trim()),
            trailing: member.id == selectedId
                ? Icon(Icons.check, color: theme.colorScheme.primary)
                : null,
            selected: member.id == selectedId,
            onTap: () => onSelected(member.id),
          ),
      ],
    );
  }
}
--- FILE: lib/features/agenda/presentation/widgets/agenda_top_controls.dart ---
import 'package:agenda_backend/app/widgets/top_controls.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class AgendaTopControls extends ConsumerWidget {
  const AgendaTopControls({super.key, this.compact = false});

  final bool compact;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return TopControls.agenda(compact: compact);
  }
}
--- FILE: lib/features/agenda/presentation/widgets/booking_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:agenda_backend/core/l10n/date_time_formats.dart';
import 'package:agenda_backend/core/models/appointment.dart';
import 'package:agenda_backend/core/widgets/labeled_form_field.dart';
import 'package:agenda_backend/core/widgets/no_scrollbar_behavior.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/booking.dart';
import '../../../../core/models/service_variant.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../clients/domain/clients.dart';
import '../../../clients/presentation/dialogs/client_edit_dialog.dart';
import '../../../clients/providers/clients_providers.dart';
import '../../../services/providers/service_categories_provider.dart';
import '../../../services/providers/services_provider.dart';
import '../../data/bookings_api.dart';
import '../../domain/service_item_data.dart';
import '../../providers/agenda_scroll_request_provider.dart';
import '../../providers/appointment_providers.dart';
import '../../providers/bookings_provider.dart';
import '../../providers/bookings_repository_provider.dart';
import '../../providers/business_providers.dart';
import '../../providers/date_range_provider.dart';
import '../../providers/layout_config_provider.dart';
import '../../providers/location_providers.dart';
import '../../providers/staff_slot_availability_provider.dart';
import 'service_item_card.dart';

/// Show the Booking dialog for creating a new multi-service booking.
Future<void> showBookingDialog(
  BuildContext context,
  WidgetRef ref, {
  Booking? existing,
  DateTime? date,
  TimeOfDay? time,
  int? initialStaffId,
  bool autoOpenDatePicker = false,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final presentation = formFactor == AppFormFactor.desktop
      ? _BookingPresentation.dialog
      : _BookingPresentation.bottomSheet;

  final content = _BookingDialog(
    existing: existing,
    initialDate: date,
    initialTime: time,
    initialStaffId: initialStaffId,
    autoOpenDatePicker: autoOpenDatePicker,
    presentation: presentation,
  );

  if (presentation == _BookingPresentation.dialog) {
    await showDialog(
      context: context,
      builder: (_) => content,
      barrierDismissible: false,
    );
  } else {
    await AppBottomSheet.show(
      context: context,
      useRootNavigator: true,
      padding: const EdgeInsets.symmetric(horizontal: 0, vertical: 16),
      builder: (_) => content,
      heightFactor: AppBottomSheet.defaultHeightFactor,
    );
  }
}

enum _BookingPresentation { dialog, bottomSheet }

class _BookingDialog extends ConsumerStatefulWidget {
  const _BookingDialog({
    this.existing,
    this.initialDate,
    this.initialTime,
    this.initialStaffId,
    this.autoOpenDatePicker = false,
    required this.presentation,
  });

  final Booking? existing;
  final DateTime? initialDate;
  final TimeOfDay? initialTime;
  final int? initialStaffId;
  final bool autoOpenDatePicker;
  final _BookingPresentation presentation;

  @override
  ConsumerState<_BookingDialog> createState() => _BookingDialogState();
}

class _BookingDialogState extends ConsumerState<_BookingDialog> {
  final _formKey = GlobalKey<FormState>();
  final _notesController = TextEditingController();
  final ScrollController _scrollController = ScrollController();

  late DateTime _date;
  int? _clientId;

  bool _clientPickerAutoRequested = false;
  int? _autoOpenServicePickerIndex;
  bool _shouldAutoOpenServicePicker = false;
  bool _datePickerAutoRequested = false;

  /// Nome cliente personalizzato (usato solo per clienti nuovi non ancora salvati)
  String _customClientName = '';

  /// Lista di servizi nella prenotazione
  final List<ServiceItemData> _serviceItems = [];

  /// Contatore per generare chiavi univoche
  int _itemKeyCounter = 0;

  bool _warningDismissed = false;

  @override
  void initState() {
    super.initState();
    final agendaDate = ref.read(agendaDateProvider);

    if (widget.existing != null) {
      // Editing existing booking
      _date = DateUtils.dateOnly(widget.initialDate ?? agendaDate);
      _notesController.text = widget.existing!.notes ?? '';
      _clientId = widget.existing!.clientId;
      _customClientName = widget.existing!.clientName ?? '';

      // Load existing appointments into _serviceItems
      final bookingAppointments = ref
          .read(appointmentsProvider.notifier)
          .getByBookingId(widget.existing!.id);

      for (final appointment in bookingAppointments) {
        final baseDuration = _baseDurationFromAppointment(appointment);
        final blockedExtraMinutes = appointment.blockedExtraMinutes;
        final processingExtraMinutes = appointment.processingExtraMinutes;
        _serviceItems.add(
          ServiceItemData(
            key: _nextItemKey(),
            startTime: TimeOfDay.fromDateTime(appointment.startTime),
            staffId: appointment.staffId,
            serviceId: appointment.serviceId,
            serviceVariantId: appointment.serviceVariantId,
            durationMinutes: baseDuration,
            blockedExtraMinutes: blockedExtraMinutes,
            processingExtraMinutes: processingExtraMinutes,
          ),
        );
      }

      // Se non ci sono appointments, aggiungi un item vuoto
      if (_serviceItems.isEmpty) {
        final initialTime =
            widget.initialTime ?? const TimeOfDay(hour: 10, minute: 0);
        _serviceItems.add(
          ServiceItemData(key: _nextItemKey(), startTime: initialTime),
        );
      }
    } else {
      _date = DateUtils.dateOnly(widget.initialDate ?? agendaDate);

      // Aggiungi un primo servizio vuoto
      final initialTime =
          widget.initialTime ?? const TimeOfDay(hour: 10, minute: 0);
      _serviceItems.add(
        ServiceItemData(
          key: _nextItemKey(),
          startTime: initialTime,
          staffId: widget.initialStaffId,
        ),
      );
    }

    if (widget.existing == null) {
      WidgetsBinding.instance.addPostFrameCallback((_) async {
        if (!mounted) return;
        if (widget.autoOpenDatePicker) {
          await _scheduleAutoDatePicker();
        }
        if (!mounted) return;
        _scheduleAutoClientPicker();
      });
    }
  }

  @override
  void dispose() {
    _notesController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  int _baseDurationFromAppointment(Appointment appointment) {
    final totalMinutes = appointment.endTime
        .difference(appointment.startTime)
        .inMinutes;
    final extraMinutes = appointment.blockedExtraMinutes;
    final base = totalMinutes - extraMinutes;
    return base > 0 ? base : 0;
  }

  String _nextItemKey() => 'item_${_itemKeyCounter++}';

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final isEdit = widget.existing != null;
    final isDialog = widget.presentation == _BookingPresentation.dialog;

    final formFactor = ref.watch(formFactorProvider);
    final services = ref.watch(servicesProvider).value ?? [];
    final serviceCategories = ref.watch(serviceCategoriesProvider);
    final variants = ref.watch(serviceVariantsProvider).value ?? [];
    final asyncClients = ref.watch(clientsProvider);
    final clients = asyncClients.value ?? [];
    final clientsById = ref.watch(clientsByIdProvider);
    final allStaff = ref.watch(staffForCurrentLocationProvider);

    // Deriva il nome del cliente dal provider se _clientId √® impostato,
    // altrimenti usa il nome personalizzato (per clienti nuovi)
    final clientName = _clientId != null
        ? (clientsById[_clientId]?.name ?? _customClientName)
        : _customClientName;

    final title = isEdit
        ? l10n.appointmentDialogTitleEdit
        : l10n.appointmentDialogTitleNew;

    final isDesktop = widget.presentation == _BookingPresentation.dialog;
    final conflictFlags = _serviceConflictFlags();
    final eligibleIndices = <int>[];
    for (int i = 0; i < _serviceItems.length; i++) {
      if (_isWarningEligible(_serviceItems[i])) {
        eligibleIndices.add(i);
      }
    }
    final allEligibleConflict =
        eligibleIndices.isNotEmpty &&
        eligibleIndices.every((i) => conflictFlags[i]);
    final showAppointmentWarning =
        eligibleIndices.length > 1 && allEligibleConflict;
    final showServiceWarnings = !showAppointmentWarning;
    final content = Form(
      key: _formKey,
      child: ConstrainedBox(
        // Su desktop, limita la larghezza del form. Su mobile, usa tutta la larghezza.
        constraints: BoxConstraints(
          maxWidth: isDesktop ? 340 : double.infinity,
        ),
        child: ScrollConfiguration(
          behavior: const NoScrollbarBehavior(),
          child: SingleChildScrollView(
            controller: _scrollController,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                const SizedBox(height: AppSpacing.formFirstRowSpacing),

                // Client selection
                _ClientSelectionField(
                  clientId: _clientId,
                  clientName: clientName,
                  clients: clients,
                  onClientSelected: (id, name) {
                    setState(() {
                      _clientId = id;
                      _customClientName = name;
                    });
                  },
                  onClientRemoved: () {
                    setState(() {
                      _clientId = null;
                      _customClientName = '';
                    });
                  },
                  onOpenPicker: _openClientPicker,
                ),
                const SizedBox(height: AppSpacing.formRowSpacing),

                // Date and Time selector (row)
                LabeledFormField(
                  label: l10n.formDate,
                  child: InkWell(
                    onTap: _pickDate,
                    borderRadius: BorderRadius.circular(8),
                    child: InputDecorator(
                      decoration: const InputDecoration(
                        border: OutlineInputBorder(),
                        isDense: true,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(DtFmt.shortDate(context, _date)),
                          const Icon(Icons.calendar_today, size: 16),
                        ],
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: AppSpacing.formRowSpacing),

                // Services section header
                // Services list
                ..._buildServiceItems(
                  services: services,
                  categories: serviceCategories,
                  variants: variants,
                  allStaff: allStaff,
                  formFactor: formFactor,
                  conflictFlags: conflictFlags,
                  showServiceWarnings: showServiceWarnings,
                  serviceWarningMessage:
                      l10n.bookingUnavailableTimeWarningService,
                ),

                const SizedBox(height: AppSpacing.formRowSpacing),

                // Notes field
                LabeledFormField(
                  label: l10n.formNotes,
                  child: TextField(
                    controller: _notesController,
                    decoration: InputDecoration(
                      hintText: l10n.notesPlaceholder,
                      border: const OutlineInputBorder(),
                      isDense: true,
                    ),
                    maxLines: 2,
                    textCapitalization: TextCapitalization.sentences,
                  ),
                ),
                const SizedBox(height: AppSpacing.formRowSpacing),
              ],
            ),
          ),
        ),
      ),
    );

    final actions = [
      AppOutlinedActionButton(
        onPressed: () => Navigator.of(context).pop(),
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppFilledButton(
        onPressed: _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionSave),
      ),
    ];

    if (isDialog) {
      return DismissibleDialog(
        child: Dialog(
          insetPadding: const EdgeInsets.symmetric(
            horizontal: 32,
            vertical: 24,
          ),
          child: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text(title, style: Theme.of(context).textTheme.headlineSmall),
                  const SizedBox(height: 8),
                  Flexible(child: content),
                  const SizedBox(height: AppSpacing.formToActionsSpacing),
                  Padding(
                    padding: const EdgeInsets.only(
                      bottom: AppSpacing.formFirstRowSpacing,
                    ),
                    child: _warningBanner(
                      20,
                      showAppointmentWarning,
                      l10n.bookingUnavailableTimeWarningAppointment,
                    ),
                  ),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      for (int i = 0; i < actions.length; i++) ...[
                        if (i > 0) const SizedBox(width: 8),
                        SizedBox(
                          width: AppButtonStyles.dialogButtonWidth,
                          child: actions[i],
                        ),
                      ],
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      );
    }

    // Bottom sheet layout
    const horizontalPadding = 20.0;
    final titlePadding = EdgeInsets.fromLTRB(
      horizontalPadding,
      0,
      horizontalPadding,
      12,
    );

    final isKeyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
    return SafeArea(
      top: false,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        mainAxisSize: MainAxisSize.min,
        children: [
          Padding(
            padding: titlePadding,
            child: Text(title, style: Theme.of(context).textTheme.titleLarge),
          ),
          Expanded(
            child: Padding(
              padding: EdgeInsets.symmetric(horizontal: horizontalPadding),
              child: content,
            ),
          ),
          _warningBanner(
            horizontalPadding,
            showAppointmentWarning,
            l10n.bookingUnavailableTimeWarningAppointment,
          ),
          if (!isKeyboardOpen) ...[
            const AppBottomSheetDivider(),
            Padding(
              padding: EdgeInsets.fromLTRB(
                horizontalPadding,
                AppSpacing.formFirstRowSpacing,
                horizontalPadding,
                0,
              ),
              child: Row(
                mainAxisAlignment: actions.length == 3
                    ? MainAxisAlignment.center
                    : MainAxisAlignment.end,
                children: [
                  for (int i = 0; i < actions.length; i++) ...[
                    if (i > 0) const SizedBox(width: 8),
                    SizedBox(
                      width: AppButtonStyles.dialogButtonWidth,
                      child: actions[i],
                    ),
                  ],
                ],
              ),
            ),
          ],

          SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
        ],
      ),
    );
  }

  List<Widget> _buildServiceItems({
    required List<dynamic> services,
    required List<dynamic> categories,
    required List<dynamic> variants,
    required List<dynamic> allStaff,
    required AppFormFactor formFactor,
    required List<bool> conflictFlags,
    required bool showServiceWarnings,
    required String serviceWarningMessage,
  }) {
    final widgets = <Widget>[];

    // Conta servizi effettivamente selezionati
    final selectedCount = _serviceItems
        .where((s) => s.serviceId != null)
        .length;

    for (int i = 0; i < _serviceItems.length; i++) {
      final item = _serviceItems[i];
      final TimeOfDay? suggestedStartTime = i > 0
          ? _resolveServiceEndTime(_serviceItems[i - 1], variants.cast())
          : null;
      final variant = item.serviceId != null
          ? variants.cast<ServiceVariant?>().firstWhere(
              (v) => v?.serviceId == item.serviceId,
              orElse: () => null,
            )
          : null;
      final defaultProcessing = variant?.processingTime ?? 0;
      final defaultBlocked = variant?.blockedTime ?? 0;
      final defaultExtraType = defaultBlocked > 0
          ? ExtraMinutesType.blocked
          : (defaultProcessing > 0 ? ExtraMinutesType.processing : null);
      final hasBlockedExtra = item.blockedExtraMinutes > 0;
      final hasProcessingExtra = item.processingExtraMinutes > 0;
      final canAddDefaultExtra = defaultExtraType == ExtraMinutesType.blocked
          ? !hasBlockedExtra
          : (defaultExtraType == ExtraMinutesType.processing
                ? !hasProcessingExtra
                : false);
      final showWarning =
          showServiceWarnings &&
          _isWarningEligible(item) &&
          i < conflictFlags.length &&
          conflictFlags[i];

      // Get eligible staff for this service
      final eligibleStaffIds = item.serviceId != null
          ? ref.watch(eligibleStaffForServiceProvider(item.serviceId!))
          : <int>[];
      final isStaffIneligible =
          item.serviceId != null &&
          item.staffId != null &&
          !eligibleStaffIds.contains(item.staffId);

      final isFirst = i == 0;
      final isLast = i == _serviceItems.length - 1;
      widgets.add(
        Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            if (isFirst) ...[
              Row(
                children: [
                  Text(
                    selectedCount > 0
                        ? context.l10n.servicesSelectedCount(selectedCount)
                        : context.l10n.formServices,
                    style: const TextStyle(fontWeight: FontWeight.w600),
                  ),
                ],
              ),
              const SizedBox(height: 8),
            ],
            Padding(
              padding: const EdgeInsets.only(bottom: 12),
              child: ServiceItemCard(
                index: i,
                item: item,
                services: services.cast(),
                categories: categories.cast(),
                variants: variants.cast(),
                eligibleStaff: eligibleStaffIds,
                allStaff: allStaff.cast(),
                formFactor: formFactor,
                canRemove: _serviceItems.length > 1,
                // Obbligatorio solo se non ci sono altri servizi selezionati
                isServiceRequired: selectedCount == 0,
                onChanged: (updated) => _updateServiceItem(i, updated),
                onRemove: () => _removeServiceItem(i),
                onStartTimeChanged: (time) => _updateServiceStartTime(i, time),
                onEndTimeChanged: (time) => _updateServiceEndTime(i, time),
                onDurationChanged: (duration) =>
                    _updateServiceDuration(i, duration),
                suggestedStartTime: suggestedStartTime,
                autoOpenServicePicker:
                    (_shouldAutoOpenServicePicker && i == 0) ||
                    _autoOpenServicePickerIndex == i,
                onServicePickerAutoOpened:
                    (_shouldAutoOpenServicePicker && i == 0) ||
                        _autoOpenServicePickerIndex == i
                    ? () {
                        if (_shouldAutoOpenServicePicker && i == 0) {
                          _onServicePickerAutoOpened();
                        }
                        _onServicePickerAutoOpenedForIndex(i);
                      }
                    : null,
                onServicePickerAutoCompleted: _scrollFormToBottom,
                onAutoOpenStaffPickerCompleted: _scrollFormToBottom,
                availabilityWarningMessage: showWarning
                    ? serviceWarningMessage
                    : null,
                staffEligibilityWarningMessage: isStaffIneligible
                    ? context.l10n.bookingStaffNotEligibleWarning
                    : null,
              ),
            ),
            if (canAddDefaultExtra) ...[
              if (isLast && item.serviceId != null)
                Row(
                  children: [
                    AppOutlinedActionButton(
                      onPressed: () {
                        setState(() {
                          _serviceItems[i] =
                              defaultExtraType == ExtraMinutesType.blocked
                              ? _serviceItems[i].copyWith(
                                  blockedExtraMinutes: defaultBlocked,
                                )
                              : _serviceItems[i].copyWith(
                                  processingExtraMinutes: defaultProcessing,
                                );
                          _recalculateTimesFrom(i + 1, variants.cast());
                        });
                      },
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.add, size: 18),
                          const SizedBox(width: 8),
                          Text(context.l10n.additionalTimeSwitch),
                        ],
                      ),
                    ),
                    const Spacer(),
                    AppOutlinedActionButton(
                      onPressed: _addService,
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.add, size: 18),
                          const SizedBox(width: 8),
                          Text(context.l10n.addService),
                        ],
                      ),
                    ),
                  ],
                )
              else
                Align(
                  alignment: Alignment.centerRight,
                  child: AppOutlinedActionButton(
                    onPressed: () {
                      setState(() {
                        _serviceItems[i] =
                            defaultExtraType == ExtraMinutesType.blocked
                            ? _serviceItems[i].copyWith(
                                blockedExtraMinutes: defaultBlocked,
                              )
                            : _serviceItems[i].copyWith(
                                processingExtraMinutes: defaultProcessing,
                              );
                        _recalculateTimesFrom(i + 1, variants.cast());
                      });
                    },
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const Icon(Icons.add, size: 18),
                        const SizedBox(width: 8),
                        Text(context.l10n.additionalTimeSwitch),
                      ],
                    ),
                  ),
                ),
              const SizedBox(height: 16),
            ],
            if (hasBlockedExtra) ...[
              ExtraTimeCard(
                title: context.l10n.fieldBlockedTimeLabel,
                startTime: _baseEndTime(item, variants.cast()),
                durationMinutes: item.blockedExtraMinutes,
                formFactor: formFactor,
                onStartTimeChanged: (_) {},
                onDurationChanged: (duration) {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      blockedExtraMinutes: duration,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                  });
                },
                onRemove: () {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      blockedExtraMinutes: 0,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                  });
                },
              ),
              const SizedBox(height: 8),
            ],
            if (hasProcessingExtra) ...[
              ExtraTimeCard(
                title: context.l10n.fieldProcessingTimeLabel,
                startTime: _addMinutes(
                  _baseEndTime(item, variants.cast()),
                  item.blockedExtraMinutes,
                ),
                durationMinutes: item.processingExtraMinutes,
                formFactor: formFactor,
                onStartTimeChanged: (_) {},
                onDurationChanged: (duration) {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      processingExtraMinutes: duration,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                  });
                },
                onRemove: () {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      processingExtraMinutes: 0,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                  });
                },
              ),
              const SizedBox(height: 8),
            ],
            if (isLast && item.serviceId != null && !canAddDefaultExtra) ...[
              Align(
                alignment: Alignment.centerRight,
                child: AppOutlinedActionButton(
                  onPressed: _addService,
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      const Icon(Icons.add, size: 18),
                      const SizedBox(width: 8),
                      Text(context.l10n.addService),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 8),
            ],
          ],
        ),
      );
    }

    if (_serviceItems.isEmpty) {
      widgets.add(
        Container(
          padding: const EdgeInsets.all(24),
          decoration: BoxDecoration(
            border: Border.all(color: Theme.of(context).colorScheme.outline),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Center(
            child: Text(
              context.l10n.noServicesAdded,
              style: TextStyle(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ),
        ),
      );
    }

    return widgets;
  }

  Widget _warningBanner(
    double horizontalPadding,
    bool hasConflicts,
    String message,
  ) {
    if (!hasConflicts || _warningDismissed) return const SizedBox.shrink();
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.amber.withOpacity(0.18),
        borderRadius: BorderRadius.circular(8),
      ),
      padding: EdgeInsets.fromLTRB(
        horizontalPadding,
        12,
        horizontalPadding,
        12,
      ),
      child: Row(
        children: [
          const Icon(
            Icons.warning_amber_rounded,
            color: Colors.amber,
            size: 20,
          ),
          const SizedBox(width: 10),
          Expanded(
            child: Text(
              message,
              style: const TextStyle(
                color: Color(0xFF8A4D00),
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          IconButton(
            icon: const Icon(Icons.close, size: 18),
            color: const Color(0xFF8A4D00),
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints.tightFor(width: 32, height: 32),
            onPressed: () {
              setState(() => _warningDismissed = true);
            },
          ),
        ],
      ),
    );
  }

  bool _isWarningEligible(ServiceItemData item) {
    return item.serviceId != null && item.staffId != null;
  }

  List<bool> _serviceConflictFlags() {
    final layout = ref.watch(layoutConfigProvider);
    final Map<int, Set<int>> cache = {};
    final flags = <bool>[];

    for (final item in _serviceItems) {
      final staffId = item.staffId;
      if (staffId == null || item.serviceId == null) {
        flags.add(false);
        continue;
      }

      final available = cache.putIfAbsent(
        staffId,
        () => ref.watch(staffSlotAvailabilityProvider(staffId)),
      );

      if (available.isEmpty) {
        flags.add(true);
        continue;
      }

      final startMinutes = item.startTime.hour * 60 + item.startTime.minute;
      final endMinutes = startMinutes + item.durationMinutes;
      final startSlot = startMinutes ~/ layout.minutesPerSlot;
      final endSlot = (endMinutes / layout.minutesPerSlot).ceil();

      var hasConflict = false;
      for (int slot = startSlot; slot < endSlot; slot++) {
        if (!available.contains(slot)) {
          hasConflict = true;
          break;
        }
      }
      flags.add(hasConflict);
    }
    return flags;
  }

  void _scheduleAutoClientPicker() {
    if (_clientPickerAutoRequested) return;
    _clientPickerAutoRequested = true;
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      _openClientPicker(triggerServiceAutoOpen: true);
    });
  }

  Future<void> _scheduleAutoDatePicker() async {
    if (_datePickerAutoRequested) return;
    _datePickerAutoRequested = true;
    await _pickDate();
  }

  Future<void> _openClientPicker({bool triggerServiceAutoOpen = false}) async {
    final formFactor = ref.read(formFactorProvider);
    final isDesktop = formFactor == AppFormFactor.desktop;
    bool dismissed = false;

    while (mounted) {
      if (!mounted) return;
      final asyncClients = ref.read(clientsProvider);
      final clients = asyncClients.value ?? [];
      _ClientItem? result;
      if (isDesktop) {
        result = await showDialog<_ClientItem?>(
          context: context,
          builder: (ctx) => Dialog(
            insetPadding: const EdgeInsets.symmetric(
              horizontal: 32,
              vertical: 24,
            ),
            child: ConstrainedBox(
              constraints: const BoxConstraints(
                minWidth: 600,
                maxWidth: 720,
                maxHeight: 600,
              ),
              child: _ClientPickerSheet(
                clients: clients,
                selectedClientId: _clientId,
              ),
            ),
          ),
        );
      } else {
        result = await AppBottomSheet.show<_ClientItem?>(
          context: context,
          useRootNavigator: true,
          padding: EdgeInsets.zero,
          heightFactor: AppBottomSheet.defaultHeightFactor,
          builder: (ctx) =>
              _ClientPickerSheet(clients: clients, selectedClientId: _clientId),
        );
      }

      if (result == null) {
        dismissed = true;
        break;
      }
      final selectedResult = result;
      if (selectedResult.id == -2) {
        if (!mounted) return;
        Client? initialClient;
        if (selectedResult.name.isNotEmpty) {
          final nameParts = Client.splitFullName(selectedResult.name);
          // NON passare businessId: lasciare che ClientForm usi currentBusinessProvider
          initialClient = Client(
            id: 0,
            businessId: ref.read(currentBusinessProvider).id,
            firstName: nameParts.firstName,
            lastName: nameParts.lastName,
            createdAt: DateTime.now(),
          );
        }
        final newClient = await showClientEditDialog(
          context,
          ref,
          client: initialClient,
        );
        if (newClient != null) {
          setState(() {
            _clientId = newClient.id;
            _customClientName = newClient.name;
          });
          break;
        }
        continue;
      } else if (selectedResult.id == -1) {
        setState(() {
          _clientId = null;
          _customClientName = '';
        });
        break;
      } else {
        setState(() {
          _clientId = selectedResult.id;
          _customClientName = selectedResult.name;
        });
        break;
      }
    }

    if (!mounted) return;
    if (triggerServiceAutoOpen && !dismissed) {
      setState(() {
        _shouldAutoOpenServicePicker = true;
      });
    }
  }

  void _onServicePickerAutoOpened() {
    if (!_shouldAutoOpenServicePicker) return;
    setState(() {
      _shouldAutoOpenServicePicker = false;
    });
  }

  void _onServicePickerAutoOpenedForIndex(int index) {
    if (_autoOpenServicePickerIndex != index) return;
    setState(() {
      _autoOpenServicePickerIndex = null;
    });
  }

  void _addService() {
    final variants = ref.read(serviceVariantsProvider).value ?? [];
    // Calcola l'orario di inizio per il nuovo servizio
    TimeOfDay nextStart;
    if (_serviceItems.isEmpty) {
      nextStart = widget.initialTime ?? const TimeOfDay(hour: 10, minute: 0);
    } else {
      // Prendi l'ultimo servizio e calcola il suo orario di fine
      final lastItem = _serviceItems.last;
      nextStart = _resolveServiceEndTime(lastItem, variants);
    }

    // Smart staff selection:
    // 1. Try initial staff if eligible
    // 2. Leave null for user selection
    int? smartStaffId = widget.initialStaffId;

    final newIndex = _serviceItems.length;
    setState(() {
      _serviceItems.add(
        ServiceItemData(
          key: _nextItemKey(),
          startTime: nextStart,
          staffId: smartStaffId,
        ),
      );
      _autoOpenServicePickerIndex = newIndex;
    });
  }

  void _removeServiceItem(int index) {
    if (_serviceItems.length <= 1) return;

    final variants = ref.read(serviceVariantsProvider).value ?? [];

    setState(() {
      _serviceItems.removeAt(index);

      // Ricalcola gli orari per i servizi successivi
      _recalculateTimesFrom(index, variants);
    });
  }

  void _updateServiceItem(int index, ServiceItemData updated) {
    final variants = ref.read(serviceVariantsProvider).value ?? [];

    setState(() {
      _serviceItems[index] = updated;

      // Se cambia il servizio, potremmo dover aggiornare lo staff
      // e ricalcolare gli orari successivi
      _recalculateTimesFrom(index + 1, variants);

      // Se lo staff √® ancora null, seleziona automaticamente un eligible
      if (updated.serviceId != null && updated.staffId == null) {
        final newStaffId = _findBestStaff(updated.serviceId!);
        _serviceItems[index] = updated.copyWith(staffId: newStaffId);
      }
    });
  }

  void _updateServiceStartTime(int index, TimeOfDay newTime) {
    final variants = ref.read(serviceVariantsProvider).value ?? [];

    setState(() {
      final updated = _serviceItems[index].copyWith(startTime: newTime);
      _serviceItems[index] = _applyAutoExtraStart(updated, variants);

      // Ricalcola gli orari per i servizi successivi
      _recalculateTimesFrom(index + 1, variants);
    });
  }

  void _updateServiceEndTime(int index, TimeOfDay newEndTime) {
    setState(() {
      final item = _serviceItems[index];

      // Calcola la nuova durata basata sulla differenza tra end e start
      final startMinutes = item.startTime.hour * 60 + item.startTime.minute;
      final endMinutes = newEndTime.hour * 60 + newEndTime.minute;
      var newDuration = endMinutes - startMinutes;

      // Se la durata √® negativa o zero, imposta un minimo di 15 minuti
      if (newDuration <= 0) {
        newDuration = 15;
      }

      _serviceItems[index] = item.copyWith(durationMinutes: newDuration);

      // Ricalcola gli orari per i servizi successivi
      final variants = ref.read(serviceVariantsProvider).value ?? [];
      _serviceItems[index] = _applyAutoExtraStart(
        _serviceItems[index],
        variants,
      );
      _recalculateTimesFrom(index + 1, variants);
    });
  }

  void _updateServiceDuration(int index, int newDuration) {
    setState(() {
      _serviceItems[index] = _serviceItems[index].copyWith(
        durationMinutes: newDuration,
      );

      // Ricalcola gli orari per i servizi successivi
      final variants = ref.read(serviceVariantsProvider).value ?? [];
      _serviceItems[index] = _applyAutoExtraStart(
        _serviceItems[index],
        variants,
      );
      _recalculateTimesFrom(index + 1, variants);
    });
  }

  void _recalculateTimesFrom(int fromIndex, List<ServiceVariant> variants) {
    if (fromIndex <= 0 || fromIndex >= _serviceItems.length) return;

    for (int i = fromIndex; i < _serviceItems.length; i++) {
      final prevItem = _serviceItems[i - 1];
      final prevEnd = _resolveServiceEndTime(prevItem, variants);
      final updated = _serviceItems[i].copyWith(startTime: prevEnd);
      _serviceItems[i] = _applyAutoExtraStart(updated, variants);
    }
  }

  TimeOfDay _resolveServiceEndTime(
    ServiceItemData item,
    List<ServiceVariant> variants,
  ) {
    final baseEnd = _baseEndTime(item, variants);
    if (item.blockedExtraMinutes <= 0) {
      return baseEnd;
    }
    return _addMinutes(baseEnd, item.blockedExtraMinutes);
  }

  ServiceItemData _applyAutoExtraStart(
    ServiceItemData item,
    List<ServiceVariant> variants,
  ) {
    return item;
  }

  TimeOfDay _baseEndTime(ServiceItemData item, List<ServiceVariant> variants) {
    final variant = _variantForItem(item, variants);
    final baseDuration = item.durationMinutes > 0
        ? item.durationMinutes
        : (variant?.durationMinutes ?? 30);
    return item.getEndTime(baseDuration);
  }

  ServiceVariant? _variantForItem(
    ServiceItemData item,
    List<ServiceVariant> variants,
  ) {
    if (item.serviceVariantId != null) {
      for (final v in variants) {
        if (v.id == item.serviceVariantId) return v;
      }
    }
    if (item.serviceId != null) {
      for (final v in variants) {
        if (v.serviceId == item.serviceId) return v;
      }
    }
    return null;
  }

  TimeOfDay _addMinutes(TimeOfDay time, int minutes) {
    final totalMinutes = time.hour * 60 + time.minute + minutes;
    return TimeOfDay(
      hour: (totalMinutes ~/ 60) % 24,
      minute: totalMinutes % 60,
    );
  }

  /// Trova lo staff migliore per un servizio:
  /// 1. Primo staff eligible disponibile
  /// 2. null per selezione manuale
  int? _findBestStaff(int serviceId) {
    final eligibleIds = ref.read(eligibleStaffForServiceProvider(serviceId));
    if (eligibleIds.isEmpty) return null;
    return eligibleIds.first;
  }

  Future<void> _pickDate() async {
    final picked = await showDialog<DateTime>(
      context: context,
      builder: (context) {
        return Dialog(
          child: CalendarDatePicker(
            initialDate: _date,
            firstDate: DateTime.now().subtract(const Duration(days: 365)),
            lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
            onDateChanged: (value) => Navigator.of(context).pop(value),
          ),
        );
      },
    );
    if (picked != null) {
      setState(() => _date = DateUtils.dateOnly(picked));
    }
  }

  void _scrollFormToBottom() {
    if (!_scrollController.hasClients) return;
    _scrollController.animateTo(
      _scrollController.position.maxScrollExtent,
      duration: const Duration(milliseconds: 250),
      curve: Curves.easeOut,
    );
  }

  Future<void> _onSave() async {
    if (!mounted) return;
    final l10n = context.l10n;
    if (!_formKey.currentState!.validate()) return;

    // Verifica che ci sia almeno un servizio con dati completi
    final validItems = _serviceItems
        .where((item) => item.serviceId != null && item.staffId != null)
        .toList();

    if (validItems.isEmpty) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text(l10n.atLeastOneServiceRequired)));
      return;
    }

    final clientsById = ref.read(clientsByIdProvider);
    final bookingsNotifier = ref.read(bookingsProvider.notifier);
    final location = ref.read(currentLocationProvider);
    final repository = ref.read(bookingsRepositoryProvider);

    // Deriva il nome del cliente dal provider se _clientId √® impostato
    final clientName = _clientId != null
        ? (clientsById[_clientId]?.name ?? _customClientName)
        : _customClientName;

    // Costruisci items per l'API (ogni servizio con il suo staff, start_time e override)
    final items = validItems.map((item) {
      final start = DateTime(
        _date.year,
        _date.month,
        _date.day,
        item.startTime.hour,
        item.startTime.minute,
      );
      return BookingItemRequest(
        serviceId: item.serviceId!,
        staffId: item.staffId!,
        startTime: start.toIso8601String(),
        // Include override values from ServiceItemData
        serviceVariantId: item.serviceVariantId,
        durationMinutes: item.durationMinutes,
        blockedExtraMinutes: item.blockedExtraMinutes > 0
            ? item.blockedExtraMinutes
            : null,
        processingExtraMinutes: item.processingExtraMinutes > 0
            ? item.processingExtraMinutes
            : null,
        // Note: price override not yet exposed in UI, could be added later
      );
    }).toList();

    try {
      // UNA singola chiamata API per creare UN booking con tutti i servizi
      final bookingResponse = await repository.createBookingWithItems(
        locationId: location.id,
        idempotencyKey: const Uuid().v4(),
        items: items,
        clientId: _clientId,
        notes: _notesController.text.isNotEmpty ? _notesController.text : null,
      );

      // Aggiorna booking metadata locale
      bookingsNotifier.ensureBooking(
        bookingId: bookingResponse.id,
        businessId: bookingResponse.businessId,
        locationId: bookingResponse.locationId,
        clientId: bookingResponse.clientId,
        clientName: bookingResponse.clientName ?? clientName,
      );

      // Refresh appointments per caricare i nuovi
      ref.invalidate(appointmentsProvider);
      await ref.read(appointmentsProvider.future);

      // Trova il primo appointment creato per lo scroll
      final currentList = ref.read(appointmentsProvider).value ?? [];
      final scrollTarget = currentList
          .where((a) => a.bookingId == bookingResponse.id)
          .firstOrNull;

      if (scrollTarget != null) {
        ref.read(agendaScrollRequestProvider.notifier).request(scrollTarget);
      }
    } catch (_) {
      if (mounted) {
        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text(l10n.errorTitle)));
      }
      return;
    }

    if (!mounted) return;
    Navigator.of(context).pop();
  }
}

// ============================================================================
// Helper Widgets
// ============================================================================

class _ClientItem {
  final int id;
  final String name;
  const _ClientItem(this.id, this.name);
}

/// Widget per la selezione del cliente con link cliccabile e hint
class _ClientSelectionField extends ConsumerWidget {
  const _ClientSelectionField({
    required this.clientId,
    required this.clientName,
    required this.clients,
    required this.onClientSelected,
    required this.onClientRemoved,
    required this.onOpenPicker,
  });

  final int? clientId;
  final String clientName;
  final List<Client> clients;
  final void Function(int? id, String name) onClientSelected;
  final VoidCallback onClientRemoved;
  final Future<void> Function()? onOpenPicker;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final hasClient = clientId != null || clientName.isNotEmpty;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          l10n.formClient,
          style: const TextStyle(fontWeight: FontWeight.w600),
        ),
        const SizedBox(height: 6),
        if (hasClient)
          _SelectedClientTile(
            clientName: clientName,
            onTap: () => onOpenPicker?.call(),
            onRemove: onClientRemoved,
          )
        else
          InkWell(
            onTap: () => onOpenPicker?.call(),
            borderRadius: BorderRadius.circular(8),
            child: Container(
              width: double.infinity,
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 14),
              decoration: BoxDecoration(
                border: Border.all(color: theme.colorScheme.outline),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.person_add_outlined,
                    size: 20,
                    color: theme.colorScheme.primary,
                  ),
                  const SizedBox(width: 8),
                  Text(
                    l10n.addClientToAppointment,
                    style: TextStyle(
                      color: theme.colorScheme.primary,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            ),
          ),
        const SizedBox(height: 6),
        Text(
          l10n.clientOptionalHint,
          style: theme.textTheme.bodySmall?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
      ],
    );
  }
}

/// Tile che mostra il cliente selezionato con opzione per rimuoverlo
class _SelectedClientTile extends StatelessWidget {
  const _SelectedClientTile({
    required this.clientName,
    required this.onTap,
    required this.onRemove,
  });

  final String clientName;
  final VoidCallback onTap;
  final VoidCallback onRemove;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
        decoration: BoxDecoration(
          border: Border.all(color: theme.colorScheme.outline),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Row(
          children: [
            StaffCircleAvatar(
              height: 32,
              color: theme.colorScheme.primary,
              isHighlighted: false,
              initials: clientName.isNotEmpty
                  ? initialsFromName(clientName, maxChars: 2)
                  : '?',
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
                clientName,
                style: const TextStyle(fontWeight: FontWeight.w500),
              ),
            ),
            IconButton(
              icon: Icon(Icons.close, size: 20, color: theme.colorScheme.error),
              onPressed: onRemove,
              tooltip: context.l10n.removeClient,
              padding: EdgeInsets.zero,
              constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
            ),
          ],
        ),
      ),
    );
  }
}

/// Bottom sheet per la selezione del cliente
class _ClientPickerSheet extends ConsumerStatefulWidget {
  const _ClientPickerSheet({required this.clients, this.selectedClientId});

  final List<Client> clients;
  final int? selectedClientId;

  @override
  ConsumerState<_ClientPickerSheet> createState() => _ClientPickerSheetState();
}

class _ClientPickerSheetState extends ConsumerState<_ClientPickerSheet> {
  final _searchController = TextEditingController();
  String _searchQuery = '';

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  List<Client> get _filteredClients {
    final asyncClients = ref.watch(clientsProvider);
    final clients = (asyncClients.value ?? [])
        .where((c) => !c.isArchived)
        .toList();
    if (_searchQuery.isEmpty) return clients;
    final q = _searchQuery.toLowerCase();
    return clients.where((c) => c.name.toLowerCase().contains(q)).toList();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    final maxHeight = MediaQuery.of(context).size.height * 0.8;
    return SafeArea(
      child: ConstrainedBox(
        constraints: BoxConstraints(maxHeight: maxHeight),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 16, 16, 12),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    l10n.selectClientTitle,
                    style: theme.textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  const SizedBox(height: AppSpacing.formFirstRowSpacing),
                  TextField(
                    controller: _searchController,
                    decoration: InputDecoration(
                      hintText: l10n.searchClientPlaceholder,
                      prefixIcon: const Icon(Icons.search, size: 20),
                      border: const OutlineInputBorder(),
                      isDense: true,
                      contentPadding: const EdgeInsets.symmetric(
                        horizontal: 12,
                        vertical: 10,
                      ),
                    ),
                    onChanged: (value) {
                      setState(() => _searchQuery = value.trim());
                    },
                  ),
                ],
              ),
            ),
            const AppBottomSheetDivider(),
            // Quick actions
            ListTile(
              leading: StaffCircleAvatar(
                height: 32,
                color: theme.colorScheme.primary,
                isHighlighted: false,
                initials: '',
                child: Icon(
                  Icons.person_add_outlined,
                  color: theme.colorScheme.onSurface,
                  size: 18,
                ),
              ),
              title: Text(l10n.createNewClient),
              onTap: () {
                Navigator.of(context).pop(_ClientItem(-2, _searchQuery));
              },
            ),
            ListTile(
              leading: StaffCircleAvatar(
                height: 32,
                color: theme.colorScheme.onSurfaceVariant,
                isHighlighted: false,
                initials: '',
                child: Icon(
                  Icons.person_off_outlined,
                  color: theme.colorScheme.onSurface,
                  size: 18,
                ),
              ),
              title: Text(l10n.noClientForAppointment),
              onTap: () {
                Navigator.of(context).pop(const _ClientItem(-1, ''));
              },
            ),
            const AppBottomSheetDivider(),
            // Client list
            Flexible(
              child: _filteredClients.isEmpty
                  ? Center(
                      child: Text(
                        l10n.clientsEmpty,
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                      ),
                    )
                  : ListView.builder(
                      padding: const EdgeInsets.only(bottom: 8),
                      itemCount: _filteredClients.length,
                      itemBuilder: (context, index) {
                        final client = _filteredClients[index];
                        final isSelected = client.id == widget.selectedClientId;
                        return ListTile(
                          leading: StaffCircleAvatar(
                            height: 32,
                            color: isSelected
                                ? theme.colorScheme.primary
                                : theme.colorScheme.primary,
                            isHighlighted: isSelected,
                            initials: client.name.isNotEmpty
                                ? initialsFromName(client.name, maxChars: 2)
                                : '?',
                          ),
                          title: Text(client.name),
                          subtitle: client.phone != null
                              ? Text(
                                  client.phone!,
                                  style: theme.textTheme.bodySmall,
                                )
                              : null,
                          trailing: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              IconButton(
                                icon: Icon(
                                  Icons.edit_outlined,
                                  size: 20,
                                  color: theme.colorScheme.onSurfaceVariant,
                                ),
                                onPressed: () async {
                                  await showClientEditDialog(
                                    context,
                                    ref,
                                    client: client,
                                  );
                                },
                                tooltip: l10n.clientsEdit,
                              ),
                              if (isSelected)
                                Icon(
                                  Icons.check_circle,
                                  color: theme.colorScheme.primary,
                                ),
                            ],
                          ),
                          onTap: () {
                            Navigator.of(
                              context,
                            ).pop(_ClientItem(client.id, client.name));
                          },
                        );
                      },
                    ),
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/agenda_feature.dart ---
/// Entry point modulare per la feature "Agenda"
/// Importa qui tutti i componenti pubblici dell'agenda.
/// Cos√¨ altrove potrai scrivere semplicemente:
///   import 'package:agenda/features/agenda/agenda_feature.dart';

library;

export 'domain/config/agenda_theme.dart'; // se aggiungi un tema centralizzato
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ÔøΩ Domain & Config
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
export 'domain/config/layout_config.dart';
// Schermata di agenda (entry screen)
export 'presentation/agenda_screen.dart';
export 'presentation/screens/day_view/components/hour_column.dart';
export 'presentation/screens/day_view/components/staff_header_row.dart';
// Vista principale (giornaliera multi-staff)
export 'presentation/screens/day_view/multi_staff_day_view.dart';
export 'presentation/screens/day_view/staff_column.dart';
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üé® Presentation layer
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Layout e componenti core
export 'presentation/screens/helper/responsive_layout.dart';
export 'presentation/screens/widgets/agenda_dividers.dart';
export 'presentation/screens/widgets/unavailable_slot_pattern.dart';
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ÔøΩ Application (providers, notifiers, stato)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
export 'providers/agenda_scroll_provider.dart';
export 'providers/pending_drop_provider.dart';
--- FILE: lib/features/staff/providers/staff_providers.dart ---
import 'package:agenda_backend/features/agenda/providers/business_providers.dart';
import 'package:agenda_backend/features/agenda/providers/location_providers.dart';
import 'package:agenda_backend/features/auth/providers/auth_provider.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/staff.dart';
import 'staff_repository_provider.dart';

class StaffNotifier extends AsyncNotifier<List<Staff>> {
  @override
  Future<List<Staff>> build() async {
    // Verifica autenticazione
    final authState = ref.watch(authProvider);
    if (!authState.isAuthenticated) {
      return [];
    }

    final business = ref.watch(currentBusinessProvider);
    if (business.id <= 0) {
      return [];
    }

    final repository = ref.watch(staffRepositoryProvider);

    try {
      final staff = await repository.getByBusiness(business.id);
      return staff;
    } catch (e) {
      return [];
    }
  }

  /// Ricarica gli staff dall'API
  Future<void> refresh() async {
    final authState = ref.read(authProvider);
    if (!authState.isAuthenticated) {
      state = const AsyncData([]);
      return;
    }

    final business = ref.read(currentBusinessProvider);
    if (business.id <= 0) {
      state = const AsyncData([]);
      return;
    }

    state = const AsyncLoading();

    try {
      final repository = ref.read(staffRepositoryProvider);
      final staff = await repository.getByBusiness(business.id);
      state = AsyncData(staff);
    } catch (e, st) {
      state = AsyncError(e, st);
    }
  }

  /// Crea un nuovo staff tramite API
  Future<Staff> createStaff({
    required String name,
    String? surname,
    String? colorHex,
    String? avatarUrl,
    bool? isBookableOnline,
    List<int>? locationIds,
    List<int>? serviceIds,
  }) async {
    final repository = ref.read(staffRepositoryProvider);
    final business = ref.read(currentBusinessProvider);

    final staff = await repository.create(
      businessId: business.id,
      name: name,
      surname: surname,
      colorHex: colorHex,
      avatarUrl: avatarUrl,
      isBookableOnline: isBookableOnline,
      locationIds: locationIds,
      serviceIds: serviceIds,
    );

    final current = state.value ?? [];
    state = AsyncData([...current, staff]);
    return staff;
  }

  /// Aggiorna uno staff esistente tramite API
  Future<Staff> updateStaffApi({
    required int staffId,
    String? name,
    String? surname,
    String? colorHex,
    String? avatarUrl,
    bool? isBookableOnline,
    int? sortOrder,
    List<int>? locationIds,
    List<int>? serviceIds,
  }) async {
    final repository = ref.read(staffRepositoryProvider);

    final updated = await repository.update(
      staffId: staffId,
      name: name,
      surname: surname,
      colorHex: colorHex,
      avatarUrl: avatarUrl,
      isBookableOnline: isBookableOnline,
      sortOrder: sortOrder,
      locationIds: locationIds,
      serviceIds: serviceIds,
    );

    final current = state.value ?? [];
    state = AsyncData([
      for (final s in current)
        if (s.id == updated.id) updated else s,
    ]);
    return updated;
  }

  /// Elimina uno staff tramite API
  Future<void> deleteStaffApi(int id) async {
    final repository = ref.read(staffRepositoryProvider);
    await repository.delete(id);

    final current = state.value ?? [];
    state = AsyncData(current.where((s) => s.id != id).toList());
  }

  // === Metodi locali per UI (backward compatibility) ===

  void add(Staff staff) {
    final current = state.value ?? [];
    state = AsyncData([...current, staff]);
  }

  void updateStaff(Staff updated) {
    final current = state.value ?? [];
    state = AsyncData([
      for (final s in current)
        if (s.id == updated.id) updated else s,
    ]);
  }

  void delete(int id) {
    final current = state.value ?? [];
    state = AsyncData(current.where((s) => s.id != id).toList());
  }

  void duplicate(Staff original) {
    final current = state.value ?? [];
    final newId = _nextId(current);
    final existingNames = current.map((s) => s.displayName).toSet();
    var base = original.displayName;
    var candidate = '$base Copia';
    var i = 1;
    while (existingNames.contains(candidate)) {
      candidate = '$base Copia $i';
      i++;
    }
    final parts = candidate.split(' ');
    final name = parts.first;
    final surname = parts.length > 1
        ? parts.sublist(1).join(' ')
        : original.surname;
    add(original.copyWith(id: newId, name: name, surname: surname));
  }

  int nextId() => _nextId(state.value ?? []);

  int nextSortOrderForLocations(Iterable<int> locationIds) {
    final current = state.value ?? [];
    if (current.isEmpty) return 0;
    final ids = locationIds.toSet();
    final relevant = ids.isEmpty
        ? current
        : current.where((s) => s.locationIds.any(ids.contains));
    if (relevant.isEmpty) return 0;
    return relevant.map((s) => s.sortOrder).reduce((a, b) => a > b ? a : b) + 1;
  }

  Future<void> reorderForLocation(
    int locationId,
    int oldIndex,
    int newIndex,
  ) async {
    final current = state.value ?? [];
    final inLocation =
        current.where((s) => s.worksAtLocation(locationId)).toList()
          ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));

    if (newIndex > oldIndex) newIndex -= 1;
    final item = inLocation.removeAt(oldIndex);
    inLocation.insert(newIndex, item);

    final updated = <Staff>[];
    for (int i = 0; i < inLocation.length; i++) {
      updated.add(inLocation[i].copyWith(sortOrder: i));
    }

    final updatedAll = [
      for (final s in current)
        if (s.worksAtLocation(locationId))
          updated.firstWhere((u) => u.id == s.id)
        else
          s,
    ];

    state = AsyncData(updatedAll);

    // Persist to API
    await _persistStaffOrder(updated);
  }

  /// Persiste l'ordine dello staff via API
  Future<void> _persistStaffOrder(List<Staff> staffList) async {
    try {
      final repository = ref.read(staffRepositoryProvider);
      await repository.reorderStaff(
        staffList.map((s) => {'id': s.id, 'sort_order': s.sortOrder}).toList(),
      );
    } catch (_) {
      // Ignora errore - utente pu√≤ riprovare
    }
  }

  int _nextId(List<Staff> current) {
    if (current.isEmpty) return 1;
    final maxId = current.map((s) => s.id).reduce((a, b) => a > b ? a : b);
    return maxId + 1;
  }
}

final allStaffProvider = AsyncNotifierProvider<StaffNotifier, List<Staff>>(
  StaffNotifier.new,
);

List<Staff> _sortStaff(List<Staff> staff) {
  final list = [...staff];
  list.sort((a, b) {
    final so = a.sortOrder.compareTo(b.sortOrder);
    return so != 0 ? so : a.displayName.compareTo(b.displayName);
  });
  return list;
}

final sortedAllStaffProvider = Provider<List<Staff>>((ref) {
  final staffAsync = ref.watch(allStaffProvider);
  return _sortStaff(staffAsync.value ?? []);
});

final staffForCurrentLocationProvider = Provider<List<Staff>>((ref) {
  final location = ref.watch(currentLocationProvider);
  final staffAsync = ref.watch(allStaffProvider);
  final staff = staffAsync.value ?? [];
  return _sortStaff([
    for (final member in staff)
      if (member.worksAtLocation(location.id)) member,
  ]);
});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üè¢ Location provider separato per la sezione Staff
// null = "Tutte le sedi" (default)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class StaffSectionLocationNotifier extends Notifier<int?> {
  @override
  int? build() => null; // Default: tutte le sedi

  void set(int? locationId) => state = locationId;

  void setAll() => state = null;
}

final staffSectionLocationIdProvider =
    NotifierProvider<StaffSectionLocationNotifier, int?>(
      StaffSectionLocationNotifier.new,
    );

/// Staff filtrato per la location selezionata nella sezione Staff.
/// Se locationId √® null (tutte le sedi), restituisce tutti gli staff.
final staffForStaffSectionProvider = Provider<List<Staff>>((ref) {
  final locationId = ref.watch(staffSectionLocationIdProvider);
  final staffAsync = ref.watch(allStaffProvider);
  final staff = staffAsync.value ?? [];

  if (locationId == null) {
    // Tutte le sedi: restituisci tutti gli staff
    return _sortStaff(staff);
  }

  return _sortStaff([
    for (final member in staff)
      if (member.worksAtLocation(locationId)) member,
  ]);
});

/// Holds the staffId that should be pre-selected when navigating to
/// the single-staff availability edit screen. Cleared after consumption.
final initialStaffToEditProvider = Provider<ValueNotifier<int?>>((ref) {
  final vn = ValueNotifier<int?>(null);
  ref.onDispose(vn.dispose);
  return vn;
});
--- FILE: lib/features/staff/providers/staff_sorted_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/location.dart';
import '../../../core/models/staff.dart';
import '../../agenda/providers/location_providers.dart';
import 'staff_providers.dart';

final sortedLocationsProvider = Provider<List<Location>>((ref) {
  // usa l'ordine della lista nello stato
  return [...ref.watch(locationsProvider)];
});

final staffByLocationProvider = Provider.family<List<Staff>, int>((
  ref,
  locationId,
) {
  final staff = ref.watch(allStaffProvider).value ?? [];
  final list = [
    for (final s in staff)
      if (s.worksAtLocation(locationId)) s,
  ];
  list.sort((a, b) {
    final so = a.sortOrder.compareTo(b.sortOrder);
    return so != 0 ? so : a.displayName.compareTo(b.displayName);
  });
  return list;
});
--- FILE: lib/features/staff/providers/staff_repository_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'staff_repository_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(staffRepository)
const staffRepositoryProvider = StaffRepositoryProvider._();

final class StaffRepositoryProvider
    extends
        $FunctionalProvider<StaffRepository, StaffRepository, StaffRepository>
    with $Provider<StaffRepository> {
  const StaffRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'staffRepositoryProvider',
        isAutoDispose: false,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$staffRepositoryHash();

  @$internal
  @override
  $ProviderElement<StaffRepository> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  StaffRepository create(Ref ref) {
    return staffRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(StaffRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<StaffRepository>(value),
    );
  }
}

String _$staffRepositoryHash() => r'f2d32cabb396f95a9f8be7d15391f2dec04629c1';
--- FILE: lib/features/staff/providers/staff_planning_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/staff_planning.dart';
import '../../../core/network/network_providers.dart';
import '../../../core/services/staff_planning_selector.dart';
import '../../../core/validation/staff_planning_validator.dart';
import '../../agenda/providers/date_range_provider.dart';

/// Provider per il selettore di planning.
final staffPlanningSelectorProvider = Provider<StaffPlanningSelector>((ref) {
  return StaffPlanningSelector();
});

/// Provider per il validatore di planning.
final staffPlanningValidatorProvider = Provider<StaffPlanningValidator>((ref) {
  return StaffPlanningValidator();
});

/// State per i planning degli staff.
/// Mappa: staffId ‚Üí `List<StaffPlanning>`
typedef StaffPlanningsState = Map<int, List<StaffPlanning>>;

/// Provider per la gestione dei planning degli staff.
///
/// Gestisce:
/// - Caricamento planning da API
/// - Selezione planning per data (biweekly A/B incluso)
/// - Validazione create/update
/// - Cache locale dei planning
class StaffPlanningsNotifier extends Notifier<StaffPlanningsState> {
  @override
  StaffPlanningsState build() {
    return {};
  }

  StaffPlanningValidator get _validator =>
      ref.read(staffPlanningValidatorProvider);

  /// Lista flat di tutti i planning (per validazione).
  List<StaffPlanning> get _allPlannings {
    return state.values.expand((list) => list).toList();
  }

  /// Carica i planning per uno staff specifico dall'API.
  Future<void> loadPlanningsForStaff(int staffId) async {
    try {
      final api = ref.read(apiClientProvider);
      final planningsJson = await api.getStaffPlannings(staffId);

      final plannings = planningsJson
          .map((json) => StaffPlanning.fromJson(json))
          .toList();

      state = {...state, staffId: plannings};
    } catch (e) {
      // Mantieni stato attuale in caso di errore
      // Log dell'errore pu√≤ essere aggiunto qui
    }
  }

  /// Aggiunge un planning con validazione.
  ///
  /// Ritorna [StaffPlanningValidationResult] con esito validazione.
  /// Se valido, aggiunge il planning allo stato e sincronizza con API.
  Future<StaffPlanningValidationResult> addPlanning(
    StaffPlanning planning,
  ) async {
    final result = _validator.validateForCreate(planning, _allPlannings);

    if (!result.isValid) {
      return result;
    }

    try {
      final api = ref.read(apiClientProvider);
      final response = await api.createStaffPlanning(
        staffId: planning.staffId,
        type: planning.type.name,
        validFrom: _dateToIso(planning.validFrom),
        validTo: planning.validTo != null
            ? _dateToIso(planning.validTo!)
            : null,
        templates: planning.templates.map((t) => t.toJson()).toList(),
      );

      // Usa il planning ritornato dal server (con ID generato)
      final createdPlanning = StaffPlanning.fromJson(response);
      final staffPlannings = List<StaffPlanning>.from(
        state[planning.staffId] ?? [],
      );
      staffPlannings.add(createdPlanning);

      state = {...state, planning.staffId: staffPlannings};
    } catch (e) {
      return StaffPlanningValidationResult(
        isValid: false,
        errors: ['api_error: ${e.toString()}'],
      );
    }

    return result;
  }

  /// Aggiorna un planning esistente con validazione.
  Future<StaffPlanningValidationResult> updatePlanning(
    StaffPlanning planning,
    StaffPlanning original,
  ) async {
    final result = _validator.validateForUpdate(
      planning,
      _allPlannings,
      original,
    );

    if (!result.isValid) {
      return result;
    }

    try {
      final api = ref.read(apiClientProvider);
      final response = await api.updateStaffPlanning(
        planningId: planning.id,
        type: planning.type.name,
        validFrom: _dateToIso(planning.validFrom),
        validTo: planning.validTo != null
            ? _dateToIso(planning.validTo!)
            : null,
        templates: planning.templates.map((t) => t.toJson()).toList(),
      );

      final updatedPlanning = StaffPlanning.fromJson(response);
      final staffPlannings = List<StaffPlanning>.from(
        state[planning.staffId] ?? [],
      );

      final index = staffPlannings.indexWhere((p) => p.id == planning.id);
      if (index != -1) {
        staffPlannings[index] = updatedPlanning;
      }

      state = {...state, planning.staffId: staffPlannings};
    } catch (e) {
      return StaffPlanningValidationResult(
        isValid: false,
        errors: ['api_error: ${e.toString()}'],
      );
    }

    return result;
  }

  /// Elimina un planning.
  Future<void> deletePlanning(int staffId, int planningId) async {
    try {
      final api = ref.read(apiClientProvider);
      await api.deleteStaffPlanning(planningId);

      final staffPlannings = List<StaffPlanning>.from(state[staffId] ?? []);
      staffPlannings.removeWhere((p) => p.id == planningId);

      state = {...state, staffId: staffPlannings};
    } catch (e) {
      // In caso di errore, non modifica lo stato
    }
  }

  /// Imposta i planning per uno staff (es. dopo caricamento da API).
  void setPlanningsForStaff(int staffId, List<StaffPlanning> plannings) {
    state = {...state, staffId: plannings};
  }

  /// Formatta DateTime in stringa ISO date.
  String _dateToIso(DateTime date) {
    return '${date.year.toString().padLeft(4, '0')}-'
        '${date.month.toString().padLeft(2, '0')}-'
        '${date.day.toString().padLeft(2, '0')}';
  }
}

/// Provider principale per i planning.
final staffPlanningsProvider =
    NotifierProvider<StaffPlanningsNotifier, StaffPlanningsState>(
      StaffPlanningsNotifier.new,
    );

/// Provider per ottenere il planning valido per uno staff in una data.
///
/// Ritorna [PlanningLookupResult]:
/// - [NoPlanningFound] se nessun planning valido
/// - [PlanningFound] con planning e week label (A/B)
/// - [MultiplePlanningsFound] se errore dati
final planningForStaffOnDateProvider =
    Provider.family<PlanningLookupResult, ({int staffId, DateTime date})>((
      ref,
      params,
    ) {
      final plannings = ref.watch(staffPlanningsProvider);
      final selector = ref.watch(staffPlanningSelectorProvider);

      return selector.findPlanningForDate(
        staffId: params.staffId,
        date: params.date,
        allPlannings: plannings.values.expand((list) => list).toList(),
      );
    });

/// Provider per gli slot disponibili di uno staff in una data.
///
/// Ritorna [Set<int>] degli slot index disponibili.
/// Set vuoto se nessun planning o giorno non lavorativo.
/// null se errore di consistenza (planning multipli).
final planningSlotsForDateProvider =
    Provider.family<Set<int>?, ({int staffId, DateTime date})>((ref, params) {
      final result = ref.watch(planningForStaffOnDateProvider(params));

      return switch (result) {
        NoPlanningFound() => {},
        PlanningFound(template: final t) => t.getSlotsForDay(
          params.date.weekday,
        ),
        MultiplePlanningsFound() => null,
      };
    });

/// Provider per verificare se uno staff √® disponibile in una data.
final isStaffAvailableOnDateProvider =
    Provider.family<bool, ({int staffId, DateTime date})>((ref, params) {
      final slots = ref.watch(planningSlotsForDateProvider(params));
      return slots != null && slots.isNotEmpty;
    });

/// Provider per la week label (A/B) di una data per uno staff con biweekly.
///
/// Ritorna null se:
/// - Nessun planning valido
/// - Planning √® weekly (non biweekly)
final weekLabelForDateProvider =
    Provider.family<WeekLabel?, ({int staffId, DateTime date})>((ref, params) {
      final result = ref.watch(planningForStaffOnDateProvider(params));

      if (result is PlanningFound) {
        final planning = result.planning;
        if (planning.type == StaffPlanningType.biweekly) {
          return result.weekLabel;
        }
      }

      return null;
    });

/// Provider per gli slot disponibili dello staff nella data corrente dell'agenda.
///
/// Combina:
/// 1. Planning base (template settimanale con supporto biweekly)
/// 2. Eccezioni (da availabilityExceptionsProvider)
///
/// Usa la data da [agendaDateProvider].
final staffPlanningBaseSlotsProvider = Provider.family<Set<int>, int>((
  ref,
  staffId,
) {
  final agendaDate = ref.watch(agendaDateProvider);
  final slots = ref.watch(
    planningSlotsForDateProvider((staffId: staffId, date: agendaDate)),
  );

  return slots ?? {};
});

/// Provider per verificare se una data √® in settimana A o B.
///
/// Per planning weekly, ritorna sempre 'A'.
/// Per planning biweekly, calcola in base a validFrom.
/// Ritorna null se nessun planning.
final currentWeekLabelProvider = Provider.family<WeekLabel?, int>((
  ref,
  staffId,
) {
  final agendaDate = ref.watch(agendaDateProvider);
  return ref.watch(
    weekLabelForDateProvider((staffId: staffId, date: agendaDate)),
  );
});

/// Provider per i planning di uno staff specifico.
final planningsForStaffProvider = Provider.family<List<StaffPlanning>, int>((
  ref,
  staffId,
) {
  final plannings = ref.watch(staffPlanningsProvider);
  return plannings[staffId] ?? [];
});

/// Provider derivato per il planning attivo di uno staff nella data corrente.
final currentPlanningForStaffProvider = Provider.family<StaffPlanning?, int>((
  ref,
  staffId,
) {
  final agendaDate = ref.watch(agendaDateProvider);
  final result = ref.watch(
    planningForStaffOnDateProvider((staffId: staffId, date: agendaDate)),
  );

  if (result is PlanningFound) {
    return result.planning;
  }
  return null;
});
--- FILE: lib/features/staff/providers/staff_repository_provider.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../core/network/network_providers.dart';
import '../data/staff_repository.dart';

part 'staff_repository_provider.g.dart';

@Riverpod(keepAlive: true)
StaffRepository staffRepository(Ref ref) {
  final apiClient = ref.watch(apiClientProvider);
  return StaffRepository(apiClient: apiClient);
}
--- FILE: lib/features/staff/providers/staff_reorder_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../agenda/providers/location_providers.dart';
import 'staff_providers.dart';

class TeamReorderNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  void toggle() => state = !state;

  void setReordering(bool value) => state = value;

  Future<void> reorderLocations(int oldIndex, int newIndex) async {
    await ref.read(locationsProvider.notifier).reorder(oldIndex, newIndex);
  }

  Future<void> reorderStaffForLocation(
    int locationId,
    int oldIndex,
    int newIndex,
  ) async {
    await ref
        .read(allStaffProvider.notifier)
        .reorderForLocation(locationId, oldIndex, newIndex);
  }
}

final teamReorderProvider = NotifierProvider<TeamReorderNotifier, bool>(
  TeamReorderNotifier.new,
);

class TeamReorderPanelNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  void toggle() => state = !state;

  void setVisible(bool value) => state = value;
}

final teamReorderPanelProvider =
    NotifierProvider<TeamReorderPanelNotifier, bool>(
      TeamReorderPanelNotifier.new,
    );
--- FILE: lib/features/staff/providers/weekly_availability_provider.dart ---

--- FILE: lib/features/staff/providers/availability_exceptions_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/availability_exception.dart';
import '../../../core/network/network_providers.dart';
import '../../agenda/providers/business_providers.dart';
import '../data/api_availability_exceptions_repository.dart';
import '../data/availability_exceptions_repository.dart';

/// Provider per il repository delle eccezioni.
/// Usa l'implementazione API reale.
final availabilityExceptionsRepositoryProvider =
    Provider<AvailabilityExceptionsRepository>((ref) {
      final apiClient = ref.watch(apiClientProvider);
      final business = ref.watch(currentBusinessProvider);
      return ApiAvailabilityExceptionsRepository(
        apiClient: apiClient,
        businessId: business.id,
      );
    });

/// Provider per la gestione dello stato delle eccezioni.
///
/// Stato: `Map<staffId, List<AvailabilityException>>`
/// Carica le eccezioni on-demand quando richieste per uno staff specifico.
class AvailabilityExceptionsNotifier
    extends AsyncNotifier<Map<int, List<AvailabilityException>>> {
  @override
  Future<Map<int, List<AvailabilityException>>> build() async {
    // Inizialmente vuoto, le eccezioni vengono caricate on-demand
    return {};
  }

  AvailabilityExceptionsRepository get _repository =>
      ref.read(availabilityExceptionsRepositoryProvider);

  /// Carica le eccezioni per uno staff specifico in un range di date.
  /// Se [fromDate] e [toDate] non sono specificati, carica tutte le eccezioni.
  Future<void> loadExceptionsForStaff(
    int staffId, {
    DateTime? fromDate,
    DateTime? toDate,
  }) async {
    final exceptions = await _repository.getExceptionsForStaff(
      staffId,
      fromDate: fromDate,
      toDate: toDate,
    );

    final current = state.value ?? {};
    state = AsyncData({...current, staffId: exceptions});
  }

  /// Aggiunge una nuova eccezione.
  Future<AvailabilityException> addException({
    required int staffId,
    required DateTime date,
    TimeOfDay? startTime,
    TimeOfDay? endTime,
    required AvailabilityExceptionType type,
    String? reason,
  }) async {
    final exception = startTime != null && endTime != null
        ? AvailabilityException.timeRange(
            id: 0, // Il repository assegner√† l'ID reale
            staffId: staffId,
            date: date,
            startTime: startTime,
            endTime: endTime,
            type: type,
            reason: reason,
          )
        : AvailabilityException.allDay(
            id: 0,
            staffId: staffId,
            date: date,
            type: type,
            reason: reason,
          );

    final saved = await _repository.addException(exception);

    // Aggiorna lo stato locale
    final current = state.value ?? {};
    final staffExceptions = List<AvailabilityException>.from(
      current[staffId] ?? [],
    );
    staffExceptions.add(saved);

    state = AsyncData({...current, staffId: staffExceptions});

    return saved;
  }

  /// Aggiunge eccezioni per un periodo (batch).
  /// Crea un'eccezione per ogni giorno nel range [startDate, endDate].
  Future<List<AvailabilityException>> addExceptionsForPeriod({
    required int staffId,
    required DateTime startDate,
    required DateTime endDate,
    TimeOfDay? startTime,
    TimeOfDay? endTime,
    required AvailabilityExceptionType type,
    String? reason,
  }) async {
    final List<AvailabilityException> created = [];

    // Normalizza le date
    var currentDate = DateUtils.dateOnly(startDate);
    final lastDate = DateUtils.dateOnly(endDate);

    // Crea un'eccezione per ogni giorno
    while (!currentDate.isAfter(lastDate)) {
      final exception = startTime != null && endTime != null
          ? AvailabilityException.timeRange(
              id: 0,
              staffId: staffId,
              date: currentDate,
              startTime: startTime,
              endTime: endTime,
              type: type,
              reason: reason,
            )
          : AvailabilityException.allDay(
              id: 0,
              staffId: staffId,
              date: currentDate,
              type: type,
              reason: reason,
            );

      final saved = await _repository.addException(exception);
      created.add(saved);

      currentDate = currentDate.add(const Duration(days: 1));
    }

    // Aggiorna lo stato locale con tutte le eccezioni create
    final current = state.value ?? {};
    final staffExceptions = List<AvailabilityException>.from(
      current[staffId] ?? [],
    );
    staffExceptions.addAll(created);

    state = AsyncData({...current, staffId: staffExceptions});

    return created;
  }

  /// Aggiorna un'eccezione esistente.
  Future<AvailabilityException> updateException(
    AvailabilityException exception,
  ) async {
    final updated = await _repository.updateException(exception);

    // Aggiorna lo stato locale
    final current = state.value ?? {};
    final staffExceptions = List<AvailabilityException>.from(
      current[exception.staffId] ?? [],
    );
    final index = staffExceptions.indexWhere((e) => e.id == exception.id);
    if (index != -1) {
      staffExceptions[index] = updated;
    }

    state = AsyncData({...current, exception.staffId: staffExceptions});

    return updated;
  }

  /// Elimina un'eccezione.
  Future<void> deleteException(int staffId, int exceptionId) async {
    await _repository.deleteException(exceptionId);

    // Aggiorna lo stato locale
    final current = state.value ?? {};
    final staffExceptions = List<AvailabilityException>.from(
      current[staffId] ?? [],
    );
    staffExceptions.removeWhere((e) => e.id == exceptionId);

    state = AsyncData({...current, staffId: staffExceptions});
  }

  /// Ottiene le eccezioni per uno staff in una data specifica (sincronamente dallo stato).
  List<AvailabilityException> getExceptionsForStaffOnDate(
    int staffId,
    DateTime date,
  ) {
    final current = state.value ?? {};
    final staffExceptions = current[staffId] ?? [];
    return staffExceptions.where((e) => e.isOnDate(date)).toList();
  }
}

final availabilityExceptionsProvider =
    AsyncNotifierProvider<
      AvailabilityExceptionsNotifier,
      Map<int, List<AvailabilityException>>
    >(AvailabilityExceptionsNotifier.new);

/// Provider derivato: eccezioni per uno staff specifico in una data specifica.
/// Utile per query puntuali nella UI.
final exceptionsForStaffOnDateProvider =
    Provider.family<
      List<AvailabilityException>,
      ({int staffId, DateTime date})
    >((ref, params) {
      final allExceptions = ref.watch(availabilityExceptionsProvider);

      return allExceptions.maybeWhen(
        data: (data) {
          final staffExceptions = data[params.staffId] ?? [];
          return staffExceptions.where((e) => e.isOnDate(params.date)).toList();
        },
        orElse: () => [],
      );
    });

/// Provider derivato: verifica se ci sono eccezioni per uno staff in una data.
final hasExceptionsForStaffOnDateProvider =
    Provider.family<bool, ({int staffId, DateTime date})>((ref, params) {
      final exceptions = ref.watch(exceptionsForStaffOnDateProvider(params));
      return exceptions.isNotEmpty;
    });

/// Provider derivato: tutte le eccezioni per uno staff (lista flat).
final allExceptionsForStaffProvider =
    Provider.family<List<AvailabilityException>, int>((ref, staffId) {
      final allExceptions = ref.watch(availabilityExceptionsProvider);

      return allExceptions.maybeWhen(
        data: (data) => data[staffId] ?? [],
        orElse: () => [],
      );
    });
--- FILE: lib/features/staff/utils/staff_formatters.dart ---
// Placeholder per futuri formatter relativi allo staff.
--- FILE: lib/features/staff/utils/staff_validators.dart ---
// Placeholder per futuri validator relativi allo staff.
--- FILE: lib/features/staff/data/weekly_availability_repository.dart ---

--- FILE: lib/features/staff/data/staff_api.dart ---
import '../../../core/models/staff.dart';
import '../../../core/network/api_client.dart';

/// API layer per Staff - chiamate reali a agenda_core
class StaffApi {
  final ApiClient _apiClient;

  StaffApi({required ApiClient apiClient}) : _apiClient = apiClient;

  /// GET /v1/staff?location_id=X
  Future<List<Staff>> fetchStaff(int locationId) async {
    final data = await _apiClient.getStaff(locationId);
    final List<dynamic> items = data['staff'] ?? [];
    return items
        .map((json) => Staff.fromJson(json as Map<String, dynamic>))
        .toList();
  }
}
--- FILE: lib/features/staff/data/api_availability_exceptions_repository.dart ---
import 'package:flutter/material.dart';

import '../../../core/models/availability_exception.dart';
import '../../../core/network/api_client.dart';
import 'availability_exceptions_repository.dart';

/// Implementazione del repository per le eccezioni che usa l'API reale.
class ApiAvailabilityExceptionsRepository
    implements AvailabilityExceptionsRepository {
  final ApiClient _apiClient;
  final int _businessId;

  // Cache locale per evitare chiamate API ripetute
  final Map<int, List<AvailabilityException>> _cache = {};
  DateTime? _cacheValidUntil;

  ApiAvailabilityExceptionsRepository({
    required ApiClient apiClient,
    required int businessId,
  }) : _apiClient = apiClient,
       _businessId = businessId;

  bool get _isCacheValid =>
      _cacheValidUntil != null && DateTime.now().isBefore(_cacheValidUntil!);

  void _invalidateCache() {
    _cache.clear();
    _cacheValidUntil = null;
  }

  /// Carica tutte le eccezioni per il business e popola la cache.
  Future<void> _loadAllExceptions({String? fromDate, String? toDate}) async {
    final result = await _apiClient.getStaffAvailabilityExceptionsAll(
      _businessId,
      fromDate: fromDate,
      toDate: toDate,
    );

    _cache.clear();
    for (final entry in result.entries) {
      _cache[entry.key] = entry.value.map(_parseException).toList();
    }
    // Cache valida per 5 minuti
    _cacheValidUntil = DateTime.now().add(const Duration(minutes: 5));
  }

  AvailabilityException _parseException(Map<String, dynamic> json) {
    final type = json['type'] == 'available'
        ? AvailabilityExceptionType.available
        : AvailabilityExceptionType.unavailable;

    final date = DateTime.parse(json['date'] as String);

    TimeOfDay? startTime;
    TimeOfDay? endTime;

    if (json['start_time'] != null) {
      final parts = (json['start_time'] as String).split(':');
      startTime = TimeOfDay(
        hour: int.parse(parts[0]),
        minute: int.parse(parts[1]),
      );
    }

    if (json['end_time'] != null) {
      final parts = (json['end_time'] as String).split(':');
      endTime = TimeOfDay(
        hour: int.parse(parts[0]),
        minute: int.parse(parts[1]),
      );
    }

    if (startTime != null && endTime != null) {
      return AvailabilityException.timeRange(
        id: json['id'] as int,
        staffId: json['staff_id'] as int,
        date: date,
        startTime: startTime,
        endTime: endTime,
        type: type,
        reasonCode: json['reason_code'] as String?,
        reason: json['reason'] as String?,
      );
    } else {
      return AvailabilityException.allDay(
        id: json['id'] as int,
        staffId: json['staff_id'] as int,
        date: date,
        type: type,
        reasonCode: json['reason_code'] as String?,
        reason: json['reason'] as String?,
      );
    }
  }

  String _formatTime(TimeOfDay time) {
    return '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';
  }

  String _formatDate(DateTime date) {
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
  }

  @override
  Future<List<AvailabilityException>> getExceptionsForStaff(
    int staffId, {
    DateTime? fromDate,
    DateTime? toDate,
  }) async {
    // Se la cache √® valida, usa quella
    if (_isCacheValid && _cache.containsKey(staffId)) {
      var exceptions = _cache[staffId]!;
      if (fromDate != null) {
        exceptions = exceptions
            .where((e) => !e.date.isBefore(fromDate))
            .toList();
      }
      if (toDate != null) {
        exceptions = exceptions.where((e) => !e.date.isAfter(toDate)).toList();
      }
      return exceptions;
    }

    // Carica da API
    final result = await _apiClient.getStaffAvailabilityExceptions(
      staffId,
      fromDate: fromDate != null ? _formatDate(fromDate) : null,
      toDate: toDate != null ? _formatDate(toDate) : null,
    );

    final exceptions = result.map(_parseException).toList();
    _cache[staffId] = exceptions;

    return exceptions;
  }

  @override
  Future<List<AvailabilityException>> getExceptionsForDate(
    DateTime date,
  ) async {
    // Carica tutte le eccezioni se cache non valida
    if (!_isCacheValid) {
      await _loadAllExceptions();
    }

    final targetDate = DateUtils.dateOnly(date);
    final result = <AvailabilityException>[];

    for (final exceptions in _cache.values) {
      for (final e in exceptions) {
        if (e.isOnDate(targetDate)) {
          result.add(e);
        }
      }
    }

    return result;
  }

  @override
  Future<AvailabilityException?> getException(int id) async {
    // Cerca prima nella cache
    for (final exceptions in _cache.values) {
      for (final e in exceptions) {
        if (e.id == id) return e;
      }
    }

    // Non trovato in cache - in futuro potremmo aggiungere endpoint GET /v1/staff/availability-exceptions/{id}
    return null;
  }

  @override
  Future<AvailabilityException> addException(
    AvailabilityException exception,
  ) async {
    final result = await _apiClient.createStaffAvailabilityException(
      staffId: exception.staffId,
      date: _formatDate(exception.date),
      startTime: exception.startTime != null
          ? _formatTime(exception.startTime!)
          : null,
      endTime: exception.endTime != null
          ? _formatTime(exception.endTime!)
          : null,
      type: exception.type == AvailabilityExceptionType.available
          ? 'available'
          : 'unavailable',
      reasonCode: exception.reasonCode,
      reason: exception.reason,
    );

    final created = _parseException(result);

    // Aggiorna cache
    _cache.putIfAbsent(created.staffId, () => []);
    _cache[created.staffId]!.add(created);

    return created;
  }

  @override
  Future<AvailabilityException> updateException(
    AvailabilityException exception,
  ) async {
    final result = await _apiClient.updateStaffAvailabilityException(
      exceptionId: exception.id,
      date: _formatDate(exception.date),
      startTime: exception.startTime != null
          ? _formatTime(exception.startTime!)
          : null,
      endTime: exception.endTime != null
          ? _formatTime(exception.endTime!)
          : null,
      type: exception.type == AvailabilityExceptionType.available
          ? 'available'
          : 'unavailable',
      reasonCode: exception.reasonCode,
      reason: exception.reason,
    );

    final updated = _parseException(result);

    // Aggiorna cache
    if (_cache.containsKey(updated.staffId)) {
      final index = _cache[updated.staffId]!.indexWhere(
        (e) => e.id == updated.id,
      );
      if (index != -1) {
        _cache[updated.staffId]![index] = updated;
      }
    }

    return updated;
  }

  @override
  Future<void> deleteException(int id) async {
    await _apiClient.deleteStaffAvailabilityException(id);

    // Rimuovi dalla cache
    for (final exceptions in _cache.values) {
      exceptions.removeWhere((e) => e.id == id);
    }
  }

  /// Forza il refresh della cache.
  void refresh() {
    _invalidateCache();
  }
}
--- FILE: lib/features/staff/data/availability_exceptions_repository.dart ---
import '../../../core/models/availability_exception.dart';

/// Repository per la gestione delle eccezioni alla disponibilit√†.
///
/// Implementazione API in `api_availability_exceptions_repository.dart`.
abstract class AvailabilityExceptionsRepository {
  /// Carica tutte le eccezioni per uno staff in un range di date.
  Future<List<AvailabilityException>> getExceptionsForStaff(
    int staffId, {
    DateTime? fromDate,
    DateTime? toDate,
  });

  /// Carica tutte le eccezioni per una data specifica (tutti gli staff).
  Future<List<AvailabilityException>> getExceptionsForDate(DateTime date);

  /// Carica un'eccezione per ID.
  Future<AvailabilityException?> getException(int id);

  /// Aggiunge una nuova eccezione.
  Future<AvailabilityException> addException(AvailabilityException exception);

  /// Aggiorna un'eccezione esistente.
  Future<AvailabilityException> updateException(
    AvailabilityException exception,
  );

  /// Elimina un'eccezione.
  Future<void> deleteException(int id);
}
--- FILE: lib/features/staff/data/staff_repository.dart ---
import '../../../core/models/staff.dart';
import '../../../core/network/api_client.dart';
import 'staff_api.dart';

class StaffRepository {
  StaffRepository({required ApiClient apiClient})
    : _apiClient = apiClient,
      _api = StaffApi(apiClient: apiClient);

  final ApiClient _apiClient;
  final StaffApi _api;

  Future<List<Staff>> getByLocation(int locationId) =>
      _api.fetchStaff(locationId);

  Future<List<Staff>> getByBusiness(int businessId) async {
    final data = await _apiClient.getStaffByBusiness(businessId);
    return data.map((json) => Staff.fromJson(json)).toList();
  }

  Future<Staff> create({
    required int businessId,
    required String name,
    String? surname,
    String? colorHex,
    String? avatarUrl,
    bool? isBookableOnline,
    List<int>? locationIds,
    List<int>? serviceIds,
  }) async {
    final data = await _apiClient.createStaff(
      businessId: businessId,
      name: name,
      surname: surname,
      colorHex: colorHex,
      avatarUrl: avatarUrl,
      isBookableOnline: isBookableOnline,
      locationIds: locationIds,
      serviceIds: serviceIds,
    );
    return Staff.fromJson(data);
  }

  Future<Staff> update({
    required int staffId,
    String? name,
    String? surname,
    String? colorHex,
    String? avatarUrl,
    bool? isBookableOnline,
    int? sortOrder,
    List<int>? locationIds,
    List<int>? serviceIds,
  }) async {
    final data = await _apiClient.updateStaff(
      staffId: staffId,
      name: name,
      surname: surname,
      colorHex: colorHex,
      avatarUrl: avatarUrl,
      isBookableOnline: isBookableOnline,
      sortOrder: sortOrder,
      locationIds: locationIds,
      serviceIds: serviceIds,
    );
    return Staff.fromJson(data);
  }

  Future<void> delete(int staffId) async {
    await _apiClient.deleteStaff(staffId);
  }

  /// Batch update sort_order for multiple staff members
  Future<void> reorderStaff(List<Map<String, dynamic>> staffList) async {
    await _apiClient.reorderStaff(staff: staffList);
  }
}
--- FILE: lib/features/staff/presentation/staff_availability_screen.dart ---
/*
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üéØ FUNZIONALIT√Ä COMPLETA: Gestione disponibilit√† staff
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

CONTESTO:
Progetto Flutter web "Agenda Platform".
Architettura basata su:
- Riverpod per lo stato e provider
- Widget principali: MultiStaffDayView, StaffColumn, AppointmentCard
- Configurazione: LayoutConfig e AgendaTheme

OBIETTIVO:
Schermata per gestire disponibilit√† settimanali dello staff.

AGGIORNAMENTI RECENTI:
- Copertura 24h (00:00‚Äì24:00)
- Scroll verticale sincronizzato tra colonna orari e griglia giorni
- Etichetta oraria centrata in ogni cella (HH:MM)
- Persistenza su DB tramite API (01/01/2026)

*/

import 'dart:async';

import 'package:agenda_backend/app/theme/extensions.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/staff.dart';
import 'package:agenda_backend/core/network/network_providers.dart';
import 'package:agenda_backend/core/widgets/staff_picker_sheet.dart';
import 'package:agenda_backend/features/agenda/providers/business_providers.dart';
import 'package:agenda_backend/features/agenda/providers/layout_config_provider.dart';
import 'package:agenda_backend/features/staff/presentation/widgets/exception_calendar_view.dart';
import 'package:agenda_backend/features/staff/presentation/widgets/weekly_schedule_editor.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üì¶ MODEL: TimeRange (ore intere)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class TimeRange {
  final int startHour; // incluso
  final int endHour; // escluso

  const TimeRange(this.startHour, this.endHour)
    : assert(startHour >= 0 && startHour <= 23),
      assert(endHour >= 1 && endHour <= 24),
      assert(endHour > startHour);

  @override
  String toString() => 'TimeRange($startHour-$endHour)';

  TimeRange copyWith({int? startHour, int? endHour}) =>
      TimeRange(startHour ?? this.startHour, endHour ?? this.endHour);
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üß† PROVIDER: StaffAvailabilityByStaffNotifier
// Stato: AsyncValue<Map<int, Map<int, Set<int>>>>
// Carica e salva disponibilit√† settimanale tramite API
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Nuovo provider per persistenza per-staff: staffId -> day -> slots (Set<int>)
class StaffAvailabilityByStaffNotifier
    extends AsyncNotifier<Map<int, Map<int, Set<int>>>> {
  static const _minutesPerSlot = 15;

  @override
  FutureOr<Map<int, Map<int, Set<int>>>> build() async {
    // Carica schedules dall'API per il business corrente
    final business = ref.watch(currentBusinessProvider);
    final apiClient = ref.watch(apiClientProvider);

    try {
      final apiSchedules = await apiClient.getStaffSchedulesAll(business.id);
      return _convertApiToSlots(apiSchedules);
    } catch (_) {
      // In caso di errore, ritorna mappa vuota
      return {};
    }
  }

  /// Converte la risposta API (time strings) in slot indices.
  Map<int, Map<int, Set<int>>> _convertApiToSlots(
    Map<int, Map<int, List<Map<String, String>>>> apiSchedules,
  ) {
    final result = <int, Map<int, Set<int>>>{};

    for (final staffEntry in apiSchedules.entries) {
      final staffId = staffEntry.key;
      final weekData = staffEntry.value;

      result[staffId] = {};
      for (int day = 1; day <= 7; day++) {
        final shifts = weekData[day] ?? [];
        final slots = <int>{};

        for (final shift in shifts) {
          final startTime = shift['start_time']!;
          final endTime = shift['end_time']!;
          slots.addAll(_timeRangeToSlots(startTime, endTime));
        }

        result[staffId]![day] = slots;
      }
    }

    return result;
  }

  /// Converte HH:MM:SS -> slot index.
  int _timeToSlotIndex(String time) {
    final parts = time.split(':');
    final hours = int.parse(parts[0]);
    final minutes = int.parse(parts[1]);
    return (hours * 60 + minutes) ~/ _minutesPerSlot;
  }

  /// Converte un range orario in set di slot indices.
  Set<int> _timeRangeToSlots(String startTime, String endTime) {
    final startSlot = _timeToSlotIndex(startTime);
    final endSlot = _timeToSlotIndex(endTime);
    return {for (int i = startSlot; i < endSlot; i++) i};
  }

  /// Converte slot index -> HH:MM string.
  String _slotToTime(int slot) {
    final minutes = slot * _minutesPerSlot;
    final h = minutes ~/ 60;
    final m = minutes % 60;
    return '${h.toString().padLeft(2, '0')}:${m.toString().padLeft(2, '0')}';
  }

  /// Converte slots in ranges contigui e poi in formato API.
  List<Map<String, String>> _slotsToApiShifts(Set<int> slots) {
    if (slots.isEmpty) return [];

    final sorted = slots.toList()..sort();
    final ranges = <List<int>>[];
    var current = <int>[sorted.first];

    for (int i = 1; i < sorted.length; i++) {
      if (sorted[i] == sorted[i - 1] + 1) {
        current.add(sorted[i]);
      } else {
        ranges.add(current);
        current = [sorted[i]];
      }
    }
    ranges.add(current);

    return ranges.map((range) {
      final startSlot = range.first;
      final endSlot = range.last + 1; // end √® esclusivo
      return {
        'start_time': _slotToTime(startSlot),
        'end_time': _slotToTime(endSlot),
      };
    }).toList();
  }

  Future<void> saveForStaff(int staffId, Map<int, Set<int>> weeklySlots) async {
    final previousState = state;
    state = const AsyncLoading();

    try {
      final apiClient = ref.read(apiClientProvider);

      // Converti slots in formato API
      final apiSchedule = <int, List<Map<String, String>>>{};
      for (int day = 1; day <= 7; day++) {
        final slots = weeklySlots[day] ?? {};
        apiSchedule[day] = _slotsToApiShifts(slots);
      }

      // Salva su API
      await apiClient.saveStaffSchedule(
        staffId: staffId,
        schedule: apiSchedule,
      );

      // Aggiorna stato locale
      final current = Map<int, Map<int, Set<int>>>.from(
        state.value ?? previousState.value ?? {},
      );
      current[staffId] = {
        for (final e in weeklySlots.entries) e.key: Set<int>.from(e.value),
      };
      state = AsyncData(current);
    } catch (e) {
      // Ripristina stato precedente
      state = previousState;
      rethrow;
    }
  }

  /// Ricarica gli schedules dall'API.
  Future<void> refresh() async {
    ref.invalidateSelf();
  }
}

final staffAvailabilityByStaffProvider =
    AsyncNotifierProvider<
      StaffAvailabilityByStaffNotifier,
      Map<int, Map<int, Set<int>>>
    >(StaffAvailabilityByStaffNotifier.new);

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üñ•Ô∏è Schermata principale: StaffAvailabilityScreen
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class StaffAvailabilityScreen extends ConsumerStatefulWidget {
  const StaffAvailabilityScreen({super.key});

  @override
  ConsumerState<StaffAvailabilityScreen> createState() =>
      _StaffAvailabilityScreenState();
}

class _StaffAvailabilityScreenState
    extends ConsumerState<StaffAvailabilityScreen>
    with SingleTickerProviderStateMixin {
  // Stato locale per staff corrente: selezioni per giorno (slot assoluti)
  Map<int, Set<int>> _weeklySelections = {
    for (int d = 1; d <= 7; d++) d: <int>{},
  };
  // Stato salvato originale per confronto (traccia modifiche non salvate)
  Map<int, Set<int>> _savedWeeklySelections = {
    for (int d = 1; d <= 7; d++) d: <int>{},
  };
  // Mappa staffId -> disponibilit√† settimanale (slots)
  final Map<int, Map<int, Set<int>>> _staffSelections = {};
  int? _selectedStaffId; // definito dopo aver caricato staff list
  bool _initializedFromProvider = false;

  // Tab controller per navigare tra orario settimanale ed eccezioni
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  /// Verifica se ci sono modifiche non salvate.
  bool get _hasUnsavedChanges {
    if (_weeklySelections.length != _savedWeeklySelections.length) return true;
    for (final entry in _weeklySelections.entries) {
      final saved = _savedWeeklySelections[entry.key];
      if (saved == null) return true;
      if (!_setEquals(entry.value, saved)) return true;
    }
    return false;
  }

  bool _setEquals(Set<int> a, Set<int> b) {
    if (a.length != b.length) return false;
    return a.containsAll(b);
  }

  void _ensureCurrentStaffInit(int staffId) {
    _staffSelections.putIfAbsent(staffId, () {
      // Clona la struttura vuota
      return {for (int d = 1; d <= 7; d++) d: <int>{}};
    });
  }

  void _switchStaff(int newStaffId, {bool updateWeeklyState = true}) {
    final currentId = _selectedStaffId;
    if (currentId == newStaffId) return;
    // Salva lo stato corrente nello staff precedente
    if (currentId != null) {
      _staffSelections[currentId] = {
        for (final entry in _weeklySelections.entries)
          entry.key: Set<int>.from(entry.value),
      };
    }
    // Carica stato per nuovo staff (o crea vuoto)
    _ensureCurrentStaffInit(newStaffId);
    final loaded = _staffSelections[newStaffId]!;
    setState(() {
      _selectedStaffId = newStaffId;
      if (updateWeeklyState) {
        _weeklySelections = {
          for (final entry in loaded.entries)
            entry.key: Set<int>.from(entry.value),
        };
        _savedWeeklySelections = {
          for (final entry in loaded.entries)
            entry.key: Set<int>.from(entry.value),
        };
      }
    });
  }

  Future<void> _save(WidgetRef ref, int minutesPerSlot) async {
    // Prima di salvare, unifica le fasce orarie contigue
    final currentSchedule = WeeklySchedule.fromSlots(
      _weeklySelections,
      minutesPerSlot: minutesPerSlot,
    );
    final mergedSchedule = currentSchedule.mergeContiguousShifts();
    final mergedSlots = mergedSchedule.toSlots(minutesPerSlot: minutesPerSlot);

    // Aggiorna lo stato locale con le fasce unificate
    setState(() {
      _weeklySelections = mergedSlots;
    });

    // Persisti nello storage locale per staff corrente
    if (_selectedStaffId != null) {
      _staffSelections[_selectedStaffId!] = {
        for (final entry in mergedSlots.entries)
          entry.key: Set<int>.from(entry.value),
      };
    }
    if (_selectedStaffId != null) {
      await ref
          .read(staffAvailabilityByStaffProvider.notifier)
          .saveForStaff(_selectedStaffId!, mergedSlots);
    }
    // Aggiorna lo stato salvato dopo il salvataggio
    _savedWeeklySelections = {
      for (final entry in mergedSlots.entries)
        entry.key: Set<int>.from(entry.value),
    };
  }

  @override
  Widget build(BuildContext context) {
    final layout = ref.watch(layoutConfigProvider);
    final availabilityByStaff = ref.watch(staffAvailabilityByStaffProvider);
    // Usa lo staff filtrato per la location selezionata nella sezione staff
    final staffList = ref.watch(staffForStaffSectionProvider);

    // If a staffId was requested from another screen, pre-select it once
    final requested = ref.read(initialStaffToEditProvider).value;
    if (_selectedStaffId == null && requested != null && staffList.isNotEmpty) {
      _switchStaff(requested);
      // clear the request to avoid re-applying
      ref.read(initialStaffToEditProvider).value = null;
    }

    // Imposta staff iniziale se non selezionato
    if (_selectedStaffId == null && staffList.isNotEmpty) {
      _switchStaff(staffList.first.id);
    }

    availabilityByStaff.whenOrNull(
      data: (all) {
        if (_initializedFromProvider) return;
        final currentWeekly = (_selectedStaffId != null)
            ? (all[_selectedStaffId!] ?? const <int, Set<int>>{})
            : const <int, Set<int>>{};
        setState(() {
          _weeklySelections = {
            for (final e in currentWeekly.entries)
              e.key: Set<int>.from(e.value),
          };
          // Salva lo stato originale per tracciare modifiche
          _savedWeeklySelections = {
            for (final e in currentWeekly.entries)
              e.key: Set<int>.from(e.value),
          };
          _initializedFromProvider = true;
        });
      },
    );

    final isSaving = availabilityByStaff.isLoading;

    String? staffName;
    if (_selectedStaffId != null && staffList.isNotEmpty) {
      final staff = staffList.firstWhere(
        (s) => s.id == _selectedStaffId,
        orElse: () => staffList.first,
      );
      staffName = '${staff.name} ${staff.surname}'.trim();
    }

    return PopScope(
      canPop: !_hasUnsavedChanges,
      onPopInvokedWithResult: (didPop, result) async {
        if (didPop) return;
        final navigator = Navigator.of(context);
        final shouldPop = await _showDiscardChangesDialog();
        if (shouldPop && mounted) {
          navigator.pop();
        }
      },
      child: Scaffold(
        appBar: AppBar(
          title: Text(
            staffName == null
                ? context.l10n.availabilityTitle
                : context.l10n.availabilityTitleFor(staffName),
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
          bottom: TabBar(
            controller: _tabController,
            tabs: [
              Tab(text: context.l10n.weeklyScheduleTitle),
              Tab(text: context.l10n.exceptionsTitle),
            ],
          ),
        ),
        body: Column(
          children: [
            // ‚îÄ‚îÄ Toolbar azioni ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // Toolbar semplificata: solo selezione staff e salvataggio
            Padding(
              padding: const EdgeInsets.all(12.0),
              child: Wrap(
                spacing: 12,
                runSpacing: 12,
                crossAxisAlignment: WrapCrossAlignment.center,
                children: [
                  Text(context.l10n.labelStaff),
                  _StaffSelectorDropdown(
                    staffList: staffList,
                    selectedStaffId: _selectedStaffId,
                    onSelected: (staffId) => _switchStaff(
                      staffId,
                      updateWeeklyState: _tabController.index == 0,
                    ),
                  ),
                  // Mostra pulsante salva solo nella tab orario settimanale
                  AnimatedBuilder(
                    animation: _tabController,
                    builder: (context, _) {
                      if (_tabController.index != 0) {
                        return const SizedBox.shrink();
                      }
                      return FilledButton(
                        onPressed: (_selectedStaffId == null || isSaving)
                            ? null
                            : () => _save(ref, layout.minutesPerSlot),
                        child: isSaving
                            ? const SizedBox(
                                width: 18,
                                height: 18,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                ),
                              )
                            : Text(context.l10n.availabilitySave),
                      );
                    },
                  ),
                ],
              ),
            ),

            const Divider(height: 1),

            // ‚îÄ‚îÄ TabBarView con editor settimanale ed eccezioni ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            Expanded(
              child: TabBarView(
                controller: _tabController,
                children: [
                  // Tab 1: Editor orario settimanale
                  _buildWeeklyScheduleTab(layout),
                  // Tab 2: Calendario eccezioni
                  if (_selectedStaffId != null)
                    SingleChildScrollView(
                      child: ExceptionCalendarView(staffId: _selectedStaffId!),
                    )
                  else
                    const Center(child: CircularProgressIndicator()),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// Costruisce il tab dell'editor settimanale.
  Widget _buildWeeklyScheduleTab(dynamic layout) {
    final schedule = WeeklySchedule.fromSlots(
      _weeklySelections,
      minutesPerSlot: layout.minutesPerSlot,
    );

    return LayoutBuilder(
      builder: (context, constraints) {
        return Stack(
          children: [
            // Editor turni settimanali (scrollabile) - sotto
            Positioned.fill(
              child: SingleChildScrollView(
                padding: const EdgeInsets.only(
                  top: 80, // Spazio per l'header
                ),
                child: WeeklyScheduleEditor(
                  initialSchedule: WeeklySchedule.fromSlots(
                    _weeklySelections,
                    minutesPerSlot: layout.minutesPerSlot,
                  ),
                  showHeader: false,
                  onChanged: (newSchedule) {
                    final newSlots = newSchedule.toSlots(
                      minutesPerSlot: layout.minutesPerSlot,
                    );
                    setState(() {
                      _weeklySelections = newSlots;
                    });
                  },
                ),
              ),
            ),

            // Header fisso con ombra - sopra
            Positioned(
              top: 0,
              left: 0,
              right: 0,
              child: DecoratedBox(
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.surface,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.1),
                      offset: const Offset(0, 4),
                      blurRadius: 8,
                    ),
                  ],
                ),
                child: Padding(
                  padding: const EdgeInsets.all(16),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text(
                        context.l10n.weeklyScheduleTitle,
                        style: Theme.of(context).textTheme.titleLarge?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        context.l10n.weeklyScheduleTotalHours(
                          schedule.totalHours,
                        ),
                        style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                          color: Theme.of(context).colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ],
        );
      },
    );
  }

  /// Mostra dialog di conferma per scartare le modifiche non salvate.
  Future<bool> _showDiscardChangesDialog() async {
    final l10n = context.l10n;
    final result = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.discardChangesTitle),
        content: Text(l10n.discardChangesMessage),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: Text(l10n.actionDiscard),
          ),
          FilledButton(
            onPressed: () => Navigator.of(context).pop(true),
            child: Text(l10n.actionConfirm),
          ),
        ],
      ),
    );
    return result ?? false;
  }
}

/// Widget per selezione staff con bottom sheet/dialog (come nel form appuntamento)
class _StaffSelectorDropdown extends ConsumerStatefulWidget {
  const _StaffSelectorDropdown({
    required this.staffList,
    required this.selectedStaffId,
    required this.onSelected,
  });

  final List<Staff> staffList;
  final int? selectedStaffId;
  final ValueChanged<int> onSelected;

  @override
  ConsumerState<_StaffSelectorDropdown> createState() =>
      _StaffSelectorDropdownState();
}

class _StaffSelectorDropdownState
    extends ConsumerState<_StaffSelectorDropdown> {
  bool _isHovered = false;

  String _getSelectedLabel() {
    if (widget.selectedStaffId == null) {
      return context.l10n.labelSelect;
    }
    final staff = widget.staffList.firstWhere(
      (s) => s.id == widget.selectedStaffId,
      orElse: () => widget.staffList.first,
    );
    return '${staff.name} ${staff.surname}'.trim();
  }

  Staff? _getSelectedStaff() {
    if (widget.selectedStaffId == null) return null;
    return widget.staffList.firstWhere(
      (s) => s.id == widget.selectedStaffId,
      orElse: () => widget.staffList.first,
    );
  }

  Future<void> _showPicker() async {
    final result = await showStaffPickerSheet(
      context: context,
      ref: ref,
      staff: widget.staffList,
      selectedId: widget.selectedStaffId,
    );
    if (result != null) {
      widget.onSelected(result);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final interactions = theme.extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = _isHovered
        ? Color.alphaBlend(hoverFill, colorScheme.surface)
        : colorScheme.surface;

    final selectedStaff = _getSelectedStaff();

    return MouseRegion(
      onEnter: (_) {
        if (!_isHovered) setState(() => _isHovered = true);
      },
      onExit: (_) {
        if (_isHovered) setState(() => _isHovered = false);
      },
      child: GestureDetector(
        onTap: _showPicker,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          decoration: BoxDecoration(
            color: backgroundColor,
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: colorScheme.outline.withOpacity(0.3)),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              if (selectedStaff != null) ...[
                StaffCircleAvatar(
                  height: 28,
                  color: selectedStaff.color,
                  isHighlighted: false,
                  initials: selectedStaff.initials,
                ),
                const SizedBox(width: 8),
              ],
              Text(_getSelectedLabel(), style: theme.textTheme.bodyMedium),
              const SizedBox(width: 8),
              Icon(
                Icons.keyboard_arrow_down,
                size: 20,
                color: colorScheme.onSurfaceVariant,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/staff_screen.dart ---
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/l10_extension.dart';
import 'widgets/staff_hub_card.dart';

class StaffScreen extends StatelessWidget {
  const StaffScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    return Scaffold(
      body: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              l10n.staffScreenPlaceholder,
              style: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 24),
            Wrap(
              spacing: 16,
              runSpacing: 16,
              children: [
                StaffHubCard(
                  icon: Icons.schedule,
                  title: l10n.staffHubAvailabilityTitle,
                  subtitle: l10n.staffHubAvailabilitySubtitle,
                  onTap: () => context.go('/staff/availability'),
                ),
                StaffHubCard(
                  icon: Icons.group,
                  title: l10n.staffHubTeamTitle,
                  subtitle: l10n.staffHubTeamSubtitle,
                  onTap: () {},
                  disabled: true,
                ),
                StaffHubCard(
                  icon: Icons.insights,
                  title: l10n.staffHubStatsTitle,
                  subtitle: l10n.staffHubStatsSubtitle,
                  onTap: () {},
                  disabled: true,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/team_screen.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/location.dart';
import 'package:agenda_backend/core/models/staff.dart';
import 'package:agenda_backend/core/widgets/app_dialogs.dart';
import 'package:agenda_backend/core/widgets/reorder_toggle_button.dart';
import 'package:agenda_backend/core/widgets/reorder_toggle_panel.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../agenda/providers/location_providers.dart';
import '../providers/staff_providers.dart';
import '../providers/staff_reorder_provider.dart';
import '../providers/staff_sorted_providers.dart';
import 'dialogs/location_dialog.dart';
import 'dialogs/staff_dialog.dart';
import 'widgets/location_item.dart';

class TeamScreen extends ConsumerStatefulWidget {
  const TeamScreen({super.key});

  @override
  ConsumerState<TeamScreen> createState() => _TeamScreenState();
}

class _TeamScreenState extends ConsumerState<TeamScreen> {
  final ScrollController _scrollController = ScrollController();
  bool isReorderLocations = false;
  bool isReorderStaff = false;

  // NOTE: Non serve initState con refresh() perch√©:
  // 1. I provider AsyncNotifier caricano i dati automaticamente nel build()
  // 2. Il refresh al cambio tab avviene in _refreshProvidersForTab()

  void _toggleLocationReorder() {
    setState(() {
      isReorderLocations = !isReorderLocations;
      if (isReorderLocations) isReorderStaff = false;
    });
    if (!isReorderLocations) {
      ref.read(teamReorderPanelProvider.notifier).setVisible(false);
    }
  }

  void _toggleStaffReorder() {
    setState(() {
      isReorderStaff = !isReorderStaff;
      if (isReorderStaff) isReorderLocations = false;
    });
    if (!isReorderStaff) {
      ref.read(teamReorderPanelProvider.notifier).setVisible(false);
    }
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final locations = ref.watch(sortedLocationsProvider);
    final staffAsync = ref.watch(allStaffProvider);
    final isWide = ref.watch(formFactorProvider) != AppFormFactor.mobile;
    final showReorderPanel = ref.watch(teamReorderPanelProvider);

    ref.listen<bool>(teamReorderPanelProvider, (previous, next) {
      if (!next && (isReorderLocations || isReorderStaff)) {
        setState(() {
          isReorderLocations = false;
          isReorderStaff = false;
        });
      }
      // Se apro il pannello e c'√® solo 1 location, attiva subito riordino staff
      if (next && previous == false && locations.length < 2) {
        setState(() {
          isReorderStaff = true;
          isReorderLocations = false;
        });
      }
    });

    // Mostra loading mentre carica staff
    if (staffAsync.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (locations.isEmpty) {
      return const SizedBox.shrink();
    }

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: () {},
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (showReorderPanel) ...[
            Builder(
              builder: (context) {
                // Conta lo staff totale
                final totalStaffCount = staffAsync.value?.length ?? 0;
                final showLocationReorder = locations.length >= 2;
                final showStaffReorder = totalStaffCount >= 2;

                return Padding(
                  padding: const EdgeInsets.all(16),
                  child: Center(
                    child: Column(
                      children: [
                        Text(
                          context.l10n.reorderTitle,
                          style: Theme.of(context).textTheme.titleSmall
                              ?.copyWith(fontWeight: FontWeight.w600),
                        ),
                        Padding(
                          padding: const EdgeInsets.fromLTRB(0, 4, 0, 8),
                          child: Text(
                            context.l10n.teamReorderHelpDescription,
                            style: Theme.of(context).textTheme.bodySmall
                                ?.copyWith(
                                  color: Theme.of(
                                    context,
                                  ).colorScheme.onSurfaceVariant,
                                ),
                          ),
                        ),
                        ReorderTogglePanel(
                          isWide: isWide,
                          children: [
                            if (showLocationReorder)
                              ReorderToggleButton(
                                isActive: isReorderLocations,
                                onPressed: _toggleLocationReorder,
                                activeLabel: context.l10n.teamLocationsLabel,
                                inactiveLabel: context.l10n.teamLocationsLabel,
                                activeIcon: Icons.check,
                                inactiveIcon: Icons.drag_indicator,
                              ),
                            if (showStaffReorder)
                              ReorderToggleButton(
                                isActive: isReorderStaff,
                                onPressed: _toggleStaffReorder,
                                activeLabel: context.l10n.teamStaffLabel,
                                inactiveLabel: context.l10n.teamStaffLabel,
                                activeIcon: Icons.check,
                                inactiveIcon: Icons.drag_indicator,
                              ),
                          ],
                        ),
                      ],
                    ),
                  ),
                );
              },
            ),
          ],
          Expanded(
            child: isReorderLocations
                ? _buildReorderLocations(context, ref, locations)
                : isReorderStaff
                ? _buildReorderStaff(context, ref, locations)
                : _buildNormalList(context, ref, locations, isWide),
          ),
        ],
      ),
    );
  }

  Widget _buildReorderLocations(
    BuildContext context,
    WidgetRef ref,
    List<Location> locations,
  ) {
    final notifier = ref.read(teamReorderProvider.notifier);
    final colorScheme = Theme.of(context).colorScheme;
    return ReorderableListView.builder(
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 100),
      buildDefaultDragHandles: false,
      proxyDecorator: (child, index, animation) => child,
      itemCount: locations.length,
      onReorder: (oldIndex, newIndex) =>
          notifier.reorderLocations(oldIndex, newIndex),
      itemBuilder: (context, index) {
        final loc = locations[index];
        return Container(
          key: ValueKey('loc-${loc.id}'),
          margin: const EdgeInsets.only(bottom: 16),
          decoration: BoxDecoration(
            color: colorScheme.surface,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: colorScheme.outlineVariant.withOpacity(0.4),
            ),
          ),
          child: ListTile(
            leading: ReorderableDragStartListener(
              index: index,
              child: const Icon(Icons.drag_indicator),
            ),
            title: Text(loc.name),
          ),
        );
      },
    );
  }

  Widget _buildReorderStaff(
    BuildContext context,
    WidgetRef ref,
    List<Location> locations,
  ) {
    final notifier = ref.read(teamReorderProvider.notifier);
    final colorScheme = Theme.of(context).colorScheme;

    final staffByLocation = <int, List<Staff>>{
      for (final loc in locations)
        loc.id: ref.watch(staffByLocationProvider(loc.id)),
    };

    final rows = <({bool isHeader, int locationId, Staff? staff})>[];
    for (final loc in locations) {
      rows.add((isHeader: true, locationId: loc.id, staff: null));
      for (final member in staffByLocation[loc.id] ?? const <Staff>[]) {
        rows.add((isHeader: false, locationId: loc.id, staff: member));
      }
    }

    int indexInLocation(int rowIndex) {
      final locationId = rows[rowIndex].locationId;
      int count = 0;
      for (int i = 0; i < rowIndex; i++) {
        final row = rows[i];
        if (!row.isHeader && row.locationId == locationId) count++;
      }
      return count;
    }

    return ReorderableListView.builder(
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 100),
      buildDefaultDragHandles: false,
      proxyDecorator: (child, index, animation) => child,
      itemCount: rows.length,
      onReorder: (oldIndex, newIndex) {
        if (newIndex > oldIndex) newIndex -= 1;
        if (newIndex >= rows.length) newIndex = rows.length - 1;
        final moving = rows[oldIndex];
        if (moving.isHeader) return;
        if (rows[newIndex].isHeader) {
          if (rows[newIndex].locationId == moving.locationId) {
            newIndex = (newIndex + 1).clamp(0, rows.length - 1);
          } else {
            return;
          }
        }
        final target = rows[newIndex];
        if (target.locationId != moving.locationId) return;
        notifier.reorderStaffForLocation(
          moving.locationId,
          indexInLocation(oldIndex),
          indexInLocation(newIndex),
        );
      },
      itemBuilder: (context, index) {
        final row = rows[index];
        if (row.isHeader) {
          final loc = locations.firstWhere((l) => l.id == row.locationId);
          return Container(
            key: ValueKey('header-${loc.id}'),
            width: double.infinity,
            margin: const EdgeInsets.only(top: 16, bottom: 6),
            decoration: BoxDecoration(
              color: colorScheme.primaryContainer,
              borderRadius: const BorderRadius.vertical(
                top: Radius.circular(16),
              ),
            ),
            padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),
            child: Text(
              loc.name,
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
                color: colorScheme.onPrimaryContainer,
              ),
            ),
          );
        }

        final member = row.staff!;
        return Container(
          key: ValueKey('staff-${row.locationId}-${member.id}'),
          margin: const EdgeInsets.only(bottom: 6),
          decoration: BoxDecoration(
            color: colorScheme.surface,
            borderRadius: BorderRadius.circular(10),
            border: Border.all(
              color: colorScheme.outlineVariant.withOpacity(0.7),
            ),
          ),
          child: ListTile(
            leading: ReorderableDragStartListener(
              index: index,
              child: const Icon(Icons.drag_indicator),
            ),
            title: Text(member.displayName),
            dense: true,
            contentPadding: const EdgeInsets.symmetric(
              horizontal: 12,
              vertical: 4,
            ),
          ),
        );
      },
    );
  }

  Widget _buildNormalList(
    BuildContext context,
    WidgetRef ref,
    List<Location> locations,
    bool isWide,
  ) {
    return ListView.builder(
      controller: _scrollController,
      padding: const EdgeInsets.fromLTRB(16, 0, 16, 24),
      itemCount: locations.length,
      itemBuilder: (context, index) {
        final loc = locations[index];
        final staff = ref.watch(staffByLocationProvider(loc.id));
        return LocationItem(
          location: loc,
          staff: staff,
          isWide: isWide,
          onAddStaff: () =>
              showStaffDialog(context, ref, initialLocationId: loc.id),
          onEditLocation: () => showLocationDialog(context, ref, initial: loc),
          onDeleteLocation: () async {
            if (staff.isNotEmpty) {
              await showAppInfoDialog(
                context,
                title: Text(context.l10n.teamDeleteLocationBlockedTitle),
                content: Text(context.l10n.teamDeleteLocationBlockedMessage),
              );
              return;
            }
            final confirmed = await showConfirmDialog(
              context,
              title: Text(context.l10n.teamDeleteLocationTitle),
              content: Text(context.l10n.teamDeleteLocationMessage),
              confirmLabel: context.l10n.actionConfirm,
              cancelLabel: context.l10n.actionCancel,
            );
            if (confirmed == true) {
              final currentId = ref.read(currentLocationIdProvider);
              await ref
                  .read(locationsProvider.notifier)
                  .deleteLocation(loc.id, currentLocationId: currentId);
            }
          },
          onEditStaff: (staff) => showStaffDialog(context, ref, initial: staff),
          onDuplicateStaff: (staff) => showStaffDialog(
            context,
            ref,
            initial: staff,
            duplicateFrom: true,
          ),
          onDeleteStaff: (staff) async {
            final confirmed = await showConfirmDialog(
              context,
              title: Text(context.l10n.teamDeleteStaffTitle),
              content: Text(context.l10n.teamDeleteStaffMessage),
              confirmLabel: context.l10n.actionConfirm,
              cancelLabel: context.l10n.actionCancel,
            );
            if (confirmed == true) {
              await ref
                  .read(allStaffProvider.notifier)
                  .deleteStaffApi(staff.id);
            }
          },
        );
      },
    );
  }
}
--- FILE: lib/features/staff/presentation/dialogs/add_exception_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:agenda_backend/core/widgets/app_bottom_sheet.dart';
import 'package:agenda_backend/core/widgets/labeled_form_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/availability_exception.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../agenda/providers/layout_config_provider.dart';
import '../../presentation/staff_availability_screen.dart';
import '../../providers/availability_exceptions_provider.dart';
import 'package:intl/intl.dart';

/// Mostra il dialog per creare o modificare un'eccezione alla disponibilit√†.
Future<void> showAddExceptionDialog(
  BuildContext context,
  WidgetRef ref, {
  AvailabilityException? initial,
  DateTime? date,
  TimeOfDay? time,
  required int staffId,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final isDesktop = formFactor == AppFormFactor.desktop;

  final dialog = _AddExceptionDialog(
    initial: initial,
    initialDate: date,
    initialTime: time,
    staffId: staffId,
    presentation: isDesktop
        ? _ExceptionDialogPresentation.dialog
        : _ExceptionDialogPresentation.bottomSheet,
  );

  if (isDesktop) {
    await showDialog(context: context, builder: (_) => dialog);
  } else {
    await AppBottomSheet.show(
      context: context,
      useRootNavigator: true,
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 20),
      builder: (_) => dialog,
    );
  }
}

enum _ExceptionDialogPresentation { dialog, bottomSheet }

/// Modalit√† di selezione del periodo
enum _PeriodMode { single, range, duration }

class _AddExceptionDialog extends ConsumerStatefulWidget {
  const _AddExceptionDialog({
    this.initial,
    this.initialDate,
    this.initialTime,
    required this.staffId,
    required this.presentation,
  });

  final AvailabilityException? initial;
  final DateTime? initialDate;
  final TimeOfDay? initialTime;
  final int staffId;
  final _ExceptionDialogPresentation presentation;

  @override
  ConsumerState<_AddExceptionDialog> createState() =>
      _AddExceptionDialogState();
}

class _AddExceptionDialogState extends ConsumerState<_AddExceptionDialog> {
  // Modalit√† periodo (solo per nuove eccezioni)
  _PeriodMode _periodMode = _PeriodMode.single;

  // Date
  late DateTime _date; // Per singolo giorno
  late DateTime _startDate; // Per range/durata
  late DateTime _endDate; // Per range
  int _durationDays = 7; // Per durata

  // Orari
  late TimeOfDay _startTime;
  late TimeOfDay _endTime;
  late AvailabilityExceptionType _type;
  final _reasonController = TextEditingController();
  String? _timeError;
  String? _validationError;
  bool _isSaving = false;
  Map<DateTime, String> _lastSkippedReasons = {};

  @override
  void initState() {
    super.initState();

    if (widget.initial != null) {
      final exc = widget.initial!;
      _date = DateTime(exc.date.year, exc.date.month, exc.date.day);
      _startDate = _date;
      _endDate = _date;
      if (exc.isAllDay) {
        _startTime = const TimeOfDay(hour: 0, minute: 0);
        _endTime = const TimeOfDay(hour: 24, minute: 0);
      } else {
        _startTime = exc.startTime ?? const TimeOfDay(hour: 9, minute: 0);
        _endTime = exc.endTime ?? const TimeOfDay(hour: 18, minute: 0);
      }
      _type = exc.type;
      _reasonController.text = exc.reason ?? '';
    } else {
      _date = DateUtils.dateOnly(widget.initialDate ?? DateTime.now());
      _startDate = _date;
      _endDate = _date.add(const Duration(days: 6)); // Default 1 settimana
      _startTime = widget.initialTime ?? const TimeOfDay(hour: 9, minute: 0);
      _endTime = TimeOfDay(
        hour: _startTime.hour + 1,
        minute: _startTime.minute,
      );
      _type = AvailabilityExceptionType.unavailable;
    }
  }

  @override
  void dispose() {
    _reasonController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final isEdit = widget.initial != null;
    final isDialog = widget.presentation == _ExceptionDialogPresentation.dialog;

    final title = isEdit
        ? l10n.exceptionDialogTitleEdit
        : l10n.exceptionDialogTitleNew;

    final content = Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Tipo eccezione
        LabeledFormField(
          label: l10n.exceptionType,
          child: SegmentedButton<AvailabilityExceptionType>(
            segments: [
              ButtonSegment(
                value: AvailabilityExceptionType.unavailable,
                label: Text(l10n.exceptionTypeUnavailable),
                icon: const Icon(Icons.block, size: 18),
              ),
              ButtonSegment(
                value: AvailabilityExceptionType.available,
                label: Text(l10n.exceptionTypeAvailable),
                icon: const Icon(Icons.check_circle_outline, size: 18),
              ),
            ],
            selected: {_type},
            onSelectionChanged: (selected) {
              setState(() {
                _type = selected.first;
                _validationError = null;
              });
            },
          ),
        ),
        const SizedBox(height: 16),

        // Modalit√† periodo (solo per nuove eccezioni)
        if (!isEdit) ...[
          LabeledFormField(
            label: l10n.exceptionPeriodMode,
            child: SegmentedButton<_PeriodMode>(
              segments: [
                ButtonSegment(
                  value: _PeriodMode.single,
                  label: Text(l10n.exceptionPeriodSingle),
                ),
                ButtonSegment(
                  value: _PeriodMode.range,
                  label: Text(l10n.exceptionPeriodRange),
                ),
                ButtonSegment(
                  value: _PeriodMode.duration,
                  label: Text(l10n.exceptionPeriodDuration),
                ),
              ],
              selected: {_periodMode},
              onSelectionChanged: (selected) {
                setState(() {
                  _periodMode = selected.first;
                  _validationError = null;
                });
              },
            ),
          ),
          const SizedBox(height: 16),
        ],

        // Sezione date in base alla modalit√†
        if (isEdit || _periodMode == _PeriodMode.single) ...[
          // Data singola
          LabeledFormField(
            label: l10n.formDate,
            child: InkWell(
              onTap: () => _pickSingleDate(),
              child: InputDecorator(
                decoration: const InputDecoration(
                  border: OutlineInputBorder(),
                  isDense: true,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(_formatDate(_date)),
                    const Icon(Icons.calendar_today, size: 16),
                  ],
                ),
              ),
            ),
          ),
        ] else if (_periodMode == _PeriodMode.range) ...[
          // Range date: Da - A
          Row(
            children: [
              Expanded(
                child: LabeledFormField(
                  label: l10n.exceptionDateFrom,
                  child: InkWell(
                    onTap: () => _pickStartDate(),
                    child: InputDecorator(
                      decoration: const InputDecoration(
                        border: OutlineInputBorder(),
                        isDense: true,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_formatDate(_startDate)),
                          const Icon(Icons.calendar_today, size: 16),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: LabeledFormField(
                  label: l10n.exceptionDateTo,
                  child: InkWell(
                    onTap: () => _pickEndDate(),
                    child: InputDecorator(
                      decoration: const InputDecoration(
                        border: OutlineInputBorder(),
                        isDense: true,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_formatDate(_endDate)),
                          const Icon(Icons.calendar_today, size: 16),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
          // Info giorni totali
          Padding(
            padding: const EdgeInsets.only(top: 8),
            child: Text(
              l10n.exceptionDurationDays(_calculateDays()),
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.primary,
              ),
            ),
          ),
        ] else if (_periodMode == _PeriodMode.duration) ...[
          // Durata: Data inizio + numero giorni
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                flex: 2,
                child: LabeledFormField(
                  label: l10n.exceptionDateFrom,
                  child: InkWell(
                    onTap: () => _pickStartDate(),
                    child: InputDecorator(
                      decoration: const InputDecoration(
                        border: OutlineInputBorder(),
                        isDense: true,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_formatDate(_startDate)),
                          const Icon(Icons.calendar_today, size: 16),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: LabeledFormField(
                  label: l10n.exceptionDuration,
                  child: _DurationDropdown(
                    value: _durationDays,
                    onChanged: (v) => setState(() {
                      _durationDays = v;
                      _validationError = null;
                    }),
                  ),
                ),
              ),
            ],
          ),
          // Info data fine calcolata
          Padding(
            padding: const EdgeInsets.only(top: 8),
            child: Text(
              '‚Üí ${_formatDate(_startDate.add(Duration(days: _durationDays - 1)))}',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.primary,
              ),
            ),
          ),
        ],
        const SizedBox(height: 12),

        // Orari
        Row(
          children: [
            Expanded(
              child: LabeledFormField(
                label: l10n.exceptionStartTime,
                child: InkWell(
                  onTap: () => _pickTime(isStart: true),
                  child: InputDecorator(
                    decoration: InputDecoration(
                      border: const OutlineInputBorder(),
                      isDense: true,
                      enabledBorder: _timeError != null
                          ? OutlineInputBorder(
                              borderSide: BorderSide(
                                color: Theme.of(context).colorScheme.error,
                              ),
                            )
                          : null,
                    ),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Text(_formatTime(_startTime)),
                        const Icon(Icons.schedule, size: 16),
                      ],
                    ),
                  ),
                ),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: LabeledFormField(
                label: l10n.exceptionEndTime,
                child: InkWell(
                  onTap: () => _pickTime(isStart: false),
                  child: InputDecorator(
                    decoration: InputDecoration(
                      border: const OutlineInputBorder(),
                      isDense: true,
                      enabledBorder: _timeError != null
                          ? OutlineInputBorder(
                              borderSide: BorderSide(
                                color: Theme.of(context).colorScheme.error,
                              ),
                            )
                          : null,
                    ),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Text(_formatTime(_endTime)),
                        const Icon(Icons.schedule, size: 16),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
        if (_timeError != null)
          Padding(
            padding: const EdgeInsets.only(top: 6, left: 12),
            child: Text(
              _timeError!,
              style: TextStyle(
                color: Theme.of(context).colorScheme.error,
                fontSize: 12,
              ),
            ),
          ),
        if (_validationError != null)
          Padding(
            padding: const EdgeInsets.only(top: 6, left: 12),
            child: Text(
              _validationError!,
              style: TextStyle(
                color: Theme.of(context).colorScheme.error,
                fontSize: 12,
              ),
            ),
          ),
        const SizedBox(height: 12),

        // Motivo opzionale
        LabeledFormField(
          label: l10n.exceptionReason,
          child: TextField(
            controller: _reasonController,
            decoration: InputDecoration(
              hintText: l10n.exceptionReasonHint,
              border: const OutlineInputBorder(),
              isDense: true,
            ),
          ),
        ),
      ],
    );

    final actions = [
      if (isEdit)
        AppDangerButton(
          onPressed: _isSaving ? null : _onDelete,
          padding: AppButtonStyles.dialogButtonPadding,
          child: Text(l10n.actionDelete),
        ),
      AppOutlinedActionButton(
        onPressed: _isSaving ? null : () => Navigator.of(context).pop(),
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppFilledButton(
        onPressed: _isSaving ? null : _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        child: _isSaving
            ? const SizedBox(
                width: 16,
                height: 16,
                child: CircularProgressIndicator(strokeWidth: 2),
              )
            : Text(l10n.actionSave),
      ),
    ];

    final bottomActions = actions
        .map(
          (a) => SizedBox(width: AppButtonStyles.dialogButtonWidth, child: a),
        )
        .toList();

    if (isDialog) {
      return DismissibleDialog(
        child: Dialog(
          insetPadding: const EdgeInsets.symmetric(
            horizontal: 32,
            vertical: 24,
          ),
          child: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 500, maxWidth: 600),
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text(title, style: Theme.of(context).textTheme.headlineSmall),
                  const SizedBox(height: 16),
                  Flexible(child: SingleChildScrollView(child: content)),
                  const SizedBox(height: 24),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      if (isEdit) ...[
                        bottomActions.first,
                        const Spacer(),
                        bottomActions[1],
                      ] else
                        bottomActions[0],
                      const SizedBox(width: 8),
                      bottomActions.last,
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      );
    }

    return SafeArea(
      top: false,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final isKeyboardOpen =
              MediaQuery.of(context).viewInsets.bottom > 0;
          return SizedBox(
            height: constraints.maxHeight,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Expanded(
                  child: SingleChildScrollView(
                    padding: EdgeInsets.zero,
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Padding(
                          padding: const EdgeInsets.only(bottom: 12),
                          child: Text(
                            title,
                            style: Theme.of(context).textTheme.titleLarge,
                          ),
                        ),
                        content,
                        const SizedBox(height: 24),
                        const SizedBox(height: AppSpacing.formRowSpacing),
                      ],
                    ),
                  ),
                ),
                if (!isKeyboardOpen) ...[
                  const AppBottomSheetDivider(),
                  Padding(
                    padding: const EdgeInsets.fromLTRB(0, 12, 0, 0),
                    child: Align(
                      alignment: bottomActions.length == 3
                          ? Alignment.center
                          : Alignment.centerRight,
                      child: Wrap(
                        alignment: bottomActions.length == 3
                            ? WrapAlignment.center
                            : WrapAlignment.end,
                        spacing: 8,
                        runSpacing: 8,
                        children: bottomActions,
                      ),
                    ),
                  ),
                ],
                SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
              ],
            ),
          );
        },
      ),
    );
  }

  String _formatTime(TimeOfDay time) {
    return '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';
  }

  String _formatDate(DateTime date) {
    return '${date.day.toString().padLeft(2, '0')}/${date.month.toString().padLeft(2, '0')}/${date.year}';
  }

  int _calculateDays() {
    return _endDate.difference(_startDate).inDays + 1;
  }

  Future<void> _pickSingleDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _date,
      firstDate: DateTime.now().subtract(const Duration(days: 30)),
      lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
    );
    if (picked != null) {
      setState(() {
        _date = DateUtils.dateOnly(picked);
        _validationError = null;
      });
    }
  }

  Future<void> _pickStartDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _startDate,
      firstDate: DateTime.now().subtract(const Duration(days: 30)),
      lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
    );
    if (picked != null) {
      setState(() {
        _startDate = DateUtils.dateOnly(picked);
        _validationError = null;
        // Se la data di fine √® prima della data di inizio, aggiornala
        if (_endDate.isBefore(_startDate)) {
          _endDate = _startDate.add(Duration(days: _durationDays - 1));
        }
      });
    }
  }

  Future<void> _pickEndDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _endDate.isBefore(_startDate) ? _startDate : _endDate,
      firstDate: _startDate,
      lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
    );
    if (picked != null) {
      setState(() {
        _endDate = DateUtils.dateOnly(picked);
        _validationError = null;
      });
    }
  }

  Future<void> _pickTime({required bool isStart}) async {
    final step = ref.read(layoutConfigProvider).minutesPerSlot;
    final selected = await AppBottomSheet.show<TimeOfDay>(
      context: context,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      builder: (ctx) {
        final height = MediaQuery.of(ctx).size.height * 0.7;
        return SizedBox(
          height: height,
          child: _TimeGridPicker(
            initial: isStart ? _startTime : _endTime,
            stepMinutes: step,
          ),
        );
      },
    );
    if (selected != null) {
      setState(() {
        _timeError = null;
        _validationError = null;
        if (isStart) {
          _startTime = selected;
          // Se l'orario di fine √® prima dell'inizio, aggiustalo
          final startMinutes = _startTime.hour * 60 + _startTime.minute;
          final endMinutes = _endTime.hour * 60 + _endTime.minute;
          if (endMinutes <= startMinutes) {
            _endTime = TimeOfDay(
              hour: (_startTime.hour + 1).clamp(0, 23),
              minute: _startTime.minute,
            );
          }
        } else {
          _endTime = selected;
        }
      });
    }
  }

  List<DateTime>? _validatedDates() {
    final l10n = context.l10n;
    setState(() {
      _validationError = null;
      _timeError = null;
    });

    final startMinutes = _startTime.hour * 60 + _startTime.minute;
    final endMinutes = _endTime.hour * 60 + _endTime.minute;
    if (endMinutes <= startMinutes) {
      setState(() => _timeError = l10n.exceptionTimeError);
      return null;
    }

    final availabilityByStaff =
        ref.read(staffAvailabilityByStaffProvider).value;
    if (availabilityByStaff == null) {
      if (widget.initial != null || _periodMode == _PeriodMode.single) {
        return <DateTime>[_date];
      }
      final DateTime startDate;
      final DateTime endDate;
      if (_periodMode == _PeriodMode.range) {
        startDate = _startDate;
        endDate = _endDate;
      } else {
        startDate = _startDate;
        endDate = _startDate.add(Duration(days: _durationDays - 1));
      }
      final dates = <DateTime>[];
      for (var d = startDate;
          !d.isAfter(endDate);
          d = d.add(const Duration(days: 1))) {
        dates.add(d);
      }
      return dates;
    }

    final layout = ref.read(layoutConfigProvider);
    final minutesPerSlot = layout.minutesPerSlot;

    Set<int> exceptionSlots() {
      final startMinutes = _startTime.hour * 60 + _startTime.minute;
      final endMinutes = _endTime.hour * 60 + _endTime.minute;
      final startSlot = startMinutes ~/ minutesPerSlot;
      final endSlot = endMinutes ~/ minutesPerSlot;
      return {for (int i = startSlot; i < endSlot; i++) i};
    }

    String? validateDate(DateTime date) {
      final baseSlots =
          availabilityByStaff[widget.staffId]?[date.weekday] ?? <int>{};
      final excSlots = exceptionSlots();
      if (_type == AvailabilityExceptionType.unavailable) {
        if (baseSlots.isEmpty) {
          return l10n.exceptionUnavailableNoBase;
        }
        if (baseSlots.intersection(excSlots).isEmpty) {
          return l10n.exceptionUnavailableNoOverlap;
        }
      } else {
        if (excSlots.difference(baseSlots).isEmpty) {
          return l10n.exceptionAvailableNoEffect;
        }
      }
      return null;
    }

    if (widget.initial != null || _periodMode == _PeriodMode.single) {
      final error = validateDate(_date);
      if (error != null) {
        setState(() => _validationError = error);
        return null;
      }
      return <DateTime>[_date];
    }

    final DateTime startDate;
    final DateTime endDate;
    if (_periodMode == _PeriodMode.range) {
      startDate = _startDate;
      endDate = _endDate;
    } else {
      startDate = _startDate;
      endDate = _startDate.add(Duration(days: _durationDays - 1));
    }

    final validDates = <DateTime>[];
    final skippedReasons = <DateTime, String>{};
    String? firstError;
    for (var d = startDate;
        !d.isAfter(endDate);
        d = d.add(const Duration(days: 1))) {
      final error = validateDate(d);
      if (error == null) {
        validDates.add(d);
      } else {
        firstError ??= error;
        skippedReasons[d] = error;
      }
    }

    if (validDates.isEmpty) {
      setState(() => _validationError = firstError);
      return null;
    }

    _lastSkippedReasons = {
      for (final entry in skippedReasons.entries)
        DateUtils.dateOnly(entry.key): entry.value,
    };
    return validDates;
  }

  Future<void> _onSave() async {
    final validDates = _validatedDates();
    if (validDates == null || validDates.isEmpty) return;

    setState(() => _isSaving = true);

    try {
      final notifier = ref.read(availabilityExceptionsProvider.notifier);
      final reason = _reasonController.text.trim();

      if (widget.initial != null) {
        // Modifica eccezione esistente (solo singolo giorno)
        final updated = widget.initial!.copyWith(
          date: validDates.first,
          startTime: _startTime,
          endTime: _endTime,
          type: _type,
          reason: reason.isEmpty ? null : reason,
          clearReason: reason.isEmpty,
        );
        await notifier.updateException(updated);
      } else {
        // Nuova eccezione - gestisci in base alla modalit√†
        if (_periodMode == _PeriodMode.single) {
          // Singolo giorno
          await notifier.addException(
            staffId: widget.staffId,
            date: validDates.first,
            startTime: _startTime,
            endTime: _endTime,
            type: _type,
            reason: reason.isEmpty ? null : reason,
          );
        } else {
          // Periodo (range o durata) - salva solo le date congruenti
          final DateTime startDate;
          final DateTime endDate;
          if (_periodMode == _PeriodMode.range) {
            startDate = _startDate;
            endDate = _endDate;
          } else {
            startDate = _startDate;
            endDate = _startDate.add(Duration(days: _durationDays - 1));
          }
          var totalDays = 0;
          final skippedDates = <DateTime>[];
          final skippedDetails = <String>[];
          for (var d = startDate;
              !d.isAfter(endDate);
              d = d.add(const Duration(days: 1))) {
            totalDays++;
          }
          for (final d in validDates) {
            await notifier.addException(
              staffId: widget.staffId,
              date: d,
              startTime: _startTime,
              endTime: _endTime,
              type: _type,
              reason: reason.isEmpty ? null : reason,
            );
          }
          if (validDates.length < totalDays) {
            for (var d = startDate;
                !d.isAfter(endDate);
                d = d.add(const Duration(days: 1))) {
              final isValid = validDates.any(
                (v) => DateUtils.isSameDay(v, d),
              );
              if (!isValid) {
                skippedDates.add(d);
              }
            }
          }
          if (mounted && skippedDates.isNotEmpty) {
            final locale = Localizations.localeOf(context).toLanguageTag();
            final formatter = DateFormat('d MMM', locale);
            for (final d in skippedDates) {
              final reason =
                  _lastSkippedReasons[DateUtils.dateOnly(d)] ?? '';
              final dateLabel = formatter.format(d);
              if (reason.isEmpty) {
                skippedDetails.add(dateLabel);
              } else {
                skippedDetails.add('$dateLabel ‚Äî $reason');
              }
            }
            await showDialog<void>(
              context: context,
              builder: (ctx) => AlertDialog(
                title: Text(ctx.l10n.exceptionPartialSaveTitle),
                content: SizedBox(
                  width: 420,
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(ctx.l10n.exceptionPartialSaveMessage),
                      const SizedBox(height: 12),
                      ConstrainedBox(
                        constraints: const BoxConstraints(maxHeight: 240),
                        child: ListView.separated(
                          shrinkWrap: true,
                          itemCount: skippedDetails.length,
                          separatorBuilder: (_, __) => const SizedBox(height: 6),
                          itemBuilder: (context, index) => Text(
                            '‚Ä¢ ${skippedDetails[index]}',
                            style: Theme.of(context).textTheme.bodySmall,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
                actions: [
                  TextButton(
                    onPressed: () => Navigator.of(ctx).pop(),
                    child: Text(ctx.l10n.actionConfirm),
                  ),
                ],
              ),
            );
          }
        }
      }

      if (mounted) {
        Navigator.of(context).pop();
      }
    } finally {
      if (mounted) {
        setState(() => _isSaving = false);
      }
    }
  }

  Future<void> _onDelete() async {
    if (widget.initial == null) return;

    final l10n = context.l10n;
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.exceptionDeleteTitle),
        content: Text(l10n.exceptionDeleteMessage),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(false),
            child: Text(l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () => Navigator.of(ctx).pop(true),
            style: FilledButton.styleFrom(
              backgroundColor: Theme.of(ctx).colorScheme.error,
            ),
            child: Text(l10n.actionDelete),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await ref
          .read(availabilityExceptionsProvider.notifier)
          .deleteException(widget.staffId, widget.initial!.id);

      if (mounted) {
        Navigator.of(context).pop();
      }
    }
  }
}

/// Semplice picker griglia per selezionare un orario.
class _TimeGridPicker extends StatefulWidget {
  const _TimeGridPicker({required this.initial, required this.stepMinutes});

  final TimeOfDay initial;
  final int stepMinutes;

  @override
  State<_TimeGridPicker> createState() => _TimeGridPickerState();
}

class _TimeGridPickerState extends State<_TimeGridPicker> {
  late TimeOfDay _selected;
  late final ScrollController _scrollController;
  late final List<TimeOfDay?> _times;
  late final int _scrollToIndex;

  @override
  void initState() {
    super.initState();
    _selected = widget.initial;
    _scrollController = ScrollController();

    // Genera tutte le opzioni di orario con 4 colonne per riga
    _times = <TimeOfDay?>[];
    for (int h = 0; h < 24; h++) {
      for (int m = 0; m < 60; m += widget.stepMinutes) {
        _times.add(TimeOfDay(hour: h, minute: m));
      }
    }
    // Aggiungi 24:00 come opzione finale
    _times.add(const TimeOfDay(hour: 24, minute: 0));

    // Verifica se l'orario iniziale √® gi√† nella lista
    int exactIndex = _times.indexWhere(
      (t) =>
          t != null &&
          t.hour == widget.initial.hour &&
          t.minute == widget.initial.minute,
    );

    if (exactIndex >= 0) {
      // L'orario √® gi√† presente
      _scrollToIndex = exactIndex;
    } else {
      // L'orario non √® presente: inserisci una NUOVA RIGA con l'orario
      // nella colonna corretta e le altre colonne vuote
      final columnsPerRow = 60 ~/ widget.stepMinutes;
      final targetColumn = widget.initial.minute ~/ widget.stepMinutes;
      final baseIndex = (widget.initial.hour + 1) * columnsPerRow;

      // Crea la nuova riga con 4 elementi (solo uno valorizzato)
      final newRow = List<TimeOfDay?>.filled(columnsPerRow, null);
      newRow[targetColumn] = widget.initial;

      // Inserisci la nuova riga
      final insertIndex = baseIndex.clamp(0, _times.length);
      _times.insertAll(insertIndex, newRow);

      // L'indice dell'orario selezionato √® la posizione nella nuova riga
      _scrollToIndex = insertIndex + targetColumn;
    }

    // Scroll all'orario dopo il primo frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _scrollToSelected();
    });
  }

  void _scrollToSelected() {
    if (!_scrollController.hasClients) return;

    const crossAxisCount = 4;
    const mainAxisSpacing = 8.0;
    const childAspectRatio = 2.5;
    const padding = 8.0;

    // Usa la larghezza effettiva del context
    final screenWidth = MediaQuery.of(context).size.width;
    final availableWidth = screenWidth - padding * 2;
    final itemWidth =
        (availableWidth - (crossAxisCount - 1) * 8) / crossAxisCount;
    final itemHeight = itemWidth / childAspectRatio;
    final rowHeight = itemHeight + mainAxisSpacing;

    final targetRow = _scrollToIndex ~/ crossAxisCount;

    final viewportHeight = _scrollController.position.viewportDimension;
    // Offset aggiuntivo per centrare meglio (compensa header visivo)
    const headerOffset = 40.0;
    final targetOffset =
        (targetRow * rowHeight) -
        (viewportHeight / 2) +
        (rowHeight / 2) +
        headerOffset;

    final maxScroll = _scrollController.position.maxScrollExtent;
    final clampedOffset = targetOffset.clamp(0.0, maxScroll);

    _scrollController.animateTo(
      clampedOffset,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeOut,
    );
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                context.l10n.exceptionSelectTime,
                style: theme.textTheme.titleMedium,
              ),
              const SizedBox.shrink(),
            ],
          ),
        ),
        const AppBottomSheetDivider(),
        Expanded(
          child: GridView.builder(
            controller: _scrollController,
            padding: const EdgeInsets.all(8),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 4,
              childAspectRatio: 2.5,
              crossAxisSpacing: 8,
              mainAxisSpacing: 8,
            ),
            itemCount: _times.length,
            itemBuilder: (context, index) {
              final time = _times[index];
              // Se la cella √® vuota, mostra uno spazio vuoto
              if (time == null) {
                return const SizedBox.shrink();
              }
              final isSelected =
                  time.hour == _selected.hour && time.minute == _selected.minute;
              final label = time.hour == 24
                  ? '24:00'
                  : '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';

              return Material(
                color: isSelected
                    ? colorScheme.primaryContainer
                    : colorScheme.surfaceContainerHighest,
                borderRadius: BorderRadius.circular(8),
                child: InkWell(
                  onTap: () => Navigator.of(context).pop(time),
                  borderRadius: BorderRadius.circular(8),
                  child: Center(
                    child: Text(
                      label,
                      style: TextStyle(
                        fontWeight: isSelected
                            ? FontWeight.bold
                            : FontWeight.normal,
                        color: isSelected
                            ? colorScheme.onPrimaryContainer
                            : colorScheme.onSurface,
                      ),
                    ),
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }
}

/// Widget dropdown per selezionare la durata in giorni.
class _DurationDropdown extends StatelessWidget {
  const _DurationDropdown({required this.value, required this.onChanged});

  final int value;
  final ValueChanged<int> onChanged;

  static const List<int> _options = [
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    10,
    14,
    21,
    30,
    60,
    90,
  ];

  @override
  Widget build(BuildContext context) {
    return DropdownButtonFormField<int>(
      value: _options.contains(value) ? value : 7,
      decoration: const InputDecoration(
        border: OutlineInputBorder(),
        isDense: true,
        contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 12),
      ),
      items: _options.map((days) {
        return DropdownMenuItem(value: days, child: Text('$days'));
      }).toList(),
      onChanged: (v) {
        if (v != null) onChanged(v);
      },
    );
  }
}
--- FILE: lib/features/staff/presentation/dialogs/location_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../app/theme/app_spacing.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/location.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/labeled_form_field.dart';
import '../../../agenda/providers/business_providers.dart';
import '../../../agenda/providers/location_providers.dart';

Future<void> showLocationDialog(
  BuildContext context,
  WidgetRef ref, {
  Location? initial,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final isDesktop = formFactor == AppFormFactor.desktop;

  final dialog = _LocationDialog(initial: initial);

  if (isDesktop) {
    await showDialog(context: context, builder: (_) => dialog);
  } else {
    await AppBottomSheet.show(
      context: context,
      builder: (_) => dialog,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      heightFactor: AppBottomSheet.defaultHeightFactor,
    );
  }
}

class _LocationDialog extends ConsumerStatefulWidget {
  const _LocationDialog({this.initial});

  final Location? initial;

  bool get isEditing => initial != null;

  @override
  ConsumerState<_LocationDialog> createState() => _LocationDialogState();
}

class _LocationDialogState extends ConsumerState<_LocationDialog> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _addressController = TextEditingController();
  final _emailController = TextEditingController();
  bool _isActive = true;

  @override
  void initState() {
    super.initState();
    if (widget.initial != null) {
      _nameController.text = widget.initial!.name;
      _addressController.text = widget.initial!.address ?? '';
      _emailController.text = widget.initial!.email ?? '';
      _isActive = widget.initial!.isActive;
    } else {
      // Pre-popola con il nome del business per nuove sedi
      final businessName = ref.read(currentBusinessProvider).name;
      _nameController.text = businessName;
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _addressController.dispose();
    _emailController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final title = widget.isEditing
        ? l10n.teamEditLocationTitle
        : l10n.teamNewLocationTitle;

    final actions = [
      AppOutlinedActionButton(
        onPressed: _isLoading ? null : () => Navigator.of(context).pop(),
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppFilledButton(
        onPressed: _isLoading ? null : _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        child: _isLoading
            ? const SizedBox(
                width: 20,
                height: 20,
                child: CircularProgressIndicator(strokeWidth: 2),
              )
            : Text(l10n.actionSave),
      ),
    ];

    final bottomActions = actions
        .map(
          (a) => SizedBox(width: AppButtonStyles.dialogButtonWidth, child: a),
        )
        .toList();

    final nameField = LabeledFormField(
      label: l10n.teamLocationNameLabel,
      child: TextFormField(
        controller: _nameController,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        validator: (v) =>
            v == null || v.trim().isEmpty ? l10n.validationRequired : null,
      ),
    );

    final addressField = LabeledFormField(
      label: l10n.teamLocationAddressLabel,
      child: TextFormField(
        controller: _addressController,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
      ),
    );

    final emailField = LabeledFormField(
      label: l10n.teamLocationEmailLabel,
      child: TextFormField(
        controller: _emailController,
        keyboardType: TextInputType.emailAddress,
        decoration: InputDecoration(
          border: const OutlineInputBorder(),
          isDense: true,
          hintText: l10n.teamLocationEmailHint,
        ),
        validator: (v) {
          if (v == null || v.trim().isEmpty) return null; // Optional
          final emailRegex = RegExp(r'^[^@]+@[^@]+\.[^@]+');
          if (!emailRegex.hasMatch(v.trim())) {
            return l10n.validationInvalidEmail;
          }
          return null;
        },
      ),
    );

    final content = Form(
      key: _formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        mainAxisSize: MainAxisSize.min,
        children: [
          nameField,
          const SizedBox(height: AppSpacing.formRowSpacing),
          addressField,
          const SizedBox(height: AppSpacing.formRowSpacing),
          emailField,
          const SizedBox(height: AppSpacing.formRowSpacing),
          SwitchListTile(
            title: Text(l10n.teamLocationIsActiveLabel),
            subtitle: Text(
              l10n.teamLocationIsActiveHint,
              style: Theme.of(context).textTheme.bodySmall,
            ),
            value: _isActive,
            onChanged: (v) => setState(() => _isActive = v),
            contentPadding: EdgeInsets.zero,
          ),
          if (_error != null) ...[
            const SizedBox(height: AppSpacing.formRowSpacing),
            Text(
              _error!,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.error,
              ),
            ),
          ],
        ],
      ),
    );

    if (ref.read(formFactorProvider) == AppFormFactor.desktop) {
      return Dialog(
        insetPadding: const EdgeInsets.symmetric(horizontal: 32, vertical: 24),
        child: ConstrainedBox(
          constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
          child: Padding(
            padding: const EdgeInsets.all(20),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Text(title, style: Theme.of(context).textTheme.headlineSmall),
                const SizedBox(height: 16),
                Flexible(child: SingleChildScrollView(child: content)),
                const SizedBox(height: 24),
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    for (int i = 0; i < bottomActions.length; i++) ...[
                      if (i > 0) const SizedBox(width: 8),
                      bottomActions[i],
                    ],
                  ],
                ),
              ],
            ),
          ),
        ),
      );
    }

    return SafeArea(
      top: false,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final isKeyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
          return SizedBox(
            height: constraints.maxHeight,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Expanded(
                  child: SingleChildScrollView(
                    child: Padding(
                      padding: EdgeInsets.only(
                        left: 16,
                        right: 16,
                        top: 12,
                        bottom: 0,
                      ),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Padding(
                            padding: const EdgeInsets.only(bottom: 12),
                            child: Text(
                              title,
                              style: Theme.of(context).textTheme.titleLarge,
                            ),
                          ),
                          content,
                          const SizedBox(height: 24),
                        ],
                      ),
                    ),
                  ),
                ),
                if (!isKeyboardOpen) ...[
                  const AppBottomSheetDivider(),
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                    child: Align(
                      alignment: bottomActions.length == 3
                          ? Alignment.center
                          : Alignment.centerRight,
                      child: Wrap(
                        alignment: bottomActions.length == 3
                            ? WrapAlignment.center
                            : WrapAlignment.end,
                        spacing: 8,
                        runSpacing: 8,
                        children: bottomActions,
                      ),
                    ),
                  ),
                ],
                SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
              ],
            ),
          );
        },
      ),
    );
  }

  bool _isLoading = false;
  String? _error;

  Future<void> _onSave() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() {
      _isLoading = true;
      _error = null;
    });

    final notifier = ref.read(locationsProvider.notifier);
    final name = _nameController.text.trim();
    final address = _addressController.text.trim();
    final email = _emailController.text.trim();

    try {
      if (widget.initial != null) {
        // Aggiorna location esistente
        await notifier.updateLocation(
          locationId: widget.initial!.id,
          name: name,
          address: address.isEmpty ? null : address,
          email: email.isEmpty ? null : email,
          isActive: _isActive,
        );
      } else {
        // Crea nuova location
        await notifier.create(
          name: name,
          address: address.isEmpty ? null : address,
          email: email.isEmpty ? null : email,
          isActive: _isActive,
        );
      }
      if (mounted) Navigator.of(context).pop();
    } catch (e) {
      setState(() {
        _error = e.toString();
        _isLoading = false;
      });
    }
  }
}
--- FILE: lib/features/staff/presentation/dialogs/staff_dialog.dart ---
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/app_constants.dart';
import '../../../../app/providers/form_factor_provider.dart';
import '../../../../app/theme/app_spacing.dart';
import '../../../../app/widgets/staff_circle_avatar.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/staff.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/app_switch.dart';
import '../../../../core/widgets/labeled_form_field.dart';
import '../../../agenda/providers/location_providers.dart';
import '../../../services/presentation/widgets/service_eligibility_selector.dart';
import '../../../services/providers/service_categories_provider.dart';
import '../../../services/providers/services_provider.dart';
import '../../providers/staff_providers.dart';

Future<void> showStaffDialog(
  BuildContext context,
  WidgetRef ref, {
  Staff? initial,
  int? initialLocationId,
  bool duplicateFrom = false,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final isDesktop = formFactor == AppFormFactor.desktop;

  final dialog = _StaffDialog(
    initial: initial,
    initialLocationId: initialLocationId,
    isDuplicating: duplicateFrom,
  );

  if (isDesktop) {
    await showDialog(context: context, builder: (_) => dialog);
  } else {
    await AppBottomSheet.show(
      context: context,
      builder: (_) => dialog,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      heightFactor: AppBottomSheet.defaultHeightFactor,
    );
  }
}

class _StaffDialog extends ConsumerStatefulWidget {
  const _StaffDialog({
    this.initial,
    this.initialLocationId,
    this.isDuplicating = false,
  });

  final Staff? initial;
  final int? initialLocationId;
  final bool isDuplicating;

  bool get isEditing => initial != null && !isDuplicating;

  @override
  ConsumerState<_StaffDialog> createState() => _StaffDialogState();
}

class _StaffDialogState extends ConsumerState<_StaffDialog> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _surnameController = TextEditingController();

  late Color _selectedColor;
  final ScrollController _colorScrollController = ScrollController();
  final Set<int> _selectedLocationIds = {};
  final Set<int> _selectedServiceIds = {};
  String? _locationsError;
  bool _isSelectingServices = false;
  bool _isSelectingLocations = false;
  bool _isBookableOnline = true;
  bool _didAutoScrollColor = false;

  static const List<Color> _palette = [
    // Gialli / Amber (alto contrasto)
    Color(0xFFFFC400),
    Color(0xFFFFA000),
    // Arancioni
    Color(0xFFFF6D00),
    Color(0xFFFF3D00),
    // Rossi
    Color(0xFFD50000),
    Color(0xFFB71C1C),
    // Magenta / Rosa
    Color(0xFFF50057),
    Color(0xFFC51162),
    // Viola
    Color(0xFFAA00FF),
    Color(0xFF6200EA),
    // Indaco
    Color(0xFF304FFE),
    Color(0xFF1A237E),
    // Blu
    Color(0xFF2962FF),
    Color(0xFF1565C0),
    // Azzurro
    Color(0xFF0091EA),
    Color(0xFF00B0FF),
    // Ciano
    Color(0xFF00B8D4),
    Color(0xFF00838F),
    // Teal / Turchese
    Color(0xFF00BFA5),
    Color(0xFF00796B),
    // Verdi
    Color(0xFF00C853),
    Color(0xFF2E7D32),
    // Lime / Verde acido
    Color(0xFF76FF03),
    Color(0xFFAEEA00),
    // Extra diversit√†
    Color(0xFFFF9100),
    Color(0xFFE65100),
    Color(0xFFAD1457),
    Color(0xFF7B1FA2),
    Color(0xFF3949AB),
    Color(0xFF00897B),
    Color(0xFF43A047),
    Color(0xFF558B2F),
    Color(0xFF01579B),
    Color(0xFF006064),
    Color(0xFF4E342E),
    Color(0xFF37474F),
  ];

  @override
  void initState() {
    super.initState();
    final initial = widget.initial;
    _selectedColor = initial?.color ?? _palette.first;
    if (initial != null) {
      if (widget.isDuplicating) {
        _nameController.clear();
        _surnameController.clear();
      } else {
        _nameController.text = initial.name;
        _surnameController.text = initial.surname;
      }
      if (kAllowStaffMultiLocationSelection) {
        _selectedLocationIds.addAll(initial.locationIds);
      } else if (initial.locationIds.isNotEmpty) {
        _selectedLocationIds.add(initial.locationIds.first);
      }
      _isBookableOnline = initial.isBookableOnline;
      // Legge serviceIds direttamente dal modello Staff (gi√† caricato da API)
      _selectedServiceIds.addAll(initial.serviceIds);
    } else if (widget.initialLocationId != null) {
      _selectedLocationIds.add(widget.initialLocationId!);
    }
    _nameController.addListener(_handleNameChange);
    _surnameController.addListener(_handleNameChange);
  }

  @override
  void dispose() {
    _nameController.removeListener(_handleNameChange);
    _surnameController.removeListener(_handleNameChange);
    _nameController.dispose();
    _surnameController.dispose();
    _colorScrollController.dispose();
    super.dispose();
  }

  void _handleNameChange() {
    if (!mounted) return;
    setState(() {});
  }

  String _buildInitials() {
    final name = _nameController.text.trim();
    final surname = _surnameController.text.trim();
    final fullName = [name, surname].where((p) => p.isNotEmpty).join(' ');
    return initialsFromName(fullName, maxChars: 3);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final title = widget.isEditing
        ? l10n.teamEditStaffTitle
        : l10n.teamNewStaffTitle;
    final formFactor = ref.read(formFactorProvider);
    final isSingleColumn = formFactor != AppFormFactor.desktop;
    final locations = ref.watch(locationsProvider);
    final totalServicesCount = (ref.watch(servicesProvider).value ?? []).length;
    final totalLocationsCount = locations.length;
    final selectedLocationName =
        !kAllowStaffMultiLocationSelection && _selectedLocationIds.isNotEmpty
        ? locations
              .firstWhere(
                (loc) => loc.id == _selectedLocationIds.first,
                orElse: () => locations.first,
              )
              .name
        : null;
    if (!_didAutoScrollColor) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (!_colorScrollController.hasClients) return;
        final index = _palette.indexWhere(
          (c) => c.value == _selectedColor.value,
        );
        if (index < 0) return;
        const double colorItemSize = 36;
        const double colorItemSpacing = 10;
        const double colorListPadding = 4;
        final viewport = _colorScrollController.position.viewportDimension;
        final target =
            index * (colorItemSize + colorItemSpacing) -
            (viewport - colorItemSize) / 2 -
            colorListPadding;
        final max = _colorScrollController.position.maxScrollExtent;
        _colorScrollController.jumpTo(target.clamp(0.0, max));
      });
      _didAutoScrollColor = true;
    }

    final editAvatar = widget.isEditing
        ? Center(
            child: StaffCircleAvatar(
              height: 64,
              color: _selectedColor,
              isHighlighted: false,
              initials: _buildInitials(),
            ),
          )
        : null;

    final actions = [
      AppOutlinedActionButton(
        onPressed: _isSaving ? null : () => Navigator.of(context).pop(),
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppFilledButton(
        onPressed: _isSaving ? null : _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        child: _isSaving
            ? const SizedBox(
                width: 20,
                height: 20,
                child: CircularProgressIndicator(strokeWidth: 2),
              )
            : Text(l10n.actionSave),
      ),
    ];

    final bottomActions = actions
        .map(
          (a) => SizedBox(width: AppButtonStyles.dialogButtonWidth, child: a),
        )
        .toList();

    final nameField = LabeledFormField(
      label: l10n.teamStaffNameLabel,
      child: TextFormField(
        controller: _nameController,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        textInputAction: TextInputAction.next,
        textCapitalization: TextCapitalization.words,
        validator: (v) =>
            v == null || v.trim().isEmpty ? l10n.validationRequired : null,
      ),
    );

    final surnameField = LabeledFormField(
      label: l10n.teamStaffSurnameLabel,
      child: TextFormField(
        controller: _surnameController,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        textInputAction: TextInputAction.next,
        textCapitalization: TextCapitalization.words,
      ),
    );

    final content = Form(
      key: _formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        mainAxisSize: MainAxisSize.min,
        children: [
          if (isSingleColumn) ...[
            nameField,
            const SizedBox(height: AppSpacing.formRowSpacing),
            surnameField,
          ] else ...[
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(child: nameField),
                const SizedBox(width: AppSpacing.formFieldSpacing),
                Expanded(child: surnameField),
              ],
            ),
          ],
          const SizedBox(height: AppSpacing.formRowSpacing),
          Text(
            l10n.teamStaffColorLabel,
            style: Theme.of(context).textTheme.titleSmall,
          ),
          const SizedBox(height: 8),
          SizedBox(
            height: 44,
            child: Row(
              children: [
                Expanded(
                  child: ShaderMask(
                    shaderCallback: (rect) {
                      return const LinearGradient(
                        begin: Alignment.centerLeft,
                        end: Alignment.centerRight,
                        colors: [
                          Colors.transparent,
                          Colors.black,
                          Colors.black,
                          Colors.transparent,
                        ],
                        stops: [0.0, 0.01, 0.99, 1.0],
                      ).createShader(rect);
                    },
                    blendMode: BlendMode.dstIn,
                    child: ScrollConfiguration(
                      behavior: const ScrollBehavior().copyWith(
                        dragDevices: {
                          PointerDeviceKind.touch,
                          PointerDeviceKind.mouse,
                          PointerDeviceKind.trackpad,
                        },
                      ),
                      child: ListView.separated(
                        controller: _colorScrollController,
                        padding: const EdgeInsets.symmetric(horizontal: 4),
                        scrollDirection: Axis.horizontal,
                        physics: const BouncingScrollPhysics(),
                        itemCount: _palette.length,
                        separatorBuilder: (_, __) => const SizedBox(width: 10),
                        itemBuilder: (context, index) {
                          final color = _palette[index];
                          final initials = _buildInitials();
                          return GestureDetector(
                            onTap: () => setState(() => _selectedColor = color),
                            child: AnimatedContainer(
                              duration: const Duration(milliseconds: 150),
                              child: StaffCircleAvatar(
                                height: 36,
                                color: color,
                                isHighlighted: _selectedColor == color,
                                initials: initials,
                              ),
                            ),
                          );
                        },
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: AppSpacing.formRowSpacing),
          if (!kAllowStaffMultiLocationSelection) ...[
            Text(
              l10n.teamLocationLabel,
              style: Theme.of(context).textTheme.titleSmall,
            ),
            const SizedBox(height: 8),
          ],
          SizedBox(
            height: 48,
            child: AppOutlinedActionButton(
              onPressed: _openLocationsSelector,
              expand: true,
              padding: AppButtonStyles.defaultPadding,
              child: Row(
                children: [
                  Expanded(
                    child: Align(
                      alignment: Alignment.centerLeft,
                      child: Text(
                        kAllowStaffMultiLocationSelection
                            ? l10n.teamChooseLocationsButton
                            : (selectedLocationName ??
                                  l10n.teamChooseLocationSingleButton),
                      ),
                    ),
                  ),
                  if (kAllowStaffMultiLocationSelection)
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 10,
                        vertical: 4,
                      ),
                      decoration: BoxDecoration(
                        color: Theme.of(
                          context,
                        ).colorScheme.primary.withOpacity(0.12),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        '${_selectedLocationIds.length}/$totalLocationsCount',
                        style: Theme.of(context).textTheme.labelSmall?.copyWith(
                          color: Theme.of(context).colorScheme.primary,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                ],
              ),
            ),
          ),
          if (_locationsError != null)
            Padding(
              padding: const EdgeInsets.only(top: 4),
              child: Text(
                _locationsError!,
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.error,
                ),
              ),
            ),
          const SizedBox(height: AppSpacing.formRowSpacing),
          Text(
            l10n.teamServicesLabel,
            style: Theme.of(context).textTheme.titleSmall,
          ),
          const SizedBox(height: 8),
          SizedBox(
            height: 48,
            child: AppOutlinedActionButton(
              onPressed: _openServicesSelector,
              expand: true,
              padding: AppButtonStyles.defaultPadding,
              child: Align(
                alignment: Alignment.centerLeft,
                child: Wrap(
                  crossAxisAlignment: WrapCrossAlignment.center,
                  spacing: 8,
                  runSpacing: 6,
                  children: [
                    Text(l10n.teamSelectedServicesButton),
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 10,
                        vertical: 4,
                      ),
                      decoration: BoxDecoration(
                        color: Theme.of(
                          context,
                        ).colorScheme.primary.withOpacity(0.12),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        l10n.teamSelectedServicesCount(
                          _selectedServiceIds.length,
                          totalServicesCount,
                        ),
                        style: Theme.of(context).textTheme.labelSmall?.copyWith(
                          color: Theme.of(context).colorScheme.primary,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
          const SizedBox(height: AppSpacing.formRowSpacing),
          _SwitchTile(
            title: l10n.teamStaffBookableOnlineLabel,
            value: _isBookableOnline,
            onChanged: (v) => setState(() => _isBookableOnline = v),
          ),
          if (_saveError != null) ...[
            const SizedBox(height: AppSpacing.formRowSpacing),
            Text(
              _saveError!,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.error,
              ),
            ),
          ],
          const SizedBox(height: AppSpacing.formRowSpacing),
          if (kAllowStaffMultiLocationSelection)
            Text(
              l10n.teamStaffMultiLocationWarning,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
        ],
      ),
    );

    if (ref.read(formFactorProvider) == AppFormFactor.desktop) {
      return Dialog(
        insetPadding: const EdgeInsets.symmetric(horizontal: 32, vertical: 24),
        child: ConstrainedBox(
          constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
          child: Padding(
            padding: const EdgeInsets.all(20),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Text(title, style: Theme.of(context).textTheme.headlineSmall),
                if (editAvatar != null) ...[
                  const SizedBox(height: 12),
                  editAvatar,
                ],
                const SizedBox(height: 16),
                Flexible(child: SingleChildScrollView(child: content)),
                const SizedBox(height: 24),
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    for (int i = 0; i < bottomActions.length; i++) ...[
                      if (i > 0) const SizedBox(width: 8),
                      bottomActions[i],
                    ],
                  ],
                ),
              ],
            ),
          ),
        ),
      );
    }

    return SafeArea(
      top: false,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final isKeyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
          return SizedBox(
            height: constraints.maxHeight,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Expanded(
                  child: SingleChildScrollView(
                    padding: EdgeInsets.zero,
                    child: Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Padding(
                            padding: const EdgeInsets.only(bottom: 12),
                            child: Text(
                              title,
                              style: Theme.of(context).textTheme.titleLarge,
                            ),
                          ),
                          if (editAvatar != null) ...[
                            editAvatar,
                            const SizedBox(height: 12),
                          ],
                          content,
                          const SizedBox(height: 24),
                          const SizedBox(height: AppSpacing.formRowSpacing),
                        ],
                      ),
                    ),
                  ),
                ),
                if (!isKeyboardOpen) ...[
                  const AppBottomSheetDivider(),
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                    child: Align(
                      alignment: bottomActions.length == 3
                          ? Alignment.center
                          : Alignment.centerRight,
                      child: Wrap(
                        alignment: bottomActions.length == 3
                            ? WrapAlignment.center
                            : WrapAlignment.end,
                        spacing: 8,
                        runSpacing: 8,
                        children: bottomActions,
                      ),
                    ),
                  ),
                ],
                SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
              ],
            ),
          );
        },
      ),
    );
  }

  bool _isSaving = false;
  String? _saveError;

  Future<void> _onSave() async {
    if (!_formKey.currentState!.validate()) return;
    if (_selectedLocationIds.isEmpty) {
      setState(() => _locationsError = context.l10n.validationRequired);
      return;
    }
    if (!kAllowStaffMultiLocationSelection && _selectedLocationIds.length > 1) {
      final firstId = _selectedLocationIds.first;
      _selectedLocationIds
        ..clear()
        ..add(firstId);
    }

    setState(() {
      _isSaving = true;
      _saveError = null;
    });

    final notifier = ref.read(allStaffProvider.notifier);
    final name = _nameController.text.trim();
    final surname = _surnameController.text.trim();
    final isEditing = widget.isEditing;

    try {
      if (isEditing) {
        // Aggiorna staff esistente tramite API (include service_ids)
        await notifier.updateStaffApi(
          staffId: widget.initial!.id,
          name: name,
          surname: surname,
          colorHex:
              '#${_selectedColor.value.toRadixString(16).substring(2).toUpperCase()}',
          isBookableOnline: _isBookableOnline,
          locationIds: _selectedLocationIds.toList(),
          serviceIds: _selectedServiceIds.toList(),
        );
      } else {
        // Crea nuovo staff tramite API (include service_ids)
        await notifier.createStaff(
          name: name,
          surname: surname,
          colorHex:
              '#${_selectedColor.value.toRadixString(16).substring(2).toUpperCase()}',
          isBookableOnline: _isBookableOnline,
          locationIds: _selectedLocationIds.toList(),
          serviceIds: _selectedServiceIds.toList(),
        );
      }

      if (mounted) Navigator.of(context).pop();
    } catch (e) {
      setState(() {
        _saveError = e.toString();
        _isSaving = false;
      });
    }
  }

  Future<void> _openServicesSelector() async {
    if (_isSelectingServices) return;
    setState(() => _isSelectingServices = true);
    final l10n = context.l10n;
    final services = ref.read(servicesProvider).value ?? [];
    final categories = ref.read(serviceCategoriesProvider);
    final formFactor = ref.read(formFactorProvider);
    Set<int> current = {..._selectedServiceIds};

    Future<void> openDialog(BuildContext ctx) async {
      await showDialog<void>(
        context: ctx,
        builder: (dialogCtx) => StatefulBuilder(
          builder: (context, setStateLocal) {
            return Dialog(
              insetPadding: const EdgeInsets.symmetric(
                horizontal: 32,
                vertical: 24,
              ),
              child: ConstrainedBox(
                constraints: const BoxConstraints(
                  minWidth: 600,
                  maxWidth: 720,
                  maxHeight: 560,
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Padding(
                      padding: const EdgeInsets.fromLTRB(20, 16, 20, 8),
                      child: Text(
                        l10n.teamEligibleServicesLabel,
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                    ),
                    const AppBottomSheetDivider(),
                    Expanded(
                      child: SingleChildScrollView(
                        child: Padding(
                          padding: const EdgeInsets.fromLTRB(0, 12, 0, 16),
                          child: ServiceEligibilitySelector(
                            services: services,
                            categories: categories,
                            selectedServiceIds: current,
                            onChanged: (value) => setStateLocal(() {
                              current = {...value};
                            }),
                          ),
                        ),
                      ),
                    ),
                    const AppBottomSheetDivider(),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                      child: Align(
                        alignment: Alignment.centerRight,
                        child: AppFilledButton(
                          onPressed: () => Navigator.of(dialogCtx).pop(),
                          padding: AppButtonStyles.dialogButtonPadding,
                          child: Text(l10n.actionConfirm),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        ),
      );
    }

    Future<void> openSheet(BuildContext ctx) async {
      await AppBottomSheet.show<void>(
        context: ctx,
        heightFactor: AppBottomSheet.defaultHeightFactor,
        padding: EdgeInsets.zero,
        builder: (sheetCtx) => StatefulBuilder(
          builder: (context, setStateLocal) {
            return SafeArea(
              top: false,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
                    child: Text(
                      l10n.teamEligibleServicesLabel,
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                  ),
                  const AppBottomSheetDivider(),
                  Expanded(
                    child: SingleChildScrollView(
                      child: Padding(
                        padding: const EdgeInsets.fromLTRB(0, 12, 0, 16),
                        child: ServiceEligibilitySelector(
                          services: services,
                          categories: categories,
                          selectedServiceIds: current,
                          onChanged: (value) => setStateLocal(() {
                            current = {...value};
                          }),
                        ),
                      ),
                    ),
                  ),
                  const AppBottomSheetDivider(),
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                    child: Align(
                      alignment: Alignment.centerRight,
                      child: AppFilledButton(
                        onPressed: () => Navigator.of(sheetCtx).pop(),
                        padding: AppButtonStyles.dialogButtonPadding,
                        child: Text(l10n.actionConfirm),
                      ),
                    ),
                  ),
                  SizedBox(height: MediaQuery.of(ctx).viewPadding.bottom),
                ],
              ),
            );
          },
        ),
      );
    }

    if (formFactor == AppFormFactor.desktop) {
      await openDialog(context);
    } else {
      await openSheet(context);
    }

    setState(() {
      _selectedServiceIds
        ..clear()
        ..addAll(current);
      _isSelectingServices = false;
    });
  }

  Future<void> _openLocationsSelector() async {
    if (_isSelectingLocations) return;
    setState(() => _isSelectingLocations = true);
    final l10n = context.l10n;
    final locations = ref.read(locationsProvider);
    final formFactor = ref.read(formFactorProvider);
    Set<int> current = {..._selectedLocationIds};

    Widget buildLocationRows(void Function(VoidCallback) setStateLocal) {
      final allIds = [for (final l in locations) l.id];
      final allSelected = allIds.isNotEmpty && allIds.every(current.contains);
      return Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          if (kAllowStaffMultiLocationSelection) ...[
            _SelectableRow(
              label: l10n.teamSelectAllLocations,
              selected: allSelected,
              onTap: () {
                if (allSelected) {
                  current.clear();
                } else {
                  current
                    ..clear()
                    ..addAll(allIds);
                }
                setStateLocal(() {});
              },
            ),
            const AppBottomSheetDivider(),
          ],
          for (final loc in locations)
            _SelectableRow(
              label: loc.name,
              selected: current.contains(loc.id),
              onTap: () {
                if (kAllowStaffMultiLocationSelection) {
                  if (current.contains(loc.id)) {
                    current.remove(loc.id);
                  } else {
                    current.add(loc.id);
                  }
                } else {
                  current
                    ..clear()
                    ..add(loc.id);
                }
                setStateLocal(() {});
                if (!kAllowStaffMultiLocationSelection) {
                  Navigator.of(context).pop();
                }
              },
            ),
        ],
      );
    }

    Future<void> openDialog(BuildContext ctx) async {
      await showDialog<void>(
        context: ctx,
        builder: (dialogCtx) => StatefulBuilder(
          builder: (context, setStateLocal) {
            return Dialog(
              insetPadding: const EdgeInsets.symmetric(
                horizontal: 32,
                vertical: 24,
              ),
              child: ConstrainedBox(
                constraints: const BoxConstraints(
                  minWidth: 600,
                  maxWidth: 720,
                  maxHeight: 560,
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Padding(
                      padding: const EdgeInsets.fromLTRB(20, 16, 20, 8),
                      child: Text(
                        kAllowStaffMultiLocationSelection
                            ? l10n.teamChooseLocationsButton
                            : l10n.teamChooseLocationSingleButton,
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                    ),
                    const AppBottomSheetDivider(),
                    Expanded(
                      child: SingleChildScrollView(
                        child: Padding(
                          padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                          child: buildLocationRows(setStateLocal),
                        ),
                      ),
                    ),
                    if (kAllowStaffMultiLocationSelection) ...[
                      const AppBottomSheetDivider(),
                      Padding(
                        padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                        child: Align(
                          alignment: Alignment.centerRight,
                          child: AppFilledButton(
                            onPressed: () => Navigator.of(dialogCtx).pop(),
                            padding: AppButtonStyles.dialogButtonPadding,
                            child: Text(l10n.actionConfirm),
                          ),
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            );
          },
        ),
      );
    }

    Future<void> openSheet(BuildContext ctx) async {
      await AppBottomSheet.show<void>(
        context: ctx,
        heightFactor: AppBottomSheet.defaultHeightFactor,
        padding: EdgeInsets.zero,
        builder: (sheetCtx) => StatefulBuilder(
          builder: (context, setStateLocal) {
            return SafeArea(
              top: false,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
                    child: Text(
                      kAllowStaffMultiLocationSelection
                          ? l10n.teamChooseLocationsButton
                          : l10n.teamChooseLocationSingleButton,
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                  ),
                  const AppBottomSheetDivider(),
                  Expanded(
                    child: SingleChildScrollView(
                      child: Padding(
                        padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                        child: buildLocationRows(setStateLocal),
                      ),
                    ),
                  ),
                  if (kAllowStaffMultiLocationSelection) ...[
                    const AppBottomSheetDivider(),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                      child: Align(
                        alignment: Alignment.centerRight,
                        child: AppFilledButton(
                          onPressed: () => Navigator.of(sheetCtx).pop(),
                          padding: AppButtonStyles.dialogButtonPadding,
                          child: Text(l10n.actionConfirm),
                        ),
                      ),
                    ),
                    SizedBox(height: MediaQuery.of(ctx).viewPadding.bottom),
                  ],
                ],
              ),
            );
          },
        ),
      );
    }

    if (formFactor == AppFormFactor.desktop) {
      await openDialog(context);
    } else {
      await openSheet(context);
    }

    setState(() {
      _selectedLocationIds
        ..clear()
        ..addAll(current);
      _locationsError = null;
      _isSelectingLocations = false;
    });
  }
}

class _SwitchTile extends StatelessWidget {
  const _SwitchTile({
    required this.title,
    required this.value,
    required this.onChanged,
  });

  final String title;
  final bool value;
  final ValueChanged<bool>? onChanged;

  @override
  Widget build(BuildContext context) {
    final titleStyle = Theme.of(context).textTheme.titleSmall;
    final borderRadius = AppButtonStyles.defaultBorderRadius;
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 5),
      decoration: BoxDecoration(
        border: Border.all(
          color: Theme.of(context).colorScheme.primary,
          width: 1.4,
        ),
        borderRadius: borderRadius,
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: onChanged == null ? null : () => onChanged!(!value),
          splashColor: Colors.transparent,
          hoverColor: Colors.transparent,
          highlightColor: Colors.transparent,
          child: Row(
            children: [
              Expanded(child: Text(title, style: titleStyle)),
              AppSwitch(value: value, onChanged: onChanged),
            ],
          ),
        ),
      ),
    );
  }
}

class _SelectableRow extends StatelessWidget {
  const _SelectableRow({
    required this.label,
    required this.selected,
    required this.onTap,
  });

  final String label;
  final bool selected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          child: Row(
            children: [
              Expanded(child: Text(label)),
              if (selected)
                Icon(
                  Icons.check,
                  color: Theme.of(context).colorScheme.primary,
                  size: 20,
                ),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/staff_week_overview_screen.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:agenda_backend/core/l10n/date_time_formats.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/availability_exception.dart';
import 'package:agenda_backend/core/models/staff.dart';
import 'package:agenda_backend/core/widgets/app_bottom_sheet.dart';
import 'package:agenda_backend/core/widgets/app_buttons.dart';
import 'package:agenda_backend/core/widgets/app_dialogs.dart';
import 'package:agenda_backend/core/widgets/no_scrollbar_behavior.dart';
import 'package:agenda_backend/features/agenda/domain/config/agenda_theme.dart';
import 'package:agenda_backend/features/agenda/providers/date_range_provider.dart';
import 'package:agenda_backend/features/agenda/providers/layout_config_provider.dart';
import 'package:agenda_backend/features/staff/presentation/dialogs/add_exception_dialog.dart';
import 'package:agenda_backend/features/staff/presentation/staff_availability_screen.dart';
import 'package:agenda_backend/features/staff/providers/availability_exceptions_provider.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:agenda_backend/features/staff/widgets/staff_top_controls.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

// Lightweight range used only for the overview chips
class HourRange {
  final int startHour;
  final int startMinute;
  final int endHour;
  final int endMinute;
  const HourRange(
    this.startHour,
    this.startMinute,
    this.endHour,
    this.endMinute,
  );

  int get minutes =>
      (endHour * 60 + endMinute) - (startHour * 60 + startMinute);
  String label(BuildContext context) =>
      '${DtFmt.hm(context, startHour, startMinute)} - ${DtFmt.hm(context, endHour, endMinute)}';
}

class _DisplayRange {
  _DisplayRange({
    required this.startMinutes,
    required this.endMinutes,
    required this.label,
    required this.isException,
    this.exceptionType,
    this.hourRange,
  });

  final int startMinutes;
  final int endMinutes;
  final String label;
  final bool isException;
  final AvailabilityExceptionType? exceptionType;
  final HourRange? hourRange;
}

class _DashedRoundedRectPainter extends CustomPainter {
  _DashedRoundedRectPainter({required this.color, required this.radius});

  final Color color;
  final double radius;

  @override
  void paint(Canvas canvas, Size size) {
    const strokeWidth = 0.6;
    const dashLength = 4.0;
    const gapLength = 3.0;
    final rect = Offset.zero & size;
    final rrect = RRect.fromRectAndRadius(rect, Radius.circular(radius));
    final path = Path()..addRRect(rrect);
    final paint = Paint()
      ..color = color
      ..strokeWidth = strokeWidth
      ..style = PaintingStyle.stroke;

    for (final metric in path.computeMetrics()) {
      var distance = 0.0;
      while (distance < metric.length) {
        final next = (distance + dashLength).clamp(0.0, metric.length);
        canvas.drawPath(metric.extractPath(distance, next), paint);
        distance += dashLength + gapLength;
      }
    }
  }

  @override
  bool shouldRepaint(covariant _DashedRoundedRectPainter oldDelegate) {
    return oldDelegate.color != color || oldDelegate.radius != radius;
  }
}

List<_DisplayRange> _mergeRangesForDisplay(
  List<HourRange> baseRanges,
  List<AvailabilityException> exceptions,
  BuildContext context, {
  bool applyUnavailableSplit = true,
  bool subtractAvailableFromBase = false,
}) {
  final items = <_DisplayRange>[];

  final availableToSubtract = subtractAvailableFromBase
      ? exceptions
            .where(
              (e) =>
                  e.type == AvailabilityExceptionType.available &&
                  e.startTime != null &&
                  e.endTime != null,
            )
            .map<({int start, int end})>(
              (e) => (
                start: e.startTime!.hour * 60 + e.startTime!.minute,
                end: e.endTime!.hour * 60 + e.endTime!.minute,
              ),
            )
            .toList()
      : const <({int start, int end})>[];

  final unavailable = applyUnavailableSplit
      ? exceptions
            .where(
              (e) =>
                  e.type == AvailabilityExceptionType.unavailable &&
                  e.startTime != null &&
                  e.endTime != null,
            )
            .map<({int start, int end})>(
              (e) => (
                start: e.startTime!.hour * 60 + e.startTime!.minute,
                end: e.endTime!.hour * 60 + e.endTime!.minute,
              ),
            )
            .toList()
      : const <({int start, int end})>[];

  for (final r in baseRanges) {
    final baseStart = r.startHour * 60 + r.startMinute;
    final baseEnd = r.endHour * 60 + r.endMinute;
    var segments = <({int start, int end})>[(start: baseStart, end: baseEnd)];

    if (availableToSubtract.isNotEmpty) {
      for (final a in availableToSubtract) {
        final next = <({int start, int end})>[];
        for (final seg in segments) {
          if (a.end <= seg.start || a.start >= seg.end) {
            next.add(seg);
            continue;
          }
          if (a.start > seg.start) {
            final leftEnd = a.start < seg.end ? a.start : seg.end;
            if (leftEnd > seg.start) {
              next.add((start: seg.start, end: leftEnd));
            }
          }
          if (a.end < seg.end) {
            final rightStart = a.end > seg.start ? a.end : seg.start;
            if (seg.end > rightStart) {
              next.add((start: rightStart, end: seg.end));
            }
          }
        }
        segments = next;
        if (segments.isEmpty) break;
      }
    }

    if (unavailable.isNotEmpty) {
      for (final u in unavailable) {
        final next = <({int start, int end})>[];
        for (final seg in segments) {
          if (u.end <= seg.start || u.start >= seg.end) {
            next.add(seg);
            continue;
          }
          if (u.start > seg.start) {
            final leftEnd = u.start < seg.end ? u.start : seg.end;
            if (leftEnd > seg.start) {
              next.add((start: seg.start, end: leftEnd));
            }
          }
          if (u.end < seg.end) {
            final rightStart = u.end > seg.start ? u.end : seg.start;
            if (seg.end > rightStart) {
              next.add((start: rightStart, end: seg.end));
            }
          }
        }
        segments = next;
        if (segments.isEmpty) break;
      }
    }

    for (final seg in segments) {
      final isAllDay = seg.start == 0 && seg.end == 24 * 60;
      final label = isAllDay
          ? context.l10n.exceptionAllDay
          : '${DtFmt.hm(context, seg.start ~/ 60, seg.start % 60)} - ${DtFmt.hm(context, seg.end ~/ 60, seg.end % 60)}';
      items.add(
        _DisplayRange(
          startMinutes: seg.start,
          endMinutes: seg.end,
          label: label,
          isException: false,
          exceptionType: null,
          hourRange: HourRange(
            seg.start ~/ 60,
            seg.start % 60,
            seg.end ~/ 60,
            seg.end % 60,
          ),
        ),
      );
    }
  }

  final allDayExceptions = exceptions.where(
    (e) => e.startTime == null && e.endTime == null,
  );
  for (final e in allDayExceptions) {
    items.add(
      _DisplayRange(
        startMinutes: 0,
        endMinutes: 24 * 60,
        label: context.l10n.exceptionAllDay,
        isException: true,
        exceptionType: e.type,
        hourRange: const HourRange(0, 0, 24, 0),
      ),
    );
  }

  for (final e in exceptions) {
    if (e.startTime == null || e.endTime == null) continue;
    final label =
        '${DtFmt.hm(context, e.startTime!.hour, e.startTime!.minute)} - ${DtFmt.hm(context, e.endTime!.hour, e.endTime!.minute)}';
    items.add(
      _DisplayRange(
        startMinutes: e.startTime!.hour * 60 + e.startTime!.minute,
        endMinutes: e.endTime!.hour * 60 + e.endTime!.minute,
        label: label,
        isException: true,
        exceptionType: e.type,
        hourRange: HourRange(
          e.startTime!.hour,
          e.startTime!.minute,
          e.endTime!.hour,
          e.endTime!.minute,
        ),
      ),
    );
  }

  // De-duplicate exact same ranges, prefer exception styling if present.
  final Map<String, _DisplayRange> unique = {};
  for (final item in items) {
    final key = '${item.startMinutes}-${item.endMinutes}';
    final existing = unique[key];
    if (existing == null) {
      unique[key] = item;
      continue;
    }
    if (!existing.isException && item.isException) {
      unique[key] = item;
    }
  }

  final result = unique.values.toList()
    ..sort((a, b) => a.startMinutes.compareTo(b.startMinutes));
  return result;
}

int _countSegmentsForDay(
  BuildContext context,
  List<HourRange> ranges,
  List<AvailabilityException> exceptions,
) {
  final displayRanges = _mergeRangesForDisplay(
    ranges,
    exceptions,
    context,
    applyUnavailableSplit: false,
    subtractAvailableFromBase: true,
  );
  return displayRanges.length;
}

/// Real data bridge: maps the editor's weekly availability (per day) to
/// the overview shape, including exceptions for the specific week being displayed.
///
/// La disponibilit√† finale per ogni giorno √® calcolata come:
/// 1. Base: template settimanale (es. Lun-Ven 09:00-18:00)
/// 2. + Eccezioni "available": aggiungono slot disponibili
/// 3. - Eccezioni "unavailable": rimuovono slot disponibili
class WeeklyExceptionsLoadKeyNotifier extends Notifier<String?> {
  @override
  String? build() => null;

  void setKey(String? value) => state = value;
}

final weeklyExceptionsLoadKeyProvider =
    NotifierProvider<WeeklyExceptionsLoadKeyNotifier, String?>(
      WeeklyExceptionsLoadKeyNotifier.new,
    );

void _ensureExceptionsLoadedForWeekWithKey(
  String? lastKey,
  void Function(String? value) setKey,
  Future<void> Function(int staffId, {DateTime? fromDate, DateTime? toDate})
  loadForStaff,
  DateTime agendaDate,
  List<Staff> staffList,
) {
  if (staffList.isEmpty) return;
  final monday = _mondayOfWeek(agendaDate);
  final staffIds = staffList.map((s) => s.id).toList()..sort();
  final key =
      '${monday.toIso8601String().split('T').first}|${staffIds.join(",")}';
  if (lastKey == key) return;
  final fromDate = monday;
  final toDate = monday.add(const Duration(days: 6));
  for (final staff in staffList) {
    loadForStaff(staff.id, fromDate: fromDate, toDate: toDate);
  }
}

final weeklyStaffAvailabilityFromEditorProvider =
    Provider<Map<int, Map<int, List<HourRange>>>>((ref) {
      final staffList = ref.watch(staffForStaffSectionProvider);
      final asyncByStaff = ref.watch(staffAvailabilityByStaffProvider);
      final layout = ref.watch(layoutConfigProvider);
      final minutesPerSlot = layout.minutesPerSlot;
      final totalSlots = layout.totalSlots;

      // Ottieni la data corrente dell'agenda per calcolare la settimana mostrata
      final agendaDate = ref.watch(agendaDateProvider);
      _ensureExceptionsLoadedForWeekWithKey(
        ref.watch(weeklyExceptionsLoadKeyProvider),
        ref.read(weeklyExceptionsLoadKeyProvider.notifier).setKey,
        ref
            .read(availabilityExceptionsProvider.notifier)
            .loadExceptionsForStaff,
        agendaDate,
        staffList,
      );
      final monday = _mondayOfWeek(agendaDate);

      List<HourRange> slotsToHourRanges(Set<int> slots) {
        if (slots.isEmpty) return const [];
        final sorted = slots.toList()..sort();
        final List<List<int>> clusters = [];
        var current = <int>[sorted.first];
        for (int i = 1; i < sorted.length; i++) {
          if (sorted[i] == sorted[i - 1] + 1) {
            current.add(sorted[i]);
          } else {
            clusters.add(current);
            current = <int>[sorted[i]];
          }
        }
        clusters.add(current);

        final List<HourRange> ranges = [];
        for (final c in clusters) {
          final startMin = c.first * minutesPerSlot;
          // La fine √® l'inizio dell'ultimo slot + la durata di uno slot
          final endMin = (c.last + 1) * minutesPerSlot;
          final sh = startMin ~/ 60;
          final sm = startMin % 60;
          final eh = endMin ~/ 60;
          final em = endMin % 60;
          ranges.add(HourRange(sh, sm, eh, em));
        }
        return ranges;
      }

      final all = asyncByStaff.value ?? const <int, Map<int, Set<int>>>{};

      // Build per-staff availability with exceptions applied for each specific date
      final Map<int, Map<int, List<HourRange>>> result = {};

      for (final s in staffList) {
        final Map<int, List<HourRange>> staffWeek = {};

        for (int d = 1; d <= 7; d++) {
          // Calcola la data specifica per questo giorno della settimana
          final specificDate = monday.add(Duration(days: d - 1));

          // 1Ô∏è‚É£ BASE: Template settimanale
          Set<int> baseSlots = Set<int>.from(all[s.id]?[d] ?? const <int>{});

          // 2Ô∏è‚É£ ECCEZIONI: Applica modifiche per la data specifica
          final exceptions = ref.watch(
            exceptionsForStaffOnDateProvider((
              staffId: s.id,
              date: specificDate,
            )),
          );

          if (exceptions.isEmpty) {
            staffWeek[d] = slotsToHourRanges(baseSlots);
          } else {
            // Applica le eccezioni in ordine
            Set<int> finalSlots = Set<int>.from(baseSlots);

            for (final exception in exceptions) {
              final exceptionSlots = exception.toSlotIndices(
                minutesPerSlot: minutesPerSlot,
                totalSlotsPerDay: totalSlots,
              );

              if (exception.type == AvailabilityExceptionType.available) {
                // AGGIUNGE disponibilit√† (es. turno extra)
                finalSlots = finalSlots.union(exceptionSlots);
              } else {
                // RIMUOVE disponibilit√† (es. ferie, malattia)
                finalSlots = finalSlots.difference(exceptionSlots);
              }
            }

            staffWeek[d] = slotsToHourRanges(finalSlots);
          }
        }

        result[s.id] = staffWeek;
      }

      return result;
    });

/// Provider che fornisce la disponibilit√† BASE (template settimanale) senza eccezioni.
/// Usato per confrontare con la disponibilit√† effettiva e identificare i turni modificati.
final weeklyStaffBaseAvailabilityProvider =
    Provider<Map<int, Map<int, List<HourRange>>>>((ref) {
      final staffList = ref.watch(staffForStaffSectionProvider);
      final asyncByStaff = ref.watch(staffAvailabilityByStaffProvider);
      final layout = ref.watch(layoutConfigProvider);
      final minutesPerSlot = layout.minutesPerSlot;

      List<HourRange> slotsToHourRanges(Set<int> slots) {
        if (slots.isEmpty) return const [];
        final sorted = slots.toList()..sort();
        final List<List<int>> clusters = [];
        var current = <int>[sorted.first];
        for (int i = 1; i < sorted.length; i++) {
          if (sorted[i] == sorted[i - 1] + 1) {
            current.add(sorted[i]);
          } else {
            clusters.add(current);
            current = <int>[sorted[i]];
          }
        }
        clusters.add(current);

        final List<HourRange> ranges = [];
        for (final c in clusters) {
          final startMin = c.first * minutesPerSlot;
          final endMin = (c.last + 1) * minutesPerSlot;
          final sh = startMin ~/ 60;
          final sm = startMin % 60;
          final eh = endMin ~/ 60;
          final em = endMin % 60;
          ranges.add(HourRange(sh, sm, eh, em));
        }
        return ranges;
      }

      final all = asyncByStaff.value ?? const <int, Map<int, Set<int>>>{};

      return {
        for (final s in staffList)
          s.id: {
            for (int d = 1; d <= 7; d++)
              d: slotsToHourRanges(all[s.id]?[d] ?? const <int>{}),
          },
      };
    });

/// Provider che traccia quali giorni della settimana hanno eccezioni per ogni staff.
/// Ritorna: `Map<staffId, Set<weekday>>` dove weekday = 1..7
final weeklyExceptionDaysProvider = Provider<Map<int, Set<int>>>((ref) {
  final staffList = ref.watch(staffForStaffSectionProvider);
  final agendaDate = ref.watch(agendaDateProvider);
  _ensureExceptionsLoadedForWeekWithKey(
    ref.watch(weeklyExceptionsLoadKeyProvider),
    ref.read(weeklyExceptionsLoadKeyProvider.notifier).setKey,
    ref.read(availabilityExceptionsProvider.notifier).loadExceptionsForStaff,
    agendaDate,
    staffList,
  );
  final monday = _mondayOfWeek(agendaDate);

  final Map<int, Set<int>> result = {};

  for (final s in staffList) {
    final Set<int> daysWithExceptions = {};

    for (int d = 1; d <= 7; d++) {
      final specificDate = monday.add(Duration(days: d - 1));
      final exceptions = ref.watch(
        exceptionsForStaffOnDateProvider((staffId: s.id, date: specificDate)),
      );

      if (exceptions.isNotEmpty) {
        daysWithExceptions.add(d);
      }
    }

    result[s.id] = daysWithExceptions;
  }

  return result;
});

DateTime _mondayOfWeek(DateTime date) {
  final d = DateTime(date.year, date.month, date.day);
  return d.subtract(Duration(days: d.weekday - DateTime.monday));
}

String _dayHeaderLabel(BuildContext context, DateTime day) {
  final locale = Intl.getCurrentLocale();
  return DateFormat('EEE, d MMM', locale).format(day);
}

int _totalMinutesForDay(Iterable<List<HourRange>> rangesPerStaff) {
  int total = 0;
  for (final list in rangesPerStaff) {
    for (final r in list) {
      total += r.minutes;
    }
  }
  return total;
}

int _totalMinutesForStaff(Map<int, List<HourRange>> byDay) {
  int total = 0;
  for (final list in byDay.values) {
    for (final r in list) {
      total += r.minutes;
    }
  }
  return total;
}

String _formatTotalHM(BuildContext context, int minutes) {
  if (minutes == 0) return '';
  final h = minutes ~/ 60;
  final m = minutes % 60;
  if (m == 0) return context.l10n.hoursHoursOnly(h);
  return context.l10n.hoursMinutesCompact(h, m);
}

class StaffWeekOverviewScreen extends ConsumerStatefulWidget {
  const StaffWeekOverviewScreen({super.key});

  @override
  ConsumerState<StaffWeekOverviewScreen> createState() =>
      _StaffWeekOverviewScreenState();
}

class _StaffWeekOverviewScreenState
    extends ConsumerState<StaffWeekOverviewScreen> {
  // Inizializzazione immediata per evitare LateInitializationError
  final ScrollController _headerHController = ScrollController();
  final ScrollController _bodyHController = ScrollController();
  final ScrollController _vScrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    // Sync header position from body only (unidirectional) per evitare conflitti di inerzia.
    _bodyHController.addListener(() {
      if (!_bodyHController.hasClients) return;
      final off = _bodyHController.offset;
      if (_headerHController.hasClients && _headerHController.offset != off) {
        // jumpTo √® immediato: per una transizione pi√π fluida si potrebbe usare animateTo con durata breve.
        _headerHController.jumpTo(off);
      }
    });
  }

  @override
  void dispose() {
    _headerHController.dispose();
    _bodyHController.dispose();
    _vScrollController.dispose();
    super.dispose();
  }

  // Caricamento eccezioni gestito dai provider

  @override
  Widget build(BuildContext context) {
    // Data sources
    final selectedDate = ref.watch(agendaDateProvider);
    // Current location could influence future filtering (kept for clarity)
    // final location = ref.watch(currentLocationProvider); // not used yet
    final staffList = ref.watch(staffForStaffSectionProvider);
    // Use real availability coming from the editor provider, mapped to overview ranges
    final availability = ref.watch(weeklyStaffAvailabilityFromEditorProvider);
    // Track which staff/day combinations have exceptions applied
    final exceptionDays = ref.watch(weeklyExceptionDaysProvider);
    final formFactor = ref.watch(formFactorProvider);
    _ensureExceptionsLoadedForWeekWithKey(
      ref.watch(weeklyExceptionsLoadKeyProvider),
      ref.read(weeklyExceptionsLoadKeyProvider.notifier).setKey,
      ref.read(availabilityExceptionsProvider.notifier).loadExceptionsForStaff,
      selectedDate,
      staffList,
    );

    // Week days (Mon..Sun)
    final weekStart = _mondayOfWeek(selectedDate);
    final days = [for (int i = 0; i < 7; i++) weekStart.add(Duration(days: i))];

    // Week label builder: include year on boundaries
    String buildWeekRangeLabel() {
      final weekEnd = weekStart.add(const Duration(days: 6));
      final locale = Intl.getCurrentLocale();
      final sameMonth =
          weekStart.month == weekEnd.month && weekStart.year == weekEnd.year;
      final sameYear = weekStart.year == weekEnd.year;

      if (sameMonth) {
        final startDay = DateFormat('d', locale).format(weekStart);
        final endDay = DateFormat('d', locale).format(weekEnd);
        final endMonthShort = DateFormat('MMM', locale).format(weekEnd);
        return '$startDay‚Äì$endDay $endMonthShort';
      }
      if (sameYear) {
        final startDay = DateFormat('d', locale).format(weekStart);
        final endDay = DateFormat('d', locale).format(weekEnd);
        final startMonthShort = DateFormat('MMM', locale).format(weekStart);
        final endMonthShort = DateFormat('MMM', locale).format(weekEnd);
        return '$startDay $startMonthShort ‚Äì $endDay $endMonthShort';
      }
      final startFull = DateFormat('d MMM y', locale).format(weekStart);
      final endFull = DateFormat('d MMM y', locale).format(weekEnd);
      return '$startFull ‚Äì $endFull';
    }

    final weekLabel = buildWeekRangeLabel();
    final weekEnd = weekStart.add(const Duration(days: 6));
    final todayDate = DateUtils.dateOnly(DateTime.now());
    //final isTodayInWeek =
    !todayDate.isBefore(weekStart) && !todayDate.isAfter(weekEnd);
    //final effectivePickerDate = isTodayInWeek ? todayDate : weekEnd;

    // Layout constants - responsive per mobile
    final isMobileLayout = formFactor == AppFormFactor.mobile;
    final staffColWidth = isMobileLayout ? 120.0 : 200.0;
    final headerHeight = 60.0;
    const chipColor = Color(0xFFECEBFF);
    const chipColorWithException = Color(
      0xFFFFE4B5,
    ); // Moccasin - colore arancione chiaro per eccezioni
    const chipColorWithAvailableException = Color(0xFFDFF5D8);
    const chipTextColorWithAvailableException = Color(0xFF0F6A36);
    const chipDisabledTextColor = Color(0xFF6B6B6B);
    const double chipHeight = 40.0;
    const double chipVGap = 3.0;
    const double chipTopPadding = 4.0;
    const double baseRowHeight = chipHeight * 2 + (chipVGap * 3) + 36.0;
    const double staffRowGap = 24.0;
    const double dayColumnWidth = 100.0;
    const double rightPadding = 5.0;
    final dividerColor = Colors.transparent; // vertical separators
    final divider = Container(height: 0.5, color: dividerColor);
    // Controller gi√† inizializzati in state

    Widget buildDayHeaderCell(DateTime day) {
      final dayIndex = day.weekday; // 1..7
      final totalMin = _totalMinutesForDay(
        availability.values.map((byDay) {
          return byDay[dayIndex] ?? const <HourRange>[];
        }),
      );
      final hasAny = totalMin > 0;
      // Center widget per centrare l'header nella colonna
      return Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(minWidth: dayColumnWidth),
          child: Container(
            height: headerHeight,
            padding: const EdgeInsets.symmetric(horizontal: 10),
            decoration: BoxDecoration(
              color: AgendaTheme.staffHeaderBackground(
                hasAny ? Colors.teal : Colors.blueGrey,
              ),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  _dayHeaderLabel(context, day),
                  style: AgendaTheme.staffHeaderTextStyle,
                  textAlign: TextAlign.center,
                ),
                if (hasAny)
                  Padding(
                    padding: const EdgeInsets.only(top: 2),
                    child: Text(
                      _formatTotalHM(context, totalMin),
                      style: Theme.of(context).textTheme.labelSmall?.copyWith(
                        color: Colors.black87,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
              ],
            ),
          ),
        ),
      );
    }

    double rowHeightForStaff(int staffId) {
      int maxRanges = 0;
      for (final d in days) {
        final exceptions = ref.watch(
          exceptionsForStaffOnDateProvider((staffId: staffId, date: d)),
        );
        final dayRanges =
            availability[staffId]?[d.weekday] ?? const <HourRange>[];
        var count = _countSegmentsForDay(context, dayRanges, exceptions);
        if (count == 0) count = 1;
        if (count > maxRanges) maxRanges = count;
      }
      if (maxRanges <= 1) return baseRowHeight; // 0 o 1 chip: altezza base
      final required =
          chipTopPadding + maxRanges * chipHeight + (maxRanges - 1) * chipVGap;
      return required > baseRowHeight ? required : baseRowHeight;
    }

    Widget buildStaffHeaderCell(int staffId) {
      final staff = staffList.firstWhere(
        (s) => s.id == staffId,
        orElse: () => staffList.first,
      );
      final minutes = _totalMinutesForStaff(availability[staffId] ?? const {});
      final isMobile = formFactor == AppFormFactor.mobile;
      void openStaffAvailability() {
        final vn = ref.read(initialStaffToEditProvider);
        vn.value = staffId;
        Navigator.of(context).push(
          MaterialPageRoute(builder: (_) => const StaffAvailabilityScreen()),
        );
      }

      if (isMobile) {
        // Mobile: avatar, nome e totale ore raggruppati al centro
        return GestureDetector(
          onTap: openStaffAvailability,
          child: Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Stack(
                  children: [
                    StaffCircleAvatar(
                      height: 40,
                      color: staff.color,
                      isHighlighted: false,
                      initials: staff.initials,
                    ),
                    Positioned(
                      right: -4,
                      bottom: -4,
                      child: Container(
                        padding: const EdgeInsets.all(2),
                        decoration: BoxDecoration(
                          color: Theme.of(context).colorScheme.surface,
                          shape: BoxShape.circle,
                          boxShadow: [
                            BoxShadow(
                              color: Colors.black.withValues(alpha: 0.1),
                              blurRadius: 2,
                            ),
                          ],
                        ),
                        child: Icon(
                          Icons.edit_outlined,
                          size: 14,
                          color: Theme.of(context).colorScheme.primary,
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 6),
                Text(
                  staff.displayName,
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                  style: Theme.of(context).textTheme.bodySmall,
                  textAlign: TextAlign.center,
                ),
                if (minutes > 0)
                  Text(
                    _formatTotalHM(context, minutes),
                    style: Theme.of(
                      context,
                    ).textTheme.labelSmall?.copyWith(color: Colors.black54),
                  ),
              ],
            ),
          ),
        );
      }

      // Desktop/Tablet: layout orizzontale
      return GestureDetector(
        onTap: openStaffAvailability,
        child: Row(
          children: [
            StaffCircleAvatar(
              height: 42,
              color: staff.color,
              isHighlighted: false,
              initials: staff.initials,
            ),
            const SizedBox(width: 8),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text(
                    staff.displayName,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  if (minutes > 0)
                    Text(
                      _formatTotalHM(context, minutes),
                      style: Theme.of(
                        context,
                      ).textTheme.labelSmall?.copyWith(color: Colors.black54),
                    ),
                ],
              ),
            ),
            IconButton(
              tooltip: context.l10n.staffEditHours,
              iconSize: 20,
              padding: const EdgeInsets.all(4),
              onPressed: openStaffAvailability,
              icon: const Icon(Icons.edit_outlined),
            ),
          ],
        ),
      );
    }

    // Helper: converte slots in HourRange list
    List<HourRange> slotsToRanges(Set<int> slots, int minutesPerSlot) {
      if (slots.isEmpty) return const [];
      final sorted = slots.toList()..sort();
      final List<List<int>> clusters = [];
      var current = <int>[sorted.first];
      for (int i = 1; i < sorted.length; i++) {
        if (sorted[i] == sorted[i - 1] + 1) {
          current.add(sorted[i]);
        } else {
          clusters.add(current);
          current = <int>[sorted[i]];
        }
      }
      clusters.add(current);

      final List<HourRange> ranges = [];
      for (final c in clusters) {
        final startMin = c.first * minutesPerSlot;
        final endMin = (c.last + 1) * minutesPerSlot;
        final sh = startMin ~/ 60;
        final sm = startMin % 60;
        final eh = endMin ~/ 60;
        final em = endMin % 60;
        ranges.add(HourRange(sh, sm, eh, em));
      }
      return ranges;
    }

    // Helper: elimina una fascia oraria
    Future<void> deleteShift(int staffId, int weekday, int shiftIndex) async {
      final layout = ref.read(layoutConfigProvider);
      final asyncByStaff = ref.read(staffAvailabilityByStaffProvider);
      final allData = asyncByStaff.value;
      if (allData == null) return;

      final staffData = allData[staffId];
      if (staffData == null) return;

      final daySlots = staffData[weekday];
      if (daySlots == null || daySlots.isEmpty) return;

      // Converti slots in ranges per identificare quale eliminare
      final ranges = slotsToRanges(daySlots, layout.minutesPerSlot);
      if (shiftIndex >= ranges.length) return;

      final rangeToDelete = ranges[shiftIndex];

      // Rimuovi gli slot corrispondenti a questa fascia
      final newSlots = Set<int>.from(daySlots);
      final startSlot =
          (rangeToDelete.startHour * 60 + rangeToDelete.startMinute) ~/
          layout.minutesPerSlot;
      final endSlot =
          (rangeToDelete.endHour * 60 + rangeToDelete.endMinute) ~/
          layout.minutesPerSlot;
      for (int slot = startSlot; slot < endSlot; slot++) {
        newSlots.remove(slot);
      }

      // Aggiorna il provider
      final newStaffData = Map<int, Set<int>>.from(staffData);
      newStaffData[weekday] = newSlots;

      await ref
          .read(staffAvailabilityByStaffProvider.notifier)
          .saveForStaff(staffId, newStaffData);
    }

    // Helper: mostra menu per eccezione "tutto il giorno"
    void showAllDayExceptionMenu(int staffId, int weekday, DateTime date) {
      final l10n = context.l10n;
      final isMobile = formFactor == AppFormFactor.mobile;
      final locale = Intl.getCurrentLocale();
      final dateLabel = DateFormat('EEEE d MMMM', locale).format(date);
      final staff = staffList.firstWhere(
        (s) => s.id == staffId,
        orElse: () => staffList.first,
      );
      final staffName = staff.displayName;

      // Trova tutte le eccezioni per questa data
      AvailabilityException? findAllDayException() {
        final exceptions = ref.read(
          exceptionsForStaffOnDateProvider((staffId: staffId, date: date)),
        );
        for (final exc in exceptions) {
          if (exc.isAllDay) return exc;
        }
        return null;
      }

      Future<void> deleteAllDayException() async {
        final exceptions = ref.read(
          exceptionsForStaffOnDateProvider((staffId: staffId, date: date)),
        );
        // Elimina tutte le eccezioni per questa data
        for (final exc in exceptions) {
          await ref
              .read(availabilityExceptionsProvider.notifier)
              .deleteException(staffId, exc.id);
        }
      }

      Widget buildContent(BuildContext ctx) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            ListTile(
              leading: const Icon(Icons.edit_calendar_outlined),
              title: Text(l10n.exceptionEditShift),
              subtitle: Text(
                l10n.exceptionEditShiftDesc,
                style: Theme.of(ctx).textTheme.bodySmall,
              ),
              onTap: () async {
                final exc = findAllDayException();
                if (exc == null) return;
                Navigator.pop(ctx);
                await showAddExceptionDialog(
                  context,
                  ref,
                  staffId: staffId,
                  initial: exc,
                );
              },
            ),
            const Divider(height: 1),
            ListTile(
              leading: Icon(
                Icons.restore_outlined,
                color: Theme.of(ctx).colorScheme.error,
              ),
              title: Text(
                l10n.exceptionDeleteShift,
                style: TextStyle(color: Theme.of(ctx).colorScheme.error),
              ),
              subtitle: Text(
                l10n.exceptionDeleteShiftDesc,
                style: Theme.of(ctx).textTheme.bodySmall,
              ),
              onTap: () async {
                Navigator.pop(ctx);
                await deleteAllDayException();
              },
            ),
          ],
        );
      }

      if (isMobile) {
        AppBottomSheet.show(
          context: context,
          heightFactor: null,
          builder: (ctx) => Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Center(
                child: Column(
                  children: [
                    StaffCircleAvatar(
                      height: 48,
                      color: staff.color,
                      isHighlighted: false,
                      initials: staff.initials,
                    ),
                    const SizedBox(height: 8),
                    Text(
                      staffName,
                      style: Theme.of(ctx).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                      textAlign: TextAlign.center,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 4),
              Text(
                dateLabel,
                style: Theme.of(ctx).textTheme.bodySmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              buildContent(ctx),
            ],
          ),
        );
      } else {
        showDialog(
          context: context,
          builder: (ctx) => AppFormDialog(
            title: Center(
              child: Column(
                children: [
                  StaffCircleAvatar(
                    height: 48,
                    color: staff.color,
                    isHighlighted: false,
                    initials: staff.initials,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    staffName,
                    style: Theme.of(ctx).textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                    textAlign: TextAlign.center,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 4),
                  Text(
                    dateLabel,
                    style: Theme.of(ctx).textTheme.bodySmall,
                    textAlign: TextAlign.center,
                  ),
                ],
              ),
            ),
            content: buildContent(ctx),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(ctx),
                child: Text(l10n.actionCancel),
              ),
            ],
          ),
        );
      }
    }

    // Helper: mostra menu opzioni per una fascia oraria
    void showShiftOptionsMenu(
      int staffId,
      int weekday,
      int shiftIndex,
      HourRange range,
      DateTime date, {
      bool isException = false,
    }) {
      final l10n = context.l10n;
      final isMobile = formFactor == AppFormFactor.mobile;
      final locale = Intl.getCurrentLocale();
      // Data in formato completo: "luned√¨ 1 dicembre"
      final dateLabel = DateFormat('EEEE d MMMM', locale).format(date);
      final dayName = DateFormat(
        'EEEE',
        locale,
      ).format(date); // Nome giorno completo
      // Nome completo dello staff
      final staff = staffList.firstWhere(
        (s) => s.id == staffId,
        orElse: () => staffList.first,
      );
      final staffName = staff.displayName;

      // Helper per eliminare solo questo turno (crea eccezione)
      Future<void> deleteThisOnly() async {
        await ref
            .read(availabilityExceptionsProvider.notifier)
            .addException(
              staffId: staffId,
              date: date,
              startTime: TimeOfDay(
                hour: range.startHour,
                minute: range.startMinute,
              ),
              endTime: TimeOfDay(hour: range.endHour, minute: range.endMinute),
              type: AvailabilityExceptionType.unavailable,
              reason: null,
            );
      }

      // Helper per eliminare tutti i turni (dalla disponibilit√† settimanale)
      Future<void> deleteAll() async {
        await deleteShift(staffId, weekday, shiftIndex);
      }

      // Helper per modificare solo questo turno (apre dialog per eccezione)
      Future<void> editThisOnly() async {
        final result = await _showEditShiftDialog(
          context: context,
          ref: ref,
          range: range,
          dateLabel: dateLabel,
          formFactor: formFactor,
        );
        if (result != null) {
          Future<void> addDeltaException(
            int startMinutes,
            int endMinutes,
            AvailabilityExceptionType type,
          ) async {
            if (endMinutes <= startMinutes) return;
            await ref
                .read(availabilityExceptionsProvider.notifier)
                .addException(
                  staffId: staffId,
                  date: date,
                  startTime: TimeOfDay(
                    hour: startMinutes ~/ 60,
                    minute: startMinutes % 60,
                  ),
                  endTime: TimeOfDay(
                    hour: endMinutes ~/ 60,
                    minute: endMinutes % 60,
                  ),
                  type: type,
                  reason: null,
                );
          }

          final baseStartMinutes = range.startHour * 60 + range.startMinute;
          final baseEndMinutes = range.endHour * 60 + range.endMinute;
          final newStartMinutes =
              result.startTime.hour * 60 + result.startTime.minute;
          final newEndMinutes =
              result.endTime.hour * 60 + result.endTime.minute;

          // Rimuovi le ore tolte rispetto al turno base
          if (newStartMinutes > baseStartMinutes) {
            await addDeltaException(
              baseStartMinutes,
              newStartMinutes,
              AvailabilityExceptionType.unavailable,
            );
          }
          if (newEndMinutes < baseEndMinutes) {
            await addDeltaException(
              newEndMinutes,
              baseEndMinutes,
              AvailabilityExceptionType.unavailable,
            );
          }

          // Aggiungi eventuali estensioni rispetto al turno base
          if (newStartMinutes < baseStartMinutes) {
            await addDeltaException(
              newStartMinutes,
              baseStartMinutes,
              AvailabilityExceptionType.available,
            );
          }
          if (newEndMinutes > baseEndMinutes) {
            await addDeltaException(
              baseEndMinutes,
              newEndMinutes,
              AvailabilityExceptionType.available,
            );
          }
        }
      }

      // Helper per modificare tutti i turni (naviga all'editor settimanale)
      void editAll() {
        final vn = ref.read(initialStaffToEditProvider);
        vn.value = staffId;
        Navigator.of(context).push(
          MaterialPageRoute(builder: (_) => const StaffAvailabilityScreen()),
        );
      }

      // Helper per trovare l'eccezione corrispondente a questo range
      AvailabilityException? findMatchingException() {
        final monday = _mondayOfWeek(ref.read(agendaDateProvider));
        final specificDate = monday.add(Duration(days: weekday - 1));
        final exceptions = ref.read(
          exceptionsForStaffOnDateProvider((
            staffId: staffId,
            date: specificDate,
          )),
        );
        final isAllDayRange =
            range.startHour == 0 &&
            range.startMinute == 0 &&
            range.endHour == 24 &&
            range.endMinute == 0;
        // Cerca l'eccezione che corrisponde a questo range orario
        for (final exc in exceptions) {
          if (isAllDayRange && exc.isAllDay) return exc;
          if (exc.startTime != null &&
              exc.endTime != null &&
              exc.startTime!.hour == range.startHour &&
              exc.startTime!.minute == range.startMinute &&
              exc.endTime!.hour == range.endHour &&
              exc.endTime!.minute == range.endMinute) {
            return exc;
          }
        }
        return null;
      }

      // Helper per eliminare un'eccezione
      Future<void> deleteException() async {
        final exc = findMatchingException();
        if (exc != null) {
          await ref
              .read(availabilityExceptionsProvider.notifier)
              .deleteException(staffId, exc.id);
        }
      }

      // Helper per modificare un'eccezione
      Future<void> editException() async {
        final exc = findMatchingException();
        if (exc == null) return;

        if (exc.isAllDay) {
          await showAddExceptionDialog(
            context,
            ref,
            staffId: staffId,
            initial: exc,
          );
          return;
        }

        final result = await _showEditShiftDialog(
          context: context,
          ref: ref,
          range: range,
          dateLabel: dateLabel,
          formFactor: formFactor,
        );
        if (result != null) {
          // Aggiorna l'eccezione esistente con i nuovi orari
          final updatedExc = exc.copyWith(
            startTime: result.startTime,
            endTime: result.endTime,
          );
          await ref
              .read(availabilityExceptionsProvider.notifier)
              .updateException(updatedExc);
        }
      }

      // Lista opzioni
      Widget buildOptionsList(BuildContext ctx) {
        // Se √® un'eccezione, mostra solo modifica/elimina eccezione
        if (isException) {
          return Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Modifica eccezione
              ListTile(
                leading: const Icon(Icons.edit_calendar_outlined),
                title: Text(l10n.exceptionEditShift),
                subtitle: Text(
                  l10n.exceptionEditShiftDesc,
                  style: Theme.of(ctx).textTheme.bodySmall,
                ),
                onTap: () async {
                  Navigator.pop(ctx);
                  await editException();
                },
              ),
              const Divider(height: 1),
              // Elimina eccezione
              ListTile(
                leading: Icon(
                  Icons.restore_outlined,
                  color: Theme.of(ctx).colorScheme.error,
                ),
                title: Text(
                  l10n.exceptionDeleteShift,
                  style: TextStyle(color: Theme.of(ctx).colorScheme.error),
                ),
                subtitle: Text(
                  l10n.exceptionDeleteShiftDesc,
                  style: Theme.of(ctx).textTheme.bodySmall,
                ),
                onTap: () async {
                  Navigator.pop(ctx);
                  await deleteException();
                },
              ),
              const Divider(height: 1),
              // Aggiungi eccezione
              ListTile(
                leading: const Icon(Icons.add_circle_outline),
                title: Text(l10n.exceptionsAdd),
                onTap: () {
                  Navigator.pop(ctx);
                  showAddExceptionDialog(
                    context,
                    ref,
                    staffId: staffId,
                    date: date,
                  );
                },
              ),
            ],
          );
        }

        // Menu standard per turni base
        return Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Modifica solo questo turno
            ListTile(
              leading: const Icon(Icons.edit_calendar_outlined),
              title: Text(l10n.shiftEditThisOnly),
              subtitle: Text(
                l10n.shiftEditThisOnlyDesc(dateLabel),
                style: Theme.of(ctx).textTheme.bodySmall,
              ),
              onTap: () async {
                Navigator.pop(ctx);
                await editThisOnly();
              },
            ),
            // Modifica tutti questi turni
            ListTile(
              leading: const Icon(Icons.edit_outlined),
              title: Text(l10n.shiftEditAll),
              subtitle: Text(
                l10n.shiftEditAllDesc(dayName),
                style: Theme.of(ctx).textTheme.bodySmall,
              ),
              onTap: () {
                Navigator.pop(ctx);
                editAll();
              },
            ),
            const Divider(height: 1),
            // Aggiungi eccezione
            ListTile(
              leading: const Icon(Icons.add_circle_outline),
              title: Text(l10n.exceptionsAdd),
              onTap: () {
                Navigator.pop(ctx);
                showAddExceptionDialog(
                  context,
                  ref,
                  staffId: staffId,
                  date: date,
                );
              },
            ),
            const Divider(height: 1),
            // Elimina solo questo turno
            ListTile(
              leading: Icon(
                Icons.event_busy_outlined,
                color: Theme.of(ctx).colorScheme.error,
              ),
              title: Text(
                l10n.shiftDeleteThisOnly,
                style: TextStyle(color: Theme.of(ctx).colorScheme.error),
              ),
              subtitle: Text(
                l10n.shiftDeleteThisOnlyDesc(dateLabel),
                style: Theme.of(ctx).textTheme.bodySmall,
              ),
              onTap: () async {
                Navigator.pop(ctx);
                await deleteThisOnly();
              },
            ),
            // Elimina tutti questi turni
            ListTile(
              leading: Icon(
                Icons.delete_outline,
                color: Theme.of(ctx).colorScheme.error,
              ),
              title: Text(
                l10n.shiftDeleteAll,
                style: TextStyle(color: Theme.of(ctx).colorScheme.error),
              ),
              subtitle: Text(
                l10n.shiftDeleteAllDesc(dayName),
                style: Theme.of(ctx).textTheme.bodySmall,
              ),
              onTap: () async {
                Navigator.pop(ctx);
                await deleteAll();
              },
            ),
          ],
        );
      }

      if (isMobile) {
        // Mobile: AppBottomSheet con avatar e nome
        AppBottomSheet.show(
          context: context,
          heightFactor: null, // Auto-size
          builder: (ctx) => Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Avatar con nome sotto
              Center(
                child: Column(
                  children: [
                    StaffCircleAvatar(
                      height: 48,
                      color: staff.color,
                      isHighlighted: false,
                      initials: staff.initials,
                    ),
                    const SizedBox(height: 8),
                    Text(
                      staffName,
                      style: Theme.of(ctx).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                      textAlign: TextAlign.center,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 4),
              Text(
                '${range.label(ctx)} ‚Ä¢ $dateLabel',
                style: Theme.of(ctx).textTheme.bodySmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              buildOptionsList(ctx),
            ],
          ),
        );
      } else {
        // Desktop/Tablet: AppFormDialog con avatar centrato
        showDialog(
          context: context,
          builder: (ctx) => AppFormDialog(
            title: Center(
              child: Column(
                children: [
                  StaffCircleAvatar(
                    height: 48,
                    color: staff.color,
                    isHighlighted: false,
                    initials: staff.initials,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    staffName,
                    style: Theme.of(ctx).textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                    textAlign: TextAlign.center,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 4),
                  Text(
                    '${range.label(ctx)} ‚Ä¢ $dateLabel',
                    style: Theme.of(ctx).textTheme.bodySmall,
                    textAlign: TextAlign.center,
                  ),
                ],
              ),
            ),
            content: buildOptionsList(ctx),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(ctx),
                child: Text(l10n.actionCancel),
              ),
            ],
          ),
        );
      }
    }

    // _DisplayRange √® definita a livello di file per poter essere usata nel sort.

    Widget buildDayCell(
      List<HourRange> ranges,
      List<AvailabilityException> exceptions,
      int staffId,
      int weekday,
      DateTime date, {
      bool hasException = false,
    }) {
      final displayRanges = _mergeRangesForDisplay(
        ranges,
        exceptions,
        context,
        applyUnavailableSplit: false,
        subtractAvailableFromBase: true,
      );
      final hasAllDayAvailable = exceptions.any(
        (e) =>
            e.type == AvailabilityExceptionType.available &&
            e.startTime == null &&
            e.endTime == null,
      );

      Widget buildAllDayChip() {
        final bgColor = hasAllDayAvailable
            ? chipColorWithAvailableException
            : chipColorWithException.withOpacity(0.45);
        final textColor = hasAllDayAvailable
            ? chipTextColorWithAvailableException
            : chipDisabledTextColor.withOpacity(0.7);
        final borderRadius = BorderRadius.circular(6);
        final borderColor = AgendaTheme.appointmentBorder.withOpacity(0.4);
        return Material(
          color: Colors.transparent,
          child: InkWell(
            borderRadius: BorderRadius.circular(6),
            onTap: () {
              // Mostra menu per eccezione "tutto il giorno"
              showAllDayExceptionMenu(staffId, weekday, date);
            },
            child: CustomPaint(
              painter: hasAllDayAvailable
                  ? null
                  : _DashedRoundedRectPainter(color: borderColor, radius: 6),
              child: Container(
                height: chipHeight,
                padding: const EdgeInsets.symmetric(horizontal: 8),
                alignment: Alignment.center,
                decoration: BoxDecoration(
                  color: bgColor,
                  borderRadius: borderRadius,
                  border: hasAllDayAvailable
                      ? Border.all(
                          color: AgendaTheme.appointmentBorder,
                          width: 0.6,
                        )
                      : null,
                ),
                child: Text(
                  context.l10n.exceptionAllDay,
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.w600,
                    color: textColor,
                  ),
                ),
              ),
            ),
          ),
        );
      }

      Widget buildChipForRange(_DisplayRange range) {
        final isAvailableException =
            range.exceptionType == AvailabilityExceptionType.available;
        final isUnavailableException =
            range.exceptionType == AvailabilityExceptionType.unavailable;
        final bgColor = range.isException
            ? (isAvailableException
                  ? chipColorWithAvailableException
                  : chipColorWithException.withOpacity(0.45))
            : chipColor;
        final textColor = range.isException
            ? (isAvailableException
                  ? chipTextColorWithAvailableException
                  : chipDisabledTextColor.withOpacity(0.7))
            : Colors.black87;
        final borderRadius = BorderRadius.circular(6);
        final borderColor = AgendaTheme.appointmentBorder.withOpacity(0.4);
        return Material(
          color: Colors.transparent,
          child: InkWell(
            borderRadius: BorderRadius.circular(6),
            onTap: () {
              if (range.hourRange != null) {
                final isAllDayRange =
                    range.hourRange!.startHour == 0 &&
                    range.hourRange!.startMinute == 0 &&
                    range.hourRange!.endHour == 24 &&
                    range.hourRange!.endMinute == 0;
                if (range.isException && isAllDayRange) {
                  AvailabilityException? exc;
                  for (final e in exceptions) {
                    if (e.isAllDay) {
                      exc = e;
                      break;
                    }
                  }
                  if (exc != null) {
                    showAddExceptionDialog(
                      context,
                      ref,
                      staffId: staffId,
                      initial: exc,
                    );
                    return;
                  }
                }
                if (range.isException && !isAllDayRange) {
                  AvailabilityException? exc;
                  for (final e in exceptions) {
                    if (e.startTime == null || e.endTime == null) continue;
                    if (e.startTime!.hour == range.hourRange!.startHour &&
                        e.startTime!.minute == range.hourRange!.startMinute &&
                        e.endTime!.hour == range.hourRange!.endHour &&
                        e.endTime!.minute == range.hourRange!.endMinute) {
                      exc = e;
                      break;
                    }
                  }
                  if (exc != null) {
                    showAddExceptionDialog(
                      context,
                      ref,
                      staffId: staffId,
                      initial: exc,
                    );
                    return;
                  }
                }
                showShiftOptionsMenu(
                  staffId,
                  weekday,
                  0,
                  range.hourRange!,
                  date,
                  isException: range.isException,
                );
              }
            },
            child: CustomPaint(
              painter: isUnavailableException
                  ? _DashedRoundedRectPainter(color: borderColor, radius: 6)
                  : null,
              child: Container(
                height: chipHeight,
                padding: const EdgeInsets.symmetric(horizontal: 8),
                alignment: Alignment.center,
                decoration: BoxDecoration(
                  color: bgColor,
                  borderRadius: borderRadius,
                  border: isUnavailableException
                      ? null
                      : Border.all(
                          color: AgendaTheme.appointmentBorder,
                          width: 0.6,
                        ),
                ),
                child: Text(
                  range.label,
                  maxLines: 1,
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.w600,
                    color: textColor,
                  ),
                ),
              ),
            ),
          ),
        );
      }

      return Column(
        crossAxisAlignment: CrossAxisAlignment.center,
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const SizedBox(height: chipTopPadding),
          if (displayRanges.isEmpty && hasException) ...[
            buildAllDayChip(),
            SizedBox(height: chipVGap),
          ],
          for (int i = 0; i < displayRanges.length; i++) ...[
            buildChipForRange(displayRanges[i]),
            SizedBox(height: chipVGap),
          ],
        ],
      );
    }

    return Scaffold(
      appBar: AppBar(
        centerTitle: formFactor != AppFormFactor.mobile,
        leading: const BackButton(),
        titleSpacing: formFactor == AppFormFactor.mobile ? 0 : null,
        title: StaffTopControls(
          todayLabel: context.l10n.currentWeek,
          labelOverride: weekLabel,
          compact: formFactor != AppFormFactor.desktop,
        ),
      ),
      body: ScrollConfiguration(
        behavior: const NoScrollbarBehavior(),
        child: Column(
          children: [
            const SizedBox(height: 24),
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(width: staffColWidth),
                const SizedBox(width: 8),
                Expanded(
                  child: SingleChildScrollView(
                    controller: _headerHController,
                    physics: const NeverScrollableScrollPhysics(),
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      children: [
                        for (final d in days) ...[
                          SizedBox(
                            width: dayColumnWidth,
                            child: buildDayHeaderCell(d),
                          ),
                          if (d != days.last) const SizedBox(width: 8),
                        ],
                        const SizedBox(width: rightPadding),
                      ],
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            // Body
            Expanded(
              child: SingleChildScrollView(
                controller: _vScrollController,
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Staff column
                    SizedBox(
                      width: staffColWidth,
                      child: Column(
                        children: [
                          for (int i = 0; i < staffList.length; i++) ...[
                            Container(
                              height: rowHeightForStaff(staffList[i].id),
                              padding: const EdgeInsets.symmetric(
                                horizontal: 8,
                              ),
                              alignment: Alignment.centerLeft,
                              child: buildStaffHeaderCell(staffList[i].id),
                            ),
                            divider,
                            if (i < staffList.length - 1)
                              const SizedBox(height: staffRowGap),
                          ],
                        ],
                      ),
                    ),
                    // Gap column with matching row dividers
                    SizedBox(
                      width: 8,
                      child: Column(
                        children: [
                          for (int i = 0; i < staffList.length; i++) ...[
                            SizedBox(
                              height: rowHeightForStaff(staffList[i].id),
                            ),
                            divider,
                            if (i < staffList.length - 1)
                              const SizedBox(height: staffRowGap),
                          ],
                        ],
                      ),
                    ),
                    // Days grid (with vertical separators between columns)
                    Expanded(
                      child: SingleChildScrollView(
                        controller: _bodyHController,
                        physics: const ClampingScrollPhysics(),
                        scrollDirection: Axis.horizontal,
                        child: Column(
                          children: [
                            for (int i = 0; i < staffList.length; i++) ...[
                              // Row of day cells + vertical gaps
                              Row(
                                children: [
                                  for (final d in days) ...[
                                    SizedBox(
                                      width: dayColumnWidth,
                                      height: rowHeightForStaff(
                                        staffList[i].id,
                                      ),
                                      child: buildDayCell(
                                        (availability[staffList[i].id]?[d
                                                .weekday]) ??
                                            const <HourRange>[],
                                        ref.watch(
                                          exceptionsForStaffOnDateProvider((
                                            staffId: staffList[i].id,
                                            date: d,
                                          )),
                                        ),
                                        staffList[i].id,
                                        d.weekday,
                                        d,
                                        hasException:
                                            exceptionDays[staffList[i].id]
                                                ?.contains(d.weekday) ??
                                            false,
                                      ),
                                    ),
                                    if (d != days.last)
                                      SizedBox(
                                        width: 8,
                                        height: rowHeightForStaff(
                                          staffList[i].id,
                                        ),
                                      ),
                                  ],
                                  SizedBox(
                                    width: rightPadding,
                                    height: rowHeightForStaff(staffList[i].id),
                                  ),
                                ],
                              ),
                              // Single full-width horizontal divider spanning day cells + gaps
                              Builder(
                                builder: (context) {
                                  final daysRowWidth =
                                      days.length * dayColumnWidth +
                                      (days.length - 1) * 8 +
                                      rightPadding;
                                  return SizedBox(
                                    width: daysRowWidth,
                                    child: divider,
                                  );
                                },
                              ),
                              if (i < staffList.length - 1)
                                const SizedBox(height: staffRowGap),
                            ],
                          ],
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
      /*bottomNavigationBar: formFactor != AppFormFactor.mobile
          ? null
          : SafeArea(
              top: false,
              bottom: true,
              minimum: const EdgeInsets.only(bottom: 15),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const AgendaHorizontalDivider(),
                  Padding(
                    padding: EdgeInsetsDirectional.only(
                      start: formFactor == AppFormFactor.mobile
                          ? 0
                          : staffColWidth + 8,
                      top: 15,
                      bottom: 1,
                    ),
                    child: AgendaDateSwitcher(
                      label: weekLabel,
                      selectedDate: effectivePickerDate,
                      onPreviousWeek: ref
                          .read(agendaDateProvider.notifier)
                          .previousWeek,
                      onNextWeek: ref
                          .read(agendaDateProvider.notifier)
                          .nextWeek,
                      onSelectDate: (date) {
                        ref
                            .read(agendaDateProvider.notifier)
                            .set(DateUtils.dateOnly(date));
                      },
                      useWeekRangePicker: true,
                      isCompact: true,
                    ),
                  ),
                ],
              ),
            ),*/
    );
  }
}

/// Risultato della modifica di un turno.
class _EditShiftResult {
  final TimeOfDay startTime;
  final TimeOfDay endTime;

  const _EditShiftResult({required this.startTime, required this.endTime});
}

/// Mostra il dialog per modificare un turno (solo gli orari).
Future<_EditShiftResult?> _showEditShiftDialog({
  required BuildContext context,
  required WidgetRef ref,
  required HourRange range,
  required String dateLabel,
  required AppFormFactor formFactor,
}) async {
  final isMobile = formFactor == AppFormFactor.mobile;

  if (isMobile) {
    return AppBottomSheet.show<_EditShiftResult>(
      context: context,
      heightFactor: null,
      builder: (ctx) => _EditShiftContent(range: range, dateLabel: dateLabel),
    );
  } else {
    return showDialog<_EditShiftResult>(
      context: context,
      builder: (ctx) => Dialog(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 400),
          child: _EditShiftContent(
            range: range,
            dateLabel: dateLabel,
            isDialog: true,
          ),
        ),
      ),
    );
  }
}

/// Widget per il contenuto del dialog di modifica turno.
class _EditShiftContent extends ConsumerStatefulWidget {
  const _EditShiftContent({
    required this.range,
    required this.dateLabel,
    this.isDialog = false,
  });

  final HourRange range;
  final String dateLabel;
  final bool isDialog;

  @override
  ConsumerState<_EditShiftContent> createState() => _EditShiftContentState();
}

class _EditShiftContentState extends ConsumerState<_EditShiftContent> {
  late TimeOfDay _startTime;
  late TimeOfDay _endTime;
  String? _timeError;

  @override
  void initState() {
    super.initState();
    _startTime = TimeOfDay(
      hour: widget.range.startHour,
      minute: widget.range.startMinute,
    );
    _endTime = TimeOfDay(
      hour: widget.range.endHour,
      minute: widget.range.endMinute,
    );
  }

  String _formatTime(TimeOfDay time) {
    return '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';
  }

  Future<void> _pickTime({required bool isStart}) async {
    final layout = ref.read(layoutConfigProvider);
    final step = layout.minutesPerSlot;
    final selected = await AppBottomSheet.show<TimeOfDay>(
      context: context,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      builder: (ctx) {
        final height = MediaQuery.of(ctx).size.height * 0.7;
        return SizedBox(
          height: height,
          child: _TimeGridPicker(
            initial: isStart ? _startTime : _endTime,
            stepMinutes: step,
          ),
        );
      },
    );
    if (selected != null) {
      setState(() {
        _timeError = null;
        if (isStart) {
          _startTime = selected;
          // Se l'orario di fine √® prima dell'inizio, aggiustalo
          final startMinutes = _startTime.hour * 60 + _startTime.minute;
          final endMinutes = _endTime.hour * 60 + _endTime.minute;
          if (endMinutes <= startMinutes) {
            _endTime = TimeOfDay(
              hour: (_startTime.hour + 1).clamp(0, 23),
              minute: _startTime.minute,
            );
          }
        } else {
          _endTime = selected;
        }
      });
    }
  }

  bool _validate() {
    final l10n = context.l10n;
    final startMinutes = _startTime.hour * 60 + _startTime.minute;
    final endMinutes = _endTime.hour * 60 + _endTime.minute;
    if (endMinutes <= startMinutes) {
      setState(() => _timeError = l10n.exceptionTimeError);
      return false;
    }
    return true;
  }

  void _onSave() {
    if (!_validate()) return;
    Navigator.of(
      context,
    ).pop(_EditShiftResult(startTime: _startTime, endTime: _endTime));
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;

    final content = Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Riga orari
        Row(
          children: [
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    l10n.shiftStartTime,
                    style: Theme.of(context).textTheme.labelMedium,
                  ),
                  const SizedBox(height: 4),
                  InkWell(
                    onTap: () => _pickTime(isStart: true),
                    child: InputDecorator(
                      decoration: InputDecoration(
                        border: const OutlineInputBorder(),
                        isDense: true,
                        enabledBorder: _timeError != null
                            ? OutlineInputBorder(
                                borderSide: BorderSide(
                                  color: colorScheme.error,
                                ),
                              )
                            : null,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_formatTime(_startTime)),
                          const Icon(Icons.access_time, size: 16),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    l10n.shiftEndTime,
                    style: Theme.of(context).textTheme.labelMedium,
                  ),
                  const SizedBox(height: 4),
                  InkWell(
                    onTap: () => _pickTime(isStart: false),
                    child: InputDecorator(
                      decoration: InputDecoration(
                        border: const OutlineInputBorder(),
                        isDense: true,
                        enabledBorder: _timeError != null
                            ? OutlineInputBorder(
                                borderSide: BorderSide(
                                  color: colorScheme.error,
                                ),
                              )
                            : null,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_formatTime(_endTime)),
                          const Icon(Icons.access_time, size: 16),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
        if (_timeError != null) ...[
          const SizedBox(height: 8),
          Text(
            _timeError!,
            style: TextStyle(color: colorScheme.error, fontSize: 12),
          ),
        ],
        const SizedBox(height: 24),
        // Bottoni
        Row(
          mainAxisAlignment: MainAxisAlignment.end,
          children: [
            AppOutlinedActionButton(
              onPressed: () => Navigator.of(context).pop(),
              padding: AppButtonStyles.dialogButtonPadding,
              child: Text(l10n.actionCancel),
            ),
            const SizedBox(width: 8),
            AppFilledButton(
              onPressed: _onSave,
              padding: AppButtonStyles.dialogButtonPadding,
              child: Text(l10n.actionSave),
            ),
          ],
        ),
      ],
    );

    if (widget.isDialog) {
      return Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              l10n.shiftEditTitle,
              style: Theme.of(context).textTheme.titleLarge,
            ),
            Text(
              widget.dateLabel,
              style: Theme.of(context).textTheme.bodySmall,
            ),
            const SizedBox(height: 16),
            content,
          ],
        ),
      );
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          l10n.shiftEditTitle,
          style: Theme.of(
            context,
          ).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
          textAlign: TextAlign.center,
        ),
        Text(widget.dateLabel, style: Theme.of(context).textTheme.bodySmall),
        const SizedBox(height: 16),
        content,
      ],
    );
  }
}

/// Widget per la selezione dell'orario con griglia.
class _TimeGridPicker extends StatefulWidget {
  const _TimeGridPicker({required this.initial, required this.stepMinutes});

  final TimeOfDay initial;
  final int stepMinutes;

  @override
  State<_TimeGridPicker> createState() => _TimeGridPickerState();
}

class _TimeGridPickerState extends State<_TimeGridPicker> {
  final ScrollController _scrollController = ScrollController();
  late final List<TimeOfDay?> _times;
  late final int _scrollToIndex;

  @override
  void initState() {
    super.initState();

    // Genera lista di orari con step specificato (da 00:00 a 24:00)
    _times = <TimeOfDay?>[];
    for (int m = 0; m <= 24 * 60; m += widget.stepMinutes) {
      final h = m ~/ 60;
      final min = m % 60;
      _times.add(TimeOfDay(hour: h, minute: min));
    }

    // Verifica se l'orario iniziale √® gi√† nella lista
    int exactIndex = _times.indexWhere(
      (t) =>
          t != null &&
          t.hour == widget.initial.hour &&
          t.minute == widget.initial.minute,
    );

    if (exactIndex >= 0) {
      // L'orario √® gi√† presente
      _scrollToIndex = exactIndex;
    } else {
      // L'orario non √® presente: inserisci una NUOVA RIGA con l'orario
      // nella colonna corretta e le altre colonne vuote
      final columnsPerRow = 60 ~/ widget.stepMinutes;
      final targetColumn = widget.initial.minute ~/ widget.stepMinutes;
      final baseIndex = (widget.initial.hour + 1) * columnsPerRow;

      // Crea la nuova riga con 4 elementi (solo uno valorizzato)
      final newRow = List<TimeOfDay?>.filled(columnsPerRow, null);
      newRow[targetColumn] = widget.initial;

      // Inserisci la nuova riga
      final insertIndex = baseIndex.clamp(0, _times.length);
      _times.insertAll(insertIndex, newRow);

      // L'indice dell'orario selezionato √® la posizione nella nuova riga
      _scrollToIndex = insertIndex + targetColumn;
    }

    // Scrolla all'orario preimpostato dopo il primo frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _scrollToSelected();
    });
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  void _scrollToSelected() {
    const crossAxisCount = 4;
    const mainAxisSpacing = 8.0;
    const crossAxisSpacing = 8.0;
    const padding = 8.0;

    // Calcola la riga in cui si trova l'elemento selezionato
    final row = _scrollToIndex ~/ crossAxisCount;

    // Stima l'altezza di ogni cella basandosi su una larghezza ragionevole
    if (_scrollController.hasClients) {
      final viewportWidth = _scrollController.position.viewportDimension > 0
          ? MediaQuery.of(context).size.width - padding * 2
          : 300.0;
      final cellWidth =
          (viewportWidth - crossAxisSpacing * (crossAxisCount - 1)) /
          crossAxisCount;
      final cellHeight = cellWidth / 2.5; // childAspectRatio = 2.5
      final rowHeight = cellHeight + mainAxisSpacing;

      // Calcola l'offset per centrare l'elemento selezionato
      final targetOffset = row * rowHeight;
      final maxScroll = _scrollController.position.maxScrollExtent;
      final scrollTo = targetOffset.clamp(0.0, maxScroll);

      _scrollController.animateTo(
        scrollTo,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;

    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.all(16),
          child: Text(
            l10n.exceptionSelectTime,
            style: Theme.of(context).textTheme.titleMedium,
          ),
        ),
        Expanded(
          child: GridView.builder(
            controller: _scrollController,
            padding: const EdgeInsets.all(8),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 4,
              childAspectRatio: 2.5,
              crossAxisSpacing: 8,
              mainAxisSpacing: 8,
            ),
            itemCount: _times.length,
            itemBuilder: (context, index) {
              final time = _times[index];
              // Se la cella √® vuota, mostra uno spazio vuoto
              if (time == null) {
                return const SizedBox.shrink();
              }
              final isSelected = index == _scrollToIndex;
              final label = time.hour == 24
                  ? '24:00'
                  : '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';

              return Material(
                color: isSelected
                    ? colorScheme.primaryContainer
                    : colorScheme.surfaceContainerHighest,
                borderRadius: BorderRadius.circular(8),
                child: InkWell(
                  onTap: () {
                    // Chiudi immediatamente con il valore selezionato
                    Navigator.of(context).pop(time);
                  },
                  borderRadius: BorderRadius.circular(8),
                  child: Center(
                    child: Text(
                      label,
                      style: TextStyle(
                        fontWeight: isSelected
                            ? FontWeight.bold
                            : FontWeight.normal,
                        color: isSelected
                            ? colorScheme.onPrimaryContainer
                            : colorScheme.onSurface,
                      ),
                    ),
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }
}
--- FILE: lib/features/staff/presentation/widgets/weekly_schedule_editor.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/extensions.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/features/agenda/domain/config/layout_config.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Rappresenta un singolo turno di lavoro (orario inizio - orario fine).
class WorkShift {
  final TimeOfDay startTime;
  final TimeOfDay endTime;

  const WorkShift({required this.startTime, required this.endTime});

  WorkShift copyWith({TimeOfDay? startTime, TimeOfDay? endTime}) {
    return WorkShift(
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
    );
  }

  /// Durata in minuti del turno.
  int get durationMinutes {
    final startMinutes = startTime.hour * 60 + startTime.minute;
    final endMinutes = endTime.hour * 60 + endTime.minute;
    return endMinutes - startMinutes;
  }

  /// Durata in ore (arrotondata).
  double get durationHours => durationMinutes / 60.0;
}

/// Rappresenta la disponibilit√† di un singolo giorno.
class DaySchedule {
  final bool isEnabled;
  final List<WorkShift> shifts;

  const DaySchedule({this.isEnabled = false, this.shifts = const []});

  DaySchedule copyWith({bool? isEnabled, List<WorkShift>? shifts}) {
    return DaySchedule(
      isEnabled: isEnabled ?? this.isEnabled,
      shifts: shifts ?? this.shifts,
    );
  }

  /// Totale ore lavorate nel giorno.
  int get totalHours {
    if (!isEnabled || shifts.isEmpty) return 0;
    final totalMinutes = shifts.fold<int>(
      0,
      (sum, shift) => sum + shift.durationMinutes,
    );
    return (totalMinutes / 60).round();
  }
}

/// Rappresenta la pianificazione settimanale completa.
class WeeklySchedule {
  /// Mappa giorno (1=luned√¨, 7=domenica) -> DaySchedule
  final Map<int, DaySchedule> days;

  const WeeklySchedule({required this.days});

  factory WeeklySchedule.empty() {
    return WeeklySchedule(
      days: {for (int i = 1; i <= 7; i++) i: const DaySchedule()},
    );
  }

  /// Crea una pianificazione con valori di default (lun-sab 09:00-18:00).
  factory WeeklySchedule.defaultSchedule() {
    return WeeklySchedule(
      days: {
        for (int i = 1; i <= 6; i++)
          i: DaySchedule(
            isEnabled: true,
            shifts: [
              const WorkShift(
                startTime: TimeOfDay(hour: 9, minute: 0),
                endTime: TimeOfDay(hour: 18, minute: 0),
              ),
            ],
          ),
        7: const DaySchedule(isEnabled: false, shifts: []),
      },
    );
  }

  WeeklySchedule copyWith({Map<int, DaySchedule>? days}) {
    return WeeklySchedule(days: days ?? this.days);
  }

  /// Totale ore settimanali.
  int get totalHours {
    return days.values.fold<int>(0, (sum, day) => sum + day.totalHours);
  }

  /// Unifica le fasce orarie contigue (dove la fine di una coincide con l'inizio della successiva).
  /// Ritorna una nuova WeeklySchedule con le fasce unificate.
  WeeklySchedule mergeContiguousShifts() {
    final Map<int, DaySchedule> mergedDays = {};

    for (final entry in days.entries) {
      final day = entry.key;
      final schedule = entry.value;

      if (!schedule.isEnabled || schedule.shifts.length <= 1) {
        // Nessuna unificazione necessaria
        mergedDays[day] = schedule;
        continue;
      }

      // Ordina le fasce per orario di inizio
      final sortedShifts = List<WorkShift>.from(schedule.shifts)
        ..sort((a, b) {
          final aMinutes = a.startTime.hour * 60 + a.startTime.minute;
          final bMinutes = b.startTime.hour * 60 + b.startTime.minute;
          return aMinutes.compareTo(bMinutes);
        });

      // Unifica fasce contigue
      final List<WorkShift> mergedShifts = [];
      WorkShift? current;

      for (final shift in sortedShifts) {
        if (current == null) {
          current = shift;
        } else {
          // Controlla se la fine di current coincide con l'inizio di shift
          final currentEndMinutes =
              current.endTime.hour * 60 + current.endTime.minute;
          final shiftStartMinutes =
              shift.startTime.hour * 60 + shift.startTime.minute;

          if (currentEndMinutes == shiftStartMinutes) {
            // Fasce contigue: unisci
            current = WorkShift(
              startTime: current.startTime,
              endTime: shift.endTime,
            );
          } else {
            // Non contigue: salva current e inizia nuovo
            mergedShifts.add(current);
            current = shift;
          }
        }
      }

      // Aggiungi l'ultima fascia
      if (current != null) {
        mergedShifts.add(current);
      }

      mergedDays[day] = DaySchedule(
        isEnabled: schedule.isEnabled,
        shifts: mergedShifts,
      );
    }

    return WeeklySchedule(days: mergedDays);
  }

  /// Converte da formato slot a WeeklySchedule.
  /// [minutesPerSlot] √® tipicamente 15.
  factory WeeklySchedule.fromSlots(
    Map<int, Set<int>> slots, {
    int minutesPerSlot = 15,
  }) {
    final Map<int, DaySchedule> days = {};

    for (int day = 1; day <= 7; day++) {
      final daySlots = slots[day] ?? <int>{};
      if (daySlots.isEmpty) {
        days[day] = const DaySchedule(isEnabled: false, shifts: []);
        continue;
      }

      // Ordina e raggruppa slot consecutivi in turni
      final sortedSlots = daySlots.toList()..sort();
      final List<WorkShift> shifts = [];

      int? rangeStart;
      int? rangePrev;

      for (final slot in sortedSlots) {
        if (rangeStart == null) {
          rangeStart = slot;
          rangePrev = slot;
        } else if (slot == rangePrev! + 1) {
          // Slot consecutivo
          rangePrev = slot;
        } else {
          // Gap trovato, chiudi range precedente
          shifts.add(_slotsToShift(rangeStart, rangePrev, minutesPerSlot));
          rangeStart = slot;
          rangePrev = slot;
        }
      }

      // Aggiungi ultimo range
      if (rangeStart != null && rangePrev != null) {
        shifts.add(_slotsToShift(rangeStart, rangePrev, minutesPerSlot));
      }

      days[day] = DaySchedule(isEnabled: shifts.isNotEmpty, shifts: shifts);
    }

    return WeeklySchedule(days: days);
  }

  static WorkShift _slotsToShift(
    int startSlot,
    int endSlot,
    int minutesPerSlot,
  ) {
    final startMinutes = startSlot * minutesPerSlot;
    final endMinutes =
        (endSlot + 1) * minutesPerSlot; // +1 perch√© endSlot √® incluso
    return WorkShift(
      startTime: TimeOfDay(hour: startMinutes ~/ 60, minute: startMinutes % 60),
      endTime: TimeOfDay(hour: endMinutes ~/ 60, minute: endMinutes % 60),
    );
  }

  /// Converte WeeklySchedule a formato slot.
  Map<int, Set<int>> toSlots({int minutesPerSlot = 15}) {
    final Map<int, Set<int>> result = {};

    for (final entry in days.entries) {
      final day = entry.key;
      final schedule = entry.value;

      if (!schedule.isEnabled || schedule.shifts.isEmpty) {
        result[day] = <int>{};
        continue;
      }

      final Set<int> daySlots = {};
      for (final shift in schedule.shifts) {
        final startMinutes = shift.startTime.hour * 60 + shift.startTime.minute;
        final endMinutes = shift.endTime.hour * 60 + shift.endTime.minute;

        // Converti range di minuti a slot
        for (int m = startMinutes; m < endMinutes; m += minutesPerSlot) {
          daySlots.add(m ~/ minutesPerSlot);
        }
      }
      result[day] = daySlots;
    }

    return result;
  }
}

/// Widget per la modifica della pianificazione settimanale.
class WeeklyScheduleEditor extends StatefulWidget {
  final WeeklySchedule initialSchedule;
  final ValueChanged<WeeklySchedule>? onChanged;
  final bool showHeader;

  const WeeklyScheduleEditor({
    super.key,
    required this.initialSchedule,
    this.onChanged,
    this.showHeader = true,
  });

  @override
  State<WeeklyScheduleEditor> createState() => _WeeklyScheduleEditorState();
}

class _WeeklyScheduleEditorState extends State<WeeklyScheduleEditor> {
  late WeeklySchedule _schedule;

  @override
  void initState() {
    super.initState();
    _schedule = widget.initialSchedule;
  }

  @override
  void didUpdateWidget(WeeklyScheduleEditor oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.initialSchedule != oldWidget.initialSchedule) {
      _schedule = widget.initialSchedule;
    }
  }

  void _updateSchedule(WeeklySchedule newSchedule) {
    setState(() => _schedule = newSchedule);
    widget.onChanged?.call(newSchedule);
  }

  void _toggleDay(int day) {
    final currentDay = _schedule.days[day]!;
    final newDay = currentDay.copyWith(
      isEnabled: !currentDay.isEnabled,
      shifts: !currentDay.isEnabled && currentDay.shifts.isEmpty
          ? [
              const WorkShift(
                startTime: TimeOfDay(hour: 9, minute: 0),
                endTime: TimeOfDay(hour: 18, minute: 0),
              ),
            ]
          : currentDay.shifts,
    );
    _updateSchedule(_schedule.copyWith(days: {..._schedule.days, day: newDay}));
  }

  void _updateShift(int day, int shiftIndex, WorkShift newShift) {
    final currentDay = _schedule.days[day]!;
    final newShifts = List<WorkShift>.from(currentDay.shifts);
    newShifts[shiftIndex] = newShift;
    _updateSchedule(
      _schedule.copyWith(
        days: {
          ..._schedule.days,
          day: currentDay.copyWith(shifts: newShifts),
        },
      ),
    );
  }

  void _addShift(int day) {
    final currentDay = _schedule.days[day]!;
    final lastShift = currentDay.shifts.isNotEmpty
        ? currentDay.shifts.last
        : null;
    final newStartHour = lastShift != null ? lastShift.endTime.hour + 1 : 9;
    final newShift = WorkShift(
      startTime: TimeOfDay(hour: newStartHour.clamp(0, 22), minute: 0),
      endTime: TimeOfDay(hour: (newStartHour + 1).clamp(1, 23), minute: 0),
    );
    _updateSchedule(
      _schedule.copyWith(
        days: {
          ..._schedule.days,
          day: currentDay.copyWith(shifts: [...currentDay.shifts, newShift]),
        },
      ),
    );
  }

  void _removeShift(int day, int shiftIndex) {
    final currentDay = _schedule.days[day]!;
    final newShifts = List<WorkShift>.from(currentDay.shifts)
      ..removeAt(shiftIndex);
    // Se non ci sono pi√π turni, disabilita il giorno
    final isEnabled = newShifts.isNotEmpty;
    _updateSchedule(
      _schedule.copyWith(
        days: {
          ..._schedule.days,
          day: currentDay.copyWith(shifts: newShifts, isEnabled: isEnabled),
        },
      ),
    );
  }

  List<String> _getDayNames(BuildContext context) {
    final l10n = context.l10n;
    return [
      l10n.dayMondayFull,
      l10n.dayTuesdayFull,
      l10n.dayWednesdayFull,
      l10n.dayThursdayFull,
      l10n.dayFridayFull,
      l10n.daySaturdayFull,
      l10n.daySundayFull,
    ];
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final dayNames = _getDayNames(context);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.min,
      children: [
        // Header con titolo e ore totali (opzionale)
        if (widget.showHeader)
          Padding(
            padding: const EdgeInsets.only(bottom: 16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  l10n.weeklyScheduleTitle,
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  l10n.weeklyScheduleTotalHours(_schedule.totalHours),
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                ),
              ],
            ),
          ),

        // Lista dei giorni - sfondo a tutta larghezza, contenuto centrato
        Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: List.generate(7, (index) {
            final day = index + 1;
            final daySchedule = _schedule.days[day]!;
            final dayName = dayNames[index];

            return _DayRow(
              day: day,
              dayName: dayName,
              allDayNames: dayNames,
              schedule: daySchedule,
              onToggle: () => _toggleDay(day),
              onShiftChanged: (shiftIndex, shift) =>
                  _updateShift(day, shiftIndex, shift),
              onAddShift: () => _addShift(day),
              onRemoveShift: (shiftIndex) => _removeShift(day, shiftIndex),
              isFirst: index == 0,
            );
          }),
        ),
      ],
    );
  }
}

/// Riga per un singolo giorno.
class _DayRow extends ConsumerWidget {
  final int day;
  final String dayName;
  final List<String> allDayNames;
  final DaySchedule schedule;
  final VoidCallback onToggle;
  final void Function(int shiftIndex, WorkShift shift) onShiftChanged;
  final VoidCallback onAddShift;
  final void Function(int shiftIndex) onRemoveShift;
  final bool isFirst;

  const _DayRow({
    required this.day,
    required this.dayName,
    required this.allDayNames,
    required this.schedule,
    required this.onToggle,
    required this.onShiftChanged,
    required this.onAddShift,
    required this.onRemoveShift,
    this.isFirst = false,
  });

  /// Calcola la larghezza massima tra tutti i nomi dei giorni
  double _getMaxDayNameWidth(BuildContext context, TextStyle? style) {
    double maxWidth = 0;
    final textPainter = TextPainter(textDirection: TextDirection.ltr);
    for (final name in allDayNames) {
      textPainter.text = TextSpan(text: name, style: style);
      textPainter.layout();
      if (textPainter.width > maxWidth) {
        maxWidth = textPainter.width;
      }
    }
    return maxWidth;
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final formFactor = ref.watch(formFactorProvider);
    final isMobile = formFactor == AppFormFactor.mobile;

    if (isMobile) {
      return _buildMobileLayout(context, l10n, theme);
    }
    return _buildDesktopLayout(context, l10n, theme);
  }

  /// Layout mobile: verticale (header sopra, turni sotto)
  Widget _buildMobileLayout(
    BuildContext context,
    dynamic l10n,
    ThemeData theme,
  ) {
    // Sfondo alternato: trasparente per dispari, colorato per pari
    final interactionColors = theme.extension<AppInteractionColors>();
    final backgroundColor = day.isEven
        ? interactionColors?.alternatingRowFill
        : null;

    final dayNameStyle = theme.textTheme.bodyLarge?.copyWith(
      fontWeight: FontWeight.w500,
    );
    final maxDayNameWidth = _getMaxDayNameWidth(context, dayNameStyle);

    return Container(
      color: backgroundColor,
      padding: EdgeInsets.only(top: isFirst ? 16 : 8, bottom: 8),
      child: Center(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: IntrinsicWidth(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Header: checkbox + nome giorno + ore + icone
                Row(
                  mainAxisAlignment: MainAxisAlignment.start,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    // Checkbox inline con il nome
                    Transform.scale(
                      scale: 1.1,
                      child: Checkbox(
                        value: schedule.isEnabled,
                        onChanged: (_) => onToggle(),
                        activeColor: theme.colorScheme.primary,
                        visualDensity: VisualDensity.compact,
                        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                      ),
                    ),

                    // Nome giorno con larghezza fissa (calcolata dinamicamente)
                    SizedBox(
                      width: maxDayNameWidth,
                      child: Text(dayName, style: dayNameStyle),
                    ),
                    if (schedule.isEnabled && schedule.totalHours > 0) ...[
                      const SizedBox(width: 8),
                      Text(
                        '${schedule.totalHours}h',
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ],

                    // Icone azioni (solo se abilitato)
                    if (schedule.isEnabled) ...[
                      const SizedBox(width: 8),
                      IconButton(
                        onPressed: onAddShift,
                        icon: Icon(
                          Icons.add_circle_outline,
                          color: theme.colorScheme.primary,
                        ),
                        tooltip: l10n.weeklyScheduleAddShift,
                        constraints: const BoxConstraints(
                          minWidth: 36,
                          minHeight: 36,
                        ),
                        padding: EdgeInsets.zero,
                        iconSize: 22,
                      ),
                    ],
                  ],
                ),

                // Contenuto turni o "Non lavora"
                if (schedule.isEnabled)
                  Padding(
                    padding: const EdgeInsets.only(top: 8),
                    child: Column(
                      children: [
                        for (int i = 0; i < schedule.shifts.length; i++)
                          Padding(
                            padding: EdgeInsets.only(
                              bottom: i < schedule.shifts.length - 1 ? 8 : 0,
                            ),
                            child: _ShiftRowMobile(
                              shift: schedule.shifts[i],
                              onChanged: (shift) => onShiftChanged(i, shift),
                              onRemove: () => onRemoveShift(i),
                              previousShiftEndTime: i > 0
                                  ? schedule.shifts[i - 1].endTime
                                  : null,
                            ),
                          ),
                      ],
                    ),
                  )
                else
                  Padding(
                    padding: const EdgeInsets.only(top: 4),
                    child: Text(
                      l10n.weeklyScheduleNotWorking,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  /// Layout desktop/tablet: orizzontale
  Widget _buildDesktopLayout(
    BuildContext context,
    dynamic l10n,
    ThemeData theme,
  ) {
    // Sfondo alternato: trasparente per dispari, colorato per pari
    final interactionColors = theme.extension<AppInteractionColors>();
    final backgroundColor = day.isEven
        ? interactionColors?.alternatingRowFill
        : null;

    final dayNameStyle = theme.textTheme.bodyLarge?.copyWith(
      fontWeight: FontWeight.w500,
    );
    final maxDayNameWidth = _getMaxDayNameWidth(context, dayNameStyle);

    return Container(
      color: backgroundColor,
      padding: EdgeInsets.only(top: isFirst ? 16 : 8, bottom: 8),
      child: Center(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: IntrinsicWidth(
            child: Row(
              mainAxisAlignment: MainAxisAlignment.start,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                // Checkbox
                Checkbox(
                  value: schedule.isEnabled,
                  onChanged: (_) => onToggle(),
                  activeColor: theme.colorScheme.primary,
                ),
                const SizedBox(width: 12),

                // Nome giorno e ore con larghezza fissa (calcolata dinamicamente)
                SizedBox(
                  width: maxDayNameWidth,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    mainAxisAlignment: MainAxisAlignment.center,
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text(dayName, style: dayNameStyle),
                      if (schedule.isEnabled && schedule.totalHours > 0)
                        Text(
                          '${schedule.totalHours}h',
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                        ),
                    ],
                  ),
                ),
                const SizedBox(width: 16),

                // Contenuto turni o "Non lavora" - larghezza minima fissa per allineamento
                // Larghezza: 2 dropdown (100*2) + 3 spacing (12*3) + testo "per" (~30) + 2 pulsanti (40*2)
                ConstrainedBox(
                  constraints: const BoxConstraints(
                    minWidth:
                        _TimeDropdown.dropdownWidth * 2 + 12 * 3 + 30 + 40 * 2,
                  ),
                  child: schedule.isEnabled
                      ? Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            for (int i = 0; i < schedule.shifts.length; i++)
                              Padding(
                                padding: EdgeInsets.only(
                                  bottom: i < schedule.shifts.length - 1
                                      ? 8
                                      : 0,
                                ),
                                child: _ShiftRow(
                                  shift: schedule.shifts[i],
                                  onChanged: (shift) =>
                                      onShiftChanged(i, shift),
                                  onAdd: onAddShift,
                                  onRemove: () => onRemoveShift(i),
                                  showAddButton:
                                      i == schedule.shifts.length - 1,
                                  previousShiftEndTime: i > 0
                                      ? schedule.shifts[i - 1].endTime
                                      : null,
                                ),
                              ),
                          ],
                        )
                      : Text(
                          l10n.weeklyScheduleNotWorking,
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                        ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

/// Riga turno per layout mobile (senza icona add, con delete)
class _ShiftRowMobile extends StatelessWidget {
  final WorkShift shift;
  final ValueChanged<WorkShift> onChanged;
  final VoidCallback onRemove;

  /// Orario di fine della fascia precedente (se esiste).
  /// Usato per impostare il minimo dell'orario di inizio.
  final TimeOfDay? previousShiftEndTime;

  const _ShiftRowMobile({
    required this.shift,
    required this.onChanged,
    required this.onRemove,
    this.previousShiftEndTime,
  });

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        // Orario inizio - minimo = fine fascia precedente (se esiste)
        _TimeDropdown(
          value: shift.startTime,
          minTime: previousShiftEndTime,
          onChanged: (time) => onChanged(shift.copyWith(startTime: time)),
        ),
        const SizedBox(width: 8),

        // "per"
        Text(
          l10n.weeklyScheduleFor,
          style: theme.textTheme.bodyMedium?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
        const SizedBox(width: 8),

        // Orario fine - minimo = orario inizio corrente
        _TimeDropdown(
          value: shift.endTime,
          minTime: shift.startTime,
          onChanged: (time) => onChanged(shift.copyWith(endTime: time)),
        ),
        const SizedBox(width: 8),

        // Pulsante rimuovi
        IconButton(
          onPressed: onRemove,
          icon: Icon(
            Icons.delete_outline,
            color: theme.colorScheme.error,
            size: 20,
          ),
          tooltip: l10n.weeklyScheduleRemoveShift,
          constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
          padding: EdgeInsets.zero,
        ),
      ],
    );
  }
}

/// Riga per un singolo turno con dropdown orari.
class _ShiftRow extends StatelessWidget {
  final WorkShift shift;
  final ValueChanged<WorkShift> onChanged;
  final VoidCallback onAdd;
  final VoidCallback onRemove;
  final bool showAddButton;

  /// Orario di fine della fascia precedente (se esiste).
  /// Usato per impostare il minimo dell'orario di inizio.
  final TimeOfDay? previousShiftEndTime;

  const _ShiftRow({
    required this.shift,
    required this.onChanged,
    required this.onAdd,
    required this.onRemove,
    this.showAddButton = false,
    this.previousShiftEndTime,
  });

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        // Orario inizio - minimo = fine fascia precedente (se esiste)
        _TimeDropdown(
          value: shift.startTime,
          minTime: previousShiftEndTime,
          onChanged: (time) => onChanged(shift.copyWith(startTime: time)),
        ),
        const SizedBox(width: 12),

        // "per"
        Text(
          l10n.weeklyScheduleFor,
          style: theme.textTheme.bodyMedium?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
        const SizedBox(width: 12),

        // Orario fine - minimo = orario inizio corrente
        _TimeDropdown(
          value: shift.endTime,
          minTime: shift.startTime,
          onChanged: (time) => onChanged(shift.copyWith(endTime: time)),
        ),
        const SizedBox(width: 12),

        // Pulsante aggiungi (solo sull'ultimo turno)
        if (showAddButton)
          IconButton(
            onPressed: onAdd,
            icon: Icon(
              Icons.add_circle_outline,
              color: theme.colorScheme.primary,
            ),
            tooltip: l10n.weeklyScheduleAddShift,
            constraints: const BoxConstraints(minWidth: 40, minHeight: 40),
            padding: EdgeInsets.zero,
          )
        else
          const SizedBox(width: 40),

        // Pulsante rimuovi
        IconButton(
          onPressed: onRemove,
          icon: Icon(Icons.delete_outline, color: theme.colorScheme.error),
          tooltip: l10n.weeklyScheduleRemoveShift,
          constraints: const BoxConstraints(minWidth: 40, minHeight: 40),
          padding: EdgeInsets.zero,
        ),
      ],
    );
  }
}

/// Dropdown per la selezione dell'orario.
class _TimeDropdown extends StatelessWidget {
  final TimeOfDay value;
  final ValueChanged<TimeOfDay> onChanged;

  /// Orario minimo selezionabile (incluso). Se null, parte da 00:00.
  final TimeOfDay? minTime;

  /// Larghezza del dropdown (formato HH:MM + padding + icona)
  static const double dropdownWidth = 100.0;

  const _TimeDropdown({
    required this.value,
    required this.onChanged,
    this.minTime,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    // Genera opzioni con incremento pari a minutesPerSlotConst
    final allOptions = <TimeOfDay>[];
    for (int hour = 0; hour < 24; hour++) {
      for (
        int minute = 0;
        minute < 60;
        minute += LayoutConfig.minutesPerSlotConst
      ) {
        allOptions.add(TimeOfDay(hour: hour, minute: minute));
      }
    }

    // Filtra le opzioni in base a minTime
    final options = allOptions.where((time) {
      final timeMinutes = time.hour * 60 + time.minute;
      if (minTime != null) {
        final minMinutes = minTime!.hour * 60 + minTime!.minute;
        if (timeMinutes < minMinutes) return false;
      }
      return true;
    }).toList();

    // Se non ci sono opzioni valide, usa tutte le opzioni
    final effectiveOptions = options.isEmpty ? allOptions : options;

    return SizedBox(
      width: dropdownWidth,
      child: Container(
        decoration: BoxDecoration(
          border: Border.all(color: theme.colorScheme.outline.withOpacity(0.5)),
          borderRadius: BorderRadius.circular(8),
        ),
        child: DropdownButtonHideUnderline(
          child: DropdownButton<TimeOfDay>(
            value: _findClosestOption(value, effectiveOptions),
            isExpanded: true,
            alignment: Alignment.center,
            borderRadius: BorderRadius.circular(8),
            icon: const SizedBox.shrink(),
            items: effectiveOptions.map((time) {
              return DropdownMenuItem(
                value: time,
                alignment: Alignment.center,
                child: Text(_formatTime(time)),
              );
            }).toList(),
            onChanged: (time) {
              if (time != null) onChanged(time);
            },
          ),
        ),
      ),
    );
  }

  TimeOfDay _findClosestOption(TimeOfDay value, List<TimeOfDay> options) {
    // Trova l'opzione pi√π vicina al valore attuale
    TimeOfDay closest = options.first;
    int minDiff = _timeDiff(value, closest).abs();

    for (final option in options) {
      final diff = _timeDiff(value, option).abs();
      if (diff < minDiff) {
        minDiff = diff;
        closest = option;
      }
    }
    return closest;
  }

  int _timeDiff(TimeOfDay a, TimeOfDay b) {
    return (a.hour * 60 + a.minute) - (b.hour * 60 + b.minute);
  }

  String _formatTime(TimeOfDay time) {
    final hour = time.hour.toString().padLeft(2, '0');
    final minute = time.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }
}
--- FILE: lib/features/staff/presentation/widgets/staff_item.dart ---
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/theme/extensions.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/staff.dart';
import '../../../services/providers/services_provider.dart';

class StaffItem extends ConsumerStatefulWidget {
  const StaffItem({
    super.key,
    required this.staff,
    required this.isLast,
    required this.isEvenRow,
    required this.isWide,
    required this.onEdit,
    required this.onDuplicate,
    required this.onDelete,
    this.trailingOverride,
  });

  final Staff staff;
  final bool isLast;
  final bool isEvenRow;
  final bool isWide;
  final VoidCallback onEdit;
  final VoidCallback onDuplicate;
  final VoidCallback onDelete;
  final Widget? trailingOverride;

  @override
  ConsumerState<StaffItem> createState() => _StaffItemState();
}

class _StaffItemState extends ConsumerState<StaffItem> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final interactionColors = Theme.of(
      context,
    ).extension<AppInteractionColors>();
    final colorScheme = Theme.of(context).colorScheme;
    final baseColor = widget.isEvenRow
        ? (interactionColors?.alternatingRowFill ??
              colorScheme.onSurface.withOpacity(0.04))
        : Colors.transparent;
    final hoverFill =
        interactionColors?.hoverFill ??
        colorScheme.primaryContainer.withOpacity(0.1);
    final bgColor = _isHovered ? hoverFill : baseColor;

    final eligibleServices = ref.watch(
      eligibleServicesForStaffProvider(widget.staff.id),
    );
    final eligibleServicesCount = eligibleServices.length;

    return MouseRegion(
      cursor: SystemMouseCursors.click,
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: Container(
        decoration: BoxDecoration(
          color: bgColor,
          borderRadius: BorderRadius.only(
            bottomLeft: widget.isLast ? const Radius.circular(16) : Radius.zero,
            bottomRight: widget.isLast
                ? const Radius.circular(16)
                : Radius.zero,
          ),
        ),
        child: ListTile(
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 10,
          ),
          minVerticalPadding: 0,
          leading: StaffCircleAvatar(
            height: 36,
            color: widget.staff.color,
            isHighlighted: false,
            initials: widget.staff.initials,
          ),
          title: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Row(
                children: [
                  Expanded(
                    child: Text(
                      widget.staff.displayName,
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ),
                  const SizedBox(width: 8),
                  Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 6,
                      vertical: 2,
                    ),
                    decoration: BoxDecoration(
                      color: colorScheme.surfaceContainerHighest,
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: Text(
                      'ID: ${widget.staff.id}',
                      style: Theme.of(context).textTheme.labelSmall?.copyWith(
                        color: colorScheme.onSurfaceVariant,
                        fontFamily: 'monospace',
                      ),
                    ),
                  ),
                ],
              ),
              if (eligibleServicesCount == 0) ...[
                const SizedBox(height: 2),
                Text(
                  context.l10n.teamEligibleServicesNone,
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.error,
                    fontStyle: FontStyle.italic,
                  ),
                ),
              ],
              if (!widget.staff.isBookableOnline) ...[
                const SizedBox(height: 2),
                Text(
                  context.l10n.staffNotBookableOnlineTooltip,
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                    color: Theme.of(context).colorScheme.error,
                    fontStyle: FontStyle.italic,
                  ),
                ),
              ],
            ],
          ),
          onTap: widget.onEdit,
          mouseCursor: SystemMouseCursors.click,
          trailing:
              widget.trailingOverride ??
              (widget.isWide
                  ? Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        IconButton(
                          tooltip: context.l10n.actionEdit,
                          icon: const Icon(Icons.edit_outlined),
                          onPressed: widget.onEdit,
                        ),
                        IconButton(
                          tooltip: context.l10n.duplicateAction,
                          icon: const Icon(Icons.copy_outlined),
                          onPressed: widget.onDuplicate,
                        ),
                        IconButton(
                          tooltip: context.l10n.actionDelete,
                          icon: const Icon(Icons.delete_outline),
                          onPressed: widget.onDelete,
                        ),
                      ],
                    )
                  : PopupMenuButton<String>(
                      onSelected: (value) {
                        if (value == 'edit') widget.onEdit();
                        if (value == 'duplicate') widget.onDuplicate();
                        if (value == 'delete') widget.onDelete();
                      },
                      itemBuilder: (context) => [
                        PopupMenuItem(
                          value: 'edit',
                          child: Text(context.l10n.actionEdit),
                        ),
                        PopupMenuItem(
                          value: 'duplicate',
                          child: Text(context.l10n.duplicateAction),
                        ),
                        PopupMenuItem(
                          value: 'delete',
                          child: Text(context.l10n.actionDelete),
                        ),
                      ],
                    )),
        ),
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/widgets/staff_hub_card.dart ---
import 'package:flutter/material.dart';

import '../../../../core/l10n/l10_extension.dart';

class StaffHubCard extends StatelessWidget {
  const StaffHubCard({
    super.key,
    required this.icon,
    required this.title,
    required this.subtitle,
    required this.onTap,
    this.disabled = false,
  });

  final IconData icon;
  final String title;
  final String subtitle;
  final VoidCallback onTap;
  final bool disabled;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final baseColor = disabled
        ? colorScheme.surfaceVariant
        : colorScheme.secondaryContainer;
    final fgColor = disabled
        ? colorScheme.onSurfaceVariant.withOpacity(0.6)
        : colorScheme.onSecondaryContainer;

    return InkWell(
      onTap: disabled ? null : onTap,
      borderRadius: BorderRadius.circular(12),
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 180),
        padding: const EdgeInsets.all(18),
        width: 260,
        decoration: BoxDecoration(
          color: baseColor,
          borderRadius: BorderRadius.circular(12),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.08),
              blurRadius: 6,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Icon(icon, size: 32, color: fgColor),
            const SizedBox(height: 12),
            Text(
              title,
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.w600,
                color: fgColor,
              ),
            ),
            const SizedBox(height: 6),
            Text(
              subtitle,
              style: TextStyle(fontSize: 14, color: fgColor.withOpacity(0.85)),
            ),
            if (disabled)
              Padding(
                padding: const EdgeInsets.only(top: 8.0),
                child: Text(
                  context.l10n.staffHubNotYetAvailable,
                  style: const TextStyle(
                    fontSize: 12,
                    fontStyle: FontStyle.italic,
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/widgets/location_item.dart ---
import 'package:flutter/material.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/location.dart';
import '../../../../core/models/staff.dart';
import '../../../services/presentation/widgets/empty_state.dart';
import 'staff_item.dart';

class LocationItem extends StatelessWidget {
  const LocationItem({
    super.key,
    required this.location,
    required this.staff,
    required this.isWide,
    required this.onAddStaff,
    required this.onEditLocation,
    required this.onDeleteLocation,
    required this.onEditStaff,
    required this.onDuplicateStaff,
    required this.onDeleteStaff,
    this.headerTrailing,
    this.staffListOverride,
    this.showDefaultActions = true,
  });

  final Location location;
  final List<Staff> staff;
  final bool isWide;
  final VoidCallback onAddStaff;
  final VoidCallback onEditLocation;
  final VoidCallback onDeleteLocation;
  final ValueChanged<Staff> onEditStaff;
  final ValueChanged<Staff> onDuplicateStaff;
  final ValueChanged<Staff> onDeleteStaff;
  final Widget? headerTrailing;
  final Widget? staffListOverride;
  final bool showDefaultActions;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final isEmptyLocation = staff.isEmpty;

    return Container(
      margin: const EdgeInsets.only(bottom: 24),
      decoration: BoxDecoration(
        color: colorScheme.surface,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 6,
            offset: const Offset(0, 3),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            width: double.infinity,
            decoration: BoxDecoration(
              color: colorScheme.primaryContainer,
              borderRadius: const BorderRadius.vertical(
                top: Radius.circular(16),
              ),
            ),
            padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),
            child: Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Expanded(
                            child: Text(
                              location.name,
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                              style: Theme.of(context).textTheme.titleMedium
                                  ?.copyWith(
                                    fontWeight: FontWeight.w600,
                                    color: colorScheme.onPrimaryContainer,
                                  ),
                            ),
                          ),
                          const SizedBox(width: 8),
                          Container(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 6,
                              vertical: 2,
                            ),
                            decoration: BoxDecoration(
                              color: colorScheme.onPrimaryContainer.withOpacity(
                                0.15,
                              ),
                              borderRadius: BorderRadius.circular(4),
                            ),
                            child: Text(
                              'ID: ${location.id}',
                              style: Theme.of(context).textTheme.labelSmall
                                  ?.copyWith(
                                    color: colorScheme.onPrimaryContainer,
                                    fontFamily: 'monospace',
                                  ),
                            ),
                          ),
                        ],
                      ),
                      if (location.address != null &&
                          location.address!.isNotEmpty)
                        Padding(
                          padding: const EdgeInsets.only(top: 4),
                          child: Text(
                            location.address!,
                            maxLines: 2,
                            overflow: TextOverflow.ellipsis,
                            style: Theme.of(context).textTheme.bodySmall
                                ?.copyWith(
                                  color: colorScheme.onPrimaryContainer
                                      .withOpacity(0.8),
                                ),
                          ),
                        ),
                    ],
                  ),
                ),
                const SizedBox(width: 12),
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    if (showDefaultActions) ...[
                      IconButton(
                        tooltip: context.l10n.teamAddStaff,
                        icon: Icon(
                          Icons.person_add_alt_1,
                          color: colorScheme.onPrimaryContainer,
                        ),
                        onPressed: onAddStaff,
                      ),
                      IconButton(
                        tooltip: context.l10n.actionEdit,
                        icon: Icon(
                          Icons.edit_outlined,
                          color: colorScheme.onPrimaryContainer,
                        ),
                        onPressed: onEditLocation,
                      ),
                      if (isEmptyLocation)
                        IconButton(
                          tooltip: context.l10n.actionDelete,
                          icon: const Icon(Icons.delete_outline),
                          color: colorScheme.onPrimaryContainer,
                          onPressed: onDeleteLocation,
                        ),
                    ],
                    if (headerTrailing != null) headerTrailing!,
                  ],
                ),
              ],
            ),
          ),
          ClipRRect(
            borderRadius: const BorderRadius.vertical(
              bottom: Radius.circular(16),
            ),
            child:
                staffListOverride ??
                (isEmptyLocation
                    ? ServicesEmptyState(
                        message: context.l10n.teamNoStaffInLocation,
                      )
                    : Column(
                        children: [
                          for (int i = 0; i < staff.length; i++)
                            StaffItem(
                              staff: staff[i],
                              isLast: i == staff.length - 1,
                              isEvenRow: i.isEven,
                              isWide: isWide,
                              onEdit: () => onEditStaff(staff[i]),
                              onDuplicate: () => onDuplicateStaff(staff[i]),
                              onDelete: () => onDeleteStaff(staff[i]),
                            ),
                        ],
                      )),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/widgets/exception_calendar_view.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/availability_exception.dart';
import '../../providers/availability_exceptions_provider.dart';
import '../dialogs/add_exception_dialog.dart';

/// Widget per visualizzare e gestire le eccezioni alla disponibilit√†
/// in una vista calendario mensile.
class ExceptionCalendarView extends ConsumerStatefulWidget {
  const ExceptionCalendarView({super.key, required this.staffId});

  final int staffId;

  @override
  ConsumerState<ExceptionCalendarView> createState() =>
      _ExceptionCalendarViewState();
}

String? _localizedReasonCode(String? code, BuildContext context) {
  if (code == null || code.isEmpty) return null;
  final l10n = context.l10n;
  switch (code) {
    case 'vacation':
      return l10n.exceptionReasonVacation;
    case 'extra_shift':
      return l10n.exceptionReasonExtraShift;
    case 'medical_visit':
      return l10n.exceptionReasonMedicalVisit;
  }
  return null;
}

class _ExceptionCalendarViewState extends ConsumerState<ExceptionCalendarView> {
  late DateTime _currentMonth;

  @override
  void initState() {
    super.initState();
    _currentMonth = DateTime.now();
    _loadExceptions();
  }

  Future<void> _loadExceptions() async {
    // Carica eccezioni per un range di 3 mesi (mese corrente ¬± 1)
    final from = DateTime(_currentMonth.year, _currentMonth.month - 1, 1);
    final to = DateTime(_currentMonth.year, _currentMonth.month + 2, 0);
    await ref
        .read(availabilityExceptionsProvider.notifier)
        .loadExceptionsForStaff(widget.staffId, fromDate: from, toDate: to);
  }

  void _previousMonth() {
    setState(() {
      _currentMonth = DateTime(_currentMonth.year, _currentMonth.month - 1, 1);
    });
    _loadExceptions();
  }

  void _nextMonth() {
    setState(() {
      _currentMonth = DateTime(_currentMonth.year, _currentMonth.month + 1, 1);
    });
    _loadExceptions();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final exceptions = ref.watch(allExceptionsForStaffProvider(widget.staffId));

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Header con titolo e navigazione mese
        Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              Expanded(
                child: Text(
                  l10n.exceptionsTitle,
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              FilledButton.icon(
                onPressed: () => showAddExceptionDialog(
                  context,
                  ref,
                  staffId: widget.staffId,
                ),
                icon: const Icon(Icons.add, size: 18),
                label: Text(l10n.exceptionsAdd),
              ),
            ],
          ),
        ),

        // Navigazione mese
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              IconButton(
                onPressed: _previousMonth,
                icon: const Icon(Icons.chevron_left),
              ),
              Text(
                _formatMonth(_currentMonth),
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
              ),
              IconButton(
                onPressed: _nextMonth,
                icon: const Icon(Icons.chevron_right),
              ),
            ],
          ),
        ),

        const SizedBox(height: 8),

        // Griglia calendario
        _CalendarGrid(
          month: _currentMonth,
          exceptions: exceptions,
          staffId: widget.staffId,
          onDayTap: (date) => _onDayTap(date, exceptions),
        ),

        const SizedBox(height: 16),

        // Lista eccezioni del mese
        _ExceptionsList(
          exceptions: _filterExceptionsForMonth(exceptions),
          staffId: widget.staffId,
        ),
      ],
    );
  }

  String _formatMonth(DateTime date) {
    final locale = Localizations.localeOf(context).toLanguageTag();
    return DateFormat('MMMM y', locale).format(date);
  }

  List<AvailabilityException> _filterExceptionsForMonth(
    List<AvailabilityException> exceptions,
  ) {
    return exceptions.where((e) {
      return e.date.year == _currentMonth.year &&
          e.date.month == _currentMonth.month;
    }).toList()..sort((a, b) => a.date.compareTo(b.date));
  }

  void _onDayTap(DateTime date, List<AvailabilityException> exceptions) {
    final dayExceptions = exceptions.where((e) => e.isOnDate(date)).toList();

    if (dayExceptions.isEmpty) {
      // Nessuna eccezione: apri dialog per crearne una nuova
      showAddExceptionDialog(context, ref, staffId: widget.staffId, date: date);
    } else if (dayExceptions.length == 1) {
      // Una sola eccezione: apri dialog per modificarla
      showAddExceptionDialog(
        context,
        ref,
        staffId: widget.staffId,
        initial: dayExceptions.first,
      );
    } else {
      // Pi√π eccezioni: mostra bottom sheet con lista
      _showExceptionsForDay(date, dayExceptions);
    }
  }

  void _showExceptionsForDay(
    DateTime date,
    List<AvailabilityException> exceptions,
  ) {
    showModalBottomSheet(
      context: context,
      builder: (ctx) => SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Padding(
              padding: const EdgeInsets.all(16),
              child: Text(
                '${date.day}/${date.month}/${date.year}',
                style: Theme.of(ctx).textTheme.titleMedium,
              ),
            ),
            ...exceptions.map(
              (e) => ListTile(
                leading: Icon(
                  e.type == AvailabilityExceptionType.available
                      ? Icons.check_circle
                      : Icons.block,
                  color: e.type == AvailabilityExceptionType.available
                      ? Colors.green
                      : Theme.of(ctx).colorScheme.error,
                ),
                title: Text(
                  e.reason ??
                      _localizedReasonCode(e.reasonCode, context) ??
                      _getDefaultReason(e.type, context),
                ),
                subtitle: Text(
                  e.isAllDay
                      ? context.l10n.exceptionAllDay
                      : _formatTimeRange(e, context),
                ),
                onTap: () {
                  Navigator.pop(ctx);
                  showAddExceptionDialog(
                    context,
                    ref,
                    staffId: widget.staffId,
                    initial: e,
                  );
                },
              ),
            ),
            const SizedBox(height: 16),
          ],
        ),
      ),
    );
  }

  String _getDefaultReason(
    AvailabilityExceptionType type,
    BuildContext context,
  ) {
    return type == AvailabilityExceptionType.available
        ? context.l10n.exceptionTypeAvailable
        : context.l10n.exceptionTypeUnavailable;
  }

  String _formatTimeRange(AvailabilityException e, BuildContext context) {
    if (e.isAllDay) return context.l10n.exceptionAllDay;
    final start =
        '${e.startTime!.hour.toString().padLeft(2, '0')}:${e.startTime!.minute.toString().padLeft(2, '0')}';
    final end =
        '${e.endTime!.hour.toString().padLeft(2, '0')}:${e.endTime!.minute.toString().padLeft(2, '0')}';
    return '$start - $end';
  }
}

/// Griglia calendario mensile.
class _CalendarGrid extends ConsumerWidget {
  const _CalendarGrid({
    required this.month,
    required this.exceptions,
    required this.staffId,
    required this.onDayTap,
  });

  final DateTime month;
  final List<AvailabilityException> exceptions;
  final int staffId;
  final ValueChanged<DateTime> onDayTap;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    // Calcola primo e ultimo giorno del mese
    final firstDay = DateTime(month.year, month.month, 1);
    final lastDay = DateTime(month.year, month.month + 1, 0);
    final daysInMonth = lastDay.day;

    // Giorno della settimana del primo giorno (1=lun, 7=dom)
    final firstWeekday = firstDay.weekday;

    // Celle vuote iniziali + giorni del mese
    final totalCells = ((firstWeekday - 1) + daysInMonth);
    final rows = (totalCells / 7).ceil();

    final today = DateTime.now();

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      child: Column(
        children: [
          // Header giorni settimana
          Row(
            children: ['L', 'M', 'M', 'G', 'V', 'S', 'D']
                .map(
                  (d) => Expanded(
                    child: Center(
                      child: Text(
                        d,
                        style: theme.textTheme.bodySmall?.copyWith(
                          fontWeight: FontWeight.bold,
                          color: colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ),
                  ),
                )
                .toList(),
          ),
          const SizedBox(height: 8),
          // Griglia giorni
          ...List.generate(rows, (rowIndex) {
            return Row(
              children: List.generate(7, (colIndex) {
                final cellIndex = rowIndex * 7 + colIndex;
                final dayNumber = cellIndex - (firstWeekday - 1) + 1;

                if (dayNumber < 1 || dayNumber > daysInMonth) {
                  return const Expanded(child: SizedBox(height: 44));
                }

                final date = DateTime(month.year, month.month, dayNumber);
                final isToday =
                    date.year == today.year &&
                    date.month == today.month &&
                    date.day == today.day;

                // Trova eccezioni per questo giorno
                final dayExceptions = exceptions
                    .where((e) => e.isOnDate(date))
                    .toList();

                return Expanded(
                  child: GestureDetector(
                    onTap: () => onDayTap(date),
                    child: Container(
                      height: 44,
                      margin: const EdgeInsets.all(2),
                      decoration: BoxDecoration(
                        color: isToday
                            ? colorScheme.primaryContainer.withOpacity(0.5)
                            : null,
                        borderRadius: BorderRadius.circular(8),
                        border: isToday
                            ? Border.all(color: colorScheme.primary, width: 2)
                            : null,
                      ),
                      child: Stack(
                        alignment: Alignment.center,
                        children: [
                          Text(
                            dayNumber.toString(),
                            style: theme.textTheme.bodyMedium?.copyWith(
                              fontWeight: isToday
                                  ? FontWeight.bold
                                  : FontWeight.normal,
                            ),
                          ),
                          // Indicatori eccezioni
                          if (dayExceptions.isNotEmpty)
                            Positioned(
                              bottom: 4,
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: dayExceptions.take(3).map((e) {
                                  return Container(
                                    width: 6,
                                    height: 6,
                                    margin: const EdgeInsets.symmetric(
                                      horizontal: 1,
                                    ),
                                    decoration: BoxDecoration(
                                      shape: BoxShape.circle,
                                      color:
                                          e.type ==
                                              AvailabilityExceptionType
                                                  .available
                                          ? Colors.green
                                          : colorScheme.error,
                                    ),
                                  );
                                }).toList(),
                              ),
                            ),
                        ],
                      ),
                    ),
                  ),
                );
              }),
            );
          }),
        ],
      ),
    );
  }
}

/// Lista delle eccezioni del mese.
class _ExceptionsList extends ConsumerWidget {
  const _ExceptionsList({required this.exceptions, required this.staffId});

  final List<AvailabilityException> exceptions;
  final int staffId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final colorScheme = theme.colorScheme;

    if (exceptions.isEmpty) {
      return Padding(
        padding: const EdgeInsets.all(16),
        child: Center(
          child: Text(
            l10n.exceptionsEmpty,
            style: theme.textTheme.bodyMedium?.copyWith(
              color: colorScheme.onSurfaceVariant,
            ),
          ),
        ),
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Divider(),
        ...exceptions.map(
          (e) => _ExceptionTile(exception: e, staffId: staffId),
        ),
      ],
    );
  }
}

/// Tile per singola eccezione.
class _ExceptionTile extends ConsumerWidget {
  const _ExceptionTile({required this.exception, required this.staffId});

  final AvailabilityException exception;
  final int staffId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    final isAvailable = exception.type == AvailabilityExceptionType.available;
    final color = isAvailable ? Colors.green : colorScheme.error;

    return ListTile(
      leading: Container(
        width: 40,
        height: 40,
        decoration: BoxDecoration(
          color: color.withOpacity(0.1),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Icon(
          isAvailable ? Icons.check_circle_outline : Icons.block_outlined,
          color: color,
        ),
      ),
      title: Text(
        exception.reason ??
            _localizedReasonCode(exception.reasonCode, context) ??
            (isAvailable
                ? context.l10n.exceptionTypeAvailable
                : context.l10n.exceptionTypeUnavailable),
        style: theme.textTheme.bodyLarge,
      ),
      subtitle: Text(
        '${_formatDate(context, exception.date)} ‚Ä¢ ${_formatTimeRange(exception, context)}',
        style: theme.textTheme.bodySmall?.copyWith(
          color: colorScheme.onSurfaceVariant,
        ),
      ),
      trailing: IconButton(
        icon: const Icon(Icons.edit_outlined),
        onPressed: () => showAddExceptionDialog(
          context,
          ref,
          staffId: staffId,
          initial: exception,
        ),
      ),
      onTap: () => showAddExceptionDialog(
        context,
        ref,
        staffId: staffId,
        initial: exception,
      ),
    );
  }

  String _formatDate(BuildContext context, DateTime date) {
    final locale = Localizations.localeOf(context).toLanguageTag();
    final weekday = DateFormat('EEE', locale).format(date);
    return '$weekday ${date.day}/${date.month}';
  }

  String _formatTimeRange(AvailabilityException e, BuildContext context) {
    if (e.isAllDay) return context.l10n.exceptionAllDay;
    final start =
        '${e.startTime!.hour.toString().padLeft(2, '0')}:${e.startTime!.minute.toString().padLeft(2, '0')}';
    final end =
        '${e.endTime!.hour.toString().padLeft(2, '0')}:${e.endTime!.minute.toString().padLeft(2, '0')}';
    return '$start - $end';
  }
}
--- FILE: lib/features/staff/widgets/staff_top_controls.dart ---
import 'package:agenda_backend/app/widgets/top_controls.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class StaffTopControls extends ConsumerWidget {
  const StaffTopControls({
    super.key,
    this.todayLabel,
    this.labelOverride,
    this.compact = false,
  });

  final String? todayLabel;
  final String? labelOverride;
  final bool compact;
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return TopControls.staff(
      todayLabel: todayLabel,
      labelOverride: labelOverride,
      compact: compact,
    );
  }
}
--- FILE: lib/features/services/services_feature.dart ---
--- FILE: lib/features/services/providers/services_sorted_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import 'service_categories_provider.dart';
import 'services_provider.dart';

/// Liste ordinate con queste priorit√†:
/// 1) Categorie con servizi prima, categorie vuote in coda
/// 2) sortOrder crescente
/// 3) nome come tie-breaker
final sortedCategoriesProvider = Provider<List<ServiceCategory>>((ref) {
  final cats = ref.watch(serviceCategoriesProvider);

  // Pre-calcolo: per ogni categoria verifichiamo se ha servizi.
  final hasServicesMap = <int, bool>{
    for (final c in cats)
      c.id: ref.watch(servicesByCategoryProvider(c.id)).isNotEmpty,
  };

  final copy = [...cats];
  copy.sort((a, b) {
    final aEmpty = !(hasServicesMap[a.id] ?? false);
    final bEmpty = !(hasServicesMap[b.id] ?? false);

    // Vuote in coda: una categoria vuota deve venire dopo una non vuota.
    if (aEmpty != bEmpty) return aEmpty ? 1 : -1;

    final so = a.sortOrder.compareTo(b.sortOrder);
    return so != 0 ? so : a.name.toLowerCase().compareTo(b.name.toLowerCase());
  });
  return copy;
});

final sortedServicesByCategoryProvider = Provider.family<List<Service>, int>((
  ref,
  categoryId,
) {
  final services = ref.watch(servicesByCategoryProvider(categoryId));
  final copy = [...services];
  copy.sort((a, b) {
    final so = a.sortOrder.compareTo(b.sortOrder);
    return so != 0 ? so : a.name.toLowerCase().compareTo(b.name.toLowerCase());
  });
  return copy;
});
--- FILE: lib/features/services/providers/services_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/service.dart';
import '../../../core/models/service_staff_eligibility.dart';
import '../../../core/models/service_variant.dart';
import '../../agenda/providers/location_providers.dart';
import '../../auth/providers/auth_provider.dart';
import '../../staff/providers/staff_providers.dart';
import '../utils/service_seed_texts.dart';
import 'service_categories_provider.dart';
import 'services_repository_provider.dart';

// Le categorie sono ora gestite in providers/service_categories_provider.dart

///
/// SERVICES NOTIFIER (CRUD via API)
///
class ServicesNotifier extends AsyncNotifier<List<Service>> {
  @override
  Future<List<Service>> build() async {
    // Verifica autenticazione
    final authState = ref.watch(authProvider);
    if (!authState.isAuthenticated) {
      return [];
    }

    final location = ref.watch(currentLocationProvider);
    if (location.id <= 0) {
      return [];
    }

    final repository = ref.watch(servicesRepositoryProvider);

    // Carica servizi E categorie dall'API
    final result = await repository.getServicesWithCategories(
      locationId: location.id,
    );

    // Popola le categorie nel provider dedicato
    ref
        .read(serviceCategoriesProvider.notifier)
        .setCategories(result.categories);

    return result.services;
  }

  /// Ricarica servizi e categorie dall'API
  Future<void> refresh() async {
    // Verifica autenticazione
    final authState = ref.read(authProvider);
    if (!authState.isAuthenticated) {
      return;
    }

    final location = ref.read(currentLocationProvider);
    if (location.id <= 0) {
      return;
    }

    state = const AsyncLoading();

    try {
      final repository = ref.read(servicesRepositoryProvider);
      final result = await repository.getServicesWithCategories(
        locationId: location.id,
      );

      // Popola le categorie nel provider dedicato
      ref
          .read(serviceCategoriesProvider.notifier)
          .setCategories(result.categories);

      state = AsyncData(result.services);
    } catch (e, st) {
      state = AsyncError(e, st);
    }
  }

  void setServices(List<Service> services) {
    state = AsyncData(services);
  }

  // ===== API METHODS =====

  /// Creates a new service via API and updates local state
  Future<Service?> createServiceApi({
    required String name,
    int? categoryId,
    String? description,
    int durationMinutes = 30,
    double price = 0,
    String? colorHex,
    bool isBookableOnline = true,
    bool isPriceStartingFrom = false,
  }) async {
    final repository = ref.read(servicesRepositoryProvider);
    final location = ref.read(currentLocationProvider);

    if (location.id <= 0) return null;

    try {
      final newService = await repository.createService(
        locationId: location.id,
        name: name,
        categoryId: categoryId,
        description: description,
        durationMinutes: durationMinutes,
        price: price,
        colorHex: colorHex,
        isBookableOnline: isBookableOnline,
        isPriceStartingFrom: isPriceStartingFrom,
      );

      // Add to local state
      final current = state.value ?? [];
      state = AsyncData([...current, newService]);

      ref
          .read(serviceCategoriesProvider.notifier)
          .bumpEmptyCategoriesToEnd(servicesOverride: state.value);

      return newService;
    } catch (e) {
      // Keep old state on error
      return null;
    }
  }

  /// Updates a service via API and updates local state
  Future<Service?> updateServiceApi({
    required int serviceId,
    String? name,
    int? categoryId,
    bool setCategoryIdNull = false,
    String? description,
    int? durationMinutes,
    double? price,
    String? colorHex,
    bool? isBookableOnline,
    bool? isPriceStartingFrom,
    int? sortOrder,
  }) async {
    final repository = ref.read(servicesRepositoryProvider);
    final location = ref.read(currentLocationProvider);

    if (location.id <= 0) return null;

    try {
      final updatedService = await repository.updateService(
        serviceId: serviceId,
        locationId: location.id,
        name: name,
        categoryId: categoryId,
        setCategoryIdNull: setCategoryIdNull,
        description: description,
        durationMinutes: durationMinutes,
        price: price,
        colorHex: colorHex,
        isBookableOnline: isBookableOnline,
        isPriceStartingFrom: isPriceStartingFrom,
        sortOrder: sortOrder,
      );

      // Update local state
      final current = state.value ?? [];
      state = AsyncData([
        for (final s in current)
          if (s.id == updatedService.id) updatedService else s,
      ]);

      ref
          .read(serviceCategoriesProvider.notifier)
          .bumpEmptyCategoriesToEnd(servicesOverride: state.value);

      return updatedService;
    } catch (e) {
      return null;
    }
  }

  /// Deletes a service via API and updates local state
  Future<bool> deleteServiceApi(int serviceId) async {
    final repository = ref.read(servicesRepositoryProvider);

    try {
      await repository.deleteService(serviceId);

      // Remove from local state
      final current = state.value ?? [];
      final newList = current.where((s) => s.id != serviceId).toList();
      state = AsyncData(newList);

      ref.read(serviceVariantsProvider.notifier).removeByServiceId(serviceId);

      ref
          .read(serviceCategoriesProvider.notifier)
          .bumpEmptyCategoriesToEnd(servicesOverride: newList);

      return true;
    } catch (e) {
      return false;
    }
  }

  /// Duplicates a service via API (creates new with modified name)
  Future<Service?> duplicateServiceApi(Service original) async {
    final current = state.value ?? [];
    final existingNames = current.map((s) => s.name).toSet();
    final duplicateName = _makeDuplicateName(original.name, existingNames);

    return createServiceApi(
      name: duplicateName,
      categoryId: original.categoryId,
      description: original.description,
      durationMinutes: original.durationMinutes ?? 30,
      price: original.price ?? 0,
      colorHex: original.color,
      isPriceStartingFrom: original.isPriceStartingFrom,
    );
  }

  // ===== LOCAL METHODS (legacy, for backward compatibility) =====

  @Deprecated('Use createServiceApi instead for persistence')
  void add(Service service) {
    final current = state.value ?? [];
    state = AsyncData([...current, service]);
    ref
        .read(serviceCategoriesProvider.notifier)
        .bumpEmptyCategoriesToEnd(servicesOverride: state.value);
  }

  @Deprecated('Use updateServiceApi instead for persistence')
  void updateService(Service updated) {
    final current = state.value ?? [];
    state = AsyncData([
      for (final s in current)
        if (s.id == updated.id) updated else s,
    ]);
    ref
        .read(serviceCategoriesProvider.notifier)
        .bumpEmptyCategoriesToEnd(servicesOverride: state.value);
  }

  @Deprecated('Use deleteServiceApi instead for persistence')
  void delete(int id) {
    final current = state.value ?? [];
    final newList = current.where((s) => s.id != id).toList();
    state = AsyncData(newList);
    ref.read(serviceVariantsProvider.notifier).removeByServiceId(id);
    ref
        .read(serviceCategoriesProvider.notifier)
        .bumpEmptyCategoriesToEnd(servicesOverride: newList);
  }

  @Deprecated('Use duplicateServiceApi instead for persistence')
  void duplicate(Service original) {
    final current = state.value ?? [];
    final newId = _nextId(current);
    final existingNames = current.map((s) => s.name).toSet();

    final copy = Service(
      id: newId,
      businessId: original.businessId,
      categoryId: original.categoryId,
      name: _makeDuplicateName(original.name, existingNames),
      description: original.description,
    );
    add(copy);

    ref
        .read(serviceCategoriesProvider.notifier)
        .bumpEmptyCategoriesToEnd(servicesOverride: state.value);
  }

  // ===== HELPER METHODS =====

  String _makeDuplicateName(String originalName, Set<String> existingNames) {
    final copyWord = ServiceSeedTexts.duplicateCopyWord;
    final copyWordEscaped = RegExp.escape(copyWord);
    String base = originalName;
    int? startFrom;

    final reNew = RegExp(
      '^(.*?)(?:\\s$copyWordEscaped(?:\\s(\\d+))?)\$',
      caseSensitive: false,
    );
    final reOld = RegExp(
      '^(.*?)(?:\\s\\((?:$copyWordEscaped)(?:\\s(\\d+))?\\))\$',
      caseSensitive: false,
    );

    RegExpMatch? m =
        reNew.firstMatch(originalName) ?? reOld.firstMatch(originalName);
    if (m != null) {
      base = (m.group(1) ?? '').trim();
      final n = m.group(2);
      if (n != null) {
        final parsed = int.tryParse(n);
        if (parsed != null) startFrom = parsed + 1;
      } else {
        startFrom = 1;
      }
    }

    String candidate = '$base $copyWord';
    if (!existingNames.contains(candidate)) return candidate;

    int i = startFrom ?? 1;
    while (true) {
      candidate = '$base $copyWord $i';
      if (!existingNames.contains(candidate)) return candidate;
      i++;
      if (i > 9999) break;
    }
    return '$base $copyWord';
  }

  int _nextId(List<Service> current) {
    if (current.isEmpty) return 1;
    final maxId = current.map((s) => s.id).reduce((a, b) => a > b ? a : b);
    return maxId + 1;
  }
}

final servicesProvider = AsyncNotifierProvider<ServicesNotifier, List<Service>>(
  ServicesNotifier.new,
);

///
/// VARIANTI SERVIZI (da API, filtrate per location)
///
class ServiceVariantsNotifier extends AsyncNotifier<List<ServiceVariant>> {
  @override
  Future<List<ServiceVariant>> build() async {
    final services = await ref.watch(servicesProvider.future);
    final location = ref.watch(currentLocationProvider);
    final currency = ref.watch(effectiveCurrencyProvider);

    // Map services to variants usando ID reale da API
    return services
        .map(
          (s) => ServiceVariant(
            // Usa serviceVariantId da API se disponibile, altrimenti fallback
            id: s.serviceVariantId ?? s.id,
            serviceId: s.id,
            locationId: location.id,
            durationMinutes: s.durationMinutes ?? 30,
            price: s.price ?? 0.0,
            colorHex: s.color ?? '#CCCCCC',
            currency: currency,
            isBookableOnline: true,
            isFree: (s.price ?? 0) == 0,
            isPriceStartingFrom: false,
            resourceRequirements: const [],
            processingTime: 0,
            blockedTime: 0,
          ),
        )
        .toList();
  }

  void upsert(ServiceVariant variant) {
    final current = state.value ?? [];
    state = AsyncData([
      for (final v in current)
        if (v.id == variant.id) variant else v,
      if (!current.any((v) => v.id == variant.id)) variant,
    ]);
  }

  void removeByServiceId(int serviceId) {
    final current = state.value ?? [];
    state = AsyncData(current.where((v) => v.serviceId != serviceId).toList());
  }
}

final serviceVariantsProvider =
    AsyncNotifierProvider<ServiceVariantsNotifier, List<ServiceVariant>>(
      ServiceVariantsNotifier.new,
    );

///
/// SERVICE VARIANT BY ID
///
final serviceVariantByIdProvider = Provider.family<ServiceVariant?, int>((
  ref,
  variantId,
) {
  final variantsAsync = ref.watch(serviceVariantsProvider);
  final variants = variantsAsync.value ?? [];
  for (final variant in variants) {
    if (variant.id == variantId) return variant;
  }
  return null;
});

final serviceVariantByServiceIdProvider = Provider.family<ServiceVariant?, int>(
  (ref, serviceId) {
    final location = ref.watch(currentLocationProvider);
    final variantsAsync = ref.watch(serviceVariantsProvider);
    final variants = variantsAsync.value ?? [];
    for (final variant in variants) {
      if (variant.serviceId == serviceId && variant.locationId == location.id) {
        return variant;
      }
    }
    return null;
  },
);

///
/// ELIGIBILITY STAFF
///
/// Questo provider ora legge i service_ids direttamente dal modello Staff
/// che √® stato caricato dall'API. Non usa pi√π dati mock.
///
class ServiceStaffEligibilityNotifier
    extends Notifier<List<ServiceStaffEligibility>> {
  @override
  List<ServiceStaffEligibility> build() {
    // Legge da allStaffProvider per costruire l'eligibilit√†
    final staffAsync = ref.watch(allStaffProvider);
    final staffList = staffAsync.value ?? [];

    final List<ServiceStaffEligibility> eligibilities = [];
    for (final staff in staffList) {
      for (final serviceId in staff.serviceIds) {
        // Per ogni location dello staff, crea un'eligibilit√†
        if (staff.locationIds.isEmpty) {
          // Staff disponibile in tutte le location
          eligibilities.add(
            ServiceStaffEligibility(serviceId: serviceId, staffId: staff.id),
          );
        } else {
          for (final locationId in staff.locationIds) {
            eligibilities.add(
              ServiceStaffEligibility(
                serviceId: serviceId,
                staffId: staff.id,
                locationId: locationId,
              ),
            );
          }
        }
      }
    }
    return eligibilities;
  }

  /// Metodo per aggiornare lo stato locale (solo UI)
  /// L'effettivo salvataggio avviene tramite StaffNotifier.updateStaffApi
  void setEligibleStaffForService({
    required int serviceId,
    required int locationId,
    required Iterable<int> staffIds,
  }) {
    final retained = [
      for (final entry in state)
        if (!(entry.serviceId == serviceId &&
            (entry.locationId == null || entry.locationId == locationId)))
          entry,
    ];
    final updated = [
      for (final staffId in staffIds)
        ServiceStaffEligibility(
          serviceId: serviceId,
          staffId: staffId,
          locationId: locationId,
        ),
    ];
    state = [...retained, ...updated];
  }

  /// Metodo per aggiornare lo stato locale (solo UI)
  /// L'effettivo salvataggio avviene tramite StaffNotifier.updateStaffApi
  void setEligibleServicesForStaff({
    required int staffId,
    required int locationId,
    required Iterable<int> serviceIds,
  }) {
    final retained = [
      for (final entry in state)
        if (!(entry.staffId == staffId &&
            (entry.locationId == null || entry.locationId == locationId)))
          entry,
    ];
    final updated = [
      for (final serviceId in serviceIds)
        ServiceStaffEligibility(
          serviceId: serviceId,
          staffId: staffId,
          locationId: locationId,
        ),
    ];
    state = [...retained, ...updated];
  }
}

final serviceStaffEligibilityProvider =
    NotifierProvider<
      ServiceStaffEligibilityNotifier,
      List<ServiceStaffEligibility>
    >(ServiceStaffEligibilityNotifier.new);

final eligibleStaffForServiceProvider = Provider.family<List<int>, int>((
  ref,
  serviceId,
) {
  final location = ref.watch(currentLocationProvider);
  final elegibility = ref.watch(serviceStaffEligibilityProvider);

  return [
    for (final entry in elegibility)
      if (entry.serviceId == serviceId &&
          (entry.locationId == null || entry.locationId == location.id))
        entry.staffId,
  ];
});

final eligibleServicesForStaffProvider = Provider.family<List<int>, int>((
  ref,
  staffId,
) {
  // Legge direttamente dal modello Staff invece di usare serviceStaffEligibilityProvider
  final staffAsync = ref.watch(allStaffProvider);
  final staffList = staffAsync.value ?? [];
  final staff = staffList.where((s) => s.id == staffId).firstOrNull;
  return staff?.serviceIds ?? [];
});

///
/// SERVICES PER CATEGORIA
///
final servicesByCategoryProvider = Provider.family<List<Service>, int>((
  ref,
  categoryId,
) {
  final servicesAsync = ref.watch(servicesProvider);
  final services = servicesAsync.value ?? [];
  return [
    for (final service in services)
      if (service.categoryId == categoryId) service,
  ];
});
--- FILE: lib/features/services/providers/services_reorder_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/l10n/l10n.dart';
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/network/network_providers.dart';
import 'service_categories_provider.dart';
import 'services_provider.dart';

/// Gestisce la modalit√† riordino e applica gli ordinamenti aggiornando sortOrder
class ServicesReorderNotifier extends Notifier<bool> {
  @override
  bool build() => false; // false = non in riordino

  void toggle() => state = !state;

  void setReordering(bool value) => state = value;

  /// Riordina le categorie a livello top
  Future<void> reorderCategories(int oldIndex, int newIndex) async {
    final notifier = ref.read(serviceCategoriesProvider.notifier);
    final list = [...ref.read(serviceCategoriesProvider)];

    if (newIndex > oldIndex) newIndex -= 1;

    final item = list.removeAt(oldIndex);
    list.insert(newIndex, item);

    final reordered = <ServiceCategory>[];
    for (int i = 0; i < list.length; i++) {
      reordered.add(list[i].copyWith(sortOrder: i));
    }

    notifier.state = reordered;

    // Persist to API
    await _persistCategoriesOrder(reordered);
  }

  /// Riordina solo le categorie NON vuote, mantenendo le vuote in coda e non spostabili.
  Future<void> reorderNonEmptyCategories(int oldIndex, int newIndex) async {
    final catsNotifier = ref.read(serviceCategoriesProvider.notifier);
    final allCats = [...ref.read(serviceCategoriesProvider)];
    final services = ref.read(servicesProvider).value ?? [];

    final nonEmpty = <ServiceCategory>[];
    final empty = <ServiceCategory>[];
    for (final c in allCats) {
      final hasServices = services.any((s) => s.categoryId == c.id);
      if (hasServices) {
        nonEmpty.add(c);
      } else {
        empty.add(c);
      }
    }

    final item = nonEmpty.removeAt(oldIndex);
    final insertIndex = newIndex.clamp(0, nonEmpty.length);
    nonEmpty.insert(insertIndex, item);

    final merged = [...nonEmpty, ...empty];
    final reordered = <ServiceCategory>[];
    for (int i = 0; i < merged.length; i++) {
      reordered.add(merged[i].copyWith(sortOrder: i));
    }

    catsNotifier.state = reordered;

    // Persist to API
    await _persistCategoriesOrder(reordered);
  }

  /// Riordina i servizi all'interno della stessa categoria
  Future<void> reorderServices(
    int categoryId,
    int oldIndex,
    int newIndex,
  ) async {
    final servicesNotifier = ref.read(servicesProvider.notifier);
    final all = [...(ref.read(servicesProvider).value ?? [])];

    final byCat = all.where((s) => s.categoryId == categoryId).toList();
    final item = byCat.removeAt(oldIndex);
    byCat.insert(newIndex, item);

    final updatedByCat = <Service>[];
    for (int i = 0; i < byCat.length; i++) {
      updatedByCat.add(byCat[i].copyWith(sortOrder: i));
    }

    final updatedAll = <Service>[
      for (final s in all)
        if (s.categoryId == categoryId)
          updatedByCat.firstWhere((x) => x.id == s.id)
        else
          s,
    ];

    servicesNotifier.setServices(updatedAll);

    // Persist to API - only services in this category
    await _persistServicesOrder(updatedByCat);
  }

  /// üîÑ Sposta un servizio da una categoria all'altra (drag cross-categoria)
  Future<void> moveServiceBetweenCategories(
    int oldCategoryId,
    int newCategoryId,
    int serviceId,
    int newIndex,
  ) async {
    final servicesNotifier = ref.read(servicesProvider.notifier);
    final all = [...(ref.read(servicesProvider).value ?? [])];

    // servizio selezionato
    final movedService = all.firstWhere(
      (s) => s.id == serviceId,
      orElse: () => throw Exception(L10n.current.errorServiceNotFound),
    );

    // rimuovi da categoria precedente
    final remainingOldCat = all
        .where((s) => s.categoryId == oldCategoryId && s.id != serviceId)
        .toList();

    // aggiungi nella nuova categoria
    final targetCat = all.where((s) => s.categoryId == newCategoryId).toList();
    if (newIndex > targetCat.length) newIndex = targetCat.length;
    targetCat.insert(
      newIndex,
      movedService.copyWith(categoryId: newCategoryId),
    );

    // ricalcola sortOrder in entrambe le categorie
    final updatedOldCat = <Service>[
      for (int i = 0; i < remainingOldCat.length; i++)
        remainingOldCat[i].copyWith(sortOrder: i),
    ];
    final updatedNewCat = <Service>[
      for (int i = 0; i < targetCat.length; i++)
        targetCat[i].copyWith(sortOrder: i),
    ];

    final updated = <Service>[
      ...all.where(
        (s) => s.categoryId != oldCategoryId && s.categoryId != newCategoryId,
      ),
      ...updatedOldCat,
      ...updatedNewCat,
    ];

    servicesNotifier.setServices(updated);
    // Aggiorna posizionamento categorie vuote vs piene
    ref.read(serviceCategoriesProvider.notifier).bumpEmptyCategoriesToEnd();

    // Persist to API - both categories affected
    await _persistServicesOrder([...updatedOldCat, ...updatedNewCat]);
  }

  /// Persiste l'ordine dei servizi via API
  Future<void> _persistServicesOrder(List<Service> services) async {
    try {
      final apiClient = ref.read(apiClientProvider);
      await apiClient.reorderServices(
        services: services
            .map(
              (s) => {
                'id': s.id,
                'category_id': s.categoryId,
                'sort_order': s.sortOrder,
              },
            )
            .toList(),
      );
    } catch (e) {
      // Log error but don't revert UI - user can retry
      // ignore: avoid_print
      print('Error persisting services order: $e');
    }
  }

  /// Persiste l'ordine delle categorie via API
  Future<void> _persistCategoriesOrder(List<ServiceCategory> categories) async {
    try {
      final apiClient = ref.read(apiClientProvider);
      await apiClient.reorderCategories(
        categories: categories
            .map((c) => {'id': c.id, 'sort_order': c.sortOrder})
            .toList(),
      );
    } catch (e) {
      // Log error but don't revert UI - user can retry
      // ignore: avoid_print
      print('Error persisting categories order: $e');
    }
  }
}

final servicesReorderProvider = NotifierProvider<ServicesReorderNotifier, bool>(
  ServicesReorderNotifier.new,
);

class ServicesReorderPanelNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  void toggle() => state = !state;

  void setVisible(bool value) => state = value;
}

final servicesReorderPanelProvider =
    NotifierProvider<ServicesReorderPanelNotifier, bool>(
      ServicesReorderPanelNotifier.new,
    );
--- FILE: lib/features/services/providers/services_repository_provider.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../core/network/network_providers.dart';
import '../data/services_repository.dart';

part 'services_repository_provider.g.dart';

@Riverpod(keepAlive: true)
ServicesRepository servicesRepository(Ref ref) {
  final apiClient = ref.watch(apiClientProvider);
  return ServicesRepository(apiClient: apiClient);
}
--- FILE: lib/features/services/providers/services_repository_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'services_repository_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(servicesRepository)
const servicesRepositoryProvider = ServicesRepositoryProvider._();

final class ServicesRepositoryProvider
    extends
        $FunctionalProvider<
          ServicesRepository,
          ServicesRepository,
          ServicesRepository
        >
    with $Provider<ServicesRepository> {
  const ServicesRepositoryProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'servicesRepositoryProvider',
        isAutoDispose: false,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$servicesRepositoryHash();

  @$internal
  @override
  $ProviderElement<ServicesRepository> $createElement(
    $ProviderPointer pointer,
  ) => $ProviderElement(pointer);

  @override
  ServicesRepository create(Ref ref) {
    return servicesRepository(ref);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(ServicesRepository value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<ServicesRepository>(value),
    );
  }
}

String _$servicesRepositoryHash() =>
    r'3fccf62359ce924f6088b2d25be6f0e1266860a8';
--- FILE: lib/features/services/providers/service_categories_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../agenda/providers/business_providers.dart';
import 'services_provider.dart';
import 'services_repository_provider.dart';

/// Notifier per la gestione delle categorie di servizi (CRUD via API)
/// Le categorie vengono inizializzate vuote e popolate dal ServicesNotifier
/// quando i dati vengono caricati dall'API.
class ServiceCategoriesNotifier extends Notifier<List<ServiceCategory>> {
  @override
  List<ServiceCategory> build() {
    // Inizia vuoto - le categorie vengono caricate dall'API insieme ai servizi
    return [];
  }

  /// Imposta le categorie caricate dall'API
  void setCategories(List<ServiceCategory> categories) {
    state = _sorted(categories);
  }

  List<ServiceCategory> _sorted(List<ServiceCategory> list) {
    final copy = [...list];
    copy.sort((a, b) => a.sortOrder.compareTo(b.sortOrder));
    return copy;
  }

  // ===== API METHODS =====

  /// Creates a new category via API and updates local state
  Future<ServiceCategory?> createCategoryApi({
    required String name,
    String? description,
  }) async {
    final repository = ref.read(servicesRepositoryProvider);
    final businessId = ref.read(currentBusinessIdProvider);

    if (businessId <= 0) return null;

    try {
      final newCategory = await repository.createCategory(
        businessId: businessId,
        name: name,
        description: description,
      );

      // Add to local state with high sort order (will be bumped if empty)
      final nextSort = state.isEmpty
          ? 0
          : (state.map((c) => c.sortOrder).reduce((a, b) => a > b ? a : b) + 1);
      final withOrder = newCategory.copyWith(sortOrder: nextSort);
      state = _sorted([...state, withOrder]);

      bumpEmptyCategoriesToEnd();

      return newCategory;
    } catch (e) {
      return null;
    }
  }

  /// Updates a category via API and updates local state
  Future<ServiceCategory?> updateCategoryApi({
    required int categoryId,
    String? name,
    String? description,
    int? sortOrder,
  }) async {
    final repository = ref.read(servicesRepositoryProvider);

    try {
      final updatedCategory = await repository.updateCategory(
        categoryId: categoryId,
        name: name,
        description: description,
        sortOrder: sortOrder,
      );

      // Update local state
      state = _sorted([
        for (final c in state)
          if (c.id == updatedCategory.id) updatedCategory else c,
      ]);

      return updatedCategory;
    } catch (e) {
      return null;
    }
  }

  /// Deletes a category via API and updates local state
  Future<bool> deleteCategoryApi(int categoryId) async {
    final repository = ref.read(servicesRepositoryProvider);

    try {
      await repository.deleteCategory(categoryId);

      // Remove from local state
      state = _sorted(state.where((c) => c.id != categoryId).toList());

      return true;
    } catch (e) {
      return false;
    }
  }

  // ===== LOCAL METHODS (legacy, for backward compatibility) =====

  @Deprecated('Use createCategoryApi instead for persistence')
  void addCategory(ServiceCategory newCategory) {
    final nextSort = state.isEmpty
        ? 0
        : (state.map((c) => c.sortOrder).reduce((a, b) => a > b ? a : b) + 1);
    final withOrder = newCategory.copyWith(sortOrder: nextSort);
    state = _sorted([...state, withOrder]);
    bumpEmptyCategoriesToEnd();
  }

  @Deprecated('Use updateCategoryApi instead for persistence')
  void updateCategory(ServiceCategory updatedCategory) {
    state = _sorted([
      for (final c in state)
        if (c.id == updatedCategory.id) updatedCategory else c,
    ]);
  }

  @Deprecated('Use deleteCategoryApi instead for persistence')
  void deleteCategory(int id) {
    state = _sorted(state.where((c) => c.id != id).toList());
  }

  /// Imposta un sortOrder elevato per le categorie senza servizi,
  /// in modo che siano naturalmente in coda all'ordinamento.
  ///
  /// Per evitare dipendenze circolari quando chiamata da ServicesNotifier,
  /// si pu√≤ passare la lista servizi gi√† aggiornata tramite [servicesOverride].
  void bumpEmptyCategoriesToEnd({List<Service>? servicesOverride}) {
    final List<Service> services =
        servicesOverride ?? (ref.read(servicesProvider).value ?? []);
    final nonEmptyCatIds = <int>{for (final s in services) s.categoryId};

    int maxNonEmptySort = -1;
    for (final c in state) {
      if (nonEmptyCatIds.contains(c.id)) {
        if (c.sortOrder > maxNonEmptySort) maxNonEmptySort = c.sortOrder;
      }
    }

    // Base alta per evitare collisioni con futuri riordini
    final base = (maxNonEmptySort < 0 ? 0 : maxNonEmptySort + 1) + 1000;
    int offset = 0;

    final updated = [
      for (final c in state)
        if (nonEmptyCatIds.contains(c.id))
          c
        else
          c.copyWith(sortOrder: base + offset++),
    ];

    state = _sorted(updated);
  }
}

final serviceCategoriesProvider =
    NotifierProvider<ServiceCategoriesNotifier, List<ServiceCategory>>(
      ServiceCategoriesNotifier.new,
    );
--- FILE: lib/features/services/utils/service_validators.dart ---
import 'package:agenda_backend/core/models/service.dart';
import 'package:agenda_backend/core/models/service_category.dart';

class ServiceValidators {
  const ServiceValidators._();

  static bool isNonEmpty(String value) => value.trim().isNotEmpty;

  static bool isDuplicateCategoryName(
    List<ServiceCategory> categories,
    String normalizedName, {
    int? excludeId,
  }) {
    final needle = normalizedName.toLowerCase();
    return categories.any(
      (c) => c.id != excludeId && c.name.toLowerCase() == needle,
    );
  }

  static bool isDuplicateServiceName(
    List<Service> services,
    String normalizedName, {
    int? excludeId,
  }) {
    final needle = normalizedName.toLowerCase();
    return services.any(
      (s) => s.id != excludeId && s.name.toLowerCase() == needle,
    );
  }
}
--- FILE: lib/features/services/utils/service_seed_texts.dart ---
import 'package:intl/intl.dart';

/// Localization helpers per le stringhe di seed e duplicazione usate dalla feature Services.
class ServiceSeedTexts {
  const ServiceSeedTexts._();

  static String get categoryBodyName => Intl.message(
        'Trattamenti Corpo',
        name: 'serviceSeedCategoryBodyName',
        desc: 'Nome della categoria di default dedicata ai trattamenti corpo.',
      );

  static String get categoryBodyDescription => Intl.message(
        'Servizi dedicati al benessere del corpo',
        name: 'serviceSeedCategoryBodyDescription',
        desc: 'Descrizione della categoria di default dedicata ai trattamenti corpo.',
      );

  static String get categorySportsName => Intl.message(
        'Trattamenti Sportivi',
        name: 'serviceSeedCategorySportsName',
        desc: 'Nome della categoria di default dedicata ai trattamenti sportivi.',
      );

  static String get categorySportsDescription => Intl.message(
        'Percorsi pensati per atleti e persone attive',
        name: 'serviceSeedCategorySportsDescription',
        desc: 'Descrizione della categoria di default dedicata ai trattamenti sportivi.',
      );

  static String get categoryFaceName => Intl.message(
        'Trattamenti Viso',
        name: 'serviceSeedCategoryFaceName',
        desc: 'Nome della categoria di default dedicata ai trattamenti viso.',
      );

  static String get categoryFaceDescription => Intl.message(
        'Cura estetica e rigenerante per il viso',
        name: 'serviceSeedCategoryFaceDescription',
        desc: 'Descrizione della categoria di default dedicata ai trattamenti viso.',
      );

  static String get serviceRelaxName => Intl.message(
        'Massaggio Relax',
        name: 'serviceSeedServiceRelaxName',
        desc: 'Nome del servizio di massaggio relax iniziale.',
      );

  static String get serviceRelaxDescription => Intl.message(
        'Trattamento rilassante da 30 minuti',
        name: 'serviceSeedServiceRelaxDescription',
        desc: 'Descrizione del servizio di massaggio relax iniziale.',
      );

  static String get serviceSportName => Intl.message(
        'Massaggio Sportivo',
        name: 'serviceSeedServiceSportName',
        desc: 'Nome del servizio di massaggio sportivo iniziale.',
      );

  static String get serviceSportDescription => Intl.message(
        'Trattamento decontratturante intensivo',
        name: 'serviceSeedServiceSportDescription',
        desc: 'Descrizione del servizio di massaggio sportivo iniziale.',
      );

  static String get serviceFaceName => Intl.message(
        'Trattamento Viso',
        name: 'serviceSeedServiceFaceName',
        desc: 'Nome del servizio per il viso iniziale.',
      );

  static String get serviceFaceDescription => Intl.message(
        'Pulizia e trattamento illuminante',
        name: 'serviceSeedServiceFaceDescription',
        desc: 'Descrizione del servizio per il viso iniziale.',
      );

  static String get duplicateCopyWord => Intl.message(
        'Copia',
        name: 'serviceDuplicateCopyWord',
        desc:
            'Parola usata per nominare servizi duplicati (es. "Servizio Copia" o "Servizio Copia 2").',
      );
}
--- FILE: lib/features/services/controllers/services_reorder_controller.dart ---
import 'package:flutter/foundation.dart';

/// Skeleton: controller per reorder servizi ‚Äì API da collegare 1:1
class ServicesReorderController {
  const ServicesReorderController();

  // Esempio di firma che potr√† essere implementata 1:1 durante l'estrazione
  void onReorder({required int oldIndex, required int newIndex}) {
    // Implementazione reale verr√† estratta da services_screen.dart
    if (kDebugMode) {
      // ignore: avoid_print
      print('Services reorder: $oldIndex -> $newIndex (skeleton)');
    }
  }
}
--- FILE: lib/features/services/controllers/categories_reorder_controller.dart ---
import 'package:flutter/foundation.dart';

/// Skeleton: controller per reorder categorie ‚Äì API da collegare 1:1
class CategoriesReorderController {
  const CategoriesReorderController();

  // Esempio di firma che potr√† essere implementata 1:1 durante l'estrazione
  void onReorder({required int oldIndex, required int newIndex}) {
    // Implementazione reale verr√† estratta da services_screen.dart
    if (kDebugMode) {
      // ignore: avoid_print
      print('Categories reorder: $oldIndex -> $newIndex (skeleton)');
    }
  }
}
--- FILE: lib/features/services/data/services_api.dart ---
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/network/api_client.dart';

/// Risultato della chiamata API servizi (include categorie)
class ServicesApiResult {
  final List<Service> services;
  final List<ServiceCategory> categories;

  ServicesApiResult({required this.services, required this.categories});
}

/// API layer per Services - chiamate reali a agenda_core
class ServicesApi {
  final ApiClient _apiClient;

  ServicesApi({required ApiClient apiClient}) : _apiClient = apiClient;

  /// GET /v1/services?location_id=X
  /// Ritorna sia servizi che categorie dalla risposta API
  Future<ServicesApiResult> fetchServicesWithCategories(int locationId) async {
    final data = await _apiClient.getServices(locationId);

    // Parse services
    final List<dynamic> serviceItems = data['services'] ?? [];
    final services = serviceItems
        .map((json) => Service.fromJson(json as Map<String, dynamic>))
        .toList();

    // Parse categories dalla risposta API
    final List<dynamic> categoryItems = data['categories'] ?? [];
    final categories = <ServiceCategory>[];
    int sortOrder = 0;

    for (final catJson in categoryItems) {
      final catMap = catJson as Map<String, dynamic>;
      // L'API ritorna id e name per ogni categoria
      if (catMap['id'] != null) {
        categories.add(
          ServiceCategory(
            id: catMap['id'] as int,
            businessId: 0, // Non usato nel frontend
            name: catMap['name'] as String? ?? '',
            sortOrder: sortOrder++,
          ),
        );
      }
    }

    return ServicesApiResult(services: services, categories: categories);
  }

  /// GET /v1/services?location_id=X (legacy - solo servizi)
  Future<List<Service>> fetchServices(int locationId) async {
    final result = await fetchServicesWithCategories(locationId);
    return result.services;
  }

  // ===== Services CRUD =====

  /// POST /v1/locations/{location_id}/services
  /// Creates a new service
  Future<Service> createService({
    required int locationId,
    required String name,
    int? categoryId,
    String? description,
    int durationMinutes = 30,
    double price = 0,
    String? colorHex,
    bool isBookableOnline = true,
    bool isPriceStartingFrom = false,
  }) async {
    final data = await _apiClient.createService(
      locationId: locationId,
      name: name,
      categoryId: categoryId,
      description: description,
      durationMinutes: durationMinutes,
      price: price,
      colorHex: colorHex,
      isBookableOnline: isBookableOnline,
      isPriceStartingFrom: isPriceStartingFrom,
    );
    return Service.fromJson(data['service'] as Map<String, dynamic>);
  }

  /// PUT /v1/services/{id}
  /// Updates an existing service
  Future<Service> updateService({
    required int serviceId,
    required int locationId,
    String? name,
    int? categoryId,
    bool setCategoryIdNull = false,
    String? description,
    int? durationMinutes,
    double? price,
    String? colorHex,
    bool? isBookableOnline,
    bool? isPriceStartingFrom,
    int? sortOrder,
  }) async {
    final data = await _apiClient.updateService(
      serviceId: serviceId,
      locationId: locationId,
      name: name,
      categoryId: categoryId,
      setCategoryIdNull: setCategoryIdNull,
      description: description,
      durationMinutes: durationMinutes,
      price: price,
      colorHex: colorHex,
      isBookableOnline: isBookableOnline,
      isPriceStartingFrom: isPriceStartingFrom,
      sortOrder: sortOrder,
    );
    return Service.fromJson(data['service'] as Map<String, dynamic>);
  }

  /// DELETE /v1/services/{id}
  /// Soft deletes a service
  Future<void> deleteService(int serviceId) async {
    await _apiClient.deleteService(serviceId);
  }

  // ===== Categories CRUD =====

  /// GET /v1/businesses/{business_id}/categories
  /// Gets all service categories for a business
  Future<List<ServiceCategory>> fetchCategories(int businessId) async {
    final data = await _apiClient.getServiceCategories(businessId);
    final List<dynamic> items = data['categories'] ?? [];
    return items
        .map((json) => ServiceCategory.fromJson(json as Map<String, dynamic>))
        .toList();
  }

  /// POST /v1/businesses/{business_id}/categories
  /// Creates a new category
  Future<ServiceCategory> createCategory({
    required int businessId,
    required String name,
    String? description,
  }) async {
    final data = await _apiClient.createServiceCategory(
      businessId: businessId,
      name: name,
      description: description,
    );
    return ServiceCategory.fromJson(data['category'] as Map<String, dynamic>);
  }

  /// PUT /v1/categories/{id}
  /// Updates an existing category
  Future<ServiceCategory> updateCategory({
    required int categoryId,
    String? name,
    String? description,
    int? sortOrder,
  }) async {
    final data = await _apiClient.updateServiceCategory(
      categoryId: categoryId,
      name: name,
      description: description,
      sortOrder: sortOrder,
    );
    return ServiceCategory.fromJson(data['category'] as Map<String, dynamic>);
  }

  /// DELETE /v1/categories/{id}
  /// Deletes a category (services become uncategorized)
  Future<void> deleteCategory(int categoryId) async {
    await _apiClient.deleteServiceCategory(categoryId);
  }
}
--- FILE: lib/features/services/data/services_repository.dart ---
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/network/api_client.dart';
import 'services_api.dart';

class ServicesRepository {
  ServicesRepository({required ApiClient apiClient})
    : _api = ServicesApi(apiClient: apiClient);

  final ServicesApi _api;

  /// Carica servizi e categorie dall'API
  Future<ServicesApiResult> getServicesWithCategories({
    required int locationId,
  }) => _api.fetchServicesWithCategories(locationId);

  /// Carica solo i servizi (legacy)
  Future<List<Service>> getServices({required int locationId}) =>
      _api.fetchServices(locationId);

  // ===== Services CRUD =====

  /// Creates a new service
  Future<Service> createService({
    required int locationId,
    required String name,
    int? categoryId,
    String? description,
    int durationMinutes = 30,
    double price = 0,
    String? colorHex,
    bool isBookableOnline = true,
    bool isPriceStartingFrom = false,
  }) => _api.createService(
    locationId: locationId,
    name: name,
    categoryId: categoryId,
    description: description,
    durationMinutes: durationMinutes,
    price: price,
    colorHex: colorHex,
    isBookableOnline: isBookableOnline,
    isPriceStartingFrom: isPriceStartingFrom,
  );

  /// Updates an existing service
  Future<Service> updateService({
    required int serviceId,
    required int locationId,
    String? name,
    int? categoryId,
    bool setCategoryIdNull = false,
    String? description,
    int? durationMinutes,
    double? price,
    String? colorHex,
    bool? isBookableOnline,
    bool? isPriceStartingFrom,
    int? sortOrder,
  }) => _api.updateService(
    serviceId: serviceId,
    locationId: locationId,
    name: name,
    categoryId: categoryId,
    setCategoryIdNull: setCategoryIdNull,
    description: description,
    durationMinutes: durationMinutes,
    price: price,
    colorHex: colorHex,
    isBookableOnline: isBookableOnline,
    isPriceStartingFrom: isPriceStartingFrom,
    sortOrder: sortOrder,
  );

  /// Deletes a service
  Future<void> deleteService(int serviceId) => _api.deleteService(serviceId);

  // ===== Categories CRUD =====

  /// Gets all categories for a business
  Future<List<ServiceCategory>> getCategories(int businessId) =>
      _api.fetchCategories(businessId);

  /// Creates a new category
  Future<ServiceCategory> createCategory({
    required int businessId,
    required String name,
    String? description,
  }) => _api.createCategory(
    businessId: businessId,
    name: name,
    description: description,
  );

  /// Updates an existing category
  Future<ServiceCategory> updateCategory({
    required int categoryId,
    String? name,
    String? description,
    int? sortOrder,
  }) => _api.updateCategory(
    categoryId: categoryId,
    name: name,
    description: description,
    sortOrder: sortOrder,
  );

  /// Deletes a category
  Future<void> deleteCategory(int categoryId) =>
      _api.deleteCategory(categoryId);
}
--- FILE: lib/features/services/domain/controllers/category_controller.dart ---
/// Placeholder per futura persistenza/sincronizzazione delle categorie
/// con un backend remoto (REST/Firebase, ecc.).
class CategoryController {
  // In futuro: metodi per fetch/save/sync
}
--- FILE: lib/features/services/domain/services.dart ---
--- FILE: lib/features/services/presentation/services_screen.dart ---
import 'dart:async';

import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/l10n/l10_extension.dart';
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/models/service_variant.dart';
import '../../../core/utils/color_utils.dart';
import '../../../core/widgets/app_dialogs.dart';
import '../../../core/widgets/reorder_toggle_button.dart';
import '../../../core/widgets/reorder_toggle_panel.dart';
import '../providers/service_categories_provider.dart';
import '../providers/services_provider.dart';
import '../providers/services_reorder_provider.dart';
import '../providers/services_sorted_providers.dart';
// utils e validators spostati nei dialog
import 'dialogs/category_dialog.dart';
import 'dialogs/service_dialog.dart';
import 'widgets/categories_list.dart';

class ServicesScreen extends ConsumerStatefulWidget {
  const ServicesScreen({super.key});

  @override
  ConsumerState<ServicesScreen> createState() => _ServicesScreenState();
}

class _ServicesScreenState extends ConsumerState<ServicesScreen> {
  static final ValueNotifier<int?> _hoveredService = ValueNotifier<int?>(null);
  static final ValueNotifier<int?> _selectedService = ValueNotifier<int?>(null);

  final ScrollController _scrollController = ScrollController();
  Timer? _autoScrollTimer;

  /// Modalit√† di riordino (mutuamente esclusive)
  bool isReorderCategories = false;
  bool isReorderServices = false;

  // NOTE: Non serve initState con refresh() perch√©:
  // 1. I provider AsyncNotifier caricano i dati automaticamente nel build()
  // 2. Il refresh al cambio tab avviene in _refreshProvidersForTab()

  // ---------- Auto-scroll mentre si trascina ----------
  void _startAutoScroll(Offset pointerInGlobal) {
    const threshold = 100.0; // distanza dal bordo
    const speed = 14.0; // px per tick ~60fps

    _autoScrollTimer?.cancel();
    _autoScrollTimer = Timer.periodic(const Duration(milliseconds: 16), (_) {
      if (!_scrollController.hasClients) return;

      final renderBox = context.findRenderObject() as RenderBox?;
      if (renderBox == null) return;

      final local = renderBox.globalToLocal(pointerInGlobal);
      final dy = local.dy;

      final pos = _scrollController.offset;
      final max = _scrollController.position.maxScrollExtent;
      final viewH = _scrollController.position.viewportDimension;

      if (dy < threshold && pos > 0) {
        _scrollController.jumpTo((pos - speed).clamp(0, max));
      } else if (dy > viewH - threshold && pos < max) {
        _scrollController.jumpTo((pos + speed).clamp(0, max));
      }
    });
  }

  void _stopAutoScroll() => _autoScrollTimer?.cancel();

  void _toggleCategoryReorder() {
    setState(() {
      isReorderCategories = !isReorderCategories;
      if (isReorderCategories) isReorderServices = false;
    });
    if (!isReorderCategories) {
      ref.read(servicesReorderPanelProvider.notifier).setVisible(false);
    }
  }

  void _toggleServiceReorder() {
    setState(() {
      isReorderServices = !isReorderServices;
      if (isReorderServices) isReorderCategories = false;
    });
    if (!isReorderServices) {
      ref.read(servicesReorderPanelProvider.notifier).setVisible(false);
    }
  }

  @override
  void dispose() {
    _autoScrollTimer?.cancel();
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final servicesAsync = ref.watch(servicesProvider);
    final allCategories = ref.watch(sortedCategoriesProvider);

    // Mostriamo sempre tutte le categorie; i provider di sort sposteranno le vuote in coda.
    final categories = allCategories;

    final colorScheme = Theme.of(context).colorScheme;
    final isWide = ref.watch(formFactorProvider) != AppFormFactor.mobile;
    final showReorderPanel = ref.watch(servicesReorderPanelProvider);

    ref.listen<bool>(servicesReorderPanelProvider, (previous, next) {
      if (!next && (isReorderCategories || isReorderServices)) {
        setState(() {
          isReorderCategories = false;
          isReorderServices = false;
        });
      }
      // Se apro il pannello e c'√® solo 1 categoria, attiva subito riordino servizi
      if (next && previous == false && categories.length < 2) {
        setState(() {
          isReorderServices = true;
          isReorderCategories = false;
        });
      }
    });

    // Mostra loading mentre carica servizi
    if (servicesAsync.isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (categories.isEmpty) {
      return const SizedBox.shrink();
    }

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: () => _selectedService.value = null,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (showReorderPanel) ...[
            Padding(
              padding: const EdgeInsets.all(16),
              child: Center(
                child: Column(
                  children: [
                    Text(
                      context.l10n.reorderTitle,
                      style: Theme.of(context).textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(0, 4, 0, 8),
                      child: Text(
                        context.l10n.reorderHelpDescription,
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          color: Theme.of(context).colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ),
                    ReorderTogglePanel(
                      isWide: isWide,
                      children: [
                        if (categories.length >= 2)
                          ReorderToggleButton(
                            isActive: isReorderCategories,
                            onPressed: _toggleCategoryReorder,
                            activeLabel: context.l10n.reorderCategoriesLabel,
                            inactiveLabel: context.l10n.reorderCategoriesLabel,
                            activeIcon: Icons.check,
                            inactiveIcon: Icons.drag_indicator,
                          ),
                        ReorderToggleButton(
                          isActive: isReorderServices,
                          onPressed: _toggleServiceReorder,
                          activeLabel: context.l10n.reorderServicesLabel,
                          inactiveLabel: context.l10n.reorderServicesLabel,
                          activeIcon: Icons.check,
                          inactiveIcon: Icons.drag_indicator,
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ],

          // ---------- Corpo ----------
          Expanded(
            child: isReorderCategories
                ? _buildReorderCategories(context, ref, categories)
                : isReorderServices
                ? _buildReorderServices(context, ref, categories)
                : _buildNormalList(
                    context,
                    ref,
                    categories,
                    isWide,
                    colorScheme,
                  ),
          ),
        ],
      ),
    );
  }

  // ============================
  //  RIORDINO CATEGORIE (solo categorie, servizi nascosti)
  // ============================
  Widget _buildReorderCategories(
    BuildContext context,
    WidgetRef ref,
    List<ServiceCategory> cats,
  ) {
    final colorScheme = Theme.of(context).colorScheme;

    // Partiziona categorie piene e vuote
    final services = ref.watch(servicesProvider).value ?? [];
    final isNonEmpty = <int, bool>{
      for (final c in cats) c.id: services.any((s) => s.categoryId == c.id),
    };
    final fullCats = [
      for (final c in cats)
        if (isNonEmpty[c.id]!) c,
    ];
    final emptyCats = [
      for (final c in cats)
        if (!isNonEmpty[c.id]!) c,
    ];

    // Costruisci righe: piene, separatore, vuote (disabilitate)
    final rows = <({String type, ServiceCategory? cat})>[];
    for (final c in fullCats) {
      rows.add((type: 'full', cat: c));
    }
    if (emptyCats.isNotEmpty) {
      rows.add((type: 'separator', cat: null));
      for (final c in emptyCats) {
        rows.add((type: 'empty', cat: c));
      }
    }

    int fullIndexFromRow(int rowIndex) {
      int count = 0;
      for (int i = 0; i < rowIndex; i++) {
        if (rows[i].type == 'full') count++;
      }
      return count;
    }

    return Listener(
      onPointerMove: (e) => _startAutoScroll(e.position),
      onPointerUp: (_) => _stopAutoScroll(),
      child: ReorderableListView.builder(
        scrollController: _scrollController,
        padding: const EdgeInsets.fromLTRB(16, 12, 16, 100),
        buildDefaultDragHandles: false,
        // Evita l'effetto elevazione/ombra sull'item in drag:
        proxyDecorator: (child, index, animation) => child,
        itemCount: rows.length,
        onReorder: (oldIndex, newIndex) {
          final movingDown = newIndex > oldIndex;
          if (movingDown) newIndex -= 1;

          // Calcola gli indici nella sola lista delle piene
          final oldFullIndex = fullIndexFromRow(oldIndex);
          final newFullIndex = fullIndexFromRow(newIndex);

          ref
              .read(servicesReorderProvider.notifier)
              .reorderNonEmptyCategories(oldFullIndex, newFullIndex);
        },
        itemBuilder: (context, index) {
          final row = rows[index];
          if (row.type == 'separator') {
            return Container(
              key: const ValueKey('sep'),
              padding: const EdgeInsets.only(top: 64, bottom: 24),
              child: Text(
                context.l10n.emptyCategoriesNotReorderableNote,
                textAlign: TextAlign.center,
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
              ),
            );
          }
          final category = row.cat!;
          final isEmpty = row.type == 'empty';
          return Opacity(
            key: ValueKey('cat-${category.id}'),
            opacity: isEmpty ? 0.6 : 1.0,
            child: Container(
              margin: const EdgeInsets.only(bottom: 16),
              decoration: BoxDecoration(
                color: colorScheme.surface,
                borderRadius: BorderRadius.circular(12),
                border: Border.all(
                  color: colorScheme.outlineVariant.withOpacity(0.4),
                ),
              ),
              child: ListTile(
                leading: isEmpty
                    ? Icon(
                        Icons.drag_indicator,
                        color: colorScheme.onSurfaceVariant.withOpacity(0.3),
                      )
                    : ReorderableDragStartListener(
                        index: index,
                        child: const Icon(Icons.drag_indicator),
                      ),
                title: Text(category.name),
                enabled: !isEmpty,
              ),
            ),
          );
        },
      ),
    );
  }

  // ============================
  //  RIORDINO SERVIZI (CROSS-CATEGORIA)
  // ============================
  Widget _buildReorderServices(
    BuildContext context,
    WidgetRef ref,
    List<ServiceCategory> cats,
  ) {
    final colorScheme = Theme.of(context).colorScheme;
    final reorder = ref.read(servicesReorderProvider.notifier);

    // Flatten di tutti i servizi (solo delle categorie visualizzate)
    final allServices = <Service>[];
    final servicesByCategory = <int, List<Service>>{};
    for (final c in cats) {
      final list = ref.watch(sortedServicesByCategoryProvider(c.id));
      servicesByCategory[c.id] = list;
      allServices.addAll(list);
    }

    // Costruisce la lista visuale con header categoria "fissi" e righe servizio.
    // Gli header non hanno drag handle e non sono riordinabili; i servizi s√¨.
    final rows = <({bool isHeader, Service? s, ServiceCategory? c})>[];
    for (final c in cats) {
      final list = servicesByCategory[c.id] ?? const <Service>[];
      // Sempre mostrare header, anche se vuota
      rows.add((isHeader: true, s: null, c: c));
      for (final s in list) {
        rows.add((isHeader: false, s: s, c: null));
      }
    }

    int serviceFlatIndexFromRowsIndex(int rowsIndex) {
      int count = 0;
      for (int i = 0; i < rowsIndex; i++) {
        if (!rows[i].isHeader) count++;
      }
      return count;
    }

    // Funzione di supporto: data la posizione "globale" nella lista piatta,
    // ritorna la coppia (categoryId, indexNellaCategoria) dove verrebbe inserito
    (int catId, int indexInCat) targetForFlatIndex(
      int flatIndex, {
      required bool movingDown,
      int? movingServiceId,
    }) {
      // Clamp e fallback
      if (allServices.isEmpty) return (cats.first.id, 0);
      final idx = flatIndex.clamp(0, allServices.length);

      // Inserimento in coda assoluta
      if (idx == allServices.length) {
        final last = allServices.last;
        final inCat = servicesByCategory[last.categoryId] ?? [];
        return (last.categoryId, inCat.length);
      }

      // Pivot alla posizione globale idx
      final pivot = allServices[idx];
      final pivotCatId = pivot.categoryId;

      // Quanti elementi di quella categoria compaiono prima dell'indice globale,
      // escludendo il servizio in movimento (per evitare off-by-one)
      int countBeforeInPivotCat = 0;
      for (int i = 0; i < idx; i++) {
        final s = allServices[i];
        if (s.categoryId == pivotCatId && s.id != movingServiceId) {
          countBeforeInPivotCat++;
        }
      }

      return (pivotCatId, countBeforeInPivotCat);
    }

    return Listener(
      onPointerMove: (e) => _startAutoScroll(e.position),
      onPointerUp: (_) => _stopAutoScroll(),
      child: ReorderableListView.builder(
        scrollController: _scrollController,
        padding: const EdgeInsets.fromLTRB(16, 12, 16, 100),
        buildDefaultDragHandles: false,
        // Coerenza visiva: nessuna elevazione/ombra anche durante il drag servizi
        proxyDecorator: (child, index, animation) => child,
        itemCount: rows.length,
        onReorder: (oldIndex, newIndex) {
          // Normalizzazione Flutter Reorderable semantics
          final movingDown = newIndex > oldIndex;
          if (movingDown) newIndex -= 1;

          // Indice e servizio originale (riga servizio)
          final sOld = rows[oldIndex].s!;
          final oldCatId = sOld.categoryId;

          // Traduci newIndex della lista visuale in indice sulla lista servizi (saltando header)
          final targetServiceFlatIndex = serviceFlatIndexFromRowsIndex(
            newIndex,
          );

          // Calcola destinazione (categoria e indice relativo nella categoria) sulla base della lista servizi "reale"
          final (targetCatId, indexInTargetCat) = targetForFlatIndex(
            targetServiceFlatIndex,
            movingDown: movingDown,
            movingServiceId: sOld.id,
          );

          if (targetCatId == oldCatId) {
            // stesso gruppo -> semplice riordino interno
            reorder.reorderServices(
              oldCatId,
              // index relativo nella categoria di origine
              (servicesByCategory[oldCatId] ?? []).indexWhere(
                (e) => e.id == sOld.id,
              ),
              indexInTargetCat,
            );
          } else {
            // Cross-categoria -> sposta
            reorder.moveServiceBetweenCategories(
              oldCatId,
              targetCatId,
              sOld.id,
              indexInTargetCat,
            );
          }
        },
        itemBuilder: (context, index) {
          final row = rows[index];
          if (row.isHeader) {
            final category = row.c!;
            return Container(
              key: ValueKey('header-${category.id}'),
              width: double.infinity,
              margin: const EdgeInsets.only(top: 16, bottom: 6),
              decoration: BoxDecoration(
                color: colorScheme.primaryContainer,
                borderRadius: const BorderRadius.vertical(
                  top: Radius.circular(16),
                ),
              ),
              padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),
              child: Text(
                category.name,
                style: Theme.of(context).textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                  color: colorScheme.onPrimaryContainer,
                ),
              ),
            );
          }

          final s = row.s!;
          return Container(
            key: ValueKey('svc-${s.id}'),
            margin: const EdgeInsets.only(bottom: 6),
            decoration: BoxDecoration(
              color: colorScheme.surface,
              borderRadius: BorderRadius.circular(10),
              border: Border.all(
                color: colorScheme.outlineVariant.withOpacity(0.7),
              ),
            ),
            child: ListTile(
              leading: ReorderableDragStartListener(
                index: index,
                child: const Icon(Icons.drag_indicator),
              ),
              title: Text(s.name),
              dense: true,
              contentPadding: const EdgeInsets.symmetric(
                horizontal: 12,
                vertical: 4,
              ),
            ),
          );
        },
      ),
    );
  }

  // ============================
  //  VISTA NORMALE (pulsanti visibili, no drag)
  // ============================
  Widget _buildNormalList(
    BuildContext context,
    WidgetRef ref,
    List<ServiceCategory> cats,
    bool isWide,
    ColorScheme colorScheme,
  ) {
    final servicesNotifier = ref.read(servicesProvider.notifier);
    Color? mostUsedColorForCategory(ServiceCategory category) {
      final services = (ref.read(servicesProvider).value ?? [])
          .where((s) => s.categoryId == category.id)
          .toList();
      if (services.isEmpty) return null;
      final variants = ref.read(serviceVariantsProvider).value ?? [];
      final counts = <int, int>{};
      Color? topColor;
      int topCount = 0;
      for (final service in services) {
        ServiceVariant? variant;
        for (final v in variants) {
          if (v.serviceId == service.id) {
            variant = v;
            break;
          }
        }
        final colorHex = variant?.colorHex;
        if (colorHex == null) continue;
        final color = ColorUtils.fromHex(colorHex);
        final key = color.value;
        final nextCount = (counts[key] ?? 0) + 1;
        counts[key] = nextCount;
        if (nextCount > topCount) {
          topCount = nextCount;
          topColor = color;
        }
      }
      return topColor;
    }

    return CategoriesList(
      categories: cats,
      isWide: isWide,
      colorScheme: colorScheme,
      hoveredService: _hoveredService,
      selectedService: _selectedService,
      scrollController: _scrollController,
      onAddService: (category) => _openServiceDialog(
        context,
        ref,
        preselectedCategoryId: category.id,
        preselectedColor: mostUsedColorForCategory(category),
      ),
      onEditCategory: (category) =>
          showCategoryDialog(context, ref, category: category),
      onDeleteCategory: (categoryId) =>
          _confirmDeleteCategory(context, ref, categoryId),
      onDeleteCategoryBlocked: () => _showCannotDeleteCategoryDialog(context),
      onServiceOpen: (service) =>
          _openServiceDialog(context, ref, service: service),
      onServiceEdit: (service) =>
          _openServiceDialog(context, ref, service: service),
      onServiceDuplicate: (service) => _openServiceDialog(
        context,
        ref,
        service: service,
        duplicateFrom: true,
      ),
      onServiceDelete: (id) => _confirmDelete(
        context,
        onConfirm: () async => servicesNotifier.deleteServiceApi(id),
      ),
    );
  }

  void _confirmDeleteCategory(
    BuildContext context,
    WidgetRef ref,
    int categoryId,
  ) {
    showAppConfirmDialog(
      context,
      title: Text(context.l10n.deleteConfirmationTitle),
      confirmLabel: context.l10n.actionDelete,
      cancelLabel: context.l10n.actionCancel,
      danger: true,
      onConfirm: () async {
        await ref
            .read(serviceCategoriesProvider.notifier)
            .deleteCategoryApi(categoryId);
      },
    );
  }

  void _showCannotDeleteCategoryDialog(BuildContext context) {
    showAppInfoDialog(
      context,
      title: Text(context.l10n.cannotDeleteTitle),
      content: Text(context.l10n.cannotDeleteCategoryContent),
      closeLabel: context.l10n.actionClose,
    );
  }

  Future<void> _openServiceDialog(
    BuildContext context,
    WidgetRef ref, {
    Service? service,
    int? preselectedCategoryId,
    Color? preselectedColor,
    bool duplicateFrom = false,
  }) {
    return showServiceDialog(
      context,
      ref,
      service: service,
      preselectedCategoryId: preselectedCategoryId,
      preselectedColor: preselectedColor,
      duplicateFrom: duplicateFrom,
    ).then((_) => _selectedService.value = null);
  }

  void _confirmDelete(BuildContext context, {required VoidCallback onConfirm}) {
    showAppConfirmDialog(
      context,
      title: Text(context.l10n.deleteServiceQuestion),
      content: Text(context.l10n.cannotUndoWarning),
      confirmLabel: context.l10n.actionDelete,
      cancelLabel: context.l10n.actionCancel,
      danger: true,
      onConfirm: onConfirm,
    );
  }
}

// Add menu locale rimosso: ora √® gestito dallo ScaffoldWithNavigation
--- FILE: lib/features/services/presentation/dialogs/category_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service_category.dart';
import '../../../../core/utils/string_utils.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/labeled_form_field.dart';
import '../../providers/service_categories_provider.dart';
import '../../utils/service_validators.dart';

Future<void> showCategoryDialog(
  BuildContext context,
  WidgetRef ref, {
  ServiceCategory? category,
}) async {
  final notifier = ref.read(serviceCategoriesProvider.notifier);
  final allCategories = ref.read(serviceCategoriesProvider);
  final isDesktop = ref.read(formFactorProvider) == AppFormFactor.desktop;

  final nameController = TextEditingController(text: category?.name ?? '');
  final descController = TextEditingController(
    text: category?.description ?? '',
  );

  bool nameError = false;
  bool duplicateError = false;

  Widget buildContent(void Function(VoidCallback) setState) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        LabeledFormField(
          label: context.l10n.fieldNameRequiredLabel,
          child: TextField(
            controller: nameController,
            decoration: InputDecoration(
              border: const OutlineInputBorder(),
              isDense: true,
              errorText: nameError
                  ? context.l10n.fieldNameRequiredError
                  : (duplicateError
                        ? context.l10n.categoryDuplicateError
                        : null),
            ),
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        LabeledFormField(
          label: context.l10n.fieldDescriptionLabel,
          child: TextField(
            controller: descController,
            maxLines: 3,
            decoration: const InputDecoration(
              border: OutlineInputBorder(),
              isDense: true,
            ),
          ),
        ),
      ],
    );
  }

  Future<bool> handleSave() async {
    final rawName = nameController.text.trim();
    if (rawName.isEmpty) {
      nameError = true;
      return false;
    }

    final formattedName = StringUtils.toTitleCase(rawName);

    if (ServiceValidators.isDuplicateCategoryName(
      allCategories,
      formattedName,
      excludeId: category?.id,
    )) {
      duplicateError = true;
      return false;
    }

    final description = descController.text.trim().isEmpty
        ? null
        : descController.text.trim();

    if (category == null) {
      // Create new category via API
      final result = await notifier.createCategoryApi(
        name: formattedName,
        description: description,
      );
      return result != null;
    } else {
      // Update existing category via API
      final result = await notifier.updateCategoryApi(
        categoryId: category.id,
        name: formattedName,
        description: description,
      );
      return result != null;
    }
  }

  final title = category == null
      ? context.l10n.newCategoryTitle
      : context.l10n.editCategoryTitle;

  final builder = StatefulBuilder(
    builder: (ctx, setState) {
      final content = buildContent(setState);

      final cancelButton = SizedBox(
        width: AppButtonStyles.dialogButtonWidth,
        child: AppOutlinedActionButton(
          onPressed: () => Navigator.pop(ctx),
          padding: AppButtonStyles.dialogButtonPadding,
          child: Text(context.l10n.actionCancel),
        ),
      );

      final saveButton = SizedBox(
        width: AppButtonStyles.dialogButtonWidth,
        child: AppFilledButton(
          onPressed: () async {
            final closed = await handleSave();
            if (!closed) {
              setState(() {});
            } else {
              if (ctx.mounted) {
                Navigator.of(ctx).pop();
              }
            }
          },
          padding: AppButtonStyles.dialogButtonPadding,
          child: Text(context.l10n.actionSave),
        ),
      );

      if (isDesktop) {
        return DismissibleDialog(
          child: Dialog(
            insetPadding: const EdgeInsets.symmetric(
              horizontal: 32,
              vertical: 24,
            ),
            child: ConstrainedBox(
              constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Text(title, style: Theme.of(ctx).textTheme.headlineSmall),
                    const SizedBox(height: 16),
                    content,
                    const SizedBox(height: 24),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        cancelButton,
                        const SizedBox(width: 8),
                        saveButton,
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ),
        );
      }

      return SafeArea(
        top: false,
        child: LayoutBuilder(
          builder: (ctx, constraints) {
            final isKeyboardOpen = MediaQuery.of(ctx).viewInsets.bottom > 0;
            return SizedBox(
              height: constraints.maxHeight,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Expanded(
                    child: SingleChildScrollView(
                      padding: EdgeInsets.only(bottom: 0),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Padding(
                            padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Padding(
                                  padding: const EdgeInsets.only(bottom: 12),
                                  child: Text(
                                    title,
                                    style: Theme.of(ctx).textTheme.titleLarge,
                                  ),
                                ),
                                content,
                                const SizedBox(height: 24),
                                const SizedBox(
                                  height: AppSpacing.formRowSpacing,
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                  if (!isKeyboardOpen) ...[
                    const AppBottomSheetDivider(),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                      child: Align(
                        alignment: 2 == 3
                            ? Alignment.center
                            : Alignment.centerRight,
                        child: Wrap(
                          alignment: 2 == 3
                              ? WrapAlignment.center
                              : WrapAlignment.end,
                          spacing: 8,
                          runSpacing: 8,
                          children: [cancelButton, saveButton],
                        ),
                      ),
                    ),
                  ],
                  SizedBox(height: MediaQuery.of(ctx).viewPadding.bottom),
                ],
              ),
            );
          },
        ),
      );
    },
  );

  if (isDesktop) {
    await showDialog(context: context, builder: (_) => builder);
  } else {
    await AppBottomSheet.show(
      context: context,
      builder: (_) => builder,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
    );
  }
}
--- FILE: lib/features/services/presentation/dialogs/service_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:agenda_backend/features/agenda/providers/location_providers.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_variant.dart';
import '../../../../core/utils/color_utils.dart';
import '../../../../core/utils/price_utils.dart';
import '../../../../core/utils/string_utils.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/app_switch.dart';
import '../../../../core/widgets/labeled_form_field.dart';
import '../../../staff/providers/staff_providers.dart';
import '../../providers/service_categories_provider.dart';
import '../../providers/services_provider.dart';
import '../../utils/service_seed_texts.dart';
import '../../utils/service_validators.dart';

enum _AdditionalTimeSelection { none, processing, blocked }

const List<Color> _serviceColorPalette = [
  // Reds
  Color(0xFFFFCDD2),
  Color(0xFFFFC1C9),
  Color(0xFFFFB4BC),
  // Oranges
  Color(0xFFFFD6B3),
  Color(0xFFFFC9A3),
  Color(0xFFFFBD93),
  // Yellows
  Color(0xFFFFF0B3),
  Color(0xFFFFE6A3),
  Color(0xFFFFDC93),
  // Yellow-greens
  Color(0xFFEAF2B3),
  Color(0xFFDFEAA3),
  Color(0xFFD4E293),
  // Greens
  Color(0xFFCDECCF),
  Color(0xFFC1E4C4),
  Color(0xFFB6DCB9),
  // Teals
  Color(0xFFBFE8E0),
  Color(0xFFB1DFD6),
  Color(0xFFA3D6CB),
  // Cyans
  Color(0xFFBDEFF4),
  Color(0xFFB0E6EF),
  Color(0xFFA3DDEA),
  // Blues
  Color(0xFFBFD9FF),
  Color(0xFFB0CEFF),
  Color(0xFFA1C3FF),
  // Indigos
  Color(0xFFC7D0FF),
  Color(0xFFBAC4FF),
  Color(0xFFADB8FF),
  // Purples
  Color(0xFFDCC9FF),
  Color(0xFFD0BDFF),
  Color(0xFFC4B1FF),
  // Pinks
  Color(0xFFFFC7E3),
  Color(0xFFFFB7D9),
  Color(0xFFFFA8CF),
];

Color _contrastFor(Color color) {
  return color.computeLuminance() > 0.5 ? Colors.black : Colors.white;
}

class _SwitchTile extends StatelessWidget {
  const _SwitchTile({
    required this.title,
    this.subtitle,
    required this.value,
    required this.onChanged,
    this.enabled = true,
  });

  final String title;
  final String? subtitle;
  final bool value;
  final ValueChanged<bool>? onChanged;
  final bool enabled;

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final baseColor = textTheme.bodyLarge?.color;
    final titleStyle = enabled
        ? textTheme.bodyLarge
        : textTheme.bodyLarge?.copyWith(color: baseColor?.withOpacity(0.6));
    final subtitleStyle = enabled
        ? textTheme.bodyMedium
        : textTheme.bodyMedium?.copyWith(color: baseColor?.withOpacity(0.6));

    return MergeSemantics(
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: enabled && onChanged != null ? () => onChanged!(!value) : null,
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 8.0),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(title, style: titleStyle),
                    if (subtitle != null)
                      Padding(
                        padding: const EdgeInsets.only(top: 2.0),
                        child: Text(subtitle!, style: subtitleStyle),
                      ),
                  ],
                ),
              ),
              AppSwitch(value: value, onChanged: enabled ? onChanged : null),
            ],
          ),
        ),
      ),
    );
  }
}

class _SelectableRow extends StatelessWidget {
  const _SelectableRow({
    required this.label,
    required this.selected,
    required this.onTap,
  });

  final String label;
  final bool selected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          child: Row(
            children: [
              Expanded(child: Text(label)),
              if (selected)
                Icon(
                  Icons.check,
                  color: Theme.of(context).colorScheme.primary,
                  size: 20,
                ),
            ],
          ),
        ),
      ),
    );
  }
}

Future<void> showServiceDialog(
  BuildContext context,
  WidgetRef ref, {
  Service? service,
  int? preselectedCategoryId,
  Color? preselectedColor,
  bool requireCategorySelection = false,
  bool duplicateFrom = false,
}) async {
  final notifier = ref.read(servicesProvider.notifier);
  final allServices = ref.read(servicesProvider).value ?? [];
  final categories = ref.read(serviceCategoriesProvider);
  final isEditing = service != null && !duplicateFrom;
  final existingVariant = service != null
      ? ref.read(serviceVariantByServiceIdProvider(service.id))
      : null;
  final currencyCode = ref.read(effectiveCurrencyProvider);
  final currencySymbol = NumberFormat.currency(
    name: currencyCode,
  ).currencySymbol;
  final isDesktop = ref.read(formFactorProvider) == AppFormFactor.desktop;
  final colorScrollController = ScrollController();
  bool didAutoScroll = false;

  String makeDuplicateName(String originalName) {
    final copyWord = ServiceSeedTexts.duplicateCopyWord;
    final copyWordEscaped = RegExp.escape(copyWord);
    String base = originalName;
    int? startFrom;

    final reNew = RegExp(
      '^(.*?)(?:\\s$copyWordEscaped(?:\\s(\\d+))?)\$',
      caseSensitive: false,
    );
    final reOld = RegExp(
      '^(.*?)(?:\\s\\((?:$copyWordEscaped)(?:\\s(\\d+))?\\))\$',
      caseSensitive: false,
    );

    final match =
        reNew.firstMatch(originalName) ?? reOld.firstMatch(originalName);
    if (match != null) {
      base = (match.group(1) ?? '').trim();
      final n = match.group(2);
      if (n != null) {
        final parsed = int.tryParse(n);
        if (parsed != null) startFrom = parsed + 1;
      } else {
        startFrom = 1;
      }
    }

    final existingNames = allServices.map((s) => s.name).toSet();
    String candidate = '$base $copyWord';
    if (!existingNames.contains(candidate)) return candidate;

    int i = startFrom ?? 1;
    while (true) {
      candidate = '$base $copyWord $i';
      if (!existingNames.contains(candidate)) return candidate;
      i++;
      if (i > 9999) break;
    }
    return '$base $copyWord';
  }

  final nameController = TextEditingController(
    text: (duplicateFrom && service != null)
        ? makeDuplicateName(service.name)
        : (service?.name ?? ''),
  );
  final priceController = TextEditingController(
    text: (existingVariant != null && existingVariant.price > 0)
        ? PriceFormatter.format(
            context: context,
            amount: existingVariant.price,
            currencyCode: existingVariant.currency ?? currencyCode,
          )
        : '',
  );
  final descController = TextEditingController(
    text: service?.description ?? '',
  );
  final staffList = ref.read(staffForCurrentLocationProvider);
  final eligibilityNotifier = ref.read(
    serviceStaffEligibilityProvider.notifier,
  );
  final locationId = ref.read(currentLocationProvider).id;
  Set<int> selectedStaffIds = service != null
      ? ref.read(eligibleStaffForServiceProvider(service.id)).toSet()
      : <int>{};
  bool isSelectingStaff = false;

  int? selectedCategory = requireCategorySelection
      ? (service?.categoryId ?? preselectedCategoryId)
      : (service?.categoryId ?? preselectedCategoryId ?? categories.first.id);
  int? selectedDuration = existingVariant?.durationMinutes;
  int selectedProcessingTime = existingVariant?.processingTime ?? 0;
  int selectedBlockedTime = existingVariant?.blockedTime ?? 0;
  final palette = <Color>[..._serviceColorPalette];
  final seen = <int>{};
  final uniquePalette = <Color>[
    for (final c in palette)
      if (seen.add(c.value)) c,
  ];
  final serviceColor = existingVariant?.colorHex != null
      ? ColorUtils.fromHex(existingVariant!.colorHex!)
      : null;
  final hasPreselectedColor =
      preselectedColor != null &&
      uniquePalette.any((c) => c.value == preselectedColor.value);
  final hasServiceColor =
      serviceColor != null &&
      uniquePalette.any((c) => c.value == serviceColor.value);
  Color selectedColor = hasServiceColor
      ? serviceColor
      : (hasPreselectedColor ? preselectedColor : uniquePalette.first);

  if (selectedProcessingTime > 0 && selectedBlockedTime > 0) {
    selectedBlockedTime = 0;
  }

  _AdditionalTimeSelection additionalSelection = selectedProcessingTime > 0
      ? _AdditionalTimeSelection.processing
      : (selectedBlockedTime > 0
            ? _AdditionalTimeSelection.blocked
            : _AdditionalTimeSelection.none);
  int additionalMinutes = selectedProcessingTime > 0
      ? selectedProcessingTime
      : selectedBlockedTime;

  bool isBookableOnline = existingVariant?.isBookableOnline ?? true;
  bool isFree = existingVariant?.isFree ?? false;
  bool isPriceStartingFrom = existingVariant?.isPriceStartingFrom ?? false;

  bool nameError = false;
  bool durationError = false;
  bool categoryError = false;

  void scrollToSelected({required bool animate}) {
    if (!colorScrollController.hasClients) return;
    final index = uniquePalette.indexWhere(
      (c) => c.value == selectedColor.value,
    );
    if (index < 0) return;
    const double colorItemSize = 36;
    const double colorItemSpacing = 10;
    const double colorListPadding = 4;
    final viewport = colorScrollController.position.viewportDimension;
    final target =
        index * (colorItemSize + colorItemSpacing) -
        (viewport - colorItemSize) / 2 -
        colorListPadding;
    final maxExtent = colorScrollController.position.maxScrollExtent;
    final clamped = target.clamp(0.0, maxExtent);
    if (animate) {
      colorScrollController.animateTo(
        clamped,
        duration: const Duration(milliseconds: 220),
        curve: Curves.easeOutCubic,
      );
    } else {
      colorScrollController.jumpTo(clamped);
    }
  }

  Future<void> handleSave() async {
    final name = nameController.text.trim();
    if (name.isEmpty) {
      nameError = true;
      return;
    }
    final normalizedName = StringUtils.toTitleCase(name);
    final isDuplicate = ServiceValidators.isDuplicateServiceName(
      allServices,
      normalizedName,
      excludeId: isEditing ? service.id : null,
    );
    if (selectedDuration == null) {
      durationError = true;
      return;
    }
    if (selectedCategory == null) {
      categoryError = true;
      return;
    }

    final parsedPrice = PriceFormatter.parse(priceController.text);
    final effectiveIsFree = isFree;
    final double? finalPrice = effectiveIsFree ? null : parsedPrice;
    final bool finalIsPriceStartingFrom =
        (effectiveIsFree || finalPrice == null) ? false : isPriceStartingFrom;

    Future<void> doSave() async {
      int processingToSave = 0;
      int blockedToSave = 0;
      if (additionalSelection == _AdditionalTimeSelection.processing &&
          additionalMinutes > 0) {
        processingToSave = additionalMinutes;
      } else if (additionalSelection == _AdditionalTimeSelection.blocked &&
          additionalMinutes > 0) {
        blockedToSave = additionalMinutes;
      }

      Service? savedService;

      if (!isEditing) {
        // Create new service via API
        savedService = await notifier.createServiceApi(
          name: normalizedName,
          categoryId: selectedCategory!,
          description: descController.text.trim().isEmpty
              ? null
              : descController.text.trim(),
          durationMinutes: selectedDuration!,
          price: finalPrice ?? 0,
          colorHex: ColorUtils.toHex(selectedColor),
          isBookableOnline: isBookableOnline,
          isPriceStartingFrom: finalIsPriceStartingFrom,
        );
      } else {
        // Update existing service via API
        savedService = await notifier.updateServiceApi(
          serviceId: service.id,
          name: normalizedName,
          categoryId: selectedCategory!,
          description: descController.text.trim().isEmpty
              ? null
              : descController.text.trim(),
          durationMinutes: selectedDuration!,
          price: finalPrice ?? 0,
          colorHex: ColorUtils.toHex(selectedColor),
          isBookableOnline: isBookableOnline,
          isPriceStartingFrom: finalIsPriceStartingFrom,
        );
      }

      if (savedService == null) {
        // API call failed, don't close dialog
        return;
      }

      // Update local variant for immediate UI feedback (variant is derived from service)
      final newVariant = ServiceVariant(
        id: isEditing
            ? (existingVariant?.id ?? (900000 + savedService.id))
            : (900000 + savedService.id),
        serviceId: savedService.id,
        locationId: ref.read(currentLocationProvider).id,
        durationMinutes: selectedDuration!,
        processingTime: processingToSave,
        blockedTime: blockedToSave,
        price: finalPrice ?? 0,
        colorHex: ColorUtils.toHex(selectedColor),
        currency: currencyCode,
        isBookableOnline: isBookableOnline,
        isFree: effectiveIsFree,
        isPriceStartingFrom: finalIsPriceStartingFrom,
        resourceRequirements: existingVariant?.resourceRequirements ?? const [],
      );

      ref.read(serviceVariantsProvider.notifier).upsert(newVariant);
      eligibilityNotifier.setEligibleStaffForService(
        serviceId: savedService.id,
        locationId: locationId,
        staffIds: selectedStaffIds,
      );

      if (context.mounted) {
        Navigator.of(context, rootNavigator: true).pop();
      }
    }

    if (isDuplicate) {
      await showAppConfirmDialog(
        context,
        title: Text(context.l10n.serviceDuplicateError),
        confirmLabel: context.l10n.actionConfirm,
        cancelLabel: context.l10n.actionCancel,
        danger: false,
        onConfirm: doSave,
      );
    } else {
      await doSave();
    }
  }

  Widget buildBody(BuildContext context, void Function(VoidCallback) setState) {
    Future<void> openStaffSelector() async {
      if (isSelectingStaff) return;
      setState(() => isSelectingStaff = true);
      final l10n = context.l10n;
      final formFactor = ref.read(formFactorProvider);
      Set<int> current = {...selectedStaffIds};

      Widget buildStaffRows(void Function(VoidCallback) setStateLocal) {
        final allIds = [for (final s in staffList) s.id];
        final allSelected = allIds.isNotEmpty && allIds.every(current.contains);
        return Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            _SelectableRow(
              label: l10n.teamSelectAllServices,
              selected: allSelected,
              onTap: () {
                if (allSelected) {
                  current.clear();
                } else {
                  current
                    ..clear()
                    ..addAll(allIds);
                }
                setStateLocal(() {});
              },
            ),
            const Divider(height: 1),
            for (final member in staffList)
              _SelectableRow(
                label: member.displayName,
                selected: current.contains(member.id),
                onTap: () {
                  if (current.contains(member.id)) {
                    current.remove(member.id);
                  } else {
                    current.add(member.id);
                  }
                  setStateLocal(() {});
                },
              ),
          ],
        );
      }

      Future<void> openDialog(BuildContext ctx) async {
        await showDialog<void>(
          context: ctx,
          builder: (dialogCtx) => StatefulBuilder(
            builder: (context, setStateLocal) {
              return Dialog(
                insetPadding: const EdgeInsets.symmetric(
                  horizontal: 32,
                  vertical: 24,
                ),
                child: ConstrainedBox(
                  constraints: const BoxConstraints(
                    minWidth: 520,
                    maxWidth: 680,
                    maxHeight: 520,
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      Padding(
                        padding: const EdgeInsets.fromLTRB(20, 16, 20, 8),
                        child: Text(
                          l10n.teamEligibleStaffLabel,
                          style: Theme.of(context).textTheme.titleLarge,
                        ),
                      ),
                      const Divider(height: 1),
                      Expanded(
                        child: SingleChildScrollView(
                          child: buildStaffRows(setStateLocal),
                        ),
                      ),
                      const Divider(height: 1),
                      Padding(
                        padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                        child: Align(
                          alignment: Alignment.centerRight,
                          child: AppFilledButton(
                            onPressed: () => Navigator.of(dialogCtx).pop(),
                            padding: AppButtonStyles.dialogButtonPadding,
                            child: Text(l10n.actionConfirm),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        );
      }

      Future<void> openSheet(BuildContext ctx) async {
        await AppBottomSheet.show<void>(
          context: ctx,
          heightFactor: AppBottomSheet.defaultHeightFactor,
          padding: EdgeInsets.zero,
          builder: (sheetCtx) => StatefulBuilder(
            builder: (context, setStateLocal) {
              return SafeArea(
                top: false,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
                      child: Text(
                        l10n.teamEligibleStaffLabel,
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                    ),
                    const Divider(height: 1),
                    Expanded(
                      child: SingleChildScrollView(
                        child: buildStaffRows(setStateLocal),
                      ),
                    ),
                    const Divider(height: 1),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                      child: Align(
                        alignment: Alignment.centerRight,
                        child: AppFilledButton(
                          onPressed: () => Navigator.of(sheetCtx).pop(),
                          padding: AppButtonStyles.dialogButtonPadding,
                          child: Text(l10n.actionConfirm),
                        ),
                      ),
                    ),
                    SizedBox(height: MediaQuery.of(ctx).viewPadding.bottom),
                  ],
                ),
              );
            },
          ),
        );
      }

      if (formFactor == AppFormFactor.desktop) {
        await openDialog(context);
      } else {
        await openSheet(context);
      }

      setState(() {
        selectedStaffIds = {...current};
        isSelectingStaff = false;
      });
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        LabeledFormField(
          label: context.l10n.fieldCategoryRequiredLabel,
          child: DropdownButtonFormField<int>(
            value: selectedCategory,
            decoration: InputDecoration(
              border: const OutlineInputBorder(),
              isDense: true,
              errorText: categoryError ? context.l10n.validationRequired : null,
            ),
            items: [
              for (final c in categories)
                DropdownMenuItem(value: c.id, child: Text(c.name)),
            ],
            onChanged: (v) => setState(() {
              selectedCategory = v;
              categoryError = false;
            }),
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        LabeledFormField(
          label: context.l10n.fieldNameRequiredLabel,
          child: TextField(
            controller: nameController,
            decoration: InputDecoration(
              border: const OutlineInputBorder(),
              isDense: true,
              errorText: nameError ? context.l10n.fieldNameRequiredError : null,
            ),
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        LabeledFormField(
          label: context.l10n.fieldDescriptionLabel,
          child: TextField(
            controller: descController,
            maxLines: 3,
            decoration: const InputDecoration(
              border: OutlineInputBorder(),
              isDense: true,
            ),
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        AppOutlinedActionButton(
          onPressed: openStaffSelector,
          expand: true,
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
          child: Row(
            children: [
              Expanded(
                child: Align(
                  alignment: Alignment.centerLeft,
                  child: Text(context.l10n.teamEligibleStaffLabel),
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 10,
                  vertical: 4,
                ),
                decoration: BoxDecoration(
                  color: Theme.of(
                    context,
                  ).colorScheme.primary.withOpacity(0.12),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  '${selectedStaffIds.length}/${staffList.length}',
                  style: Theme.of(context).textTheme.labelSmall?.copyWith(
                    color: Theme.of(context).colorScheme.primary,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
            ],
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        LabeledFormField(
          label: context.l10n.serviceColorLabel,
          child: SizedBox(
            height: 44,
            child: Row(
              children: [
                Expanded(
                  child: ShaderMask(
                    shaderCallback: (rect) {
                      return const LinearGradient(
                        begin: Alignment.centerLeft,
                        end: Alignment.centerRight,
                        colors: [
                          Colors.transparent,
                          Colors.black,
                          Colors.black,
                          Colors.transparent,
                        ],
                        stops: [0.0, 0.01, 0.99, 1.0],
                      ).createShader(rect);
                    },
                    blendMode: BlendMode.dstIn,
                    child: ScrollConfiguration(
                      behavior: const ScrollBehavior().copyWith(
                        dragDevices: {
                          PointerDeviceKind.touch,
                          PointerDeviceKind.mouse,
                          PointerDeviceKind.trackpad,
                        },
                      ),
                      child: ListView.separated(
                        controller: colorScrollController,
                        padding: const EdgeInsets.symmetric(horizontal: 4),
                        scrollDirection: Axis.horizontal,
                        physics: const BouncingScrollPhysics(),
                        itemCount: uniquePalette.length,
                        separatorBuilder: (_, __) => const SizedBox(width: 10),
                        itemBuilder: (context, index) {
                          final color = uniquePalette[index];
                          return GestureDetector(
                            onTap: () => setState(() {
                              selectedColor = color;
                            }),
                            child: AnimatedContainer(
                              duration: const Duration(milliseconds: 150),
                              width: 36,
                              height: 36,
                              decoration: BoxDecoration(
                                color: color,
                                shape: BoxShape.circle,
                                border: Border.all(
                                  color: selectedColor.value == color.value
                                      ? Theme.of(context).colorScheme.onSurface
                                      : Colors.black.withOpacity(0.08),
                                  width: selectedColor.value == color.value
                                      ? 2
                                      : 1,
                                ),
                                boxShadow: [
                                  BoxShadow(
                                    color: Colors.black.withOpacity(0.08),
                                    blurRadius: 4,
                                    offset: const Offset(0, 2),
                                  ),
                                ],
                              ),
                              child: selectedColor.value == color.value
                                  ? Icon(
                                      Icons.check,
                                      color: _contrastFor(color),
                                      size: 18,
                                    )
                                  : null,
                            ),
                          );
                        },
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: AppSpacing.medium),
        Align(
          alignment: Alignment.center,
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 300),
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
              decoration: BoxDecoration(
                color: selectedColor,
                borderRadius: BorderRadius.circular(10),
              ),
              child: DefaultTextStyle(
                style: const TextStyle(
                  color: Colors.black87,
                  fontWeight: FontWeight.w600,
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      '09:00 - 10:00  ${context.l10n.formClient}',
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 2),
                    Text(
                      nameController.text.trim().isEmpty
                          ? context.l10n.formService
                          : nameController.text.trim(),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: const TextStyle(
                        color: Colors.black54,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        LabeledFormField(
          label: context.l10n.fieldDurationRequiredLabel,
          child: DropdownButtonFormField<int>(
            value: selectedDuration,
            decoration: InputDecoration(
              border: const OutlineInputBorder(),
              isDense: true,
              errorText: durationError
                  ? context.l10n.fieldDurationRequiredError
                  : null,
            ),
            items: [
              for (final (minutes, label) in _durationOptions(context))
                DropdownMenuItem(value: minutes, child: Text(label)),
            ],
            onChanged: (v) => setState(() {
              selectedDuration = v;
              durationError = false;
              if ((selectedDuration ?? 0) <= 0) {
                additionalSelection = _AdditionalTimeSelection.none;
                additionalMinutes = 0;
              }
            }),
          ),
        ),
        if ((selectedDuration ?? 0) > 0) ...[
          const SizedBox(height: AppSpacing.formRowSpacing),
          LabeledFormField(
            label: context.l10n.additionalTimeSwitch,
            child: DropdownButtonFormField<_AdditionalTimeSelection>(
              value: additionalSelection == _AdditionalTimeSelection.none
                  ? null
                  : additionalSelection,
              decoration: const InputDecoration(
                border: OutlineInputBorder(),
                isDense: true,
              ),
              hint: const Text(''),
              items: [
                DropdownMenuItem(
                  value: _AdditionalTimeSelection.none,
                  child: const Text(''),
                ),
                DropdownMenuItem(
                  value: _AdditionalTimeSelection.processing,
                  child: Text(context.l10n.additionalTimeOptionProcessing),
                ),
                DropdownMenuItem(
                  value: _AdditionalTimeSelection.blocked,
                  child: Text(context.l10n.additionalTimeOptionBlocked),
                ),
              ],
              onChanged: (sel) => setState(() {
                additionalSelection = sel ?? _AdditionalTimeSelection.none;
                if (additionalSelection == _AdditionalTimeSelection.none) {
                  additionalMinutes = 0;
                }
              }),
            ),
          ),
          if (additionalSelection != _AdditionalTimeSelection.none) ...[
            const SizedBox(height: AppSpacing.formRowSpacing),
            LabeledFormField(
              label:
                  (additionalSelection == _AdditionalTimeSelection.processing)
                  ? context.l10n.fieldProcessingTimeLabel
                  : context.l10n.fieldBlockedTimeLabel,
              child: DropdownButtonFormField<int>(
                value: additionalMinutes,
                decoration: const InputDecoration(
                  border: OutlineInputBorder(),
                  isDense: true,
                ),
                items: [
                  for (final (minutes, label) in _bufferOptions(context))
                    DropdownMenuItem(value: minutes, child: Text(label)),
                ],
                onChanged: (v) => setState(() {
                  additionalMinutes = v ?? 0;
                }),
              ),
            ),
          ],
        ],
        const SizedBox(height: AppSpacing.formRowSpacing),
        LabeledFormField(
          label: context.l10n.fieldPriceLabel,
          child: TextField(
            controller: priceController,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            inputFormatters: [
              FilteringTextInputFormatter.allow(RegExp(r'[0-9.,\-]')),
            ],
            decoration: InputDecoration(
              border: const OutlineInputBorder(),
              isDense: true,
              prefixText: '$currencySymbol ',
            ),
            enabled: !isFree,
            onChanged: (_) {
              if (priceController.text.trim().isEmpty && isPriceStartingFrom) {
                setState(() => isPriceStartingFrom = false);
              }
            },
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        _SwitchTile(
          title: context.l10n.freeServiceSwitch,
          value: isFree,
          onChanged: (v) {
            setState(() {
              isFree = v;
              if (isFree) {
                priceController.clear();
                isPriceStartingFrom = false;
              }
            });
          },
        ),
        _SwitchTile(
          title: context.l10n.priceStartingFromSwitch,
          subtitle: (isFree || priceController.text.trim().isEmpty)
              ? context.l10n.setPriceToEnable
              : null,
          value: isPriceStartingFrom,
          onChanged: (!isFree && priceController.text.trim().isNotEmpty)
              ? (v) => setState(() => isPriceStartingFrom = v)
              : null,
          enabled: (!isFree && priceController.text.trim().isNotEmpty),
        ),
        const SizedBox(height: 40),
        _SwitchTile(
          title: context.l10n.bookableOnlineSwitch,
          value: isBookableOnline,
          onChanged: (v) => setState(() => isBookableOnline = v),
        ),
      ],
    );
  }

  final dialogTitle = !isEditing
      ? context.l10n.newServiceTitle
      : context.l10n.editServiceTitle;

  final builder = StatefulBuilder(
    builder: (context, setState) {
      if (!didAutoScroll) {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          scrollToSelected(animate: false);
        });
        didAutoScroll = true;
      }
      final body = buildBody(context, setState);

      final cancelButton = SizedBox(
        width: AppButtonStyles.dialogButtonWidth,
        child: AppOutlinedActionButton(
          onPressed: () => Navigator.of(context, rootNavigator: true).pop(),
          padding: AppButtonStyles.dialogButtonPadding,
          child: Text(context.l10n.actionCancel),
        ),
      );

      final saveButton = SizedBox(
        width: AppButtonStyles.dialogButtonWidth,
        child: AppFilledButton(
          onPressed: () async {
            await handleSave();
            setState(() {});
          },
          padding: AppButtonStyles.dialogButtonPadding,
          child: Text(context.l10n.actionSave),
        ),
      );
      final bottomActions = [cancelButton, saveButton];

      if (isDesktop) {
        return DismissibleDialog(
          child: Dialog(
            insetPadding: const EdgeInsets.symmetric(
              horizontal: 32,
              vertical: 24,
            ),
            child: ConstrainedBox(
              constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Text(
                      dialogTitle,
                      style: Theme.of(context).textTheme.headlineSmall,
                    ),
                    const SizedBox(height: 16),
                    Flexible(child: SingleChildScrollView(child: body)),
                    const SizedBox(height: 24),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        cancelButton,
                        const SizedBox(width: 8),
                        saveButton,
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ),
        );
      }

      return SafeArea(
        top: false,
        child: LayoutBuilder(
          builder: (context, constraints) {
            final isKeyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
            return SizedBox(
              height: constraints.maxHeight,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Expanded(
                    child: SingleChildScrollView(
                      padding: EdgeInsets.zero,
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Padding(
                            padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                Padding(
                                  padding: const EdgeInsets.only(bottom: 12),
                                  child: Text(
                                    dialogTitle,
                                    style: Theme.of(
                                      context,
                                    ).textTheme.titleLarge,
                                  ),
                                ),
                                body,
                                const SizedBox(height: 24),
                                const SizedBox(
                                  height: AppSpacing.formRowSpacing,
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                  if (!isKeyboardOpen) ...[
                    const AppBottomSheetDivider(),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                      child: Align(
                        alignment: bottomActions.length == 3
                            ? Alignment.center
                            : Alignment.centerRight,
                        child: Wrap(
                          alignment: bottomActions.length == 3
                              ? WrapAlignment.center
                              : WrapAlignment.end,
                          spacing: 8,
                          runSpacing: 8,
                          children: bottomActions,
                        ),
                      ),
                    ),
                  ],
                  SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
                ],
              ),
            );
          },
        ),
      );
    },
  );

  if (isDesktop) {
    await showDialog(
      context: context,
      barrierDismissible: true,
      builder: (_) => builder,
    );
  } else {
    await AppBottomSheet.show(
      context: context,
      builder: (_) => builder,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
    );
  }
}

List<(int, String)> _durationOptions(BuildContext context) {
  final List<(int, String)> options = [];
  for (int i = 5; i <= 240; i += 5) {
    options.add((i, context.localizedDurationLabel(i)));
  }
  return options;
}

List<(int, String)> _bufferOptions(BuildContext context) {
  final List<(int, String)> options = [];
  final steps = <int>[0, 5, 10, 15, 20, 30, 45, 60];
  for (final m in steps) {
    options.add((m, context.localizedDurationLabel(m)));
  }
  return options;
}
--- FILE: lib/features/services/presentation/widgets/category_item.dart ---
import 'package:flutter/material.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';
import 'empty_state.dart';
import 'services_list.dart';

/// Item che rappresenta la card di una singola categoria (header + servizi).
class CategoryItem extends StatelessWidget {
  final ServiceCategory category;
  final List<Service> services;
  final bool isWide;
  final ColorScheme colorScheme;
  final ValueNotifier<int?> hoveredService;
  final ValueNotifier<int?> selectedService;
  final VoidCallback onAddService;
  final VoidCallback onEditCategory;
  final VoidCallback onDeleteCategory;
  final VoidCallback onDeleteBlocked;
  final ValueChanged<Service> onServiceOpen;
  final ValueChanged<Service> onServiceEdit;
  final ValueChanged<Service> onServiceDuplicate;
  final ValueChanged<int> onServiceDelete;
  final bool addTopSpacing;

  const CategoryItem({
    super.key,
    required this.category,
    required this.services,
    required this.isWide,
    required this.colorScheme,
    required this.hoveredService,
    required this.selectedService,
    required this.onAddService,
    required this.onEditCategory,
    required this.onDeleteCategory,
    required this.onDeleteBlocked,
    required this.onServiceOpen,
    required this.onServiceEdit,
    required this.onServiceDuplicate,
    required this.onServiceDelete,
    required this.addTopSpacing,
  });

  @override
  Widget build(BuildContext context) {
    final isEmptyCategory = services.isEmpty;
    return Container(
      margin: EdgeInsets.only(
        top: addTopSpacing ? 32 : 0,
        bottom: 24,
      ),
      decoration: BoxDecoration(
        color: colorScheme.surface,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 6,
            offset: const Offset(0, 3),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header categoria
          Container(
            width: double.infinity,
            decoration: BoxDecoration(
              color: colorScheme.primaryContainer,
              borderRadius: const BorderRadius.vertical(
                top: Radius.circular(16),
              ),
            ),
            padding: const EdgeInsets.symmetric(
              horizontal: 18,
              vertical: 14,
            ),
            child: Row(
              children: [
                // Titolo + descrizione
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        category.name,
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                        style: Theme.of(context).textTheme.titleMedium?.copyWith(
                              fontWeight: FontWeight.w600,
                              color: colorScheme.onPrimaryContainer,
                            ),
                      ),
                      if (category.description != null)
                        Padding(
                          padding: const EdgeInsets.only(top: 4),
                          child: Text(
                            category.description!,
                            maxLines: 2,
                            overflow: TextOverflow.ellipsis,
                            style: Theme.of(context)
                                .textTheme
                                .bodySmall
                                ?.copyWith(
                                  color: colorScheme.onPrimaryContainer
                                      .withOpacity(0.8),
                                ),
                          ),
                        ),
                    ],
                  ),
                ),
                const SizedBox(width: 12),

                // Pulsanti azione (solo in vista normale)
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    IconButton(
                      tooltip: context.l10n.addServiceTooltip,
                      icon: Icon(
                        Icons.add,
                        color: colorScheme.onPrimaryContainer,
                      ),
                      onPressed: onAddService,
                    ),
                    IconButton(
                      tooltip: context.l10n.actionEdit,
                      icon: Icon(
                        Icons.edit_outlined,
                        color: colorScheme.onPrimaryContainer,
                      ),
                      onPressed: onEditCategory,
                    ),
                    if (isEmptyCategory)
                      IconButton(
                        tooltip: context.l10n.actionDelete,
                        icon: const Icon(Icons.delete_outline),
                        color: colorScheme.onPrimaryContainer,
                        onPressed: onDeleteCategory,
                      ),
                  ],
                ),
              ],
            ),
          ),

          // Body: lista servizi o stato vuoto
          ClipRRect(
            borderRadius: const BorderRadius.vertical(
              bottom: Radius.circular(16),
            ),
            child: isEmptyCategory
                ? ServicesEmptyState(message: context.l10n.noServicesInCategory)
                : ServicesList(
                    services: services,
                    isWide: isWide,
                    colorScheme: colorScheme,
                    hoveredService: hoveredService,
                    selectedService: selectedService,
                    onOpen: onServiceOpen,
                    onEdit: onServiceEdit,
                    onDuplicate: onServiceDuplicate,
                    onDelete: onServiceDelete,
                  ),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/service_item.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/theme/extensions.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/utils/color_utils.dart';
import '../../../../core/utils/price_utils.dart';
import '../../providers/services_provider.dart';

class ServiceItem extends ConsumerWidget {
  final Service service;
  final bool isLast;
  final bool isEvenRow;
  final bool isHovered;
  final bool isSelected;
  final bool isWide;
  final ColorScheme colorScheme;
  final VoidCallback onTap;
  final VoidCallback onEnter;
  final VoidCallback onExit;
  final VoidCallback onEdit;
  final VoidCallback onDuplicate;
  final VoidCallback onDelete;

  const ServiceItem({
    super.key,
    required this.service,
    required this.isLast,
    required this.isEvenRow,
    required this.isHovered,
    required this.isSelected,
    required this.isWide,
    required this.colorScheme,
    required this.onTap,
    required this.onEnter,
    required this.onExit,
    required this.onEdit,
    required this.onDuplicate,
    required this.onDelete,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final interactionColors = Theme.of(
      context,
    ).extension<AppInteractionColors>();
    final variant = ref.watch(serviceVariantByServiceIdProvider(service.id));
    final eligibleStaffIds = ref.watch(
      eligibleStaffForServiceProvider(service.id),
    );
    final eligibleStaffCount = eligibleStaffIds.length;
    final baseColor = isEvenRow
        ? (interactionColors?.alternatingRowFill ??
              colorScheme.onSurface.withOpacity(0.04))
        : Colors.transparent;

    final hoverFill =
        interactionColors?.hoverFill ??
        colorScheme.primaryContainer.withOpacity(0.1);
    final bgColor = (isHovered || isSelected) ? hoverFill : baseColor;

    final durationMinutes = variant?.durationMinutes;
    final extraMinutes =
        (variant?.processingTime ?? 0) + (variant?.blockedTime ?? 0);
    final totalMinutes = (durationMinutes ?? 0) + extraMinutes;
    final durationLabel = durationMinutes != null
        ? context.localizedDurationLabel(
            extraMinutes > 0 ? totalMinutes : durationMinutes,
          )
        : null;

    return MouseRegion(
      cursor: SystemMouseCursors.click,
      onEnter: (_) => onEnter(),
      onExit: (_) => onExit(),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: onTap,
          borderRadius: BorderRadius.only(
            bottomLeft: isLast ? const Radius.circular(16) : Radius.zero,
            bottomRight: isLast ? const Radius.circular(16) : Radius.zero,
          ),
          child: Container(
            decoration: BoxDecoration(
              color: bgColor,
              borderRadius: BorderRadius.only(
                bottomLeft: isLast ? const Radius.circular(16) : Radius.zero,
                bottomRight: isLast ? const Radius.circular(16) : Radius.zero,
              ),
            ),
            child: IntrinsicHeight(
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Container(
                    width: 4,
                    decoration: BoxDecoration(
                      color: variant?.colorHex != null
                          ? ColorUtils.fromHex(variant!.colorHex!)
                          : colorScheme.primary,
                      borderRadius: BorderRadius.only(
                        bottomLeft: isLast
                            ? const Radius.circular(16)
                            : Radius.zero,
                      ),
                    ),
                  ),
                  Expanded(
                    child: ListTile(
                      contentPadding: const EdgeInsets.fromLTRB(16, 2, 16, 16),
                      mouseCursor: SystemMouseCursors.click,
                      title: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            service.name,
                            style: Theme.of(context).textTheme.titleMedium
                                ?.copyWith(fontWeight: FontWeight.w500),
                          ),
                          if (eligibleStaffCount == 0) ...[
                            const SizedBox(height: 2),
                            Text(
                              context.l10n.serviceEligibleStaffNone,
                              style: Theme.of(context).textTheme.bodySmall
                                  ?.copyWith(
                                    color: Theme.of(context).colorScheme.error,
                                    fontStyle: FontStyle.italic,
                                  ),
                            ),
                          ],
                          if (durationLabel != null ||
                              variant?.price != null ||
                              (variant?.isFree ?? false))
                            Padding(
                              padding: const EdgeInsets.only(top: 4),
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  if (durationLabel != null)
                                    Text(
                                      durationLabel,
                                      style: const TextStyle(
                                        fontSize: 11,
                                        color: Colors.black54,
                                        height: 1.1,
                                      ),
                                    ),
                                  if (durationLabel != null &&
                                      (variant?.price != null ||
                                          (variant?.isFree ?? false)))
                                    const SizedBox(width: 8),
                                  if (variant?.isFree ?? false)
                                    Text(
                                      context.l10n.freeLabel,
                                      style: const TextStyle(
                                        fontSize: 11,
                                        color: Colors.black54,
                                        height: 1.1,
                                      ),
                                    )
                                  else if (variant?.price != null)
                                    Text(
                                      service.isPriceStartingFrom
                                          ? '${context.l10n.priceStartingFromPrefix} ${PriceFormatter.formatVariant(context: context, ref: ref, variant: variant!)}'
                                          : PriceFormatter.formatVariant(
                                              context: context,
                                              ref: ref,
                                              variant: variant!,
                                            ),
                                      style: const TextStyle(
                                        fontSize: 11,
                                        color: Colors.black54,
                                        height: 1.1,
                                      ),
                                    ),
                                ],
                              ),
                            ),
                          if (!(variant?.isBookableOnline ?? true))
                            Padding(
                              padding: const EdgeInsets.only(top: 2),
                              child: Text(
                                context.l10n.notBookableOnline,
                                style: Theme.of(context).textTheme.bodySmall
                                    ?.copyWith(
                                      color: Colors.red[600],
                                      fontStyle: FontStyle.italic,
                                    ),
                              ),
                            ),
                        ],
                      ),
                      trailing: UnconstrainedBox(
                        alignment: Alignment.centerRight,
                        child: isWide
                            ? _buildActionIcons(context)
                            : _buildPopupMenu(),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildActionIcons(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        IconButton(
          tooltip: context.l10n.actionEdit,
          icon: const Icon(Icons.edit_outlined),
          onPressed: onEdit,
        ),
        IconButton(
          tooltip: context.l10n.duplicateAction,
          icon: const Icon(Icons.copy_outlined),
          onPressed: onDuplicate,
        ),
        IconButton(
          tooltip: context.l10n.actionDelete,
          icon: const Icon(Icons.delete_outline, color: Colors.red),
          onPressed: onDelete,
        ),
      ],
    );
  }

  Widget _buildPopupMenu() {
    return PopupMenuButton<String>(
      onSelected: (value) {
        switch (value) {
          case 'edit':
            onEdit();
            break;
          case 'duplicate':
            onDuplicate();
            break;
          case 'delete':
            onDelete();
            break;
        }
      },
      itemBuilder: (context) => [
        PopupMenuItem(value: 'edit', child: Text(context.l10n.actionEdit)),
        PopupMenuItem(
          value: 'duplicate',
          child: Text(context.l10n.duplicateAction),
        ),
        PopupMenuItem(value: 'delete', child: Text(context.l10n.actionDelete)),
      ],
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/service_eligibility_selector.dart ---
import 'package:flutter/material.dart';

import '../../../../app/theme/extensions.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';

class ServiceEligibilitySelector extends StatelessWidget {
  const ServiceEligibilitySelector({
    super.key,
    required this.services,
    required this.categories,
    required this.selectedServiceIds,
    required this.onChanged,
    this.showSelectAll = true,
  });

  final List<Service> services;
  final List<ServiceCategory> categories;
  final Set<int> selectedServiceIds;
  final ValueChanged<Set<int>> onChanged;
  final bool showSelectAll;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    final servicesByCategory = <int, List<Service>>{};
    for (final service in services) {
      (servicesByCategory[service.categoryId] ??= []).add(service);
    }

    final hasServicesMap = <int, bool>{
      for (final category in categories)
        category.id: (servicesByCategory[category.id]?.isNotEmpty ?? false),
    };

    final sortedCategories = [...categories]
      ..sort((a, b) {
        final aEmpty = !(hasServicesMap[a.id] ?? false);
        final bEmpty = !(hasServicesMap[b.id] ?? false);
        if (aEmpty != bEmpty) return aEmpty ? 1 : -1;
        final so = a.sortOrder.compareTo(b.sortOrder);
        return so != 0
            ? so
            : a.name.toLowerCase().compareTo(b.name.toLowerCase());
      });

    final allServiceIds = [
      for (final service in services) service.id,
    ];
    final isAllSelected =
        allServiceIds.isNotEmpty &&
        allServiceIds.every(selectedServiceIds.contains);

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        if (showSelectAll)
          _SelectableRow(
            label: l10n.teamSelectAllServices,
            selected: isAllSelected,
            onTap: () {
              if (isAllSelected) {
                onChanged(<int>{});
              } else {
                onChanged(allServiceIds.toSet());
              }
            },
          ),
        if (showSelectAll) const Divider(height: 1),
        for (final category in sortedCategories)
          if ((servicesByCategory[category.id] ?? const <Service>[]).isNotEmpty)
            ...[
              _CategoryHeader(
                category: category,
                selectedIds: selectedServiceIds,
                services: servicesByCategory[category.id]!,
                onChanged: onChanged,
              ),
              for (int i = 0; i < servicesByCategory[category.id]!.length; i++)
                _ServiceRow(
                  service: servicesByCategory[category.id]![i],
                  isEven: i.isEven,
                  selectedIds: selectedServiceIds,
                  onChanged: onChanged,
                  evenBackgroundColor: theme
                          .extension<AppInteractionColors>()
                          ?.alternatingRowFill ??
                      theme.colorScheme.onSurface.withOpacity(0.04),
                ),
            ],
      ],
    );
  }
}

class _SelectableRow extends StatelessWidget {
  const _SelectableRow({
    required this.label,
    required this.selected,
    required this.onTap,
  });

  final String label;
  final bool selected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          child: Row(
            children: [
              Expanded(child: Text(label)),
              if (selected)
                Icon(
                  Icons.check,
                  color: Theme.of(context).colorScheme.primary,
                  size: 20,
                ),
            ],
          ),
        ),
      ),
    );
  }
}

class _CategoryHeader extends StatelessWidget {
  const _CategoryHeader({
    required this.category,
    required this.services,
    required this.selectedIds,
    required this.onChanged,
  });

  final ServiceCategory category;
  final List<Service> services;
  final Set<int> selectedIds;
  final ValueChanged<Set<int>> onChanged;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final serviceIds = services.map((s) => s.id).toList();
    final isSelected =
        serviceIds.isNotEmpty && serviceIds.every(selectedIds.contains);

    return Material(
      color: theme.colorScheme.primary,
      child: InkWell(
        onTap: () {
          if (serviceIds.isEmpty) return;
          final updated = {...selectedIds};
          if (isSelected) {
            updated.removeWhere(serviceIds.contains);
          } else {
            updated.addAll(serviceIds);
          }
          onChanged(updated);
        },
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 20),
          child: Row(
            children: [
              Expanded(
                child: Text(
                  category.name.toUpperCase(),
                  style: theme.textTheme.labelMedium?.copyWith(
                    color: theme.colorScheme.onPrimary,
                    fontWeight: FontWeight.bold,
                    letterSpacing: 0.5,
                  ),
                ),
              ),
              if (serviceIds.isNotEmpty)
                Icon(
                  isSelected ? Icons.check_box : Icons.check_box_outline_blank,
                  color: theme.colorScheme.onPrimary,
                  size: 18,
                ),
            ],
          ),
        ),
      ),
    );
  }
}

class _ServiceRow extends StatelessWidget {
  const _ServiceRow({
    required this.service,
    required this.isEven,
    required this.selectedIds,
    required this.onChanged,
    required this.evenBackgroundColor,
  });

  final Service service;
  final bool isEven;
  final Set<int> selectedIds;
  final ValueChanged<Set<int>> onChanged;
  final Color evenBackgroundColor;

  @override
  Widget build(BuildContext context) {
    final isSelected = selectedIds.contains(service.id);
    return Material(
      color: isEven ? evenBackgroundColor : Colors.transparent,
      child: InkWell(
        onTap: () {
          final updated = {...selectedIds};
          if (isSelected) {
            updated.remove(service.id);
          } else {
            updated.add(service.id);
          }
          onChanged(updated);
        },
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          child: Row(
            children: [
              Expanded(child: Text(service.name)),
              if (isSelected)
                Icon(
                  Icons.check,
                  color: Theme.of(context).colorScheme.primary,
                  size: 20,
                ),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/services_list.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/models/service.dart';
import 'service_item.dart';

class ServicesList extends ConsumerWidget {
  final List<Service> services;
  final bool isWide;
  final ColorScheme colorScheme;
  final ValueNotifier<int?> hoveredService;
  final ValueNotifier<int?> selectedService;
  final void Function(Service) onOpen;
  final void Function(Service) onEdit;
  final void Function(Service) onDuplicate;
  final void Function(int id) onDelete;

  const ServicesList({
    super.key,
    required this.services,
    required this.isWide,
    required this.colorScheme,
    required this.hoveredService,
    required this.selectedService,
    required this.onOpen,
    required this.onEdit,
    required this.onDuplicate,
    required this.onDelete,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ValueListenableBuilder<int?>(
      valueListenable: hoveredService,
      builder: (context, hoveredId, _) {
        return ValueListenableBuilder<int?>(
          valueListenable: selectedService,
          builder: (context, selectedId, __) {
            return Column(
              children: [
                for (int i = 0; i < services.length; i++)
                  ServiceItem(
                    service: services[i],
                    isLast: i == services.length - 1,
                    isEvenRow: i.isEven,
                    isHovered: hoveredId == services[i].id,
                    isSelected: selectedId == services[i].id,
                    isWide: isWide,
                    colorScheme: colorScheme,
                    onTap: () {
                      selectedService.value = services[i].id;
                      onOpen(services[i]);
                    },
                    onEnter: () => hoveredService.value = services[i].id,
                    onExit: () => hoveredService.value = null,
                    onEdit: () => onEdit(services[i]),
                    onDuplicate: () => onDuplicate(services[i]),
                    onDelete: () => onDelete(services[i].id),
                  ),
                if (services.isNotEmpty)
                  Divider(
                    color: Colors.grey.withOpacity(0.2),
                    height: 1,
                    thickness: 1,
                  ),
              ],
            );
          },
        );
      },
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/empty_state.dart ---
import 'package:flutter/material.dart';

/// Widget riutilizzabile per i casi in cui una categoria non contiene servizi.
class ServicesEmptyState extends StatelessWidget {
  final String message;

  const ServicesEmptyState({
    super.key,
    required this.message,
  });

  @override
  Widget build(BuildContext context) {
    final textStyle = Theme.of(context).textTheme.bodyMedium;

    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.inbox_outlined,
            color: Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
          ),
          const SizedBox(width: 8),
          Flexible(
            child: Text(
              message,
              textAlign: TextAlign.center,
              style: textStyle?.copyWith(
                color: textStyle.color?.withOpacity(0.7),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/categories_list.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';
import '../../providers/services_sorted_providers.dart';
import 'category_item.dart';

/// Lista dei pannelli categoria aggiornata per la vista normale.
class CategoriesList extends ConsumerWidget {
  final List<ServiceCategory> categories;
  final bool isWide;
  final ColorScheme colorScheme;
  final ValueNotifier<int?> hoveredService;
  final ValueNotifier<int?> selectedService;
  final ValueChanged<ServiceCategory> onAddService;
  final ValueChanged<ServiceCategory> onEditCategory;
  final ValueChanged<int> onDeleteCategory;
  final VoidCallback onDeleteCategoryBlocked;
  final ValueChanged<Service> onServiceOpen;
  final ValueChanged<Service> onServiceEdit;
  final ValueChanged<Service> onServiceDuplicate;
  final ValueChanged<int> onServiceDelete;
  final ScrollController scrollController;

  const CategoriesList({
    super.key,
    required this.categories,
    required this.isWide,
    required this.colorScheme,
    required this.hoveredService,
    required this.selectedService,
    required this.onAddService,
    required this.onEditCategory,
    required this.onDeleteCategory,
    required this.onDeleteCategoryBlocked,
    required this.onServiceOpen,
    required this.onServiceEdit,
    required this.onServiceDuplicate,
    required this.onServiceDelete,
    required this.scrollController,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ListView.builder(
      controller: scrollController,
      padding: const EdgeInsets.fromLTRB(16, 0, 16, 100),
      itemCount: categories.length,
      itemBuilder: (context, index) {
        final category = categories[index];
        final services = ref.watch(
          sortedServicesByCategoryProvider(category.id),
        );
        final hasPrev = index > 0;
        final prevIsNonEmpty = hasPrev
            ? ref
                  .watch(
                    sortedServicesByCategoryProvider(categories[index - 1].id),
                  )
                  .isNotEmpty
            : false;
        final isFirstEmptyAfterNonEmpty =
            services.isEmpty && (!hasPrev || prevIsNonEmpty);

        return AnimatedSwitcher(
          duration: const Duration(milliseconds: 300),
          switchInCurve: Curves.easeInOut,
          switchOutCurve: Curves.easeInOut,
          layoutBuilder: (currentChild, previousChildren) => Stack(
            alignment: Alignment.topCenter,
            children: [
              ...previousChildren,
              if (currentChild != null) currentChild,
            ],
          ),
          transitionBuilder: (child, animation) => FadeTransition(
            opacity: animation,
            child: SizeTransition(
              sizeFactor: animation,
              axisAlignment: -1.0,
              child: child,
            ),
          ),
          child: KeyedSubtree(
            key: ValueKey(
              'cat-${category.id}-${services.isEmpty ? 'empty' : 'full'}',
            ),
            child: CategoryItem(
              category: category,
              services: services,
              isWide: isWide,
              colorScheme: colorScheme,
              hoveredService: hoveredService,
              selectedService: selectedService,
              onAddService: () => onAddService(category),
              onEditCategory: () => onEditCategory(category),
              onDeleteCategory: () => onDeleteCategory(category.id),
              onDeleteBlocked: onDeleteCategoryBlocked,
              onServiceOpen: onServiceOpen,
              onServiceEdit: onServiceEdit,
              onServiceDuplicate: onServiceDuplicate,
              onServiceDelete: onServiceDelete,
              addTopSpacing: isFirstEmptyAfterNonEmpty,
            ),
          ),
        );
      },
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/category_tile.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service_category.dart';
import '../../providers/service_categories_provider.dart';

class CategoryTile extends ConsumerWidget {
  const CategoryTile({super.key, required this.category, this.onEdit});

  final ServiceCategory category;
  final VoidCallback? onEdit;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    return InkWell(
      onTap: onEdit,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: theme.cardColor,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: theme.dividerColor.withOpacity(0.4)),
        ),
        child: Row(
          children: [
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(category.name, style: theme.textTheme.titleMedium),
                  if (category.description != null &&
                      category.description!.isNotEmpty)
                    Padding(
                      padding: const EdgeInsets.only(top: 4),
                      child: Text(
                        category.description!,
                        style: theme.textTheme.bodySmall,
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                ],
              ),
            ),
            IconButton(
              tooltip: context.l10n.actionEdit,
              icon: const Icon(Icons.edit_outlined),
              onPressed: onEdit,
            ),
            IconButton(
              tooltip: context.l10n.actionDelete,
              icon: const Icon(Icons.delete_outline, color: Colors.redAccent),
              onPressed: () => _confirmDelete(context, ref),
            ),
          ],
        ),
      ),
    );
  }

  void _confirmDelete(BuildContext context, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (_) => AlertDialog(
        title: Text(context.l10n.deleteConfirmationTitle),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text(context.l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () async {
              await ref
                  .read(serviceCategoriesProvider.notifier)
                  .deleteCategoryApi(category.id);
              if (context.mounted) Navigator.of(context).pop();
            },
            child: Text(context.l10n.actionDelete),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/main.dart ---
import 'package:agenda_backend/app/app.dart';
import 'package:agenda_backend/core/services/preferences_service.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_web_plugins/url_strategy.dart';
import 'package:shared_preferences/shared_preferences.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  usePathUrlStrategy(); // Usa URL path-based (senza #)

  // Inizializza SharedPreferences
  final prefs = await SharedPreferences.getInstance();

  runApp(
    ProviderScope(
      overrides: [sharedPreferencesProvider.overrideWithValue(prefs)],
      child: const MyApp(),
    ),
  );
}
--- FILE: pubspec.yaml ---
name: agenda_backend
description: "A new Flutter project."
publish_to: 'none'
version: 1.0.0+1

environment:
  sdk: ^3.10.4

dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter
  flutter_web_plugins:
    sdk: flutter
  
  intl: ^0.20.2    
  flutter_riverpod: ^3.0.3
  riverpod_annotation: ^3.0.3
  go_router: ^16.2.4
  url_launcher: ^6.3.1
  dio: ^5.8.0+1
  uuid: ^4.5.1
  flutter_secure_storage: ^9.2.4
  shared_preferences: ^2.3.5
dev_dependencies:
  build_runner: ^2.7.1
  riverpod_generator: ^3.0.3
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0
  intl_utils: ^2.8.11

flutter:
  uses-material-design: true


flutter_intl:
  enabled: true
  class_name: L10n
  main_locale: it
  arb_dir: lib/core/l10n
  output_dir: lib/core/l10n

--------------------------

>>> CONTENUTO: Core
=======================================
AGENDA CORE - PROJECT SNAPSHOT
Generated on: Sun Jan  4 17:55:15 CET 2026
=======================================

=======================================
----- FILE: AGENTS.md -----

# AGENTS.md ‚Äî agenda_core (Agenda Engine / Core Backend Services)

Questo file √® la fonte di verit√† per qualsiasi agent AI che lavori su agenda_core.
DEVE essere letto prima di scrivere codice.

Compatibilit√† obbligatoria:
- Agenda Frontend (Flutter ‚Äì prenotazione online)
- Agenda Backend (Flutter ‚Äì gestionale)

‚ö†Ô∏è **TERMINOLOGIA OBBLIGATORIA:**
- Il termine **"frontend"** si riferisce SOLO al progetto `agenda_frontend` (prenotazioni clienti)
- Il termine **"backend"** si riferisce SOLO al progetto `agenda_backend` (gestionale operatori)
- Il termine **"core"** o **"API"** si riferisce al progetto `agenda_core` (backend PHP)
- NON usare "frontend" per indicare genericamente interfacce utente

JSON snake_case.
I modelli e i campi gi√† usati dai client NON devono essere rinominati.

Prenotazione pubblica, login obbligatorio solo per conferma.

Autenticazione:
- JWT access token breve (10‚Äì15 min)
- Refresh token lungo (30‚Äì90 gg) con rotazione
- Web: refresh in cookie httpOnly
- Mobile: refresh in secure storage

**Due tipi di autenticazione separati:**
1. **Operatore (users table)**: `POST /v1/auth/login` ‚Üí token con `role: operator`
2. **Customer (clients table)**: `POST /v1/customer/{business_id}/auth/login` ‚Üí token con `role: customer`

I token non sono intercambiabili:
- Customer token non pu√≤ accedere a endpoint gestionale
- Operator token non pu√≤ accedere a endpoint customer

Architettura obbligatoria:
- Http layer (routing, middleware)
- Use cases (CreateBooking, ComputeAvailability‚Ä¶)
- Domain (regole pure)
- Infrastructure (DB, log, provider)

Endpoint minimi:
- POST /v1/auth/login
- POST /v1/auth/refresh
- POST /v1/auth/logout
- GET  /v1/me
- PUT  /v1/me (aggiorna profilo)
- POST /v1/me/change-password (cambio password utente autenticato)
- GET  /v1/auth/verify-reset-token/{token} (verifica token reset)
- POST /v1/auth/reset-password (reset password con token)
- GET  /v1/services
- GET  /v1/staff
- GET  /v1/availability
- POST /v1/bookings (protetto, idempotente)
- POST /v1/admin/businesses/{id}/resend-invite (superadmin)

**Customer Auth Endpoints (self-service booking):**
- POST /v1/customer/{business_id}/auth/login
- POST /v1/customer/{business_id}/auth/register
- POST /v1/customer/{business_id}/auth/refresh
- POST /v1/customer/{business_id}/auth/logout
- POST /v1/customer/{business_id}/auth/forgot-password (richiede email reset)
- POST /v1/customer/auth/reset-password (reset con token)
- GET  /v1/customer/me (customer_auth)
- PUT  /v1/customer/me (customer_auth, aggiorna profilo)
- POST /v1/customer/me/change-password (customer_auth, cambio password)
- POST /v1/customer/{business_id}/bookings (customer_auth, idempotent)
- GET  /v1/customer/bookings (customer_auth)

Booking payload (VINCOLANTE):
- service_ids
- staff_id?
- start_time (ISO8601)
- notes?

Se uno slot √® occupato:
- HTTP 409
- error.code = slot_conflict

Test (PHPUnit):
- 98 test, 195 asserzioni
- Eseguire: `./vendor/bin/phpunit --testdox`
- Classi repository sono `final` ‚Üí NO mock, test logica pura
- JWT_SECRET richiesto in setUp()

Notifiche Email (M10):
- Provider configurabile via `.env`: MAIL_PROVIDER=smtp|brevo|mailgun
- Coda asincrona: notifiche NON bloccano booking flow
- Worker cron: `bin/notification-worker.php` (ogni minuto)
- Reminder cron: `bin/queue-reminders.php` (ogni ora)
- Template: bookingConfirmed, bookingCancelled, bookingReminder, bookingRescheduled
- **Test mode**: `NOTIFICATION_TEST_MODE=true` ‚Üí email inviate a `nome.cognome@romeolab.it`

Cron Jobs (02/01/2026):
| Job | Comando | Intervallo | Scopo |
|-----|---------|------------|-------|
| notification-worker | `php bin/notification-worker.php` | `* * * * *` | Invia email dalla coda |
| queue-reminders | `php bin/queue-reminders.php` | `0 * * * *` | Accoda reminder appuntamenti |
| cleanup-sessions | `php bin/cleanup-sessions.php` | `0 3 1 * *` | Pulisce sessioni e log vecchi |

Formato comando cron SiteGround:
```
cd /home/u1251-kkefwq4fumer/www/api.romeolab.it && php bin/[worker].php >> logs/[worker].log 2>&1
```

File .env:
- `.env` ‚Üí configurazione REALE (non committato, in .gitignore)
- `.env.example` ‚Üí TEMPLATE con placeholder (committato)
- I due file DEVONO avere le STESSE variabili, sempre allineati
- Quando si aggiunge una variabile a `.env.example`, aggiungerla anche a `.env`
- `.env.example` usa valori placeholder, `.env` usa valori reali

Cleanup Worker (02/01/2026):
- File: `bin/cleanup-sessions.php`
- Elimina sessioni scadute/revocate da >30 giorni (`auth_sessions`, `client_sessions`)
- Elimina token reset usati/scaduti (`password_reset_token_users`, `password_reset_token_clients`)
- Tronca log >10MB mantenendo ultime 1000 righe
- Elimina file `.log.*` pi√π vecchi di 30 giorni
- Eseguire: primo del mese alle 03:00 (`0 3 1 * *`)

---

## üîë BACKUP CREDENZIALI PRODUZIONE (02/01/2026)

### Posizione backup
- **iCloud Drive**: `Backup_Credenziali_Agenda/`
- **Password Manager**: voce "Agenda RomeoLab - Produzione"

### File di backup
| File | Contenuto |
|------|-----------|
| `BACKUP_ENV_PRODUZIONE_YYYYMMDD.txt` | Intero `.env` produzione |
| `BACKUP_SSH_KEY_SITEGROUND_YYYYMMDD` | Chiave privata SSH |
| `BACKUP_SSH_KEY_SITEGROUND_YYYYMMDD.pub` | Chiave pubblica SSH |

### ‚ö†Ô∏è QUANDO AGGIORNARE I BACKUP

Aggiornare backup su iCloud + Password Manager quando si modifica:
- `JWT_SECRET` ‚Üí tutti gli utenti devono riloggarsi
- `DB_PASSWORD` ‚Üí credenziali database
- `BREVO_API_KEY` ‚Üí chiave API email
- Chiave SSH SiteGround

### Comando per rigenerare backup

```bash
# Backup .env produzione
ssh siteground "cat www/api.romeolab.it/.env" > ~/Library/Mobile\ Documents/com~apple~CloudDocs/Backup_Credenziali_Agenda/BACKUP_ENV_PRODUZIONE_$(date +%Y%m%d).txt

# Backup chiave SSH (se cambiata)
cp ~/.ssh/siteground_ed25519 ~/Library/Mobile\ Documents/com~apple~CloudDocs/Backup_Credenziali_Agenda/BACKUP_SSH_KEY_SITEGROUND_$(date +%Y%m%d)
cp ~/.ssh/siteground_ed25519.pub ~/Library/Mobile\ Documents/com~apple~CloudDocs/Backup_Credenziali_Agenda/BACKUP_SSH_KEY_SITEGROUND_$(date +%Y%m%d).pub
```

### Credenziali da tenere nel Password Manager
- DB: host, database, username, password
- JWT_SECRET (intero)
- BREVO_API_KEY (intero)
- SSH: user (`u1251-kkefwq4fumer`), porta (`18765`)

---

## üö® REGOLE DEPLOY CRITICHE ‚Äî LEGGERE PRIMA DI OGNI DEPLOY

### Mapping ESATTO Progetto ‚Üí URL ‚Üí Cartella SiteGround

| Progetto | Descrizione | URL Produzione | Cartella SiteGround |
|----------|-------------|----------------|---------------------|
| **agenda_core** | API PHP Backend | api.romeolab.it | `www/api.romeolab.it/` |
| **agenda_frontend** | Prenotazioni CLIENTI | **prenota**.romeolab.it | `www/prenota.romeolab.it/public_html/` |
| **agenda_backend** | Gestionale OPERATORI | **gestionale**.romeolab.it | `www/gestionale.romeolab.it/public_html/` |

### ‚ö†Ô∏è ERRORI COMUNI DA EVITARE

‚ùå **MAI** deployare `agenda_backend` su `prenota.romeolab.it`  
‚ùå **MAI** deployare `agenda_frontend` su `gestionale.romeolab.it`  
‚ùå **MAI** confondere i due progetti Flutter

### Come distinguere i progetti Flutter:

| Caratteristica | agenda_frontend (PRENOTA) | agenda_backend (GESTIONALE) |
|----------------|---------------------------|-----------------------------|
| **Scopo** | Clienti prenotano online | Operatori gestiscono agenda |
| **Route principale** | `/:slug/booking` | `/agenda` |
| **Features** | `booking/` | `agenda/`, `clients/`, `staff/` |
| **Ha drag & drop** | ‚ùå No | ‚úÖ S√¨ |
| **Ha StatefulShellRoute** | ‚ùå No | ‚úÖ S√¨ |
| **Usa routeSlugProvider** | ‚úÖ S√¨ | ‚ùå No |

### Comandi Deploy CORRETTI

```bash
# 1Ô∏è‚É£ FRONTEND PRENOTAZIONI (agenda_frontend ‚Üí prenota.romeolab.it)
cd /path/to/agenda_frontend
flutter build web --release --dart-define=API_BASE_URL=https://api.romeolab.it
rsync -avz --delete build/web/ siteground:www/prenota.romeolab.it/public_html/

# 2Ô∏è‚É£ GESTIONALE (agenda_backend ‚Üí gestionale.romeolab.it)  
cd /path/to/agenda_backend
flutter build web --release --dart-define=API_BASE_URL=https://api.romeolab.it
rsync -avz --delete build/web/ siteground:www/gestionale.romeolab.it/public_html/

# 3Ô∏è‚É£ API (agenda_core ‚Üí api.romeolab.it)
rsync -avz public/ siteground:www/api.romeolab.it/public_html/
rsync -avz --delete src/ siteground:www/api.romeolab.it/src/
rsync -avz --delete vendor/ siteground:www/api.romeolab.it/vendor/
```

### Checklist PRE-DEPLOY

- [ ] Sono nella cartella CORRETTA del progetto?
- [ ] Il nome cartella corrisponde al progetto giusto?
- [ ] L'URL di destinazione √® quello CORRETTO?
- [ ] Ho incrementato `?v=YYYYMMDD-N` in `web/index.html`?

---

Deploy Produzione (28/12/2025):
- API: https://api.romeolab.it
- Frontend: https://prenota.romeolab.it
- Gestionale: https://gestionale.romeolab.it
- Hosting: SiteGround condiviso
- CORS: `CORS_ALLOWED_ORIGINS=https://prenota.romeolab.it,https://gestionale.romeolab.it,http://localhost:8080`
- SSH: porta 18765, chiave ed25519

‚ö†Ô∏è DEPLOY agenda_core ‚Äî SOLO QUESTE CARTELLE:
- `public_html/` ‚Üí entry point (index.php, .htaccess)
- `src/` ‚Üí codice sorgente PHP
- `vendor/` ‚Üí dipendenze Composer
- `bin/` ‚Üí worker notifiche (opzionale, se cron attivo)

MAI deployare: `docs/`, `tests/`, `scripts/`, `migrations/`, `lib/`, `.git/`, `*.md`, `phpunit.xml`, `composer.json`

Comando deploy corretto:
```bash
rsync -avz public/ siteground:www/api.romeolab.it/public_html/
rsync -avz --delete src/ siteground:www/api.romeolab.it/src/
rsync -avz --delete vendor/ siteground:www/api.romeolab.it/vendor/
```

‚ö†Ô∏è VERSIONE CACHE BUSTING (01/01/2026):

**Prima di ogni deploy Flutter (frontend o backend)**, incrementare la versione in `web/index.html`:
```html
<script src="flutter_bootstrap.js?v=YYYYMMDD-N" async></script>
```
- Formato: `?v=YYYYMMDD-N` dove N √® un contatore giornaliero
- Esempio: `?v=20260101-1`, `?v=20260101-2`, ecc.
- Questo forza il browser a ricaricare il JavaScript aggiornato

‚ö†Ô∏è STRUTTURA PROGETTO vs DEPLOY SITEGROUND (31/12/2025):

Nel progetto locale:
- `index.php` e `.htaccess` sono in `public/`
- I path usano `__DIR__ . '/../vendor/autoload.php'` (vendor nella parent)

Su SiteGround (deploy):
- La document root √® SEMPRE `public_html` (obbligatorio)
- `public/` viene mappata come `public_html/` con rsync
- I path sono gi√† corretti, nessuna modifica necessaria

Deploy:
```bash
rsync -avz public/ siteground:www/api.romeolab.it/public_html/
```

Vedi DEPLOY.md sezione 12 per comandi completi.

CORS e Cache Headers (30/12/2025):
- Variabile env: `CORS_ALLOWED_ORIGINS` (NON `CORS_ORIGIN`)
- Response.php aggiunge: `Vary: Origin` per proxy caching corretto
- Response.php aggiunge: `Cache-Control: no-store, no-cache, must-revalidate`
- SiteGround proxy pu√≤ cachare risposte ‚Üí header Vary evita CORS errors
- Se CORS fallisce dopo deploy: purgare cache da SiteGround Site Tools

Multi-Business Path-Based (29/12/2025):
- Struttura URL: `/{slug}/booking`, `/{slug}/login`, ecc.
- SiteGround shared hosting: NO wildcard DNS, NO subdomain routing
- Router Flutter estrae slug dal path e aggiorna `routeSlugProvider`
- Landing page (`/`) mostra "Business non specificato"
- Slug inesistente ‚Üí mostra "Business non trovato" (404 API gestito gracefully)
- Reset password globale: `/reset-password/:token` (senza business context)

Superadmin Business Management (30/12/2025):
- Endpoint CRUD: GET/POST/PUT/DELETE `/v1/admin/businesses`
- PUT `/v1/admin/businesses/{id}` per modifica business
- UseCase `CreateBusiness` con transazione atomica (rollback su errore)
- UseCase `UpdateBusiness` per aggiornamento campi
- Frontend: `BusinessListScreen`, dialogs create/edit
- Flow: superadmin ‚Üí /businesses ‚Üí seleziona/crea/modifica ‚Üí /agenda
- Pulsante "Cambia" in navigation per tornare alla lista business
- **MAI usare StateProvider** ‚Üí sempre Notifier + NotifierProvider

Multi-Location Support (30/12/2025):
- Endpoint pubblico: `GET /v1/businesses/{business_id}/locations/public`
- Ritorna locations attive con campi limitati (id, name, address, city, phone, timezone, is_default)
- Controller: `LocationsController::indexPublic()` usa `$request->getAttribute('business_id')`
- **NON** usare `getRouteParam()` per route pubbliche senza middleware auth
- Frontend: step "Sede" nel booking flow se business ha >1 location

Profilo Utente e Admin Email (31/12/2025):
- `PUT /v1/me` ‚Üí aggiorna profilo utente (first_name, last_name, email, phone)
- UseCase `UpdateProfile` in `src/UseCases/Auth/UpdateProfile.php`
- Validazione email unica (errore se gi√† esistente)
- CreateBusiness: `admin_email` √® OPZIONALE (business pu√≤ essere creato senza owner)
- UpdateBusiness: pu√≤ aggiungere admin a business senza owner, o trasferire ownership
- `POST /v1/admin/businesses/{id}/resend-invite` ‚Üí reinvia email benvenuto admin
- UseCase `ResendAdminInvite` genera nuovo token reset (24h) e invia email
- Template email: `businessAdminWelcome` con link reset password
- BusinessRepository: `findByIdWithAdmin()` e `findAllWithSearch()` includono admin_email
- **GET /v1/admin/businesses** ritorna `admin_email` per ogni business (fix 01/01/2026)

Email Benvenuto Admin (01/01/2026):
- Template `businessAdminWelcome` temporaneamente senza URL prenotazioni
- URL prenotazioni commentato in HTML, rimosso da versione text
- Da riattivare quando frontend booking pronto per il business
- File: `src/Infrastructure/Notifications/EmailTemplateRenderer.php`

Cambio Password e Verifica Token (01/01/2026):
- `GET /v1/auth/verify-reset-token/{token}` ‚Üí verifica validit√† token PRIMA di mostrare form
- UseCase `VerifyResetToken` controlla token non usato e non scaduto
- Errori: `invalid_reset_token` (400) o `reset_token_expired` (400)
- `POST /v1/me/change-password` ‚Üí cambio password utente autenticato
- Payload: `{"current_password": "...", "new_password": "..."}`
- Validazione: password attuale corretta, nuova password rispetta policy (8+ char, maiuscole, minuscole, numeri)
- Errore password errata: `invalid_credentials` (401)

Gestionale UI/UX (01/01/2026):
- **User Menu**: Icona profilo (index 4) nella navigation apre popup menu
- Menu contiene: header nome/email, Cambia password, Cambia Business (superadmin), Esci
- Superadmin: stesso menu sia in `/businesses` che dopo selezione business
- **Login error persistence**: Errore gestito in stato locale widget, non dal provider globale
- **Router rebuild**: Provider derivato `_routerAuthStateProvider` evita rebuild su cambio errorMessage

Logout e Session Expired (01/01/2026):
- `logout(silent: true)` ‚Üí NON fa chiamata API (per sessione gi√† scaduta)
- `SessionExpiredListener` usa `silent: true` per evitare loop infinito
- Flow: sessione scaduta ‚Üí logout silenzioso ‚Üí redirect a login

Categorie Servizi (01/01/2026):
- **NO dati hardcoded** in `ServiceCategoriesNotifier`
- Categorie caricate dall'API insieme ai servizi (`GET /v1/services`)
- `ServicesApi.fetchServicesWithCategories()` estrae categorie dalla risposta
- `ServicesNotifier` popola `serviceCategoriesProvider` con dati API

Services e Categories CRUD (02/01/2026):
- **Endpoint Services:**
  - `POST /v1/locations/{location_id}/services` ‚Üí crea servizio (auth required)
  - `PUT /v1/services/{id}` ‚Üí aggiorna servizio (auth required, `location_id` nel body)
  - `DELETE /v1/services/{id}` ‚Üí soft delete servizio (auth required)
- **Endpoint Categories:**
  - `GET /v1/businesses/{business_id}/categories` ‚Üí lista categorie
  - `POST /v1/businesses/{business_id}/categories` ‚Üí crea categoria
  - `PUT /v1/categories/{id}` ‚Üí aggiorna categoria
  - `DELETE /v1/categories/{id}` ‚Üí elimina categoria (servizi diventano senza categoria)
- **File PHP:**
  - `src/Infrastructure/Repositories/ServiceRepository.php` ‚Üí CRUD methods
  - `src/Http/Controllers/ServicesController.php` ‚Üí endpoint handlers
  - `src/Http/Kernel.php` ‚Üí route registration
- **File Flutter (agenda_backend):**
  - `lib/core/network/api_client.dart` ‚Üí metodi HTTP CRUD
  - `lib/features/services/data/services_api.dart` ‚Üí metodi API
  - `lib/features/services/providers/services_provider.dart` ‚Üí `*Api` methods
  - `lib/features/services/providers/service_categories_provider.dart` ‚Üí `*Api` methods
- **Metodi deprecati:** `add()`, `updateService()`, `delete()`, `duplicate()` locali
- **Usare:** `createServiceApi()`, `updateServiceApi()`, `deleteServiceApi()`, `duplicateServiceApi()`

---

## üóÑÔ∏è API Gestionale - Entit√† Persistite (01/01/2026)

### Staff Services (Servizi abilitati per Staff)
Relazione N:M tra staff e servizi che pu√≤ erogare.

**Gestione tramite endpoint Staff esistenti:**
- `GET /v1/businesses/{business_id}/staff` - ritorna `service_ids` per ogni staff
- `POST /v1/businesses/{business_id}/staff` - accetta `service_ids` nel body
- `PUT /v1/staff/{id}` - accetta `service_ids` nel body

**Tabella:** `staff_services`
- `staff_id`, `service_id` (chiave primaria composta)

**File PHP:**
- `src/Infrastructure/Repositories/StaffRepository.php` ‚Üí `getServiceIds()`, `setServices()`
- `src/Http/Controllers/StaffController.php` ‚Üí gestione `service_ids` in store/update

**File Flutter:**
- `lib/core/models/staff.dart` ‚Üí campo `serviceIds`
- `lib/features/services/providers/services_provider.dart` ‚Üí `eligibleServicesForStaffProvider` legge da Staff
- `lib/features/staff/presentation/dialogs/staff_dialog.dart` ‚Üí salvataggio via API

### Staff Availability Exceptions
Eccezioni ai turni base dello staff (ferie, malattia, straordinari).

**Endpoint:**
- `GET /v1/staff/{id}/availability-exceptions` - lista eccezioni per staff
- `POST /v1/staff/{id}/availability-exceptions` - crea eccezione
- `PUT /v1/staff/availability-exceptions/{id}` - modifica eccezione
- `DELETE /v1/staff/availability-exceptions/{id}` - elimina eccezione

**Tabella:** `staff_availability_exceptions`
- `id`, `staff_id`, `date`, `start_time`, `end_time`, `is_available`, `note`

**File PHP:**
- `src/Infrastructure/Repositories/StaffAvailabilityExceptionRepository.php`
- `src/Http/Controllers/StaffAvailabilityExceptionController.php`

### Resources (Risorse)
Risorse fisiche assegnabili ai servizi (es. cabine, lettini).

**Endpoint:**
- `GET /v1/locations/{id}/resources` - lista risorse per sede
- `POST /v1/locations/{id}/resources` - crea risorsa
- `PUT /v1/resources/{id}` - modifica risorsa
- `DELETE /v1/resources/{id}` - soft delete risorsa

**Tabelle:**
- `resources` - id, location_id, name, description, is_active, deleted_at
- `service_variant_resource_requirements` - variante_servizio ‚Üî risorsa (M:N)

**File PHP:**
- `src/Infrastructure/Repositories/ResourceRepository.php`
- `src/Http/Controllers/ResourcesController.php`

### Time Blocks (Blocchi Non Disponibilit√†)
Periodi di non disponibilit√† per uno o pi√π staff (riunioni, pause, ferie).

**Endpoint:**
- `GET /v1/locations/{id}/time-blocks` - lista blocchi per sede (con filtro date)
- `POST /v1/locations/{id}/time-blocks` - crea blocco
- `PUT /v1/time-blocks/{id}` - modifica blocco
- `DELETE /v1/time-blocks/{id}` - elimina blocco

**Tabelle:**
- `time_blocks` - id, business_id, location_id, start_time, end_time, reason, is_all_day
- `time_block_staff` - blocco ‚Üî staff (M:N)

**File PHP:**
- `src/Infrastructure/Repositories/TimeBlockRepository.php`
- `src/Http/Controllers/TimeBlocksController.php`

---

## üîÑ Refresh e Polling Dati (01/01/2026)

### Refresh all'entrata nelle sezioni
Ogni sezione del gestionale ricarica i dati dal DB quando l'utente vi accede.

| Sezione | Provider ricaricati |
|---------|--------------------|
| Agenda | staff, locations, servizi, clienti |
| Clienti | clienti |
| Team | staff, locations, servizi |
| Servizi | servizi, staff |

### Polling automatico in Agenda
Gli appuntamenti vengono ricaricati automaticamente:
- **Debug**: ogni 10 secondi
- **Produzione**: ogni 5 minuti

Questo permette di vedere nuove prenotazioni fatte online o da altri dispositivi.

### Filtro Location Attive
Il provider `LocationsNotifier` filtra automaticamente le location non attive (`is_active = 0`).
Questo impatta filtri agenda, sezione team e dialog staff.

---

‚ö†Ô∏è REGOLA CRITICA DATABASE:
- **MAI** inserire, modificare o eliminare dati nel database senza richiesta esplicita dell'utente
- Le operazioni di seed/migration vanno eseguite solo se l'utente lo richiede
- In caso di dubbio, chiedere conferma prima di modificare dati in produzione

‚ö†Ô∏è REGOLA CRITICA DEPLOY:
- **MAI** deployare l'intero progetto con un singolo rsync
- Deployare SOLO: `public_html/`, `src/`, `vendor/`, `bin/` (se necessario)
- **MAI** deployare: `docs/`, `tests/`, `scripts/`, `migrations/`, `lib/`, `.git/`, `*.md`, `phpunit.xml`
- Usare sempre i comandi specifici documentati in DEPLOY.md sezione 12

---

## üí∞ Prezzo "A partire da" (01/01/2026)

### Schema Database
`service_variants.is_price_starting_from` (TINYINT, default 0)

### Backend PHP
Tutti gli endpoint che ritornano service_variants includono il campo:
- `ServiceRepository::findById()` ‚Üí include `is_price_starting_from AS is_price_from`
- `ServiceRepository::findByLocationId()` ‚Üí include `is_price_starting_from AS is_price_from`
- `ServiceRepository::findByIds()` ‚Üí include `is_price_starting_from AS is_price_from`
- `ServicesController::index()` ‚Üí ritorna `is_price_starting_from` nella response JSON

### Gestionale Flutter
- `Service.isPriceStartingFrom` (bool) ‚Üí campo flat dal service
- `ServiceVariant.isPriceStartingFrom` (bool) ‚Üí campo dal variant
- `ServiceItem` widget usa `service.isPriceStartingFrom` per visualizzare "a partire da ‚Ç¨X"
- Chiave localizzazione: `priceStartingFromPrefix` = "a partire da"

### Frontend Prenotazioni
Se necessario, seguire stessa logica del gestionale.

---

## üîß Repository Method Names (01/01/2026)

### IMPORTANTE
Il metodo per ottenere PDO connection √®:
```php
$this->db->getPdo()  // ‚úÖ CORRETTO
$this->db->pdo()     // ‚ùå ERRORE - metodo non esistente
```

### Fix Applicati
- `TimeBlockRepository` ‚Üí tutti i `pdo()` sostituiti con `getPdo()`

### Verifica
Prima di usare un repository, verificare che usi `getPdo()` e non `pdo()`.

---

## üîê Sicurezza API - Autorizzazione Business (02/01/2026)

### Pattern Autorizzazione
Tutti i controller che gestiscono dati business-specific implementano il metodo `hasBusinessAccess()`:

```php
private function hasBusinessAccess(Request $request, int $businessId): bool
{
    $userId = $request->getAttribute('user_id');
    if ($userId === null) return false;
    
    // Superadmin ha accesso a tutti i business
    if ($this->userRepo->isSuperadmin($userId)) return true;
    
    // Utente normale: verifica entry in business_users
    return $this->businessUserRepo->hasAccess($userId, $businessId, false);
}
```

### Controller Protetti

| Controller | Endpoint Protetti | Note |
|------------|-------------------|------|
| **ClientsController** | GET/POST/PUT/DELETE `/v1/clients` | Verifica business_id |
| **ServicesController** | POST/PUT/DELETE services e categories | Verifica ownership |
| **BusinessController** | GET `/v1/businesses`, GET `/v1/businesses/{id}` | Solo business accessibili |
| **LocationsController** | GET `/v1/businesses/{id}/locations`, GET `/v1/locations/{id}` | Verifica accesso |
| **AppointmentsController** | GET/PATCH/POST cancel | Owner booking O operatore business |
| **BookingsController** | GET index/show | Verifica business_id |

### Security Best Practice
- `show/update/delete` ritornano **404** (non 403) per non rivelare esistenza risorse
- Operatori con accesso al business possono gestire TUTTI gli appuntamenti
- Utenti normali possono gestire solo i PROPRI booking

### Controller gi√† protetti (pre-esistenti)
- `StaffController` ‚Üí verifica `hasAccess()`
- `TimeBlocksController` ‚Üí verifica `hasAccess()`
- `ResourcesController` ‚Üí verifica `hasAccess()`
- `BusinessUsersController` ‚Üí verifica `checkManageAccess()`
- `AdminBusinessesController` ‚Üí verifica `is_superadmin`

### Dipendenze Controller
Tutti i controller protetti richiedono:
- `BusinessUserRepository` - per verificare accesso
- `UserRepository` - per verificare superadmin

Aggiornare `Kernel.php` quando si aggiungono dipendenze ai controller.

### Nuovi Metodi Repository (02/01/2026)
- `BusinessRepository::findByUserId(int $userId)` - business accessibili all'utente
- `ServiceRepository::findServiceById(int $serviceId)` - trova servizio senza location

---

## üìä Import Dati da Fresha (02/01/2026)

### Istruzioni Migrazione
File in `migrations/fromfresha/`:
- `migra_servizi.md` - import servizi e categorie
- `migra_staff.md` - import staff
- `import_clients.sql` - import clienti (216 record)

### Regola Critica
**NON creare associazioni tra tabelle** (es. `staff_services`) durante import.
Le associazioni devono essere configurate manualmente dall'operatore nel gestionale.

### Match Automatico Clienti
Quando un utente prenota online e nel DB esiste gi√† un client con stessa email/telefono:
- `ClientRepository::findUnlinkedByEmailOrPhone()` cerca client senza `user_id`
- `ClientRepository::linkUserToClient()` associa `user_id` al client esistente
- Priorit√†: email > telefono

---

## üîê Separazione Autenticazione Operator/Customer (02/01/2026)

### Architettura a Due Sistemi Auth

Il sistema usa **due tabelle separate** per l'autenticazione:

| Sistema | Tabella | Endpoint Base | JWT Role | Scopo |
|---------|---------|---------------|----------|-------|
| **Operator** | `users` | `/v1/auth/` | `role: operator` | Gestionale (agenda_backend) |
| **Customer** | `clients` | `/v1/customer/{business_id}/auth/` | `role: customer` | Prenotazioni online (agenda_frontend) |

### ‚ö†Ô∏è REGOLA CRITICA
- I token **NON sono intercambiabili**
- Un token `role: customer` **NON pu√≤** accedere a endpoint gestionale (`/v1/me`, `/v1/businesses`, ecc.)
- Un token `role: operator` **NON pu√≤** accedere a endpoint customer (`/v1/customer/bookings`)

### Schema Database Customer Auth

```sql
-- Nuovi campi su clients
ALTER TABLE clients ADD password_hash VARCHAR(255) NULL;
ALTER TABLE clients ADD email_verified_at TIMESTAMP NULL;

-- Sessioni customer (refresh token)
CREATE TABLE client_sessions (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    client_id INT NOT NULL,
    token_hash VARCHAR(64) NOT NULL UNIQUE,
    expires_at TIMESTAMP NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (client_id) REFERENCES clients(id) ON DELETE CASCADE
);

-- Reset password customer
CREATE TABLE password_reset_token_clients (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    client_id INT NOT NULL,
    token_hash VARCHAR(64) NOT NULL UNIQUE,
    expires_at TIMESTAMP NOT NULL,
    used_at TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (client_id) REFERENCES clients(id) ON DELETE CASCADE
);
```

### Endpoint Customer Auth

| Metodo | Endpoint | Descrizione |
|--------|----------|-------------|
| POST | `/v1/customer/{business_id}/auth/register` | Registrazione nuovo cliente |
| POST | `/v1/customer/{business_id}/auth/login` | Login cliente |
| POST | `/v1/customer/{business_id}/auth/refresh` | Rinnovo access token |
| POST | `/v1/customer/{business_id}/auth/logout` | Logout (revoca refresh token) |
| POST | `/v1/customer/{business_id}/auth/forgot-password` | Richiede email reset password |
| POST | `/v1/customer/auth/reset-password` | Reset password con token |
| GET | `/v1/customer/me` | Profilo cliente autenticato |
| POST | `/v1/customer/{business_id}/bookings` | Crea prenotazione (customer) |
| GET | `/v1/customer/bookings` | Lista prenotazioni del cliente |

### JWT Token Structure

**Operator Token:**
```json
{
  "sub": 6,              // user_id
  "role": "operator",
  "exp": 1735830000,
  "iat": 1735829100
}
```

**Customer Token:**
```json
{
  "sub": 42,             // client_id
  "role": "customer",
  "business_id": 1,
  "exp": 1735830000,
  "iat": 1735829100
}
```

### File PHP Creati

| File | Descrizione |
|------|-------------|
| `src/Infrastructure/Repositories/ClientAuthRepository.php` | CRUD client auth, sessioni, password reset |
| `src/Http/Controllers/CustomerAuthController.php` | Endpoint auth customer |
| `src/Http/Middleware/CustomerAuthMiddleware.php` | Valida JWT con `role: customer` |
| `src/UseCases/CustomerAuth/LoginCustomer.php` | UseCase login |
| `src/UseCases/CustomerAuth/RegisterCustomer.php` | UseCase registrazione |
| `src/UseCases/CustomerAuth/RefreshCustomerToken.php` | UseCase refresh token |
| `src/UseCases/CustomerAuth/LogoutCustomer.php` | UseCase logout |
| `src/UseCases/CustomerAuth/GetCustomerMe.php` | UseCase profilo |
| `src/UseCases/CustomerAuth/UpdateCustomerProfile.php` | UseCase aggiorna profilo cliente |
| `src/UseCases/CustomerAuth/ChangeCustomerPassword.php` | UseCase cambio password cliente |

### File PHP Modificati

| File | Modifiche |
|------|-----------|
| `src/Infrastructure/Auth/JwtService.php` | Aggiunto `generateCustomerAccessToken()` con `role: customer` |
| `src/Http/Middleware/AuthMiddleware.php` | Verifica `role: operator` (backwards compatible) |
| `src/Http/Kernel.php` | Route customer auth, middleware `customer_auth` |
| `src/Http/Controllers/BookingsController.php` | `storeCustomer()`, `myCustomerBookings()` |
| `src/UseCases/Booking/CreateBooking.php` | `executeForCustomer()` per booking da customer |
| `src/Domain/Booking/BookingException.php` | Aggiunto `invalidClient()` error |
| `src/Infrastructure/Repositories/BookingRepository.php` | Rimosso metodo duplicato `findByClientId()` |

### Migrazione Database

**File:** `migrations/0020_separate_customer_auth.sql`

**‚ö†Ô∏è PRIMA di eseguire la migrazione:**
1. Fare backup del database
2. Verificare che non ci siano utenti "puri clienti" da migrare (se non ce ne sono, la query INSERT non far√† nulla)

**Eseguire migrazione (se necessario):**
```bash
# Copia file su server
rsync -avz migrations/0020_separate_customer_auth.sql siteground:www/api.romeolab.it/migrations/

# Esegui migrazione
ssh siteground "cd www/api.romeolab.it && mysql -u \$DB_USERNAME -p\$DB_PASSWORD \$DB_DATABASE < migrations/0020_separate_customer_auth.sql"
```

### Middleware Registration (Kernel.php)

```php
// Middleware customer auth
$customerAuthMiddleware = new CustomerAuthMiddleware($jwtService);

// Route customer auth (pubbliche)
$router->post('/v1/customer/{business_id}/auth/register', ...);
$router->post('/v1/customer/{business_id}/auth/login', ...);
$router->post('/v1/customer/{business_id}/auth/refresh', ...);
$router->post('/v1/customer/{business_id}/auth/logout', ...);
$router->post('/v1/customer/{business_id}/auth/forgot-password', ...);
$router->post('/v1/customer/auth/reset-password', ...);

// Route customer protette
$router->group(['middleware' => [$customerAuthMiddleware]], function ($router) {
    $router->get('/v1/customer/me', ...);
    $router->post('/v1/customer/{business_id}/bookings', ...);
    $router->get('/v1/customer/bookings', ...);
});
```

### Migrazione Dati (ATTENZIONE)

La migrazione `0020_separate_customer_auth.sql`:
- Copia dati da `users` a `clients` solo per utenti **NON** in `business_users`
- Gli operatori/admin rimangono **solo** in `users`
- I clienti puri vengono copiati in `clients` con `password_hash`

```sql
-- Solo utenti NON operatori/admin
INSERT INTO clients (business_id, email, password_hash, first_name, last_name, phone, ...)
SELECT bu2.business_id, u.email, u.password_hash, u.first_name, u.last_name, u.phone, ...
FROM users u
JOIN bookings b ON b.user_id = u.id
JOIN appointments a ON a.booking_id = b.id
JOIN staff s ON s.id = a.staff_id
JOIN locations l ON l.id = s.location_id
JOIN business_users bu2 ON bu2.business_id = l.business_id AND bu2.is_owner = 1
WHERE u.password_hash IS NOT NULL
  AND NOT EXISTS (SELECT 1 FROM business_users bu WHERE bu.user_id = u.id)
GROUP BY u.id, bu2.business_id;
```

### Compatibilit√† Backward

L'`AuthMiddleware` per operatori √® **backward compatible**:
- Token senza campo `role` ‚Üí accettato (legacy)
- Token con `role: operator` ‚Üí accettato
- Token con `role: customer` ‚Üí rifiutato (401)

### ‚úÖ Integrazione Flutter Frontend (03/01/2026)

L'integrazione customer auth √® **COMPLETATA** in `agenda_frontend`:

| Componente | Stato | Note |
|------------|-------|------|
| `api_config.dart` | ‚úÖ | Endpoint customer auth |
| `api_client.dart` | ‚úÖ | Metodi `customerLogin()`, `customerRegister()`, `customerLogout()`, `getCustomerMe()` |
| `token_storage_*.dart` | ‚úÖ | Salvataggio `businessId` per refresh token |
| `auth_repository.dart` | ‚úÖ | Usa endpoint customer con `businessId` |
| `auth_provider.dart` | ‚úÖ | `login()`, `logout()`, `register()` richiedono `businessId` |
| `login_screen.dart` | ‚úÖ | Passa `businessId` da `currentBusinessIdProvider` |
| `register_screen.dart` | ‚úÖ | Passa `businessId` da `currentBusinessIdProvider` |

**Flow completo:**
```
1. Cliente accede a: prenota.romeolab.it/romeolab/login
2. Router estrae slug "romeolab" ‚Üí routeSlugProvider
3. currentBusinessProvider carica business da API ‚Üí id: 1
4. Login chiama: POST /v1/customer/1/auth/login
5. Token JWT con role: "customer" salvato in memoria
6. businessId salvato in localStorage/secureStorage per refresh
```

---


SOURCE OF TRUTH: ../../STAFF_PLANNING_MODEL.md

Agisci come senior backend engineer.

Obiettivo:
Integrare nel progetto agenda_core il modello di staff planning temporale gi√† implementato in agenda_backend.

Vincoli:
- Segui ESATTAMENTE STAFF_PLANNING_MODEL.md.
- Non introdurre nuove regole.
- Non modificare il modello dati deciso.
- Non riscrivere logica di business gi√† implementata nel backend.
- Esporre solo API e query necessarie.
- Non toccare agenda_backend n√© agenda_frontend.

Attivit√† obbligatorie:
1) Esporre via API le entit√† staff_planning e staff_planning_week_template.
2) Esporre endpoint per:
   - lettura planning per staff
   - lettura planning valido per una data
   - lettura disponibilit√† staff per una data
3) Gestire valid_to = null come ‚Äúmai‚Äù.
4) Rispettare intervalli temporali chiusi-chiusi.
5) Se pi√π planning risultano validi per una data, restituire errore di consistenza.
6) Non aggiungere fallback automatici.

Output richiesto:
- Codice PHP/API aggiornato.
- Eventuali query SQL di lettura necessarie.
- Nessuna spiegazione testuale.

----- FILE: docs/api_contract_v1.md -----

# API Contract v1 ‚Äî agenda_core

Base URL: `/v1`

---

## Health Check

### GET /health

No authentication required.

Response (200):
```json
{
  "status": "ok",
  "timestamp": "2025-01-15T10:00:00+01:00",
  "version": "1.0.0"
}
```

---

## Response Format

### Success
```json
{
  "success": true,
  "data": { ... }
}
```

### Error
```json
{
  "success": false,
  "error": {
    "code": "error_code",
    "message": "Human readable message",
    "details": { ... }
  }
}
```

---

## Auth Endpoints (globale, no business context)

### POST /v1/auth/login

Request:
```json
{
  "email": "user@example.com",
  "password": "secret"
}
```

Response (200):
```json
{
  "success": true,
  "data": {
    "access_token": "eyJ...",
    "refresh_token": "abc123...",
    "expires_in": 900,
    "user": {
      "id": 1,
      "email": "user@example.com",
      "first_name": "Mario",
      "last_name": "Rossi"
    }
  }
}
```

Note: `refresh_token` viene anche settato come cookie httpOnly.

---

### POST /v1/auth/register

Request:
```json
{
  "email": "newuser@example.com",
  "password": "SecurePass123!",
  "first_name": "Mario",
  "last_name": "Rossi",
  "phone": "+39123456789"
}
```

Oppure con campo `name` unificato:
```json
{
  "email": "newuser@example.com",
  "password": "SecurePass123!",
  "name": "Mario Rossi"
}
```

Response (201):
```json
{
  "success": true,
  "data": {
    "access_token": "eyJ...",
    "refresh_token": "abc123...",
    "expires_in": 900,
    "user": {
      "id": 4,
      "email": "newuser@example.com",
      "first_name": "Mario",
      "last_name": "Rossi"
    }
  }
}
```

Errors:
- `email_already_exists` (409): Email gi√† registrata
- `weak_password` (400): Password non sufficientemente sicura (min 8 caratteri, maiuscola, minuscola, numero)

---

### POST /v1/auth/forgot-password

Request:
```json
{
  "email": "user@example.com"
}
```

Response (200):
```json
{
  "success": true,
  "data": {
    "message": "If the email exists, a password reset link has been sent"
  }
}
```

Note: Ritorna sempre 200 per evitare email enumeration.

---

### POST /v1/auth/reset-password

Request:
```json
{
  "token": "abc123def456...",
  "password": "NewSecurePass456!"
}
```

Response (200):
```json
{
  "success": true,
  "data": {
    "message": "Password has been reset successfully"
  }
}
```

Errors:
- `invalid_reset_token` (400): Token non valido o gi√† usato
- `reset_token_expired` (400): Token scaduto (validit√† 1 ora)
- `weak_password` (400): Password non sufficientemente sicura

---

### POST /v1/auth/refresh

Request (body o cookie):
```json
{
  "refresh_token": "abc123..."
}
```

Response (200):
```json
{
  "success": true,
  "data": {
    "access_token": "eyJ...",
    "refresh_token": "new-token...",
    "expires_in": 900
  }
}
```

Note: Implementa token rotation (vecchio refresh token invalidato).

---

### POST /v1/auth/logout

Headers: `Authorization: Bearer <access_token>`

Request (body o cookie):
```json
{
  "refresh_token": "abc123..."
}
```

Response (200):
```json
{
  "success": true,
  "data": {
    "message": "Logged out successfully"
  }
}
```

---

### GET /v1/me

Headers: `Authorization: Bearer <access_token>`

Response (200):
```json
{
  "success": true,
  "data": {
    "id": 1,
    "email": "user@example.com",
    "first_name": "Mario",
    "last_name": "Rossi",
    "phone": "+39...",
    "is_active": true,
    "staff_memberships": [
      {
        "staff_id": 1,
        "business_id": 1,
        "business_name": "Salone Bella Vita",
        "role": "stylist",
        "display_name": "Mario R."
      }
    ]
  }
}
```

---

### PUT /v1/me

Aggiorna il profilo dell'utente autenticato.

Headers: `Authorization: Bearer <access_token>`

Request (tutti i campi opzionali):
```json
{
  "first_name": "Mario",
  "last_name": "Rossi",
  "email": "nuova@email.com",
  "phone": "+39 333 1234567"
}
```

Response (200):
```json
{
  "success": true,
  "data": {
    "user": {
      "id": 1,
      "email": "nuova@email.com",
      "first_name": "Mario",
      "last_name": "Rossi",
      "phone": "+39 333 1234567",
      "is_active": true
    }
  }
}
```

Errors:
- `unauthorized` (401): Access token non valido o scaduto
- `validation_error` (400): Email gi√† in uso da altro utente

---

### POST /v1/me/change-password

Headers: `Authorization: Bearer <access_token>`

Request:
```json
{
  "current_password": "OldPass123!",
  "new_password": "NewSecurePass456!"
}
```

Response (200):
```json
{
  "success": true,
  "data": {
    "message": "Password changed successfully"
  }
}
```

Errors:
- `unauthorized` (401): Access token non valido o scaduto
- `validation_error` (400): Current password e new password sono obbligatori
- `invalid_credentials` (400): Current password errata
- `weak_password` (400): New password non sufficientemente sicura
- `validation_error` (400): New password uguale a current password

Note: 
- La password deve contenere almeno 8 caratteri
- Deve includere: maiuscola, minuscola, numero
- La nuova password deve essere diversa da quella corrente

---

### GET /v1/me/bookings

Headers: `Authorization: Bearer <access_token>`

Get all bookings for the authenticated user (upcoming and past).

Response (200):
```json
{
  "success": true,
  "data": {
    "upcoming": [
      {
        "booking_id": 123,
        "status": "confirmed",
        "start_time": "2025-12-30T14:00:00+01:00",
        "end_time": "2025-12-30T15:30:00+01:00",
        "service_names": ["Taglio", "Piega"],
        "staff_name": "Mario Rossi",
        "total_price": 45.00,
        "notes": "Note opzionali",
        "location_id": 1,
        "location_name": "Sede Centro",
        "location_address": "Via Roma 123",
        "location_city": "Milano",
        "business_id": 1,
        "business_name": "Salone Bella Vita",
        "can_modify": true,
        "can_modify_until": "2025-12-29T14:00:00+01:00",
        "created_at": "2025-12-20T10:00:00+01:00"
      }
    ],
    "past": [
      {
        "booking_id": 100,
        "status": "completed",
        "start_time": "2025-12-15T10:00:00+01:00",
        "end_time": "2025-12-15T11:00:00+01:00",
        "service_names": ["Taglio Uomo"],
        "staff_name": "Luigi Bianchi",
        "total_price": 25.00,
        "notes": null,
        "location_id": 1,
        "location_name": "...",
        "business_id": 1,
        "business_name": "...",
        "can_modify": false,
        "can_modify_until": null,
        "created_at": "2025-12-10T09:00:00+01:00"
      }
    ]
  }
}
```

Note:
- `booking_id`: ID univoco del booking (alias `id` per compatibilit√† frontend)
- `service_names`: Array di nomi servizi (aggregati da booking_items)
- `staff_name`: Nome completo dello staff (primo assegnato)
- `total_price`: Somma dei prezzi di tutti i booking_items
- `can_modify`: `true` se now < can_modify_until
- `can_modify_until`: deadline calcolata da `start_time - cancellation_hours`
- `cancellation_hours`: policy configurata a livello location o business (default 24h)
- Upcoming bookings ordinati per start_time ASC (prossimo prima)
- Past bookings ordinati per start_time DESC (recente prima)
- Formato flat (no nested objects) per semplicit√† parsing

---

## Superadmin Endpoints (30/12/2025)

Endpoint riservati ai superadmin (`users.is_superadmin = 1`).

### GET /v1/admin/businesses

Lista tutti i business della piattaforma.

**Auth required**: Yes (superadmin only)

Query params:
- `search`: Filtra per nome (opzionale)
- `limit`: Max risultati (default 50, max 100)
- `offset`: Per paginazione

Response (200):
```json
{
  "success": true,
  "data": {
    "businesses": [
      {
        "id": 1,
        "name": "Salone Bella Vita",
        "slug": "salone-bella-vita",
        "email": "info@bellavita.it",
        "phone": "+39 06 12345678",
        "timezone": "Europe/Rome",
        "currency": "EUR",
        "is_active": true,
        "created_at": "2025-01-01T10:00:00+01:00",
        "admin_email": "admin@bellavita.it"
      }
    ],
    "total": 15,
    "limit": 50,
    "offset": 0
  }
}
```

Note:
- `admin_email` √® l'email dell'owner del business (pu√≤ essere null se non assegnato)

Errors:
- `forbidden` (403): Non superadmin

---

### POST /v1/admin/businesses

Crea un nuovo business con owner.

**Auth required**: Yes (superadmin only)

Request:
```json
{
  "name": "Nuovo Salone",
  "slug": "nuovo-salone",
  "admin_email": "admin@nuovosalone.it",
  "email": "info@nuovosalone.it",
  "phone": "+39 333 1234567",
  "timezone": "Europe/Rome",
  "currency": "EUR"
}
```

Note: 
- `name` e `slug` sono obbligatori
- `admin_email` (opzionale): email dell'admin del business
  - Se omesso, il business viene creato senza owner (assegnabile in seguito via PUT)
  - Se l'email non esiste, viene creato un nuovo utente
  - Viene inviata email di benvenuto con link reset password (24h)

Response (201):
```json
{
  "success": true,
  "data": {
    "business": {
      "id": 2,
      "name": "Nuovo Salone",
      "slug": "nuovo-salone",
      "email": "info@nuovosalone.it",
      "phone": "+39 333 1234567",
      "timezone": "Europe/Rome",
      "currency": "EUR",
      "is_active": true,
      "created_at": "2025-12-30T10:00:00+01:00"
    },
    "owner": {
      "id": 1,
      "user_id": 123,
      "business_id": 2,
      "role": "owner"
    }
  }
}
```

Errors:
- `forbidden` (403): Non superadmin
- `validation_error` (400): Slug gi√† esistente o campo mancante

---

### PUT /v1/admin/businesses/{id}

Modifica un business esistente.

**Auth required**: Yes (superadmin only)

Request (tutti i campi opzionali):
```json
{
  "name": "Nome Aggiornato",
  "slug": "slug-aggiornato",
  "admin_email": "nuovo-admin@email.it",
  "email": "nuova@email.it",
  "phone": "+39 333 9999999",
  "timezone": "Europe/Rome",
  "currency": "EUR"
}
```

Note:
- Se `admin_email` viene fornito su business senza owner, viene assegnato come owner
- Se `admin_email` viene cambiato, la ownership viene trasferita
- Il vecchio admin diventa "admin", il nuovo diventa "owner"
- Viene inviata email di benvenuto al nuovo admin

Response (200):
```json
{
  "success": true,
  "data": {
    "business": {
      "id": 2,
      "name": "Nome Aggiornato",
      "slug": "slug-aggiornato",
      "email": "nuova@email.it",
      "phone": "+39 333 9999999",
      "timezone": "Europe/Rome",
      "currency": "EUR",
      "is_active": true,
      "created_at": "2025-12-30T10:00:00+01:00"
    }
  }
}
```

Errors:
- `forbidden` (403): Non superadmin
- `validation_error` (400): Slug gi√† in uso da altro business
- `not_found` (404): Business non trovato

---

### POST /v1/admin/businesses/{id}/resend-invite

Reinvia email di invito all'admin del business.

**Auth required**: Yes (superadmin only)

Genera un nuovo token reset password (validit√† 24h) e invia email di benvenuto.
Utile se l'admin non ha impostato la password in tempo.

Response (200):
```json
{
  "success": true,
  "data": {
    "message": "Invite email sent successfully",
    "admin_email": "admin@example.com"
  }
}
```

Errors:
- `forbidden` (403): Non superadmin
- `not_found` (404): Business non trovato
- `not_found` (404): Business non ha un admin associato

---

### DELETE /v1/admin/businesses/{id}

Soft-delete di un business (imposta `is_active = false`).

**Auth required**: Yes (superadmin only)

Response (200):
```json
{
  "success": true,
  "data": {
    "message": "Business deleted successfully",
    "id": 2
  }
}
```

Errors:
- `forbidden` (403): Non superadmin
- `not_found` (404): Business non trovato

---

## Management Endpoints (admin/staff access)

### GET /v1/businesses

Headers: `Authorization: Bearer <access_token>`

Ritorna la lista di tutti i businesses. (In produzione potrebbe filtrare per user permissions).

Response (200):
```json
{
  "success": true,
  "data": {
    "businesses": [
      {
        "id": 1,
        "name": "Salone Bella Vita",
        "slug": "salone-bella-vita",
        "email": "info@bellavita.it",
        "phone": "+39 06 12345678",
        "timezone": "Europe/Rome",
        "currency": "EUR",
        "is_active": true,
        "created_at": "2025-01-01T00:00:00Z"
      }
    ]
  }
}
```

---

### GET /v1/businesses/{business_id}

Headers: `Authorization: Bearer <access_token>`

Response (200):
```json
{
  "success": true,
  "data": {
    "id": 1,
    "name": "Salone Bella Vita",
    "slug": "salone-bella-vita",
    "email": "info@bellavita.it",
    "phone": "+39 06 12345678",
    "timezone": "Europe/Rome",
    "currency": "EUR",
    "is_active": true,
    "created_at": "2025-01-01T00:00:00Z",
    "updated_at": "2025-01-15T10:00:00Z"
  }
}
```

Error - Not Found (404):
```json
{
  "success": false,
  "error": {
    "code": "not_found",
    "message": "Business not found"
  }
}
```

---

### GET /v1/businesses/{business_id}/locations

Headers: `Authorization: Bearer <access_token>`

Ritorna tutte le locations di un business.

Response (200):
```json
{
  "success": true,
  "data": {
    "data": [
      {
        "id": 1,
        "business_id": 1,
        "name": "Sede Centrale",
        "address": "Via Roma 123, Roma",
        "city": "Roma",
        "region": "Lazio",
        "country": "IT",
        "timezone": "Europe/Rome",
        "latitude": 41.9028,
        "longitude": 12.4964,
        "phone": "+39 06 12345678",
        "email": "roma@bellavita.it",
        "currency": "EUR",
        "is_default": true,
        "is_active": true,
        "created_at": "2025-01-15T10:00:00Z",
        "updated_at": "2025-01-15T10:00:00Z"
      }
    ]
  }
}
```

---

### GET /v1/businesses/{business_id}/locations/public

**No authentication required** (pubblico, per booking flow).

Ritorna le locations attive di un business con campi limitati per il frontend di prenotazione.

Response (200):
```json
{
  "success": true,
  "data": {
    "data": [
      {
        "id": 1,
        "business_id": 1,
        "name": "Sede Centrale",
        "address": "Via Roma 123",
        "city": "Roma",
        "phone": "+39 06 12345678",
        "timezone": "Europe/Rome",
        "is_default": true
      }
    ]
  }
}
```

Nota: Endpoint usato dal frontend di prenotazione per mostrare le sedi disponibili. Se il business ha pi√π di una location, l'utente pu√≤ scegliere dove prenotare.

---

### GET /v1/locations/{location_id}

Headers: `Authorization: Bearer <access_token>`

Response (200):
```json
{
  "success": true,
  "data": {
    "id": 1,
    "business_id": 1,
    "name": "Sede Centrale",
    "address": "Via Roma 123, Roma",
    "city": "Roma",
    "postal_code": "00100",
    "country": "IT",
    "timezone": "Europe/Rome",
    "latitude": 41.9028,
    "longitude": 12.4964,
    "phone": "+39 06 12345678",
    "email": "roma@bellavita.it",
    "currency": "EUR",
    "is_active": true,
    "created_at": "2025-01-01T00:00:00Z",
    "updated_at": "2025-01-15T10:00:00Z"
  }
}
```

---

## Public Endpoints (business-scoped via query param)

### GET /v1/services?location_id=1

Response (200):
```json
{
  "success": true,
  "data": {
    "categories": [
      {
        "id": 1,
        "name": "Taglio",
        "services": [
          {
            "id": 1,
            "name": "Taglio Uomo",
            "description": "...",
            "default_duration_minutes": 30,
            "default_price": 20.00,
            "color": "#FF6B6B",
            "category_id": 1
          }
        ]
      }
    ],
    "services": [ ... ]
  }
}
```

---

### GET /v1/staff?location_id=1

Response (200):
```json
{
  "success": true,
  "data": {
    "staff": [
      {
        "id": 1,
        "display_name": "Anna B.",
        "role": "stylist",
        "color": "#FF6B6B",
        "avatar_url": null
      }
    ]
  }
}
```

---

### GET /v1/availability?location_id=1&date=2024-01-15&service_ids=1,2&staff_id=1

Parameters:
- `location_id` (required): ID della location
- `date` (required): Data in formato YYYY-MM-DD
- `service_ids` (required): IDs servizi separati da virgola
- `staff_id` (optional): Filtra per staff specifico

Response (200):
```json
{
  "success": true,
  "data": {
    "slots": [
      {
        "start_time": "2024-01-15T09:00:00+01:00",
        "end_time": "2024-01-15T10:15:00+01:00",
        "staff_id": 1,
        "staff_name": "Anna B."
      }
    ]
  }
}
```

---

## Protected Endpoints (auth + business-scoped via path)

### POST /v1/locations/{location_id}/bookings

Headers:
- `Authorization: Bearer <access_token>` (required)
- `X-Idempotency-Key: <uuid-v4>` (required, formato UUID v4)

Request Payload (INVARIABILE):
```json
{
  "service_ids": [1, 2],
  "staff_id": 1,
  "start_time": "2024-01-15T10:00:00Z",
  "notes": "Prima visita"
}
```

Response (201):
```json
{
  "success": true,
  "data": {
    "id": 42,
    "business_id": 1,
    "location_id": 1,
    "client_id": 1,
    "status": "confirmed",
    "notes": "Prima visita",
    "total_price": 55.00,
    "total_duration_minutes": 75,
    "created_at": "2024-01-10T14:30:00Z",
    "items": [
      {
        "id": 1,
        "service_id": 1,
        "service_name": "Taglio Uomo",
        "staff_id": 1,
        "staff_name": "Anna B.",
        "location_id": 1,
        "start_time": "2024-01-15T10:00:00Z",
        "end_time": "2024-01-15T10:30:00Z",
        "price": 20.00,
        "duration_minutes": 30
      },
      {
        "id": 2,
        "service_id": 2,
        "service_name": "Taglio Donna",
        "staff_id": 1,
        "staff_name": "Anna B.",
        "location_id": 1,
        "start_time": "2024-01-15T10:30:00Z",
        "end_time": "2024-01-15T11:15:00Z",
        "price": 35.00,
        "duration_minutes": 45
      }
    ]
  }
}
```

Error - Slot Conflict (409):
```json
{
  "success": false,
  "error": {
    "code": "slot_conflict",
    "message": "The requested time slot is no longer available",
    "details": {
      "conflicts": [...]
    }
  }
}
```

---

### PUT /v1/locations/{location_id}/bookings/{booking_id}

Headers: `Authorization: Bearer <access_token>`

**Use Case 1: Update Status or Notes**

Request:
```json
{
  "status": "confirmed",
  "notes": "Cliente confermato via telefono"
}
```

**Use Case 2: Reschedule (Change Date/Time)**

Request:
```json
{
  "start_time": "2025-12-30T14:00:00+01:00",
  "notes": "Riprogrammazione appuntamento"
}
```

Campi opzionali (almeno uno richiesto):
- `status`: "pending" | "confirmed" | "cancelled" | "completed" | "no_show"
- `notes`: stringa
- `start_time`: ISO8601 datetime per reschedule

**Note sul Reschedule**:
- Aggiorna tutti i `booking_items` mantenendo durate e intervalli relativi
- Non permette cambio servizi o staff
- Soggetto a cancellation policy (stesso vincolo di DELETE)
- ‚úÖ Availability check server-side: verifica conflitti staff con `FOR UPDATE`
- Transazione atomica per evitare race conditions

Response (200):
```json
{
  "success": true,
  "data": {
    "id": 42,
    "status": "confirmed",
    "notes": "Cliente confermato via telefono",
    "items": [
      {
        "id": 101,
        "start_time": "2025-12-30T14:00:00+01:00",
        "end_time": "2025-12-30T15:00:00+01:00",
        ...
      }
    ],
    ...
  }
}
```

Error - Not Found (404):
```json
{
  "success": false,
  "error": {
    "code": "not_found",
    "message": "Booking not found"
  }
}
```

Error - Unauthorized (403):
```json
{
  "success": false,
  "error": {
    "code": "unauthorized",
    "message": "You do not have permission to update this booking"
  }
}
```

Error - Cancellation Policy Violation (400):
```json
{
  "success": false,
  "error": {
    "code": "validation_error",
    "message": "Cannot modify booking within 24 hours of appointment start time",
    "details": {
      "cancellation_deadline": "2025-12-29T14:00:00+01:00"
    }
  }
}
```
  }
}
```

---

### DELETE /v1/locations/{location_id}/bookings/{booking_id}

Headers: `Authorization: Bearer <access_token>`

Cancella un booking e tutti i suoi booking_items associati.

Response (200):
```json
{
  "success": true,
  "data": {
    "message": "Booking deleted successfully"
  }
}
```

Error - Not Found (404):
```json
{
  "success": false,
  "error": {
    "code": "not_found",
    "message": "Booking not found"
  }
}
```

Error - Unauthorized (403):
```json
{
  "success": false,
  "error": {
    "code": "unauthorized",
    "message": "You do not have permission to delete this booking"
  }
}
```

---

## Appointments (Gestionale)

### GET /v1/locations/{location_id}/appointments?date=YYYY-MM-DD

Get all appointments (booking_items) for a specific location and date.

**Auth required**: Yes  
**Middleware**: auth, location_path

Query params:
- `date` (required): Date in YYYY-MM-DD format

Response (200):
```json
{
  "success": true,
  "data": {
    "appointments": [
      {
        "id": 1,
        "booking_id": 10,
        "location_id": 1,
        "staff_id": 2,
        "service_variant_id": 5,
        "start_time": "2025-12-27T10:00:00+01:00",
        "end_time": "2025-12-27T10:30:00+01:00",
        "extra_blocked_minutes": 0,
        "extra_processing_minutes": 0,
        "booking_status": "confirmed",
        "client_name": "Mario Rossi",
        "service_name": "Taglio Uomo",
        "staff_name": "Anna Bianchi",
        "created_at": "2025-12-26T15:00:00+01:00",
        "updated_at": "2025-12-26T15:00:00+01:00"
      }
    ]
  }
}
```

---

### PATCH /v1/locations/{location_id}/appointments/{id}

Reschedule or update an appointment.

**Auth required**: Yes  
**Middleware**: auth, location_path  
**Permission**: Only booking owner can update

Request:
```json
{
  "start_time": "2025-12-27T11:00:00+01:00",
  "end_time": "2025-12-27T11:30:00+01:00",
  "staff_id": 3
}
```

Response (200):
```json
{
  "success": true,
  "data": {
    "id": 1,
    "booking_id": 10,
    "start_time": "2025-12-27T11:00:00+01:00",
    "end_time": "2025-12-27T11:30:00+01:00",
    "staff_id": 3,
    "..."
  }
}
```

---

### POST /v1/locations/{location_id}/appointments/{id}/cancel

Cancel an appointment.

**Auth required**: Yes  
**Middleware**: auth, location_path  
**Permission**: Only booking owner can cancel

Response (200):
```json
{
  "success": true,
  "data": {
    "cancelled": true,
    "appointment_id": 1
  }
}
```

---

## Clients (Gestionale)

### GET /v1/clients?business_id=X&search=term

Get clients for a business.

**Auth required**: Yes

Query params:
- `business_id` (required): Business ID
- `search` (optional): Search term (name, email, phone)
- `limit` (optional): Max results (default 100)
- `offset` (optional): Pagination offset

Response (200):
```json
{
  "success": true,
  "data": {
    "clients": [
      {
        "id": 1,
        "business_id": 1,
        "user_id": 5,
        "first_name": "Mario",
        "last_name": "Rossi",
        "email": "mario@example.com",
        "phone": "+39123456789",
        "notes": null,
        "is_archived": false,
        "created_at": "2025-01-01T10:00:00+01:00",
        "updated_at": "2025-01-01T10:00:00+01:00"
      }
    ]
  }
}
```

---

### POST /v1/clients

Create a new client.

**Auth required**: Yes

Request:
```json
{
  "business_id": 1,
  "first_name": "Mario",
  "last_name": "Rossi",
  "email": "mario@example.com",
  "phone": "+39123456789",
  "notes": "Cliente VIP"
}
```

Response (201):
```json
{
  "success": true,
  "data": {
    "id": 1,
    "business_id": 1,
    "first_name": "Mario",
    "..."
  }
}
```

---

### PUT /v1/clients/{id}

Update a client.

**Auth required**: Yes

Request:
```json
{
  "first_name": "Mario",
  "last_name": "Rossi",
  "email": "newemail@example.com",
  "phone": "+39987654321",
  "notes": "Updated notes",
  "is_archived": false
}
```

---

### DELETE /v1/clients/{id}

Archive a client (soft delete).

**Auth required**: Yes

Response (200):
```json
{
  "success": true,
  "data": {
    "deleted": true
  }
}
```

---

## Business Users (Operators) Endpoints

Endpoints per gestire gli operatori di un business (chi pu√≤ accedere al gestionale).

### GET /v1/businesses/{business_id}/users

List operators for a business.

**Auth required**: Yes (owner/admin or superadmin)

Response (200):
```json
{
  "success": true,
  "data": {
    "users": [
      {
        "id": 1,
        "user_id": 2,
        "business_id": 1,
        "role": "owner",
        "email": "anna@example.com",
        "first_name": "Anna",
        "last_name": "Bianchi",
        "status": "active",
        "invited_at": null,
        "joined_at": "2025-01-01T10:00:00+01:00",
        "is_current_user": true
      },
      {
        "id": 2,
        "user_id": 3,
        "business_id": 1,
        "role": "staff",
        "email": "mario@example.com",
        "first_name": "Mario",
        "last_name": "Rossi",
        "status": "active",
        "invited_at": "2025-12-28T10:00:00+01:00",
        "joined_at": "2025-12-28T12:00:00+01:00",
        "is_current_user": false
      }
    ]
  }
}
```

---

### POST /v1/businesses/{business_id}/users

Add an existing user to a business.

**Auth required**: Yes (owner/admin or superadmin)

Request:
```json
{
  "user_id": 5,
  "role": "staff"
}
```

Response (201):
```json
{
  "success": true,
  "data": {
    "id": 3,
    "user_id": 5,
    "business_id": 1,
    "role": "staff"
  }
}
```

Errors:
- `already_member` (409): User gi√† membro del business
- `forbidden` (403): Non puoi assegnare un ruolo >= al tuo

---

### PATCH /v1/businesses/{business_id}/users/{user_id}

Update operator role.

**Auth required**: Yes (owner/admin or superadmin)

Request:
```json
{
  "role": "manager"
}
```

Response (200):
```json
{
  "success": true,
  "data": {
    "id": 2,
    "user_id": 3,
    "role": "manager"
  }
}
```

---

### DELETE /v1/businesses/{business_id}/users/{user_id}

Remove operator from business.

**Auth required**: Yes (owner/admin or superadmin)

Response (200):
```json
{
  "success": true,
  "data": {
    "removed": true
  }
}
```

Errors:
- `forbidden` (403): Non puoi rimuovere owner o te stesso

---

## Business Invitations Endpoints

Endpoints per gestire inviti via email agli operatori.

### GET /v1/businesses/{business_id}/invitations

List pending invitations for a business.

**Auth required**: Yes (owner/admin or superadmin)

Response (200):
```json
{
  "success": true,
  "data": {
    "invitations": [
      {
        "id": 1,
        "email": "nuovo@example.com",
        "role": "staff",
        "expires_at": "2026-01-04T14:00:00+01:00",
        "created_at": "2025-12-28T14:00:00+01:00",
        "invited_by": {
          "first_name": "Anna",
          "last_name": "Bianchi"
        }
      }
    ]
  }
}
```

---

### POST /v1/businesses/{business_id}/invitations

Create a new invitation.

**Auth required**: Yes (owner/admin or superadmin)

Request:
```json
{
  "email": "nuovo@example.com",
  "role": "staff"
}
```

Response (201):
```json
{
  "success": true,
  "data": {
    "id": 1,
    "email": "nuovo@example.com",
    "role": "staff",
    "token": "abc123...",
    "expires_at": "2026-01-04T14:00:00+01:00",
    "invite_url": "https://app.example.com/invite/abc123...",
    "business": {
      "id": 1,
      "name": "Salone Bella Vita"
    }
  }
}
```

Errors:
- `validation_error` (400): Email gi√† membro del business
- `validation_error` (400): Invito gi√† pendente per questa email
- `forbidden` (403): Non puoi invitare con ruolo >= al tuo

---

### DELETE /v1/businesses/{business_id}/invitations/{invitation_id}

Revoke a pending invitation.

**Auth required**: Yes (owner/admin or superadmin)

Response (200):
```json
{
  "success": true,
  "data": {
    "message": "Invitation revoked",
    "id": 1
  }
}
```

---

### GET /v1/invitations/{token}

Get invitation details (public endpoint, no auth required).

Response (200):
```json
{
  "success": true,
  "data": {
    "email": "nuovo@example.com",
    "role": "staff",
    "business": {
      "id": 1,
      "name": "Salone Bella Vita",
      "slug": "salone-bella-vita"
    },
    "expires_at": "2026-01-04T14:00:00+01:00"
  }
}
```

Errors:
- `not_found` (404): Token non valido
- `validation_error` (400): Invito scaduto o gi√† usato

---

### POST /v1/invitations/{token}/accept

Accept an invitation.

**Auth required**: Yes (email must match invitation)

Response (200):
```json
{
  "success": true,
  "data": {
    "message": "Invitation accepted",
    "business_id": 1,
    "business_name": "Salone Bella Vita",
    "role": "staff"
  }
}
```

Errors:
- `not_found` (404): Token non valido
- `validation_error` (400): Invito scaduto
- `forbidden` (403): Email non corrisponde all'invito

---

## Business Context Derivation

| Endpoint Type | location_id Source | business_id |
|---------------|-------------------|-------------|
| Auth | N/A | N/A |
| Public | Query param `?location_id=X` | DB lookup da location_id |
| POST /bookings | PATH param `/locations/{X}/...` | DB lookup da location_id |

**IMPORTANTE**: JWT contiene SOLO `user_id`. MAI `business_id` o `location_id`.

---

## Error Codes

| Code | HTTP | Descrizione |
|------|------|-------------|
| `invalid_credentials` | 401 | Email o password errati |
| `account_disabled` | 401 | Account disabilitato |
| `token_expired` | 401 | Access token scaduto |
| `token_invalid` | 401 | Token malformato o firma invalida |
| `session_revoked` | 401 | Refresh token revocato |
| `unauthorized` | 401 | Authorization header mancante |
| `missing_location` | 400 | location_id non fornito |
| `invalid_location` | 400 | Location non esiste o non attiva |
| `slot_conflict` | 409 | Slot gi√† occupato |
| `invalid_service` | 400 | Servizio non valido |
| `invalid_staff` | 400 | Staff non disponibile |
| `invalid_time` | 400 | Orario non valido |
| `validation_error` | 400 | Errore di validazione generico |
| `not_found` | 404 | Risorsa non trovata |
| `internal_error` | 500 | Errore interno |

---

## Idempotency

Per `POST /bookings`, inviare header `X-Idempotency-Key: <uuid>`.

Se una richiesta con lo stesso `idempotency_key` viene ripetuta (stesso business):
- Se booking gi√† creato ‚Üí ritorna booking esistente (200)
- Se in corso ‚Üí attende completamento

Chiave unica: `(business_id, idempotency_key)`

----- FILE: docs/data_models.md -----

# Data Models ‚Äî agenda_core

## Core Entities

### Service
- id
- business_id
- category_id
- name
- duration_minutes
- price
- is_free
- is_price_starting_from
- is_bookable_online

### Staff
- id
- business_id
- name
- surname
- is_bookable_online

### Booking
- id
- business_id
- location_id
- customer_id
- start_time
- end_time
- notes

---

## User & Auth Entities

### User
- id
- email (unique, global)
- password_hash
- first_name
- last_name
- phone
- is_active
- is_superadmin
- created_at
- updated_at

### AuthSession
- id
- user_id
- refresh_token_hash (SHA-256)
- device_info
- ip_address
- last_used_at
- expires_at
- revoked_at
- created_at

---

## Business Access Control (M11)

### BusinessUser
Associa utenti a businesses con ruoli e permessi.

- id
- business_id
- user_id
- role (enum: owner, admin, manager, staff)
- staff_id (optional, link a staff record)
- can_manage_bookings
- can_manage_clients
- can_manage_services
- can_manage_staff
- can_view_reports
- is_active
- invited_by
- invited_at
- joined_at
- created_at
- updated_at

**Role Hierarchy:**
- `owner`: Full control, can delete business, manage all users
- `admin`: Full control except delete business, can manage users
- `manager`: Can manage appointments, clients, staff schedules
- `staff`: Can view/edit own appointments only

**Unique Constraint:** `(business_id, user_id)`

### BusinessInvitation
Inviti via email per nuovi operatori.

- id
- business_id
- email
- role (enum: admin, manager, staff)
- token (64-char hex, unique)
- expires_at (default: created_at + 7 days)
- status (enum: pending, accepted, expired, revoked)
- accepted_by (user_id, nullable)
- accepted_at (nullable)
- invited_by (user_id)
- created_at
- updated_at

**Unique Constraint:** `(business_id, email, status)` - un solo invito pending per email

**Indexes:**
- `token, status` - lookup per accettazione
- `business_id, status` - lista inviti pendenti
- `email, status` - ricerca inviti per email

---

## Relationships

```
User (1) ----< (N) AuthSession
User (1) ----< (N) BusinessUser >---- (1) Business
User (1) ----< (N) BusinessInvitation >---- (1) Business
Business (1) ----< (N) Location
Business (1) ----< (N) Staff
Business (1) ----< (N) Service
Business (1) ----< (N) Client
Location (1) ----< (N) Booking
```

---

## Notes

- `is_superadmin` in `users` √® flag globale, non legato a nessun business
- Superadmin bypassa completamente `business_users` e pu√≤ operare su qualsiasi business
- `staff_id` in `business_users` permette di collegare un operatore al suo calendario staff

----- FILE: docs/db_schema_mvp.md -----

# DB Schema MVP ‚Äî agenda_core

Schema MySQL/MariaDB per la piattaforma Agenda multi-tenant.

---

## üèóÔ∏è Architettura Multi-Tenant

### Modello di Identit√†

| Entit√† | Scope | Note |
|--------|-------|------|
| `users` | **GLOBALE** | Solo per login/auth. Nessun business_id. |
| `clients` | **PER BUSINESS** | Anagrafica locale. Ha business_id e user_id opzionale. |

Un utente pu√≤ essere client di pi√π business tramite pi√π record `clients`.
Ogni business vede esclusivamente i propri clients.

### JWT

| Campo | Presente | Note |
|-------|----------|------|
| user_id | ‚úÖ | Identit√† utente |
| business_id | ‚ùå | MAI nel JWT |
| location_id | ‚ùå | MAI nel JWT |

### Derivazione contesto business

| Campo | Origine | Quando |
|-------|---------|--------|
| `location_id` | **PATH parameter** | Sempre. Es: `/v1/locations/{location_id}/bookings` |
| `business_id` | **Lookup DB** | `SELECT business_id FROM locations WHERE id = :location_id` |

**‚ö†Ô∏è IMPORTANTE:** 
- Il contesto business deriva SEMPRE dal `location_id` nel PATH
- `business_id` NON √® nel payload, NON √® nel JWT
- Il server lo ricava dal database partendo da `location_id`

---

## üìä Diagramma ER semplificato

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  businesses ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ<‚îÇ  locations  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                   ‚îÇ
       ‚îÇ                   ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ                   ‚ñº                  ‚ñº
       ‚îÇ            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ            ‚îÇ    staff    ‚îÇ    ‚îÇ   resources   ‚îÇ
       ‚îÇ            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ                   ‚îÇ
       ‚ñº                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê         ‚îÇ
‚îÇ business_users ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ (staff_id opzionale)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ
       ‚îÇ                   ‚îÇ
       ‚ñº                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ
‚îÇ    users    ‚îÇ            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ
       ‚îÇ                   ‚îÇ
       ‚ñº                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
‚îÇ auth_sessions ‚îÇ          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
                           ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê            ‚îÇ
‚îÇ  services   ‚îÇ            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò            ‚îÇ
       ‚îÇ                   ‚îÇ
       ‚ñº                   ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ service_variants ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  bookings   ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ<‚îÇ booking_items ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚ñ≤
       ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   clients   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üìã Tabelle

### 1. businesses
Tenant principale. Ogni business √® completamente isolato.

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| name | VARCHAR(255) NOT NULL | |
| slug | VARCHAR(100) UNIQUE NOT NULL | Per URL pubblici |
| email | VARCHAR(255) | |
| phone | VARCHAR(50) | |
| timezone | VARCHAR(50) DEFAULT 'Europe/Rome' | |
| currency | VARCHAR(3) DEFAULT 'EUR' | |
| cancellation_hours | INT UNSIGNED DEFAULT 24 | Default policy: ore minime prima appuntamento per cancellare/modificare |
| is_active | TINYINT(1) DEFAULT 1 | |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

### 2. locations
Sedi fisiche di un business.

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| business_id | INT UNSIGNED FK NOT NULL | |
| name | VARCHAR(255) NOT NULL | |
| address | VARCHAR(500) | |
| city | VARCHAR(100) | |
| postal_code | VARCHAR(20) | Aggiunto in migration 0009 |
| region | VARCHAR(100) | |
| country | VARCHAR(100) DEFAULT 'IT' | |
| phone | VARCHAR(50) | |
| email | VARCHAR(255) | |
| latitude | DECIMAL(10,8) | |
| longitude | DECIMAL(11,8) | |
| timezone | VARCHAR(50) DEFAULT 'Europe/Rome' | Aggiunto in migration 0005 |
| currency | VARCHAR(3) | Override business |
| cancellation_hours | INT UNSIGNED NULL | Override business cancellation policy. NULL = usa business default |
| is_default | TINYINT(1) DEFAULT 0 | |
| is_active | TINYINT(1) DEFAULT 1 | |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

### 3. users
Utenti GLOBALI per autenticazione. Non appartengono a nessun business.
Un utente pu√≤ operare con pi√π business diversi tramite la tabella `business_users` (operatori gestionale) o `clients` (clienti prenotazione).

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| email | VARCHAR(255) UNIQUE NOT NULL | Globale, non per business |
| password_hash | VARCHAR(255) NOT NULL | bcrypt/argon2 |
| first_name | VARCHAR(100) NOT NULL | |
| last_name | VARCHAR(100) NOT NULL | |
| phone | VARCHAR(50) | |
| email_verified_at | TIMESTAMP | |
| is_active | TINYINT(1) DEFAULT 1 | |
| is_superadmin | TINYINT(1) DEFAULT 0 | Ruolo globale: pu√≤ gestire tutti i business senza record in business_users |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

**Superadmin**: Non ha record in `business_users`. Quando seleziona un business, opera come admin.

### 3a. business_users
Associazione utenti-business per operatori del gestionale (multi-tenant access control).

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| business_id | INT UNSIGNED FK NOT NULL | |
| user_id | INT UNSIGNED FK NOT NULL | |
| role | ENUM('owner','admin','manager','staff') DEFAULT 'staff' | Gerarchia permessi |
| staff_id | INT UNSIGNED FK NULL | Link opzionale a record staff |
| can_manage_bookings | TINYINT(1) DEFAULT 1 | |
| can_manage_clients | TINYINT(1) DEFAULT 1 | |
| can_manage_services | TINYINT(1) DEFAULT 0 | |
| can_manage_staff | TINYINT(1) DEFAULT 0 | |
| can_view_reports | TINYINT(1) DEFAULT 0 | |
| is_active | TINYINT(1) DEFAULT 1 | |
| invited_by | INT UNSIGNED FK NULL | User che ha invitato |
| invited_at | TIMESTAMP NULL | |
| accepted_at | TIMESTAMP NULL | |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

UNIQUE (business_id, user_id)

**Ruoli e permessi default:**
| Ruolo | bookings | clients | services | staff | reports |
|-------|----------|---------|----------|-------|---------|
| owner | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| admin | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ | ‚úÖ |
| manager | ‚úÖ | ‚úÖ | ‚ùå | ‚ùå | ‚úÖ |
| staff | ‚úÖ* | ‚úÖ* | ‚ùå | ‚ùå | ‚ùå |

*staff: solo propri appuntamenti/clienti di default

### 3b. business_invitations
Inviti via email per nuovi operatori del business.

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| business_id | INT UNSIGNED FK NOT NULL | |
| email | VARCHAR(255) NOT NULL | Email destinatario |
| role | ENUM('admin','manager','staff') DEFAULT 'staff' | Ruolo assegnato |
| token | VARCHAR(64) NOT NULL UNIQUE | Token hex 64 caratteri |
| expires_at | TIMESTAMP NOT NULL | Default: +7 giorni |
| status | ENUM('pending','accepted','expired','revoked') DEFAULT 'pending' | |
| accepted_by | INT UNSIGNED FK NULL | User che ha accettato |
| accepted_at | TIMESTAMP NULL | |
| invited_by | INT UNSIGNED FK NOT NULL | User che ha invitato |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

UNIQUE (business_id, email, status) - un solo invito pending per email

**Indexes:**
- `(token, status)` - lookup per accettazione
- `(business_id, status)` - lista inviti pendenti
- `(email, status)` - ricerca inviti per email

**Flusso invito:**
1. Owner/Admin crea invito ‚Üí genera token
2. Email inviata con link `/invite/{token}`
3. Destinatario apre link, fa login/register
4. `POST /v1/invitations/{token}/accept` ‚Üí crea record `business_users`

### 4. auth_sessions
Sessioni di autenticazione con refresh token (hash, mai in chiaro).

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| user_id | INT UNSIGNED FK NOT NULL | |
| refresh_token_hash | VARCHAR(255) NOT NULL | SHA-256 del token |
| user_agent | VARCHAR(500) | Per identificare device |
| ip_address | VARCHAR(45) | IPv4 o IPv6 |
| expires_at | TIMESTAMP NOT NULL | Scadenza refresh token |
| last_used_at | TIMESTAMP | Ultimo utilizzo (per rotation) |
| revoked_at | TIMESTAMP | Se revocato manualmente |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |

**Rotation pattern:**
1. Al refresh, si crea una nuova sessione con nuovo `refresh_token_hash`
2. La vecchia sessione viene marcata con `revoked_at = NOW()`
3. Se un token revocato viene riutilizzato ‚Üí si revocano TUTTE le sessioni utente (possibile furto)

### 5. service_categories
Categorie di servizi per organizzazione.

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| business_id | INT UNSIGNED FK NOT NULL | |
| name | VARCHAR(255) NOT NULL | |
| description | TEXT | |
| sort_order | INT DEFAULT 0 | |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

### 6. services
Servizi offerti dal business.

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| business_id | INT UNSIGNED FK NOT NULL | |
| category_id | INT UNSIGNED FK NOT NULL | |
| name | VARCHAR(255) NOT NULL | |
| description | TEXT | |
| sort_order | INT DEFAULT 0 | |
| is_active | TINYINT(1) DEFAULT 1 | |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

### 7. service_variants
Varianti di servizio per location (durata, prezzo, disponibilit√† online).

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| service_id | INT UNSIGNED FK NOT NULL | |
| location_id | INT UNSIGNED FK NOT NULL | |
| duration_minutes | INT UNSIGNED NOT NULL | |
| processing_time | INT UNSIGNED | Minuti post-lavorazione |
| blocked_time | INT UNSIGNED | Minuti bloccati |
| price | DECIMAL(10,2) NOT NULL DEFAULT 0 | |
| currency | VARCHAR(3) | Override location |
| color_hex | VARCHAR(7) | Es. #FF5733 |
| is_bookable_online | TINYINT(1) DEFAULT 1 | |
| is_free | TINYINT(1) DEFAULT 0 | |
| is_price_starting_from | TINYINT(1) DEFAULT 0 | "da ‚Ç¨X" |
| is_active | TINYINT(1) DEFAULT 1 | |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

UNIQUE (service_id, location_id)

### 8. staff
Operatori/dipendenti del business.

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| business_id | INT UNSIGNED FK NOT NULL | |
| name | VARCHAR(100) NOT NULL | |
| surname | VARCHAR(100) DEFAULT '' | |
| color_hex | VARCHAR(7) DEFAULT '#FFD700' | |
| avatar_url | VARCHAR(500) | |
| sort_order | INT DEFAULT 0 | |
| is_default | TINYINT(1) DEFAULT 0 | |
| is_bookable_online | TINYINT(1) DEFAULT 1 | |
| is_active | TINYINT(1) DEFAULT 1 | |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

### 9. staff_locations
Relazione N:M staff ‚Üî locations.

| Colonna | Tipo | Note |
|---------|------|------|
| staff_id | INT UNSIGNED FK NOT NULL | PK part |
| location_id | INT UNSIGNED FK NOT NULL | PK part |

PRIMARY KEY (staff_id, location_id)

### 9a. staff_services
Restrizioni servizi per staff (quali servizi ogni staff pu√≤ erogare).

| Colonna | Tipo | Note |
|---------|------|------|
| staff_id | INT UNSIGNED FK NOT NULL | PK part |
| service_id | INT UNSIGNED FK NOT NULL | PK part |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |

PRIMARY KEY (staff_id, service_id)

**Logica**: Se la tabella √® vuota per uno staff, pu√≤ erogare tutti i servizi (permissivo di default). Se esistono record, validare che lo staff possa erogare TUTTI i servizi richiesti.

### 9b. location_schedules
Orari di apertura per location per giorno della settimana.

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| location_id | INT UNSIGNED FK NOT NULL | |
| day_of_week | TINYINT UNSIGNED NOT NULL | 0=Sunday, 1=Monday, ..., 6=Saturday |
| open_time | TIME NOT NULL | Orario apertura (es. 09:00:00) |
| close_time | TIME NOT NULL | Orario chiusura (es. 18:00:00) |
| is_closed | TINYINT(1) DEFAULT 0 | Giorno chiuso |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

UNIQUE (location_id, day_of_week)

CHECK (day_of_week BETWEEN 0 AND 6)
CHECK (open_time < close_time OR is_closed = 1)

**Fallback**: Se non configurato, default 9:00-18:00 Lun-Ven.

### 10. clients
Clienti gestiti dal business (anagrafica gestionale).

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| business_id | INT UNSIGNED FK NOT NULL | |
| user_id | INT UNSIGNED FK | Link a user se registrato online |
| first_name | VARCHAR(100) | |
| last_name | VARCHAR(100) | |
| email | VARCHAR(255) | |
| phone | VARCHAR(50) | |
| gender | VARCHAR(20) | |
| birth_date | DATE | |
| city | VARCHAR(100) | |
| notes | TEXT | |
| loyalty_points | INT DEFAULT 0 | |
| last_visit | TIMESTAMP | |
| is_archived | TINYINT(1) DEFAULT 0 | |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

INDEX (business_id, email)
INDEX (business_id, phone)

### 11. bookings
Prenotazioni (contenitore di uno o pi√π servizi).

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| business_id | INT UNSIGNED FK NOT NULL | |
| location_id | INT UNSIGNED FK NOT NULL | |
| client_id | INT UNSIGNED FK | |
| user_id | INT UNSIGNED FK | User che ha prenotato online |
| client_name | VARCHAR(255) | Fallback se no client |
| notes | TEXT | |
| status | ENUM('pending','confirmed','completed','cancelled','no_show') DEFAULT 'confirmed' | |
| source | ENUM('online','manual','import','onlinestaff') DEFAULT 'manual' | |
| idempotency_key | VARCHAR(64) | Per idempotenza POST |
| idempotency_expires_at | TIMESTAMP | TTL per cleanup |

UNIQUE (business_id, idempotency_key) ‚Äî scoped per tenant, evita collisioni globali
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

INDEX (business_id, location_id, created_at)
INDEX (client_id)
INDEX (user_id)

### 12. booking_items
Singoli appuntamenti/servizi dentro una booking (multi-servizio).

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| booking_id | INT UNSIGNED FK NOT NULL | |
| location_id | INT UNSIGNED FK NOT NULL | Denormalizzato per query availability |
| service_id | INT UNSIGNED FK NOT NULL | |
| service_variant_id | INT UNSIGNED FK NOT NULL | |
| staff_id | INT UNSIGNED FK NOT NULL | |
| start_time | TIMESTAMP NOT NULL | UTC |
| end_time | TIMESTAMP NOT NULL | UTC |
| price | DECIMAL(10,2) | Prezzo applicato |
| extra_blocked_minutes | INT UNSIGNED DEFAULT 0 | |
| extra_processing_minutes | INT UNSIGNED DEFAULT 0 | |
| service_name_snapshot | VARCHAR(255) | Denormalizzato |
| client_name_snapshot | VARCHAR(255) | Denormalizzato |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

INDEX (staff_id, start_time, end_time)
INDEX (location_id, start_time, end_time) ‚Äî per availability senza JOIN

### 13. resources (opzionale MVP+)
Risorse fisiche (es. cabine, attrezzature).

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| location_id | INT UNSIGNED FK NOT NULL | |
| name | VARCHAR(255) NOT NULL | |
| quantity | INT UNSIGNED DEFAULT 1 | |
| type | VARCHAR(100) | |
| note | TEXT | |
| is_active | TINYINT(1) DEFAULT 1 | |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |
| updated_at | TIMESTAMP ON UPDATE | |

---

## üîê Idempotenza per POST /bookings

### Strategia
1. Client genera un `Idempotency-Key` (UUID v4) e lo include nell'header
2. Server verifica se esiste gi√† una booking con quella key:
   - **Esiste**: ritorna la booking esistente (HTTP 200, non 201)
   - **Non esiste**: crea la booking e salva la key
3. Le key scadono dopo 24h (cleanup via cron o TTL index)

### Colonne dedicate in `bookings`
```sql
idempotency_key VARCHAR(64) UNIQUE,
idempotency_expires_at TIMESTAMP
```

### Alternativa: tabella separata
Se si preferisce non "sporcare" la tabella bookings:
```sql
CREATE TABLE idempotency_keys (
  key_hash VARCHAR(64) PRIMARY KEY,
  resource_type VARCHAR(50) NOT NULL,
  resource_id INT UNSIGNED NOT NULL,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Scelta MVP:** Colonne dedicate in `bookings` (pi√π semplice, meno join).

---

## üîê Password Reset Tokens

Tabella per gestire il flusso di password reset in modo sicuro.

### password_reset_tokens

| Colonna | Tipo | Note |
|---------|------|------|
| id | INT UNSIGNED PK AUTO_INCREMENT | |
| user_id | INT UNSIGNED NOT NULL | FK ‚Üí users.id |
| token_hash | VARCHAR(64) NOT NULL | SHA-256 del token inviato via email |
| expires_at | TIMESTAMP NOT NULL | Validit√† 1 ora dalla creazione |
| used_at | TIMESTAMP NULL | NULL = non ancora usato |
| created_at | TIMESTAMP DEFAULT CURRENT_TIMESTAMP | |

**Indici**:
```sql
INDEX idx_token_hash (token_hash)
INDEX idx_user_id (user_id)
INDEX idx_expires_at (expires_at)  -- Per cleanup automatico
```

**Foreign Keys**:
```sql
FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
```

**Security**:
- Token plain-text inviato via email, mai salvato nel DB
- Solo SHA-256 hash salvato per lookup
- Token monouso: `used_at IS NULL` per validit√†
- Scadenza 1 ora per ridurre finestra attacco
- Cleanup automatico via cron o TTL index

**Flusso**:
1. `POST /auth/forgot-password` ‚Üí genera token random (32 bytes), hash SHA-256, salva, invia email
2. User click link email ‚Üí `POST /auth/reset-password` con token plain-text
3. Server calcola SHA-256(token), cerca in DB con `used_at IS NULL AND expires_at > NOW()`
4. Se valido: update password, marca `used_at = NOW()`, invalida sessioni

**Migration**: Inclusa in `FULL_DATABASE_SCHEMA.sql`

---

## üïê Gestione fusi orari

- **DB**: Tutti i `TIMESTAMP` sono in **UTC**
- **API**: Tutti gli orari in **ISO8601** con timezone (`2025-01-15T10:00:00+01:00`)
- **Conversione**: Il server converte da/verso UTC usando `businesses.timezone`

---

## üìà Indici raccomandati

```sql
-- Query frequenti agenda
CREATE INDEX idx_booking_items_staff_time 
  ON booking_items(staff_id, start_time, end_time);

-- Disponibilit√†
CREATE INDEX idx_booking_items_location_time 
  ON booking_items(location_id, start_time, end_time);

-- Multi-tenant
CREATE INDEX idx_bookings_business_location 
  ON bookings(business_id, location_id);

-- Sessioni attive
CREATE INDEX idx_auth_sessions_user_expires 
  ON auth_sessions(user_id, expires_at, revoked_at);

-- Cleanup idempotency
CREATE INDEX idx_bookings_idempotency_expires 
  ON bookings(idempotency_expires_at);
```

---

## üîÑ Compatibilit√† con i client

### Frontend (BookingRequest ‚Üí bookings + booking_items)
```
service_ids ‚Üí booking_items.service_id (uno per ogni)
staff_id ‚Üí booking_items.staff_id (se null, assegnato dal server)
start_time ‚Üí booking_items.start_time (calcolato in sequenza)
notes ‚Üí bookings.notes
```

### Backend (Appointment ‚Üí booking_items)
La tabella `booking_items` corrisponde al modello `Appointment` del gestionale:
- `booking_id` = relazione con booking
- `service_id`, `service_variant_id`, `staff_id` = riferimenti
- `start_time`, `end_time` = slot temporale
- `extra_*_minutes` = tempi extra
- `*_snapshot` = valori denormalizzati per storico

----- FILE: docs/decisions.md -----

# Decisions ‚Äî agenda_core

- JWT access + refresh token (rotazione)
- Prenotazione pubblica, login solo in conferma
- snake_case
- ISO 8601
- UTC nel DB
- Idempotency-Key su POST /bookings

---

## Decisioni DB Schema MVP (2025-12-26)

### 1. Appointment vs booking_items
**Contesto**: Il backend usa il modello `Appointment` con molti campi, il frontend usa `BookingRequest` pi√π semplice.

**Decisione**: La tabella `booking_items` unifica entrambi i modelli:
- Corrisponde a `Appointment` del gestionale
- Supporta multi-servizio come richiesto da `BookingRequest.service_ids`
- Campi legacy `extra_minutes`/`extra_minutes_type` mappati su `extra_blocked_minutes`/`extra_processing_minutes`

### 2. Service vs ServiceVariant
**Contesto**: Il backend separa `Service` (metadati) da `ServiceVariant` (durata/prezzo per location). Il frontend ha tutto in `Service`.

**Decisione**: Mantenere la separazione del backend:
- `services`: nome, descrizione, categoria
- `service_variants`: durata, prezzo, bookable_online per location
- L'API pubblica pu√≤ "appiattire" i dati per il frontend se necessario

### 3. Client vs User
**Contesto**: `Client` √® l'anagrafica gestionale, `User` √® chi prenota online.

**Decisione (DEFINITIVA)**:
- `users`: account GLOBALI per autenticazione (email unica globale, NESSUN business_id)
- `clients`: anagrafica PER BUSINESS (ha business_id, user_id opzionale)
- Un user pu√≤ essere client di pi√π business tramite pi√π record `clients`
- Ogni business vede esclusivamente i propri clients

**ATTENZIONE Schema DB**: La tabella `clients` usa `is_archived` (non `is_active`):
```sql
-- CORRETTO:
WHERE is_archived = 0

-- SBAGLIATO:
WHERE is_active = 1  -- colonna non esiste!
```

**JWT**:
- Contiene SOLO `user_id`
- NON contiene `business_id`
- NON contiene `location_id`

**Derivazione contesto business**:
- `location_id` viene dal PATH: `/v1/locations/{location_id}/bookings`
- `business_id` viene da lookup DB: `SELECT business_id FROM locations WHERE id = :location_id`

**Flusso creazione booking autenticato**:
1. Leggi `location_id` dal PATH
2. Ricava `business_id` dal DB
3. Cerca record `clients` con `(business_id, user_id)`
4. Se non esiste, crealo automaticamente
5. Associa `client_id` alla booking

### 4. Idempotency implementation
**Contesto**: POST /bookings deve essere idempotente senza cambiare il payload client.

**Decisione**: Colonne dedicate in `bookings`:
- `idempotency_key`: UUID dall'header `Idempotency-Key`
- `idempotency_expires_at`: TTL 24 ore
- Pi√π semplice di tabella separata, cleanup via UPDATE (null) non DELETE

**UNIQUE constraint**: `(business_id, idempotency_key)`

Alternativa valutata: `(business_id, user_id, idempotency_key)`
- Scartata perch√© `user_id` pu√≤ essere NULL (prenotazioni manuali)
- MySQL: `NULL != NULL` ‚Üí UNIQUE non protegge i record con user_id NULL
- UUID v4 ha 122 bit casuali ‚Üí collisione tra utenti diversi praticamente impossibile

Regola: il client genera UUID v4 come Idempotency-Key, il server non lo modifica.

### 5. TimeBlock vs booking_items
**Contesto**: Il backend ha `TimeBlock` per blocchi multi-staff.

**Decisione**: Tabella separata `time_blocks` + `time_block_staff`:
- Non sono booking, sono blocchi di indisponibilit√†
- Relazione N:M con staff (un blocco pu√≤ coinvolgere pi√π operatori)
- Pi√π pulito di usare booking_items con flag speciale

### 6. Refresh token storage
**Contesto**: Sicurezza sessioni.

**Decisione**: 
- Mai salvare token in chiaro, solo SHA-256 hash
- Rotation: nuova sessione ad ogni refresh, vecchia revocata
- Riutilizzo token revocato ‚Üí revoca TUTTE le sessioni utente (possibile furto)
- `last_used_at` per tracking, `revoked_at` per revoca esplicita

### 7. Derivazione business_id/location_id
**Contesto**: Come garantire isolamento tenant.

**Decisione (DEFINITIVA)**:
- `location_id`: dal PATH parameter per booking (`/v1/locations/{location_id}/bookings`), query param per altri endpoint
- `business_id`: lookup DB da location_id (`SELECT business_id FROM locations WHERE id = ?`)
- MAI accettare questi ID dal payload client
- MAI inserire questi ID nel JWT
- Il server li ricava autonomamente per ogni request

**Endpoint booking**:
```
POST /v1/locations/{location_id}/bookings
```

**Endpoint public**:
```
GET /v1/services?location_id={location_id}
GET /v1/staff?location_id={location_id}
GET /v1/availability?location_id={location_id}
```

**Payload booking (INVARIABILE)**:
```json
{
  "service_ids": [int],
  "staff_id": int | null,
  "start_time": "ISO8601",
  "notes": "string | null"
}
```

### 8. Naming conventions
**Decisione**: Tutti i nomi colonna in snake_case per compatibilit√† con i modelli Flutter esistenti. I campi JSON dei client sono VINCOLANTI e non devono essere rinominati.

### 9. Timezone gestione (2025-12-26)
**Contesto**: Il calcolo degli slot disponibili necessita del timezone corretto della location.

**Decisione**: 
- Aggiungere colonna `timezone` (VARCHAR 50) a tabella `locations`
- Default value: 'Europe/Rome'
- ComputeAvailability use case legge timezone dalla location invece di hardcoded
- Format: nomi PHP DateTimeZone (es. 'Europe/Rome', 'America/New_York')

### 10. Restrizioni servizi per staff (2025-12-26)
**Contesto**: Non tutti gli staff possono erogare tutti i servizi.

**Decisione**: Tabella `staff_services` (N:M):
- Schema: `(staff_id, service_id)` PRIMARY KEY
- Logica: se tabella vuota ‚Üí staff pu√≤ fare tutto (permissivo di default)
- Se esistono record per uno staff ‚Üí validare che possa erogare TUTTI i servizi richiesti
- Foreign keys CASCADE su delete

### 11. Orari di apertura per location (2025-12-26)
**Contesto**: Ogni location ha orari di apertura diversi per giorno della settimana.

**Decisione**: Tabella `location_schedules`:
- Schema: `location_id`, `day_of_week` (0=Sunday, 6=Saturday), `open_time`, `close_time`, `is_closed`
- UNIQUE constraint su `(location_id, day_of_week)`
- CHECK constraints: `day_of_week BETWEEN 0 AND 6`, `open_time < close_time OR is_closed = 1`
- Fallback a orari default (9:00-18:00, Lun-Ven) se non configurato

### 12. API gestionali (2025-12-27)
**Contesto**: Il gestionale (agenda_backend) necessita di API dedicate per CRUD clients e appointments.

**Decisione**: Separazione tra API booking (pubbliche) e API gestionali:
- **Appointments endpoints** (`/v1/locations/{id}/appointments`):
  - GET con date filter per vista calendario
  - PATCH per reschedule (solo owner)
  - POST /cancel per cancellazione (solo owner)
  - Ritornano booking_items con dati joined (client, service, staff)
  
- **Clients endpoints** (`/v1/clients`):
  - GET con business_id filter + search
  - POST/PUT/DELETE con validazione business ownership
  - Soft delete via `is_archived = 1`

**Permission model**:
- Clients: visibili solo al business di appartenenza
- Appointments: modificabili solo da user che ha creato la booking

### 13. Webhook infrastructure (2025-12-27)
**Contesto**: Necessit√† di notificare sistemi esterni agli eventi della piattaforma.

**Decisione**: Infrastruttura webhook preparatoria:
- `webhook_endpoints`: registrazione endpoint per business + eventi sottoscritti
- `webhook_deliveries`: log tentativi con retry logic (max 3 tentativi, backoff esponenziale)
- Payload firmato con HMAC-SHA256 usando `secret` dell'endpoint
- Eventi standard: `booking.created`, `booking.updated`, `booking.cancelled`, `appointment.rescheduled`

**NON implementato ora**: dispatcher asincrono e integrazione nei flussi (milestone futura).

### 14. Mock elimination strategy (2025-01-15)
**Contesto**: I progetti frontend (agenda_backend e agenda_frontend) inizialmente usavano dati mock hardcoded per sviluppo rapido. Necessit√† di passare completamente a dati reali tramite API.

**Decisione architetturale**:
- **NO mock data** nei provider di produzione
- **Repository pattern**: Ogni feature ha un repository dedicato che chiama ApiClient
- **Async loading**: Provider usano FutureProvider o Notifier con async initialization per caricare dati all'avvio
- **Fallback graceful**: In caso di errore API, mostrare stato error/empty piuttosto che fallback a mock

**Implementazione business/locations**:
- Creato `BusinessRepository` (PHP) e `BusinessController` per endpoint `/v1/businesses`
- Creato `LocationsController` per endpoint `/v1/businesses/{id}/locations` e `/v1/locations/{id}`
- Esteso `ApiClient` (Dart) con metodi `getBusinesses()` e `getLocations(businessId)`
- Sostituiti provider mock con:
  - `businessRepository` ‚Üí chiama API per lista businesses
  - `locationsRepository` ‚Üí chiama API per locations per business
  - `currentBusinessProvider` ‚Üí FutureProvider che carica business selezionato
  - `currentLocationProvider` ‚Üí Notifier con `_loadLocations()` async

**Rationale**: Eliminare mock garantisce che lo sviluppo frontend scopra subito problemi di integrazione API, validazione dati, e performance. I mock rimangono solo nei test unitari dove appropriato.

### 15. Test strategy and TODO resolution (2025-01-15)
**Contesto**: TODO comments sparsi nei test indicavano test mancanti o stub da implementare.

**Decisione**:
- **Test completi nel backend PHP** (agenda_core): validation, business logic, edge cases
- **Test minimi nel frontend Flutter**: integration tests opzionali, stub per CRUD verificano solo compilazione
- **TODO ‚Üí Documentation**: Tutti i TODO nei test convertiti in commenti documentativi che spiegano la strategia

**Motivazione**: Evitare duplicazione test logica tra backend e frontend. Il frontend testa principalmente UI rendering, state management, e integrazione components. La logica di business √® testata exhaustivamente nel backend.

**Casi specifici risolti**:
- `updateClientForBooking()`: Documentato che API backend PATCH /appointments/{id} non supporta modifica client_id (booking property vs appointment property)
- Stub test CRUD: Documentati come placeholder per future integration tests opzionali
- Integration tests: Aggiunti commenti su come eseguirli manualmente contro backend reale

### 16. Provider loading patterns (2025-01-15)
**Contesto**: Riverpod offre FutureProvider e AsyncNotifier per loading asincrono, ma serve compatibilit√† con codice esistente.

**Decisione**:
- **FutureProvider**: Per liste read-only semplici (es. businesses list)
- **Notifier con async init**: Per state mutabile che richiede loading iniziale (es. locations con add/remove)
- **NO AsyncNotifier**: Evitare per compatibilit√† con logica sincrona esistente

**Pattern standard**:
```dart
// FutureProvider per read-only
@riverpod
Future<List<Business>> businesses(Ref ref) async {
  return ref.watch(businessRepositoryProvider).getAll();
}

// Notifier con async init per state mutabile
@riverpod
class Locations extends _$Locations {
  @override
  List<Location> build() => []; // Inizia vuoto
  
  Future<void> _loadLocations() async {
    final data = await repository.getAll();
    state = data;
  }
}
```

### 17. Multi-Business Path-Based URL (2025-12-29)
**Contesto**: SiteGround shared hosting non supporta wildcard DNS n√© subdomain dinamici. Serve routing multi-business.

**Problema**: `SubdomainResolver.getBusinessSlug()` usava `Uri.base.pathSegments` che √® **statico** al caricamento JavaScript. Quando go_router cambiava il path, `Uri.base` non si aggiornava ‚Üí loop infiniti o loading bloccato.

**Decisione**: Routing path-based con StateProvider dinamico:
- `routeSlugProvider` ‚Äî StateProvider aggiornato dal router nel redirect
- `currentBusinessProvider` ‚Äî Legge slug da `routeSlugProvider`, non pi√π da `SubdomainResolver`
- Router estrae `:slug` dal path e aggiorna provider via `Future.microtask()`

**Struttura URL**:
```
/                      ‚Üí Landing (no business)
/:slug                 ‚Üí Redirect a /:slug/booking  
/:slug/booking         ‚Üí Prenotazione
/:slug/login           ‚Üí Login
/:slug/register        ‚Üí Registrazione
/:slug/my-bookings     ‚Üí Le mie prenotazioni
/reset-password/:token ‚Üí Reset password (globale)
```

**Path riservati** (non sono slug): `reset-password`, `login`, `register`, `booking`, `my-bookings`, `change-password`, `privacy`, `terms`

**File modificati**:
- `lib/app/providers/route_slug_provider.dart` (NUOVO)
- `lib/app/router.dart` (REFACTORED)
- `lib/features/booking/providers/business_provider.dart` (usa routeSlugProvider)

**‚ö†Ô∏è ATTENZIONE**: NON usare `SubdomainResolver.getBusinessSlug()` per ottenere lo slug corrente. Usare sempre `ref.watch(routeSlugProvider)`.

---

## Regole di Dominio (2025-12-26)

### REGOLA DOMINIO 1 ‚Äî Conflict Detection

**Principio**: Il DB NON impedisce overlap temporali. La validazione √® a livello applicativo.

**Definizione conflitto**:
Un booking √® in conflitto se esiste un `booking_item` tale che:
- stesso `staff_id`
- stessa `location_id`
- `start_time < new_end_time`
- `end_time > new_start_time`
- `booking.status IN ('confirmed', 'pending')`

**Implementazione obbligatoria**:
```sql
BEGIN;

-- Lock pessimistico
SELECT id FROM booking_items
WHERE staff_id = @staff_id
  AND location_id = @location_id
  AND start_time < @new_end_time
  AND end_time > @new_start_time
  AND booking_id IN (
    SELECT id FROM bookings 
    WHERE status IN ('confirmed', 'pending')
  )
FOR UPDATE;

-- Se count > 0 ‚Üí ROLLBACK + HTTP 409 slot_conflict
-- Altrimenti:
INSERT INTO bookings (...) VALUES (...);
INSERT INTO booking_items (...) VALUES (...);

COMMIT;
```

---

### REGOLA DOMINIO 2 ‚Äî Service Variants Resolution

**Principio**: Il client invia solo `service_ids`, mai `service_variant_id`.

**Flusso**:
1. Client invia `POST /v1/locations/{location_id}/bookings` con `service_ids: [1, 2]`
2. Server estrae `location_id` dal PATH
3. Per ogni `service_id`, server esegue lookup:
   ```sql
   SELECT id, duration_minutes, price 
   FROM service_variants
   WHERE service_id = @service_id 
     AND location_id = @location_id
     AND is_bookable_online = 1
     AND is_active = 1;
   ```
4. Server calcola `end_time` da `start_time + duration_minutes`
5. Server inserisce `booking_items` con `service_variant_id` risolto

**Constraint**: `UNIQUE (service_id, location_id)` garantisce al massimo una variant per combinazione.

**Errori**:
| Situazione | HTTP | Codice errore |
|------------|------|---------------|
| Variant non esiste per location | 400 | `service_not_available_at_location` |
| `is_bookable_online = 0` | 400 | `service_not_bookable_online` |
| `is_active = 0` | 400 | `service_not_available` |

**Motivazione**: Il frontend espone un modello `Service` semplificato con durata/prezzo diretti. La complessit√† delle variant per location √® nascosta lato server.

---

## 17. Password Management Pattern (2025-12-27)

**Contesto**: Implementazione completa del flusso password reset e cambio password per utenti autenticati.

**Decisione**: Pattern a due fasi per password reset + endpoint dedicato per cambio password:

### Password Reset (utente non autenticato)
1. **Step 1 - Request Reset**: `POST /v1/auth/forgot-password`
   - Input: `email`
   - Output: Sempre 200 (anti email enumeration)
   - Backend: genera token (SHA-256 hash), salva in `password_reset_tokens`, invia email
   - Token validity: 1 ora

2. **Step 2 - Confirm Reset**: `POST /v1/auth/reset-password`
   - Input: `token` (da email), `password`
   - Validazione password: min 8 caratteri, maiuscola + minuscola + numero
   - Backend: verifica token non scaduto/usato, aggiorna password, invalida tutte le sessioni utente
   - Output: 200 success o 400 con error code (`invalid_reset_token`, `reset_token_expired`, `weak_password`)

### Change Password (utente autenticato)
**Endpoint**: `POST /v1/me/change-password` (richiede access token)
- Input: `current_password`, `new_password`
- Validazioni:
  - Current password corretta
  - New password != current password
  - New password rispetta policy (8 char, maiuscola, minuscola, numero)
- Output: 200 success o 400/401 error

**Frontend Implementation**:
- `/reset-password/:token` route per deep link da email
- `/change-password` route per utenti loggati
- Localizzazioni complete IT/EN
- Validazione real-time in UI

**Security**:
- Token SHA-256 hashed nel DB
- Token monouso (campo `used_at`)
- Scadenza 1 ora
- Password reset invalida tutte le sessioni (force re-login)
- Change password richiede autenticazione JWT

**Rationale**: Separare forgot/reset (pubblico, via email) da change (privato, richiede autenticazione) migliora security e UX.

---

## 18. Cancellation Policy & User Booking Management (2025-12-27)

**Contesto**: Gli utenti devono poter consultare e gestire i propri appuntamenti dal frontend pubblico. Appuntamenti passati: solo consultazione. Appuntamenti futuri: annullamento e modifica, con vincoli temporali.

**Decisione**: Implementare cancellation policy configurabile con granularit√† business/location + endpoint dedicato per gestione appuntamenti utente.

### Cancellation Policy Configuration

**Schema DB**:
```sql
-- businesses: policy di default per tutto il business
ALTER TABLE businesses ADD COLUMN cancellation_hours INT UNSIGNED NOT NULL DEFAULT 24;

-- locations: override opzionale per singola sede
ALTER TABLE locations ADD COLUMN cancellation_hours INT UNSIGNED NULL DEFAULT NULL;
```

**Logica**: 
- `cancellation_hours` = ore minime richieste prima dell'appuntamento per cancellare/modificare
- Valore di default: 24 ore
- Gerarchia: `location.cancellation_hours` ‚Üí `business.cancellation_hours` ‚Üí 24
- `cancellation_hours = 0` ‚Üí nessuna cancellazione permessa
- `cancellation_hours = NULL` su location ‚Üí usa policy del business

**Esempi**:
- Business con `cancellation_hours = 48`: utenti possono cancellare fino a 48h prima
- Location A con `cancellation_hours = 12`: override, solo 12h per questa sede
- Location B con `cancellation_hours = NULL`: usa il default del business (48h)

### User Booking Management API

**Endpoint**: `GET /v1/me/bookings` (richiede autenticazione)

**Response**:
```json
{
  "success": true,
  "data": {
    "upcoming": [
      {
        "id": 123,
        "status": "confirmed",
        "start_time": "2025-12-30T14:00:00+01:00",
        "end_time": "2025-12-30T15:30:00+01:00",
        "service_name": "Taglio + Piega",
        "staff_name": "Mario R.",
        "price": 45.00,
        "location": { "id": 1, "name": "Sede Centro", "address": "..." },
        "business": { "id": 1, "name": "Salone Bella Vita" },
        "can_modify": true,
        "can_modify_until": "2025-12-29T14:00:00+01:00",
        "notes": "Porta foto riferimento"
      }
    ],
    "past": [ ... ]
  }
}
```

**Campi chiave**:
- `can_modify`: `true` se ora corrente < `can_modify_until`
- `can_modify_until`: timestamp deadline calcolato da `start_time - cancellation_hours`
- Separazione `upcoming` (modificabili) vs `past` (solo consultazione)

### Validation in UpdateBooking / DeleteBooking

Entrambi i use case validano la policy prima di procedere:

```php
private function validateCancellationPolicy(array $booking): void {
    $startTime = new DateTimeImmutable($earliestStartFromItems);
    $now = new DateTimeImmutable();
    
    // Query policy con fallback
    $cancellationHours = $location->cancellation_hours 
        ?? $business->cancellation_hours 
        ?? 24;
    
    $deadline = $startTime->modify("-{$cancellationHours} hours");
    
    if ($now >= $deadline) {
        throw BookingException::validationError(
            "Cannot modify booking within {$cancellationHours} hours of start time"
        );
    }
}
```

**Errore HTTP 400**:
```json
{
  "success": false,
  "error": {
    "code": "validation_error",
    "message": "Cannot cancel booking within 24 hours of appointment start time",
    "details": {
      "cancellation_deadline": "2025-12-29T14:00:00+01:00"
    }
  }
}
```

### Frontend Implementation (agenda_frontend)

**Nuova feature**: `/my-bookings` route con:
- Lista appuntamenti futuri con badge "modificabile" basato su `can_modify`
- Lista appuntamenti passati (read-only)
- Bottoni "Annulla" e "Modifica" condizionali
- Dialog conferma cancellazione con spiegazione policy
- Form modifica che rispetta vincoli originali (staff, services, availability)

**UX**:
- Se `can_modify = false`: bottoni disabilitati + tooltip con `can_modify_until`
- Countdown visivo ore rimanenti per modifica
- Localizzazioni IT/EN complete

**Constraints su modifica**:
- Stessi vincoli della prenotazione originale (availability, staff_services, etc.)
- Non pu√≤ modificare se oltre deadline
- Reschedule = delete + create (transazionale)

### Rationale

**Business flexibility**: Ogni attivit√† ha esigenze diverse (parrucchiere 24h vs medico 48h vs massaggiatore 2h). Location override permette eccezioni (es: sede remota con policy pi√π rigida).

**User transparency**: Frontend mostra chiaramente deadline e motivazione, evitando frustrazione.

**Backend enforcement**: Policy validata server-side, impossibile bypassare da client.

**Default sensato**: 24h copre la maggioranza dei casi, evitando configurazione obbligatoria.

---

## Decision 19: Reschedule Prenotazione (2025-12-27)

### Contesto

Gli utenti devono poter riprogrammare le proprie prenotazioni future, scegliendo nuova data/ora mantenendo gli stessi servizi e operatore.

### Soluzione Implementata

**Backend**:
- Esteso `PUT /v1/locations/{location_id}/bookings/{id}` per accettare `start_time`
- Nuovo metodo `BookingRepository::rescheduleBooking()` che:
  - Calcola offset temporale tra vecchio e nuovo start_time
  - Aggiorna tutti i `booking_items` con nuovo orario mantenendo durate
  - Preserva intervalli relativi tra servizi multipli

**Frontend**:
- Dialog `RescheduleBookingDialog` con:
  - Date picker per nuova data
  - Availability check in tempo reale
  - Selezione slot disponibili
  - Campo note opzionale
- Integrazione con `myBookingsProvider.rescheduleBooking()`
- Validazione cancellation policy (stessa logica di cancellazione)

**API Endpoint**:
```http
PUT /v1/locations/{location_id}/bookings/{id}
Authorization: Bearer <token>

{
  "start_time": "2025-12-30T14:00:00+01:00",
  "notes": "Modifica appuntamento"
}
```

**Response (200)**:
```json
{
  "success": true,
  "data": {
    "id": 123,
    "items": [
      {
        "id": 456,
        "start_time": "2025-12-30T14:00:00+01:00",
        "end_time": "2025-12-30T15:00:00+01:00",
        ...
      }
    ],
    ...
  }
}
```

### Vincoli

1. **Cancellation Policy**: Stesso vincolo di cancellazione (default 24h)
2. **Availability Check**: ‚úÖ Verificato slot libero per staff nel nuovo orario (transazionale)
3. **Preservazione Servizi**: Non permette cambio servizi, solo data/ora
4. **Multi-Item**: Aggiorna tutti i `booking_items` mantenendo sequenza originale
5. **Transazionalit√†**: Operazione atomica con `FOR UPDATE` per evitare race conditions

### Rationale

**UX semplificata**: Dialog dedicato invece di flow prenotazione completo.

**Mantenimento contesto**: Stessi servizi/staff evitano complessit√† ricalcolo durata/prezzo.

**Consistency**: Stessa policy di cancellazione per prevedibilit√† utente.

**Performance**: Update diretto booking_items invece di delete + recreate.

**Race Condition Safety**: `checkConflicts()` usa `FOR UPDATE` dentro transazione.

### Implementazione Completata (2025-12-27)

‚úÖ **Backend**:
- `UpdateBooking::validateAvailabilityForReschedule()` verifica conflitti per ogni booking_item
- Transazione wrapping check + update per atomicit√†
- `BookingRepository::checkConflicts()` con `FOR UPDATE` e `excludeBookingId`
- Errore HTTP 409 con dettagli conflitti se slot occupato

‚úÖ **Frontend**:
- Dialog con availability check real-time
- Gestione errore 409 con messaggio utente

### TODO

- [ ] Test edge case: reschedule con servizi multipli sovrapposti
- [ ] Email notifica reschedule (richiede M10)

---

## Decision 20: Distinzione Reschedule Client vs Gestionale (2025-12-27)

### Contesto

L'applicazione ha due frontend diversi:
- **agenda_frontend** (cliente): utente finale prenota e gestisce i propri appuntamenti
- **agenda_backend** (gestionale): staff e admin gestiscono tutti gli appuntamenti

### Problema

Come gestire il reschedule (spostamento) di appuntamenti nei due contesti?

### Soluzione: Due Pattern Distinti

| App | Endpoint | Granularit√† | Motivo |
|-----|----------|-------------|--------|
| **agenda_frontend** | `PUT /v1/locations/{id}/bookings/{id}` | Intera prenotazione | Cliente vede la prenotazione come unit√† atomica |
| **agenda_backend** | `PATCH /v1/locations/{id}/appointments/{id}` | Singolo appuntamento | Staff ha flessibilit√† per riorganizzare i singoli slot |

### Esempi Pratici

**Scenario Cliente**:
Mario ha prenotato "Taglio + Piega" alle 14:00. Vuole spostare a domani.
‚Üí Usa `PUT /bookings/{id}` con `start_time` ‚Üí entrambi i servizi si spostano insieme.

**Scenario Staff**:
Anna deve spostare solo la "Piega" di Mario alle 16:00 perch√© lo slot era gi√† occupato.
‚Üí Usa `PATCH /appointments/{id}` ‚Üí sposta solo quel servizio, il "Taglio" resta.

### Implementazione

**Backend (agenda_core)**:
```php
// PUT /bookings/{id} - Reschedule intero booking
if (isset($data['start_time'])) {
    $this->validateAvailabilityForReschedule($booking, $newStartTime);
    $this->bookingRepo->rescheduleBooking($bookingId, $newStartTime);
}

// PATCH /appointments/{id} - Reschedule singolo appointment
$this->appointmentRepo->updateAppointment($appointmentId, $startTime, $endTime, $staffId);
```

**Frontend Cliente (agenda_frontend)**:
- `MyBookingsProvider.rescheduleBooking()` ‚Üí chiama PUT con `start_time`
- Dialog unico per scegliere nuova data/ora
- Tutti i servizi si spostano automaticamente

**Gestionale (agenda_backend)**:
- `AppointmentsProvider.moveAppointment()` ‚Üí chiama PATCH
- Drag & drop singolo appuntamento
- Flessibilit√† totale per staff

### Rationale

1. **UX appropriata per ruolo**:
   - Cliente: semplicit√†, non deve gestire dettagli operativi
   - Staff: controllo granulare per ottimizzare agenda

2. **Backwards compatibility**:
   - Gestionale gi√† usa PATCH /appointments (non cambia nulla)
   - PUT /bookings con start_time √® additive

3. **Conflict detection**:
   - Entrambi i flussi verificano availability
   - FOR UPDATE lock evita race conditions

4. **Coerenza dati**:
   - Client vede sempre booking come unit√†
   - Staff pu√≤ intervenire su singoli item se necessario

### Vincoli

- Il cliente **non** pu√≤ modificare singoli servizi (solo annullare o spostare tutto)
- Lo staff **pu√≤** modificare singoli servizi ma deve gestire manualmente la coerenza
- Reschedule cliente soggetto a cancellation policy
- Reschedule staff **non** soggetto a policy (pu√≤ sempre modificare)

---

## Decision 21: Sistema Permessi Operatori Gestionale (2025-12-28)

### Contesto
Il gestionale (agenda_backend) necessita di un sistema di autenticazione e autorizzazione per gli operatori. Attualmente:
- Gli utenti (`users`) sono globali e non hanno relazione diretta con i business
- I `clients` collegano utenti ai business, ma sono per chi prenota, non per chi gestisce
- Lo `staff` √® anagrafica dipendenti, senza credenziali di login

### Problema
Come assegnare un utente (che pu√≤ fare login) a uno o pi√π business con permessi specifici?

### Decisione
Creare tabella `business_users` che collega `users` a `businesses` con ruoli e permessi.

### Schema
```sql
CREATE TABLE business_users (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    business_id INT UNSIGNED NOT NULL,
    user_id INT UNSIGNED NOT NULL,
    role ENUM('owner', 'admin', 'manager', 'staff') DEFAULT 'staff',
    staff_id INT UNSIGNED NULL,  -- Link opzionale a record staff
    can_manage_bookings TINYINT(1) DEFAULT 1,
    can_manage_clients TINYINT(1) DEFAULT 1,
    can_manage_services TINYINT(1) DEFAULT 0,
    can_manage_staff TINYINT(1) DEFAULT 0,
    can_view_reports TINYINT(1) DEFAULT 0,
    is_active TINYINT(1) DEFAULT 1,
    invited_by INT UNSIGNED NULL,
    invited_at TIMESTAMP NULL,
    accepted_at TIMESTAMP NULL,
    UNIQUE (business_id, user_id)
);

-- Superadmin flag in users table
ALTER TABLE users ADD COLUMN is_superadmin TINYINT(1) DEFAULT 0;
```

### Modello Enterprise (Admin Platform)
Il sistema usa il modello **Enterprise** dove:
- **Superadmin** (globale) gestisce la piattaforma, non √® legato a business specifici
- **Owner** gestisce il proprio business e invita operatori
- Nessuna self-registration di business

### Superadmin: Ruolo Globale

Il superadmin **NON ha record in `business_users`**. √à un flag globale su `users.is_superadmin`.

**Comportamento:**
- Vede lista di TUTTI i business (con ricerca/filtri)
- Pu√≤ creare nuovi business
- Pu√≤ eliminare business
- Quando seleziona un business ‚Üí opera come **admin** (accesso completo)
- Non appare nella lista operatori del business

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              SUPERADMIN (users.is_superadmin = 1)       ‚îÇ
‚îÇ  Scope: GLOBALE (nessun record in business_users)       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  ‚Ä¢ GET /v1/admin/businesses ‚Üí Lista TUTTI i business    ‚îÇ
‚îÇ  ‚Ä¢ POST /v1/admin/businesses ‚Üí Crea business            ‚îÇ
‚îÇ  ‚Ä¢ DELETE /v1/admin/businesses/{id} ‚Üí Elimina           ‚îÇ
‚îÇ  ‚Ä¢ Seleziona business ‚Üí entra come admin                ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Gerarchia Ruoli (per business)

| Ruolo | Scope | Descrizione |
|-------|-------|-------------|
| **owner** | Business | Proprietario, controllo totale |
| **admin** | Business | Come owner, ma non pu√≤ eliminare business |
| **manager** | Business | Gestisce appuntamenti, clienti, orari |
| **staff** | Business | Solo propri appuntamenti |

### Chi Pu√≤ Assegnare Ruoli

| Assigner | Pu√≤ Creare |
|----------|------------|
| superadmin | owner (alla creazione business) |
| owner | owner, admin, manager, staff |
| admin | admin, manager, staff |
| manager | ‚ùå |
| staff | ‚ùå |

### API Endpoints

```
# Superadmin only (is_superadmin = true)
GET /v1/admin/businesses              ‚Üí Lista tutti i business (con search)
POST /v1/admin/businesses             ‚Üí Crea nuovo business + owner
DELETE /v1/admin/businesses/{id}      ‚Üí Elimina business
GET /v1/admin/businesses/{id}         ‚Üí Entra come admin

# Authenticated users (business_users)
GET /v1/me/businesses                 ‚Üí Lista business dove user ha accesso
GET /v1/me/businesses/{id}            ‚Üí Dettaglio business con ruolo/permessi

# Owner/Admin only
POST /v1/businesses/{id}/users        ‚Üí Invita nuovo operatore
PUT /v1/businesses/{id}/users/{id}    ‚Üí Modifica ruolo/permessi
DELETE /v1/businesses/{id}/users/{id} ‚Üí Rimuovi accesso
```

### Flusso Superadmin

```
1. POST /v1/auth/login ‚Üí JWT con user_id
2. Server verifica is_superadmin = true
3. GET /v1/admin/businesses?search=salone ‚Üí Lista filtrata
4. Click su business ‚Üí GET /v1/admin/businesses/{id}
5. Da qui opera come admin (bypass business_users check)
```

### Flusso Operatore Normale

```
1. POST /v1/auth/login ‚Üí JWT con user_id
2. GET /v1/me/businesses ‚Üí Lista da business_users
3. Seleziona business ‚Üí salva currentBusinessId
4. Middleware valida accesso tramite business_users
```

### Middleware Access Check

```php
// Pseudocode per validazione accesso
function checkBusinessAccess($userId, $businessId): string {
    // 1. Superadmin bypassa tutto
    if ($this->userRepo->isSuperadmin($userId)) {
        return 'admin'; // Opera come admin
    }
    
    // 2. Verifica business_users
    $businessUser = $this->businessUserRepo->find($userId, $businessId);
    if (!$businessUser || !$businessUser['is_active']) {
        throw AuthException::forbidden('No access to this business');
    }
    
    return $businessUser['role'];
}
```

### Link Staff-User (opzionale)
Campo `staff_id` permette di collegare un operatore al suo record staff:
- Utile per mostrare solo il proprio calendario
- Permette "login as staff" per operatori singoli
- Se NULL, l'operatore vede tutto il team

### Migration
Inclusa in: `migrations/FULL_DATABASE_SCHEMA.sql` (sezione BUSINESS USERS)

### Impatto Frontend (agenda_backend)
1. Creare `features/auth/` con login/logout
2. Modificare `businessesProvider` per usare `/v1/me/businesses`
3. Aggiungere route guard per redirect a login
4. Salvare `currentBusinessId` dopo selezione

### 21. Sistema inviti via email (2025-12-28)
**Contesto**: Gli operatori devono essere invitati tramite email invece di essere aggiunti direttamente.

**Decisione**: Tabella `business_invitations` separata:
- Token univoco 64 caratteri (hex)
- Scadenza 7 giorni default
- Status: `pending`, `accepted`, `expired`, `revoked`
- Constraint: un solo invito pending per (business_id, email)

**Flusso invito**:
1. Owner/Admin crea invito con email + ruolo desiderato
2. Sistema genera token, salva in `business_invitations`
3. Email inviata con link `https://app/invite/{token}`
4. Destinatario apre link, fa login o register
5. `POST /v1/invitations/{token}/accept` verifica email match e crea record `business_users`

**Gerarchia ruoli per inviti**:
- Owner pu√≤ invitare: admin, manager, staff
- Admin pu√≤ invitare: manager, staff
- Manager pu√≤ invitare: staff
- Staff non pu√≤ invitare

**Migration**: Inclusa in `FULL_DATABASE_SCHEMA.sql` (sezione BUSINESS INVITATIONS)

### 22. Frontend integration operators (2025-12-28)
**Contesto**: Il gestionale (agenda_backend) necessita di UI per gestire operatori.

**Decisione**: Struttura modulare nella feature `business/`:
- **Modelli** in `core/models/`: `BusinessUser`, `BusinessInvitation`
- **Repository** in `features/business/data/`: `BusinessUsersRepository`
- **Provider** in `features/business/providers/`: `businessUsersProvider(businessId)` con Riverpod 3.x
- **UI** in `features/business/presentation/`:
  - `OperatorsScreen` - lista operatori + inviti pendenti
  - `dialogs/InviteOperatorDialog` - dialog/sheet per invitare
  - `dialogs/RoleSelectionDialog` - dialog/sheet per cambiare ruolo

**Pattern responsive**:
- Desktop: `showDialog()` con `AppFormDialog`
- Mobile/Tablet: `AppBottomSheet.show()` con sheet dedicati

**Localizzazione**: Chiavi `operators*` in `intl_it.arb` e `intl_en.arb`

### 23. Testing strategy (2025-12-28)
**Contesto**: M8 richiede test minimi per validare logica di business.

**Decisione**: Test PHPUnit focalizzati su logica pura, senza mock di classi `final`.

**Struttura test suite**:
```
tests/
‚îú‚îÄ‚îÄ AuthTest.php           # JWT, password hashing base
‚îú‚îÄ‚îÄ AuthUseCaseTest.php    # Validazione auth, sessioni, email
‚îú‚îÄ‚îÄ BookingTest.php        # Slot overlap, date validation
‚îú‚îÄ‚îÄ BookingUseCaseTest.php # Conflict detection, idempotency, durata
‚îú‚îÄ‚îÄ AvailabilityTest.php   # Slot generation, working hours, timezone
‚îú‚îÄ‚îÄ ExceptionsTest.php     # Auth e Booking exceptions
‚îú‚îÄ‚îÄ IdempotencyTest.php    # UUID v4 validation
‚îú‚îÄ‚îÄ PasswordHasherTest.php # Bcrypt security
‚îú‚îÄ‚îÄ RequestTest.php        # HTTP request parsing
‚îú‚îÄ‚îÄ ResponseTest.php       # HTTP response formatting
‚îî‚îÄ‚îÄ RouterTest.php         # Routing e middleware
```

**Pattern adottati**:
- Classi repository sono `final` ‚Üí NO mock, test della logica pura
- Test di validazione indipendenti dal DB
- Test di calcolo (durata, slot, conflict) con dati in memoria
- Setup JWT_SECRET in `setUp()` / `tearDown()`

**Risultato**: 98 test, 195 asserzioni, 100% pass

**Comandi**:
```bash
# Eseguire tutti i test
./vendor/bin/phpunit --testdox

# Eseguire test specifici
./vendor/bin/phpunit --filter AuthUseCaseTest
```

---

## Vincoli e Divieti

### VIETATO
- Aggiungere `business_id` a `users`
- Inserire `business_id` o `location_id` nel JWT
- Richiedere `business_id` o `location_id` nel payload
- Rinominare colonne esistenti
- Modificare il payload booking
- Implementare booking prima dell'autenticazione
- Spostare logica di dominio nel frontend
- Permettere self-registration di business (modello Enterprise)

### OBBLIGATORIO
- `location_id` nel PATH per ogni request business-scoped
- `business_id` ricavato via lookup DB da `location_id`
- Query gestionali filtrate per `clients.business_id`
- Creazione automatica record `clients` al primo booking autenticato
- Validazione `business_users` per API gestionali (M11+)

---

## Ordine Implementazione

1. **M1 Auth**: login, refresh token con rotazione, me, logout
2. **M2 Public browse**: services, staff, availability
3. **M3 Booking**: POST /v1/locations/{location_id}/bookings (protetto)
4. **M4 Gestionale**: compatibilit√† con backend esistente
5. **M11 Permessi operatori**: business_users, auth gestionale

---

## M10 Notification System - Decisione Architetturale (2025-12-28)

### Contesto
Necessit√† di inviare notifiche email per il ciclo di vita delle prenotazioni (conferma, cancellazione, reminder) su hosting condiviso (SiteGround) con budget limitato.

### Decisione: Architettura Multi-Provider con Strategy Pattern

**Provider selezionabile via `.env`**:
```ini
MAIL_PROVIDER=brevo  # smtp | brevo | mailgun
```

**Motivazioni**:
1. **Vendor lock-in evitato**: Cambio provider con modifica singola variabile
2. **Fallback progression**: Brevo API ‚Üí Brevo SMTP ‚Üí errore
3. **Testing semplificato**: Provider sostituibile in test
4. **Costi ottimizzati**: Brevo free tier 300/giorno sufficiente per MVP

### Gerarchia Email Sender (priorit√†)

| Priorit√† | Fonte | Esempio |
|----------|-------|---------|
| **1¬∞ (alta)** | `locations.email` | `sede.roma@salonemario.it` |
| **2¬∞** | `businesses.email` | `info@salonemario.it` |
| **3¬∞ (fallback)** | `.env MAIL_FROM_*` | `noreply@romeolab.it` |

**Logica implementata**:
```php
$fromEmail = $variables['sender_email'] 
    ?? $variables['location_email'] 
    ?? $variables['business_email'] 
    ?? null;  // null = usa .env fallback
```

Questo permette:
- **Multi-sede**: ogni sede pu√≤ avere email dedicata
- **Multi-business**: ogni business pu√≤ avere email dedicata
- **Fallback sicuro**: se nessuna email configurata, usa quella del `.env`

### Alternativa considerata: Provider unico (SMTP)
**Scartata perch√©**:
- SiteGround SMTP ha limiti di invio (100/ora)
- Nessun tracking deliverability
- Nessun retry automatico

### Alternativa considerata: Invio sincrono
**Scartata perch√©**:
- Booking POST bloccato durante invio email
- Timeout se SMTP lento
- Nessun retry su errore temporaneo

### Implementazione scelta: Coda asincrona
- `notification_queue` con status, retry_count, scheduled_at
- Worker via cron (ogni minuto)
- Notifiche non bloccano flusso principale
- Retry automatico con backoff

### File implementati
```
src/Infrastructure/Notifications/
‚îú‚îÄ‚îÄ EmailProviderInterface.php
‚îú‚îÄ‚îÄ SmtpProvider.php
‚îú‚îÄ‚îÄ BrevoProvider.php
‚îú‚îÄ‚îÄ MailgunProvider.php
‚îú‚îÄ‚îÄ EmailService.php (factory)
‚îî‚îÄ‚îÄ EmailTemplateRenderer.php

src/Infrastructure/Notifications/
‚îî‚îÄ‚îÄ NotificationRepository.php

src/UseCases/Notifications/
‚îú‚îÄ‚îÄ QueueBookingConfirmation.php
‚îú‚îÄ‚îÄ QueueBookingCancellation.php
‚îî‚îÄ‚îÄ QueueBookingReminder.php

bin/
‚îú‚îÄ‚îÄ notification-worker.php
‚îú‚îÄ‚îÄ queue-reminders.php
‚îú‚îÄ‚îÄ run-worker.sh
‚îî‚îÄ‚îÄ run-reminders.sh

migrations/
‚îî‚îÄ‚îÄ FULL_DATABASE_SCHEMA.sql  # Include notification_queue, notification_templates, notification_settings
```

### Cron setup produzione
```bash
# Processa coda ogni minuto (usa wrapper per portabilit√† PHP path)
* * * * * /path/to/agenda_core/bin/run-worker.sh

# Accoda reminder ogni ora
0 * * * * /path/to/agenda_core/bin/run-reminders.sh
```

### Configurazione .env
```ini
MAIL_PROVIDER=brevo
BREVO_API_KEY=xkeysib-xxxxx
BREVO_SMTP_KEY=xsmtpsib-xxxxx
MAIL_FROM_ADDRESS=noreply@tuodominio.it
MAIL_FROM_NAME="Agenda"
```

### Frontend (agenda_backend)
- Campo email aggiunto al dialog modifica location
- Localizzazioni: `teamLocationEmailLabel`, `teamLocationEmailHint`

---

## 23. Superadmin Business Management (30/12/2025)

**Contesto**: Il superadmin deve poter gestire i business dalla piattaforma.

**Decisione**: Implementato flow completo:

### API Endpoints
- `GET /v1/admin/businesses` - Lista tutti i business (con search/pagination)
- `POST /v1/admin/businesses` - Crea business + owner (transazione atomica)
- `PUT /v1/admin/businesses/{id}` - Modifica business
- `DELETE /v1/admin/businesses/{id}` - Soft-delete business

### UseCase Pattern
```
src/UseCases/Business/
‚îú‚îÄ‚îÄ CreateBusiness.php     # Transazione: crea business + owner, rollback su errore
‚îú‚îÄ‚îÄ UpdateBusiness.php     # Aggiorna campi business (name, slug, email, phone, timezone, currency)
‚îú‚îÄ‚îÄ GetAllBusinesses.php   # Lista paginata con ricerca
‚îî‚îÄ‚îÄ GetUserBusinesses.php  # Lista business per utente normale
```

### Frontend (agenda_backend)
- `BusinessListScreen` per superadmin su `/businesses`
- Dialog creazione business con auto-generazione slug
- Dialog modifica business
- Pulsante "Cambia Business" nella navigation per tornare alla lista
- Redirect automatico: superadmin ‚Üí `/businesses`, utente normale ‚Üí `/agenda`

### Router Superadmin Flow
```
Login ‚Üí is_superadmin? 
  ‚îú‚îÄ YES ‚Üí /businesses (lista)
  ‚îÇ        ‚îú‚îÄ Crea nuovo business
  ‚îÇ        ‚îú‚îÄ Modifica business (icona edit)
  ‚îÇ        ‚îî‚îÄ Seleziona business ‚Üí /agenda
  ‚îÇ            ‚îî‚îÄ "Cambia" in navigation ‚Üí /businesses
  ‚îî‚îÄ NO  ‚Üí /agenda (normale)
```

### Provider Riverpod (NO StateProvider!)
```dart
// ‚ùå VIETATO - Deprecato in Riverpod 3.x
final myProvider = StateProvider<int>((ref) => 0);

// ‚úÖ OBBLIGATORIO - Usare Notifier
class SuperadminSelectedBusinessNotifier extends Notifier<int?> {
  @override
  int? build() => null;
  void select(int id) => state = id;
  void clear() => state = null;
}
final superadminSelectedBusinessProvider = NotifierProvider<...>(...)
```

### Modello Business aggiornato
Campi aggiunti: `slug`, `email`, `phone`, `timezone`

### File chiave
| Concetto | File |
|----------|------|
| UseCase Create | `src/UseCases/Business/CreateBusiness.php` |
| UseCase Update | `src/UseCases/Business/UpdateBusiness.php` |
| Controller | `src/Http/Controllers/AdminBusinessesController.php` |
| Lista Screen | `features/business/presentation/business_list_screen.dart` |
| Create Dialog | `features/business/presentation/dialogs/create_business_dialog.dart` |
| Edit Dialog | `features/business/presentation/dialogs/edit_business_dialog.dart` |

---

## 24. Multi-Location Support Frontend (30/12/2025)

**Contesto**: Un business pu√≤ avere pi√π sedi (locations). L'utente deve poter scegliere dove prenotare.

**Decisione**: Implementato step location nel booking flow.

### Comportamento
| Sedi | Flow di prenotazione |
|------|----------------------|
| 0    | "Attivit√† non attiva" (business senza sedi configurate) |
| 1    | Servizi ‚Üí Staff ‚Üí Data/Ora ‚Üí Riepilogo (skip location) |
| 2+   | **Sede** ‚Üí Servizi ‚Üí Staff ‚Üí Data/Ora ‚Üí Riepilogo |

### API Endpoint (pubblico, no auth)
```
GET /v1/businesses/{business_id}/locations/public
```

Response:
```json
{
  "success": true,
  "data": {
    "data": [
      {
        "id": 1,
        "business_id": 4,
        "name": "Sede Centrale",
        "address": "Via Roma 1",
        "city": "Milano",
        "phone": "+39 02 1234567",
        "timezone": "Europe/Rome",
        "is_default": true
      }
    ]
  }
}
```

### Frontend (agenda_frontend)

**Nuovo modello**:
```dart
// lib/core/models/location.dart
class Location {
  final int id;
  final int businessId;
  final String name;
  final String? address;
  final String? city;
  final String? phone;
  final String timezone;
  final bool isDefault;
  // ...
}
```

**Provider**:
```dart
// lib/features/booking/providers/locations_provider.dart
final locationsProvider = NotifierProvider<LocationsNotifier, AsyncValue<List<Location>>>(...);
final selectedLocationProvider = NotifierProvider<SelectedLocationNotifier, Location?>(...);
final hasMultipleLocationsProvider = Provider<bool>(...);
final effectiveLocationProvider = Provider<Location?>(...);
final effectiveLocationIdProvider = Provider<int>(...);
```

**Step**:
- `LocationStep` widget per selezione sede
- `BookingStepIndicator` con parametro `showLocationStep`

### Booking flow aggiornato
```dart
enum BookingStep { location, services, staff, dateTime, summary, confirmation }
```

Il `BookingFlowNotifier`:
- Determina step iniziale basato su `hasMultipleLocationsProvider`
- Salta automaticamente `BookingStep.location` se c'√® una sola sede
- Usa `effectiveLocationIdProvider` per determinare la location da usare

### File chiave
| Concetto | File |
|----------|------|
| Modello Location | `lib/core/models/location.dart` |
| Provider | `lib/features/booking/providers/locations_provider.dart` |
| Step UI | `lib/features/booking/presentation/screens/location_step.dart` |
| Controller PHP | `src/Http/Controllers/LocationsController.php` |
| Endpoint route | `src/Http/Kernel.php` (line ~97) |

### 22. Profilo utente (2025-12-31)
**Contesto**: Gli utenti devono poter modificare il proprio profilo (nome, cognome, email, telefono).

**Decisione**: Endpoint `PUT /v1/me` per aggiornare profilo utente autenticato:
- UseCase `UpdateProfile` in `src/UseCases/Auth/UpdateProfile.php`
- Validazione email unica (errore se gi√† esistente da altro utente)
- Campi aggiornabili: `first_name`, `last_name`, `email`, `phone`
- Frontend (entrambi): pagina `/profilo` o `/:slug/profile`

### 23. Admin email invece di user_id (2025-12-31)
**Contesto**: La creazione business richiedeva `owner_user_id` (utente gi√† esistente). Necessit√† di creare admin anche per email non registrate.

**Decisione**: Sostituire `owner_user_id` con `admin_email`:
- `CreateBusiness`: accetta `admin_email`, crea utente se non esiste
- Se utente nuovo: invia email benvenuto con link reset password (24h)
- Se utente esistente: associato come owner senza email
- Token reset in tabella `password_reset_tokens`

### 24. Trasferimento ownership business (2025-12-31)
**Contesto**: Quando si cambia `admin_email` in UpdateBusiness, la ownership deve essere trasferita.

**Decisione**: 
- `UpdateBusiness` rileva cambio admin_email
- Vecchio admin: ruolo da "owner" a "admin"
- Nuovo admin: creato se non esiste, ruolo "owner"
- Email benvenuto inviata al nuovo admin
- Metodo `BusinessUserRepository::transferOwnership()`

### 25. Reinvio invito admin (2025-12-31)
**Contesto**: Token reset scade dopo 24h. Se admin non ha impostato password in tempo, serve reinvio.

**Decisione**: Endpoint `POST /v1/admin/businesses/{id}/resend-invite`:
- UseCase `ResendAdminInvite`
- Genera nuovo token reset (24h)
- Invia stessa email benvenuto con nuovo link
- Solo superadmin pu√≤ invocare

### 26. Email benvenuto admin senza URL prenotazioni (2026-01-01)
**Contesto**: L'email di benvenuto admin includeva URL prenotazioni, ma il frontend booking non √® ancora pronto per tutti i business.

**Decisione**: Commentato temporaneamente nell'email `businessAdminWelcome`:
- Rimosso `üîó URL prenotazioni: {{booking_url}}`
- Rimosso `üìÖ Condividi questo link con i tuoi clienti...`
- HTML: Commentato con `<!-- TODO: Riattivare URL prenotazioni quando pronto -->`
- Text: Righe rimosse (non supporta commenti)
- Da riattivare quando il frontend booking sar√† configurato per il business

### 27. Login error message persistence (2026-01-01)
**Contesto**: Il messaggio di errore "Credenziali non valide" scompariva dopo pochi istanti.

**Analisi**: Il router usava `ref.watch(authProvider)` che triggherava rebuild ogni volta che lo stato cambiava (incluso `loading ‚Üí error`), ricreando `LoginScreen` e perdendo lo stato locale `_errorMessage`.

**Decisione**: 
- Creato provider derivato `_routerAuthStateProvider` che cambia SOLO quando `isAuthenticated` o `isSuperadmin` cambiano
- Lo stato `error` non causa pi√π rebuild del router
- LoginScreen gestisce errore in stato locale (`setState`) invece che dal provider globale
- File: `lib/app/router_provider.dart`

### 28. Logout loop infinito (2026-01-01)
**Contesto**: Chiamate infinite a `/v1/auth/logout` quando sessione scaduta.

**Analisi**: 
1. Sessione scaduta ‚Üí `sessionExpiredProvider` triggerato
2. `SessionExpiredListener` chiama `logout()`
3. `logout()` fa chiamata API senza token valido ‚Üí 401
4. 401 triggera di nuovo `sessionExpiredProvider` ‚Üí loop

**Decisione**: 
- Aggiunto parametro `silent` a `logout({bool silent = false})`
- `SessionExpiredListener` chiama `logout(silent: true)` ‚Üí nessuna chiamata API
- File: `lib/features/auth/providers/auth_provider.dart`

### 29. Categorie servizi hardcoded (2026-01-01)
**Contesto**: La sezione Servizi mostrava categorie anche con DB vuoto.

**Analisi**: `ServiceCategoriesNotifier` aveva dati seed hardcoded nel metodo `build()` invece di caricare dall'API.

**Decisione**: 
- Rimossi seed data da `ServiceCategoriesNotifier`
- L'API `GET /v1/services` ritorna gi√† `categories` nella risposta
- `ServicesApi.fetchServicesWithCategories()` estrae categorie dalla risposta
- `ServicesNotifier` popola `serviceCategoriesProvider` con categorie dall'API
- File: `lib/features/services/providers/service_categories_provider.dart`

### 30. User menu in navigation (2026-01-01)
**Contesto**: Menu utente (profilo, cambio password, logout) doveva essere accessibile dalla navigation bar.

**Decisione**: 
- Icona "Profilo" (index 4) nella navigation bar apre popup menu
- Menu contiene: header con nome/email, Cambia password, Cambia Business (solo superadmin), Esci
- Rimossa voce "Profilo" dal menu (non necessaria)
- Superadmin vede stesso menu sia in `/businesses` che dopo selezione business
- File: `lib/app/scaffold_with_navigation.dart`, `lib/app/widgets/user_menu_button.dart`

### 31. Aggiungi eccezione spostato nel menu shift (2026-01-01)
**Contesto**: Il bottone "+" per aggiungere eccezioni alla disponibilit√† occupava spazio nella griglia settimanale.

**Decisione**: 
- Rimosso il bottone "+" standalone dalla griglia
- Aggiunta voce "Aggiungi eccezione" nel menu che appare cliccando su un turno
- La funzionalit√† √® disponibile sia nel menu dei turni base che nel menu delle eccezioni esistenti
- Aggiornato `_countSegmentsForDay` per non contare +1 per il chip rimosso
- File: `lib/features/staff/presentation/staff_week_overview_screen.dart`

----- FILE: docs/milestones.md -----

# Milestones ‚Äî agenda_core

## Stato al 31/12/2025

| Milestone | Descrizione | Stato |
|-----------|-------------|-------|
| **M1** | Auth reale (login, refresh, logout, me) | ‚úÖ Completato |
| **M1.1** | Register + Password Reset | ‚úÖ Completato |
| **M1.2** | Booking Management (view, cancel, reschedule) | ‚úÖ Completato |
| **M2** | Public browse (services, staff, availability) | ‚úÖ Completato |
| **M3** | Booking conferma (POST /bookings + idempotency + conflict) | ‚úÖ Completato |
| **M3.1** | Update/Delete booking | ‚úÖ Completato |
| **M3.2** | Timezone, staff_services, location_schedules | ‚úÖ Completato |
| **M3.3** | API Gestionali (appointments, clients CRUD) | ‚úÖ Completato |
| **M4** | Frontend integration | ‚úÖ Completato |
| **M4.1** | Token web hardening (cookie httpOnly) | ‚úÖ Documentato |
| **M5** | Deploy produzione | ‚úÖ **LIVE** |
| **M6** | Webhook infrastructure | ‚úÖ Completato |
| **M7** | Compatibilit√† gestionale (agenda_backend) | ‚úÖ Completato |
| **M7.1** | Mock elimination | ‚úÖ Completato |
| **M8** | Test minimi | ‚úÖ Completato |
| **M9** | Multi-user sync (adaptive polling + SSE) | ‚¨ú Su richiesta |
| **M10** | Notification system (Email + Webhook lifecycle) | ‚úÖ Completato |
| **M11** | Permessi operatori gestionale (business_users) | ‚úÖ Completato |
| **M11.1** | Sistema inviti via email (business_invitations) | ‚úÖ Completato |
| **M12** | Email multilingua (IT/EN) | ‚¨ú Su richiesta |
| **F1** | Frontend responsive (form factor) | ‚¨ú Su richiesta |
| **F2** | Auto-logout su token scaduto | ‚úÖ Completato |
| **D1** | Deploy effettivo produzione SiteGround | ‚úÖ **LIVE** |
| **D2** | Multi-Business Path-Based URL | ‚úÖ **LIVE** |
| **D3** | Multi-Location Support Frontend | ‚úÖ **LIVE** |
| **D4** | Profilo Utente e Admin Email | ‚úÖ **LIVE** |
| **S1** | Audit Log (tracciamento accessi dati sensibili) | ‚¨ú Su richiesta |

---

## Audit Log - Tracciamento Accessi (S1) ‚¨ú Su richiesta

### Descrizione
Sistema di logging per tracciare tutte le operazioni sui dati sensibili (clienti, appuntamenti).
Utile per compliance GDPR, debug e rilevamento accessi anomali.

> ‚ö†Ô∏è **Nota**: Questa funzionalit√† verr√† implementata solo su specifica richiesta.
> La protezione attuale (autorizzazione API) √® gi√† sufficiente per la sicurezza base.

### Cosa traccia
| Campo | Descrizione |
|-------|-------------|
| `user_id` | Chi ha fatto l'operazione |
| `action` | VIEW, LIST, CREATE, UPDATE, DELETE |
| `resource_type` | client, appointment, booking, ecc. |
| `resource_id` | ID della risorsa |
| `business_id` | Business di appartenenza |
| `ip_address` | IP dell'utente |
| `created_at` | Timestamp operazione |

### Schema DB
```sql
CREATE TABLE audit_logs (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    user_id INT,
    action ENUM('VIEW', 'LIST', 'CREATE', 'UPDATE', 'DELETE', 'LOGIN', 'LOGOUT'),
    resource_type VARCHAR(50),
    resource_id INT NULL,
    business_id INT NULL,
    ip_address VARCHAR(45),
    user_agent TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_user (user_id),
    INDEX idx_resource (resource_type, resource_id),
    INDEX idx_business (business_id),
    INDEX idx_created (created_at)
);
```

### Risorse da loggare
- **Clients**: VIEW, LIST, CREATE, UPDATE, DELETE
- **Appointments**: VIEW, LIST, CREATE, UPDATE, CANCEL
- **Users**: LOGIN, LOGOUT, PASSWORD_CHANGE

### Query utili
```sql
-- Chi ha visto il cliente X?
SELECT * FROM audit_logs WHERE resource_type = 'client' AND resource_id = X;

-- Attivit√† di un utente
SELECT * FROM audit_logs WHERE user_id = Y ORDER BY created_at DESC;

-- Rilevamento accessi anomali (troppi LIST)
SELECT user_id, COUNT(*) as views FROM audit_logs 
WHERE action = 'LIST' GROUP BY user_id HAVING views > 100;
```

### Implementazione
1. Creare classe `AuditLogger` in `src/Infrastructure/Logging/`
2. Iniettare nei controller che gestiscono dati sensibili
3. Chiamare `$this->auditLog->log(...)` dopo ogni operazione

---

## Email Multilingua (M12) ‚¨ú Su richiesta

### Descrizione
Supporto multilingua per tutte le email di sistema (IT/EN inizialmente).

> ‚ö†Ô∏è **Nota**: Questa funzionalit√† verr√† implementata solo su specifica richiesta.
> Attualmente tutte le email sono in italiano (target principale Italia).

### Requisiti
- Lingua determinata dalla preferenza utente (`users.locale`) o business (`businesses.locale`)
- Fallback a IT se non specificata
- Template separati per lingua o sistema placeholder con dizionario

### Template da tradurre
- `businessAdminWelcome` ‚Äî Email benvenuto admin business
- `bookingConfirmed` ‚Äî Conferma prenotazione
- `bookingCancelled` ‚Äî Cancellazione prenotazione
- `bookingReminder` ‚Äî Reminder prenotazione
- `bookingRescheduled` ‚Äî Riprogrammazione prenotazione
- `passwordReset` ‚Äî Reset password

### Implementazione proposta
```php
// Opzione 1: Metodi separati per lingua
EmailTemplateRenderer::businessAdminWelcome('it')
EmailTemplateRenderer::businessAdminWelcome('en')

// Opzione 2: Dizionario + placeholder
EmailTemplateRenderer::render('businessAdminWelcome', $data, 'it')
```

### Modifiche DB (se necessario)
```sql
ALTER TABLE users ADD COLUMN locale VARCHAR(5) DEFAULT 'it';
ALTER TABLE businesses ADD COLUMN locale VARCHAR(5) DEFAULT 'it';
```

---

## Frontend Responsive - Form Factor (F1) ‚¨ú Su richiesta

### Descrizione
Implementare il supporto form factor (responsive breakpoints) nel frontend di prenotazione (agenda_frontend), analogamente a quanto gi√† implementato nel gestionale (agenda_backend).

> ‚ö†Ô∏è **Nota**: Questa funzionalit√† verr√† implementata solo su specifica richiesta.
> Attualmente il frontend funziona ma non ha layout ottimizzati per desktop/tablet/mobile.

### Stato attuale
- **agenda_backend (gestionale)**: ‚úÖ Form factor implementato
  - `AppFormFactor.mobile / .tablet / .desktop`
  - `formFactorProvider` per breakpoint responsive
  - Dialog su desktop, bottom sheet su mobile/tablet
- **agenda_frontend (prenotazione)**: ‚ùå Non implementato
  - Layout unico per tutti i dispositivi

### Implementazione richiesta
1. Copiare `form_factor_provider.dart` da agenda_backend
2. Aggiungere breakpoint responsive
3. Adattare UI per:
   - **Mobile**: Layout verticale, bottom sheet per dialogs
   - **Tablet**: Layout misto
   - **Desktop**: Layout orizzontale, dialog/popup

### File di riferimento (agenda_backend)
- `lib/app/providers/form_factor_provider.dart` ‚Äî Provider breakpoint
- `lib/core/widgets/app_bottom_sheet.dart` ‚Äî Bottom sheet wrapper

---

## Auto-logout su Token Scaduto (F2) ‚úÖ Completato 01/01/2026

### Descrizione
Quando il token JWT scade e il refresh fallisce, invece di mostrare "invalid or expired token", il sistema fa logout automatico e reindirizza alla pagina di login.

### Implementazione
1. **ApiClient**: Aggiunto callback `onSessionExpired` e metodo `_triggerSessionExpired()`
2. **SessionExpiredNotifier**: Provider che emette eventi quando la sessione scade
3. **SessionExpiredListener**: Widget che ascolta gli eventi e fa logout + redirect
4. Snackbar "Sessione scaduta. Effettua nuovamente il login."

### File modificati (agenda_backend)
- `lib/core/network/api_client.dart` ‚Äî Callback `onSessionExpired`, metodo `_triggerSessionExpired()`
- `lib/core/network/network_providers.dart` ‚Äî `SessionExpiredNotifier`, passa callback a ApiClient
- `lib/core/widgets/session_expired_listener.dart` ‚Äî **Nuovo**: Widget listener
- `lib/app/app.dart` ‚Äî Wrappa con `SessionExpiredListener`

### Comportamento
- Su qualsiasi 401 (token scaduto, token invalido, unauthorized)
- ApiClient chiama `_triggerSessionExpired()`
- `SessionExpiredNotifier` incrementa contatore
- `SessionExpiredListener` rileva cambio e:
  - Esegue `authProvider.logout()`
  - Mostra snackbar arancione
  - Redirect a `/login`

---

## Profilo Utente e Admin Email (D4) ‚úÖ LIVE 31/12/2025

### Funzionalit√† implementate

**1. Profilo utente (`PUT /v1/me`):**
- Gli utenti possono modificare nome, cognome, email, telefono
- Validazione email unica (errore se gi√† esistente)
- Pagina profilo in entrambi i frontend

**2. Admin email in CreateBusiness:**
- Nuovo campo `admin_email` invece di `owner_user_id`
- Se email non esiste, crea nuovo utente
- Invia email benvenuto con link reset password (24h)

**3. Trasferimento ownership in UpdateBusiness:**
- Rileva cambio `admin_email`
- Vecchio admin: ruolo da "owner" a "admin"
- Nuovo admin: creato se necessario, ruolo "owner"
- Email benvenuto al nuovo admin

**4. Reinvio invito (`POST /v1/admin/businesses/{id}/resend-invite`):**
- Genera nuovo token reset (24h)
- Invia email benvenuto
- Solo superadmin pu√≤ invocare

**5. Fix admin_email in GET businesses (01/01/2026):**
- `GetAllBusinesses` UseCase ora ritorna `admin_email` nella response
- Permette visualizzazione admin nel dialog di modifica business

**6. Email benvenuto senza URL prenotazioni (01/01/2026):**
- Template `businessAdminWelcome` temporaneamente senza URL prenotazioni
- URL e descrizione commentati (da riattivare quando frontend booking pronto)

### File modificati Backend (agenda_core)
- `src/UseCases/Auth/UpdateProfile.php` ‚Äî Nuovo UseCase
- `src/UseCases/Admin/UpdateBusiness.php` ‚Äî Gestione admin_email
- `src/UseCases/Admin/ResendAdminInvite.php` ‚Äî Nuovo UseCase
- `src/Http/Controllers/AuthController.php` ‚Äî `updateMe()` method
- `src/Http/Controllers/AdminBusinessesController.php` ‚Äî `resendInvite()` action
- `src/Infrastructure/Repository/BusinessRepository.php` ‚Äî `findByIdWithAdmin()`, `findAllWithSearch()` con admin_email
- `src/Http/Kernel.php` ‚Äî Route PUT /v1/me e POST resend-invite

### File modificati Frontend (agenda_backend)
- `lib/features/auth/presentation/profile_screen.dart` ‚Äî Nuova pagina profilo
- `lib/features/business/presentation/dialogs/edit_business_dialog.dart` ‚Äî Campo admin_email
- `lib/features/business/presentation/dialogs/create_business_dialog.dart` ‚Äî Campo admin_email
- `lib/features/business/presentation/business_list_screen.dart` ‚Äî Menu reinvia invito
- `lib/features/business/data/business_repository.dart` ‚Äî Metodo `resendAdminInvite()`
- `lib/app/router.dart` ‚Äî Route /profilo

### File modificati Frontend (agenda_frontend)
- `lib/features/auth/presentation/screens/profile_screen.dart` ‚Äî Nuova pagina profilo
- `lib/core/network/api_client.dart` ‚Äî Metodo `put()` e `updateProfile()`
- `lib/app/router.dart` ‚Äî Route /:slug/profile

---

## Multi-Location Support Frontend (D3) ‚úÖ LIVE 30/12/2025

### Funzionalit√†
Se un business ha pi√π sedi attive, l'utente pu√≤ scegliere dove prenotare.
Se il business ha una sola sede, lo step "Sede" viene saltato automaticamente.

### Implementazione Backend (agenda_core)

**Nuovo endpoint pubblico:**
```
GET /v1/businesses/{business_id}/locations/public
```

**Response:**
```json
{
  "data": [
    {
      "id": 1,
      "business_id": 1,
      "name": "Sede Centrale",
      "address": "Via Roma 1",
      "city": "Milano",
      "phone": "+39 02 1234567",
      "timezone": "Europe/Rome",
      "is_default": true
    }
  ]
}
```

**File modificati:**
- `src/Http/Kernel.php` - Aggiunta route pubblica
- `src/Http/Controllers/LocationsController.php` - Aggiunto `indexPublic()` method

### Implementazione Frontend (agenda_frontend)

**Nuovi file:**
- `lib/core/models/location.dart` - Modello Location
- `lib/features/booking/providers/locations_provider.dart` - Provider per locations
- `lib/features/booking/presentation/screens/location_step.dart` - UI step selezione sede

**Provider chiave:**
- `locationsProvider` ‚Äî Carica lista sedi dal backend
- `selectedLocationProvider` ‚Äî NotifierProvider per selezione utente
- `hasMultipleLocationsProvider` ‚Äî Bool, determina se mostrare step Sede
- `effectiveLocationProvider` ‚Äî Location effettiva (scelta o default)
- `effectiveLocationIdProvider` ‚Äî Int ID per chiamate API

**Booking flow modificato:**
```dart
enum BookingStep { location, services, staff, dateTime, summary }
// location step mostrato solo se hasMultipleLocations == true
```

### Note tecniche
- `LocationsController.indexPublic()` usa `$request->getAttribute('business_id')` (NON `getRouteParam()`)
- Le route pubbliche non hanno middleware auth, quindi `getRouteParam()` non funziona
- L'endpoint ritorna solo sedi con `is_active = 1`

---

## Multi-Business Path-Based (D2) ‚úÖ LIVE 29/12/2025

### Problema risolto
L'URL originale usava `SubdomainResolver.getBusinessSlug()` che leggeva `Uri.base.pathSegments` - 
valore **statico** al caricamento della pagina JavaScript. Quando go_router cambiava il path,
`Uri.base` non si aggiornava, causando loop infiniti o loading bloccato.

### Soluzione implementata
1. **Nuovo provider**: `routeSlugProvider` (StateProvider) aggiornato dinamicamente dal router
2. **Router refactored**: Estrae `:slug` dal path e aggiorna `routeSlugProvider` nel redirect
3. **business_provider.dart**: Ora legge slug da `routeSlugProvider` invece di `SubdomainResolver`

### Struttura URL
```
/                      ‚Üí Landing page (business non specificato)
/:slug                 ‚Üí Redirect a /:slug/booking
/:slug/booking         ‚Üí Schermata prenotazione
/:slug/login           ‚Üí Login
/:slug/register        ‚Üí Registrazione
/:slug/my-bookings     ‚Üí Le mie prenotazioni
/reset-password/:token ‚Üí Reset password (globale, no slug)
```

### Path riservati (non slug)
`reset-password`, `login`, `register`, `booking`, `my-bookings`, `change-password`, `privacy`, `terms`

### File modificati
- `lib/app/providers/route_slug_provider.dart` (NUOVO)
- `lib/app/router.dart` (REFACTORED)
- `lib/features/booking/providers/business_provider.dart` (MODIFIED)

### Test comportamento
| URL | Comportamento |
|-----|---------------|
| `https://prenota.romeolab.it/` | Landing: "Business non specificato" |
| `https://prenota.romeolab.it/salone-mario` | Redirect a `/salone-mario/booking` |
| `https://prenota.romeolab.it/salone-mario/booking` | Carica business da API |
| `https://prenota.romeolab.it/slug-inesistente` | API 404 ‚Üí mostra "Business non trovato" |

---

## Deploy Produzione (D1) ‚úÖ LIVE 28/12/2025

### URL Produzione
- **API**: https://api.romeolab.it
- **Frontend Prenotazioni**: https://prenota.romeolab.it
- **Gestionale**: https://gestionale.romeolab.it (da deployare)

### Infrastruttura SiteGround
- **Hosting**: SiteGround condiviso
- **PHP**: 8.2
- **MySQL**: MariaDB (pannello SiteGround)
- **SSH**: Porta 18765, chiave ed25519

### CORS Configurato
```
CORS_ALLOWED_ORIGINS=https://prenota.romeolab.it,https://gestionale.romeolab.it,http://localhost:8080
```

### Fix Implementati
1. **Loop infinito API** - Convertito `FutureProvider` a `StateNotifier` con flag `_hasFetched`
2. **CORS duplicate headers** - Rimosso da `.htaccess`, gestito solo in PHP
3. **Auth state rebuild** - Usato `ref.watch(authProvider.select(...))` per evitare rebuild

### Comandi Deploy
```bash
# API (agenda_core)
rsync -avz --delete --exclude='.env' --exclude='logs/' \
  agenda_core/ siteground:www/api.romeolab.it/

# Frontend (agenda_frontend)
flutter build web --release --dart-define=API_BASE_URL=https://api.romeolab.it
rsync -avz --delete build/web/ siteground:www/prenota.romeolab.it/public_html/
```

---

## Dettaglio

### M1 - Auth reale ‚úÖ
- `POST /v1/auth/login` - Ritorna access_token + refresh_token
- `POST /v1/auth/refresh` - Rotazione token, revoca su riuso
- `POST /v1/auth/logout` - Invalida sessione
- `GET /v1/me` - Profilo utente + client memberships

### M1.1 - Register + Password Management ‚úÖ
- `POST /v1/auth/register` - Registrazione nuovo utente con validazione password
- **Password Reset Flow**:
  - `POST /v1/auth/forgot-password` - Step 1: richiesta reset (email enumeration protected)
  - `POST /v1/auth/reset-password` - Step 2: conferma reset con token da email
  - Token validity: 1 ora, SHA-256 hashed, monouso
  - Reset invalida tutte le sessioni utente (force re-login)
- **Change Password**:
  - `POST /v1/me/change-password` - Cambio password per utente autenticato
  - Validazione: current password corretta, new password diversa, policy enforcement
- **Frontend (agenda_frontend)**:
  - `/reset-password/:token` - Screen per conferma reset con deep link da email
  - `/change-password` - Screen per cambio password (utenti loggati)
  - Localizzazioni complete IT/EN per tutti i flussi

### M2 - Public browse ‚úÖ
- `GET /v1/services?location_id=1` - 9 servizi raggruppati per categoria
- `GET /v1/staff?location_id=1` - 3 staff prenotabili online
- `GET /v1/availability?location_id=1&date=YYYY-MM-DD&service_ids=1,2` - ~105 slot/giorno

### M3 - Booking conferma ‚úÖ
- `POST /v1/locations/{id}/bookings` - Creazione booking
- Header `X-Idempotency-Key` - UUID v4 obbligatorio
- Conflict detection - HTTP 409 + `slot_conflict`
- Auto-create client da user
- Multi-service con durata sequenziale

### M3.1 - Update/Delete booking ‚úÖ
- `PUT /v1/locations/{id}/bookings/{id}` - Aggiorna status/notes
- `DELETE /v1/locations/{id}/bookings/{id}` - Cancella booking
- Validazione permessi: solo user che ha creato la booking pu√≤ modificare/cancellare
- Status validi: 'pending', 'confirmed', 'cancelled', 'completed', 'no_show'

### M3.2 - Infrastructure enhancements ‚úÖ
- **Timezone location**: Campo `timezone` in tabella `locations` (default 'Europe/Rome')
- **Staff services restrictions**: Tabella `staff_services` per definire quali servizi ogni staff pu√≤ erogare
- **L3.3 - API Gestionali ‚úÖ
- **Appointments API**: 
  - `GET /v1/locations/{id}/appointments?date=YYYY-MM-DD` - Lista appuntamenti con join
  - `PATCH /v1/locations/{id}/appointments/{id}` - Reschedule
  - `POST /v1/locations/{id}/appointments/{id}/cancel` - Cancellazione
- **Clients API**:
  - `GET /v1/clients?business_id=X&search=term` - Lista con search
  - `POST /v1/clients` - Creazione
  - `PUT /v1/clients/{id}` - Aggiornamento
  - `DELETE /v1/clients/{id}` - Soft delete (is_archived)
- Permission model: solo owner pu√≤ modificare appointments/bookings

### M4 - Frontend integration ‚úÖ
- Network layer: `ApiClient` con Dio + auto token refresh
- Token storage: `flutter_secure_storage` (mobile) / memory (web MVP)
- Auth flow: login, logout, session restore
- Booking flow: services, staff, availability, confirm booking
- Tutti i mock rimossi da agenda_frontend

### M4.1 - Token web hardening ‚úÖ
- **Documentazione completa**: TOKEN_STORAGE_WEB.md
- Access token in memoria (cancellato a reload)
- Refresh token in httpOnly cookie (immune XSS)
- Cookie secure, sameSite=Strict
- Refresh automatico su reload app
- Auto-refresh interceptor per 401
- CORS configurato con credentials

### M5 - Deploy produzione ‚úÖ
- **Documentazione completa**: DEPLOY.md
- Nginx config con SSL e security headers
- PHP-FPM tuning
- Database setup con utente dedicato
- Environment config (.env.example)
- Backup script
- Monitoring e health check
- Let's Encrypt integration

### M6 - Webhook infrastructure ‚úÖ
- Migration 0008: `webhook_endpoints` + `webhook_deliveries`
- Schema eventi standard (booking.*, client.*, appointment.*)
- Retry logic preparato (attempt_count, next_retry_at)
- Payload firmabile con HMAC-SHA256
- NON attivo nei flussi (milestone futura)

### M7 - Compatibilit√† gestionale (agenda_backend) ‚úÖ
- **Business/Locations API**:
  - `GET /v1/businesses` - Lista businesses
  - `GET /v1/businesses/{id}` - Dettaglio business
  - `GET /v1/businesses/{id}/locations` - Locations per business
  - `GET /v1/locations/{id}` - Dettaglio location
- **Integration agenda_backend**:
  - ApiClient esteso con `getBusinesses()` e `getLocations()`
  - BusinessRepository e LocationsRepository creati
  - Provider refactored per usare API reali
  - Tutti i TODO risolti e documentati

### M7.1 - Mock elimination ‚úÖ
- **Eliminazione completa mock data**:
  - business_providers.dart: da Provider mock a FutureProvider con API
  - location_providers.dart: da Notifier con mock a Notifier con async API loading
  - appointment_providers.dart: TODO rimossi, aggiunti commenti su limitazioni API
  - Test files: 12 TODO convertiti in documentazione strategia test
- **Pattern adottati**:
  - Repository pattern per tutte le feature
  - FutureProvider per dati read-only
  - Notifier con async init per state mutabile
  - Nessun fallback a mock in produzione

### M8 - Test minimi ‚úÖ
- **Test suite completa**: 98 test, 195 asserzioni
- **AuthUseCaseTest**: Password hashing, validazione email, JWT, refresh token, sessioni
- **BookingUseCaseTest**: Validazione booking, calcolo durata, conflict detection, idempotency
- **AvailabilityTest**: Slot generation, working hours, multi-staff, timezone, buffer time
- **BookingTest**: Slot overlap, validazione date, working hours logic
- **ExceptionsTest**: Auth e Booking exceptions
- **IdempotencyTest**: UUID v4 validation
- **RequestTest/ResponseTest**: HTTP layer
- **RouterTest**: Routing e middleware
- **File test creati**:
  - `tests/AuthUseCaseTest.php` - 18 test auth logic
  - `tests/BookingUseCaseTest.php` - 18 test booking logic
  - `tests/AvailabilityTest.php` - 16 test availability computation

### M11 - Permessi operatori gestionale ‚úÖ
- **Modello Enterprise**: Superadmin globale crea businesses, non self-registration
- **Migration 0013**: Tabella `business_users` con ruoli e permessi
- **Gerarchia ruoli**: owner > admin > manager > staff
- **API Backend (agenda_core)**:
  - `GET /v1/admin/businesses` - Lista businesses (superadmin only)
  - `POST /v1/admin/businesses` - Crea business (superadmin only)
  - `GET /v1/businesses/{id}/users` - Lista operatori
  - `POST /v1/businesses/{id}/users` - Aggiungi operatore esistente
  - `PATCH /v1/businesses/{id}/users/{user_id}` - Modifica ruolo
  - `DELETE /v1/businesses/{id}/users/{user_id}` - Rimuovi operatore
- **File implementati**:
  - `BusinessUserRepository.php` - CRUD operatori con soft delete/reinvite
  - `BusinessUsersController.php` - API endpoints
  - `AdminBusinessesController.php` - API superadmin

### M11.1 - Sistema inviti via email ‚úÖ
- **Migration 0014**: Tabella `business_invitations` con token 64 caratteri
- **Flusso invito**:
  1. Owner/Admin crea invito con email + ruolo
  2. Genera token univoco, scadenza 7 giorni
  3. Utente riceve link, fa login/register
  4. `POST /v1/invitations/{token}/accept` associa utente a business
- **API Backend (agenda_core)**:
  - `GET /v1/businesses/{id}/invitations` - Lista inviti pendenti
  - `POST /v1/businesses/{id}/invitations` - Crea invito
  - `DELETE /v1/businesses/{id}/invitations/{id}` - Revoca invito
  - `GET /v1/invitations/{token}` - Dettagli invito (pubblico)
  - `POST /v1/invitations/{token}/accept` - Accetta invito (auth)
- **Frontend (agenda_backend)**:
  - Modelli: `BusinessUser`, `BusinessInvitation`
  - Repository: `BusinessUsersRepository`
  - Provider: `businessUsersProvider(businessId)` Riverpod 3.x
  - UI: `OperatorsScreen`, `InviteOperatorDialog`, `RoleSelectionDialog`
  - Localizzazioni: chiavi `operators*` in IT/EN

### M9 - Multi-user sync (adaptive polling + SSE) ‚¨ú Su richiesta

**Contesto**: Supportare centinaia di operatori simultanei con sessioni brevi (2-5 min) per gestione appuntamenti, mantenendo sincronizzazione dati senza overhead eccessivo su hosting condiviso.

**Pattern d'uso identificato**:
- Alta frequenza: appointments (modifiche continue + booking online random)
- Bassa frequenza: services, staff, locations (modifiche rare, 1-2 volte/mese)
- Mix business: da singolo staff (no conflitti) a team 10+ persone
- Sessioni brevi: 2-5 minuti medi, non collaborazione real-time lunga

**Requisiti**:
- ‚úÖ Supportare 300-500 operatori su hosting condiviso
- ‚úÖ Latency booking online < 2 secondi
- ‚úÖ Carico server < 10 req/sec medio
- ‚úÖ Adaptive: intervalli polling basati su staff count
- ‚úÖ Zero overhead per business singolo operatore

---

#### Sprint 1: Adaptive Polling Foundation

**Backend (agenda_core)**:
Nessuna modifica richiesta, API esistenti sufficienti.

**Frontend (agenda_backend)**:

1. **PollingConfigProvider** [NUOVO]
   ```dart
   // lib/core/providers/polling_config_provider.dart
   @riverpod
   PollingConfig pollingConfig(Ref ref) {
     final business = ref.watch(currentBusinessProvider);
     final staffCount = ref.watch(staffProvider).length;
     
     return PollingConfig(
       appointments: _getAppointmentsInterval(staffCount),
       // Services/Staff/Locations: NO polling (load on demand)
     );
   }
   
   Duration _getAppointmentsInterval(int staffCount) {
     if (staffCount == 1) return Duration(seconds: 120);  // No conflitti
     if (staffCount <= 5) return Duration(seconds: 60);   // Team piccolo
     return Duration(seconds: 30);                         // Team grande
   }
   ```

2. **AppointmentsNotifier con Polling** [MODIFICARE]
   ```dart
   // lib/features/agenda/providers/appointment_providers.dart
   class AppointmentsNotifier extends AsyncNotifier<List<Appointment>> {
     Timer? _pollTimer;
     
     @override
     Future<List<Appointment>> build() async {
       final data = await _fetchAppointments();
       _startAdaptivePolling();
       ref.onDispose(() => _pollTimer?.cancel());
       return data;
     }
     
     void _startAdaptivePolling() {
       final config = ref.read(pollingConfigProvider);
       final interval = config.appointments;
       
       _pollTimer = Timer.periodic(interval, (_) async {
         // Protezione: skip se drag/resize attivo
         if (_isUserInteracting()) return;
         
         await _refreshSilently();
       });
     }
     
     bool _isUserInteracting() {
       final isDragging = ref.read(dragSessionProvider) != null;
       final isResizing = ref.read(isResizingProvider);
       return isDragging || isResizing;
     }
     
     Future<void> _refreshSilently() async {
       try {
         final newData = await _fetchAppointments();
         state = AsyncData(newData);
       } catch (e) {
         // Log error, non mostrare all'utente
       }
     }
   }
   ```

3. **Services/Staff/Locations: Load on Demand** [CONFERMARE]
   - NO polling automatico
   - Refresh solo dopo CREATE/UPDATE/DELETE
   - Pull-to-refresh manuale disponibile

**Testing**:
- Simulare 2-3 browser contemporanei
- Verificare adaptive intervals (1, 3, 10 staff)
- Testare protezione drag & drop (no refresh durante drag)
- Load test: 50 operatori simulati

**Deliverable**:
- Appointments sincronizzati tra operatori
- Carico server: 5-7 req/sec con 250 operatori
- Funziona su SiteGround shared hosting

**Metriche successo**:
- Conflitti appuntamenti: < 1/settimana (target)
- CPU server medio: < 8%
- Latency API P95: < 150ms

---

#### Sprint 2: SSE Real-Time per Booking Online

**Obiettivo**: Notificare operatori in < 2 secondi quando arriva booking online.

**Backend (agenda_core)**:

1. **EventStream Controller** [NUOVO]
   ```php
   // src/Http/Controllers/EventStreamController.php
   class EventStreamController {
     public function stream(Request $request): Response {
       $locationId = $request->query('location_id');
       
       // Validazione auth
       $this->requireAuth($request);
       
       // Setup SSE headers
       header('Content-Type: text/event-stream');
       header('Cache-Control: no-cache');
       header('Connection: keep-alive');
       
       // Keep-alive heartbeat
       while (true) {
         echo "event: heartbeat\n";
         echo "data: {\"timestamp\": \"" . date('c') . "\"}\n\n";
         flush();
         
         // Check for events ogni 5s
         $events = $this->eventStore->getPendingEvents($locationId);
         foreach ($events as $event) {
           echo "event: {$event->type}\n";
           echo "data: " . json_encode($event->data) . "\n\n";
           flush();
           $this->eventStore->markAsSent($event->id);
         }
         
         sleep(5);
       }
     }
   }
   ```

2. **EventStore Redis/MySQL** [NUOVO]
   ```sql
   CREATE TABLE event_stream (
     id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
     location_id INT UNSIGNED NOT NULL,
     event_type VARCHAR(100) NOT NULL,
     payload JSON NOT NULL,
     created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
     sent_at TIMESTAMP NULL,
     INDEX idx_location_pending (location_id, sent_at)
   );
   ```

3. **Dispatch in CreateBooking** [MODIFICARE]
   ```php
   // src/UseCases/CreateBooking.php
   public function execute(CreateBookingRequest $request): Booking {
     $booking = $this->repository->create($request);
     
     // Nuovo: Dispatch SSE event
     $this->eventStore->push([
       'location_id' => $booking->location_id,
       'event_type' => 'booking.created',
       'payload' => [
         'booking_id' => $booking->id,
         'start_time' => $booking->start_time,
         'client_name' => $booking->client->full_name,
       ],
     ]);
     
     return $booking;
   }
   ```

**Frontend (agenda_backend)**:

1. **EventSource Service** [NUOVO]
   ```dart
   // lib/core/services/event_stream_service.dart
   class EventStreamService {
     EventSource? _eventSource;
     final StreamController<ServerEvent> _controller = StreamController.broadcast();
     
     Stream<ServerEvent> listen(int locationId, String accessToken) {
       _eventSource?.close();
       
       _eventSource = EventSource(
         '${ApiConfig.baseUrl}/events?location_id=$locationId',
         headers: {'Authorization': 'Bearer $accessToken'},
       );
       
       _eventSource!.addEventListener('booking.created', (event) {
         _controller.add(BookingCreatedEvent.fromJson(event.data));
       });
       
       return _controller.stream;
     }
     
     void dispose() {
       _eventSource?.close();
       _controller.close();
     }
   }
   ```

2. **AppointmentsNotifier Integration** [MODIFICARE]
   ```dart
   @override
   Future<List<Appointment>> build() async {
     final data = await _fetchAppointments();
     _startAdaptivePolling();
     _listenToSSE(); // NUOVO
     return data;
   }
   
   void _listenToSSE() {
     final locationId = ref.read(currentLocationProvider).id;
     
     ref.listen(eventStreamProvider(locationId), (prev, next) {
       if (next case AsyncData(value: final event)) {
         if (event is BookingCreatedEvent) {
           // Refresh immediato + notifica
           _refreshSilently();
           _showNotification('Nuova prenotazione online ricevuta!');
         }
       }
     });
   }
   ```

**Testing**:
- Simulare booking online da agenda_frontend
- Verificare notifica < 2s in agenda_backend
- Testare reconnection su disconnect
- Load test: 100 connessioni SSE simultanee

**Deliverable**:
- Latency booking online ‚Üí notifica: < 2 secondi
- Overhead SSE: < 1% CPU (heartbeat leggero)
- Funziona con 300+ operatori

**Metriche successo**:
- Latency P95 notifica: < 2s
- Connessioni SSE concorrenti: 300+ senza problemi
- Reconnection automatica su network issues

---

#### Sprint 3: UX Polish & Manual Refresh

**Obiettivo**: Dare controllo all'utente su sincronizzazione + indicatori stato.

1. **Pull-to-Refresh** [AGGIUNGERE]
   ```dart
   // Tutte le schermate lista (agenda, clients, services, staff)
   RefreshIndicator(
     onRefresh: () => ref.refresh(dataProvider.future),
     child: ListView(...),
   )
   ```

2. **Refresh Button in AppBar** [AGGIUNGERE]
   ```dart
   AppBar(
     actions: [
       IconButton(
         icon: Icon(Icons.refresh),
         onPressed: () => ref.invalidate(appointmentsProvider),
       ),
     ],
   )
   ```

3. **Timestamp Ultimo Aggiornamento** [NUOVO]
   ```dart
   class LastUpdateIndicator extends ConsumerWidget {
     @override
     Widget build(BuildContext context, WidgetRef ref) {
       final lastUpdate = ref.watch(lastAppointmentUpdateProvider);
       return Text(
         'Aggiornato ${_formatTimeAgo(lastUpdate)}',
         style: Theme.of(context).textTheme.bodySmall,
       );
     }
   }
   ```

4. **Sync Status Badge** [NUOVO - opzionale]
   ```dart
   // AppBar indicator
   class SyncStatusBadge extends ConsumerWidget {
     @override
     Widget build(BuildContext context, WidgetRef ref) {
       final isSyncing = ref.watch(isSyncingProvider);
       final hasError = ref.watch(syncErrorProvider) != null;
       
       return Icon(
         hasError ? Icons.sync_problem : 
         isSyncing ? Icons.sync : Icons.check_circle,
         color: hasError ? Colors.red : 
                isSyncing ? Colors.orange : Colors.green,
         size: 16,
       );
     }
   }
   ```

5. **Settings: Disable Auto-Sync** [NUOVO - opzionale]
   ```dart
   // lib/features/settings/presentation/sync_settings_screen.dart
   SwitchListTile(
     title: Text('Sincronizzazione automatica'),
     subtitle: Text('Aggiorna appuntamenti in background'),
     value: ref.watch(autoSyncEnabledProvider),
     onChanged: (value) {
       ref.read(autoSyncEnabledProvider.notifier).state = value;
       if (!value) {
         // Stop polling
         ref.read(appointmentsProvider.notifier).stopPolling();
       }
     },
   )
   ```

**Testing**:
- UX flow: pull-to-refresh su tutte le schermate
- Indicatori timestamp corretti
- Settings disabilita/abilita sync

**Deliverable**:
- UI polish completo
- Controllo utente su sync
- Trasparenza stato sincronizzazione

---

#### Architettura Finale

**Data Sync Strategy**:
| Tipo Data | Strategia | Intervallo | Trigger |
|-----------|-----------|------------|---------|
| Appointments | Adaptive Polling | 30-120s | Auto + SSE + Manual |
| Services | Load on Demand | - | Manual refresh |
| Staff | Load on Demand | - | Manual refresh |
| Locations | Load on Demand | - | Manual refresh |
| Booking Online | SSE Push | Real-time | Server event |

**Adaptive Intervals Logic**:
- 1 staff ‚Üí 120s (no conflitti possibili)
- 2-5 staff ‚Üí 60s (team piccolo)
- 6+ staff ‚Üí 30s (team grande)
- Pause polling durante drag/resize attivo

**Performance Target**:
- Request/sec medio: 5-7 (250 operatori)
- Request/sec picco: 20-25 (100 operatori login simultaneo)
- CPU server: < 10% su shared hosting
- Supporto: 300-500 operatori su SiteGround shared (‚Ç¨10/mese)

---

#### Costi & Timeline

**Sviluppo**:
- Sprint 1 (Adaptive Polling): 2 giorni √ó ‚Ç¨400 = ‚Ç¨800
- Sprint 2 (SSE): 3 giorni √ó ‚Ç¨400 = ‚Ç¨1,200
- Sprint 3 (UX Polish): 1 giorno √ó ‚Ç¨400 = ‚Ç¨400
- **Totale one-time**: ‚Ç¨2,400

**Operativi** (annuale, 250 operatori):
- Hosting: ‚Ç¨120/anno (shared sufficiente)
- Bandwidth: trascurabile (< 1 GB/giorno)
---

#### Decision Point: Quando Implementare

**Implementa Sprint 1 se**:
- ‚úÖ Pi√π di 5 business con 3+ staff
- ‚úÖ Frequenti modifiche appuntamenti (20+/giorno per business)
- ‚úÖ Segnalazioni conflitti da operatori (2+/settimana)

**Implementa Sprint 2 se**:
- ‚úÖ Sprint 1 implementato e funzionante
- ‚úÖ Booking online attivo e usato frequentemente (10+/giorno)
- ‚úÖ Latency notifica > 1 minuto non accettabile

**Implementa Sprint 3 se**:
- ‚úÖ Sprint 1 e/o 2 implementati
- ‚úÖ Feedback utenti su trasparenza sync
- ‚úÖ Richiesta controllo manuale polling

**NON implementare se**:
- ‚ùå Tutti business con singolo staff
- ‚ùå Modifiche rare (< 5/giorno)
- ‚ùå Nessuna segnalazione conflitti

---

#### Metriche di Successo

**KPI Post-Implementazione**:
| Metrica | Baseline | Target Sprint 1 | Target Sprint 2 |
|---------|----------|-----------------|-----------------|
| Conflitti/settimana | 3-5 | < 1 | < 1 |
| Latency booking online | N/A | 30-120s | < 2s |
| Ricariche manuali/giorno | 20-30 | < 10 | < 5 |
| Server CPU avg | 1% | 3-5% | 5-8% |
| Operatori supportati | 50 | 300 | 500 |

**Alerting**:
- ‚ö†Ô∏è Polling lag > 60s per 3 cicli ‚Üí Network issues
- üî¥ Error rate polling > 10% ‚Üí Backend problems
- üî¥ SSE disconnections > 5/ora ‚Üí Infrastructure issues
- üî¥ Memory leak > 50MB in 1h ‚Üí Code issue

---

#### Scalabilit√† Futura

| Operatori | Soluzione | Hosting | Note |
|-----------|-----------|---------|------|
| 1-300 | Sprint 1 | Shared hosting | Sufficiente |
| 301-500 | Sprint 1+2 | Shared hosting | Con SSE |
| 501-1000 | Sprint 1+2 + ETags | Cloud hosting | + Conditional requests |
| 1000+ | WebSocket full | Cloud scalabile | Real-time bi-direzionale |

**Upgrade Path**: Quando superi 500 operatori, considera migrazione a Cloud hosting e implementazione full WebSocket invece di polling + SSE.

---

### M10 - Notification System (Email + Webhook lifecycle) ‚úÖ Completato

**Contesto**: Sistema completo di notifiche email per il ciclo di vita degli appuntamenti, con architettura multi-provider e coda asincrona.

#### Architettura Multi-Provider

**Pattern Strategy** per cambio provider via `.env`:
```ini
MAIL_PROVIDER=brevo  # smtp | brevo | mailgun
```

**Provider implementati**:
1. **SmtpProvider**: SMTP generico (SiteGround, Gmail, qualsiasi server SMTP)
2. **BrevoProvider**: Brevo API (300 email/giorno gratis) + fallback SMTP
3. **MailgunProvider**: Mailgun REST API con supporto region EU/US

#### Gerarchia Email Sender (priorit√†)

| Priorit√† | Fonte | Esempio |
|----------|-------|---------|
| **1¬∞ (alta)** | `locations.email` | `sede.roma@salonemario.it` |
| **2¬∞** | `businesses.email` | `info@salonemario.it` |
| **3¬∞ (fallback)** | `.env MAIL_FROM_*` | `noreply@romeolab.it` |

**Logica implementata nel worker**:
```php
$fromEmail = $variables['sender_email'] 
    ?? $variables['location_email'] 
    ?? $variables['business_email'] 
    ?? null;  // null = usa .env fallback
```

#### File Backend (agenda_core)

```
src/Infrastructure/Notifications/
‚îú‚îÄ‚îÄ EmailProviderInterface.php    # Contratto comune
‚îú‚îÄ‚îÄ SmtpProvider.php              # SMTP generico
‚îú‚îÄ‚îÄ BrevoProvider.php             # Brevo API
‚îú‚îÄ‚îÄ MailgunProvider.php           # Mailgun API
‚îú‚îÄ‚îÄ EmailService.php              # Factory con caching
‚îú‚îÄ‚îÄ EmailTemplateRenderer.php     # Template HTML responsive
‚îî‚îÄ‚îÄ NotificationRepository.php    # CRUD coda notifiche

src/UseCases/Notifications/
‚îú‚îÄ‚îÄ QueueBookingConfirmation.php  # Conferma prenotazione
‚îú‚îÄ‚îÄ QueueBookingCancellation.php  # Cancellazione
‚îî‚îÄ‚îÄ QueueBookingReminder.php      # Reminder 24h prima

bin/
‚îú‚îÄ‚îÄ notification-worker.php       # Processa coda (cron ogni minuto)
‚îú‚îÄ‚îÄ queue-reminders.php           # Accoda reminder (cron ogni ora)
‚îú‚îÄ‚îÄ run-worker.sh                 # Wrapper portabile
‚îî‚îÄ‚îÄ run-reminders.sh              # Wrapper portabile

migrations/
‚îî‚îÄ‚îÄ FULL_DATABASE_SCHEMA.sql      # Include notification_queue, notification_templates, notification_settings
```

#### Template Email

4 template HTML responsive con versione plaintext:
1. `bookingConfirmed` - Conferma prenotazione
2. `bookingCancelled` - Cancellazione
3. `bookingReminder` - Reminder 24h
4. `bookingRescheduled` - Modifica data/ora

#### Integrazione Use Case

- **CreateBooking.php**: Accoda conferma + reminder (non bloccante)
- **DeleteBooking.php**: Accoda cancellazione (non bloccante)

#### Frontend (agenda_backend)

- **Campo email location**: Aggiunto al dialog modifica sede
- **Localizzazioni**: `teamLocationEmailLabel`, `teamLocationEmailHint` (IT/EN)

#### Cron Setup Produzione

```bash
# Wrapper script (portabili - non dipendono da path PHP)
* * * * * /path/to/agenda_core/bin/run-worker.sh
0 * * * * /path/to/agenda_core/bin/run-reminders.sh
```

#### Configurazione .env

```ini
MAIL_PROVIDER=brevo
BREVO_API_KEY=xkeysib-xxxxx
BREVO_SMTP_KEY=xsmtpsib-xxxxx
MAIL_FROM_ADDRESS=noreply@tuodominio.it
MAIL_FROM_NAME="Agenda"
```

#### Raccomandazione

Per hosting condiviso (SiteGround): **Brevo** (300 email/giorno gratuiti)
- Verificare dominio su Brevo per sender dinamico
- Ogni location/business pu√≤ avere email personalizzata

---

### M11 - Permessi operatori gestionale ‚¨ú Proposta pronta

**Obiettivo**: Implementare sistema di autenticazione e autorizzazione per operatori del gestionale (agenda_backend), permettendo assegnazione utenti a business con ruoli e permessi.

**Problema attuale**:
- Gli operatori non hanno login nel gestionale
- Il business √® hardcoded (`currentBusinessId = 1`)
- Tutti vedono tutti i business (no multi-tenant security)

**Soluzione**: Tabella `business_users` che collega `users` a `businesses`.

---

#### Sprint 1: Database & API Base

**Backend (agenda_core)**:

1. **Migration** ‚úÖ CREATA
   - Inclusa in: `migrations/FULL_DATABASE_SCHEMA.sql`
   - Tabella `business_users` con ruoli (owner/admin/manager/staff)
   - Permessi granulari (can_manage_bookings, can_manage_clients, etc.)
   - Link opzionale a `staff_id`

2. **Repository** [DA CREARE]
   ```php
   // src/Infrastructure/Repositories/BusinessUserRepository.php
   class BusinessUserRepository {
       public function findByUserId(int $userId): array;
       public function findByBusinessId(int $businessId): array;
       public function hasAccess(int $userId, int $businessId): bool;
       public function getRole(int $userId, int $businessId): ?string;
       public function create(array $data): int;
       public function update(int $id, array $data): void;
       public function delete(int $id): void;
   }
   ```

3. **Use Cases** [DA CREARE]
   ```php
   // GetUserBusinesses - Lista business dove user ha accesso
   // InviteUserToBusiness - Invita nuovo operatore
   // UpdateBusinessUser - Modifica ruolo/permessi
   // RemoveBusinessUser - Rimuovi accesso
   ```

4. **Controller** [DA CREARE]
   ```php
   // src/Http/Controllers/BusinessUsersController.php
   // GET /v1/me/businesses
   // POST /v1/businesses/{id}/users
   // PUT /v1/businesses/{id}/users/{userId}
   // DELETE /v1/businesses/{id}/users/{userId}
   ```

5. **Middleware** [DA CREARE]
   ```php
   // BusinessAccessMiddleware - Valida accesso al business
   // Applicato a tutte le route /v1/businesses/{id}/*
   ```

**Deliverable Sprint 1**:
- API `/v1/me/businesses` funzionante
- Middleware validazione accesso
- Test unitari repository

---

#### Sprint 2: Frontend Auth

**Frontend (agenda_backend)**:

1. **Auth Feature** [DA CREARE]
   ```
   lib/features/auth/
   ‚îú‚îÄ‚îÄ data/
   ‚îÇ   ‚îî‚îÄ‚îÄ auth_repository.dart
   ‚îú‚îÄ‚îÄ domain/
   ‚îÇ   ‚îî‚îÄ‚îÄ auth_state.dart
   ‚îú‚îÄ‚îÄ providers/
   ‚îÇ   ‚îî‚îÄ‚îÄ auth_provider.dart
   ‚îî‚îÄ‚îÄ presentation/
       ‚îî‚îÄ‚îÄ login_screen.dart
   ```

2. **Modifiche Provider** [DA MODIFICARE]
   ```dart
   // business_providers.dart
   // Cambiare da GET /v1/businesses a GET /v1/me/businesses
   final userBusinessesProvider = FutureProvider<List<Business>>((ref) async {
     final repository = ref.watch(authRepositoryProvider);
     return repository.getMyBusinesses();
   });
   ```

3. **Route Guard** [DA CREARE]
   ```dart
   // router.dart - Aggiungere redirect
   redirect: (context, state) {
     final isLoggedIn = ref.read(authProvider).isAuthenticated;
     if (!isLoggedIn && !state.matchedLocation.startsWith('/login')) {
       return '/login';
     }
     return null;
   }
   ```

4. **Business Selection** [DA MODIFICARE]
   - Mostrare dialog selezione business dopo login
   - Salvare `currentBusinessId` in local storage
   - Visualizzare business corrente in app bar

**Deliverable Sprint 2**:
- Login/logout funzionante
- Selezione business post-login
- Persistenza sessione

---

#### Sprint 3: Gestione Team

**Backend (agenda_core)**:

1. **Invite Flow**
   - `POST /v1/businesses/{id}/users` con email destinatario
   - Invio email invito (se M10 completato, altrimenti skip)
   - Token invito con scadenza 7 giorni
   - `POST /v1/invitations/{token}/accept` per accettare

2. **Team Management UI** (agenda_backend)
   - Screen lista operatori business
   - Form modifica ruolo/permessi
   - Azione rimuovi accesso
   - Azione re-invita

**Deliverable Sprint 3**:
- Invito nuovi operatori
- Gestione ruoli esistenti

---

#### Sprint 4: Permessi Granulari

**Backend**:

1. **Permission Check Middleware**
   ```php
   // Esempio: solo manager+ pu√≤ gestire clienti
   if (!$this->hasPermission($userId, $businessId, 'can_manage_clients')) {
       throw AuthException::forbidden('Cannot manage clients');
   }
   ```

2. **Staff-Only View**
   - Se `role = 'staff'` e `staff_id` impostato
   - Filtrare appointments per `staff_id`
   - Nascondere altri calendari

**Frontend**:

1. **UI Conditional Rendering**
   ```dart
   if (userPermissions.canManageStaff) {
     // Mostra sezione gestione team
   }
   ```

2. **Menu Condizionale**
   - Nascondere voci menu non autorizzate
   - Disabilitare azioni non permesse

**Deliverable Sprint 4**:
- Permessi granulari funzionanti
- UI adattiva ai permessi
- Test E2E flusso completo

---

#### Metriche Successo

| Metrica | Target | Misurazione |
|---------|--------|-------------|
| Login success rate | > 99% | auth_sessions created |
| Business selection time | < 2s | UX test |
| Permission check latency | < 10ms | API profiling |
| Unauthorized access attempts | 0 | Security logs |

---

## Note Aggiuntive

### Decisioni architetturali
Vedere [decisions.md](./decisions.md) per dettaglio su:
- Mock elimination strategy
- Test strategy (backend-heavy)
- Provider loading patterns
- Business context derivation
- **Decision 21**: Sistema permessi operatori

### API Documentation
Vedere [api_contract_v1.md](./api_contract_v1.md) per contratto completo API.

----- FILE: docs/model_map.md -----

# Model Map ‚Äî agenda_core

Questo documento elenca i modelli reali usati dai client Flutter e i campi con tipi e nullabilit√†.
I campi **vincolanti** (snake_case) NON possono essere rinominati.

---

## üì¶ Frontend (prenotazione online)

### ServiceCategory
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| businessId | int | ‚úó | `business_id` |
| name | String | ‚úó | `name` |
| description | String | ‚úì | `description` |
| sortOrder | int | ‚úó (default: 0) | `sort_order` |

### Service
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| businessId | int | ‚úó | `business_id` |
| categoryId | int | ‚úó | `category_id` |
| name | String | ‚úó | `name` |
| description | String | ‚úì | `description` |
| sortOrder | int | ‚úó (default: 0) | `sort_order` |
| durationMinutes | int | ‚úó (default: 30) | `duration_minutes` |
| price | double | ‚úó (default: 0.0) | `price` |
| isFree | bool | ‚úó (default: false) | `is_free` |
| isPriceStartingFrom | bool | ‚úó (default: false) | `is_price_starting_from` |
| isBookableOnline | bool | ‚úó (default: true) | `is_bookable_online` |

### Staff
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| businessId | int | ‚úó | `business_id` |
| name | String | ‚úó | `name` |
| surname | String | ‚úó (default: '') | `surname` |
| avatarUrl | String | ‚úì | `avatar_url` |
| sortOrder | int | ‚úó (default: 0) | `sort_order` |
| isBookableOnline | bool | ‚úó (default: true) | `is_bookable_online` |

### TimeSlot
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| startTime | DateTime | ‚úó | `start_time` (ISO8601) |
| endTime | DateTime | ‚úó | `end_time` (ISO8601) |
| staffId | int | ‚úì | `staff_id` |

### User
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| email | String | ‚úó | `email` |
| firstName | String | ‚úó | `first_name` |
| lastName | String | ‚úó | `last_name` |
| phone | String | ‚úì | `phone` |
| createdAt | DateTime | ‚úó | `created_at` (ISO8601) |

### BookingRequest (payload POST /bookings)
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| services | List<Service> | ‚úó | ‚Üí `service_ids` (array int) |
| selectedStaff | Staff | ‚úì | ‚Üí `staff_id` (int) |
| selectedSlot | TimeSlot | ‚úì | ‚Üí `start_time` (ISO8601) |
| notes | String | ‚úì | `notes` |

**‚ö†Ô∏è Payload finale inviato al server:**
```json
{
  "service_ids": [1, 2],
  "staff_id": 5,
  "start_time": "2025-01-15T10:00:00Z",
  "notes": "optional"
}
```

---

## üè¢ Backend (gestionale)

### ServiceCategory (Backend)
Identico al frontend.

### Service (Backend)
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| businessId | int | ‚úó | `business_id` |
| categoryId | int | ‚úó | `category_id` |
| name | String | ‚úó | `name` |
| description | String | ‚úì | `description` |
| sortOrder | int | ‚úó (default: 0) | `sort_order` |

> **Nota**: Il backend usa `ServiceVariant` per durata/prezzo per location.

### ServiceVariant
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| serviceId | int | ‚úó | `service_id` |
| locationId | int | ‚úó | `location_id` |
| durationMinutes | int | ‚úó | `duration_minutes` |
| processingTime | int | ‚úì | `processing_time` |
| blockedTime | int | ‚úì | `blocked_time` |
| price | double | ‚úó | `price` |
| colorHex | String | ‚úì | `color_hex` |
| currency | String | ‚úì | `currency` |
| isBookableOnline | bool | ‚úó (default: true) | `is_bookable_online` |
| isFree | bool | ‚úó (default: false) | `is_free` |
| isPriceStartingFrom | bool | ‚úó (default: false) | `is_price_starting_from` |

### Staff (Backend)
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| businessId | int | ‚úó | `business_id` |
| name | String | ‚úó | `name` |
| surname | String | ‚úó (default: '') | `surname` |
| color | Color | ‚úó | `color_hex` |
| locationIds | List<int> | ‚úó | `location_ids` |
| sortOrder | int | ‚úó (default: 0) | `sort_order` |
| isDefault | bool | ‚úó (default: false) | `is_default` |
| isBookableOnline | bool | ‚úó (default: true) | `is_bookable_online` |

### Location
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| businessId | int | ‚úó | `business_id` |
| name | String | ‚úó | `name` |
| address | String | ‚úì | `address` |
| city | String | ‚úì | `city` |
| region | String | ‚úì | `region` |
| country | String | ‚úì | `country` |
| phone | String | ‚úì | `phone` |
| email | String | ‚úì | `email` |
| latitude | double | ‚úì | `latitude` |
| longitude | double | ‚úì | `longitude` |
| currency | String | ‚úì | `currency` |
| isDefault | bool | ‚úó (default: false) | `is_default` |

### Booking
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| businessId | int | ‚úó | `business_id` |
| locationId | int | ‚úó | `location_id` |
| clientId | int | ‚úì | `client_id` |
| clientName | String | ‚úì | `client_name` |
| notes | String | ‚úì | `notes` |

### Appointment (booking item)
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| bookingId | int | ‚úó | `booking_id` |
| businessId | int | ‚úó | `business_id` |
| locationId | int | ‚úó | `location_id` |
| staffId | int | ‚úó | `staff_id` |
| serviceId | int | ‚úó | `service_id` |
| serviceVariantId | int | ‚úó | `service_variant_id` |
| clientId | int | ‚úì | `client_id` |
| clientName | String | ‚úó (default: '') | `client_name` |
| serviceName | String | ‚úó (default: '') | `service_name` |
| startTime | DateTime | ‚úó | `start_time` (ISO8601) |
| endTime | DateTime | ‚úó | `end_time` (ISO8601) |
| price | double | ‚úì | `price` |
| extraMinutes | int | ‚úì | `extra_minutes` |
| extraMinutesType | ExtraMinutesType | ‚úì | `extra_minutes_type` |
| extraBlockedMinutes | int | ‚úì | `extra_blocked_minutes` |
| extraProcessingMinutes | int | ‚úì | `extra_processing_minutes` |

### Client
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| businessId | int | ‚úó | `business_id` |
| firstName | String | ‚úì | `first_name` |
| lastName | String | ‚úì | `last_name` |
| email | String | ‚úì | `email` |
| phone | String | ‚úì | `phone` |
| gender | String | ‚úì | `gender` |
| birthDate | DateTime | ‚úì | `birth_date` |
| city | String | ‚úì | `city` |
| notes | String | ‚úì | `notes` |
| createdAt | DateTime | ‚úó | `created_at` |
| lastVisit | DateTime | ‚úì | `last_visit` |
| loyaltyPoints | int | ‚úì | `loyalty_points` |
| tags | List<String> | ‚úì | `tags` |
| isArchived | bool | ‚úó (default: false) | `is_archived` |

### Resource
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| locationId | int | ‚úó | `location_id` |
| name | String | ‚úó | `name` |
| quantity | int | ‚úó | `quantity` |
| type | String | ‚úì | `type` |
| note | String | ‚úì | `note` |

### TimeBlock
| Campo | Tipo | Nullable | JSON key (vincolante) |
|-------|------|----------|----------------------|
| id | int | ‚úó | `id` |
| businessId | int | ‚úó | `business_id` |
| locationId | int | ‚úó | `location_id` |
| staffIds | List<int> | ‚úó | `staff_ids` |
| startTime | DateTime | ‚úó | `start_time` (ISO8601) |
| endTime | DateTime | ‚úó | `end_time` (ISO8601) |
| reason | String | ‚úì | `reason` |
| isAllDay | bool | ‚úó (default: false) | `is_all_day` |

---

## üîí Riepilogo campi vincolanti

Questi campi sono usati attivamente nei client Flutter e **NON devono essere rinominati**:

| Modello | Campi critici |
|---------|---------------|
| Service | `id`, `business_id`, `category_id`, `name`, `duration_minutes`, `price`, `is_free`, `is_price_starting_from`, `is_bookable_online` |
| Staff | `id`, `business_id`, `name`, `surname`, `is_bookable_online`, `sort_order` |
| TimeSlot | `start_time`, `end_time`, `staff_id` |
| BookingRequest | `service_ids`, `staff_id`, `start_time`, `notes` |
| Booking | `id`, `business_id`, `location_id`, `client_id`, `client_name`, `notes` |
| Appointment | `id`, `booking_id`, `business_id`, `location_id`, `staff_id`, `service_id`, `start_time`, `end_time` |
| User | `id`, `email`, `first_name`, `last_name`, `phone`, `created_at` |
| Client | `id`, `business_id`, `first_name`, `last_name`, `email`, `phone`, `created_at` |

----- FILE: docs/test_scenarios.md -----

# Test Scenarios ‚Äî Agenda Core API

Questo documento definisce tutti i casi di test per validare il comportamento dell'API Agenda Core.
Aggiornato al: **27 dicembre 2025**

---

## üìã Indice

- [Setup Test Environment](#setup-test-environment)
- [M1: Authentication](#m1-authentication)
- [M2: Public Browse](#m2-public-browse)
- [M3: Booking Creation](#m3-booking-creation)
- [M1.1: Booking Management](#m11-booking-management)
  - [View Bookings](#view-bookings)
  - [Cancel Booking](#cancel-booking)
  - [Reschedule Booking](#reschedule-booking)
- [Edge Cases & Error Handling](#edge-cases--error-handling)
- [Performance & Concurrency](#performance--concurrency)

---

## Setup Test Environment

### Prerequisiti

```bash
# Database di test
mysql -u root -p agenda_test < migrations/FULL_DATABASE_SCHEMA.sql

# Dati di test
mysql -u root -p agenda_test < migrations/seed_data.sql
```

### Test User Credentials

```json
{
  "test_user_1": {
    "email": "mario.rossi@test.com",
    "password": "TestPass123!",
    "user_id": 1
  },
  "test_user_2": {
    "email": "anna.bianchi@test.com",
    "password": "TestPass456!",
    "user_id": 2
  }
}
```

### Test Business/Location IDs

- **Business ID**: 1 (Salone Bella Vita)
- **Location ID**: 1 (Sede Centro, cancellation_hours: 24)
- **Location ID**: 2 (Sede Periferia, cancellation_hours: 48)

### Test Staff/Services

- **Staff ID**: 1 (Anna B., stylist)
- **Staff ID**: 2 (Luigi M., barber)
- **Service ID**: 1 (Taglio Uomo, 30 min, ‚Ç¨20)
- **Service ID**: 2 (Taglio Donna, 45 min, ‚Ç¨35)
- **Service ID**: 3 (Piega, 30 min, ‚Ç¨15)

---

## M1: Authentication

### TEST-AUTH-001: Login con credenziali valide

**Request:**
```http
POST /v1/auth/login
Content-Type: application/json

{
  "email": "mario.rossi@test.com",
  "password": "TestPass123!"
}
```

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "access_token": "eyJ...",
    "refresh_token": "abc123...",
    "expires_in": 900,
    "user": {
      "id": 1,
      "email": "mario.rossi@test.com",
      "first_name": "Mario",
      "last_name": "Rossi"
    }
  }
}
```

**Validazioni:**
- ‚úÖ `access_token` √® un JWT valido
- ‚úÖ `expires_in` = 900 (15 minuti)
- ‚úÖ `refresh_token` salvato in DB con scadenza 30-90 giorni

---

### TEST-AUTH-002: Login con password errata

**Request:**
```http
POST /v1/auth/login
Content-Type: application/json

{
  "email": "mario.rossi@test.com",
  "password": "WrongPassword!"
}
```

**Expected Response (401):**
```json
{
  "success": false,
  "error": {
    "code": "invalid_credentials",
    "message": "Invalid email or password"
  }
}
```

---

### TEST-AUTH-003: Refresh token con token valido

**Request:**
```http
POST /v1/auth/refresh
Content-Type: application/json

{
  "refresh_token": "abc123..."
}
```

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "access_token": "eyJ_new...",
    "refresh_token": "xyz789_new...",
    "expires_in": 900
  }
}
```

**Validazioni:**
- ‚úÖ Vecchio `refresh_token` invalidato (token rotation)
- ‚úÖ Nuovo `refresh_token` salvato in DB
- ‚úÖ Tentativo di riutilizzo vecchio token ‚Üí 401

---

### TEST-AUTH-004: Logout invalida refresh token

**Request:**
```http
POST /v1/auth/logout
Authorization: Bearer <access_token>
Content-Type: application/json

{
  "refresh_token": "abc123..."
}
```

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "message": "Logged out successfully"
  }
}
```

**Validazioni:**
- ‚úÖ `refresh_token` rimosso da DB
- ‚úÖ Tentativo refresh dopo logout ‚Üí 401 `invalid_refresh_token`

---

## M2: Public Browse

### TEST-BROWSE-001: Lista servizi per location

**Request:**
```http
GET /v1/services?location_id=1
```

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "categories": [
      {
        "id": 1,
        "name": "Taglio",
        "services": [
          {
            "id": 1,
            "name": "Taglio Uomo",
            "description": "Taglio classico o moderno",
            "default_duration_minutes": 30,
            "default_price": 20.00,
            "color": "#FF6B6B",
            "category_id": 1
          }
        ]
      }
    ]
  }
}
```

---

### TEST-BROWSE-002: Availability check base

**Request:**
```http
GET /v1/availability?location_id=1&date=2026-01-15&service_ids=1&staff_id=1
```

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "slots": [
      {
        "start_time": "2026-01-15T09:00:00+01:00",
        "end_time": "2026-01-15T09:30:00+01:00",
        "staff_id": 1,
        "staff_name": "Anna B."
      },
      {
        "start_time": "2026-01-15T09:30:00+01:00",
        "end_time": "2026-01-15T10:00:00+01:00",
        "staff_id": 1,
        "staff_name": "Anna B."
      }
    ]
  }
}
```

**Validazioni:**
- ‚úÖ Solo slot liberi (no conflitti con booking esistenti)
- ‚úÖ Rispetta orari lavoro staff
- ‚úÖ Durata slot = somma durate servizi

---

### TEST-BROWSE-003: Availability con servizi multipli

**Request:**
```http
GET /v1/availability?location_id=1&date=2026-01-15&service_ids=1,3&staff_id=1
```

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "slots": [
      {
        "start_time": "2026-01-15T09:00:00+01:00",
        "end_time": "2026-01-15T10:00:00+01:00",
        "staff_id": 1,
        "staff_name": "Anna B."
      }
    ]
  }
}
```

**Validazioni:**
- ‚úÖ Durata slot = 30 min (service 1) + 30 min (service 3) = 60 min
- ‚úÖ Verifica disponibilit√† continuativa per entrambi i servizi

---

## M3: Booking Creation

### TEST-BOOKING-001: Creazione booking con slot disponibile

**Request:**
```http
POST /v1/locations/1/bookings
Authorization: Bearer <access_token>
X-Idempotency-Key: 550e8400-e29b-41d4-a716-446655440001
Content-Type: application/json

{
  "service_ids": [1],
  "staff_id": 1,
  "start_time": "2026-01-15T10:00:00+01:00",
  "notes": "Prima visita"
}
```

**Expected Response (201):**
```json
{
  "success": true,
  "data": {
    "id": 42,
    "business_id": 1,
    "location_id": 1,
    "client_id": 1,
    "status": "confirmed",
    "notes": "Prima visita",
    "total_price": 20.00,
    "total_duration_minutes": 30,
    "created_at": "2025-12-27T14:30:00+01:00",
    "items": [
      {
        "id": 101,
        "service_id": 1,
        "service_name": "Taglio Uomo",
        "staff_id": 1,
        "staff_name": "Anna B.",
        "location_id": 1,
        "start_time": "2026-01-15T10:00:00+01:00",
        "end_time": "2026-01-15T10:30:00+01:00",
        "price": 20.00,
        "duration_minutes": 30
      }
    ]
  }
}
```

**Validazioni:**
- ‚úÖ Record `bookings` creato con `status='confirmed'`
- ‚úÖ Record `booking_items` creato con `service_variant_id` risolto
- ‚úÖ Record `clients` auto-creato se primo booking utente
- ‚úÖ `idempotency_key` salvato con expires_at = +24h

---

### TEST-BOOKING-002: Creazione booking con slot occupato

**Setup:**
1. Crea booking A: staff_id=1, 2026-01-15 10:00-10:30
2. Tenta booking B: staff_id=1, 2026-01-15 10:15-10:45 (overlap)

**Request (Booking B):**
```http
POST /v1/locations/1/bookings
Authorization: Bearer <access_token>
X-Idempotency-Key: 550e8400-e29b-41d4-a716-446655440002
Content-Type: application/json

{
  "service_ids": [1],
  "staff_id": 1,
  "start_time": "2026-01-15T10:15:00+01:00"
}
```

**Expected Response (409):**
```json
{
  "success": false,
  "error": {
    "code": "slot_conflict",
    "message": "The requested time slot is no longer available",
    "details": {
      "conflicts": [
        {
          "booking_id": 42,
          "start_time": "2026-01-15T10:00:00+01:00",
          "end_time": "2026-01-15T10:30:00+01:00"
        }
      ]
    }
  }
}
```

**Validazioni:**
- ‚úÖ Nessun record creato in `bookings` o `booking_items`
- ‚úÖ Transazione rollback completata
- ‚úÖ `FOR UPDATE` ha bloccato row durante check

---

### TEST-BOOKING-003: Idempotency key duplicata

**Setup:**
1. Crea booking con idempotency_key X (successo)
2. Riprova stessa request con idempotency_key X (entro 24h)

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "id": 42,
    ...stesso booking del primo tentativo...
  }
}
```

**Validazioni:**
- ‚úÖ Nessun nuovo booking creato
- ‚úÖ Ritorna booking esistente con idempotency_key X
- ‚úÖ HTTP status 200 (non 201)

---

### TEST-BOOKING-004: Booking servizi multipli sequenziali

**Request:**
```http
POST /v1/locations/1/bookings
Authorization: Bearer <access_token>
X-Idempotency-Key: 550e8400-e29b-41d4-a716-446655440003
Content-Type: application/json

{
  "service_ids": [1, 3],
  "staff_id": 1,
  "start_time": "2026-01-15T14:00:00+01:00"
}
```

**Expected Response (201):**
```json
{
  "success": true,
  "data": {
    "id": 43,
    "total_duration_minutes": 60,
    "total_price": 35.00,
    "items": [
      {
        "id": 102,
        "service_id": 1,
        "start_time": "2026-01-15T14:00:00+01:00",
        "end_time": "2026-01-15T14:30:00+01:00",
        "duration_minutes": 30,
        "price": 20.00
      },
      {
        "id": 103,
        "service_id": 3,
        "start_time": "2026-01-15T14:30:00+01:00",
        "end_time": "2026-01-15T15:00:00+01:00",
        "duration_minutes": 30,
        "price": 15.00
      }
    ]
  }
}
```

**Validazioni:**
- ‚úÖ 2 `booking_items` con orari consecutivi
- ‚úÖ `items[0].end_time` = `items[1].start_time`
- ‚úÖ `total_duration` = somma durate
- ‚úÖ `total_price` = somma prezzi

---

## M1.1: Booking Management

> **Nota:** Aggiornato al 27/12/2025 con formato response flat (no nested objects).

### View Bookings

#### TEST-VIEW-001: Lista bookings utente autenticato

**Request:**
```http
GET /v1/me/bookings
Authorization: Bearer <access_token>
```

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "upcoming": [
      {
        "booking_id": 123,
        "status": "confirmed",
        "start_time": "2026-01-20T14:00:00+01:00",
        "end_time": "2026-01-20T15:00:00+01:00",
        "service_names": ["Taglio", "Piega"],
        "staff_name": "Anna B.",
        "total_price": 35.00,
        "notes": null,
        "location_id": 1,
        "location_name": "Sede Centro",
        "location_address": "Via Roma 123",
        "location_city": "Milano",
        "business_id": 1,
        "business_name": "Salone Bella Vita",
        "can_modify": true,
        "can_modify_until": "2026-01-19T14:00:00+01:00",
        "created_at": "2025-12-20T10:00:00+01:00"
      }
    ],
    "past": [
      {
        "booking_id": 100,
        "status": "completed",
        "start_time": "2025-12-15T10:00:00+01:00",
        "end_time": "2025-12-15T11:00:00+01:00",
        "service_names": ["Taglio Uomo"],
        "staff_name": "Luigi M.",
        "total_price": 25.00,
        "notes": null,
        "location_id": 1,
        "location_name": "Sede Centro",
        "location_address": "Via Roma 123",
        "location_city": "Milano",
        "business_id": 1,
        "business_name": "Salone Bella Vita",
        "can_modify": false,
        "can_modify_until": null,
        "created_at": "2025-12-10T09:00:00+01:00"
      }
    ]
  }
}
```

**Validazioni:**
- ‚úÖ `upcoming` ordinati per `start_time ASC`
- ‚úÖ `past` ordinati per `start_time DESC`
- ‚úÖ `can_modify = true` solo se `now < can_modify_until`
- ‚úÖ `can_modify_until = start_time - cancellation_hours`
- ‚úÖ `service_names` √® array (aggregato da booking_items)
- ‚úÖ `total_price` √® somma prezzi di tutti booking_items
- ‚úÖ Formato flat (no oggetti nested location/business)

---

#### TEST-VIEW-002: Can_modify calculation con location override

**Setup:**
- Location 1: `cancellation_hours = 24`
- Location 2: `cancellation_hours = 48`
- Booking A: location_id=1, start_time = now + 30 ore
- Booking B: location_id=2, start_time = now + 30 ore

**Expected:**
- Booking A: `can_modify = true` (30h > 24h)
- Booking B: `can_modify = false` (30h < 48h)

---

### Cancel Booking

#### TEST-CANCEL-001: Cancellazione entro deadline

**Setup:**
- Location cancellation_hours = 24
- Booking start_time = now + 48 ore
- Now = 2025-12-27T10:00:00

**Request:**
```http
DELETE /v1/locations/1/bookings/123
Authorization: Bearer <access_token>
```

**Expected Response (204):**
```
(empty body)
```

**Validazioni:**
- ‚úÖ `bookings.status` ‚Üí 'cancelled'
- ‚úÖ `booking_items` non eliminati (audit trail)
- ‚úÖ Slot liberato (disponibile in availability check)

---

#### TEST-CANCEL-002: Cancellazione oltre deadline

**Setup:**
- Location cancellation_hours = 24
- Booking start_time = now + 20 ore (entro deadline)

**Request:**
```http
DELETE /v1/locations/1/bookings/123
Authorization: Bearer <access_token>
```

**Expected Response (400):**
```json
{
  "success": false,
  "error": {
    "code": "validation_error",
    "message": "Cannot cancel booking within 24 hours of appointment start time",
    "details": {
      "cancellation_deadline": "2025-12-28T14:00:00+01:00"
    }
  }
}
```

**Validazioni:**
- ‚úÖ Booking non modificato (status rimane 'confirmed')
- ‚úÖ Messaggio include deadline precisa

---

#### TEST-CANCEL-003: Cancellazione booking di altro utente

**Setup:**
- Booking owner: user_id=1
- Request from: user_id=2

**Request:**
```http
DELETE /v1/locations/1/bookings/123
Authorization: Bearer <access_token_user_2>
```

**Expected Response (403):**
```json
{
  "success": false,
  "error": {
    "code": "unauthorized",
    "message": "You do not have permission to cancel this booking"
  }
}
```

---

### Reschedule Booking

#### TEST-RESCHEDULE-001: Reschedule con slot disponibile

**Setup:**
- Booking originale: staff_id=1, 2026-01-20 14:00-15:00 (servizi 1+3)
- Nuovo slot: 2026-01-22 10:00-11:00 (libero)
- Cancellation deadline: non violata

**Request:**
```http
PUT /v1/locations/1/bookings/123
Authorization: Bearer <access_token>
Content-Type: application/json

{
  "start_time": "2026-01-22T10:00:00+01:00",
  "notes": "Riprogrammazione per impegno"
}
```

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "id": 123,
    "status": "confirmed",
    "notes": "Riprogrammazione per impegno",
    "items": [
      {
        "id": 456,
        "service_id": 1,
        "start_time": "2026-01-22T10:00:00+01:00",
        "end_time": "2026-01-22T10:30:00+01:00"
      },
      {
        "id": 457,
        "service_id": 3,
        "start_time": "2026-01-22T10:30:00+01:00",
        "end_time": "2026-01-22T11:00:00+01:00"
      }
    ]
  }
}
```

**Validazioni:**
- ‚úÖ Tutti i `booking_items` aggiornati con nuovo orario
- ‚úÖ Offset temporale preservato (servizio 3 inizia quando finisce servizio 1)
- ‚úÖ Durate invariate
- ‚úÖ Staff e servizi invariati
- ‚úÖ Vecchio slot liberato, nuovo slot occupato

---

#### TEST-RESCHEDULE-002: Reschedule con slot occupato (availability check)

**Setup:**
1. Booking A: staff_id=1, 2026-01-22 10:00-10:30 (esistente)
2. Booking B: staff_id=1, 2026-01-20 14:00-14:30 (da spostare)
3. Tentativo reschedule B ‚Üí 2026-01-22 10:00-10:30 (conflitto con A)

**Request:**
```http
PUT /v1/locations/1/bookings/124
Authorization: Bearer <access_token>
Content-Type: application/json

{
  "start_time": "2026-01-22T10:00:00+01:00"
}
```

**Expected Response (409):**
```json
{
  "success": false,
  "error": {
    "code": "slot_conflict",
    "message": "The requested time slot is no longer available for this staff member",
    "details": {
      "conflicts": [
        {
          "booking_id": 123,
          "start_time": "2026-01-22T10:00:00+01:00",
          "end_time": "2026-01-22T10:30:00+01:00"
        }
      ]
    }
  }
}
```

**Validazioni:**
- ‚úÖ Booking B non modificato (orario originale preservato)
- ‚úÖ Transazione rollback completata
- ‚úÖ `FOR UPDATE` ha bloccato row di Booking A durante check

---

#### TEST-RESCHEDULE-003: Reschedule multi-service con offset complesso

**Setup:**
- Booking originale:
  - Item 1: service_id=1, 2026-01-20 14:00-14:30 (30 min)
  - Item 2: service_id=3, 2026-01-20 14:30-15:00 (30 min)
  - Item 3: service_id=2, 2026-01-20 15:00-15:45 (45 min)
- Nuovo start: 2026-01-22 09:00:00

**Expected:**
- Item 1: 2026-01-22 09:00-09:30 (offset: +43h)
- Item 2: 2026-01-22 09:30-10:00 (offset: +43h)
- Item 3: 2026-01-22 10:00-10:45 (offset: +43h)

**Validazioni:**
- ‚úÖ Offset calcolato correttamente: `new_start - old_start`
- ‚úÖ Tutti gli item spostati con stesso offset
- ‚úÖ Intervalli relativi preservati (no gap, no overlap)

---

#### TEST-RESCHEDULE-004: Reschedule oltre cancellation deadline

**Setup:**
- Location cancellation_hours = 24
- Booking start_time = now + 20 ore
- Tentativo reschedule a now + 48 ore

**Request:**
```http
PUT /v1/locations/1/bookings/123
Authorization: Bearer <access_token>
Content-Type: application/json

{
  "start_time": "2025-12-29T14:00:00+01:00"
}
```

**Expected Response (400):**
```json
{
  "success": false,
  "error": {
    "code": "validation_error",
    "message": "Cannot modify booking within 24 hours of appointment start time",
    "details": {
      "cancellation_deadline": "2025-12-28T14:00:00+01:00"
    }
  }
}
```

**Validazioni:**
- ‚úÖ Policy validata PRIMA dell'availability check
- ‚úÖ Booking non modificato

---

#### TEST-RESCHEDULE-005: Reschedule dello stesso booking a slot parzialmente sovrapposto

**Setup:**
- Booking originale: 2026-01-20 14:00-15:00
- Reschedule a: 2026-01-20 14:30-15:30 (overlap 30 min)
- Nessun altro booking per questo staff

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "id": 123,
    "items": [
      {
        "start_time": "2026-01-20T14:30:00+01:00",
        "end_time": "2026-01-20T15:30:00+01:00"
      }
    ]
  }
}
```

**Validazioni:**
- ‚úÖ `checkConflicts()` riceve `excludeBookingId=123`
- ‚úÖ Overlap con se stesso ignorato
- ‚úÖ Update completato con successo

---

#### TEST-RESCHEDULE-006: Update status/notes (no reschedule)

**Request:**
```http
PUT /v1/locations/1/bookings/123
Authorization: Bearer <access_token>
Content-Type: application/json

{
  "status": "confirmed",
  "notes": "Cliente confermato via telefono"
}
```

**Expected Response (200):**
```json
{
  "success": true,
  "data": {
    "id": 123,
    "status": "confirmed",
    "notes": "Cliente confermato via telefono",
    "items": [
      {
        "start_time": "2026-01-20T14:00:00+01:00",
        ...orario invariato...
      }
    ]
  }
}
```

**Validazioni:**
- ‚úÖ Solo `status` e `notes` aggiornati
- ‚úÖ `booking_items` invariati
- ‚úÖ No availability check eseguito
- ‚úÖ Cancellation policy NON validata (solo per reschedule/cancel)

---

## Edge Cases & Error Handling

### TEST-EDGE-001: Booking con service_variant non disponibile online

**Setup:**
- Service 1 ha variant per location 1 con `is_bookable_online=0`

**Request:**
```http
POST /v1/locations/1/bookings
Authorization: Bearer <access_token>
X-Idempotency-Key: 550e8400-e29b-41d4-a716-446655440004

{
  "service_ids": [1],
  "staff_id": 1,
  "start_time": "2026-01-15T10:00:00+01:00"
}
```

**Expected Response (400):**
```json
{
  "success": false,
  "error": {
    "code": "validation_error",
    "message": "Service 1 is not available for online booking at this location"
  }
}
```

---

### TEST-EDGE-002: Reschedule con start_time formato invalido

**Request:**
```http
PUT /v1/locations/1/bookings/123
Authorization: Bearer <access_token>

{
  "start_time": "2026-01-22 10:00:00"
}
```

**Expected Response (400):**
```json
{
  "success": false,
  "error": {
    "code": "validation_error",
    "message": "Invalid start_time format. Use ISO8601."
  }
}
```

---

### TEST-EDGE-003: Booking con JWT scaduto

**Request:**
```http
POST /v1/locations/1/bookings
Authorization: Bearer <expired_token>
X-Idempotency-Key: 550e8400-e29b-41d4-a716-446655440005

{
  "service_ids": [1],
  "staff_id": 1,
  "start_time": "2026-01-15T10:00:00+01:00"
}
```

**Expected Response (401):**
```json
{
  "success": false,
  "error": {
    "code": "unauthorized",
    "message": "Access token expired"
  }
}
```

---

### TEST-EDGE-004: Reschedule booking gi√† cancellato

**Setup:**
- Booking status = 'cancelled'

**Request:**
```http
PUT /v1/locations/1/bookings/123
Authorization: Bearer <access_token>

{
  "start_time": "2026-01-22T10:00:00+01:00"
}
```

**Expected Response (400):**
```json
{
  "success": false,
  "error": {
    "code": "validation_error",
    "message": "Cannot reschedule a cancelled booking"
  }
}
```

---

### TEST-EDGE-005: Location ID mismatch tra path e booking

**Setup:**
- Booking originale: location_id=1
- Request path: `/v1/locations/2/bookings/123`

**Request:**
```http
PUT /v1/locations/2/bookings/123
Authorization: Bearer <access_token>

{
  "notes": "Test"
}
```

**Expected Response (404):**
```json
{
  "success": false,
  "error": {
    "code": "not_found",
    "message": "Booking not found"
  }
}
```

**Validazioni:**
- ‚úÖ Query filtrata per `location_id=2 AND booking_id=123` ‚Üí nessun match
- ‚úÖ Previene accesso cross-location

---

## Performance & Concurrency

### TEST-PERF-001: Race condition su reschedule simultanei

**Setup:**
1. Booking A: staff_id=1, 2026-01-20 14:00-14:30
2. Slot target: 2026-01-22 10:00-10:30 (libero)

**Scenario:**
- Thread 1: Reschedule Booking A ‚Üí target slot
- Thread 2: Reschedule Booking A ‚Üí stesso target slot
- Esecuzione simultanea (delay < 100ms)

**Expected Outcome:**
- 1 request ‚Üí **200 OK** (prima a completare transazione)
- 1 request ‚Üí **409 Conflict** (rileva booking gi√† spostato)

**Validazioni:**
- ‚úÖ Una sola transazione committata
- ‚úÖ Nessun double-booking
- ‚úÖ `FOR UPDATE` ha serializzato accesso

---

### TEST-PERF-002: Race condition su booking + reschedule

**Setup:**
- Slot target: 2026-01-22 10:00-10:30 (libero)

**Scenario:**
- Thread 1: `POST /bookings` ‚Üí nuovo booking su target slot
- Thread 2: `PUT /bookings/123` ‚Üí reschedule esistente su target slot
- Esecuzione simultanea

**Expected Outcome:**
- 1 request ‚Üí **201 Created** / **200 OK**
- 1 request ‚Üí **409 Conflict**

**Validazioni:**
- ‚úÖ Una sola transazione occupa lo slot
- ‚úÖ Lock acquisito da `checkConflicts()` FOR UPDATE

---

### TEST-PERF-003: Reschedule multi-item con 10+ servizi

**Setup:**
- Booking con 10 servizi consecutivi (totale 5 ore)
- Nuovo slot: disponibile per tutti i 10 servizi

**Expected:**
- Response time < 1s
- Tutti i 10 `booking_items` aggiornati con offset corretto
- Una sola query UPDATE per tutti gli items (batch)

**Validazioni:**
- ‚úÖ No N+1 query problem
- ‚úÖ Transazione unica

---

### TEST-PERF-004: Availability check con 50+ booking esistenti

**Setup:**
- Staff 1 ha 50 booking su 2026-01-22
- Request availability per 2026-01-22

**Expected:**
- Response time < 500ms
- Solo slot liberi ritornati
- Query con indici su `(staff_id, location_id, start_time, end_time)`

---

## Automation Scripts

### Script: Run All Critical Tests

```bash
#!/bin/bash
# test_critical.sh

BASE_URL="https://api.agenda-test.local/v1"

echo "üß™ Running Critical Test Suite..."

# Login
ACCESS_TOKEN=$(curl -s -X POST "$BASE_URL/auth/login" \
  -H "Content-Type: application/json" \
  -d '{"email":"mario.rossi@test.com","password":"TestPass123!"}' \
  | jq -r '.data.access_token')

echo "‚úÖ Authentication OK"

# TEST-RESCHEDULE-001: Reschedule con slot disponibile
BOOKING_ID=$(curl -s -X POST "$BASE_URL/locations/1/bookings" \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -H "X-Idempotency-Key: $(uuidgen)" \
  -H "Content-Type: application/json" \
  -d '{"service_ids":[1],"staff_id":1,"start_time":"2026-01-20T14:00:00+01:00"}' \
  | jq -r '.data.id')

RESCHEDULE_RESPONSE=$(curl -s -X PUT "$BASE_URL/locations/1/bookings/$BOOKING_ID" \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"start_time":"2026-01-22T10:00:00+01:00"}')

RESCHEDULE_STATUS=$(echo $RESCHEDULE_RESPONSE | jq -r '.success')
if [ "$RESCHEDULE_STATUS" = "true" ]; then
  echo "‚úÖ TEST-RESCHEDULE-001 PASSED"
else
  echo "‚ùå TEST-RESCHEDULE-001 FAILED"
  echo $RESCHEDULE_RESPONSE | jq
fi

# TEST-RESCHEDULE-002: Slot occupato
CONFLICT_RESPONSE=$(curl -s -X PUT "$BASE_URL/locations/1/bookings/$BOOKING_ID" \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"start_time":"2026-01-22T10:00:00+01:00"}')

ERROR_CODE=$(echo $CONFLICT_RESPONSE | jq -r '.error.code')
if [ "$ERROR_CODE" = "slot_conflict" ]; then
  echo "‚úÖ TEST-RESCHEDULE-002 PASSED"
else
  echo "‚ùå TEST-RESCHEDULE-002 FAILED (expected slot_conflict, got $ERROR_CODE)"
fi

echo ""
echo "üìä Test Suite Complete"
```

### Script: Race Condition Simulator

```bash
#!/bin/bash
# test_race_condition.sh

BASE_URL="https://api.agenda-test.local/v1"
ACCESS_TOKEN="<your_token>"
BOOKING_ID=123

# Esegui due reschedule simultanei
(
  curl -s -X PUT "$BASE_URL/locations/1/bookings/$BOOKING_ID" \
    -H "Authorization: Bearer $ACCESS_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"start_time":"2026-01-22T10:00:00+01:00"}' &
  
  curl -s -X PUT "$BASE_URL/locations/1/bookings/$BOOKING_ID" \
    -H "Authorization: Bearer $ACCESS_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"start_time":"2026-01-22T10:00:00+01:00"}' &
  
  wait
) | jq -s 'map(.success) | group_by(.) | map({key: .[0], count: length})'

# Expected output: [{"key":true,"count":1}, {"key":false,"count":1}]
```

---

## Future Test Scenarios

### M10: Notifications

- **TEST-NOTIF-001**: Email conferma dopo booking creation
- **TEST-NOTIF-002**: Email notifica reschedule a cliente e staff
- **TEST-NOTIF-003**: SMS reminder 24h prima appuntamento
- **TEST-NOTIF-004**: Push notification cancellazione booking

### M4: Admin Dashboard

- **TEST-ADMIN-001**: Gestionale vede booking multi-location
- **TEST-ADMIN-002**: Report bookings per staff/periodo
- **TEST-ADMIN-003**: Modifica booking lato admin (no policy)

### M5: Reviews

- **TEST-REVIEW-001**: Cliente pu√≤ recensire solo dopo status='completed'
- **TEST-REVIEW-002**: Review visibile solo dopo approvazione admin

---

## Maintenance

### Aggiornamento Scenari

Quando aggiungi una nuova feature:
1. Crea sezione dedicata (es: `## M2: Feature Name`)
2. Numera test sequenzialmente (`TEST-FEATURE-001`)
3. Includi setup, request, expected response, validazioni
4. Aggiungi script bash per automazione se applicabile

### Test Data Reset

```bash
# Ripristina DB test a stato pulito
mysql -u root -p agenda_test < test_data/reset.sql
mysql -u root -p agenda_test < test_data/seed.sql
```

---

**Ultimo aggiornamento**: 28 dicembre 2025  
**Versione API**: v1  
**Maintainer**: Team Agenda Core

---

## M8: Unit Test Suite (PHPUnit)

### Panoramica

Test suite implementata con PHPUnit 10.5.60. Focus su logica di business pura senza dipendenze dal database.

**Risultati**: 98 test, 195 asserzioni, 100% pass

### TEST-UNIT-AUTH: Auth Use Case Tests

| Test | Descrizione |
|------|-------------|
| `testPasswordHashingAndVerification` | Bcrypt hash + verify |
| `testLoginValidationRequiresEmail` | Email obbligatoria |
| `testLoginValidationRequiresValidEmailFormat` | Formato email valido |
| `testPasswordMinimumLength` | Password ‚â• 8 caratteri |
| `testJwtGenerationAndValidation` | JWT create + validate |
| `testJwtRejectsInvalidToken` | Token malformato |
| `testJwtRejectsTamperedToken` | Token manomesso |
| `testRefreshTokenHashGeneration` | SHA-256 deterministic |
| `testRefreshTokenExpiryCheck` | Scadenza +30 giorni |
| `testRefreshTokenRevokedCheck` | Flag is_revoked |
| `testDisabledAccountCheck` | Account disabilitato |
| `testUserRoleValidation` | Ruoli validi |
| `testAuthExceptionInvalidCredentials` | Exception credentials |
| `testAuthExceptionAccountDisabled` | Exception disabled |
| `testAuthExceptionTokenExpired` | Exception expired |
| `testSessionExpiryCalculation` | TTL access/refresh |
| `testLogoutRequiresUserId` | User ID obbligatorio |

### TEST-UNIT-BOOKING: Booking Use Case Tests

| Test | Descrizione |
|------|-------------|
| `testBookingRequiresServiceIds` | service_ids obbligatorio |
| `testBookingRequiresValidStartTime` | start_time obbligatorio |
| `testBookingRejectsPastStartTime` | No date passate |
| `testBookingAcceptsFutureStartTime` | Date future OK |
| `testTotalDurationCalculation` | Somma durate servizi |
| `testEndTimeCalculation` | start + duration = end |
| `testConflictDetection` | Overlap rilevato |
| `testNoConflictForAdjacentBookings` | Adiacenti OK |
| `testNoConflictForNonOverlappingBookings` | Separati OK |
| `testConflictWhenNewBookingContainsExisting` | Nuovo contiene esistente |
| `testConflictWhenExistingContainsNew` | Esistente contiene nuovo |
| `testIdempotencyKeyFormat` | UUID v4 valido |
| `testIdempotencyKeyRejectsInvalidFormat` | UUID invalido |
| `testTotalPriceCalculation` | Somma prezzi |
| `testValidBookingStatuses` | pending/confirmed/... |
| `testDefaultBookingStatusIsPending` | Default = pending |
| `testSequentialServiceSlotCalculation` | Multi-service sequential |

### TEST-UNIT-AVAILABILITY: Availability Tests

| Test | Descrizione |
|------|-------------|
| `testWorkingHoursParsingAM` | Parse orari apertura |
| `testWorkingHoursSpansDayCorrectly` | Calcolo ore totali |
| `testGenerateSlots30MinInterval` | Slot 30 min |
| `testGenerateSlots15MinInterval` | Slot 15 min |
| `testFilterOutBookedSlots` | Escludi occupati |
| `testFilterSlotsForServiceDuration` | Servizio > slot |
| `testStaffBreakTimeExcludedFromAvailability` | Pausa pranzo |
| `testStaffAvailableOutsideBreak` | Fuori pausa OK |
| `testAnyStaffAvailableReturnsSlot` | Multi-staff OR |
| `testNoStaffAvailableReturnsUnavailable` | Tutti occupati |
| `testAvailabilityForDateRange` | Range date |
| `testExcludeClosedDays` | Domenica chiuso |
| `testBufferTimeBetweenAppointments` | Buffer 15 min |
| `testNoBufferWhenNotConfigured` | Buffer 0 |
| `testSlotConversionBetweenTimezones` | UTC ‚Üî Rome |
| `testSlotsGeneratedInBusinessTimezone` | Timezone business |

### Esecuzione Test

```bash
# Tutti i test con output dettagliato
cd agenda_core
./vendor/bin/phpunit --testdox

# Solo test Auth
./vendor/bin/phpunit --filter AuthUseCaseTest

# Solo test Booking
./vendor/bin/phpunit --filter BookingUseCaseTest

# Solo test Availability
./vendor/bin/phpunit --filter AvailabilityTest

# Coverage report (richiede xdebug)
./vendor/bin/phpunit --coverage-html coverage/
```

### File Test

```
tests/
‚îú‚îÄ‚îÄ AuthTest.php           # 6 test - JWT base, password
‚îú‚îÄ‚îÄ AuthUseCaseTest.php    # 17 test - Logica auth completa
‚îú‚îÄ‚îÄ AvailabilityTest.php   # 16 test - Slot e disponibilit√†
‚îú‚îÄ‚îÄ BookingTest.php        # 7 test - Overlap e date
‚îú‚îÄ‚îÄ BookingUseCaseTest.php # 18 test - Logica booking
‚îú‚îÄ‚îÄ ExceptionsTest.php     # 7 test - Domain exceptions
‚îú‚îÄ‚îÄ IdempotencyTest.php    # 5 test - UUID validation
‚îú‚îÄ‚îÄ PasswordHasherTest.php # 4 test - Bcrypt
‚îú‚îÄ‚îÄ RequestTest.php        # 5 test - HTTP request
‚îú‚îÄ‚îÄ ResponseTest.php       # 7 test - HTTP response
‚îî‚îÄ‚îÄ RouterTest.php         # 7 test - Routing
```

=======================================
----- FILE: .env.example -----

# Environment
APP_ENV=development
APP_DEBUG=true

# Base path prefix for URL routing (es. /agenda_core/public per MAMP)
# Lasciare vuoto se non necessario
APP_BASE_PATH=

# Database
DB_HOST=localhost
DB_PORT=3306
DB_DATABASE=agenda_core
DB_USERNAME=root
DB_PASSWORD=

# JWT
JWT_SECRET=your-secret-key-min-32-chars-here
JWT_ACCESS_TTL=900
JWT_REFRESH_TTL=864000

# CORS
CORS_ORIGIN=http://localhost:3000

# Timezone
APP_TIMEZONE=Europe/Rome

# ========================================
# EMAIL NOTIFICATIONS
# ========================================

# Provider: smtp | brevo | mailgun
MAIL_PROVIDER=smtp

# Default sender (used by all providers)
MAIL_FROM_ADDRESS=noreply@example.com
MAIL_FROM_NAME="Agenda Platform"

# SMTP Configuration (for MAIL_PROVIDER=smtp)
# Works with SiteGround, Gmail, or any SMTP server
SMTP_HOST=smtp.example.com
SMTP_PORT=587
SMTP_USERNAME=your-smtp-username
SMTP_PASSWORD=your-smtp-password
# Encryption: tls | ssl | none
SMTP_ENCRYPTION=tls

# Brevo Configuration (for MAIL_PROVIDER=brevo)
# Free tier: 300 emails/day
# Get API key from: https://app.brevo.com/settings/keys/api
BREVO_API_KEY=your-brevo-api-key
# Optional: Brevo SMTP fallback
BREVO_SMTP_KEY=your-brevo-smtp-key

# Mailgun Configuration (for MAIL_PROVIDER=mailgun)
# Get credentials from: https://app.mailgun.com/mg/dashboard
MAILGUN_API_KEY=your-mailgun-api-key
MAILGUN_DOMAIN=mg.example.com
# Region: eu | us (default: eu)
MAILGUN_REGION=eu

# ========================================
# FRONTEND URLs
# ========================================

# URL frontend prenotazione (per clienti)
FRONTEND_URL=https://prenota.romeolab.it

# URL backend/gestionale (per admin business)
BACKEND_URL=https://gestionale.romeolab.it

# Test mode: redirect all notification emails to nome.cognome@romeolab.it
NOTIFICATION_TEST_MODE=false

=======================================
----- FILE: migrations/0021_business_suspension.sql -----

-- ============================================================================
-- MIGRATION 0021: Business Suspension Support
-- Date: 2026-01-03
-- Description: Add is_suspended and suspension_message fields to businesses
-- ============================================================================

-- Add suspension fields to businesses table
ALTER TABLE businesses 
ADD COLUMN is_suspended TINYINT(1) NOT NULL DEFAULT 0 
    COMMENT 'Whether the business is suspended (visible but not operational)'
    AFTER is_active;

ALTER TABLE businesses 
ADD COLUMN suspension_message TEXT DEFAULT NULL 
    COMMENT 'Message shown to operators and customers when business is suspended'
    AFTER is_suspended;

-- Add index for efficient querying
CREATE INDEX idx_businesses_suspended ON businesses(is_suspended);

----- FILE: migrations/0021_rename_customer_name_to_client_name.sql -----

-- Migration: Rinomina customer_name in client_name per coerenza con client_id
-- Data: 2026-01-04

-- Rinomina colonna nella tabella bookings
ALTER TABLE bookings CHANGE COLUMN customer_name client_name VARCHAR(200) NULL;

----- FILE: migrations/0022_staff_planning.sql -----

-- =============================================================================
-- Migration: 0022_staff_planning.sql
-- Descrizione: Crea tabelle per staff planning settimanale/bisettimanale
-- Data: 2026-01-04
-- =============================================================================

-- -----------------------------------------------------------------------------
-- Tabella: staff_planning
-- Rappresenta una pianificazione settimanale o bisettimanale di uno staff.
-- Intervallo di validit√† [valid_from, valid_to] chiuso-chiuso.
-- valid_to NULL significa "senza scadenza".
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS staff_planning (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    staff_id INT UNSIGNED NOT NULL,
    type ENUM('weekly', 'biweekly') NOT NULL DEFAULT 'weekly',
    valid_from DATE NOT NULL,
    valid_to DATE NULL DEFAULT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
    
    PRIMARY KEY (id),
    
    -- FK verso staff
    CONSTRAINT fk_staff_planning_staff
        FOREIGN KEY (staff_id) REFERENCES staff(id)
        ON DELETE CASCADE
        ON UPDATE CASCADE,
    
    -- Indice per ricerche per staff
    INDEX idx_staff_planning_staff_id (staff_id),
    
    -- Indice per ricerche di validit√† (query: valid_from <= D AND (valid_to IS NULL OR valid_to >= D))
    INDEX idx_staff_planning_validity (staff_id, valid_from, valid_to),
    
    -- Indice per valid_from (ordinamento cronologico)
    INDEX idx_staff_planning_valid_from (valid_from)
    
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;


-- -----------------------------------------------------------------------------
-- Tabella: staff_planning_week_template
-- Template settimanale con slot per ogni giorno.
-- Per planning weekly: solo record con week_label='A'.
-- Per planning biweekly: record con week_label='A' e 'B'.
-- day_of_week: 1=Monday, 7=Sunday (ISO 8601).
-- slots: JSON array di interi (indici slot, es. [36,37,38,39] = 09:00-10:00 con slot 15min).
-- -----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS staff_planning_week_template (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    staff_planning_id INT UNSIGNED NOT NULL,
    week_label ENUM('A', 'B') NOT NULL DEFAULT 'A',
    day_of_week TINYINT UNSIGNED NOT NULL,
    slots JSON NOT NULL,
    
    PRIMARY KEY (id),
    
    -- FK verso staff_planning
    CONSTRAINT fk_staff_planning_week_template_planning
        FOREIGN KEY (staff_planning_id) REFERENCES staff_planning(id)
        ON DELETE CASCADE
        ON UPDATE CASCADE,
    
    -- Unicit√†: un solo record per (planning, settimana, giorno)
    UNIQUE KEY uk_planning_week_day (staff_planning_id, week_label, day_of_week),
    
    -- Indice per ricerche per planning
    INDEX idx_week_template_planning_id (staff_planning_id),
    
    -- Vincolo: day_of_week deve essere 1-7
    CONSTRAINT chk_planning_template_day_of_week CHECK (day_of_week >= 1 AND day_of_week <= 7)
    
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

----- FILE: migrations/FULL_DATABASE_SCHEMA.sql -----

-- ============================================================================
-- FULL DATABASE SCHEMA - Agenda Platform
-- Generated: 2025-12-28
-- Description: Schema completo per deploy produzione (unico file)
-- Database: MySQL 8.0+ / MariaDB 10.5+
-- 
-- USAGE:
-- 1. Create empty database in phpMyAdmin
-- 2. Import this file
-- 3. (Optional) Run seed_data.sql for demo data
-- ============================================================================

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ============================================================================
-- SECTION 1: CORE TABLES (from 0001_init.sql)
-- ============================================================================

-- ----------------------------------------------------------------------------
-- businesses: Tenant principale
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS businesses (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    name VARCHAR(255) NOT NULL,
    slug VARCHAR(100) NOT NULL,
    email VARCHAR(255) DEFAULT NULL,
    phone VARCHAR(50) DEFAULT NULL,
    timezone VARCHAR(50) NOT NULL DEFAULT 'Europe/Rome',
    currency VARCHAR(3) NOT NULL DEFAULT 'EUR',
    cancellation_hours INT UNSIGNED NOT NULL DEFAULT 24 
        COMMENT 'Default hours before appointment when cancellation/modification is allowed',
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY uk_businesses_slug (slug),
    KEY idx_businesses_active (is_active)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- locations: Sedi fisiche di un business
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS locations (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    name VARCHAR(255) NOT NULL,
    address VARCHAR(500) DEFAULT NULL,
    city VARCHAR(100) DEFAULT NULL,
    postal_code VARCHAR(20) DEFAULT NULL COMMENT 'Postal/ZIP code',
    region VARCHAR(100) DEFAULT NULL,
    country VARCHAR(100) NOT NULL DEFAULT 'IT',
    phone VARCHAR(50) DEFAULT NULL,
    email VARCHAR(255) DEFAULT NULL,
    latitude DECIMAL(10,8) DEFAULT NULL,
    longitude DECIMAL(11,8) DEFAULT NULL,
    timezone VARCHAR(50) DEFAULT 'Europe/Rome' COMMENT 'Location timezone',
    currency VARCHAR(3) DEFAULT NULL COMMENT 'Override business currency',
    cancellation_hours INT UNSIGNED DEFAULT NULL 
        COMMENT 'Override business cancellation policy. NULL = use business default',
    is_default TINYINT(1) NOT NULL DEFAULT 0,
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_locations_business (business_id),
    KEY idx_locations_business_default (business_id, is_default),
    KEY idx_locations_postal_code (postal_code),
    KEY idx_locations_cancellation (business_id, cancellation_hours),
    CONSTRAINT fk_locations_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- location_schedules: Define working hours for each location by day of week
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS location_schedules (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    location_id INT UNSIGNED NOT NULL,
    day_of_week TINYINT UNSIGNED NOT NULL COMMENT '0=Sunday, 1=Monday, ..., 6=Saturday',
    open_time TIME NOT NULL COMMENT 'Opening time (e.g., 09:00:00)',
    close_time TIME NOT NULL COMMENT 'Closing time (e.g., 18:00:00)',
    is_closed TINYINT(1) NOT NULL DEFAULT 0 COMMENT 'Day is closed for business',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY uk_location_schedules (location_id, day_of_week),
    CONSTRAINT fk_location_schedules_location FOREIGN KEY (location_id) 
        REFERENCES locations(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT chk_day_of_week CHECK (day_of_week BETWEEN 0 AND 6),
    CONSTRAINT chk_times CHECK (open_time < close_time OR is_closed = 1)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
COMMENT='Working hours schedule for each location';

-- ----------------------------------------------------------------------------
-- service_categories: Categorie di servizi
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS service_categories (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT DEFAULT NULL,
    sort_order INT NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_service_categories_business (business_id),
    KEY idx_service_categories_sort (business_id, sort_order),
    CONSTRAINT fk_service_categories_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- services: Servizi offerti
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS services (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    category_id INT UNSIGNED NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT DEFAULT NULL,
    sort_order INT NOT NULL DEFAULT 0,
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_services_business (business_id),
    KEY idx_services_category (category_id),
    KEY idx_services_sort (business_id, category_id, sort_order),
    CONSTRAINT fk_services_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_services_category FOREIGN KEY (category_id) 
        REFERENCES service_categories(id) ON DELETE RESTRICT ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- service_variants: Varianti per location (durata, prezzo, disponibilit√†)
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS service_variants (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    service_id INT UNSIGNED NOT NULL,
    location_id INT UNSIGNED NOT NULL,
    duration_minutes INT UNSIGNED NOT NULL,
    processing_time INT UNSIGNED DEFAULT NULL COMMENT 'Minuti post-lavorazione',
    blocked_time INT UNSIGNED DEFAULT NULL COMMENT 'Minuti bloccati',
    price DECIMAL(10,2) NOT NULL DEFAULT 0.00,
    currency VARCHAR(3) DEFAULT NULL COMMENT 'Override location currency',
    color_hex VARCHAR(7) DEFAULT NULL COMMENT 'Es. #FF5733',
    is_bookable_online TINYINT(1) NOT NULL DEFAULT 1,
    is_free TINYINT(1) NOT NULL DEFAULT 0,
    is_price_starting_from TINYINT(1) NOT NULL DEFAULT 0 COMMENT 'Mostra "da ‚Ç¨X"',
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY uk_service_variants_service_location (service_id, location_id),
    KEY idx_service_variants_location (location_id),
    KEY idx_service_variants_bookable (location_id, is_bookable_online, is_active),
    CONSTRAINT fk_service_variants_service FOREIGN KEY (service_id) 
        REFERENCES services(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_service_variants_location FOREIGN KEY (location_id) 
        REFERENCES locations(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- staff: Operatori/dipendenti
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS staff (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    name VARCHAR(100) NOT NULL,
    surname VARCHAR(100) NOT NULL DEFAULT '',
    color_hex VARCHAR(7) NOT NULL DEFAULT '#FFD700',
    avatar_url VARCHAR(500) DEFAULT NULL,
    sort_order INT NOT NULL DEFAULT 0,
    is_default TINYINT(1) NOT NULL DEFAULT 0,
    is_bookable_online TINYINT(1) NOT NULL DEFAULT 1,
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_staff_business (business_id),
    KEY idx_staff_sort (business_id, sort_order),
    KEY idx_staff_bookable (business_id, is_bookable_online, is_active),
    CONSTRAINT fk_staff_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- staff_locations: Relazione N:M staff <-> locations
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS staff_locations (
    staff_id INT UNSIGNED NOT NULL,
    location_id INT UNSIGNED NOT NULL,
    PRIMARY KEY (staff_id, location_id),
    KEY idx_staff_locations_location (location_id),
    CONSTRAINT fk_staff_locations_staff FOREIGN KEY (staff_id) 
        REFERENCES staff(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_staff_locations_location FOREIGN KEY (location_id) 
        REFERENCES locations(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- staff_services: Define which services each staff member can perform
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS staff_services (
    staff_id INT UNSIGNED NOT NULL,
    service_id INT UNSIGNED NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (staff_id, service_id),
    KEY idx_staff_services_service (service_id),
    CONSTRAINT fk_staff_services_staff FOREIGN KEY (staff_id) 
        REFERENCES staff(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_staff_services_service FOREIGN KEY (service_id) 
        REFERENCES services(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
COMMENT='Services that each staff member is qualified to perform';

-- ----------------------------------------------------------------------------
-- staff_schedules: Define working hours for each staff member by day of week
-- Supports multiple time ranges per day (e.g., morning + afternoon shift)
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS staff_schedules (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    staff_id INT UNSIGNED NOT NULL,
    day_of_week TINYINT UNSIGNED NOT NULL COMMENT '1=Monday, 2=Tuesday, ..., 7=Sunday (ISO 8601)',
    start_time TIME NOT NULL COMMENT 'Shift start time (e.g., 09:00:00)',
    end_time TIME NOT NULL COMMENT 'Shift end time (e.g., 13:00:00)',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_staff_schedules_staff (staff_id),
    KEY idx_staff_schedules_day (staff_id, day_of_week),
    CONSTRAINT fk_staff_schedules_staff FOREIGN KEY (staff_id) 
        REFERENCES staff(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT chk_staff_day_of_week CHECK (day_of_week BETWEEN 1 AND 7),
    CONSTRAINT chk_staff_times CHECK (start_time < end_time)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
COMMENT='Working hours schedule for each staff member. Multiple rows per day allowed for split shifts.';

-- ----------------------------------------------------------------------------
-- clients: Clienti gestiti dal business (anagrafica gestionale)
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS clients (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    user_id INT UNSIGNED DEFAULT NULL COMMENT 'Link a user se registrato online',
    first_name VARCHAR(100) DEFAULT NULL,
    last_name VARCHAR(100) DEFAULT NULL,
    email VARCHAR(255) DEFAULT NULL,
    phone VARCHAR(50) DEFAULT NULL,
    gender VARCHAR(20) DEFAULT NULL,
    birth_date DATE DEFAULT NULL,
    city VARCHAR(100) DEFAULT NULL,
    notes TEXT DEFAULT NULL,
    loyalty_points INT NOT NULL DEFAULT 0,
    last_visit TIMESTAMP NULL DEFAULT NULL,
    is_archived TINYINT(1) NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_clients_business (business_id),
    KEY idx_clients_business_email (business_id, email),
    KEY idx_clients_business_phone (business_id, phone),
    KEY idx_clients_business_archived (business_id, is_archived),
    KEY idx_clients_user (user_id),
    CONSTRAINT fk_clients_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- resources: Risorse fisiche (cabine, attrezzature) - opzionale MVP+
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS resources (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    location_id INT UNSIGNED NOT NULL,
    name VARCHAR(255) NOT NULL,
    quantity INT UNSIGNED NOT NULL DEFAULT 1,
    type VARCHAR(100) DEFAULT NULL,
    note TEXT DEFAULT NULL,
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_resources_location (location_id),
    CONSTRAINT fk_resources_location FOREIGN KEY (location_id) 
        REFERENCES locations(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ============================================================================
-- SECTION 2: AUTHENTICATION TABLES (from 0002_auth.sql)
-- ============================================================================

-- ----------------------------------------------------------------------------
-- users: Identit√† GLOBALE per autenticazione
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS users (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    email VARCHAR(255) NOT NULL,
    password_hash VARCHAR(255) NOT NULL COMMENT 'bcrypt or argon2id hash',
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    phone VARCHAR(50) DEFAULT NULL,
    email_verified_at TIMESTAMP NULL DEFAULT NULL,
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    is_superadmin TINYINT(1) NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY uk_users_email (email),
    KEY idx_users_active (is_active),
    KEY idx_users_created (created_at),
    KEY idx_users_superadmin (is_superadmin)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- auth_sessions: Sessioni con refresh token
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS auth_sessions (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    user_id INT UNSIGNED NOT NULL,
    refresh_token_hash VARCHAR(64) NOT NULL COMMENT 'SHA-256 hex of refresh token',
    user_agent VARCHAR(500) DEFAULT NULL COMMENT 'Browser/app identification',
    ip_address VARCHAR(45) DEFAULT NULL COMMENT 'IPv4 or IPv6',
    expires_at TIMESTAMP NOT NULL COMMENT 'Refresh token expiration',
    last_used_at TIMESTAMP NULL DEFAULT NULL COMMENT 'Last refresh attempt',
    revoked_at TIMESTAMP NULL DEFAULT NULL COMMENT 'Manual revocation timestamp',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY uk_auth_sessions_token (refresh_token_hash),
    KEY idx_auth_sessions_user (user_id),
    KEY idx_auth_sessions_user_active (user_id, revoked_at, expires_at),
    KEY idx_auth_sessions_expires (expires_at),
    CONSTRAINT fk_auth_sessions_user FOREIGN KEY (user_id) 
        REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- password_reset_tokens: Token per reset password
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS password_reset_token_users (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    user_id INT UNSIGNED NOT NULL,
    token_hash VARCHAR(64) NOT NULL COMMENT 'SHA-256 hex of reset token',
    expires_at TIMESTAMP NOT NULL,
    used_at TIMESTAMP NULL DEFAULT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY uk_password_reset_token (token_hash),
    KEY idx_password_reset_user (user_id),
    KEY idx_password_reset_expires (expires_at),
    CONSTRAINT fk_password_reset_user FOREIGN KEY (user_id) 
        REFERENCES users(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- Add FK from clients to users
ALTER TABLE clients
    ADD CONSTRAINT fk_clients_user FOREIGN KEY (user_id) 
        REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE;

-- ============================================================================
-- SECTION 3: BUSINESS USERS & INVITATIONS (from 0013, 0014)
-- ============================================================================

-- ----------------------------------------------------------------------------
-- business_users: Links users to businesses with role-based access
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS business_users (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    business_id INT UNSIGNED NOT NULL,
    user_id INT UNSIGNED NOT NULL,
    role ENUM('owner', 'admin', 'manager', 'staff') NOT NULL DEFAULT 'staff',
    staff_id INT UNSIGNED NULL,
    can_manage_bookings TINYINT(1) NOT NULL DEFAULT 1,
    can_manage_clients TINYINT(1) NOT NULL DEFAULT 1,
    can_manage_services TINYINT(1) NOT NULL DEFAULT 0,
    can_manage_staff TINYINT(1) NOT NULL DEFAULT 0,
    can_view_reports TINYINT(1) NOT NULL DEFAULT 0,
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    invited_by INT UNSIGNED NULL,
    invited_at TIMESTAMP NULL,
    accepted_at TIMESTAMP NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    CONSTRAINT fk_business_users_business 
        FOREIGN KEY (business_id) REFERENCES businesses(id) ON DELETE CASCADE,
    CONSTRAINT fk_business_users_user 
        FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_business_users_staff 
        FOREIGN KEY (staff_id) REFERENCES staff(id) ON DELETE SET NULL,
    CONSTRAINT fk_business_users_invited_by 
        FOREIGN KEY (invited_by) REFERENCES users(id) ON DELETE SET NULL,
    CONSTRAINT uk_business_user UNIQUE (business_id, user_id),
    KEY idx_business_users_user_active (user_id, is_active),
    KEY idx_business_users_business_role (business_id, role, is_active),
    KEY idx_business_users_staff (staff_id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- business_invitations: Email-based invites
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS business_invitations (
    id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
    business_id INT UNSIGNED NOT NULL,
    email VARCHAR(255) NOT NULL,
    role ENUM('admin', 'manager', 'staff') NOT NULL DEFAULT 'staff',
    token VARCHAR(64) NOT NULL,
    expires_at TIMESTAMP NOT NULL,
    status ENUM('pending', 'accepted', 'expired', 'revoked') NOT NULL DEFAULT 'pending',
    accepted_by INT UNSIGNED NULL,
    accepted_at TIMESTAMP NULL,
    invited_by INT UNSIGNED NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    CONSTRAINT fk_invitations_business 
        FOREIGN KEY (business_id) REFERENCES businesses(id) ON DELETE CASCADE,
    CONSTRAINT fk_invitations_invited_by 
        FOREIGN KEY (invited_by) REFERENCES users(id) ON DELETE CASCADE,
    CONSTRAINT fk_invitations_accepted_by 
        FOREIGN KEY (accepted_by) REFERENCES users(id) ON DELETE SET NULL,
    CONSTRAINT uk_invitation_token UNIQUE (token),
    CONSTRAINT uk_pending_invitation UNIQUE (business_id, email, status),
    KEY idx_invitations_token (token, status),
    KEY idx_invitations_business_status (business_id, status),
    KEY idx_invitations_email_status (email, status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ============================================================================
-- SECTION 4: BOOKING TABLES (from 0003_booking.sql)
-- ============================================================================

-- ----------------------------------------------------------------------------
-- bookings: Prenotazioni (contenitore di uno o pi√π servizi)
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS bookings (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    location_id INT UNSIGNED NOT NULL,
    client_id INT UNSIGNED DEFAULT NULL COMMENT 'Client from business anagrafica',
    user_id INT UNSIGNED DEFAULT NULL COMMENT 'User who booked online',
    client_name VARCHAR(255) DEFAULT NULL COMMENT 'Fallback if no client',
    notes TEXT DEFAULT NULL,
    status ENUM('pending', 'confirmed', 'completed', 'cancelled', 'no_show') 
        NOT NULL DEFAULT 'confirmed',
    source ENUM('online', 'manual', 'import') NOT NULL DEFAULT 'manual',
    idempotency_key VARCHAR(64) DEFAULT NULL COMMENT 'Client-provided UUID for idempotent POST',
    idempotency_expires_at TIMESTAMP NULL DEFAULT NULL COMMENT 'Key expiration (24h TTL)',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY uk_bookings_idempotency (business_id, idempotency_key),
    KEY idx_bookings_business_location (business_id, location_id),
    KEY idx_bookings_business_location_created (business_id, location_id, created_at),
    KEY idx_bookings_client (client_id),
    KEY idx_bookings_user (user_id),
    KEY idx_bookings_status (business_id, status),
    KEY idx_bookings_idempotency_expires (idempotency_expires_at),
    CONSTRAINT fk_bookings_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_bookings_location FOREIGN KEY (location_id) 
        REFERENCES locations(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_bookings_client FOREIGN KEY (client_id) 
        REFERENCES clients(id) ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT fk_bookings_user FOREIGN KEY (user_id) 
        REFERENCES users(id) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- booking_items: Singoli appuntamenti dentro una booking
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS booking_items (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    booking_id INT UNSIGNED NOT NULL,
    location_id INT UNSIGNED NOT NULL COMMENT 'Denormalized from bookings for availability queries',
    service_id INT UNSIGNED NOT NULL,
    service_variant_id INT UNSIGNED NOT NULL,
    staff_id INT UNSIGNED NOT NULL,
    start_time TIMESTAMP NOT NULL COMMENT 'UTC',
    end_time TIMESTAMP NOT NULL COMMENT 'UTC',
    price DECIMAL(10,2) DEFAULT NULL COMMENT 'Applied price at booking time',
    extra_blocked_minutes INT UNSIGNED NOT NULL DEFAULT 0,
    extra_processing_minutes INT UNSIGNED NOT NULL DEFAULT 0,
    service_name_snapshot VARCHAR(255) DEFAULT NULL,
    client_name_snapshot VARCHAR(255) DEFAULT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_booking_items_booking (booking_id),
    KEY idx_booking_items_staff_time (staff_id, start_time, end_time),
    KEY idx_booking_items_location_time (location_id, start_time, end_time),
    KEY idx_booking_items_service (service_id),
    KEY idx_booking_items_variant (service_variant_id),
    CONSTRAINT fk_booking_items_booking FOREIGN KEY (booking_id) 
        REFERENCES bookings(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_booking_items_location FOREIGN KEY (location_id) 
        REFERENCES locations(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_booking_items_service FOREIGN KEY (service_id) 
        REFERENCES services(id) ON DELETE RESTRICT ON UPDATE CASCADE,
    CONSTRAINT fk_booking_items_variant FOREIGN KEY (service_variant_id) 
        REFERENCES service_variants(id) ON DELETE RESTRICT ON UPDATE CASCADE,
    CONSTRAINT fk_booking_items_staff FOREIGN KEY (staff_id) 
        REFERENCES staff(id) ON DELETE RESTRICT ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- time_blocks: Blocchi di non disponibilit√† (ferie, pause, riunioni)
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS time_blocks (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    location_id INT UNSIGNED NOT NULL,
    start_time TIMESTAMP NOT NULL,
    end_time TIMESTAMP NOT NULL,
    reason VARCHAR(255) DEFAULT NULL,
    is_all_day TINYINT(1) NOT NULL DEFAULT 0,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_time_blocks_business_location (business_id, location_id),
    KEY idx_time_blocks_time (start_time, end_time),
    CONSTRAINT fk_time_blocks_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_time_blocks_location FOREIGN KEY (location_id) 
        REFERENCES locations(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ----------------------------------------------------------------------------
-- time_block_staff: Relazione N:M time_blocks <-> staff
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS time_block_staff (
    time_block_id INT UNSIGNED NOT NULL,
    staff_id INT UNSIGNED NOT NULL,
    PRIMARY KEY (time_block_id, staff_id),
    KEY idx_time_block_staff_staff (staff_id),
    CONSTRAINT fk_time_block_staff_block FOREIGN KEY (time_block_id) 
        REFERENCES time_blocks(id) ON DELETE CASCADE ON UPDATE CASCADE,
    CONSTRAINT fk_time_block_staff_staff FOREIGN KEY (staff_id) 
        REFERENCES staff(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

-- ============================================================================
-- SECTION 5: WEBHOOKS (from 0008_webhook_infrastructure.sql)
-- ============================================================================

-- ----------------------------------------------------------------------------
-- webhook_endpoints: Registered webhook endpoints for businesses
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS webhook_endpoints (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    url VARCHAR(500) NOT NULL,
    secret VARCHAR(255) NOT NULL COMMENT 'Used to sign webhook payloads',
    events JSON NOT NULL COMMENT 'Array of event types to subscribe to',
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_webhook_endpoints_business (business_id),
    KEY idx_webhook_endpoints_active (business_id, is_active),
    CONSTRAINT fk_webhook_endpoints_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
COMMENT='Webhook endpoints registered by businesses';

-- ----------------------------------------------------------------------------
-- webhook_deliveries: Log of webhook delivery attempts
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS webhook_deliveries (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    webhook_endpoint_id INT UNSIGNED NOT NULL,
    event_type VARCHAR(100) NOT NULL COMMENT 'booking.created, booking.updated, etc.',
    payload JSON NOT NULL,
    http_status_code INT UNSIGNED NULL COMMENT 'HTTP response code',
    response_body TEXT NULL COMMENT 'Response from webhook endpoint',
    attempt_count INT UNSIGNED NOT NULL DEFAULT 0,
    next_retry_at TIMESTAMP NULL COMMENT 'When to retry if failed',
    delivered_at TIMESTAMP NULL COMMENT 'When successfully delivered',
    failed_at TIMESTAMP NULL COMMENT 'When permanently failed',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_webhook_deliveries_endpoint (webhook_endpoint_id),
    KEY idx_webhook_deliveries_retry (next_retry_at, delivered_at, failed_at),
    KEY idx_webhook_deliveries_event (event_type, created_at),
    CONSTRAINT fk_webhook_deliveries_endpoint FOREIGN KEY (webhook_endpoint_id) 
        REFERENCES webhook_endpoints(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
COMMENT='Log of webhook delivery attempts with retry tracking';

-- ============================================================================
-- SECTION 6: NOTIFICATIONS (from 0015_notification_queue.sql)
-- ============================================================================

-- ----------------------------------------------------------------------------
-- notification_queue: Queue for async notification processing
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS notification_queue (
    id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT,
    type ENUM('email', 'sms', 'push', 'webhook') NOT NULL DEFAULT 'email',
    channel VARCHAR(50) NOT NULL COMMENT 'booking_confirmed, booking_cancelled, reminder_24h, etc.',
    recipient_type ENUM('user', 'client', 'staff') NOT NULL,
    recipient_id INT UNSIGNED NOT NULL,
    recipient_email VARCHAR(255) NULL,
    recipient_phone VARCHAR(20) NULL,
    recipient_name VARCHAR(100) NULL,
    subject VARCHAR(255) NULL COMMENT 'Email subject',
    payload JSON NOT NULL COMMENT 'Template variables and metadata',
    priority TINYINT UNSIGNED NOT NULL DEFAULT 5 COMMENT '1=highest, 10=lowest',
    scheduled_at TIMESTAMP NULL COMMENT 'For scheduled notifications like reminders',
    status ENUM('pending', 'processing', 'sent', 'failed') NOT NULL DEFAULT 'pending',
    attempts INT UNSIGNED NOT NULL DEFAULT 0,
    max_attempts INT UNSIGNED NOT NULL DEFAULT 3,
    last_attempt_at TIMESTAMP NULL,
    sent_at TIMESTAMP NULL,
    failed_at TIMESTAMP NULL,
    error_message TEXT NULL,
    business_id INT UNSIGNED NULL COMMENT 'For business-specific templates',
    booking_id INT UNSIGNED NULL COMMENT 'Reference to related booking',
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    KEY idx_notification_pending (status, scheduled_at, priority),
    KEY idx_notification_business (business_id, channel),
    KEY idx_notification_booking (booking_id),
    KEY idx_notification_recipient (recipient_type, recipient_id),
    CONSTRAINT fk_notification_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE SET NULL ON UPDATE CASCADE,
    CONSTRAINT fk_notification_booking FOREIGN KEY (booking_id) 
        REFERENCES bookings(id) ON DELETE SET NULL ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
COMMENT='Queue for async notification processing';

-- ----------------------------------------------------------------------------
-- notification_templates: Custom templates per business
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS notification_templates (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    channel VARCHAR(50) NOT NULL COMMENT 'booking_confirmed, booking_cancelled, etc.',
    type ENUM('email', 'sms') NOT NULL DEFAULT 'email',
    subject VARCHAR(255) NULL COMMENT 'Email subject with {{placeholders}}',
    body_html TEXT NULL COMMENT 'HTML body for email',
    body_text TEXT NULL COMMENT 'Plain text body for SMS or email fallback',
    is_active TINYINT(1) NOT NULL DEFAULT 1,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY uk_business_channel_type (business_id, channel, type),
    CONSTRAINT fk_notification_templates_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
COMMENT='Custom notification templates per business';

-- ----------------------------------------------------------------------------
-- notification_settings: Business notification preferences
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS notification_settings (
    id INT UNSIGNED NOT NULL AUTO_INCREMENT,
    business_id INT UNSIGNED NOT NULL,
    email_enabled TINYINT(1) NOT NULL DEFAULT 1,
    email_booking_confirmed TINYINT(1) NOT NULL DEFAULT 1,
    email_booking_cancelled TINYINT(1) NOT NULL DEFAULT 1,
    email_booking_rescheduled TINYINT(1) NOT NULL DEFAULT 1,
    email_reminder_enabled TINYINT(1) NOT NULL DEFAULT 1,
    email_reminder_hours INT UNSIGNED NOT NULL DEFAULT 24 COMMENT 'Hours before appointment',
    sms_enabled TINYINT(1) NOT NULL DEFAULT 0,
    sms_reminder_enabled TINYINT(1) NOT NULL DEFAULT 0,
    sms_reminder_hours INT UNSIGNED NOT NULL DEFAULT 24,
    sender_name VARCHAR(100) NULL COMMENT 'Custom from name',
    reply_to_email VARCHAR(255) NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    PRIMARY KEY (id),
    UNIQUE KEY uk_business (business_id),
    CONSTRAINT fk_notification_settings_business FOREIGN KEY (business_id) 
        REFERENCES businesses(id) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci
COMMENT='Business notification preferences';

-- ============================================================================
-- RE-ENABLE FOREIGN KEY CHECKS
-- ============================================================================
SET FOREIGN_KEY_CHECKS = 1;

-- ============================================================================
-- END OF SCHEMA
-- ============================================================================

=======================================
----- FILE: public/index.php -----

<?php

/**
 * Agenda Core - Entry Point
 * 
 * Struttura: public/ contiene index.php e .htaccess
 * Deploy SiteGround: public/ ‚Üí mappata come public_html/
 */

declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use Agenda\Http\Kernel;
use Agenda\Http\Request;

$dotenv = Dotenv\Dotenv::createImmutable(__DIR__ . '/..');
$dotenv->safeLoad();

date_default_timezone_set($_ENV['APP_TIMEZONE'] ?? 'UTC');

$allowedOrigins = array_map('trim', explode(',', $_ENV['CORS_ALLOWED_ORIGINS'] ?? '*'));
$requestOrigin = $_SERVER['HTTP_ORIGIN'] ?? '';
$corsOrigin = in_array($requestOrigin, $allowedOrigins, true) ? $requestOrigin : ($allowedOrigins[0] ?? '*');

if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    header('Access-Control-Allow-Origin: ' . $corsOrigin);
    header('Access-Control-Allow-Methods: GET, POST, PUT, PATCH, DELETE, OPTIONS');
    header('Access-Control-Allow-Headers: Content-Type, Authorization, Idempotency-Key, X-Idempotency-Key');
    header('Access-Control-Allow-Credentials: true');
    header('Access-Control-Max-Age: 86400');
    http_response_code(204);
    exit;
}

$request = Request::fromGlobals();
$kernel = new Kernel();
$response = $kernel->handle($request);
$response->send();

----- FILE: src/Http/Kernel.php -----

<?php

declare(strict_types=1);

namespace Agenda\Http;

use Agenda\Http\Controllers\AuthController;
use Agenda\Http\Controllers\AvailabilityController;
use Agenda\Http\Controllers\BookingsController;
use Agenda\Http\Controllers\BusinessController;
use Agenda\Http\Controllers\AdminBusinessesController;
use Agenda\Http\Controllers\BusinessUsersController;
use Agenda\Http\Controllers\BusinessInvitationsController;
use Agenda\Http\Controllers\ClientsController;
use Agenda\Http\Controllers\CustomerAuthController;
use Agenda\Http\Controllers\HealthController;
use Agenda\Http\Controllers\LocationsController;
use Agenda\Http\Controllers\ServicesController;
use Agenda\Http\Controllers\StaffController;
use Agenda\Http\Controllers\StaffAvailabilityExceptionController;
use Agenda\Http\Controllers\StaffPlanningController;
use Agenda\Http\Controllers\ResourcesController;
use Agenda\Http\Controllers\TimeBlocksController;
use Agenda\Http\Controllers\AppointmentsController;
use Agenda\Http\Middleware\AuthMiddleware;
use Agenda\Http\Middleware\BusinessAccessMiddleware;
use Agenda\Http\Middleware\CustomerAuthMiddleware;
use Agenda\Http\Middleware\IdempotencyMiddleware;
use Agenda\Http\Middleware\LocationContextMiddleware;
use Agenda\Infrastructure\Database\Connection;
use Agenda\Infrastructure\Logger\Logger;
use Agenda\Infrastructure\Repositories\AuthSessionRepository;
use Agenda\Infrastructure\Repositories\BookingRepository;
use Agenda\Infrastructure\Repositories\BusinessRepository;
use Agenda\Infrastructure\Repositories\BusinessUserRepository;
use Agenda\Infrastructure\Repositories\BusinessInvitationRepository;
use Agenda\Infrastructure\Repositories\ClientAuthRepository;
use Agenda\Infrastructure\Repositories\ClientRepository;
use Agenda\Infrastructure\Repositories\LocationRepository;
use Agenda\Infrastructure\Repositories\ServiceRepository;
use Agenda\Infrastructure\Repositories\StaffRepository;
use Agenda\Infrastructure\Repositories\StaffScheduleRepository;
use Agenda\Infrastructure\Repositories\StaffAvailabilityExceptionRepository;
use Agenda\Infrastructure\Repositories\StaffPlanningRepository;
use Agenda\Infrastructure\Repositories\ResourceRepository;
use Agenda\Infrastructure\Repositories\TimeBlockRepository;
use Agenda\Infrastructure\Repositories\UserRepository;
use Agenda\Infrastructure\Security\JwtService;
use Agenda\Infrastructure\Security\PasswordHasher;
use Agenda\UseCases\Auth\GetMe;
use Agenda\UseCases\Auth\LoginUser;
use Agenda\UseCases\Auth\LogoutUser;
use Agenda\UseCases\Auth\RefreshToken;
use Agenda\UseCases\Auth\RegisterUser;
use Agenda\UseCases\Auth\RequestPasswordReset;
use Agenda\UseCases\Auth\ResetPassword;
use Agenda\UseCases\Auth\VerifyResetToken;
use Agenda\UseCases\Auth\ChangePassword;
use Agenda\UseCases\Auth\UpdateProfile;
use Agenda\UseCases\Booking\ComputeAvailability;
use Agenda\UseCases\Booking\CreateBooking;
use Agenda\UseCases\Booking\UpdateBooking;
use Agenda\UseCases\Booking\DeleteBooking;
use Agenda\UseCases\Booking\GetMyBookings;
use Agenda\UseCases\CustomerAuth\LoginCustomer;
use Agenda\UseCases\CustomerAuth\RegisterCustomer;
use Agenda\UseCases\CustomerAuth\RefreshCustomerToken;
use Agenda\UseCases\CustomerAuth\LogoutCustomer;
use Agenda\UseCases\CustomerAuth\GetCustomerMe;
use Agenda\UseCases\CustomerAuth\RequestCustomerPasswordReset;
use Agenda\UseCases\CustomerAuth\ResetCustomerPassword;
use Agenda\UseCases\CustomerAuth\UpdateCustomerProfile;
use Agenda\UseCases\CustomerAuth\ChangeCustomerPassword;
use Throwable;

final class Kernel
{
    private Router $router;
    private Connection $db;
    private Logger $logger;
    private array $middleware = [];
    private array $controllers = [];

    public function __construct()
    {
        $this->db = new Connection();
        $this->logger = new Logger();
        $this->router = new Router();
        
        $this->registerRoutes();
        $this->registerMiddleware();
        $this->registerControllers();
    }

    private function registerRoutes(): void
    {
        // Health check (no auth, no business context)
        $this->router->get('/health', HealthController::class, 'check');

        // Auth (no business context)
        $this->router->post('/v1/auth/login', AuthController::class, 'login');
        $this->router->post('/v1/auth/register', AuthController::class, 'register');
        $this->router->post('/v1/auth/refresh', AuthController::class, 'refresh');
        $this->router->post('/v1/auth/logout', AuthController::class, 'logout', ['auth']);
        $this->router->post('/v1/auth/forgot-password', AuthController::class, 'forgotPassword');
        $this->router->get('/v1/auth/verify-reset-token/{token}', AuthController::class, 'verifyResetTokenAction');
        $this->router->post('/v1/auth/reset-password', AuthController::class, 'resetPasswordAction');
        $this->router->get('/v1/me', AuthController::class, 'me', ['auth']);
        $this->router->put('/v1/me', AuthController::class, 'updateMe', ['auth']);
        $this->router->post('/v1/me/change-password', AuthController::class, 'changePassword', ['auth']);
        $this->router->get('/v1/me/bookings', BookingsController::class, 'myBookings', ['auth']);
        $this->router->get('/v1/me/businesses', AdminBusinessesController::class, 'myBusinesses', ['auth']);

        // Admin/Superadmin endpoints
        $this->router->get('/v1/admin/businesses', AdminBusinessesController::class, 'index', ['auth']);
        $this->router->post('/v1/admin/businesses', AdminBusinessesController::class, 'store', ['auth']);
        $this->router->put('/v1/admin/businesses/{id}', AdminBusinessesController::class, 'update', ['auth']);
        $this->router->delete('/v1/admin/businesses/{id}', AdminBusinessesController::class, 'destroy', ['auth']);
        $this->router->post('/v1/admin/businesses/{id}/resend-invite', AdminBusinessesController::class, 'resendInvite', ['auth']);

        // Businesses - Public endpoint for subdomain resolution
        $this->router->get('/v1/businesses/by-slug/{slug}', BusinessController::class, 'showBySlug');
        // Public locations for a business (for booking flow)
        $this->router->get('/v1/businesses/{business_id}/locations/public', LocationsController::class, 'indexPublic');

        // Businesses and Locations (auth required)
        $this->router->get('/v1/businesses', BusinessController::class, 'index', ['auth']);
        $this->router->get('/v1/businesses/{id}', BusinessController::class, 'show', ['auth']);
        $this->router->get('/v1/businesses/{business_id}/locations', LocationsController::class, 'index', ['auth']);
        $this->router->post('/v1/businesses/{business_id}/locations', LocationsController::class, 'store', ['auth']);
        $this->router->get('/v1/locations/{id}', LocationsController::class, 'show', ['auth']);
        $this->router->put('/v1/locations/{id}', LocationsController::class, 'update', ['auth']);
        $this->router->delete('/v1/locations/{id}', LocationsController::class, 'destroy', ['auth']);
        $this->router->post('/v1/locations/reorder', LocationsController::class, 'reorder', ['auth']);

        // Staff management (auth required)
        $this->router->get('/v1/businesses/{business_id}/staff', StaffController::class, 'indexByBusiness', ['auth']);
        $this->router->post('/v1/businesses/{business_id}/staff', StaffController::class, 'store', ['auth']);
        $this->router->put('/v1/staff/{id}', StaffController::class, 'update', ['auth']);
        $this->router->delete('/v1/staff/{id}', StaffController::class, 'destroy', ['auth']);
        $this->router->post('/v1/staff/reorder', StaffController::class, 'reorder', ['auth']);

        // Staff schedules (auth required)
        $this->router->get('/v1/businesses/{business_id}/staff/schedules', StaffController::class, 'indexSchedules', ['auth']);
        $this->router->get('/v1/staff/{id}/schedules', StaffController::class, 'showSchedule', ['auth']);
        $this->router->put('/v1/staff/{id}/schedules', StaffController::class, 'updateSchedule', ['auth']);

        // Staff availability exceptions (auth required)
        $this->router->get('/v1/businesses/{business_id}/staff/availability-exceptions', StaffAvailabilityExceptionController::class, 'indexForBusiness', ['auth']);
        $this->router->get('/v1/staff/{id}/availability-exceptions', StaffAvailabilityExceptionController::class, 'indexForStaff', ['auth']);
        $this->router->post('/v1/staff/{id}/availability-exceptions', StaffAvailabilityExceptionController::class, 'store', ['auth']);
        $this->router->put('/v1/staff/availability-exceptions/{id}', StaffAvailabilityExceptionController::class, 'update', ['auth']);
        $this->router->delete('/v1/staff/availability-exceptions/{id}', StaffAvailabilityExceptionController::class, 'destroy', ['auth']);

        // Staff planning (auth required)
        $this->router->get('/v1/staff/{id}/plannings', StaffPlanningController::class, 'indexForStaff', ['auth']);
        $this->router->get('/v1/staff/{id}/planning', StaffPlanningController::class, 'showForDate', ['auth']);
        $this->router->get('/v1/staff/{id}/planning/{planning_id}', StaffPlanningController::class, 'show', ['auth']);
        $this->router->get('/v1/staff/{id}/planning-availability', StaffPlanningController::class, 'availabilityForDate', ['auth']);
        $this->router->post('/v1/staff/{id}/plannings', StaffPlanningController::class, 'store', ['auth']);
        $this->router->put('/v1/staff/{id}/plannings/{planning_id}', StaffPlanningController::class, 'update', ['auth']);
        $this->router->delete('/v1/staff/{id}/plannings/{planning_id}', StaffPlanningController::class, 'destroy', ['auth']);

        // Resources (auth required)
        $this->router->get('/v1/businesses/{business_id}/resources', ResourcesController::class, 'indexByBusiness', ['auth']);
        $this->router->get('/v1/locations/{location_id}/resources', ResourcesController::class, 'indexByLocation', ['auth']);
        $this->router->post('/v1/locations/{location_id}/resources', ResourcesController::class, 'store', ['auth']);
        $this->router->put('/v1/resources/{id}', ResourcesController::class, 'update', ['auth']);
        $this->router->delete('/v1/resources/{id}', ResourcesController::class, 'destroy', ['auth']);

        // Business Users (operators management)
        $this->router->get('/v1/businesses/{business_id}/users', BusinessUsersController::class, 'index', ['auth']);
        $this->router->post('/v1/businesses/{business_id}/users', BusinessUsersController::class, 'store', ['auth']);
        $this->router->patch('/v1/businesses/{business_id}/users/{target_user_id}', BusinessUsersController::class, 'update', ['auth']);
        $this->router->delete('/v1/businesses/{business_id}/users/{target_user_id}', BusinessUsersController::class, 'destroy', ['auth']);

        // Business Invitations
        $this->router->get('/v1/businesses/{business_id}/invitations', BusinessInvitationsController::class, 'index', ['auth']);
        $this->router->post('/v1/businesses/{business_id}/invitations', BusinessInvitationsController::class, 'store', ['auth']);
        $this->router->delete('/v1/businesses/{business_id}/invitations/{invitation_id}', BusinessInvitationsController::class, 'destroy', ['auth']);
        $this->router->get('/v1/invitations/{token}', BusinessInvitationsController::class, 'show');
        $this->router->post('/v1/invitations/{token}/accept', BusinessInvitationsController::class, 'accept', ['auth']);

        // Public (business-scoped via query param)
        $this->router->get('/v1/services', ServicesController::class, 'index', ['location_query']);
        $this->router->get('/v1/staff', StaffController::class, 'index', ['location_query']);
        $this->router->get('/v1/availability', AvailabilityController::class, 'index', ['location_query']);

        // Services CRUD (auth required)
        $this->router->post('/v1/locations/{location_id}/services', ServicesController::class, 'store', ['auth', 'location_path']);
        $this->router->put('/v1/services/{id}', ServicesController::class, 'update', ['auth']);
        $this->router->delete('/v1/services/{id}', ServicesController::class, 'destroy', ['auth']);
        $this->router->post('/v1/services/reorder', ServicesController::class, 'reorderServices', ['auth']);

        // Service Categories CRUD (auth required)
        $this->router->get('/v1/businesses/{business_id}/categories', ServicesController::class, 'indexCategories', ['auth', 'business_access_route']);
        $this->router->post('/v1/businesses/{business_id}/categories', ServicesController::class, 'storeCategory', ['auth', 'business_access_route']);
        $this->router->put('/v1/categories/{id}', ServicesController::class, 'updateCategory', ['auth']);
        $this->router->delete('/v1/categories/{id}', ServicesController::class, 'destroyCategory', ['auth']);
        $this->router->post('/v1/categories/reorder', ServicesController::class, 'reorderCategories', ['auth']);

        // Clients (auth required)
        $this->router->get('/v1/clients', ClientsController::class, 'index', ['auth']);
        $this->router->get('/v1/clients/{id}', ClientsController::class, 'show', ['auth']);
        $this->router->post('/v1/clients', ClientsController::class, 'store', ['auth']);
        $this->router->put('/v1/clients/{id}', ClientsController::class, 'update', ['auth']);
        $this->router->delete('/v1/clients/{id}', ClientsController::class, 'destroy', ['auth']);

        // Bookings (protected, business-scoped via path)
        $this->router->get('/v1/locations/{location_id}/bookings', BookingsController::class, 'index', ['auth', 'location_path']);
        $this->router->get('/v1/locations/{location_id}/bookings/{booking_id}', BookingsController::class, 'show', ['auth', 'location_path']);
        $this->router->post('/v1/locations/{location_id}/bookings', BookingsController::class, 'store', ['auth', 'location_path', 'idempotency']);
        $this->router->put('/v1/locations/{location_id}/bookings/{booking_id}', BookingsController::class, 'update', ['auth', 'location_path']);
        $this->router->delete('/v1/locations/{location_id}/bookings/{booking_id}', BookingsController::class, 'destroy', ['auth', 'location_path']);

        // Time blocks (auth required)
        $this->router->get('/v1/locations/{location_id}/time-blocks', TimeBlocksController::class, 'index', ['auth']);
        $this->router->post('/v1/locations/{location_id}/time-blocks', TimeBlocksController::class, 'store', ['auth']);
        $this->router->put('/v1/time-blocks/{id}', TimeBlocksController::class, 'update', ['auth']);
        $this->router->delete('/v1/time-blocks/{id}', TimeBlocksController::class, 'destroy', ['auth']);

        // Appointments (protected, business-scoped via path)
        $this->router->get('/v1/locations/{location_id}/appointments', AppointmentsController::class, 'index', ['auth', 'location_path']);
        $this->router->get('/v1/locations/{location_id}/appointments/{id}', AppointmentsController::class, 'show', ['auth', 'location_path']);
        $this->router->patch('/v1/locations/{location_id}/appointments/{id}', AppointmentsController::class, 'update', ['auth', 'location_path']);
        $this->router->post('/v1/locations/{location_id}/appointments/{id}/cancel', AppointmentsController::class, 'cancel', ['auth', 'location_path']);
        $this->router->post('/v1/bookings/{booking_id}/items', AppointmentsController::class, 'store', ['auth']);
        $this->router->delete('/v1/bookings/{booking_id}/items/{item_id}', AppointmentsController::class, 'destroyItem', ['auth']);

        // =========================================================================
        // CUSTOMER AUTH (self-service booking)
        // Separate from operator auth - uses clients table, not users table
        // =========================================================================
        $this->router->post('/v1/customer/{business_id}/auth/login', CustomerAuthController::class, 'login');
        $this->router->post('/v1/customer/{business_id}/auth/register', CustomerAuthController::class, 'register');
        $this->router->post('/v1/customer/{business_id}/auth/refresh', CustomerAuthController::class, 'refresh');
        $this->router->post('/v1/customer/{business_id}/auth/logout', CustomerAuthController::class, 'logout');
        $this->router->post('/v1/customer/{business_id}/auth/forgot-password', CustomerAuthController::class, 'forgotPassword');
        $this->router->post('/v1/customer/auth/reset-password', CustomerAuthController::class, 'resetPasswordWithToken');
        $this->router->get('/v1/customer/me', CustomerAuthController::class, 'me', ['customer_auth']);
        $this->router->put('/v1/customer/me', CustomerAuthController::class, 'updateProfile', ['customer_auth']);
        $this->router->post('/v1/customer/me/change-password', CustomerAuthController::class, 'changePassword', ['customer_auth']);
        
        // Customer bookings (protected, uses client_id from customer JWT)
        $this->router->post('/v1/customer/{business_id}/bookings', BookingsController::class, 'storeCustomer', ['customer_auth', 'idempotency']);
        $this->router->get('/v1/customer/bookings', BookingsController::class, 'myCustomerBookings', ['customer_auth']);
    }

    private function registerMiddleware(): void
    {
        $jwtService = new JwtService();
        $locationRepo = new LocationRepository($this->db);
        $businessUserRepo = new BusinessUserRepository($this->db);
        $userRepo = new UserRepository($this->db);

        $this->middleware = [
            'auth' => new AuthMiddleware($jwtService),
            'customer_auth' => new CustomerAuthMiddleware($jwtService),
            'location_path' => new LocationContextMiddleware($locationRepo, 'path'),
            'location_query' => new LocationContextMiddleware($locationRepo, 'query'),
            'idempotency' => new IdempotencyMiddleware(),
            'business_access' => new BusinessAccessMiddleware($businessUserRepo, $userRepo, 'attribute'),
            'business_access_route' => new BusinessAccessMiddleware($businessUserRepo, $userRepo, 'route'),
        ];
    }

    private function registerControllers(): void
    {
        // Repositories
        $userRepo = new UserRepository($this->db);
        $sessionRepo = new AuthSessionRepository($this->db);
        $businessRepo = new BusinessRepository($this->db);
        $businessUserRepo = new BusinessUserRepository($this->db);
        $businessInvitationRepo = new BusinessInvitationRepository($this->db);
        $locationRepo = new LocationRepository($this->db);
        $serviceRepo = new ServiceRepository($this->db);
        $staffRepo = new StaffRepository($this->db);
        $staffScheduleRepo = new StaffScheduleRepository($this->db);
        $staffExceptionRepo = new StaffAvailabilityExceptionRepository($this->db);
        $staffPlanningRepo = new StaffPlanningRepository($this->db);
        $resourceRepo = new ResourceRepository($this->db);
        $timeBlockRepo = new TimeBlockRepository($this->db);
        $bookingRepo = new BookingRepository($this->db);
        $clientRepo = new ClientRepository($this->db);
        $clientAuthRepo = new ClientAuthRepository($this->db);

        // Services
        $jwtService = new JwtService();
        $passwordHasher = new PasswordHasher();

        // Operator Auth Use Cases
        $loginUser = new LoginUser($userRepo, $sessionRepo, $jwtService, $passwordHasher);
        $refreshToken = new RefreshToken($userRepo, $sessionRepo, $jwtService);
        $logoutUser = new LogoutUser($sessionRepo);
        $getMe = new GetMe($userRepo, $clientRepo);
        $registerUser = new RegisterUser($userRepo, $sessionRepo, $jwtService, $passwordHasher);
        $requestPasswordReset = new RequestPasswordReset($this->db, $userRepo);
        $resetPassword = new ResetPassword($this->db, $userRepo, $passwordHasher);
        $verifyResetToken = new VerifyResetToken($this->db);
        $changePassword = new ChangePassword($userRepo, $passwordHasher);
        $updateProfile = new UpdateProfile($this->db, $userRepo);

        // Customer Auth Use Cases
        $loginCustomer = new LoginCustomer($clientAuthRepo, $jwtService, $passwordHasher);
        $registerCustomer = new RegisterCustomer($clientAuthRepo, $clientRepo, $jwtService, $passwordHasher);
        $refreshCustomerToken = new RefreshCustomerToken($clientAuthRepo, $jwtService);
        $logoutCustomer = new LogoutCustomer($clientAuthRepo);
        $getCustomerMe = new GetCustomerMe($clientAuthRepo);
        $requestCustomerPasswordReset = new RequestCustomerPasswordReset($clientAuthRepo, $businessRepo);
        $resetCustomerPassword = new ResetCustomerPassword($clientAuthRepo, $passwordHasher);
        $updateCustomerProfile = new UpdateCustomerProfile($clientAuthRepo);
        $changeCustomerPassword = new ChangeCustomerPassword($clientAuthRepo, $passwordHasher);

        // Booking Use Cases
        $computeAvailability = new ComputeAvailability($bookingRepo, $staffRepo, $locationRepo, $staffPlanningRepo);
        $createBooking = new CreateBooking($this->db, $bookingRepo, $serviceRepo, $staffRepo, $clientRepo, $locationRepo, $userRepo);
        $updateBooking = new UpdateBooking($bookingRepo, $this->db);
        $deleteBooking = new DeleteBooking($bookingRepo, $this->db);
        $getMyBookings = new GetMyBookings($this->db);

        // Controllers
        $this->controllers = [
            HealthController::class => new HealthController(),
            AuthController::class => new AuthController($loginUser, $refreshToken, $logoutUser, $getMe, $registerUser, $requestPasswordReset, $resetPassword, $verifyResetToken, $changePassword, $updateProfile),
            CustomerAuthController::class => new CustomerAuthController($loginCustomer, $refreshCustomerToken, $logoutCustomer, $getCustomerMe, $registerCustomer, $requestCustomerPasswordReset, $resetCustomerPassword, $updateCustomerProfile, $changeCustomerPassword, $businessRepo),
            BusinessController::class => new BusinessController($businessRepo, $locationRepo, $businessUserRepo, $userRepo),
            LocationsController::class => new LocationsController($locationRepo, $businessUserRepo, $userRepo),
            ServicesController::class => new ServicesController($serviceRepo, $locationRepo, $businessUserRepo, $userRepo),
            StaffController::class => new StaffController($staffRepo, $staffScheduleRepo, $businessUserRepo, $locationRepo, $userRepo),
            AvailabilityController::class => new AvailabilityController($computeAvailability, $serviceRepo),
            BookingsController::class => new BookingsController($createBooking, $bookingRepo, $getMyBookings, $updateBooking, $deleteBooking, $locationRepo, $businessUserRepo, $userRepo),
            ClientsController::class => new ClientsController($clientRepo, $businessUserRepo, $userRepo),
            AppointmentsController::class => new AppointmentsController($bookingRepo, $createBooking, $updateBooking, $deleteBooking, $locationRepo, $businessUserRepo, $userRepo),
            AdminBusinessesController::class => new AdminBusinessesController($this->db, $businessRepo, $businessUserRepo, $userRepo),
            BusinessUsersController::class => new BusinessUsersController($businessRepo, $businessUserRepo, $userRepo),
            BusinessInvitationsController::class => new BusinessInvitationsController($businessRepo, $businessUserRepo, $businessInvitationRepo, $userRepo),
            StaffAvailabilityExceptionController::class => new StaffAvailabilityExceptionController($staffExceptionRepo, $staffRepo, $businessUserRepo, $userRepo),
            StaffPlanningController::class => new StaffPlanningController($staffPlanningRepo, $staffRepo, $businessUserRepo, $userRepo),
            ResourcesController::class => new ResourcesController($resourceRepo, $locationRepo, $businessUserRepo, $userRepo),
            TimeBlocksController::class => new TimeBlocksController($timeBlockRepo, $locationRepo, $businessUserRepo, $userRepo),
        ];
    }

    public function handle(Request $request): Response
    {
        try {
            $this->logger->info('Request', [
                'method' => $request->method,
                'path' => $request->path,
                'trace_id' => $request->traceId,
            ]);

            $route = $this->router->match($request->method, $request->path);
            
            if ($route === null) {
                return Response::notFound('Endpoint not found', $request->traceId);
            }

            // Set path params as attributes
            foreach ($route['params'] as $key => $value) {
                $request->setAttribute($key, $value);
            }

            // Apply middleware
            foreach ($route['middleware'] as $middlewareName) {
                if (!isset($this->middleware[$middlewareName])) {
                    continue;
                }
                
                $middleware = $this->middleware[$middlewareName];
                $result = $middleware->handle($request);
                
                if ($result instanceof Response) {
                    return $result;
                }
            }

            // Call controller
            $controller = $this->controllers[$route['controller']] ?? null;
            if ($controller === null) {
                return Response::serverError('Controller not found', $request->traceId);
            }

            $method = $route['method'];
            $response = $controller->$method($request);

            $this->logger->info('Response', [
                'status' => $response->status,
                'trace_id' => $request->traceId,
            ]);

            return $response;

        } catch (\PDOException $e) {
            $this->logger->error('Database error', [
                'message' => $e->getMessage(),
                'trace_id' => $request->traceId,
                'code' => $e->getCode(),
            ]);

            // Return user-friendly message for database errors
            return Response::error(
                'Service temporarily unavailable. Please try again later.',
                'database_error',
                503,
                $request->traceId
            );

        } catch (Throwable $e) {
            $this->logger->error('Exception', [
                'message' => $e->getMessage(),
                'trace_id' => $request->traceId,
                'file' => $e->getFile(),
                'line' => $e->getLine(),
            ]);

            $debug = ($_ENV['APP_DEBUG'] ?? false) === 'true';
            $message = $debug ? $e->getMessage() : 'Internal server error';
            
            return Response::serverError($message, $request->traceId);
        }
    }
}

----- FILE: src/Http/Request.php -----

<?php

declare(strict_types=1);

namespace Agenda\Http;

use Ramsey\Uuid\Uuid;

final class Request
{
    private array $attributes = [];
    private array $cookies = [];

    public function __construct(
        public readonly string $method,
        public readonly string $path,
        public readonly array $query,
        public readonly array $headers,
        public readonly ?array $body,
        public readonly string $traceId,
        array $cookies = [],
    ) {
        $this->cookies = $cookies;
    }

    public static function fromGlobals(): self
    {
        $method = $_SERVER['REQUEST_METHOD'];
        $rawPath = parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH);
        
        // Strip base path prefix (e.g., /agenda_core/public) for MAMP compatibility
        $basePath = $_ENV['APP_BASE_PATH'] ?? '';
        if ($basePath !== '' && str_starts_with($rawPath, $basePath)) {
            $path = substr($rawPath, strlen($basePath)) ?: '/';
        } else {
            $path = $rawPath;
        }
        
        $query = $_GET;
        
        $headers = [];
        
        // Try getallheaders() first (Apache/FPM with mod_php)
        if (function_exists('getallheaders')) {
            foreach (getallheaders() as $name => $value) {
                $headers[strtolower($name)] = $value;
            }
        }
        
        // Fallback to $_SERVER parsing
        foreach ($_SERVER as $key => $value) {
            if (str_starts_with($key, 'HTTP_')) {
                $headerName = strtolower(str_replace('_', '-', substr($key, 5)));
                // Only add if not already set from getallheaders
                if (!isset($headers[$headerName])) {
                    $headers[$headerName] = $value;
                }
            }
        }
        
        // Special case: Authorization header may be set by htaccess
        if (!isset($headers['authorization']) && isset($_SERVER['HTTP_AUTHORIZATION'])) {
            $headers['authorization'] = $_SERVER['HTTP_AUTHORIZATION'];
        }
        // Also check REDIRECT_ prefixed (mod_rewrite sometimes adds this)
        if (!isset($headers['authorization']) && isset($_SERVER['REDIRECT_HTTP_AUTHORIZATION'])) {
            $headers['authorization'] = $_SERVER['REDIRECT_HTTP_AUTHORIZATION'];
        }
        
        $body = null;
        $rawBody = file_get_contents('php://input');
        if ($rawBody !== '' && $rawBody !== false) {
            $body = json_decode($rawBody, true);
        }
        
        $traceId = Uuid::uuid4()->toString();
        
        return new self($method, $path, $query, $headers, $body, $traceId, $_COOKIE);
    }

    public function getHeader(string $name): ?string
    {
        return $this->headers[strtolower($name)] ?? null;
    }

    public function header(string $name): ?string
    {
        return $this->getHeader($name);
    }

    public function bearerToken(): ?string
    {
        $auth = $this->getHeader('authorization');
        if ($auth && str_starts_with($auth, 'Bearer ')) {
            return substr($auth, 7);
        }
        return null;
    }

    public function setAttribute(string $key, mixed $value): void
    {
        $this->attributes[$key] = $value;
    }

    public function getAttribute(string $key, mixed $default = null): mixed
    {
        return $this->attributes[$key] ?? $default;
    }

    public function getBody(): ?array
    {
        return $this->body;
    }

    public function getQuery(): array
    {
        return $this->query;
    }

    public function queryParam(string $name, ?string $default = null): ?string
    {
        return $this->query[$name] ?? $default;
    }

    public function getCookie(string $name): ?string
    {
        return $this->cookies[$name] ?? null;
    }

    public function getClientIp(): ?string
    {
        // Check X-Forwarded-For first (for proxies)
        $forwarded = $this->getHeader('x-forwarded-for');
        if ($forwarded !== null) {
            $ips = explode(',', $forwarded);
            return trim($ips[0]);
        }

        return $_SERVER['REMOTE_ADDR'] ?? null;
    }

    public function userId(): ?int
    {
        return $this->getAttribute('user_id');
    }

    public function businessId(): ?int
    {
        return $this->getAttribute('business_id');
    }

    public function locationId(): ?int
    {
        return $this->getAttribute('location_id');
    }

    /**
     * Get a route parameter (alias for getAttribute).
     * Route params are set as attributes by the Kernel after routing.
     */
    public function getRouteParam(string $name): mixed
    {
        return $this->getAttribute($name);
    }
}

----- FILE: src/Http/Response.php -----

<?php

declare(strict_types=1);

namespace Agenda\Http;

final class Response
{
    private array $cookies = [];

    public function __construct(
        public readonly int $status,
        public readonly array $data,
        public readonly ?string $traceId = null,
    ) {}

    public static function success(array $data, int $status = 200): self
    {
        return new self($status, [
            'success' => true,
            'data' => $data,
        ]);
    }

    public static function json(array $data, int $status = 200): self
    {
        return new self($status, $data);
    }

    public static function created(array $data): self
    {
        return self::success($data, 201);
    }

    public static function error(string $message, string $code, int $status = 400, ?string $traceId = null): self
    {
        return new self($status, [
            'success' => false,
            'error' => [
                'code' => $code,
                'message' => $message,
            ],
        ], $traceId);
    }

    public static function unauthorized(string $message, ?string $traceId = null): self
    {
        return self::error($message, 'unauthorized', 401);
    }

    public static function forbidden(string $message, ?string $traceId = null): self
    {
        return self::error($message, 'forbidden', 403);
    }

    public static function notFound(string $message, ?string $traceId = null): self
    {
        return self::error($message, 'not_found', 404);
    }

    public static function conflict(string $code, string $message, ?string $traceId = null): self
    {
        return self::error($message, $code, 409);
    }

    public static function validationError(string $message, ?string $traceId = null): self
    {
        return self::error($message, 'validation_error', 422);
    }

    public static function serverError(string $message, ?string $traceId = null): self
    {
        return self::error($message, 'internal_error', 500);
    }

    public function setCookie(string $name, string $value, array $options = []): self
    {
        $this->cookies[$name] = [
            'value' => $value,
            'options' => $options,
        ];
        return $this;
    }

    public function send(): void
    {
        http_response_code($this->status);
        header('Content-Type: application/json; charset=utf-8');
        
        // Determina l'origin consentito dinamicamente
        $allowedOrigins = array_map('trim', explode(',', $_ENV['CORS_ALLOWED_ORIGINS'] ?? '*'));
        $requestOrigin = $_SERVER['HTTP_ORIGIN'] ?? '';
        $corsOrigin = in_array($requestOrigin, $allowedOrigins, true) ? $requestOrigin : ($allowedOrigins[0] ?? '*');
        header('Access-Control-Allow-Origin: ' . $corsOrigin);
        header('Access-Control-Allow-Credentials: true');
        header('Vary: Origin');
        header('Cache-Control: no-store, no-cache, must-revalidate');  // Disabilita cache proxy
        
        if ($this->traceId !== null) {
            header('X-Trace-Id: ' . $this->traceId);
        }

        // Set cookies
        foreach ($this->cookies as $name => $cookie) {
            $options = $cookie['options'];
            $cookieOptions = [
                'expires' => time() + ($options['maxAge'] ?? 0),
                'path' => $options['path'] ?? '/',
                'domain' => $options['domain'] ?? '',
                'secure' => $options['secure'] ?? true,
                'httponly' => $options['httpOnly'] ?? true,
                'samesite' => $options['sameSite'] ?? 'Lax',
            ];
            setcookie($name, $cookie['value'], $cookieOptions);
        }
        
        echo json_encode($this->data, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES);
    }
}

----- FILE: src/Http/Router.php -----

<?php

declare(strict_types=1);

namespace Agenda\Http;

final class Router
{
    private array $routes = [];

    public function get(string $path, string $controller, string $method, array $middleware = []): void
    {
        $this->addRoute('GET', $path, $controller, $method, $middleware);
    }

    public function post(string $path, string $controller, string $method, array $middleware = []): void
    {
        $this->addRoute('POST', $path, $controller, $method, $middleware);
    }

    public function put(string $path, string $controller, string $method, array $middleware = []): void
    {
        $this->addRoute('PUT', $path, $controller, $method, $middleware);
    }

    public function patch(string $path, string $controller, string $method, array $middleware = []): void
    {
        $this->addRoute('PATCH', $path, $controller, $method, $middleware);
    }

    public function delete(string $path, string $controller, string $method, array $middleware = []): void
    {
        $this->addRoute('DELETE', $path, $controller, $method, $middleware);
    }

    private function addRoute(string $httpMethod, string $path, string $controller, string $method, array $middleware): void
    {
        $pattern = preg_replace('/\{([a-zA-Z_]+)\}/', '(?P<$1>[^/]+)', $path);
        $pattern = '#^' . $pattern . '$#';
        
        $this->routes[] = [
            'httpMethod' => $httpMethod,
            'pattern' => $pattern,
            'path' => $path,
            'controller' => $controller,
            'method' => $method,
            'middleware' => $middleware,
        ];
    }

    public function match(string $method, string $path): ?array
    {
        foreach ($this->routes as $route) {
            if ($route['httpMethod'] !== $method) {
                continue;
            }
            
            if (preg_match($route['pattern'], $path, $matches)) {
                $params = array_filter($matches, 'is_string', ARRAY_FILTER_USE_KEY);
                return [
                    'controller' => $route['controller'],
                    'method' => $route['method'],
                    'middleware' => $route['middleware'],
                    'params' => $params,
                ];
            }
        }
        
        return null;
    }
}

=======================================
----- FILE: public/index.php -----

<?php

/**
 * Agenda Core - Entry Point
 * 
 * Struttura: public/ contiene index.php e .htaccess
 * Deploy SiteGround: public/ ‚Üí mappata come public_html/
 */

declare(strict_types=1);

require_once __DIR__ . '/../vendor/autoload.php';

use Agenda\Http\Kernel;
use Agenda\Http\Request;

$dotenv = Dotenv\Dotenv::createImmutable(__DIR__ . '/..');
$dotenv->safeLoad();

date_default_timezone_set($_ENV['APP_TIMEZONE'] ?? 'UTC');

$allowedOrigins = array_map('trim', explode(',', $_ENV['CORS_ALLOWED_ORIGINS'] ?? '*'));
$requestOrigin = $_SERVER['HTTP_ORIGIN'] ?? '';
$corsOrigin = in_array($requestOrigin, $allowedOrigins, true) ? $requestOrigin : ($allowedOrigins[0] ?? '*');

if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    header('Access-Control-Allow-Origin: ' . $corsOrigin);
    header('Access-Control-Allow-Methods: GET, POST, PUT, PATCH, DELETE, OPTIONS');
    header('Access-Control-Allow-Headers: Content-Type, Authorization, Idempotency-Key, X-Idempotency-Key');
    header('Access-Control-Allow-Credentials: true');
    header('Access-Control-Max-Age: 86400');
    http_response_code(204);
    exit;
}

$request = Request::fromGlobals();
$kernel = new Kernel();
$response = $kernel->handle($request);
$response->send();

=======================================

=======================================
END OF SNAPSHOT
=======================================

=== FINE DEL BUNDLE ===
