=== Bundle di tutti i file TXT dei progetti ===
Bundle generato il: Sat Dec 27 19:39:05 CET 2025

>>> CONTENUTO: Frontend
--- FILE: lib/core/l10n/l10_extension.dart ---
import 'package:flutter/widgets.dart';

import 'l10n.dart';

/// üî§ Estensione per accedere facilmente alle stringhe localizzate.
///
/// Permette di scrivere:
/// ```dart
/// Text(context.l10n.welcomeMessage)
/// ```
/// invece di:
/// ```dart
/// Text(L10n.of(context).welcomeMessage)
/// ```
///
/// ‚úÖ Compatibile con aggiornamenti runtime della lingua.
/// ‚úÖ Evita dipendenze da `L10n.current` statico.
/// ‚úÖ Standard consigliato per progetti Flutter internazionalizzati.
extension L10nX on BuildContext {
  /// Restituisce l'istanza corrente di [L10n] per questo [BuildContext].
  L10n get l10n => L10n.of(this);
}

extension DurationLocalization on BuildContext {
  String localizedDurationLabel(int minutes) {
    final hours = minutes ~/ 60;
    final mins = minutes % 60;
    final l10n = this.l10n;

    if (hours > 0 && mins > 0) {
      return l10n.durationHourMinute(hours, mins);
    } else if (hours > 0) {
      return l10n.durationHour(hours);
    } else {
      return l10n.durationMinute(mins);
    }
  }
}
--- FILE: lib/core/l10n/intl/messages_all.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that looks up messages for specific locales by
// delegating to the appropriate library.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:implementation_imports, file_names, unnecessary_new
// ignore_for_file:unnecessary_brace_in_string_interps, directives_ordering
// ignore_for_file:argument_type_not_assignable, invalid_assignment
// ignore_for_file:prefer_single_quotes, prefer_generic_function_type_aliases
// ignore_for_file:comment_references

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';
import 'package:intl/src/intl_helpers.dart';

import 'messages_it.dart' as messages_it;

typedef Future<dynamic> LibraryLoader();
Map<String, LibraryLoader> _deferredLibraries = {
  'it': () => new SynchronousFuture(null),
};

MessageLookupByLibrary? _findExact(String localeName) {
  switch (localeName) {
    case 'it':
      return messages_it.messages;
    default:
      return null;
  }
}

/// User programs should call this before using [localeName] for messages.
Future<bool> initializeMessages(String localeName) {
  var availableLocale = Intl.verifiedLocale(
    localeName,
    (locale) => _deferredLibraries[locale] != null,
    onFailure: (_) => null,
  );
  if (availableLocale == null) {
    return new SynchronousFuture(false);
  }
  var lib = _deferredLibraries[availableLocale];
  lib == null ? new SynchronousFuture(false) : lib();
  initializeInternalMessageLookup(() => new CompositeMessageLookup());
  messageLookup.addLocale(availableLocale, _findGeneratedMessagesFor);
  return new SynchronousFuture(true);
}

bool _messagesExistFor(String locale) {
  try {
    return _findExact(locale) != null;
  } catch (e) {
    return false;
  }
}

MessageLookupByLibrary? _findGeneratedMessagesFor(String locale) {
  var actualLocale = Intl.verifiedLocale(
    locale,
    _messagesExistFor,
    onFailure: (_) => null,
  );
  if (actualLocale == null) return null;
  return _findExact(actualLocale);
}
--- FILE: lib/core/l10n/intl/messages_it.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that provides messages for a it locale. All the
// messages from the main program should be duplicated here with the same
// function name.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:unnecessary_brace_in_string_interps, unnecessary_new
// ignore_for_file:prefer_single_quotes,comment_references, directives_ordering
// ignore_for_file:annotate_overrides,prefer_generic_function_type_aliases
// ignore_for_file:unused_import, file_names, avoid_escaping_inner_quotes
// ignore_for_file:unnecessary_string_interpolations, unnecessary_string_escapes

import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = new MessageLookup();

typedef String MessageIfAbsent(String messageStr, List<dynamic> args);

class MessageLookup extends MessageLookupByLibrary {
  String get localeName => 'it';

  static String m0(id) => "Codice prenotazione: ${id}";

  static String m1(date) => "Prima disponibilit√†: ${date}";

  static String m2(hours) => "${hours} ora";

  static String m3(hours, minutes) => "${hours} ora ${minutes} min";

  static String m4(minutes) => "${minutes} min";

  static String m5(minutes) => "${minutes} min";

  static String m6(path) => "Pagina non trovata: ${path}";

  static String m7(price) => "‚Ç¨${price}";

  static String m8(duration) => "${duration} min";

  static String m9(price) => "da ${price}";

  static String m10(count) =>
      "${Intl.plural(count, zero: 'Nessun servizio selezionato', one: '1 servizio selezionato', other: '${count} servizi selezionati')}";

  static String m11(total) => "Totale: ${total}";

  final messages = _notInlinedMessages(_notInlinedMessages);
  static Map<String, Function> _notInlinedMessages(_) => <String, Function>{
    "actionBack": MessageLookupByLibrary.simpleMessage("Indietro"),
    "actionCancel": MessageLookupByLibrary.simpleMessage("Annulla"),
    "actionClose": MessageLookupByLibrary.simpleMessage("Chiudi"),
    "actionConfirm": MessageLookupByLibrary.simpleMessage("Conferma"),
    "actionLogin": MessageLookupByLibrary.simpleMessage("Accedi"),
    "actionLogout": MessageLookupByLibrary.simpleMessage("Esci"),
    "actionNext": MessageLookupByLibrary.simpleMessage("Avanti"),
    "actionRegister": MessageLookupByLibrary.simpleMessage("Registrati"),
    "actionRetry": MessageLookupByLibrary.simpleMessage("Riprova"),
    "appTitle": MessageLookupByLibrary.simpleMessage("Prenota Online"),
    "authConfirmPassword": MessageLookupByLibrary.simpleMessage(
      "Conferma password",
    ),
    "authEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "authFirstName": MessageLookupByLibrary.simpleMessage("Nome"),
    "authForgotPassword": MessageLookupByLibrary.simpleMessage(
      "Password dimenticata?",
    ),
    "authHaveAccount": MessageLookupByLibrary.simpleMessage(
      "Hai gi√† un account?",
    ),
    "authInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Email non valida",
    ),
    "authInvalidPassword": MessageLookupByLibrary.simpleMessage(
      "Password troppo corta (min. 6 caratteri)",
    ),
    "authInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Numero di telefono non valido",
    ),
    "authLastName": MessageLookupByLibrary.simpleMessage("Cognome"),
    "authLoginFailed": MessageLookupByLibrary.simpleMessage(
      "Credenziali non valide",
    ),
    "authLoginSuccess": MessageLookupByLibrary.simpleMessage(
      "Accesso effettuato",
    ),
    "authLoginTitle": MessageLookupByLibrary.simpleMessage(
      "Accedi al tuo account",
    ),
    "authNoAccount": MessageLookupByLibrary.simpleMessage(
      "Non hai un account?",
    ),
    "authPassword": MessageLookupByLibrary.simpleMessage("Password"),
    "authPasswordMismatch": MessageLookupByLibrary.simpleMessage(
      "Le password non coincidono",
    ),
    "authPhone": MessageLookupByLibrary.simpleMessage("Telefono"),
    "authRegisterFailed": MessageLookupByLibrary.simpleMessage(
      "Registrazione fallita",
    ),
    "authRegisterSuccess": MessageLookupByLibrary.simpleMessage(
      "Registrazione completata",
    ),
    "authRegisterTitle": MessageLookupByLibrary.simpleMessage(
      "Crea un nuovo account",
    ),
    "authRequiredField": MessageLookupByLibrary.simpleMessage(
      "Campo obbligatorio",
    ),
    "authResetPasswordError": MessageLookupByLibrary.simpleMessage(
      "Errore durante l\'invio. Riprova.",
    ),
    "authResetPasswordMessage": MessageLookupByLibrary.simpleMessage(
      "Inserisci la tua email e ti invieremo le istruzioni per reimpostare la password.",
    ),
    "authResetPasswordSend": MessageLookupByLibrary.simpleMessage("Invia"),
    "authResetPasswordSuccess": MessageLookupByLibrary.simpleMessage(
      "Email inviata! Controlla la tua casella di posta.",
    ),
    "authResetPasswordTitle": MessageLookupByLibrary.simpleMessage(
      "Recupera password",
    ),
    "authWelcome": MessageLookupByLibrary.simpleMessage("Benvenuto"),
    "bookingStepDateTime": MessageLookupByLibrary.simpleMessage("Data e ora"),
    "bookingStepServices": MessageLookupByLibrary.simpleMessage("Servizi"),
    "bookingStepStaff": MessageLookupByLibrary.simpleMessage("Operatore"),
    "bookingStepSummary": MessageLookupByLibrary.simpleMessage("Riepilogo"),
    "bookingTitle": MessageLookupByLibrary.simpleMessage(
      "Prenota appuntamento",
    ),
    "confirmationBookingId": m0,
    "confirmationGoHome": MessageLookupByLibrary.simpleMessage(
      "Torna alla home",
    ),
    "confirmationNewBooking": MessageLookupByLibrary.simpleMessage(
      "Nuova prenotazione",
    ),
    "confirmationSubtitle": MessageLookupByLibrary.simpleMessage(
      "Ti abbiamo inviato un\'email di conferma",
    ),
    "confirmationTitle": MessageLookupByLibrary.simpleMessage(
      "Prenotazione confermata!",
    ),
    "dateTimeAfternoon": MessageLookupByLibrary.simpleMessage("Pomeriggio"),
    "dateTimeEvening": MessageLookupByLibrary.simpleMessage("Sera"),
    "dateTimeFirstAvailable": m1,
    "dateTimeMorning": MessageLookupByLibrary.simpleMessage("Mattina"),
    "dateTimeNoSlots": MessageLookupByLibrary.simpleMessage(
      "Nessun orario disponibile per questa data",
    ),
    "dateTimeSelectDate": MessageLookupByLibrary.simpleMessage(
      "Seleziona una data",
    ),
    "dateTimeSubtitle": MessageLookupByLibrary.simpleMessage(
      "Seleziona quando desideri prenotare",
    ),
    "dateTimeTitle": MessageLookupByLibrary.simpleMessage("Scegli data e ora"),
    "durationHour": m2,
    "durationHourMinute": m3,
    "durationMinute": m4,
    "durationMinutes": m5,
    "errorGeneric": MessageLookupByLibrary.simpleMessage(
      "Si √® verificato un errore",
    ),
    "errorLoadingAvailability": MessageLookupByLibrary.simpleMessage(
      "Errore nel caricamento delle disponibilit√†",
    ),
    "errorLoadingServices": MessageLookupByLibrary.simpleMessage(
      "Errore nel caricamento dei servizi",
    ),
    "errorLoadingStaff": MessageLookupByLibrary.simpleMessage(
      "Errore nel caricamento degli operatori",
    ),
    "errorNoAvailability": MessageLookupByLibrary.simpleMessage(
      "Nessuna disponibilit√† per la data selezionata",
    ),
    "errorNotFound": m6,
    "errorTitle": MessageLookupByLibrary.simpleMessage("Errore"),
    "monthApril": MessageLookupByLibrary.simpleMessage("Aprile"),
    "monthAugust": MessageLookupByLibrary.simpleMessage("Agosto"),
    "monthDecember": MessageLookupByLibrary.simpleMessage("Dicembre"),
    "monthFebruary": MessageLookupByLibrary.simpleMessage("Febbraio"),
    "monthJanuary": MessageLookupByLibrary.simpleMessage("Gennaio"),
    "monthJuly": MessageLookupByLibrary.simpleMessage("Luglio"),
    "monthJune": MessageLookupByLibrary.simpleMessage("Giugno"),
    "monthMarch": MessageLookupByLibrary.simpleMessage("Marzo"),
    "monthMay": MessageLookupByLibrary.simpleMessage("Maggio"),
    "monthNovember": MessageLookupByLibrary.simpleMessage("Novembre"),
    "monthOctober": MessageLookupByLibrary.simpleMessage("Ottobre"),
    "monthSeptember": MessageLookupByLibrary.simpleMessage("Settembre"),
    "priceFormat": m7,
    "servicesDuration": m8,
    "servicesFree": MessageLookupByLibrary.simpleMessage("Gratis"),
    "servicesPriceFrom": m9,
    "servicesSelected": m10,
    "servicesSubtitle": MessageLookupByLibrary.simpleMessage(
      "Puoi selezionare uno o pi√π servizi",
    ),
    "servicesTitle": MessageLookupByLibrary.simpleMessage("Scegli i servizi"),
    "servicesTotal": m11,
    "staffAnyOperator": MessageLookupByLibrary.simpleMessage(
      "Qualsiasi operatore disponibile",
    ),
    "staffAnyOperatorSubtitle": MessageLookupByLibrary.simpleMessage(
      "Ti assegneremo il primo operatore libero",
    ),
    "staffSubtitle": MessageLookupByLibrary.simpleMessage(
      "Seleziona con chi desideri essere servito",
    ),
    "staffTitle": MessageLookupByLibrary.simpleMessage("Scegli l\'operatore"),
    "summaryDateTime": MessageLookupByLibrary.simpleMessage("Data e ora"),
    "summaryDuration": MessageLookupByLibrary.simpleMessage("Durata totale"),
    "summaryNotes": MessageLookupByLibrary.simpleMessage("Note (opzionale)"),
    "summaryNotesHint": MessageLookupByLibrary.simpleMessage(
      "Aggiungi eventuali note per l\'appuntamento...",
    ),
    "summaryOperator": MessageLookupByLibrary.simpleMessage("Operatore"),
    "summaryPrice": MessageLookupByLibrary.simpleMessage("Prezzo totale"),
    "summaryServices": MessageLookupByLibrary.simpleMessage(
      "Servizi selezionati",
    ),
    "summarySubtitle": MessageLookupByLibrary.simpleMessage(
      "Controlla i dettagli prima di confermare",
    ),
    "summaryTitle": MessageLookupByLibrary.simpleMessage(
      "Riepilogo prenotazione",
    ),
    "validationInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Email non valida",
    ),
    "validationInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Telefono non valido",
    ),
    "validationRequired": MessageLookupByLibrary.simpleMessage(
      "Campo obbligatorio",
    ),
    "weekdayFri": MessageLookupByLibrary.simpleMessage("Ven"),
    "weekdayMon": MessageLookupByLibrary.simpleMessage("Lun"),
    "weekdaySat": MessageLookupByLibrary.simpleMessage("Sab"),
    "weekdaySun": MessageLookupByLibrary.simpleMessage("Dom"),
    "weekdayThu": MessageLookupByLibrary.simpleMessage("Gio"),
    "weekdayTue": MessageLookupByLibrary.simpleMessage("Mar"),
    "weekdayWed": MessageLookupByLibrary.simpleMessage("Mer"),
  };
}
--- FILE: lib/core/l10n/l10n.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'intl/messages_all.dart';

// **************************************************************************
// Generator: Flutter Intl IDE plugin
// Made by Localizely
// **************************************************************************

// ignore_for_file: non_constant_identifier_names, lines_longer_than_80_chars
// ignore_for_file: join_return_with_assignment, prefer_final_in_for_each
// ignore_for_file: avoid_redundant_argument_values, avoid_escaping_inner_quotes

class L10n {
  L10n();

  static L10n? _current;

  static L10n get current {
    assert(
      _current != null,
      'No instance of L10n was loaded. Try to initialize the L10n delegate before accessing L10n.current.',
    );
    return _current!;
  }

  static const AppLocalizationDelegate delegate = AppLocalizationDelegate();

  static Future<L10n> load(Locale locale) {
    final name = (locale.countryCode?.isEmpty ?? false)
        ? locale.languageCode
        : locale.toString();
    final localeName = Intl.canonicalizedLocale(name);
    return initializeMessages(localeName).then((_) {
      Intl.defaultLocale = localeName;
      final instance = L10n();
      L10n._current = instance;

      return instance;
    });
  }

  static L10n of(BuildContext context) {
    final instance = L10n.maybeOf(context);
    assert(
      instance != null,
      'No instance of L10n present in the widget tree. Did you add L10n.delegate in localizationsDelegates?',
    );
    return instance!;
  }

  static L10n? maybeOf(BuildContext context) {
    return Localizations.of<L10n>(context, L10n);
  }

  /// `Prenota Online`
  String get appTitle {
    return Intl.message('Prenota Online', name: 'appTitle', desc: '', args: []);
  }

  /// `Indietro`
  String get actionBack {
    return Intl.message('Indietro', name: 'actionBack', desc: '', args: []);
  }

  /// `Avanti`
  String get actionNext {
    return Intl.message('Avanti', name: 'actionNext', desc: '', args: []);
  }

  /// `Conferma`
  String get actionConfirm {
    return Intl.message('Conferma', name: 'actionConfirm', desc: '', args: []);
  }

  /// `Annulla`
  String get actionCancel {
    return Intl.message('Annulla', name: 'actionCancel', desc: '', args: []);
  }

  /// `Chiudi`
  String get actionClose {
    return Intl.message('Chiudi', name: 'actionClose', desc: '', args: []);
  }

  /// `Riprova`
  String get actionRetry {
    return Intl.message('Riprova', name: 'actionRetry', desc: '', args: []);
  }

  /// `Accedi`
  String get actionLogin {
    return Intl.message('Accedi', name: 'actionLogin', desc: '', args: []);
  }

  /// `Registrati`
  String get actionRegister {
    return Intl.message(
      'Registrati',
      name: 'actionRegister',
      desc: '',
      args: [],
    );
  }

  /// `Esci`
  String get actionLogout {
    return Intl.message('Esci', name: 'actionLogout', desc: '', args: []);
  }

  /// `Errore`
  String get errorTitle {
    return Intl.message('Errore', name: 'errorTitle', desc: '', args: []);
  }

  /// `Si √® verificato un errore`
  String get errorGeneric {
    return Intl.message(
      'Si √® verificato un errore',
      name: 'errorGeneric',
      desc: '',
      args: [],
    );
  }

  /// `Pagina non trovata: {path}`
  String errorNotFound(String path) {
    return Intl.message(
      'Pagina non trovata: $path',
      name: 'errorNotFound',
      desc: '',
      args: [path],
    );
  }

  /// `Nessuna disponibilit√† per la data selezionata`
  String get errorNoAvailability {
    return Intl.message(
      'Nessuna disponibilit√† per la data selezionata',
      name: 'errorNoAvailability',
      desc: '',
      args: [],
    );
  }

  /// `Errore nel caricamento dei servizi`
  String get errorLoadingServices {
    return Intl.message(
      'Errore nel caricamento dei servizi',
      name: 'errorLoadingServices',
      desc: '',
      args: [],
    );
  }

  /// `Errore nel caricamento degli operatori`
  String get errorLoadingStaff {
    return Intl.message(
      'Errore nel caricamento degli operatori',
      name: 'errorLoadingStaff',
      desc: '',
      args: [],
    );
  }

  /// `Errore nel caricamento delle disponibilit√†`
  String get errorLoadingAvailability {
    return Intl.message(
      'Errore nel caricamento delle disponibilit√†',
      name: 'errorLoadingAvailability',
      desc: '',
      args: [],
    );
  }

  /// `Benvenuto`
  String get authWelcome {
    return Intl.message('Benvenuto', name: 'authWelcome', desc: '', args: []);
  }

  /// `Accedi al tuo account`
  String get authLoginTitle {
    return Intl.message(
      'Accedi al tuo account',
      name: 'authLoginTitle',
      desc: '',
      args: [],
    );
  }

  /// `Crea un nuovo account`
  String get authRegisterTitle {
    return Intl.message(
      'Crea un nuovo account',
      name: 'authRegisterTitle',
      desc: '',
      args: [],
    );
  }

  /// `Email`
  String get authEmail {
    return Intl.message('Email', name: 'authEmail', desc: '', args: []);
  }

  /// `Password`
  String get authPassword {
    return Intl.message('Password', name: 'authPassword', desc: '', args: []);
  }

  /// `Conferma password`
  String get authConfirmPassword {
    return Intl.message(
      'Conferma password',
      name: 'authConfirmPassword',
      desc: '',
      args: [],
    );
  }

  /// `Nome`
  String get authFirstName {
    return Intl.message('Nome', name: 'authFirstName', desc: '', args: []);
  }

  /// `Cognome`
  String get authLastName {
    return Intl.message('Cognome', name: 'authLastName', desc: '', args: []);
  }

  /// `Telefono`
  String get authPhone {
    return Intl.message('Telefono', name: 'authPhone', desc: '', args: []);
  }

  /// `Password dimenticata?`
  String get authForgotPassword {
    return Intl.message(
      'Password dimenticata?',
      name: 'authForgotPassword',
      desc: '',
      args: [],
    );
  }

  /// `Non hai un account?`
  String get authNoAccount {
    return Intl.message(
      'Non hai un account?',
      name: 'authNoAccount',
      desc: '',
      args: [],
    );
  }

  /// `Hai gi√† un account?`
  String get authHaveAccount {
    return Intl.message(
      'Hai gi√† un account?',
      name: 'authHaveAccount',
      desc: '',
      args: [],
    );
  }

  /// `Email non valida`
  String get authInvalidEmail {
    return Intl.message(
      'Email non valida',
      name: 'authInvalidEmail',
      desc: '',
      args: [],
    );
  }

  /// `Password troppo corta (min. 6 caratteri)`
  String get authInvalidPassword {
    return Intl.message(
      'Password troppo corta (min. 6 caratteri)',
      name: 'authInvalidPassword',
      desc: '',
      args: [],
    );
  }

  /// `Le password non coincidono`
  String get authPasswordMismatch {
    return Intl.message(
      'Le password non coincidono',
      name: 'authPasswordMismatch',
      desc: '',
      args: [],
    );
  }

  /// `Campo obbligatorio`
  String get authRequiredField {
    return Intl.message(
      'Campo obbligatorio',
      name: 'authRequiredField',
      desc: '',
      args: [],
    );
  }

  /// `Numero di telefono non valido`
  String get authInvalidPhone {
    return Intl.message(
      'Numero di telefono non valido',
      name: 'authInvalidPhone',
      desc: '',
      args: [],
    );
  }

  /// `Accesso effettuato`
  String get authLoginSuccess {
    return Intl.message(
      'Accesso effettuato',
      name: 'authLoginSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Registrazione completata`
  String get authRegisterSuccess {
    return Intl.message(
      'Registrazione completata',
      name: 'authRegisterSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Credenziali non valide`
  String get authLoginFailed {
    return Intl.message(
      'Credenziali non valide',
      name: 'authLoginFailed',
      desc: '',
      args: [],
    );
  }

  /// `Registrazione fallita`
  String get authRegisterFailed {
    return Intl.message(
      'Registrazione fallita',
      name: 'authRegisterFailed',
      desc: '',
      args: [],
    );
  }

  /// `Recupera password`
  String get authResetPasswordTitle {
    return Intl.message(
      'Recupera password',
      name: 'authResetPasswordTitle',
      desc: '',
      args: [],
    );
  }

  /// `Inserisci la tua email e ti invieremo le istruzioni per reimpostare la password.`
  String get authResetPasswordMessage {
    return Intl.message(
      'Inserisci la tua email e ti invieremo le istruzioni per reimpostare la password.',
      name: 'authResetPasswordMessage',
      desc: '',
      args: [],
    );
  }

  /// `Invia`
  String get authResetPasswordSend {
    return Intl.message(
      'Invia',
      name: 'authResetPasswordSend',
      desc: '',
      args: [],
    );
  }

  /// `Email inviata! Controlla la tua casella di posta.`
  String get authResetPasswordSuccess {
    return Intl.message(
      'Email inviata! Controlla la tua casella di posta.',
      name: 'authResetPasswordSuccess',
      desc: '',
      args: [],
    );
  }

  /// `Errore durante l'invio. Riprova.`
  String get authResetPasswordError {
    return Intl.message(
      'Errore durante l\'invio. Riprova.',
      name: 'authResetPasswordError',
      desc: '',
      args: [],
    );
  }

  /// `Prenota appuntamento`
  String get bookingTitle {
    return Intl.message(
      'Prenota appuntamento',
      name: 'bookingTitle',
      desc: '',
      args: [],
    );
  }

  /// `Servizi`
  String get bookingStepServices {
    return Intl.message(
      'Servizi',
      name: 'bookingStepServices',
      desc: '',
      args: [],
    );
  }

  /// `Operatore`
  String get bookingStepStaff {
    return Intl.message(
      'Operatore',
      name: 'bookingStepStaff',
      desc: '',
      args: [],
    );
  }

  /// `Data e ora`
  String get bookingStepDateTime {
    return Intl.message(
      'Data e ora',
      name: 'bookingStepDateTime',
      desc: '',
      args: [],
    );
  }

  /// `Riepilogo`
  String get bookingStepSummary {
    return Intl.message(
      'Riepilogo',
      name: 'bookingStepSummary',
      desc: '',
      args: [],
    );
  }

  /// `Scegli i servizi`
  String get servicesTitle {
    return Intl.message(
      'Scegli i servizi',
      name: 'servicesTitle',
      desc: '',
      args: [],
    );
  }

  /// `Puoi selezionare uno o pi√π servizi`
  String get servicesSubtitle {
    return Intl.message(
      'Puoi selezionare uno o pi√π servizi',
      name: 'servicesSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `{count, plural, =0{Nessun servizio selezionato} =1{1 servizio selezionato} other{{count} servizi selezionati}}`
  String servicesSelected(int count) {
    return Intl.plural(
      count,
      zero: 'Nessun servizio selezionato',
      one: '1 servizio selezionato',
      other: '$count servizi selezionati',
      name: 'servicesSelected',
      desc: '',
      args: [count],
    );
  }

  /// `Totale: {total}`
  String servicesTotal(String total) {
    return Intl.message(
      'Totale: $total',
      name: 'servicesTotal',
      desc: '',
      args: [total],
    );
  }

  /// `{duration} min`
  String servicesDuration(int duration) {
    return Intl.message(
      '$duration min',
      name: 'servicesDuration',
      desc: '',
      args: [duration],
    );
  }

  /// `Gratis`
  String get servicesFree {
    return Intl.message('Gratis', name: 'servicesFree', desc: '', args: []);
  }

  /// `da {price}`
  String servicesPriceFrom(String price) {
    return Intl.message(
      'da $price',
      name: 'servicesPriceFrom',
      desc: '',
      args: [price],
    );
  }

  /// `Scegli l'operatore`
  String get staffTitle {
    return Intl.message(
      'Scegli l\'operatore',
      name: 'staffTitle',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona con chi desideri essere servito`
  String get staffSubtitle {
    return Intl.message(
      'Seleziona con chi desideri essere servito',
      name: 'staffSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Qualsiasi operatore disponibile`
  String get staffAnyOperator {
    return Intl.message(
      'Qualsiasi operatore disponibile',
      name: 'staffAnyOperator',
      desc: '',
      args: [],
    );
  }

  /// `Ti assegneremo il primo operatore libero`
  String get staffAnyOperatorSubtitle {
    return Intl.message(
      'Ti assegneremo il primo operatore libero',
      name: 'staffAnyOperatorSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Scegli data e ora`
  String get dateTimeTitle {
    return Intl.message(
      'Scegli data e ora',
      name: 'dateTimeTitle',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona quando desideri prenotare`
  String get dateTimeSubtitle {
    return Intl.message(
      'Seleziona quando desideri prenotare',
      name: 'dateTimeSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Prima disponibilit√†: {date}`
  String dateTimeFirstAvailable(String date) {
    return Intl.message(
      'Prima disponibilit√†: $date',
      name: 'dateTimeFirstAvailable',
      desc: '',
      args: [date],
    );
  }

  /// `Nessun orario disponibile per questa data`
  String get dateTimeNoSlots {
    return Intl.message(
      'Nessun orario disponibile per questa data',
      name: 'dateTimeNoSlots',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona una data`
  String get dateTimeSelectDate {
    return Intl.message(
      'Seleziona una data',
      name: 'dateTimeSelectDate',
      desc: '',
      args: [],
    );
  }

  /// `Mattina`
  String get dateTimeMorning {
    return Intl.message('Mattina', name: 'dateTimeMorning', desc: '', args: []);
  }

  /// `Pomeriggio`
  String get dateTimeAfternoon {
    return Intl.message(
      'Pomeriggio',
      name: 'dateTimeAfternoon',
      desc: '',
      args: [],
    );
  }

  /// `Sera`
  String get dateTimeEvening {
    return Intl.message('Sera', name: 'dateTimeEvening', desc: '', args: []);
  }

  /// `Riepilogo prenotazione`
  String get summaryTitle {
    return Intl.message(
      'Riepilogo prenotazione',
      name: 'summaryTitle',
      desc: '',
      args: [],
    );
  }

  /// `Controlla i dettagli prima di confermare`
  String get summarySubtitle {
    return Intl.message(
      'Controlla i dettagli prima di confermare',
      name: 'summarySubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Servizi selezionati`
  String get summaryServices {
    return Intl.message(
      'Servizi selezionati',
      name: 'summaryServices',
      desc: '',
      args: [],
    );
  }

  /// `Operatore`
  String get summaryOperator {
    return Intl.message(
      'Operatore',
      name: 'summaryOperator',
      desc: '',
      args: [],
    );
  }

  /// `Data e ora`
  String get summaryDateTime {
    return Intl.message(
      'Data e ora',
      name: 'summaryDateTime',
      desc: '',
      args: [],
    );
  }

  /// `Durata totale`
  String get summaryDuration {
    return Intl.message(
      'Durata totale',
      name: 'summaryDuration',
      desc: '',
      args: [],
    );
  }

  /// `Prezzo totale`
  String get summaryPrice {
    return Intl.message(
      'Prezzo totale',
      name: 'summaryPrice',
      desc: '',
      args: [],
    );
  }

  /// `Note (opzionale)`
  String get summaryNotes {
    return Intl.message(
      'Note (opzionale)',
      name: 'summaryNotes',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi eventuali note per l'appuntamento...`
  String get summaryNotesHint {
    return Intl.message(
      'Aggiungi eventuali note per l\'appuntamento...',
      name: 'summaryNotesHint',
      desc: '',
      args: [],
    );
  }

  /// `Prenotazione confermata!`
  String get confirmationTitle {
    return Intl.message(
      'Prenotazione confermata!',
      name: 'confirmationTitle',
      desc: '',
      args: [],
    );
  }

  /// `Ti abbiamo inviato un'email di conferma`
  String get confirmationSubtitle {
    return Intl.message(
      'Ti abbiamo inviato un\'email di conferma',
      name: 'confirmationSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Codice prenotazione: {id}`
  String confirmationBookingId(String id) {
    return Intl.message(
      'Codice prenotazione: $id',
      name: 'confirmationBookingId',
      desc: '',
      args: [id],
    );
  }

  /// `Nuova prenotazione`
  String get confirmationNewBooking {
    return Intl.message(
      'Nuova prenotazione',
      name: 'confirmationNewBooking',
      desc: '',
      args: [],
    );
  }

  /// `Torna alla home`
  String get confirmationGoHome {
    return Intl.message(
      'Torna alla home',
      name: 'confirmationGoHome',
      desc: '',
      args: [],
    );
  }

  /// `{minutes} min`
  String durationMinutes(int minutes) {
    return Intl.message(
      '$minutes min',
      name: 'durationMinutes',
      desc: '',
      args: [minutes],
    );
  }

  /// `{minutes} min`
  String durationMinute(int minutes) {
    return Intl.message(
      '$minutes min',
      name: 'durationMinute',
      desc: '',
      args: [minutes],
    );
  }

  /// `{hours} ora`
  String durationHour(int hours) {
    return Intl.message(
      '$hours ora',
      name: 'durationHour',
      desc: '',
      args: [hours],
    );
  }

  /// `{hours} ora {minutes} min`
  String durationHourMinute(int hours, int minutes) {
    return Intl.message(
      '$hours ora $minutes min',
      name: 'durationHourMinute',
      desc: '',
      args: [hours, minutes],
    );
  }

  /// `‚Ç¨{price}`
  String priceFormat(String price) {
    return Intl.message(
      '‚Ç¨$price',
      name: 'priceFormat',
      desc: '',
      args: [price],
    );
  }

  /// `Gennaio`
  String get monthJanuary {
    return Intl.message('Gennaio', name: 'monthJanuary', desc: '', args: []);
  }

  /// `Febbraio`
  String get monthFebruary {
    return Intl.message('Febbraio', name: 'monthFebruary', desc: '', args: []);
  }

  /// `Marzo`
  String get monthMarch {
    return Intl.message('Marzo', name: 'monthMarch', desc: '', args: []);
  }

  /// `Aprile`
  String get monthApril {
    return Intl.message('Aprile', name: 'monthApril', desc: '', args: []);
  }

  /// `Maggio`
  String get monthMay {
    return Intl.message('Maggio', name: 'monthMay', desc: '', args: []);
  }

  /// `Giugno`
  String get monthJune {
    return Intl.message('Giugno', name: 'monthJune', desc: '', args: []);
  }

  /// `Luglio`
  String get monthJuly {
    return Intl.message('Luglio', name: 'monthJuly', desc: '', args: []);
  }

  /// `Agosto`
  String get monthAugust {
    return Intl.message('Agosto', name: 'monthAugust', desc: '', args: []);
  }

  /// `Settembre`
  String get monthSeptember {
    return Intl.message(
      'Settembre',
      name: 'monthSeptember',
      desc: '',
      args: [],
    );
  }

  /// `Ottobre`
  String get monthOctober {
    return Intl.message('Ottobre', name: 'monthOctober', desc: '', args: []);
  }

  /// `Novembre`
  String get monthNovember {
    return Intl.message('Novembre', name: 'monthNovember', desc: '', args: []);
  }

  /// `Dicembre`
  String get monthDecember {
    return Intl.message('Dicembre', name: 'monthDecember', desc: '', args: []);
  }

  /// `Lun`
  String get weekdayMon {
    return Intl.message('Lun', name: 'weekdayMon', desc: '', args: []);
  }

  /// `Mar`
  String get weekdayTue {
    return Intl.message('Mar', name: 'weekdayTue', desc: '', args: []);
  }

  /// `Mer`
  String get weekdayWed {
    return Intl.message('Mer', name: 'weekdayWed', desc: '', args: []);
  }

  /// `Gio`
  String get weekdayThu {
    return Intl.message('Gio', name: 'weekdayThu', desc: '', args: []);
  }

  /// `Ven`
  String get weekdayFri {
    return Intl.message('Ven', name: 'weekdayFri', desc: '', args: []);
  }

  /// `Sab`
  String get weekdaySat {
    return Intl.message('Sab', name: 'weekdaySat', desc: '', args: []);
  }

  /// `Dom`
  String get weekdaySun {
    return Intl.message('Dom', name: 'weekdaySun', desc: '', args: []);
  }

  /// `Campo obbligatorio`
  String get validationRequired {
    return Intl.message(
      'Campo obbligatorio',
      name: 'validationRequired',
      desc: '',
      args: [],
    );
  }

  /// `Email non valida`
  String get validationInvalidEmail {
    return Intl.message(
      'Email non valida',
      name: 'validationInvalidEmail',
      desc: '',
      args: [],
    );
  }

  /// `Telefono non valido`
  String get validationInvalidPhone {
    return Intl.message(
      'Telefono non valido',
      name: 'validationInvalidPhone',
      desc: '',
      args: [],
    );
  }
}

class AppLocalizationDelegate extends LocalizationsDelegate<L10n> {
  const AppLocalizationDelegate();

  List<Locale> get supportedLocales {
    return const <Locale>[Locale.fromSubtags(languageCode: 'it')];
  }

  @override
  bool isSupported(Locale locale) => _isSupported(locale);
  @override
  Future<L10n> load(Locale locale) => L10n.load(locale);
  @override
  bool shouldReload(AppLocalizationDelegate old) => false;

  bool _isSupported(Locale locale) {
    for (var supportedLocale in supportedLocales) {
      if (supportedLocale.languageCode == locale.languageCode) {
        return true;
      }
    }
    return false;
  }
}
--- FILE: lib/core/models/service_category.dart ---
/// Categoria di servizi
class ServiceCategory {
  final int id;
  final int businessId;
  final String name;
  final String? description;
  final int sortOrder;

  const ServiceCategory({
    required this.id,
    required this.businessId,
    required this.name,
    this.description,
    this.sortOrder = 0,
  });

  ServiceCategory copyWith({
    int? id,
    int? businessId,
    String? name,
    String? description,
    int? sortOrder,
  }) =>
      ServiceCategory(
        id: id ?? this.id,
        businessId: businessId ?? this.businessId,
        name: name ?? this.name,
        description: description ?? this.description,
        sortOrder: sortOrder ?? this.sortOrder,
      );

  factory ServiceCategory.fromJson(Map<String, dynamic> json) =>
      ServiceCategory(
        id: json['id'] as int,
        businessId: json['business_id'] as int,
        name: json['name'] as String,
        description: json['description'] as String?,
        sortOrder: json['sort_order'] as int? ?? 0,
      );

  Map<String, dynamic> toJson() => {
        'id': id,
        'business_id': businessId,
        'name': name,
        if (description != null) 'description': description,
        'sort_order': sortOrder,
      };
}
--- FILE: lib/core/models/user.dart ---
/// Modello utente per l'autenticazione
class User {
  final int id;
  final String email;
  final String firstName;
  final String lastName;
  final String? phone;
  final DateTime createdAt;

  const User({
    required this.id,
    required this.email,
    required this.firstName,
    required this.lastName,
    this.phone,
    required this.createdAt,
  });

  String get fullName => '$firstName $lastName';

  User copyWith({
    int? id,
    String? email,
    String? firstName,
    String? lastName,
    String? phone,
    DateTime? createdAt,
  }) =>
      User(
        id: id ?? this.id,
        email: email ?? this.email,
        firstName: firstName ?? this.firstName,
        lastName: lastName ?? this.lastName,
        phone: phone ?? this.phone,
        createdAt: createdAt ?? this.createdAt,
      );

  factory User.fromJson(Map<String, dynamic> json) => User(
        id: json['id'] as int,
        email: json['email'] as String,
        firstName: json['first_name'] as String,
        lastName: json['last_name'] as String,
        phone: json['phone'] as String?,
        createdAt: DateTime.parse(json['created_at'] as String),
      );

  Map<String, dynamic> toJson() => {
        'id': id,
        'email': email,
        'first_name': firstName,
        'last_name': lastName,
        if (phone != null) 'phone': phone,
        'created_at': createdAt.toIso8601String(),
      };
}
--- FILE: lib/core/models/service.dart ---
/// Modello Servizio prenotabile online
class Service {
  final int id;
  final int businessId;
  final int categoryId;
  final String name;
  final String? description;
  final int sortOrder;
  final int durationMinutes;
  final double price;
  final bool isFree;
  final bool isPriceStartingFrom;
  final bool isBookableOnline;

  const Service({
    required this.id,
    required this.businessId,
    required this.categoryId,
    required this.name,
    this.description,
    this.sortOrder = 0,
    required this.durationMinutes,
    required this.price,
    this.isFree = false,
    this.isPriceStartingFrom = false,
    this.isBookableOnline = true,
  });

  Service copyWith({
    int? id,
    int? businessId,
    int? categoryId,
    String? name,
    String? description,
    int? sortOrder,
    int? durationMinutes,
    double? price,
    bool? isFree,
    bool? isPriceStartingFrom,
    bool? isBookableOnline,
  }) =>
      Service(
        id: id ?? this.id,
        businessId: businessId ?? this.businessId,
        categoryId: categoryId ?? this.categoryId,
        name: name ?? this.name,
        description: description ?? this.description,
        sortOrder: sortOrder ?? this.sortOrder,
        durationMinutes: durationMinutes ?? this.durationMinutes,
        price: price ?? this.price,
        isFree: isFree ?? this.isFree,
        isPriceStartingFrom: isPriceStartingFrom ?? this.isPriceStartingFrom,
        isBookableOnline: isBookableOnline ?? this.isBookableOnline,
      );

  factory Service.fromJson(Map<String, dynamic> json) => Service(
        id: json['id'] as int,
        businessId: json['business_id'] as int,
        categoryId: json['category_id'] as int,
        name: json['name'] as String,
        description: json['description'] as String?,
        sortOrder: json['sort_order'] as int? ?? 0,
        durationMinutes: json['duration_minutes'] as int? ?? 30,
        price: (json['price'] as num?)?.toDouble() ?? 0.0,
        isFree: json['is_free'] as bool? ?? false,
        isPriceStartingFrom: json['is_price_starting_from'] as bool? ?? false,
        isBookableOnline: json['is_bookable_online'] as bool? ?? true,
      );

  Map<String, dynamic> toJson() => {
        'id': id,
        'business_id': businessId,
        'category_id': categoryId,
        'name': name,
        if (description != null) 'description': description,
        'sort_order': sortOrder,
        'duration_minutes': durationMinutes,
        'price': price,
        'is_free': isFree,
        'is_price_starting_from': isPriceStartingFrom,
        'is_bookable_online': isBookableOnline,
      };

  String get formattedPrice {
    if (isFree) return 'Gratis';
    final priceStr = price.toStringAsFixed(2).replaceAll('.', ',');
    return isPriceStartingFrom ? 'da ‚Ç¨$priceStr' : '‚Ç¨$priceStr';
  }
}
--- FILE: lib/core/models/staff.dart ---
/// Modello Staff/Operatore
class Staff {
  final int id;
  final int businessId;
  final String name;
  final String surname;
  final String? avatarUrl;
  final int sortOrder;
  final bool isBookableOnline;

  const Staff({
    required this.id,
    required this.businessId,
    required this.name,
    required this.surname,
    this.avatarUrl,
    this.sortOrder = 0,
    this.isBookableOnline = true,
  });

  String get displayName {
    if (surname.isEmpty) return name;
    return '$name $surname';
  }

  String get initials {
    final nameInitial = name.isNotEmpty ? name[0].toUpperCase() : '';
    final surnameInitial = surname.isNotEmpty ? surname[0].toUpperCase() : '';
    return '$nameInitial$surnameInitial';
  }

  Staff copyWith({
    int? id,
    int? businessId,
    String? name,
    String? surname,
    String? avatarUrl,
    int? sortOrder,
    bool? isBookableOnline,
  }) =>
      Staff(
        id: id ?? this.id,
        businessId: businessId ?? this.businessId,
        name: name ?? this.name,
        surname: surname ?? this.surname,
        avatarUrl: avatarUrl ?? this.avatarUrl,
        sortOrder: sortOrder ?? this.sortOrder,
        isBookableOnline: isBookableOnline ?? this.isBookableOnline,
      );

  factory Staff.fromJson(Map<String, dynamic> json) => Staff(
        id: json['id'] as int,
        businessId: json['business_id'] as int,
        name: json['name'] as String,
        surname: json['surname'] as String? ?? '',
        avatarUrl: json['avatar_url'] as String?,
        sortOrder: json['sort_order'] as int? ?? 0,
        isBookableOnline: json['is_bookable_online'] as bool? ?? true,
      );

  Map<String, dynamic> toJson() => {
        'id': id,
        'business_id': businessId,
        'name': name,
        'surname': surname,
        if (avatarUrl != null) 'avatar_url': avatarUrl,
        'sort_order': sortOrder,
        'is_bookable_online': isBookableOnline,
      };
}
--- FILE: lib/core/models/time_slot.dart ---
/// Slot temporale disponibile per la prenotazione
class TimeSlot {
  final DateTime startTime;
  final DateTime endTime;
  final int? staffId;

  const TimeSlot({
    required this.startTime,
    required this.endTime,
    this.staffId,
  });

  int get durationMinutes => endTime.difference(startTime).inMinutes;

  String get formattedTime {
    final hour = startTime.hour.toString().padLeft(2, '0');
    final minute = startTime.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }

  TimeSlot copyWith({
    DateTime? startTime,
    DateTime? endTime,
    int? staffId,
  }) =>
      TimeSlot(
        startTime: startTime ?? this.startTime,
        endTime: endTime ?? this.endTime,
        staffId: staffId ?? this.staffId,
      );

  factory TimeSlot.fromJson(Map<String, dynamic> json) => TimeSlot(
        startTime: DateTime.parse(json['start_time'] as String),
        endTime: DateTime.parse(json['end_time'] as String),
        staffId: json['staff_id'] as int?,
      );

  Map<String, dynamic> toJson() => {
        'start_time': startTime.toIso8601String(),
        'end_time': endTime.toIso8601String(),
        if (staffId != null) 'staff_id': staffId,
      };
}
--- FILE: lib/core/models/booking_request.dart ---
import 'service.dart';
import 'staff.dart';
import 'time_slot.dart';

/// Modello per la richiesta di prenotazione
class BookingRequest {
  final List<Service> services;
  final Staff? selectedStaff;
  final TimeSlot? selectedSlot;
  final String? notes;

  const BookingRequest({
    this.services = const [],
    this.selectedStaff,
    this.selectedSlot,
    this.notes,
  });

  /// Durata totale in minuti
  int get totalDurationMinutes =>
      services.fold(0, (sum, s) => sum + s.durationMinutes);

  /// Prezzo totale
  double get totalPrice =>
      services.fold(0.0, (sum, s) => sum + (s.isFree ? 0 : s.price));

  /// Formatta il prezzo totale
  String get formattedTotalPrice {
    if (totalPrice == 0) return 'Gratis';
    return '‚Ç¨${totalPrice.toStringAsFixed(2).replaceAll('.', ',')}';
  }

  /// Verifica se la prenotazione √® completa
  bool get isComplete =>
      services.isNotEmpty && selectedSlot != null;

  BookingRequest copyWith({
    List<Service>? services,
    Staff? selectedStaff,
    TimeSlot? selectedSlot,
    String? notes,
    bool clearStaff = false,
    bool clearSlot = false,
  }) =>
      BookingRequest(
        services: services ?? this.services,
        selectedStaff: clearStaff ? null : (selectedStaff ?? this.selectedStaff),
        selectedSlot: clearSlot ? null : (selectedSlot ?? this.selectedSlot),
        notes: notes ?? this.notes,
      );

  Map<String, dynamic> toJson() => {
        'service_ids': services.map((s) => s.id).toList(),
        if (selectedStaff != null) 'staff_id': selectedStaff!.id,
        if (selectedSlot != null) 'start_time': selectedSlot!.startTime.toIso8601String(),
        if (notes != null && notes!.isNotEmpty) 'notes': notes,
      };
}
--- FILE: lib/app/router.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../features/auth/presentation/login_screen.dart';
import '../features/auth/presentation/register_screen.dart';
import '../features/auth/providers/auth_provider.dart';
import '../features/booking/presentation/screens/booking_screen.dart';

final routerProvider = Provider<GoRouter>((ref) {
  final authState = ref.watch(authProvider);

  return GoRouter(
    initialLocation: '/booking',
    debugLogDiagnostics: true,
    redirect: (context, state) {
      final isLoggedIn = authState.isAuthenticated;
      final isLoggingIn = state.matchedLocation == '/login';
      final isRegistering = state.matchedLocation == '/register';

      // Se non √® autenticato e non sta cercando di loggarsi o registrarsi
      if (!isLoggedIn && !isLoggingIn && !isRegistering) {
        return '/booking';
      }

      // Se √® autenticato e sta cercando di accedere a login/register
      if (isLoggedIn && (isLoggingIn || isRegistering)) {
        return '/booking';
      }

      return null;
    },
    routes: [
      GoRoute(path: '/', redirect: (context, state) => '/booking'),
      GoRoute(
        path: '/login',
        name: 'login',
        builder: (context, state) => const LoginScreen(),
      ),
      GoRoute(
        path: '/register',
        name: 'register',
        builder: (context, state) => const RegisterScreen(),
      ),
      GoRoute(
        path: '/booking',
        name: 'booking',
        builder: (context, state) => const BookingScreen(),
      ),
    ],
    errorBuilder: (context, state) => Scaffold(
      body: Center(child: Text('Pagina non trovata: ${state.uri.path}')),
    ),
  );
});
--- FILE: lib/app/providers/form_factor_provider.dart ---
import 'dart:ui' as ui;

import 'package:flutter/widgets.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'form_factor_provider.g.dart';

// Definiamo i tre layout che ci interessano
enum AppFormFactor { mobile, tablet, desktop }

AppFormFactor _formFactorForWidth(double width) {
  if (width >= 1024) return AppFormFactor.desktop;
  if (width >= 600) return AppFormFactor.tablet;
  return AppFormFactor.mobile;
}

@riverpod
class FormFactorNotifier extends _$FormFactorNotifier {
  @override
  AppFormFactor build() {
    final binding = WidgetsFlutterBinding.ensureInitialized();
    final dispatcher = binding.platformDispatcher;
    final ui.FlutterView? view = dispatcher.views.isNotEmpty
        ? dispatcher.views.first
        : dispatcher.implicitView;

    if (view != null) {
      final logicalSize = view.physicalSize / view.devicePixelRatio;
      return _formFactorForWidth(logicalSize.width);
    }

    return AppFormFactor.mobile;
  }

  /// Aggiorna il form factor in base alla larghezza dello schermo.
  /// Usa lo stesso breakpoint di 600px che usi nel resto dell'app.
  void update(double screenWidth) {
    final newFactor = _formFactorForWidth(screenWidth);

    // Aggiorna lo stato solo se il form factor cambia
    if (state != newFactor) {
      state = newFactor;
    }
  }
}
--- FILE: lib/app/providers/form_factor_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'form_factor_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(FormFactorNotifier)
const formFactorProvider = FormFactorNotifierProvider._();

final class FormFactorNotifierProvider
    extends $NotifierProvider<FormFactorNotifier, AppFormFactor> {
  const FormFactorNotifierProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'formFactorProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$formFactorNotifierHash();

  @$internal
  @override
  FormFactorNotifier create() => FormFactorNotifier();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AppFormFactor value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AppFormFactor>(value),
    );
  }
}

String _$formFactorNotifierHash() =>
    r'c2d345138b8b938ff84a110cd4b6bf3dda7a605e';

abstract class _$FormFactorNotifier extends $Notifier<AppFormFactor> {
  AppFormFactor build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<AppFormFactor, AppFormFactor>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AppFormFactor, AppFormFactor>,
              AppFormFactor,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/app/theme/theme_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'theme.dart';
import 'theme_config.dart';

/// Notifier per gestire il tema dinamico
class ThemeNotifier extends Notifier<AppThemeConfig> {
  @override
  AppThemeConfig build() => const AppThemeConfig(
        seedColor: colorPrimary,
        brightness: Brightness.light,
      );

  void updateSeed(Color color) {
    state = state.copyWith(seedColor: color);
  }

  void toggleBrightness() {
    final newBrightness = state.brightness == Brightness.light
        ? Brightness.dark
        : Brightness.light;
    state = state.copyWith(brightness: newBrightness);
  }
}

/// Provider globale per il tema
final themeNotifierProvider = NotifierProvider<ThemeNotifier, AppThemeConfig>(
  ThemeNotifier.new,
);
--- FILE: lib/app/theme/theme_config.dart ---
import 'package:flutter/material.dart';

class AppThemeConfig {
  final Color seedColor;
  final Brightness brightness;

  const AppThemeConfig({
    required this.seedColor,
    this.brightness = Brightness.light,
  });

  AppThemeConfig copyWith({Color? seedColor, Brightness? brightness}) {
    return AppThemeConfig(
      seedColor: seedColor ?? this.seedColor,
      brightness: brightness ?? this.brightness,
    );
  }
}
--- FILE: lib/app/theme/theme.dart ---
import 'package:flutter/material.dart';

import 'theme_config.dart';

const colorPrimary = Color(0xFF141414);
const colorBackground = Color(0xFFFEFEFE);
const colorAccent = Color(0xFF2196F3);

/// Crea il tema dell'app
ThemeData buildTheme(AppThemeConfig config, Brightness brightness) {
  final isDark = brightness == Brightness.dark;

  final background = isDark ? colorPrimary : colorBackground;
  final onBackground = isDark ? colorBackground : colorPrimary;

  final colorScheme = ColorScheme(
    brightness: brightness,
    primary: colorAccent,
    onPrimary: Colors.white,
    secondary: colorAccent,
    onSecondary: Colors.white,
    error: Colors.red,
    onError: Colors.white,
    surface: background,
    onSurface: onBackground,
  );

  return ThemeData(
    useMaterial3: true,
    colorScheme: colorScheme,
    brightness: brightness,
    scaffoldBackgroundColor: background,
    appBarTheme: AppBarTheme(
      backgroundColor: background,
      foregroundColor: onBackground,
      elevation: 0,
      centerTitle: true,
      surfaceTintColor: Colors.transparent,
    ),
    cardTheme: CardThemeData(
      color: background,
      elevation: 0,
      margin: const EdgeInsets.all(8),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: onBackground.withOpacity(0.1)),
      ),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        backgroundColor: colorAccent,
        foregroundColor: Colors.white,
        minimumSize: const Size(double.infinity, 52),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        elevation: 0,
      ),
    ),
    outlinedButtonTheme: OutlinedButtonThemeData(
      style: OutlinedButton.styleFrom(
        foregroundColor: colorPrimary,
        minimumSize: const Size(double.infinity, 52),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        side: BorderSide(color: colorPrimary.withOpacity(0.2)),
      ),
    ),
    textButtonTheme: TextButtonThemeData(
      style: TextButton.styleFrom(
        foregroundColor: colorAccent,
      ),
    ),
    inputDecorationTheme: InputDecorationTheme(
      filled: true,
      fillColor: onBackground.withOpacity(0.05),
      border: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: BorderSide.none,
      ),
      enabledBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: BorderSide(color: onBackground.withOpacity(0.1)),
      ),
      focusedBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: colorAccent, width: 2),
      ),
      errorBorder: OutlineInputBorder(
        borderRadius: BorderRadius.circular(12),
        borderSide: const BorderSide(color: Colors.red),
      ),
      contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
    ),
    chipTheme: ChipThemeData(
      backgroundColor: colorAccent.withOpacity(0.1),
      selectedColor: colorAccent,
      labelStyle: TextStyle(color: onBackground),
      secondaryLabelStyle: const TextStyle(color: Colors.white),
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
    ),
    dividerColor: onBackground.withOpacity(0.1),
    progressIndicatorTheme: const ProgressIndicatorThemeData(
      color: colorAccent,
    ),
  );
}
--- FILE: lib/app/app.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../core/l10n/l10n.dart';
import 'router.dart';
import 'theme/theme.dart';
import 'theme/theme_provider.dart';

class App extends ConsumerWidget {
  const App({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final router = ref.watch(routerProvider);
    final themeConfig = ref.watch(themeNotifierProvider);
    final theme = buildTheme(themeConfig, themeConfig.brightness);

    return MaterialApp.router(
      title: 'Agenda Booking',
      debugShowCheckedModeBanner: false,
      theme: theme,
      routerConfig: router,
      localizationsDelegates: [
        L10n.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: L10n.delegate.supportedLocales,
      locale: const Locale('it'),
    );
  }
}
--- FILE: lib/features/auth/providers/auth_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../data/auth_repository.dart';
import '../domain/auth_state.dart';

/// Provider per il repository di autenticazione
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  return AuthRepository();
});

/// Provider per lo stato di autenticazione
final authProvider = NotifierProvider<AuthNotifier, AuthState>(
  AuthNotifier.new,
);

class AuthNotifier extends Notifier<AuthState> {
  @override
  AuthState build() {
    _checkCurrentUser();
    return AuthState.initial();
  }

  AuthRepository get _repository => ref.read(authRepositoryProvider);

  Future<void> _checkCurrentUser() async {
    state = AuthState.loading();
    try {
      final user = await _repository.getCurrentUser();
      if (user != null) {
        state = AuthState.authenticated(user);
      } else {
        state = AuthState.unauthenticated();
      }
    } catch (e) {
      state = AuthState.unauthenticated();
    }
  }

  Future<bool> login({required String email, required String password}) async {
    state = AuthState.loading();
    try {
      final user = await _repository.login(email: email, password: password);
      state = AuthState.authenticated(user);
      return true;
    } catch (e) {
      state = AuthState.error(e.toString());
      return false;
    }
  }

  Future<bool> register({
    required String email,
    required String password,
    required String firstName,
    required String lastName,
    String? phone,
  }) async {
    state = AuthState.loading();
    try {
      final user = await _repository.register(
        email: email,
        password: password,
        firstName: firstName,
        lastName: lastName,
        phone: phone,
      );
      state = AuthState.authenticated(user);
      return true;
    } catch (e) {
      state = AuthState.error(e.toString());
      return false;
    }
  }

  Future<void> logout() async {
    await _repository.logout();
    state = AuthState.unauthenticated();
  }

  Future<bool> resetPassword(String email) async {
    try {
      await _repository.resetPassword(email);
      return true;
    } catch (e) {
      return false;
    }
  }

  void clearError() {
    state = state.copyWith(clearError: true);
  }
}
--- FILE: lib/features/auth/data/auth_repository.dart ---
import '../../../core/models/user.dart';

/// Repository per l'autenticazione (Mock API)
class AuthRepository {
  // Simula utente salvato
  User? _currentUser;

  Future<User?> getCurrentUser() async {
    await Future.delayed(const Duration(milliseconds: 300));
    return _currentUser;
  }

  Future<User> login({
    required String email,
    required String password,
  }) async {
    await Future.delayed(const Duration(seconds: 1));
    
    // Mock: accetta qualsiasi email/password valida
    if (email.isEmpty || password.length < 6) {
      throw Exception('Credenziali non valide');
    }

    _currentUser = User(
      id: 1,
      email: email,
      firstName: 'Mario',
      lastName: 'Rossi',
      phone: '+39 333 1234567',
      createdAt: DateTime.now(),
    );

    return _currentUser!;
  }

  Future<User> register({
    required String email,
    required String password,
    required String firstName,
    required String lastName,
    String? phone,
  }) async {
    await Future.delayed(const Duration(seconds: 1));

    // Mock: crea utente
    _currentUser = User(
      id: DateTime.now().millisecondsSinceEpoch,
      email: email,
      firstName: firstName,
      lastName: lastName,
      phone: phone,
      createdAt: DateTime.now(),
    );

    return _currentUser!;
  }

  Future<void> logout() async {
    await Future.delayed(const Duration(milliseconds: 300));
    _currentUser = null;
  }

  Future<void> resetPassword(String email) async {
    await Future.delayed(const Duration(seconds: 1));
    // Mock: simula invio email
  }
}
--- FILE: lib/features/auth/domain/auth_state.dart ---
import '../../../core/models/user.dart';

/// Stati possibili dell'autenticazione
enum AuthStatus {
  initial,
  loading,
  authenticated,
  unauthenticated,
  error,
}

/// Stato dell'autenticazione
class AuthState {
  final AuthStatus status;
  final User? user;
  final String? errorMessage;

  const AuthState({
    this.status = AuthStatus.initial,
    this.user,
    this.errorMessage,
  });

  bool get isAuthenticated => status == AuthStatus.authenticated && user != null;
  bool get isLoading => status == AuthStatus.loading;

  AuthState copyWith({
    AuthStatus? status,
    User? user,
    String? errorMessage,
    bool clearUser = false,
    bool clearError = false,
  }) =>
      AuthState(
        status: status ?? this.status,
        user: clearUser ? null : (user ?? this.user),
        errorMessage: clearError ? null : (errorMessage ?? this.errorMessage),
      );

  factory AuthState.initial() => const AuthState(status: AuthStatus.initial);
  
  factory AuthState.loading() => const AuthState(status: AuthStatus.loading);
  
  factory AuthState.authenticated(User user) => AuthState(
        status: AuthStatus.authenticated,
        user: user,
      );
  
  factory AuthState.unauthenticated() => const AuthState(
        status: AuthStatus.unauthenticated,
      );
  
  factory AuthState.error(String message) => AuthState(
        status: AuthStatus.error,
        errorMessage: message,
      );
}
--- FILE: lib/features/auth/presentation/register_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/l10_extension.dart';
import '../providers/auth_provider.dart';

class RegisterScreen extends ConsumerStatefulWidget {
  const RegisterScreen({super.key});

  @override
  ConsumerState<RegisterScreen> createState() => _RegisterScreenState();
}

class _RegisterScreenState extends ConsumerState<RegisterScreen> {
  final _formKey = GlobalKey<FormState>();
  final _firstNameController = TextEditingController();
  final _lastNameController = TextEditingController();
  final _emailController = TextEditingController();
  final _phoneController = TextEditingController();
  final _passwordController = TextEditingController();
  final _confirmPasswordController = TextEditingController();
  bool _obscurePassword = true;
  bool _obscureConfirmPassword = true;

  @override
  void dispose() {
    _firstNameController.dispose();
    _lastNameController.dispose();
    _emailController.dispose();
    _phoneController.dispose();
    _passwordController.dispose();
    _confirmPasswordController.dispose();
    super.dispose();
  }

  Future<void> _handleRegister() async {
    if (!_formKey.currentState!.validate()) return;

    final success = await ref
        .read(authProvider.notifier)
        .register(
          email: _emailController.text.trim(),
          password: _passwordController.text,
          firstName: _firstNameController.text.trim(),
          lastName: _lastNameController.text.trim(),
          phone: _phoneController.text.trim().isNotEmpty
              ? _phoneController.text.trim()
              : null,
        );

    if (success && mounted) {
      context.go('/booking');
    }
  }

  @override
  Widget build(BuildContext context) {
    final authState = ref.watch(authProvider);
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.pop(),
        ),
        title: Text(l10n.authRegisterTitle),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                const SizedBox(height: 16),

                // Nome
                TextFormField(
                  controller: _firstNameController,
                  textInputAction: TextInputAction.next,
                  textCapitalization: TextCapitalization.words,
                  decoration: InputDecoration(
                    labelText: l10n.authFirstName,
                    prefixIcon: const Icon(Icons.person_outline),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // Cognome
                TextFormField(
                  controller: _lastNameController,
                  textInputAction: TextInputAction.next,
                  textCapitalization: TextCapitalization.words,
                  decoration: InputDecoration(
                    labelText: l10n.authLastName,
                    prefixIcon: const Icon(Icons.person_outline),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // Email
                TextFormField(
                  controller: _emailController,
                  keyboardType: TextInputType.emailAddress,
                  textInputAction: TextInputAction.next,
                  decoration: InputDecoration(
                    labelText: l10n.authEmail,
                    prefixIcon: const Icon(Icons.email_outlined),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    if (!value.contains('@')) {
                      return l10n.authInvalidEmail;
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // Telefono (opzionale)
                TextFormField(
                  controller: _phoneController,
                  keyboardType: TextInputType.phone,
                  textInputAction: TextInputAction.next,
                  decoration: InputDecoration(
                    labelText: '${l10n.authPhone} (opzionale)',
                    prefixIcon: const Icon(Icons.phone_outlined),
                  ),
                ),
                const SizedBox(height: 16),

                // Password
                TextFormField(
                  controller: _passwordController,
                  obscureText: _obscurePassword,
                  textInputAction: TextInputAction.next,
                  decoration: InputDecoration(
                    labelText: l10n.authPassword,
                    prefixIcon: const Icon(Icons.lock_outlined),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscurePassword
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(() => _obscurePassword = !_obscurePassword);
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    if (value.length < 6) {
                      return l10n.authInvalidPassword;
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // Conferma Password
                TextFormField(
                  controller: _confirmPasswordController,
                  obscureText: _obscureConfirmPassword,
                  textInputAction: TextInputAction.done,
                  onFieldSubmitted: (_) => _handleRegister(),
                  decoration: InputDecoration(
                    labelText: l10n.authConfirmPassword,
                    prefixIcon: const Icon(Icons.lock_outlined),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscureConfirmPassword
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(
                          () => _obscureConfirmPassword =
                              !_obscureConfirmPassword,
                        );
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    if (value != _passwordController.text) {
                      return l10n.authPasswordMismatch;
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 24),

                // Errore
                if (authState.errorMessage != null) ...[
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: theme.colorScheme.error.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Row(
                      children: [
                        Icon(
                          Icons.error_outline,
                          color: theme.colorScheme.error,
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            l10n.authRegisterFailed,
                            style: TextStyle(color: theme.colorScheme.error),
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 16),
                ],

                // Bottone Registra
                ElevatedButton(
                  onPressed: authState.isLoading ? null : _handleRegister,
                  child: authState.isLoading
                      ? const SizedBox(
                          height: 20,
                          width: 20,
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            color: Colors.white,
                          ),
                        )
                      : Text(l10n.actionRegister),
                ),
                const SizedBox(height: 24),

                // Link login
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(l10n.authHaveAccount),
                    TextButton(
                      onPressed: () => context.go('/login'),
                      child: Text(l10n.actionLogin),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/auth/presentation/login_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/l10_extension.dart';
import '../providers/auth_provider.dart';

class LoginScreen extends ConsumerStatefulWidget {
  const LoginScreen({super.key});

  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends ConsumerState<LoginScreen> {
  final _formKey = GlobalKey<FormState>();
  final _emailController = TextEditingController();
  final _passwordController = TextEditingController();
  bool _obscurePassword = true;

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  Future<void> _handleLogin() async {
    if (!_formKey.currentState!.validate()) return;

    final success = await ref
        .read(authProvider.notifier)
        .login(
          email: _emailController.text.trim(),
          password: _passwordController.text,
        );

    if (success && mounted) {
      context.go('/booking');
    }
  }

  @override
  Widget build(BuildContext context) {
    final authState = ref.watch(authProvider);
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Scaffold(
      appBar: AppBar(
        leading: IconButton(
          icon: const Icon(Icons.arrow_back),
          onPressed: () => context.pop(),
        ),
        title: Text(l10n.authLoginTitle),
      ),
      body: SafeArea(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24),
          child: Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                const SizedBox(height: 32),

                // Logo o icona
                Icon(
                  Icons.lock_outline,
                  size: 64,
                  color: theme.colorScheme.primary,
                ),
                const SizedBox(height: 32),

                // Email
                TextFormField(
                  controller: _emailController,
                  keyboardType: TextInputType.emailAddress,
                  textInputAction: TextInputAction.next,
                  decoration: InputDecoration(
                    labelText: l10n.authEmail,
                    prefixIcon: const Icon(Icons.email_outlined),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    if (!value.contains('@')) {
                      return l10n.authInvalidEmail;
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 16),

                // Password
                TextFormField(
                  controller: _passwordController,
                  obscureText: _obscurePassword,
                  textInputAction: TextInputAction.done,
                  onFieldSubmitted: (_) => _handleLogin(),
                  decoration: InputDecoration(
                    labelText: l10n.authPassword,
                    prefixIcon: const Icon(Icons.lock_outlined),
                    suffixIcon: IconButton(
                      icon: Icon(
                        _obscurePassword
                            ? Icons.visibility_outlined
                            : Icons.visibility_off_outlined,
                      ),
                      onPressed: () {
                        setState(() => _obscurePassword = !_obscurePassword);
                      },
                    ),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return l10n.authRequiredField;
                    }
                    if (value.length < 6) {
                      return l10n.authInvalidPassword;
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 8),

                // Password dimenticata
                Align(
                  alignment: Alignment.centerRight,
                  child: TextButton(
                    onPressed: () => _showResetPasswordDialog(context, ref),
                    child: Text(l10n.authForgotPassword),
                  ),
                ),
                const SizedBox(height: 24),

                // Errore
                if (authState.errorMessage != null) ...[
                  Container(
                    padding: const EdgeInsets.all(12),
                    decoration: BoxDecoration(
                      color: theme.colorScheme.error.withOpacity(0.1),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Row(
                      children: [
                        Icon(
                          Icons.error_outline,
                          color: theme.colorScheme.error,
                        ),
                        const SizedBox(width: 8),
                        Expanded(
                          child: Text(
                            l10n.authLoginFailed,
                            style: TextStyle(color: theme.colorScheme.error),
                          ),
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(height: 16),
                ],

                // Bottone Login
                ElevatedButton(
                  onPressed: authState.isLoading ? null : _handleLogin,
                  child: authState.isLoading
                      ? const SizedBox(
                          height: 20,
                          width: 20,
                          child: CircularProgressIndicator(
                            strokeWidth: 2,
                            color: Colors.white,
                          ),
                        )
                      : Text(l10n.actionLogin),
                ),
                const SizedBox(height: 24),

                // Link registrazione
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(l10n.authNoAccount),
                    TextButton(
                      onPressed: () => context.go('/register'),
                      child: Text(l10n.actionRegister),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  void _showResetPasswordDialog(BuildContext context, WidgetRef ref) {
    final emailController = TextEditingController();
    final l10n = context.l10n;

    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.authResetPasswordTitle),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(l10n.authResetPasswordMessage),
            const SizedBox(height: 16),
            TextField(
              controller: emailController,
              keyboardType: TextInputType.emailAddress,
              decoration: InputDecoration(
                labelText: l10n.authEmail,
                prefixIcon: const Icon(Icons.email_outlined),
              ),
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text(l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () async {
              final email = emailController.text.trim();
              if (email.isEmpty) return;

              Navigator.pop(context);

              final success = await ref
                  .read(authProvider.notifier)
                  .resetPassword(email);

              if (context.mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text(
                      success
                          ? l10n.authResetPasswordSuccess
                          : l10n.authResetPasswordError,
                    ),
                    backgroundColor: success ? Colors.green : Colors.red,
                  ),
                );
              }
            },
            child: Text(l10n.authResetPasswordSend),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/booking/providers/booking_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_riverpod/legacy.dart';

import '../../../core/models/booking_request.dart';
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/models/staff.dart';
import '../../../core/models/time_slot.dart';
import '../data/booking_repository.dart';
import '../domain/booking_config.dart';

/// Provider per il repository
final bookingRepositoryProvider = Provider<BookingRepository>((ref) {
  return BookingRepository();
});

/// Provider per la configurazione del booking
final bookingConfigProvider = Provider<BookingConfig>((ref) {
  return defaultBookingConfig;
});

/// Step del flow di prenotazione
enum BookingStep { services, staff, dateTime, summary, confirmation }

/// Stato del flow di prenotazione
class BookingFlowState {
  final BookingStep currentStep;
  final BookingRequest request;
  final bool isLoading;
  final String? errorMessage;
  final String? confirmedBookingId;

  const BookingFlowState({
    this.currentStep = BookingStep.services,
    this.request = const BookingRequest(),
    this.isLoading = false,
    this.errorMessage,
    this.confirmedBookingId,
  });

  bool get canGoBack =>
      currentStep.index > 0 && currentStep != BookingStep.confirmation;

  bool get canGoNext {
    switch (currentStep) {
      case BookingStep.services:
        return request.services.isNotEmpty;
      case BookingStep.staff:
        return true; // Staff opzionale
      case BookingStep.dateTime:
        return request.selectedSlot != null;
      case BookingStep.summary:
        return request.isComplete;
      case BookingStep.confirmation:
        return false;
    }
  }

  BookingFlowState copyWith({
    BookingStep? currentStep,
    BookingRequest? request,
    bool? isLoading,
    String? errorMessage,
    String? confirmedBookingId,
    bool clearError = false,
  }) => BookingFlowState(
    currentStep: currentStep ?? this.currentStep,
    request: request ?? this.request,
    isLoading: isLoading ?? this.isLoading,
    errorMessage: clearError ? null : (errorMessage ?? this.errorMessage),
    confirmedBookingId: confirmedBookingId ?? this.confirmedBookingId,
  );
}

/// Provider principale per il flow di prenotazione
final bookingFlowProvider =
    NotifierProvider<BookingFlowNotifier, BookingFlowState>(
      BookingFlowNotifier.new,
    );

class BookingFlowNotifier extends Notifier<BookingFlowState> {
  @override
  BookingFlowState build() => const BookingFlowState();

  BookingRepository get _repository => ref.read(bookingRepositoryProvider);
  BookingConfig get _config => ref.read(bookingConfigProvider);

  /// Reset del flow
  void reset() {
    state = const BookingFlowState();
  }

  /// Vai allo step successivo
  void nextStep() {
    if (!state.canGoNext) return;

    final nextIndex = state.currentStep.index + 1;
    if (nextIndex < BookingStep.values.length) {
      // Se staff selection √® disabilitata, salta lo step staff
      var nextStep = BookingStep.values[nextIndex];
      if (nextStep == BookingStep.staff && !_config.allowStaffSelection) {
        nextStep = BookingStep.dateTime;
      }
      state = state.copyWith(currentStep: nextStep);
    }
  }

  /// Vai allo step precedente
  void previousStep() {
    if (!state.canGoBack) return;

    var prevIndex = state.currentStep.index - 1;
    var prevStep = BookingStep.values[prevIndex];

    // Se staff selection √® disabilitata, salta lo step staff
    if (prevStep == BookingStep.staff && !_config.allowStaffSelection) {
      prevIndex--;
      prevStep = BookingStep.values[prevIndex];
    }

    state = state.copyWith(currentStep: prevStep);
  }

  /// Vai a uno step specifico
  void goToStep(BookingStep step) {
    if (step.index < state.currentStep.index) {
      state = state.copyWith(currentStep: step);
    }
  }

  /// Toggle selezione servizio
  void toggleService(Service service) {
    final currentServices = List<Service>.from(state.request.services);

    if (currentServices.any((s) => s.id == service.id)) {
      currentServices.removeWhere((s) => s.id == service.id);
    } else {
      currentServices.add(service);
    }

    // Quando cambiano i servizi, resetta slot selezionato
    state = state.copyWith(
      request: state.request.copyWith(
        services: currentServices,
        clearSlot: true,
      ),
    );
  }

  /// Seleziona staff
  void selectStaff(Staff? staff) {
    state = state.copyWith(
      request: state.request.copyWith(
        selectedStaff: staff,
        clearStaff: staff == null,
        clearSlot: true, // Resetta slot quando cambia staff
      ),
    );
  }

  /// Seleziona slot temporale
  void selectTimeSlot(TimeSlot slot) {
    state = state.copyWith(request: state.request.copyWith(selectedSlot: slot));
  }

  /// Aggiorna note
  void updateNotes(String notes) {
    state = state.copyWith(request: state.request.copyWith(notes: notes));
  }

  /// Conferma prenotazione
  Future<bool> confirmBooking() async {
    if (!state.request.isComplete) return false;

    state = state.copyWith(isLoading: true, clearError: true);

    try {
      final bookingId = await _repository.confirmBooking(
        businessId: _config.businessId,
        locationId: _config.locationId,
        serviceIds: state.request.services.map((s) => s.id).toList(),
        startTime: state.request.selectedSlot!.startTime,
        staffId: state.request.selectedStaff?.id,
        notes: state.request.notes,
      );

      state = state.copyWith(
        isLoading: false,
        currentStep: BookingStep.confirmation,
        confirmedBookingId: bookingId,
      );
      return true;
    } catch (e) {
      state = state.copyWith(isLoading: false, errorMessage: e.toString());
      return false;
    }
  }
}

/// Provider per le categorie
final categoriesProvider = FutureProvider<List<ServiceCategory>>((ref) async {
  final repository = ref.read(bookingRepositoryProvider);
  final config = ref.read(bookingConfigProvider);
  final categories = await repository.getCategories(config.businessId);
  // Ordina per sortOrder (crea una nuova lista per evitare modificare const)
  final sortedCategories = List<ServiceCategory>.from(categories);
  sortedCategories.sort((a, b) => a.sortOrder.compareTo(b.sortOrder));
  return sortedCategories;
});

/// Provider per i servizi
final servicesProvider = FutureProvider<List<Service>>((ref) async {
  final repository = ref.read(bookingRepositoryProvider);
  final config = ref.read(bookingConfigProvider);
  final services = await repository.getServices(config.businessId);
  // Ordina per sortOrder (crea una nuova lista per evitare modificare const)
  final sortedServices = List<Service>.from(services);
  sortedServices.sort((a, b) => a.sortOrder.compareTo(b.sortOrder));
  return sortedServices;
});

/// Provider per lo staff
final staffProvider = FutureProvider<List<Staff>>((ref) async {
  final repository = ref.read(bookingRepositoryProvider);
  final config = ref.read(bookingConfigProvider);
  final staff = await repository.getStaff(config.businessId);
  // Ordina per sortOrder (crea una nuova lista per evitare modificare const)
  final sortedStaff = List<Staff>.from(staff);
  sortedStaff.sort((a, b) => a.sortOrder.compareTo(b.sortOrder));
  return sortedStaff;
});

/// Provider per la data selezionata nel calendario
final selectedDateProvider = StateProvider<DateTime?>((ref) => null);

/// Provider per gli slot disponibili
final availableSlotsProvider = FutureProvider<List<TimeSlot>>((ref) async {
  final repository = ref.read(bookingRepositoryProvider);
  final config = ref.read(bookingConfigProvider);
  final bookingState = ref.watch(bookingFlowProvider);
  final selectedDate = ref.watch(selectedDateProvider);

  if (selectedDate == null || bookingState.request.services.isEmpty) {
    return [];
  }

  return repository.getAvailableSlots(
    businessId: config.businessId,
    locationId: config.locationId,
    date: selectedDate,
    totalDurationMinutes: bookingState.request.totalDurationMinutes,
    staffId: bookingState.request.selectedStaff?.id,
  );
});

/// Provider per la prima data disponibile
final firstAvailableDateProvider = FutureProvider<DateTime>((ref) async {
  final repository = ref.read(bookingRepositoryProvider);
  final config = ref.read(bookingConfigProvider);
  final bookingState = ref.watch(bookingFlowProvider);

  return repository.getFirstAvailableDate(
    businessId: config.businessId,
    locationId: config.locationId,
    totalDurationMinutes: bookingState.request.totalDurationMinutes,
    staffId: bookingState.request.selectedStaff?.id,
  );
});
--- FILE: lib/features/booking/data/booking_repository.dart ---
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/models/staff.dart';
import '../../../core/models/time_slot.dart';

/// Repository per le prenotazioni (Mock API)
class BookingRepository {
  /// Recupera le categorie di servizi ordinate
  Future<List<ServiceCategory>> getCategories(int businessId) async {
    await Future.delayed(const Duration(milliseconds: 500));
    
    return [
      const ServiceCategory(id: 1, businessId: 1, name: 'Taglio', sortOrder: 1),
      const ServiceCategory(id: 2, businessId: 1, name: 'Colore', sortOrder: 2),
      const ServiceCategory(id: 3, businessId: 1, name: 'Trattamenti', sortOrder: 3),
      const ServiceCategory(id: 4, businessId: 1, name: 'Styling', sortOrder: 4),
    ];
  }

  /// Recupera i servizi prenotabili online ordinati
  Future<List<Service>> getServices(int businessId) async {
    await Future.delayed(const Duration(milliseconds: 500));
    
    return [
      // Categoria Taglio
      const Service(
        id: 1, businessId: 1, categoryId: 1,
        name: 'Taglio Uomo', durationMinutes: 30, price: 20.0, sortOrder: 1,
      ),
      const Service(
        id: 2, businessId: 1, categoryId: 1,
        name: 'Taglio Donna', durationMinutes: 45, price: 35.0, sortOrder: 2,
      ),
      const Service(
        id: 3, businessId: 1, categoryId: 1,
        name: 'Taglio Bambino', durationMinutes: 20, price: 15.0, sortOrder: 3,
      ),
      // Categoria Colore
      const Service(
        id: 4, businessId: 1, categoryId: 2,
        name: 'Colore Base', durationMinutes: 60, price: 45.0, sortOrder: 1,
      ),
      const Service(
        id: 5, businessId: 1, categoryId: 2,
        name: 'Meches', durationMinutes: 90, price: 65.0, sortOrder: 2,
      ),
      const Service(
        id: 6, businessId: 1, categoryId: 2,
        name: 'Balayage', durationMinutes: 120, price: 85.0, isPriceStartingFrom: true, sortOrder: 3,
      ),
      // Categoria Trattamenti
      const Service(
        id: 7, businessId: 1, categoryId: 3,
        name: 'Trattamento Ristrutturante', durationMinutes: 30, price: 25.0, sortOrder: 1,
      ),
      const Service(
        id: 8, businessId: 1, categoryId: 3,
        name: 'Maschera Nutriente', durationMinutes: 20, price: 15.0, sortOrder: 2,
      ),
      // Categoria Styling
      const Service(
        id: 9, businessId: 1, categoryId: 4,
        name: 'Piega', durationMinutes: 30, price: 20.0, sortOrder: 1,
      ),
      const Service(
        id: 10, businessId: 1, categoryId: 4,
        name: 'Acconciatura Sposa', durationMinutes: 90, price: 120.0, isPriceStartingFrom: true, sortOrder: 2,
      ),
    ];
  }

  /// Recupera gli staff prenotabili online
  Future<List<Staff>> getStaff(int businessId) async {
    await Future.delayed(const Duration(milliseconds: 500));
    
    return const [
      Staff(id: 1, businessId: 1, name: 'Marco', surname: 'Rossi', sortOrder: 1),
      Staff(id: 2, businessId: 1, name: 'Laura', surname: 'Bianchi', sortOrder: 2),
      Staff(id: 3, businessId: 1, name: 'Giuseppe', surname: 'Verdi', sortOrder: 3),
    ];
  }

  /// Recupera gli slot disponibili per una data e durata
  Future<List<TimeSlot>> getAvailableSlots({
    required int businessId,
    required int locationId,
    required DateTime date,
    required int totalDurationMinutes,
    int? staffId,
  }) async {
    await Future.delayed(const Duration(milliseconds: 800));
    
    final slots = <TimeSlot>[];
    final baseDate = DateTime(date.year, date.month, date.day);
    
    // Simula slot mattina (9:00 - 13:00)
    for (var hour = 9; hour < 13; hour++) {
      for (var minute = 0; minute < 60; minute += 30) {
        final start = baseDate.add(Duration(hours: hour, minutes: minute));
        final end = start.add(Duration(minutes: totalDurationMinutes));
        
        // Salta alcuni slot per simulare indisponibilit√†
        if (hour == 10 && minute == 30) continue;
        if (hour == 11 && minute == 0) continue;
        
        slots.add(TimeSlot(
          startTime: start,
          endTime: end,
          staffId: staffId,
        ));
      }
    }
    
    // Simula slot pomeriggio (14:00 - 19:00)
    for (var hour = 14; hour < 19; hour++) {
      for (var minute = 0; minute < 60; minute += 30) {
        final start = baseDate.add(Duration(hours: hour, minutes: minute));
        final end = start.add(Duration(minutes: totalDurationMinutes));
        
        // Salta alcuni slot per simulare indisponibilit√†
        if (hour == 15 && minute == 0) continue;
        if (hour == 16 && minute == 30) continue;
        
        slots.add(TimeSlot(
          startTime: start,
          endTime: end,
          staffId: staffId,
        ));
      }
    }
    
    return slots;
  }

  /// Trova la prima data disponibile
  Future<DateTime> getFirstAvailableDate({
    required int businessId,
    required int locationId,
    required int totalDurationMinutes,
    int? staffId,
  }) async {
    await Future.delayed(const Duration(milliseconds: 300));
    
    // Simula: prima disponibilit√† domani
    final now = DateTime.now();
    return DateTime(now.year, now.month, now.day + 1);
  }

  /// Conferma la prenotazione
  Future<String> confirmBooking({
    required int businessId,
    required int locationId,
    required List<int> serviceIds,
    required DateTime startTime,
    int? staffId,
    String? notes,
  }) async {
    await Future.delayed(const Duration(seconds: 1));
    
    // Genera un ID prenotazione mock
    final bookingId = 'BK${DateTime.now().millisecondsSinceEpoch}';
    return bookingId;
  }
}
--- FILE: lib/features/booking/domain/booking_config.dart ---
/// Configurazione per il flow di prenotazione
class BookingConfig {
  /// Consente all'utente di scegliere l'operatore
  final bool allowStaffSelection;
  
  /// ID del business
  final int businessId;
  
  /// ID della location (sede)
  final int locationId;

  const BookingConfig({
    this.allowStaffSelection = true,
    required this.businessId,
    required this.locationId,
  });
}

/// Provider per la configurazione (pu√≤ essere configurato dall'esterno)
const defaultBookingConfig = BookingConfig(
  allowStaffSelection: true,
  businessId: 1,
  locationId: 1,
);
--- FILE: lib/features/booking/presentation/screens/staff_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/staff.dart';
import '../../providers/booking_provider.dart';

class StaffStep extends ConsumerWidget {
  const StaffStep({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final staffAsync = ref.watch(staffProvider);
    final bookingState = ref.watch(bookingFlowProvider);
    final selectedStaff = bookingState.request.selectedStaff;

    return Column(
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                l10n.staffTitle,
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                l10n.staffSubtitle,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurface.withOpacity(0.7),
                ),
              ),
            ],
          ),
        ),

        // Lista staff
        Expanded(
          child: staffAsync.when(
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (e, _) => Center(child: Text(l10n.errorLoadingStaff)),
            data: (staffList) => ListView(
              padding: const EdgeInsets.symmetric(horizontal: 16),
              children: [
                // Opzione "Qualsiasi operatore"
                _StaffTile(
                  staff: null,
                  isSelected: selectedStaff == null,
                  onTap: () {
                    ref.read(bookingFlowProvider.notifier).selectStaff(null);
                  },
                ),
                const SizedBox(height: 8),
                // Lista operatori
                ...staffList
                    .where((s) => s.isBookableOnline)
                    .map(
                      (staff) => Padding(
                        padding: const EdgeInsets.only(bottom: 8),
                        child: _StaffTile(
                          staff: staff,
                          isSelected: selectedStaff?.id == staff.id,
                          onTap: () {
                            ref
                                .read(bookingFlowProvider.notifier)
                                .selectStaff(staff);
                          },
                        ),
                      ),
                    ),
              ],
            ),
          ),
        ),

        // Footer con bottone
        _buildFooter(context, ref),
      ],
    );
  }

  Widget _buildFooter(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, -5),
          ),
        ],
      ),
      child: SafeArea(
        child: ElevatedButton(
          onPressed: () => ref.read(bookingFlowProvider.notifier).nextStep(),
          child: Text(l10n.actionNext),
        ),
      ),
    );
  }
}

class _StaffTile extends StatelessWidget {
  final Staff? staff;
  final bool isSelected;
  final VoidCallback onTap;

  const _StaffTile({
    required this.staff,
    required this.isSelected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    return Card(
      margin: EdgeInsets.zero,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(
          color: isSelected ? theme.colorScheme.primary : theme.dividerColor,
          width: isSelected ? 2 : 1,
        ),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Avatar
              CircleAvatar(
                radius: 24,
                backgroundColor: staff == null
                    ? theme.colorScheme.primary.withOpacity(0.1)
                    : theme.colorScheme.secondary.withOpacity(0.1),
                child: staff == null
                    ? Icon(Icons.groups, color: theme.colorScheme.primary)
                    : Text(
                        staff!.initials,
                        style: TextStyle(
                          color: theme.colorScheme.secondary,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
              ),
              const SizedBox(width: 16),
              // Info
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      staff?.displayName ?? l10n.staffAnyOperator,
                      style: theme.textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    if (staff == null) ...[
                      const SizedBox(height: 4),
                      Text(
                        l10n.staffAnyOperatorSubtitle,
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurface.withOpacity(0.6),
                        ),
                      ),
                    ],
                  ],
                ),
              ),
              // Radio
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected
                      ? theme.colorScheme.primary
                      : Colors.transparent,
                  border: Border.all(
                    color: isSelected
                        ? theme.colorScheme.primary
                        : theme.colorScheme.onSurface.withOpacity(0.3),
                    width: 2,
                  ),
                ),
                child: isSelected
                    ? const Icon(Icons.check, size: 16, color: Colors.white)
                    : null,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/summary_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../providers/booking_provider.dart';

class SummaryStep extends ConsumerStatefulWidget {
  const SummaryStep({super.key});

  @override
  ConsumerState<SummaryStep> createState() => _SummaryStepState();
}

class _SummaryStepState extends ConsumerState<SummaryStep> {
  final _notesController = TextEditingController();

  @override
  void dispose() {
    _notesController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final bookingState = ref.watch(bookingFlowProvider);
    final request = bookingState.request;

    return Column(
      children: [
        Expanded(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Header
                Text(
                  l10n.summaryTitle,
                  style: theme.textTheme.headlineSmall?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  l10n.summarySubtitle,
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.onSurface.withOpacity(0.7),
                  ),
                ),
                const SizedBox(height: 24),

                // Servizi selezionati
                _SummarySection(
                  title: l10n.summaryServices,
                  icon: Icons.list_alt,
                  child: Column(
                    children: request.services.map((service) {
                      return Padding(
                        padding: const EdgeInsets.symmetric(vertical: 4),
                        child: Row(
                          mainAxisAlignment: MainAxisAlignment.spaceBetween,
                          children: [
                            Expanded(
                              child: Column(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: [
                                  Text(
                                    service.name,
                                    style: theme.textTheme.bodyMedium,
                                  ),
                                  Text(
                                    l10n.durationMinutes(
                                      service.durationMinutes,
                                    ),
                                    style: theme.textTheme.bodySmall?.copyWith(
                                      color: theme.colorScheme.onSurface
                                          .withOpacity(0.6),
                                    ),
                                  ),
                                ],
                              ),
                            ),
                            Text(
                              service.formattedPrice,
                              style: theme.textTheme.bodyMedium?.copyWith(
                                fontWeight: FontWeight.w600,
                              ),
                            ),
                          ],
                        ),
                      );
                    }).toList(),
                  ),
                ),
                const SizedBox(height: 16),

                // Operatore
                if (request.selectedStaff != null)
                  _SummarySection(
                    title: l10n.summaryOperator,
                    icon: Icons.person,
                    child: Row(
                      children: [
                        CircleAvatar(
                          radius: 20,
                          backgroundColor: theme.colorScheme.primary
                              .withOpacity(0.1),
                          child: Text(
                            request.selectedStaff!.initials,
                            style: TextStyle(
                              color: theme.colorScheme.primary,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                        const SizedBox(width: 12),
                        Text(
                          request.selectedStaff!.displayName,
                          style: theme.textTheme.bodyMedium,
                        ),
                      ],
                    ),
                  ),
                if (request.selectedStaff != null) const SizedBox(height: 16),

                // Data e ora
                if (request.selectedSlot != null)
                  _SummarySection(
                    title: l10n.summaryDateTime,
                    icon: Icons.calendar_today,
                    child: Text(
                      DateFormat(
                        "EEEE d MMMM yyyy 'alle' HH:mm",
                        'it',
                      ).format(request.selectedSlot!.startTime),
                      style: theme.textTheme.bodyMedium,
                    ),
                  ),
                if (request.selectedSlot != null) const SizedBox(height: 16),

                // Durata totale
                _SummarySection(
                  title: l10n.summaryDuration,
                  icon: Icons.schedule,
                  child: Text(
                    l10n.durationMinutes(request.totalDurationMinutes),
                    style: theme.textTheme.bodyMedium,
                  ),
                ),
                const SizedBox(height: 16),

                // Prezzo totale
                _SummarySection(
                  title: l10n.summaryPrice,
                  icon: Icons.euro,
                  child: Text(
                    request.formattedTotalPrice,
                    style: theme.textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: theme.colorScheme.primary,
                    ),
                  ),
                ),
                const SizedBox(height: 24),

                // Note
                Text(
                  l10n.summaryNotes,
                  style: theme.textTheme.titleSmall?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: 8),
                TextField(
                  controller: _notesController,
                  maxLines: 3,
                  decoration: InputDecoration(
                    hintText: l10n.summaryNotesHint,
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                  onChanged: (value) {
                    ref.read(bookingFlowProvider.notifier).updateNotes(value);
                  },
                ),
              ],
            ),
          ),
        ),

        // Footer
        _buildFooter(context, ref, bookingState),
      ],
    );
  }

  Widget _buildFooter(
    BuildContext context,
    WidgetRef ref,
    BookingFlowState state,
  ) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, -5),
          ),
        ],
      ),
      child: SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Errore
            if (state.errorMessage != null) ...[
              Container(
                padding: const EdgeInsets.all(12),
                margin: const EdgeInsets.only(bottom: 12),
                decoration: BoxDecoration(
                  color: theme.colorScheme.error.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Row(
                  children: [
                    Icon(Icons.error_outline, color: theme.colorScheme.error),
                    const SizedBox(width: 8),
                    Expanded(
                      child: Text(
                        state.errorMessage!,
                        style: TextStyle(color: theme.colorScheme.error),
                      ),
                    ),
                  ],
                ),
              ),
            ],
            // Bottone conferma
            ElevatedButton(
              onPressed: state.isLoading
                  ? null
                  : () =>
                        ref.read(bookingFlowProvider.notifier).confirmBooking(),
              child: state.isLoading
                  ? const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: Colors.white,
                      ),
                    )
                  : Text(l10n.actionConfirm),
            ),
          ],
        ),
      ),
    );
  }
}

class _SummarySection extends StatelessWidget {
  final String title;
  final IconData icon;
  final Widget child;

  const _SummarySection({
    required this.title,
    required this.icon,
    required this.child,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Card(
      margin: EdgeInsets.zero,
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Icon(icon, size: 18, color: theme.colorScheme.primary),
                const SizedBox(width: 8),
                Text(
                  title,
                  style: theme.textTheme.titleSmall?.copyWith(
                    fontWeight: FontWeight.w600,
                    color: theme.colorScheme.onSurface.withOpacity(0.7),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            child,
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/services_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';
import '../../providers/booking_provider.dart';

class ServicesStep extends ConsumerWidget {
  const ServicesStep({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final categoriesAsync = ref.watch(categoriesProvider);
    final servicesAsync = ref.watch(servicesProvider);
    final bookingState = ref.watch(bookingFlowProvider);
    final selectedServices = bookingState.request.services;

    return Column(
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                l10n.servicesTitle,
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              Text(
                l10n.servicesSubtitle,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.onSurface.withOpacity(0.7),
                ),
              ),
            ],
          ),
        ),

        // Lista servizi per categoria
        Expanded(
          child: categoriesAsync.when(
            loading: () => const Center(child: CircularProgressIndicator()),
            error: (e, _) => Center(child: Text(l10n.errorLoadingServices)),
            data: (categories) => servicesAsync.when(
              loading: () => const Center(child: CircularProgressIndicator()),
              error: (e, _) => Center(child: Text(l10n.errorLoadingServices)),
              data: (services) => _buildServicesList(
                context,
                ref,
                categories,
                services,
                selectedServices,
              ),
            ),
          ),
        ),

        // Footer con selezione e bottone
        _buildFooter(context, ref, selectedServices),
      ],
    );
  }

  Widget _buildServicesList(
    BuildContext context,
    WidgetRef ref,
    List<ServiceCategory> categories,
    List<Service> services,
    List<Service> selectedServices,
  ) {
    return ListView.builder(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      itemCount: categories.length,
      itemBuilder: (context, index) {
        final category = categories[index];
        final categoryServices =
            services
                .where((s) => s.categoryId == category.id && s.isBookableOnline)
                .toList()
              ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));

        if (categoryServices.isEmpty) return const SizedBox.shrink();

        return _CategorySection(
          category: category,
          services: categoryServices,
          selectedServices: selectedServices,
          onServiceTap: (service) {
            ref.read(bookingFlowProvider.notifier).toggleService(service);
          },
        );
      },
    );
  }

  Widget _buildFooter(
    BuildContext context,
    WidgetRef ref,
    List<Service> selectedServices,
  ) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final bookingState = ref.watch(bookingFlowProvider);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, -5),
          ),
        ],
      ),
      child: SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Info selezione
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  l10n.servicesSelected(selectedServices.length),
                  style: theme.textTheme.bodyMedium,
                ),
                if (selectedServices.isNotEmpty)
                  Text(
                    bookingState.request.formattedTotalPrice,
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                      color: theme.colorScheme.primary,
                    ),
                  ),
              ],
            ),
            const SizedBox(height: 12),
            // Bottone avanti
            ElevatedButton(
              onPressed: bookingState.canGoNext
                  ? () => ref.read(bookingFlowProvider.notifier).nextStep()
                  : null,
              child: Text(l10n.actionNext),
            ),
          ],
        ),
      ),
    );
  }
}

class _CategorySection extends StatelessWidget {
  final ServiceCategory category;
  final List<Service> services;
  final List<Service> selectedServices;
  final void Function(Service) onServiceTap;

  const _CategorySection({
    required this.category,
    required this.services,
    required this.selectedServices,
    required this.onServiceTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.symmetric(vertical: 12),
          child: Text(
            category.name,
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
        ...services.map((service) {
          final isSelected = selectedServices.any((s) => s.id == service.id);
          return _ServiceTile(
            service: service,
            isSelected: isSelected,
            onTap: () => onServiceTap(service),
          );
        }),
        const SizedBox(height: 8),
      ],
    );
  }
}

class _ServiceTile extends StatelessWidget {
  final Service service;
  final bool isSelected;
  final VoidCallback onTap;

  const _ServiceTile({
    required this.service,
    required this.isSelected,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    return Card(
      margin: const EdgeInsets.only(bottom: 8),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(
          color: isSelected ? theme.colorScheme.primary : theme.dividerColor,
          width: isSelected ? 2 : 1,
        ),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              // Checkbox
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: isSelected
                      ? theme.colorScheme.primary
                      : Colors.transparent,
                  border: Border.all(
                    color: isSelected
                        ? theme.colorScheme.primary
                        : theme.colorScheme.onSurface.withOpacity(0.3),
                    width: 2,
                  ),
                ),
                child: isSelected
                    ? const Icon(Icons.check, size: 16, color: Colors.white)
                    : null,
              ),
              const SizedBox(width: 16),
              // Info servizio
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      service.name,
                      style: theme.textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      l10n.servicesDuration(service.durationMinutes),
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onSurface.withOpacity(0.6),
                      ),
                    ),
                  ],
                ),
              ),
              // Prezzo
              Text(
                service.formattedPrice,
                style: theme.textTheme.titleSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                  color: theme.colorScheme.primary,
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/booking_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../providers/booking_provider.dart';
import '../widgets/booking_step_indicator.dart';
import 'confirmation_step.dart';
import 'date_time_step.dart';
import 'services_step.dart';
import 'staff_step.dart';
import 'summary_step.dart';

class BookingScreen extends ConsumerWidget {
  const BookingScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final bookingState = ref.watch(bookingFlowProvider);
    final config = ref.watch(bookingConfigProvider);
    final l10n = context.l10n;

    return Scaffold(
      appBar: AppBar(
        title: Text(l10n.bookingTitle),
        leading: bookingState.canGoBack
            ? IconButton(
                icon: const Icon(Icons.arrow_back),
                onPressed: () =>
                    ref.read(bookingFlowProvider.notifier).previousStep(),
              )
            : null,
      ),
      body: Column(
        children: [
          // Step indicator
          if (bookingState.currentStep != BookingStep.confirmation)
            BookingStepIndicator(
              currentStep: bookingState.currentStep,
              allowStaffSelection: config.allowStaffSelection,
              onStepTap: (step) {
                ref.read(bookingFlowProvider.notifier).goToStep(step);
              },
            ),

          // Content
          Expanded(
            child: AnimatedSwitcher(
              duration: const Duration(milliseconds: 300),
              child: _buildStepContent(bookingState.currentStep),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStepContent(BookingStep step) {
    switch (step) {
      case BookingStep.services:
        return const ServicesStep();
      case BookingStep.staff:
        return const StaffStep();
      case BookingStep.dateTime:
        return const DateTimeStep();
      case BookingStep.summary:
        return const SummaryStep();
      case BookingStep.confirmation:
        return const ConfirmationStep();
    }
  }
}
--- FILE: lib/features/booking/presentation/screens/date_time_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/time_slot.dart';
import '../../providers/booking_provider.dart';

class DateTimeStep extends ConsumerStatefulWidget {
  const DateTimeStep({super.key});

  @override
  ConsumerState<DateTimeStep> createState() => _DateTimeStepState();
}

class _DateTimeStepState extends ConsumerState<DateTimeStep> {
  DateTime _focusedMonth = DateTime.now();

  @override
  void initState() {
    super.initState();
    // Imposta la prima data disponibile
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadFirstAvailableDate();
    });
  }

  Future<void> _loadFirstAvailableDate() async {
    final firstDateAsync = ref.read(firstAvailableDateProvider);
    firstDateAsync.whenData((date) {
      ref.read(selectedDateProvider.notifier).state = date;
      setState(() => _focusedMonth = date);
    });
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final selectedDate = ref.watch(selectedDateProvider);
    final slotsAsync = ref.watch(availableSlotsProvider);
    final bookingState = ref.watch(bookingFlowProvider);
    final firstDateAsync = ref.watch(firstAvailableDateProvider);

    return Column(
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.all(16),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                l10n.dateTimeTitle,
                style: theme.textTheme.headlineSmall?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 4),
              firstDateAsync.when(
                loading: () => const SizedBox.shrink(),
                error: (_, __) => const SizedBox.shrink(),
                data: (date) => Text(
                  l10n.dateTimeFirstAvailable(
                    DateFormat('EEEE d MMMM', 'it').format(date),
                  ),
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.primary,
                  ),
                ),
              ),
            ],
          ),
        ),

        // Contenuto scrollabile
        Expanded(
          child: SingleChildScrollView(
            child: Column(
              children: [
                // Calendario
                _buildCalendar(context, selectedDate),

                const Divider(),

                // Slot orari
                slotsAsync.when(
                  loading: () =>
                      const Center(child: CircularProgressIndicator()),
                  error: (e, _) =>
                      Center(child: Text(l10n.errorLoadingAvailability)),
                  data: (slots) => slots.isEmpty
                      ? Padding(
                          padding: const EdgeInsets.all(32),
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                Icons.event_busy,
                                size: 48,
                                color: theme.colorScheme.onSurface.withOpacity(
                                  0.3,
                                ),
                              ),
                              const SizedBox(height: 16),
                              Text(
                                l10n.dateTimeNoSlots,
                                textAlign: TextAlign.center,
                                style: theme.textTheme.bodyLarge?.copyWith(
                                  color: theme.colorScheme.onSurface
                                      .withOpacity(0.6),
                                ),
                              ),
                            ],
                          ),
                        )
                      : _buildTimeSlots(context, ref, slots),
                ),
              ],
            ),
          ),
        ),

        // Footer
        _buildFooter(context, ref, bookingState),
      ],
    );
  }

  Widget _buildCalendar(BuildContext context, DateTime? selectedDate) {
    final theme = Theme.of(context);
    final now = DateTime.now();
    final firstDayOfMonth = DateTime(
      _focusedMonth.year,
      _focusedMonth.month,
      1,
    );
    final lastDayOfMonth = DateTime(
      _focusedMonth.year,
      _focusedMonth.month + 1,
      0,
    );
    final firstWeekday = firstDayOfMonth.weekday;
    final daysInMonth = lastDayOfMonth.day;

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      child: Column(
        children: [
          // Header mese
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              IconButton(
                icon: const Icon(Icons.chevron_left),
                onPressed: () {
                  setState(() {
                    _focusedMonth = DateTime(
                      _focusedMonth.year,
                      _focusedMonth.month - 1,
                    );
                  });
                },
              ),
              Text(
                DateFormat('MMMM yyyy', 'it').format(_focusedMonth),
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
              ),
              IconButton(
                icon: const Icon(Icons.chevron_right),
                onPressed: () {
                  setState(() {
                    _focusedMonth = DateTime(
                      _focusedMonth.year,
                      _focusedMonth.month + 1,
                    );
                  });
                },
              ),
            ],
          ),
          const SizedBox(height: 8),
          // Giorni della settimana
          Row(
            children: ['L', 'M', 'M', 'G', 'V', 'S', 'D']
                .map(
                  (day) => Expanded(
                    child: Center(
                      child: Text(
                        day,
                        style: theme.textTheme.bodySmall?.copyWith(
                          fontWeight: FontWeight.bold,
                          color: theme.colorScheme.onSurface.withOpacity(0.5),
                        ),
                      ),
                    ),
                  ),
                )
                .toList(),
          ),
          const SizedBox(height: 8),
          // Griglia giorni
          GridView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 7,
              mainAxisSpacing: 4,
              crossAxisSpacing: 4,
            ),
            itemCount: 42,
            itemBuilder: (context, index) {
              final dayOffset = index - (firstWeekday - 1);
              if (dayOffset < 1 || dayOffset > daysInMonth) {
                return const SizedBox.shrink();
              }

              final date = DateTime(
                _focusedMonth.year,
                _focusedMonth.month,
                dayOffset,
              );
              final isToday =
                  date.year == now.year &&
                  date.month == now.month &&
                  date.day == now.day;
              final isPast = date.isBefore(
                DateTime(now.year, now.month, now.day),
              );
              final isSelected =
                  selectedDate != null &&
                  date.year == selectedDate.year &&
                  date.month == selectedDate.month &&
                  date.day == selectedDate.day;

              return GestureDetector(
                onTap: isPast
                    ? null
                    : () {
                        ref.read(selectedDateProvider.notifier).state = date;
                      },
                child: Container(
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    color: isSelected
                        ? theme.colorScheme.primary
                        : isToday
                        ? theme.colorScheme.primary.withOpacity(0.1)
                        : null,
                  ),
                  child: Center(
                    child: Text(
                      '$dayOffset',
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: isSelected
                            ? Colors.white
                            : isPast
                            ? theme.colorScheme.onSurface.withOpacity(0.3)
                            : theme.colorScheme.onSurface,
                        fontWeight: isToday || isSelected
                            ? FontWeight.bold
                            : null,
                      ),
                    ),
                  ),
                ),
              );
            },
          ),
        ],
      ),
    );
  }

  Widget _buildTimeSlots(
    BuildContext context,
    WidgetRef ref,
    List<TimeSlot> slots,
  ) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final bookingState = ref.watch(bookingFlowProvider);
    final selectedSlot = bookingState.request.selectedSlot;

    // Raggruppa per fascia oraria
    final morningSlots = slots.where((s) => s.startTime.hour < 12).toList();
    final afternoonSlots = slots
        .where((s) => s.startTime.hour >= 12 && s.startTime.hour < 18)
        .toList();
    final eveningSlots = slots.where((s) => s.startTime.hour >= 18).toList();

    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        if (morningSlots.isNotEmpty) ...[
          Text(l10n.dateTimeMorning, style: theme.textTheme.titleSmall),
          const SizedBox(height: 8),
          _buildSlotGrid(context, ref, morningSlots, selectedSlot),
          const SizedBox(height: 16),
        ],
        if (afternoonSlots.isNotEmpty) ...[
          Text(l10n.dateTimeAfternoon, style: theme.textTheme.titleSmall),
          const SizedBox(height: 8),
          _buildSlotGrid(context, ref, afternoonSlots, selectedSlot),
          const SizedBox(height: 16),
        ],
        if (eveningSlots.isNotEmpty) ...[
          Text(l10n.dateTimeEvening, style: theme.textTheme.titleSmall),
          const SizedBox(height: 8),
          _buildSlotGrid(context, ref, eveningSlots, selectedSlot),
        ],
      ],
    );
  }

  Widget _buildSlotGrid(
    BuildContext context,
    WidgetRef ref,
    List<TimeSlot> slots,
    TimeSlot? selectedSlot,
  ) {
    final theme = Theme.of(context);

    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: slots.map((slot) {
        final isSelected = selectedSlot?.startTime == slot.startTime;
        return GestureDetector(
          onTap: () {
            ref.read(bookingFlowProvider.notifier).selectTimeSlot(slot);
          },
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
            decoration: BoxDecoration(
              color: isSelected
                  ? theme.colorScheme.primary
                  : Colors.transparent,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(
                color: isSelected
                    ? theme.colorScheme.primary
                    : theme.dividerColor,
              ),
            ),
            child: Text(
              slot.formattedTime,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: isSelected ? Colors.white : theme.colorScheme.onSurface,
                fontWeight: isSelected ? FontWeight.bold : null,
              ),
            ),
          ),
        );
      }).toList(),
    );
  }

  Widget _buildFooter(
    BuildContext context,
    WidgetRef ref,
    BookingFlowState state,
  ) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(top: BorderSide(color: theme.dividerColor)),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 10,
            offset: const Offset(0, -5),
          ),
        ],
      ),
      child: SafeArea(
        child: ElevatedButton(
          onPressed: state.canGoNext
              ? () => ref.read(bookingFlowProvider.notifier).nextStep()
              : null,
          child: Text(l10n.actionNext),
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/screens/confirmation_step.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../providers/booking_provider.dart';

class ConfirmationStep extends ConsumerWidget {
  const ConfirmationStep({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final bookingState = ref.watch(bookingFlowProvider);

    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Spacer(),

            // Icona successo
            Container(
              width: 100,
              height: 100,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                color: Colors.green.withOpacity(0.1),
              ),
              child: const Icon(
                Icons.check_circle,
                size: 64,
                color: Colors.green,
              ),
            ),
            const SizedBox(height: 32),

            // Titolo
            Text(
              l10n.confirmationTitle,
              style: theme.textTheme.headlineSmall?.copyWith(
                fontWeight: FontWeight.bold,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),

            // Sottotitolo
            Text(
              l10n.confirmationSubtitle,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 24),

            // Codice prenotazione
            if (bookingState.confirmedBookingId != null)
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 24,
                  vertical: 16,
                ),
                decoration: BoxDecoration(
                  color: theme.colorScheme.primary.withOpacity(0.1),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  l10n.confirmationBookingId(bookingState.confirmedBookingId!),
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: theme.colorScheme.primary,
                  ),
                ),
              ),

            const Spacer(),

            // Bottoni azioni
            ElevatedButton(
              onPressed: () {
                ref.read(bookingFlowProvider.notifier).reset();
                context.go('/booking');
              },
              child: Text(l10n.confirmationNewBooking),
            ),
            const SizedBox(height: 12),
            OutlinedButton(
              onPressed: () {
                ref.read(bookingFlowProvider.notifier).reset();
                context.go('/');
              },
              child: Text(l10n.confirmationGoHome),
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/booking/presentation/widgets/booking_step_indicator.dart ---
import 'package:flutter/material.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../providers/booking_provider.dart';

class BookingStepIndicator extends StatelessWidget {
  final BookingStep currentStep;
  final bool allowStaffSelection;
  final void Function(BookingStep) onStepTap;

  const BookingStepIndicator({
    super.key,
    required this.currentStep,
    required this.allowStaffSelection,
    required this.onStepTap,
  });

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    final steps = [
      (BookingStep.services, l10n.bookingStepServices, Icons.list_alt),
      if (allowStaffSelection)
        (BookingStep.staff, l10n.bookingStepStaff, Icons.person),
      (BookingStep.dateTime, l10n.bookingStepDateTime, Icons.calendar_today),
      (
        BookingStep.summary,
        l10n.bookingStepSummary,
        Icons.check_circle_outline,
      ),
    ];

    return Container(
      padding: const EdgeInsets.symmetric(vertical: 16, horizontal: 8),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(bottom: BorderSide(color: theme.dividerColor)),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceEvenly,
        children: steps.asMap().entries.map((entry) {
          final index = entry.key;
          final (step, label, icon) = entry.value;
          final isActive = step == currentStep;
          final isPast = step.index < currentStep.index;
          final isClickable = isPast;

          return Expanded(
            child: GestureDetector(
              onTap: isClickable ? () => onStepTap(step) : null,
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Row(
                    children: [
                      if (index > 0)
                        Expanded(
                          child: Container(
                            height: 2,
                            color: isPast || isActive
                                ? theme.colorScheme.primary
                                : theme.dividerColor,
                          ),
                        ),
                      Container(
                        width: 32,
                        height: 32,
                        decoration: BoxDecoration(
                          shape: BoxShape.circle,
                          color: isActive
                              ? theme.colorScheme.primary
                              : isPast
                              ? theme.colorScheme.primary.withOpacity(0.2)
                              : theme.dividerColor,
                        ),
                        child: Icon(
                          isPast ? Icons.check : icon,
                          size: 18,
                          color: isActive
                              ? Colors.white
                              : isPast
                              ? theme.colorScheme.primary
                              : theme.colorScheme.onSurface.withOpacity(0.5),
                        ),
                      ),
                      if (index < steps.length - 1)
                        Expanded(
                          child: Container(
                            height: 2,
                            color: isPast
                                ? theme.colorScheme.primary
                                : theme.dividerColor,
                          ),
                        ),
                    ],
                  ),
                  const SizedBox(height: 8),
                  Text(
                    label,
                    style: theme.textTheme.bodySmall?.copyWith(
                      fontWeight: isActive
                          ? FontWeight.bold
                          : FontWeight.normal,
                      color: isActive || isPast
                          ? theme.colorScheme.onSurface
                          : theme.colorScheme.onSurface.withOpacity(0.5),
                    ),
                    textAlign: TextAlign.center,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ),
            ),
          );
        }).toList(),
      ),
    );
  }
}
--- FILE: lib/main.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'app/app.dart';

void main() {
  WidgetsFlutterBinding.ensureInitialized();
  runApp(
    const ProviderScope(
      child: App(),
    ),
  );
}
--- FILE: pubspec.yaml ---
name: agenda_frontend
description: "Frontend per prenotazioni online - Agenda Platform"
publish_to: 'none'
version: 1.0.0+1

environment:
  sdk: ^3.10.4

dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter
  
  intl: ^0.20.2    
  flutter_riverpod: ^3.0.3
  riverpod_annotation: ^3.0.3
  go_router: ^16.2.4

dev_dependencies:
  build_runner: ^2.7.1
  riverpod_generator: ^3.0.3
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0
  intl_utils: ^2.8.11

flutter:
  uses-material-design: true

flutter_intl:
  enabled: true
  class_name: L10n
  main_locale: it
  arb_dir: lib/core/l10n
  output_dir: lib/core/l10n

--------------------------

>>> CONTENUTO: Backend
--- FILE: lib/core/l10n/l10_extension.dart ---
import 'package:flutter/widgets.dart';

import 'l10n.dart';

/// üî§ Estensione per accedere facilmente alle stringhe localizzate.
///
/// Permette di scrivere:
/// ```dart
/// Text(context.l10n.welcomeMessage)
/// ```
/// invece di:
/// ```dart
/// Text(L10n.of(context).welcomeMessage)
/// ```
///
/// ‚úÖ Compatibile con aggiornamenti runtime della lingua.
/// ‚úÖ Evita dipendenze da `L10n.current` statico.
/// ‚úÖ Standard consigliato per progetti Flutter internazionalizzati.
extension L10nX on BuildContext {
  /// Restituisce l'istanza corrente di [L10n] per questo [BuildContext].
  L10n get l10n => L10n.of(this);
}

extension DurationLocalization on BuildContext {
  String localizedDurationLabel(int minutes) {
    final hours = minutes ~/ 60;
    final mins = minutes % 60;
    final l10n = this.l10n;

    if (hours > 0 && mins > 0) {
      return l10n.durationHourMinute(hours, mins);
    } else if (hours > 0) {
      return l10n.durationHour(hours);
    } else {
      return l10n.durationMinute(mins);
    }
  }
}
--- FILE: lib/core/l10n/intl/messages_all.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that looks up messages for specific locales by
// delegating to the appropriate library.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:implementation_imports, file_names, unnecessary_new
// ignore_for_file:unnecessary_brace_in_string_interps, directives_ordering
// ignore_for_file:argument_type_not_assignable, invalid_assignment
// ignore_for_file:prefer_single_quotes, prefer_generic_function_type_aliases
// ignore_for_file:comment_references

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';
import 'package:intl/src/intl_helpers.dart';

import 'messages_en.dart' as messages_en;
import 'messages_it.dart' as messages_it;

typedef Future<dynamic> LibraryLoader();
Map<String, LibraryLoader> _deferredLibraries = {
  'en': () => new SynchronousFuture(null),
  'it': () => new SynchronousFuture(null),
};

MessageLookupByLibrary? _findExact(String localeName) {
  switch (localeName) {
    case 'en':
      return messages_en.messages;
    case 'it':
      return messages_it.messages;
    default:
      return null;
  }
}

/// User programs should call this before using [localeName] for messages.
Future<bool> initializeMessages(String localeName) {
  var availableLocale = Intl.verifiedLocale(
    localeName,
    (locale) => _deferredLibraries[locale] != null,
    onFailure: (_) => null,
  );
  if (availableLocale == null) {
    return new SynchronousFuture(false);
  }
  var lib = _deferredLibraries[availableLocale];
  lib == null ? new SynchronousFuture(false) : lib();
  initializeInternalMessageLookup(() => new CompositeMessageLookup());
  messageLookup.addLocale(availableLocale, _findGeneratedMessagesFor);
  return new SynchronousFuture(true);
}

bool _messagesExistFor(String locale) {
  try {
    return _findExact(locale) != null;
  } catch (e) {
    return false;
  }
}

MessageLookupByLibrary? _findGeneratedMessagesFor(String locale) {
  var actualLocale = Intl.verifiedLocale(
    locale,
    _messagesExistFor,
    onFailure: (_) => null,
  );
  if (actualLocale == null) return null;
  return _findExact(actualLocale);
}
--- FILE: lib/core/l10n/intl/messages_it.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that provides messages for a it locale. All the
// messages from the main program should be duplicated here with the same
// function name.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:unnecessary_brace_in_string_interps, unnecessary_new
// ignore_for_file:prefer_single_quotes,comment_references, directives_ordering
// ignore_for_file:annotate_overrides,prefer_generic_function_type_aliases
// ignore_for_file:unused_import, file_names, avoid_escaping_inner_quotes
// ignore_for_file:unnecessary_string_interpolations, unnecessary_string_escapes

import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = new MessageLookup();

typedef String MessageIfAbsent(String messageStr, List<dynamic> args);

class MessageLookup extends MessageLookupByLibrary {
  String get localeName => 'it';

  static String m0(count) =>
      "Il cliente verr√† associato anche agli altri ${count} appuntamenti di questa prenotazione.";

  static String m1(name) => "Disponibilit√† ‚Äì ${name}";

  static String m2(clientName) => "Appuntamenti di ${clientName}";

  static String m3(hours) => "${hours} ora";

  static String m4(hours, minutes) => "${hours} ora ${minutes} min";

  static String m5(minutes) => "${minutes} min";

  static String m6(id) => "Eccezione non trovata: ${id}";

  static String m7(factor) => "Nessun builder disponibile per ${factor}";

  static String m8(path) => "Pagina non trovata: ${path}";

  static String m9(count) =>
      "${count} ${Intl.plural(count, one: 'giorno', other: 'giorni')}";

  static String m10(dates) => "Alcuni giorni non sono stati salvati: ${dates}.";

  static String m11(details) =>
      "Alcuni giorni non sono stati salvati: ${details}.";

  static String m12(hours) => "${hours}h";

  static String m13(hours, minutes) => "${hours}h ${minutes}m";

  static String m14(date) => "Ultima visita: ${date}";

  static String m15(newTime, staffName) =>
      "L\'appuntamento verr√† spostato alle ${newTime} per ${staffName}.";

  static String m16(count) => "${count} membri abilitati";

  static String m17(count) =>
      "${Intl.plural(count, one: '1 servizio selezionato', other: '${count} servizi selezionati')}";

  static String m18(dayName) =>
      "Elimina la fascia oraria settimanale di ogni ${dayName}";

  static String m19(date) => "Elimina solo la fascia oraria di ${date}";

  static String m20(dayName) =>
      "Modifica la fascia oraria settimanale di ogni ${dayName}";

  static String m21(date) => "Modifica solo la fascia oraria di ${date}";

  static String m22(count) => "${count} servizi abilitati";

  static String m23(selected, total) => "${selected} su ${total}";

  static String m24(hours) => "${hours} ore totale";

  final messages = _notInlinedMessages(_notInlinedMessages);
  static Map<String, Function> _notInlinedMessages(_) => <String, Function>{
    "actionCancel": MessageLookupByLibrary.simpleMessage("Annulla"),
    "actionClose": MessageLookupByLibrary.simpleMessage("Conferma"),
    "actionConfirm": MessageLookupByLibrary.simpleMessage("Conferma"),
    "actionDelete": MessageLookupByLibrary.simpleMessage("Elimina"),
    "actionDeleteBooking": MessageLookupByLibrary.simpleMessage(
      "Elimina prenotazione",
    ),
    "actionDiscard": MessageLookupByLibrary.simpleMessage("Annulla"),
    "actionEdit": MessageLookupByLibrary.simpleMessage("Modifica"),
    "actionKeepEditing": MessageLookupByLibrary.simpleMessage(
      "Continua a modificare",
    ),
    "actionSave": MessageLookupByLibrary.simpleMessage("Salva"),
    "addClientToAppointment": MessageLookupByLibrary.simpleMessage(
      "Aggiungi un cliente all\'appuntamento",
    ),
    "addService": MessageLookupByLibrary.simpleMessage("Aggiungi un servizio"),
    "addServiceTooltip": MessageLookupByLibrary.simpleMessage(
      "Aggiungi servizio",
    ),
    "additionalTimeOptionBlocked": MessageLookupByLibrary.simpleMessage(
      "Tempo bloccato",
    ),
    "additionalTimeOptionProcessing": MessageLookupByLibrary.simpleMessage(
      "Tempo di lavorazione",
    ),
    "additionalTimeSwitch": MessageLookupByLibrary.simpleMessage(
      "Tempo aggiuntivo",
    ),
    "agendaAdd": MessageLookupByLibrary.simpleMessage("Aggiungi"),
    "agendaAddAppointment": MessageLookupByLibrary.simpleMessage(
      "Nuovo appuntamento",
    ),
    "agendaAddBlock": MessageLookupByLibrary.simpleMessage("Nuovo blocco"),
    "agendaAddTitle": MessageLookupByLibrary.simpleMessage("Aggiungi un..."),
    "agendaNextDay": MessageLookupByLibrary.simpleMessage("Giorno successivo"),
    "agendaNextMonth": MessageLookupByLibrary.simpleMessage("Mese successivo"),
    "agendaNextWeek": MessageLookupByLibrary.simpleMessage(
      "Settimana successivo",
    ),
    "agendaNoLocations": MessageLookupByLibrary.simpleMessage(
      "Nessuna sede disponibile",
    ),
    "agendaNoOnDutyTeamTitle": MessageLookupByLibrary.simpleMessage(
      "Nessun membro del team di turno oggi",
    ),
    "agendaNoSelectedTeamTitle": MessageLookupByLibrary.simpleMessage(
      "Nessun membro del team selezionato",
    ),
    "agendaPrevDay": MessageLookupByLibrary.simpleMessage("Giorno precedente"),
    "agendaPrevMonth": MessageLookupByLibrary.simpleMessage("Mese precedente"),
    "agendaPrevWeek": MessageLookupByLibrary.simpleMessage(
      "Settimana precedente",
    ),
    "agendaSelectLocation": MessageLookupByLibrary.simpleMessage(
      "Seleziona sede",
    ),
    "agendaShowAllTeamButton": MessageLookupByLibrary.simpleMessage(
      "Visualizza tutto il team",
    ),
    "agendaToday": MessageLookupByLibrary.simpleMessage("Oggi"),
    "allLocations": MessageLookupByLibrary.simpleMessage("Tutte le sedi"),
    "appTitle": MessageLookupByLibrary.simpleMessage("Agenda Platform"),
    "applyClientToAllAppointmentsMessage": m0,
    "applyClientToAllAppointmentsTitle": MessageLookupByLibrary.simpleMessage(
      "Applicare il cliente a tutta la prenotazione?",
    ),
    "appointmentDialogTitleEdit": MessageLookupByLibrary.simpleMessage(
      "Modifica appuntamento",
    ),
    "appointmentDialogTitleNew": MessageLookupByLibrary.simpleMessage(
      "Nuovo appuntamento",
    ),
    "appointmentNoteLabel": MessageLookupByLibrary.simpleMessage(
      "Nota appuntamento",
    ),
    "appointmentNotesTitle": MessageLookupByLibrary.simpleMessage("Note"),
    "atLeastOneServiceRequired": MessageLookupByLibrary.simpleMessage(
      "Aggiungi almeno un servizio",
    ),
    "availabilitySave": MessageLookupByLibrary.simpleMessage("Salva modifiche"),
    "availabilityTitle": MessageLookupByLibrary.simpleMessage(
      "Disponibilit√† settimanale",
    ),
    "availabilityTitleFor": m1,
    "blockAllDay": MessageLookupByLibrary.simpleMessage("Giornata intera"),
    "blockDialogTitleEdit": MessageLookupByLibrary.simpleMessage(
      "Modifica blocco",
    ),
    "blockDialogTitleNew": MessageLookupByLibrary.simpleMessage("Nuovo blocco"),
    "blockEndTime": MessageLookupByLibrary.simpleMessage("Orario fine"),
    "blockReason": MessageLookupByLibrary.simpleMessage("Motivo (opzionale)"),
    "blockReasonHint": MessageLookupByLibrary.simpleMessage(
      "Es. Riunione, Pausa, ecc.",
    ),
    "blockSelectStaff": MessageLookupByLibrary.simpleMessage("Seleziona team"),
    "blockSelectStaffError": MessageLookupByLibrary.simpleMessage(
      "Seleziona almeno un team",
    ),
    "blockStartTime": MessageLookupByLibrary.simpleMessage("Orario inizio"),
    "blockTimeError": MessageLookupByLibrary.simpleMessage(
      "L\'ora di fine deve essere successiva all\'ora di inizio",
    ),
    "bookableOnlineSwitch": MessageLookupByLibrary.simpleMessage(
      "Prenotabile online",
    ),
    "bookingDetails": MessageLookupByLibrary.simpleMessage(
      "Dettagli prenotazione",
    ),
    "bookingItems": MessageLookupByLibrary.simpleMessage("Servizi"),
    "bookingNotes": MessageLookupByLibrary.simpleMessage("Note prenotazione"),
    "bookingStaffNotEligibleWarning": MessageLookupByLibrary.simpleMessage(
      "Attenzione: il membro del team selezionato non √® abilitato per questo servizio.",
    ),
    "bookingTotal": MessageLookupByLibrary.simpleMessage("Totale"),
    "bookingUnavailableTimeWarningAppointment":
        MessageLookupByLibrary.simpleMessage(
          "Attenzione: l‚Äôorario selezionato per l‚Äôappuntamento include fasce non disponibili per il team scelto.",
        ),
    "bookingUnavailableTimeWarningService": MessageLookupByLibrary.simpleMessage(
      "Attenzione: l‚Äôorario di questo servizio include fasce non disponibili per il team scelto.",
    ),
    "cannotDeleteCategoryContent": MessageLookupByLibrary.simpleMessage(
      "La categoria contiene uno o pi√π servizi.",
    ),
    "cannotDeleteTitle": MessageLookupByLibrary.simpleMessage(
      "Impossibile eliminare",
    ),
    "cannotUndoWarning": MessageLookupByLibrary.simpleMessage(
      "Questa azione non pu√≤ essere annullata.",
    ),
    "categoryDuplicateError": MessageLookupByLibrary.simpleMessage(
      "Esiste gi√† una categoria con questo nome",
    ),
    "clientAppointmentsEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessun appuntamento",
    ),
    "clientAppointmentsPast": MessageLookupByLibrary.simpleMessage("Passati"),
    "clientAppointmentsTitle": m2,
    "clientAppointmentsUpcoming": MessageLookupByLibrary.simpleMessage(
      "Prossimi",
    ),
    "clientLockedHint": MessageLookupByLibrary.simpleMessage(
      "Il cliente non pu√≤ essere modificato per questo appuntamento",
    ),
    "clientNoteLabel": MessageLookupByLibrary.simpleMessage("Nota cliente"),
    "clientOptionalHint": MessageLookupByLibrary.simpleMessage(
      "Lascia il campo vuoto se non vuoi associare un cliente all\'appuntamento",
    ),
    "clientsEdit": MessageLookupByLibrary.simpleMessage("Modifica cliente"),
    "clientsEmpty": MessageLookupByLibrary.simpleMessage("Nessun cliente"),
    "clientsNew": MessageLookupByLibrary.simpleMessage("Nuovo cliente"),
    "clientsTitle": MessageLookupByLibrary.simpleMessage("Elenco Clienti"),
    "createCategoryButtonLabel": MessageLookupByLibrary.simpleMessage(
      "Nuova categoria",
    ),
    "createNewClient": MessageLookupByLibrary.simpleMessage(
      "Crea nuovo cliente",
    ),
    "currentWeek": MessageLookupByLibrary.simpleMessage("Settimana corrente"),
    "dayFridayFull": MessageLookupByLibrary.simpleMessage("venerd√¨"),
    "dayMondayFull": MessageLookupByLibrary.simpleMessage("luned√¨"),
    "daySaturdayFull": MessageLookupByLibrary.simpleMessage("sabato"),
    "daySundayFull": MessageLookupByLibrary.simpleMessage("domenica"),
    "dayThursdayFull": MessageLookupByLibrary.simpleMessage("gioved√¨"),
    "dayTuesdayFull": MessageLookupByLibrary.simpleMessage("marted√¨"),
    "dayWednesdayFull": MessageLookupByLibrary.simpleMessage("mercoled√¨"),
    "deleteAppointmentConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "L\'appuntamento verr√† rimosso. L\'operazione non pu√≤ essere annullata.",
    ),
    "deleteAppointmentConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare l\'appuntamento?",
    ),
    "deleteBookingConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "Verranno rimossi tutti i servizi collegati. L\'operazione non pu√≤ essere annullata.",
    ),
    "deleteBookingConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare l‚Äôintera prenotazione?",
    ),
    "deleteClientConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "Il cliente verr√† eliminato definitivamente. Questa azione non pu√≤ essere annullata.",
    ),
    "deleteClientConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare il cliente?",
    ),
    "deleteConfirmationTitle": MessageLookupByLibrary.simpleMessage(
      "Confermi l‚Äôeliminazione?",
    ),
    "deleteServiceQuestion": MessageLookupByLibrary.simpleMessage(
      "Eliminare il servizio?",
    ),
    "discardChangesMessage": MessageLookupByLibrary.simpleMessage(
      "Hai delle modifiche non salvate. Vuoi scartarle?",
    ),
    "discardChangesTitle": MessageLookupByLibrary.simpleMessage(
      "Modifiche non salvate",
    ),
    "duplicateAction": MessageLookupByLibrary.simpleMessage("Duplica"),
    "durationHour": m3,
    "durationHourMinute": m4,
    "durationMinute": m5,
    "editCategoryTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica categoria",
    ),
    "editServiceTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica servizio",
    ),
    "emptyCategoriesNotReorderableNote": MessageLookupByLibrary.simpleMessage(
      "Le categorie senza servizi non sono riordinabili e restano in coda.",
    ),
    "errorExceptionNotFound": m6,
    "errorFormFactorBuilderMissing": m7,
    "errorFormFactorBuilderRequired": MessageLookupByLibrary.simpleMessage(
      "Specificare almeno un builder per form factor",
    ),
    "errorNotFound": m8,
    "errorServiceNotFound": MessageLookupByLibrary.simpleMessage(
      "Servizio non trovato",
    ),
    "errorTitle": MessageLookupByLibrary.simpleMessage("Errore"),
    "exceptionAllDay": MessageLookupByLibrary.simpleMessage("Giornata intera"),
    "exceptionAvailableNoEffect": MessageLookupByLibrary.simpleMessage(
      "La disponibilit√† extra deve aggiungere ore rispetto alla disponibilit√† base.",
    ),
    "exceptionDateFrom": MessageLookupByLibrary.simpleMessage("Data inizio"),
    "exceptionDateTo": MessageLookupByLibrary.simpleMessage("Data fine"),
    "exceptionDeleteMessage": MessageLookupByLibrary.simpleMessage(
      "L\'eccezione verr√† eliminata definitivamente.",
    ),
    "exceptionDeleteShift": MessageLookupByLibrary.simpleMessage(
      "Elimina eccezione",
    ),
    "exceptionDeleteShiftDesc": MessageLookupByLibrary.simpleMessage(
      "Ripristina la disponibilit√† base",
    ),
    "exceptionDeleteTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare l\'eccezione?",
    ),
    "exceptionDialogTitleEdit": MessageLookupByLibrary.simpleMessage(
      "Modifica eccezione",
    ),
    "exceptionDialogTitleNew": MessageLookupByLibrary.simpleMessage(
      "Nuova eccezione",
    ),
    "exceptionDuration": MessageLookupByLibrary.simpleMessage(
      "Durata (giorni)",
    ),
    "exceptionDurationDays": m9,
    "exceptionEditShift": MessageLookupByLibrary.simpleMessage(
      "Modifica eccezione",
    ),
    "exceptionEditShiftDesc": MessageLookupByLibrary.simpleMessage(
      "Modifica gli orari di questa eccezione",
    ),
    "exceptionEndTime": MessageLookupByLibrary.simpleMessage("Orario fine"),
    "exceptionPartialSaveInfo": m10,
    "exceptionPartialSaveInfoDetailed": m11,
    "exceptionPartialSaveMessage": MessageLookupByLibrary.simpleMessage(
      "I giorni sotto non erano congruenti e non sono stati salvati:",
    ),
    "exceptionPartialSaveTitle": MessageLookupByLibrary.simpleMessage(
      "Eccezioni non salvate",
    ),
    "exceptionPeriodDuration": MessageLookupByLibrary.simpleMessage("Durata"),
    "exceptionPeriodMode": MessageLookupByLibrary.simpleMessage("Periodo"),
    "exceptionPeriodRange": MessageLookupByLibrary.simpleMessage("Da - A"),
    "exceptionPeriodSingle": MessageLookupByLibrary.simpleMessage(
      "Giorno singolo",
    ),
    "exceptionReason": MessageLookupByLibrary.simpleMessage(
      "Motivo (opzionale)",
    ),
    "exceptionReasonExtraShift": MessageLookupByLibrary.simpleMessage(
      "Turno extra",
    ),
    "exceptionReasonHint": MessageLookupByLibrary.simpleMessage(
      "Es. Ferie, Visita medica, Turno extra...",
    ),
    "exceptionReasonMedicalVisit": MessageLookupByLibrary.simpleMessage(
      "Visita medica",
    ),
    "exceptionReasonVacation": MessageLookupByLibrary.simpleMessage("Ferie"),
    "exceptionSelectTime": MessageLookupByLibrary.simpleMessage(
      "Seleziona orario",
    ),
    "exceptionStartTime": MessageLookupByLibrary.simpleMessage("Orario inizio"),
    "exceptionTimeError": MessageLookupByLibrary.simpleMessage(
      "L\'ora di fine deve essere successiva all\'ora di inizio",
    ),
    "exceptionType": MessageLookupByLibrary.simpleMessage("Tipo eccezione"),
    "exceptionTypeAvailable": MessageLookupByLibrary.simpleMessage(
      "Disponibile",
    ),
    "exceptionTypeUnavailable": MessageLookupByLibrary.simpleMessage(
      "Non disponibile",
    ),
    "exceptionUnavailableNoBase": MessageLookupByLibrary.simpleMessage(
      "Non puoi aggiungere una non disponibilit√† in un giorno senza disponibilit√† base.",
    ),
    "exceptionUnavailableNoOverlap": MessageLookupByLibrary.simpleMessage(
      "La non disponibilit√† deve sovrapporsi alla disponibilit√† base.",
    ),
    "exceptionsAdd": MessageLookupByLibrary.simpleMessage("Aggiungi eccezione"),
    "exceptionsEmpty": MessageLookupByLibrary.simpleMessage(
      "Nessuna eccezione configurata",
    ),
    "exceptionsTitle": MessageLookupByLibrary.simpleMessage("Eccezioni"),
    "fieldBlockedTimeLabel": MessageLookupByLibrary.simpleMessage(
      "Tempo bloccato",
    ),
    "fieldCategoryRequiredLabel": MessageLookupByLibrary.simpleMessage(
      "Categoria *",
    ),
    "fieldDescriptionLabel": MessageLookupByLibrary.simpleMessage(
      "Descrizione",
    ),
    "fieldDurationRequiredError": MessageLookupByLibrary.simpleMessage(
      "Seleziona una durata",
    ),
    "fieldDurationRequiredLabel": MessageLookupByLibrary.simpleMessage(
      "Durata *",
    ),
    "fieldNameRequiredError": MessageLookupByLibrary.simpleMessage(
      "Il nome √® obbligatorio",
    ),
    "fieldNameRequiredLabel": MessageLookupByLibrary.simpleMessage("Nome *"),
    "fieldPriceLabel": MessageLookupByLibrary.simpleMessage("Prezzo"),
    "fieldProcessingTimeLabel": MessageLookupByLibrary.simpleMessage(
      "Tempo di lavorazione",
    ),
    "filterAll": MessageLookupByLibrary.simpleMessage("Tutti"),
    "filterInactive": MessageLookupByLibrary.simpleMessage("Inattivi"),
    "filterNew": MessageLookupByLibrary.simpleMessage("Nuovi"),
    "filterVIP": MessageLookupByLibrary.simpleMessage("VIP"),
    "formClient": MessageLookupByLibrary.simpleMessage("Cliente"),
    "formDate": MessageLookupByLibrary.simpleMessage("Data"),
    "formEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "formFirstName": MessageLookupByLibrary.simpleMessage("Nome"),
    "formLastName": MessageLookupByLibrary.simpleMessage("Cognome"),
    "formNotes": MessageLookupByLibrary.simpleMessage(
      "Note (non visibili al cliente)",
    ),
    "formPhone": MessageLookupByLibrary.simpleMessage("Telefono"),
    "formService": MessageLookupByLibrary.simpleMessage("Servizio"),
    "formServices": MessageLookupByLibrary.simpleMessage("Servizi"),
    "formStaff": MessageLookupByLibrary.simpleMessage("Team"),
    "freeLabel": MessageLookupByLibrary.simpleMessage("Gratis"),
    "freeServiceSwitch": MessageLookupByLibrary.simpleMessage(
      "Servizio gratuito",
    ),
    "hoursHoursOnly": m12,
    "hoursMinutesCompact": m13,
    "labelSelect": MessageLookupByLibrary.simpleMessage("Seleziona"),
    "labelStaff": MessageLookupByLibrary.simpleMessage("Team:"),
    "lastVisitLabel": m14,
    "moveAppointmentConfirmMessage": m15,
    "moveAppointmentConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Confermi lo spostamento?",
    ),
    "navAgenda": MessageLookupByLibrary.simpleMessage("Agenda"),
    "navClients": MessageLookupByLibrary.simpleMessage("Clienti"),
    "navServices": MessageLookupByLibrary.simpleMessage("Servizi"),
    "navStaff": MessageLookupByLibrary.simpleMessage("Team"),
    "newCategoryTitle": MessageLookupByLibrary.simpleMessage("Nuova categoria"),
    "newServiceTitle": MessageLookupByLibrary.simpleMessage("Nuovo servizio"),
    "noClientForAppointment": MessageLookupByLibrary.simpleMessage(
      "Nessun cliente per l\'appuntamento",
    ),
    "noServicesAdded": MessageLookupByLibrary.simpleMessage(
      "Nessun servizio aggiunto",
    ),
    "noServicesInCategory": MessageLookupByLibrary.simpleMessage(
      "Nessun servizio in questa categoria",
    ),
    "noStaffAvailable": MessageLookupByLibrary.simpleMessage(
      "Nessun team disponibile",
    ),
    "notBookableOnline": MessageLookupByLibrary.simpleMessage(
      "Non prenotabile online",
    ),
    "notesPlaceholder": MessageLookupByLibrary.simpleMessage(
      "Note sull\'appuntamento...",
    ),
    "priceNotAvailable": MessageLookupByLibrary.simpleMessage("N/D"),
    "priceStartingFromPrefix": MessageLookupByLibrary.simpleMessage(
      "a partire da",
    ),
    "priceStartingFromSwitch": MessageLookupByLibrary.simpleMessage(
      "Prezzo \"a partire da\"",
    ),
    "removeClient": MessageLookupByLibrary.simpleMessage("Rimuovi cliente"),
    "reorderCategoriesLabel": MessageLookupByLibrary.simpleMessage("Categorie"),
    "reorderHelpDescription": MessageLookupByLibrary.simpleMessage(
      "Riordina categorie e servizi trascinandoli: l‚Äôordine sar√† lo stesso anche nella prenotazione online. Seleziona se ordinare categorie o servizi.",
    ),
    "reorderServicesLabel": MessageLookupByLibrary.simpleMessage("Servizi"),
    "reorderTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica ordinamento",
    ),
    "searchClientPlaceholder": MessageLookupByLibrary.simpleMessage(
      "Cerca cliente...",
    ),
    "selectClientTitle": MessageLookupByLibrary.simpleMessage(
      "Seleziona cliente",
    ),
    "selectService": MessageLookupByLibrary.simpleMessage(
      "Seleziona un servizio",
    ),
    "selectStaffTitle": MessageLookupByLibrary.simpleMessage("Seleziona team"),
    "serviceColorLabel": MessageLookupByLibrary.simpleMessage(
      "Colore servizio",
    ),
    "serviceDuplicateCopyWord": MessageLookupByLibrary.simpleMessage("Copia"),
    "serviceDuplicateError": MessageLookupByLibrary.simpleMessage(
      "Esiste gi√† un servizio con questo nome",
    ),
    "serviceEligibleStaffCount": m16,
    "serviceEligibleStaffNone": MessageLookupByLibrary.simpleMessage(
      "Nessun membro abilitato",
    ),
    "serviceSeedCategoryBodyDescription": MessageLookupByLibrary.simpleMessage(
      "Servizi dedicati al benessere del corpo",
    ),
    "serviceSeedCategoryBodyName": MessageLookupByLibrary.simpleMessage(
      "Trattamenti Corpo",
    ),
    "serviceSeedCategoryFaceDescription": MessageLookupByLibrary.simpleMessage(
      "Cura estetica e rigenerante per il viso",
    ),
    "serviceSeedCategoryFaceName": MessageLookupByLibrary.simpleMessage(
      "Trattamenti Viso",
    ),
    "serviceSeedCategorySportsDescription":
        MessageLookupByLibrary.simpleMessage(
          "Percorsi pensati per atleti e persone attive",
        ),
    "serviceSeedCategorySportsName": MessageLookupByLibrary.simpleMessage(
      "Trattamenti Sportivi",
    ),
    "serviceSeedServiceFaceDescription": MessageLookupByLibrary.simpleMessage(
      "Pulizia e trattamento illuminante",
    ),
    "serviceSeedServiceFaceName": MessageLookupByLibrary.simpleMessage(
      "Trattamento Viso",
    ),
    "serviceSeedServiceRelaxDescription": MessageLookupByLibrary.simpleMessage(
      "Trattamento rilassante da 30 minuti",
    ),
    "serviceSeedServiceRelaxName": MessageLookupByLibrary.simpleMessage(
      "Massaggio Relax",
    ),
    "serviceSeedServiceSportDescription": MessageLookupByLibrary.simpleMessage(
      "Trattamento decontratturante intensivo",
    ),
    "serviceSeedServiceSportName": MessageLookupByLibrary.simpleMessage(
      "Massaggio Sportivo",
    ),
    "servicesNewServiceMenu": MessageLookupByLibrary.simpleMessage(
      "Nuovo servizio",
    ),
    "servicesSelectedCount": m17,
    "setPriceToEnable": MessageLookupByLibrary.simpleMessage(
      "Imposta un prezzo per abilitarlo",
    ),
    "shiftDeleteAll": MessageLookupByLibrary.simpleMessage(
      "Elimina tutti questi turni",
    ),
    "shiftDeleteAllDesc": m18,
    "shiftDeleteThisOnly": MessageLookupByLibrary.simpleMessage(
      "Elimina solo questo turno",
    ),
    "shiftDeleteThisOnlyDesc": m19,
    "shiftEditAll": MessageLookupByLibrary.simpleMessage(
      "Modifica tutti questi turni",
    ),
    "shiftEditAllDesc": m20,
    "shiftEditThisOnly": MessageLookupByLibrary.simpleMessage(
      "Modifica solo questo turno",
    ),
    "shiftEditThisOnlyDesc": m21,
    "shiftEditTitle": MessageLookupByLibrary.simpleMessage("Modifica turno"),
    "shiftEndTime": MessageLookupByLibrary.simpleMessage("Ora fine"),
    "shiftStartTime": MessageLookupByLibrary.simpleMessage("Ora inizio"),
    "sortByCreatedAtAsc": MessageLookupByLibrary.simpleMessage(
      "Data creazione (vecchi)",
    ),
    "sortByCreatedAtDesc": MessageLookupByLibrary.simpleMessage(
      "Data creazione (nuovi)",
    ),
    "sortByLastNameAsc": MessageLookupByLibrary.simpleMessage("Cognome (A-Z)"),
    "sortByLastNameDesc": MessageLookupByLibrary.simpleMessage("Cognome (Z-A)"),
    "sortByLastVisitAsc": MessageLookupByLibrary.simpleMessage(
      "Ultima visita (meno recenti)",
    ),
    "sortByLastVisitDesc": MessageLookupByLibrary.simpleMessage(
      "Ultima visita (recenti)",
    ),
    "sortByNameAsc": MessageLookupByLibrary.simpleMessage("Nome (A-Z)"),
    "sortByNameDesc": MessageLookupByLibrary.simpleMessage("Nome (Z-A)"),
    "sortByTitle": MessageLookupByLibrary.simpleMessage("Ordina per"),
    "staffEditHours": MessageLookupByLibrary.simpleMessage("Modifica orari"),
    "staffFilterAllTeam": MessageLookupByLibrary.simpleMessage("Tutto il team"),
    "staffFilterOnDuty": MessageLookupByLibrary.simpleMessage("Team di turno"),
    "staffFilterSelectMembers": MessageLookupByLibrary.simpleMessage(
      "Seleziona membri del team",
    ),
    "staffFilterTitle": MessageLookupByLibrary.simpleMessage("Filtra team"),
    "staffFilterTooltip": MessageLookupByLibrary.simpleMessage("Filtra team"),
    "staffHubAvailabilitySubtitle": MessageLookupByLibrary.simpleMessage(
      "Configura gli orari di lavoro settimanali",
    ),
    "staffHubAvailabilityTitle": MessageLookupByLibrary.simpleMessage(
      "Disponibilit√†",
    ),
    "staffHubNotYetAvailable": MessageLookupByLibrary.simpleMessage(
      "Non ancora disponibile",
    ),
    "staffHubStatsSubtitle": MessageLookupByLibrary.simpleMessage(
      "Performance e carichi di lavoro",
    ),
    "staffHubStatsTitle": MessageLookupByLibrary.simpleMessage("Statistiche"),
    "staffHubTeamSubtitle": MessageLookupByLibrary.simpleMessage(
      "Gestione membri e ruoli",
    ),
    "staffHubTeamTitle": MessageLookupByLibrary.simpleMessage("Team"),
    "staffNotBookableOnlineMessage": MessageLookupByLibrary.simpleMessage(
      "Questo membro del team non √® abilitato alle prenotazioni online. Puoi modificare l‚Äôimpostazione dal form di modifica dello staff.",
    ),
    "staffNotBookableOnlineTitle": MessageLookupByLibrary.simpleMessage(
      "Non prenotabile online",
    ),
    "staffNotBookableOnlineTooltip": MessageLookupByLibrary.simpleMessage(
      "Non prenotabile online",
    ),
    "staffScreenPlaceholder": MessageLookupByLibrary.simpleMessage(
      "Schermata Team",
    ),
    "teamAddStaff": MessageLookupByLibrary.simpleMessage("Aggiungi membro"),
    "teamChooseLocationSingleButton": MessageLookupByLibrary.simpleMessage(
      "Seleziona la sede",
    ),
    "teamChooseLocationsButton": MessageLookupByLibrary.simpleMessage(
      "Seleziona sedi",
    ),
    "teamDeleteLocationBlockedMessage": MessageLookupByLibrary.simpleMessage(
      "Rimuovi prima tutti i membri del team associati.",
    ),
    "teamDeleteLocationBlockedTitle": MessageLookupByLibrary.simpleMessage(
      "Impossibile eliminare la sede",
    ),
    "teamDeleteLocationMessage": MessageLookupByLibrary.simpleMessage(
      "La sede verr√† rimossa dal team. L\'operazione non pu√≤ essere annullata.",
    ),
    "teamDeleteLocationTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare la sede?",
    ),
    "teamDeleteStaffMessage": MessageLookupByLibrary.simpleMessage(
      "Il membro verr√† rimosso dal team. L\'operazione non pu√≤ essere annullata.",
    ),
    "teamDeleteStaffTitle": MessageLookupByLibrary.simpleMessage(
      "Eliminare il membro del team?",
    ),
    "teamEditLocationTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica sede",
    ),
    "teamEditStaffTitle": MessageLookupByLibrary.simpleMessage(
      "Modifica membro del team",
    ),
    "teamEligibleServicesCount": m22,
    "teamEligibleServicesLabel": MessageLookupByLibrary.simpleMessage(
      "Servizi abilitati",
    ),
    "teamEligibleServicesNone": MessageLookupByLibrary.simpleMessage(
      "Nessun servizio abilitato",
    ),
    "teamEligibleStaffLabel": MessageLookupByLibrary.simpleMessage(
      "Team abilitato",
    ),
    "teamLocationAddressLabel": MessageLookupByLibrary.simpleMessage(
      "Indirizzo",
    ),
    "teamLocationLabel": MessageLookupByLibrary.simpleMessage("Sede"),
    "teamLocationNameLabel": MessageLookupByLibrary.simpleMessage("Nome sede"),
    "teamLocationsLabel": MessageLookupByLibrary.simpleMessage("Sedi"),
    "teamNewLocationTitle": MessageLookupByLibrary.simpleMessage("Nuova sede"),
    "teamNewStaffTitle": MessageLookupByLibrary.simpleMessage(
      "Nuovo membro del team",
    ),
    "teamNoStaffInLocation": MessageLookupByLibrary.simpleMessage(
      "Nessun membro in questa sede",
    ),
    "teamReorderHelpDescription": MessageLookupByLibrary.simpleMessage(
      "Riordina sedi e membri del team trascinandoli. Seleziona se ordinare sedi o team. L‚Äôordine sar√† lo stesso anche nella sezione agenda.",
    ),
    "teamSelectAllLocations": MessageLookupByLibrary.simpleMessage(
      "Seleziona tutto",
    ),
    "teamSelectAllServices": MessageLookupByLibrary.simpleMessage(
      "Seleziona tutto",
    ),
    "teamSelectedServicesButton": MessageLookupByLibrary.simpleMessage(
      "Servizi selezionati",
    ),
    "teamSelectedServicesCount": m23,
    "teamServicesLabel": MessageLookupByLibrary.simpleMessage("Servizi"),
    "teamStaffBookableOnlineLabel": MessageLookupByLibrary.simpleMessage(
      "Abilitato alle prenotazioni online",
    ),
    "teamStaffColorLabel": MessageLookupByLibrary.simpleMessage("Colore"),
    "teamStaffLabel": MessageLookupByLibrary.simpleMessage("Team"),
    "teamStaffLocationsLabel": MessageLookupByLibrary.simpleMessage(
      "Sedi associate",
    ),
    "teamStaffMultiLocationWarning": MessageLookupByLibrary.simpleMessage(
      "Se il membro lavora su pi√π sedi, ricorda di allineare disponibilit√† e orari con le sedi selezionate.",
    ),
    "teamStaffNameLabel": MessageLookupByLibrary.simpleMessage("Nome"),
    "teamStaffSurnameLabel": MessageLookupByLibrary.simpleMessage("Cognome"),
    "validationInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Email non valida",
    ),
    "validationInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Telefono non valido",
    ),
    "validationNameOrLastNameRequired": MessageLookupByLibrary.simpleMessage(
      "Inserire almeno nome o cognome",
    ),
    "validationRequired": MessageLookupByLibrary.simpleMessage("Richiesto"),
    "weeklyScheduleAddShift": MessageLookupByLibrary.simpleMessage(
      "Aggiungi turno",
    ),
    "weeklyScheduleFor": MessageLookupByLibrary.simpleMessage("-"),
    "weeklyScheduleNotWorking": MessageLookupByLibrary.simpleMessage(
      "Non lavora",
    ),
    "weeklyScheduleRemoveShift": MessageLookupByLibrary.simpleMessage(
      "Rimuovi turno",
    ),
    "weeklyScheduleTitle": MessageLookupByLibrary.simpleMessage(
      "Orario settimanale",
    ),
    "weeklyScheduleTotalHours": m24,
  };
}
--- FILE: lib/core/l10n/intl/messages_en.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that provides messages for a en locale. All the
// messages from the main program should be duplicated here with the same
// function name.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:unnecessary_brace_in_string_interps, unnecessary_new
// ignore_for_file:prefer_single_quotes,comment_references, directives_ordering
// ignore_for_file:annotate_overrides,prefer_generic_function_type_aliases
// ignore_for_file:unused_import, file_names, avoid_escaping_inner_quotes
// ignore_for_file:unnecessary_string_interpolations, unnecessary_string_escapes

import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = new MessageLookup();

typedef String MessageIfAbsent(String messageStr, List<dynamic> args);

class MessageLookup extends MessageLookupByLibrary {
  String get localeName => 'en';

  static String m0(count) =>
      "The client will also be associated with the other ${count} appointments in this booking.";

  static String m1(name) => "Availability ‚Äì ${name}";

  static String m2(clientName) => "${clientName}\'s appointments";

  static String m3(hours) => "${hours} hour";

  static String m4(hours, minutes) => "${hours} hour ${minutes} min";

  static String m5(minutes) => "${minutes} min";

  static String m6(id) => "Exception not found: ${id}";

  static String m7(factor) => "No builder available for ${factor}";

  static String m8(path) => "Page not found: ${path}";

  static String m9(count) =>
      "${count} ${Intl.plural(count, one: 'day', other: 'days')}";

  static String m10(dates) => "Some days were not saved: ${dates}.";

  static String m11(details) => "Some days were not saved: ${details}.";

  static String m12(hours) => "${hours}h";

  static String m13(hours, minutes) => "${hours}h ${minutes}m";

  static String m14(date) => "Last visit: ${date}";

  static String m15(newTime, staffName) =>
      "The appointment will be moved to ${newTime} for ${staffName}.";

  static String m16(count) => "${count} eligible team members";

  static String m17(count) =>
      "${Intl.plural(count, one: '1 service selected', other: '${count} services selected')}";

  static String m18(dayName) =>
      "Delete the weekly time slot for every ${dayName}";

  static String m19(date) => "Delete only the time slot of ${date}";

  static String m20(dayName) =>
      "Edit the weekly time slot for every ${dayName}";

  static String m21(date) => "Edit only the time slot of ${date}";

  static String m22(count) => "${count} eligible services";

  static String m23(selected, total) => "${selected} of ${total}";

  static String m24(hours) => "${hours} hours total";

  final messages = _notInlinedMessages(_notInlinedMessages);
  static Map<String, Function> _notInlinedMessages(_) => <String, Function>{
    "actionCancel": MessageLookupByLibrary.simpleMessage("Cancel"),
    "actionClose": MessageLookupByLibrary.simpleMessage("Close"),
    "actionConfirm": MessageLookupByLibrary.simpleMessage("Confirm"),
    "actionDelete": MessageLookupByLibrary.simpleMessage("Delete"),
    "actionDeleteBooking": MessageLookupByLibrary.simpleMessage(
      "Delete booking",
    ),
    "actionDiscard": MessageLookupByLibrary.simpleMessage("Cancel"),
    "actionEdit": MessageLookupByLibrary.simpleMessage("Edit"),
    "actionKeepEditing": MessageLookupByLibrary.simpleMessage("Keep editing"),
    "actionSave": MessageLookupByLibrary.simpleMessage("Save"),
    "addClientToAppointment": MessageLookupByLibrary.simpleMessage(
      "Add a client to the appointment",
    ),
    "addService": MessageLookupByLibrary.simpleMessage("Add service"),
    "addServiceTooltip": MessageLookupByLibrary.simpleMessage("Add service"),
    "additionalTimeOptionBlocked": MessageLookupByLibrary.simpleMessage(
      "Blocked time",
    ),
    "additionalTimeOptionProcessing": MessageLookupByLibrary.simpleMessage(
      "Processing time",
    ),
    "additionalTimeSwitch": MessageLookupByLibrary.simpleMessage(
      "Additional time",
    ),
    "agendaAdd": MessageLookupByLibrary.simpleMessage("Add"),
    "agendaAddAppointment": MessageLookupByLibrary.simpleMessage(
      "New appointment",
    ),
    "agendaAddBlock": MessageLookupByLibrary.simpleMessage("New block"),
    "agendaAddTitle": MessageLookupByLibrary.simpleMessage("Add a..."),
    "agendaNextDay": MessageLookupByLibrary.simpleMessage("Next day"),
    "agendaNextMonth": MessageLookupByLibrary.simpleMessage("Next month"),
    "agendaNextWeek": MessageLookupByLibrary.simpleMessage("Next Week"),
    "agendaNoLocations": MessageLookupByLibrary.simpleMessage(
      "No locations available",
    ),
    "agendaNoOnDutyTeamTitle": MessageLookupByLibrary.simpleMessage(
      "No team members on duty today",
    ),
    "agendaNoSelectedTeamTitle": MessageLookupByLibrary.simpleMessage(
      "No selected team members",
    ),
    "agendaPrevDay": MessageLookupByLibrary.simpleMessage("Previous day"),
    "agendaPrevMonth": MessageLookupByLibrary.simpleMessage("Previous month"),
    "agendaPrevWeek": MessageLookupByLibrary.simpleMessage("Previous Week"),
    "agendaSelectLocation": MessageLookupByLibrary.simpleMessage(
      "Select location",
    ),
    "agendaShowAllTeamButton": MessageLookupByLibrary.simpleMessage(
      "View all team",
    ),
    "agendaToday": MessageLookupByLibrary.simpleMessage("Today"),
    "allLocations": MessageLookupByLibrary.simpleMessage("All locations"),
    "appTitle": MessageLookupByLibrary.simpleMessage("Agenda Platform"),
    "applyClientToAllAppointmentsMessage": m0,
    "applyClientToAllAppointmentsTitle": MessageLookupByLibrary.simpleMessage(
      "Apply client to entire booking?",
    ),
    "appointmentDialogTitleEdit": MessageLookupByLibrary.simpleMessage(
      "Edit appointment",
    ),
    "appointmentDialogTitleNew": MessageLookupByLibrary.simpleMessage(
      "New appointment",
    ),
    "appointmentNoteLabel": MessageLookupByLibrary.simpleMessage(
      "Appointment note",
    ),
    "appointmentNotesTitle": MessageLookupByLibrary.simpleMessage("Notes"),
    "atLeastOneServiceRequired": MessageLookupByLibrary.simpleMessage(
      "Add at least one service",
    ),
    "availabilitySave": MessageLookupByLibrary.simpleMessage("Save changes"),
    "availabilityTitle": MessageLookupByLibrary.simpleMessage(
      "Weekly availability",
    ),
    "availabilityTitleFor": m1,
    "blockAllDay": MessageLookupByLibrary.simpleMessage("All day"),
    "blockDialogTitleEdit": MessageLookupByLibrary.simpleMessage("Edit block"),
    "blockDialogTitleNew": MessageLookupByLibrary.simpleMessage("New block"),
    "blockEndTime": MessageLookupByLibrary.simpleMessage("End time"),
    "blockReason": MessageLookupByLibrary.simpleMessage("Reason (optional)"),
    "blockReasonHint": MessageLookupByLibrary.simpleMessage(
      "E.g. Meeting, Break, etc.",
    ),
    "blockSelectStaff": MessageLookupByLibrary.simpleMessage("Select team"),
    "blockSelectStaffError": MessageLookupByLibrary.simpleMessage(
      "Select at least one team member",
    ),
    "blockStartTime": MessageLookupByLibrary.simpleMessage("Start time"),
    "blockTimeError": MessageLookupByLibrary.simpleMessage(
      "End time must be after start time",
    ),
    "bookableOnlineSwitch": MessageLookupByLibrary.simpleMessage(
      "Bookable online",
    ),
    "bookingDetails": MessageLookupByLibrary.simpleMessage("Booking details"),
    "bookingItems": MessageLookupByLibrary.simpleMessage("Services"),
    "bookingNotes": MessageLookupByLibrary.simpleMessage("Booking notes"),
    "bookingStaffNotEligibleWarning": MessageLookupByLibrary.simpleMessage(
      "Warning: the selected team member is not eligible for this service.",
    ),
    "bookingTotal": MessageLookupByLibrary.simpleMessage("Total"),
    "bookingUnavailableTimeWarningAppointment":
        MessageLookupByLibrary.simpleMessage(
          "Warning: the appointment time includes unavailable slots for the chosen team.",
        ),
    "bookingUnavailableTimeWarningService": MessageLookupByLibrary.simpleMessage(
      "Warning: this service time includes unavailable slots for the chosen team.",
    ),
    "cannotDeleteCategoryContent": MessageLookupByLibrary.simpleMessage(
      "This category contains one or more services.",
    ),
    "cannotDeleteTitle": MessageLookupByLibrary.simpleMessage("Cannot delete"),
    "cannotUndoWarning": MessageLookupByLibrary.simpleMessage(
      "This action cannot be undone.",
    ),
    "categoryDuplicateError": MessageLookupByLibrary.simpleMessage(
      "A category with this name already exists",
    ),
    "clientAppointmentsEmpty": MessageLookupByLibrary.simpleMessage(
      "No appointments",
    ),
    "clientAppointmentsPast": MessageLookupByLibrary.simpleMessage("Past"),
    "clientAppointmentsTitle": m2,
    "clientAppointmentsUpcoming": MessageLookupByLibrary.simpleMessage(
      "Upcoming",
    ),
    "clientLockedHint": MessageLookupByLibrary.simpleMessage(
      "Client cannot be changed for this appointment",
    ),
    "clientNoteLabel": MessageLookupByLibrary.simpleMessage("Client note"),
    "clientOptionalHint": MessageLookupByLibrary.simpleMessage(
      "Leave empty if you don\'t want to associate a client with the appointment",
    ),
    "clientsEdit": MessageLookupByLibrary.simpleMessage("Edit client"),
    "clientsEmpty": MessageLookupByLibrary.simpleMessage("No clients"),
    "clientsNew": MessageLookupByLibrary.simpleMessage("New client"),
    "clientsTitle": MessageLookupByLibrary.simpleMessage("Clients List"),
    "createCategoryButtonLabel": MessageLookupByLibrary.simpleMessage(
      "New category",
    ),
    "createNewClient": MessageLookupByLibrary.simpleMessage(
      "Create new client",
    ),
    "currentWeek": MessageLookupByLibrary.simpleMessage("Current week"),
    "dayFridayFull": MessageLookupByLibrary.simpleMessage("Friday"),
    "dayMondayFull": MessageLookupByLibrary.simpleMessage("Monday"),
    "daySaturdayFull": MessageLookupByLibrary.simpleMessage("Saturday"),
    "daySundayFull": MessageLookupByLibrary.simpleMessage("Sunday"),
    "dayThursdayFull": MessageLookupByLibrary.simpleMessage("Thursday"),
    "dayTuesdayFull": MessageLookupByLibrary.simpleMessage("Tuesday"),
    "dayWednesdayFull": MessageLookupByLibrary.simpleMessage("Wednesday"),
    "deleteAppointmentConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "The appointment will be removed. This action cannot be undone.",
    ),
    "deleteAppointmentConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Delete appointment?",
    ),
    "deleteBookingConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "All linked services will be removed. This action cannot be undone.",
    ),
    "deleteBookingConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Delete entire booking?",
    ),
    "deleteClientConfirmMessage": MessageLookupByLibrary.simpleMessage(
      "The client will be permanently deleted. This action cannot be undone.",
    ),
    "deleteClientConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Delete client?",
    ),
    "deleteConfirmationTitle": MessageLookupByLibrary.simpleMessage(
      "Confirm deletion?",
    ),
    "deleteServiceQuestion": MessageLookupByLibrary.simpleMessage(
      "Delete this service?",
    ),
    "discardChangesMessage": MessageLookupByLibrary.simpleMessage(
      "You have unsaved changes. Do you want to discard them?",
    ),
    "discardChangesTitle": MessageLookupByLibrary.simpleMessage(
      "Unsaved changes",
    ),
    "duplicateAction": MessageLookupByLibrary.simpleMessage("Duplicate"),
    "durationHour": m3,
    "durationHourMinute": m4,
    "durationMinute": m5,
    "editCategoryTitle": MessageLookupByLibrary.simpleMessage("Edit category"),
    "editServiceTitle": MessageLookupByLibrary.simpleMessage("Edit service"),
    "emptyCategoriesNotReorderableNote": MessageLookupByLibrary.simpleMessage(
      "Categories without services cannot be reordered and stay at the end.",
    ),
    "errorExceptionNotFound": m6,
    "errorFormFactorBuilderMissing": m7,
    "errorFormFactorBuilderRequired": MessageLookupByLibrary.simpleMessage(
      "Specify at least one builder for form factor",
    ),
    "errorNotFound": m8,
    "errorServiceNotFound": MessageLookupByLibrary.simpleMessage(
      "Service not found",
    ),
    "errorTitle": MessageLookupByLibrary.simpleMessage("Error"),
    "exceptionAllDay": MessageLookupByLibrary.simpleMessage("All day"),
    "exceptionAvailableNoEffect": MessageLookupByLibrary.simpleMessage(
      "Extra availability must add hours beyond the base availability.",
    ),
    "exceptionDateFrom": MessageLookupByLibrary.simpleMessage("Start date"),
    "exceptionDateTo": MessageLookupByLibrary.simpleMessage("End date"),
    "exceptionDeleteMessage": MessageLookupByLibrary.simpleMessage(
      "The exception will be permanently deleted.",
    ),
    "exceptionDeleteShift": MessageLookupByLibrary.simpleMessage(
      "Delete exception",
    ),
    "exceptionDeleteShiftDesc": MessageLookupByLibrary.simpleMessage(
      "Restore base availability",
    ),
    "exceptionDeleteTitle": MessageLookupByLibrary.simpleMessage(
      "Delete exception?",
    ),
    "exceptionDialogTitleEdit": MessageLookupByLibrary.simpleMessage(
      "Edit exception",
    ),
    "exceptionDialogTitleNew": MessageLookupByLibrary.simpleMessage(
      "New exception",
    ),
    "exceptionDuration": MessageLookupByLibrary.simpleMessage(
      "Duration (days)",
    ),
    "exceptionDurationDays": m9,
    "exceptionEditShift": MessageLookupByLibrary.simpleMessage(
      "Edit exception",
    ),
    "exceptionEditShiftDesc": MessageLookupByLibrary.simpleMessage(
      "Edit the times of this exception",
    ),
    "exceptionEndTime": MessageLookupByLibrary.simpleMessage("End time"),
    "exceptionPartialSaveInfo": m10,
    "exceptionPartialSaveInfoDetailed": m11,
    "exceptionPartialSaveMessage": MessageLookupByLibrary.simpleMessage(
      "The days below were not congruent and were not saved:",
    ),
    "exceptionPartialSaveTitle": MessageLookupByLibrary.simpleMessage(
      "Exceptions not saved",
    ),
    "exceptionPeriodDuration": MessageLookupByLibrary.simpleMessage("Duration"),
    "exceptionPeriodMode": MessageLookupByLibrary.simpleMessage("Period"),
    "exceptionPeriodRange": MessageLookupByLibrary.simpleMessage("From - To"),
    "exceptionPeriodSingle": MessageLookupByLibrary.simpleMessage("Single day"),
    "exceptionReason": MessageLookupByLibrary.simpleMessage(
      "Reason (optional)",
    ),
    "exceptionReasonExtraShift": MessageLookupByLibrary.simpleMessage(
      "Extra shift",
    ),
    "exceptionReasonHint": MessageLookupByLibrary.simpleMessage(
      "E.g. Holiday, Medical visit, Extra shift...",
    ),
    "exceptionReasonMedicalVisit": MessageLookupByLibrary.simpleMessage(
      "Medical visit",
    ),
    "exceptionReasonVacation": MessageLookupByLibrary.simpleMessage("Vacation"),
    "exceptionSelectTime": MessageLookupByLibrary.simpleMessage("Select time"),
    "exceptionStartTime": MessageLookupByLibrary.simpleMessage("Start time"),
    "exceptionTimeError": MessageLookupByLibrary.simpleMessage(
      "End time must be after start time",
    ),
    "exceptionType": MessageLookupByLibrary.simpleMessage("Exception type"),
    "exceptionTypeAvailable": MessageLookupByLibrary.simpleMessage("Available"),
    "exceptionTypeUnavailable": MessageLookupByLibrary.simpleMessage(
      "Unavailable",
    ),
    "exceptionUnavailableNoBase": MessageLookupByLibrary.simpleMessage(
      "You can\'t add unavailability on a day with no base availability.",
    ),
    "exceptionUnavailableNoOverlap": MessageLookupByLibrary.simpleMessage(
      "Unavailability must overlap the base availability.",
    ),
    "exceptionsAdd": MessageLookupByLibrary.simpleMessage("Add exception"),
    "exceptionsEmpty": MessageLookupByLibrary.simpleMessage(
      "No exceptions configured",
    ),
    "exceptionsTitle": MessageLookupByLibrary.simpleMessage("Exceptions"),
    "fieldBlockedTimeLabel": MessageLookupByLibrary.simpleMessage(
      "Blocked time",
    ),
    "fieldCategoryRequiredLabel": MessageLookupByLibrary.simpleMessage(
      "Category *",
    ),
    "fieldDescriptionLabel": MessageLookupByLibrary.simpleMessage(
      "Description",
    ),
    "fieldDurationRequiredError": MessageLookupByLibrary.simpleMessage(
      "Please select a duration",
    ),
    "fieldDurationRequiredLabel": MessageLookupByLibrary.simpleMessage(
      "Duration *",
    ),
    "fieldNameRequiredError": MessageLookupByLibrary.simpleMessage(
      "Name is required",
    ),
    "fieldNameRequiredLabel": MessageLookupByLibrary.simpleMessage("Name *"),
    "fieldPriceLabel": MessageLookupByLibrary.simpleMessage("Price"),
    "fieldProcessingTimeLabel": MessageLookupByLibrary.simpleMessage(
      "Processing time",
    ),
    "filterAll": MessageLookupByLibrary.simpleMessage("All"),
    "filterInactive": MessageLookupByLibrary.simpleMessage("Inactive"),
    "filterNew": MessageLookupByLibrary.simpleMessage("New"),
    "filterVIP": MessageLookupByLibrary.simpleMessage("VIP"),
    "formClient": MessageLookupByLibrary.simpleMessage("Client"),
    "formDate": MessageLookupByLibrary.simpleMessage("Date"),
    "formEmail": MessageLookupByLibrary.simpleMessage("Email"),
    "formFirstName": MessageLookupByLibrary.simpleMessage("First name"),
    "formLastName": MessageLookupByLibrary.simpleMessage("Last name"),
    "formNotes": MessageLookupByLibrary.simpleMessage(
      "Notes (not visible to client)",
    ),
    "formPhone": MessageLookupByLibrary.simpleMessage("Phone"),
    "formService": MessageLookupByLibrary.simpleMessage("Service"),
    "formServices": MessageLookupByLibrary.simpleMessage("Services"),
    "formStaff": MessageLookupByLibrary.simpleMessage("Team"),
    "freeLabel": MessageLookupByLibrary.simpleMessage("Free"),
    "freeServiceSwitch": MessageLookupByLibrary.simpleMessage("Free service"),
    "hoursHoursOnly": m12,
    "hoursMinutesCompact": m13,
    "labelSelect": MessageLookupByLibrary.simpleMessage("Select"),
    "labelStaff": MessageLookupByLibrary.simpleMessage("Team:"),
    "lastVisitLabel": m14,
    "moveAppointmentConfirmMessage": m15,
    "moveAppointmentConfirmTitle": MessageLookupByLibrary.simpleMessage(
      "Confirm move?",
    ),
    "navAgenda": MessageLookupByLibrary.simpleMessage("Agenda"),
    "navClients": MessageLookupByLibrary.simpleMessage("Clients"),
    "navServices": MessageLookupByLibrary.simpleMessage("Services"),
    "navStaff": MessageLookupByLibrary.simpleMessage("Team"),
    "newCategoryTitle": MessageLookupByLibrary.simpleMessage("New category"),
    "newServiceTitle": MessageLookupByLibrary.simpleMessage("New service"),
    "noClientForAppointment": MessageLookupByLibrary.simpleMessage(
      "No client for the appointment",
    ),
    "noServicesAdded": MessageLookupByLibrary.simpleMessage(
      "No services added",
    ),
    "noServicesInCategory": MessageLookupByLibrary.simpleMessage(
      "No services in this category",
    ),
    "noStaffAvailable": MessageLookupByLibrary.simpleMessage(
      "No team available",
    ),
    "notBookableOnline": MessageLookupByLibrary.simpleMessage(
      "Not bookable online",
    ),
    "notesPlaceholder": MessageLookupByLibrary.simpleMessage(
      "Notes about the appointment...",
    ),
    "priceNotAvailable": MessageLookupByLibrary.simpleMessage("N/A"),
    "priceStartingFromPrefix": MessageLookupByLibrary.simpleMessage(
      "starting from",
    ),
    "priceStartingFromSwitch": MessageLookupByLibrary.simpleMessage(
      "Price ‚Äústarting from‚Äù",
    ),
    "removeClient": MessageLookupByLibrary.simpleMessage("Remove client"),
    "reorderCategoriesLabel": MessageLookupByLibrary.simpleMessage(
      "Categories",
    ),
    "reorderHelpDescription": MessageLookupByLibrary.simpleMessage(
      "Reorder categories and services by dragging them: the same order will be applied to online booking. Select whether to sort categories or services.",
    ),
    "reorderServicesLabel": MessageLookupByLibrary.simpleMessage("Services"),
    "reorderTitle": MessageLookupByLibrary.simpleMessage("Reorder"),
    "searchClientPlaceholder": MessageLookupByLibrary.simpleMessage(
      "Search client...",
    ),
    "selectClientTitle": MessageLookupByLibrary.simpleMessage("Select client"),
    "selectService": MessageLookupByLibrary.simpleMessage("Select service"),
    "selectStaffTitle": MessageLookupByLibrary.simpleMessage("Select team"),
    "serviceColorLabel": MessageLookupByLibrary.simpleMessage("Service color"),
    "serviceDuplicateCopyWord": MessageLookupByLibrary.simpleMessage("Copy"),
    "serviceDuplicateError": MessageLookupByLibrary.simpleMessage(
      "A service with this name already exists",
    ),
    "serviceEligibleStaffCount": m16,
    "serviceEligibleStaffNone": MessageLookupByLibrary.simpleMessage(
      "No eligible team members",
    ),
    "serviceSeedCategoryBodyDescription": MessageLookupByLibrary.simpleMessage(
      "Services dedicated to body wellness",
    ),
    "serviceSeedCategoryBodyName": MessageLookupByLibrary.simpleMessage(
      "Body Treatments",
    ),
    "serviceSeedCategoryFaceDescription": MessageLookupByLibrary.simpleMessage(
      "Aesthetic and rejuvenating care for the face",
    ),
    "serviceSeedCategoryFaceName": MessageLookupByLibrary.simpleMessage(
      "Facial Treatments",
    ),
    "serviceSeedCategorySportsDescription":
        MessageLookupByLibrary.simpleMessage(
          "Programs designed for athletes and active people",
        ),
    "serviceSeedCategorySportsName": MessageLookupByLibrary.simpleMessage(
      "Sports Treatments",
    ),
    "serviceSeedServiceFaceDescription": MessageLookupByLibrary.simpleMessage(
      "Cleansing and illuminating treatment",
    ),
    "serviceSeedServiceFaceName": MessageLookupByLibrary.simpleMessage(
      "Facial Treatment",
    ),
    "serviceSeedServiceRelaxDescription": MessageLookupByLibrary.simpleMessage(
      "Relaxing 30-minute treatment",
    ),
    "serviceSeedServiceRelaxName": MessageLookupByLibrary.simpleMessage(
      "Relax Massage",
    ),
    "serviceSeedServiceSportDescription": MessageLookupByLibrary.simpleMessage(
      "Intensive decontracting treatment",
    ),
    "serviceSeedServiceSportName": MessageLookupByLibrary.simpleMessage(
      "Sports Massage",
    ),
    "servicesNewServiceMenu": MessageLookupByLibrary.simpleMessage(
      "New service",
    ),
    "servicesSelectedCount": m17,
    "setPriceToEnable": MessageLookupByLibrary.simpleMessage(
      "Set a price to enable this option",
    ),
    "shiftDeleteAll": MessageLookupByLibrary.simpleMessage(
      "Delete all these shifts",
    ),
    "shiftDeleteAllDesc": m18,
    "shiftDeleteThisOnly": MessageLookupByLibrary.simpleMessage(
      "Delete only this shift",
    ),
    "shiftDeleteThisOnlyDesc": m19,
    "shiftEditAll": MessageLookupByLibrary.simpleMessage(
      "Edit all these shifts",
    ),
    "shiftEditAllDesc": m20,
    "shiftEditThisOnly": MessageLookupByLibrary.simpleMessage(
      "Edit only this shift",
    ),
    "shiftEditThisOnlyDesc": m21,
    "shiftEditTitle": MessageLookupByLibrary.simpleMessage("Edit shift"),
    "shiftEndTime": MessageLookupByLibrary.simpleMessage("End time"),
    "shiftStartTime": MessageLookupByLibrary.simpleMessage("Start time"),
    "sortByCreatedAtAsc": MessageLookupByLibrary.simpleMessage(
      "Created (oldest)",
    ),
    "sortByCreatedAtDesc": MessageLookupByLibrary.simpleMessage(
      "Created (newest)",
    ),
    "sortByLastNameAsc": MessageLookupByLibrary.simpleMessage(
      "Last name (A-Z)",
    ),
    "sortByLastNameDesc": MessageLookupByLibrary.simpleMessage(
      "Last name (Z-A)",
    ),
    "sortByLastVisitAsc": MessageLookupByLibrary.simpleMessage(
      "Last visit (oldest)",
    ),
    "sortByLastVisitDesc": MessageLookupByLibrary.simpleMessage(
      "Last visit (recent)",
    ),
    "sortByNameAsc": MessageLookupByLibrary.simpleMessage("Name (A-Z)"),
    "sortByNameDesc": MessageLookupByLibrary.simpleMessage("Name (Z-A)"),
    "sortByTitle": MessageLookupByLibrary.simpleMessage("Sort by"),
    "staffEditHours": MessageLookupByLibrary.simpleMessage("Edit hours"),
    "staffFilterAllTeam": MessageLookupByLibrary.simpleMessage("All team"),
    "staffFilterOnDuty": MessageLookupByLibrary.simpleMessage("On duty team"),
    "staffFilterSelectMembers": MessageLookupByLibrary.simpleMessage(
      "Select team members",
    ),
    "staffFilterTitle": MessageLookupByLibrary.simpleMessage("Filter team"),
    "staffFilterTooltip": MessageLookupByLibrary.simpleMessage("Filter team"),
    "staffHubAvailabilitySubtitle": MessageLookupByLibrary.simpleMessage(
      "Configure weekly working hours",
    ),
    "staffHubAvailabilityTitle": MessageLookupByLibrary.simpleMessage(
      "Availability",
    ),
    "staffHubNotYetAvailable": MessageLookupByLibrary.simpleMessage(
      "Not yet available",
    ),
    "staffHubStatsSubtitle": MessageLookupByLibrary.simpleMessage(
      "Performance and workloads",
    ),
    "staffHubStatsTitle": MessageLookupByLibrary.simpleMessage("Statistics"),
    "staffHubTeamSubtitle": MessageLookupByLibrary.simpleMessage(
      "Manage members and roles",
    ),
    "staffHubTeamTitle": MessageLookupByLibrary.simpleMessage("Team"),
    "staffNotBookableOnlineMessage": MessageLookupByLibrary.simpleMessage(
      "This team member is not enabled for online bookings. You can change this in the staff edit form.",
    ),
    "staffNotBookableOnlineTitle": MessageLookupByLibrary.simpleMessage(
      "Not bookable online",
    ),
    "staffNotBookableOnlineTooltip": MessageLookupByLibrary.simpleMessage(
      "Not bookable online",
    ),
    "staffScreenPlaceholder": MessageLookupByLibrary.simpleMessage(
      "Team Screen",
    ),
    "teamAddStaff": MessageLookupByLibrary.simpleMessage("Add team member"),
    "teamChooseLocationSingleButton": MessageLookupByLibrary.simpleMessage(
      "Select location",
    ),
    "teamChooseLocationsButton": MessageLookupByLibrary.simpleMessage(
      "Select locations",
    ),
    "teamDeleteLocationBlockedMessage": MessageLookupByLibrary.simpleMessage(
      "Remove all team members assigned to this location first.",
    ),
    "teamDeleteLocationBlockedTitle": MessageLookupByLibrary.simpleMessage(
      "Cannot delete location",
    ),
    "teamDeleteLocationMessage": MessageLookupByLibrary.simpleMessage(
      "The location will be removed from the team. This action cannot be undone.",
    ),
    "teamDeleteLocationTitle": MessageLookupByLibrary.simpleMessage(
      "Delete location?",
    ),
    "teamDeleteStaffMessage": MessageLookupByLibrary.simpleMessage(
      "The member will be removed from the team. This action cannot be undone.",
    ),
    "teamDeleteStaffTitle": MessageLookupByLibrary.simpleMessage(
      "Delete team member?",
    ),
    "teamEditLocationTitle": MessageLookupByLibrary.simpleMessage(
      "Edit location",
    ),
    "teamEditStaffTitle": MessageLookupByLibrary.simpleMessage(
      "Edit team member",
    ),
    "teamEligibleServicesCount": m22,
    "teamEligibleServicesLabel": MessageLookupByLibrary.simpleMessage(
      "Eligible services",
    ),
    "teamEligibleServicesNone": MessageLookupByLibrary.simpleMessage(
      "No eligible services",
    ),
    "teamEligibleStaffLabel": MessageLookupByLibrary.simpleMessage(
      "Eligible team members",
    ),
    "teamLocationAddressLabel": MessageLookupByLibrary.simpleMessage("Address"),
    "teamLocationLabel": MessageLookupByLibrary.simpleMessage("Location"),
    "teamLocationNameLabel": MessageLookupByLibrary.simpleMessage(
      "Location name",
    ),
    "teamLocationsLabel": MessageLookupByLibrary.simpleMessage("Locations"),
    "teamNewLocationTitle": MessageLookupByLibrary.simpleMessage(
      "New location",
    ),
    "teamNewStaffTitle": MessageLookupByLibrary.simpleMessage(
      "New team member",
    ),
    "teamNoStaffInLocation": MessageLookupByLibrary.simpleMessage(
      "No team members in this location",
    ),
    "teamReorderHelpDescription": MessageLookupByLibrary.simpleMessage(
      "Reorder locations and team members by dragging them. Select whether to sort locations or team. The order will also apply in the agenda section.",
    ),
    "teamSelectAllLocations": MessageLookupByLibrary.simpleMessage(
      "Select all",
    ),
    "teamSelectAllServices": MessageLookupByLibrary.simpleMessage("Select all"),
    "teamSelectedServicesButton": MessageLookupByLibrary.simpleMessage(
      "Selected services",
    ),
    "teamSelectedServicesCount": m23,
    "teamServicesLabel": MessageLookupByLibrary.simpleMessage("Services"),
    "teamStaffBookableOnlineLabel": MessageLookupByLibrary.simpleMessage(
      "Enabled for online bookings",
    ),
    "teamStaffColorLabel": MessageLookupByLibrary.simpleMessage("Color"),
    "teamStaffLabel": MessageLookupByLibrary.simpleMessage("Team"),
    "teamStaffLocationsLabel": MessageLookupByLibrary.simpleMessage(
      "Assigned locations",
    ),
    "teamStaffMultiLocationWarning": MessageLookupByLibrary.simpleMessage(
      "If the member works across multiple locations, make sure availability aligns with the selected locations.",
    ),
    "teamStaffNameLabel": MessageLookupByLibrary.simpleMessage("First name"),
    "teamStaffSurnameLabel": MessageLookupByLibrary.simpleMessage("Last name"),
    "validationInvalidEmail": MessageLookupByLibrary.simpleMessage(
      "Invalid email",
    ),
    "validationInvalidPhone": MessageLookupByLibrary.simpleMessage(
      "Invalid phone",
    ),
    "validationNameOrLastNameRequired": MessageLookupByLibrary.simpleMessage(
      "Enter at least first name or last name",
    ),
    "validationRequired": MessageLookupByLibrary.simpleMessage("Required"),
    "weeklyScheduleAddShift": MessageLookupByLibrary.simpleMessage("Add shift"),
    "weeklyScheduleFor": MessageLookupByLibrary.simpleMessage("to"),
    "weeklyScheduleNotWorking": MessageLookupByLibrary.simpleMessage(
      "Not working",
    ),
    "weeklyScheduleRemoveShift": MessageLookupByLibrary.simpleMessage(
      "Remove shift",
    ),
    "weeklyScheduleTitle": MessageLookupByLibrary.simpleMessage("Weekly"),
    "weeklyScheduleTotalHours": m24,
  };
}
--- FILE: lib/core/l10n/date_time_formats.dart ---
import 'package:flutter/widgets.dart';
import 'package:intl/intl.dart';

/// Helper centralizzati per formattare date e orari in base alla locale corrente.
class DtFmt {
  DtFmt._();

  /// HH:mm secondo la locale; su it rimane 24h, su en pu√≤ essere 12/24 in base alle impostazioni.
  static String hm(BuildContext context, int hour, int minute) {
    final locale = Intl.getCurrentLocale();
    final dt = DateTime(0, 1, 1, hour, minute);
    // Prefer format 'HH:mm' but respect locale by using DateFormat.Hm
    return DateFormat.Hm(locale).format(dt);
  }

  /// Etichetta ora piena (senza minuti): es. "09:00" o "9 AM" a seconda locale.
  static String hOnly(BuildContext context, int hour) {
    final locale = Intl.getCurrentLocale();
    final dt = DateTime(0, 1, 1, hour, 0);
    return DateFormat.Hm(locale).format(dt);
  }

  /// Giorno breve localizzato per intestazioni (Lun, Mar, ... / Mon, Tue, ...)
  static String weekdayShort(BuildContext context, int weekdayIso) {
    final locale = Intl.getCurrentLocale();
    final now = DateTime.now();
    final base = now.subtract(Duration(days: now.weekday - weekdayIso));
    return DateFormat.E(locale).format(base);
  }

  /// Data compatta per form: "sab 6 dic 25" / "Sat 6 Dec 25"
  static String shortDate(BuildContext context, DateTime date) {
    final locale = Intl.getCurrentLocale();
    // E = giorno settimana abbreviato, d = giorno, MMM = mese abbreviato, yy = anno a 2 cifre
    return DateFormat('E d MMM yy', locale).format(date);
  }
}
--- FILE: lib/core/l10n/l10n.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'intl/messages_all.dart';

// **************************************************************************
// Generator: Flutter Intl IDE plugin
// Made by Localizely
// **************************************************************************

// ignore_for_file: non_constant_identifier_names, lines_longer_than_80_chars
// ignore_for_file: join_return_with_assignment, prefer_final_in_for_each
// ignore_for_file: avoid_redundant_argument_values, avoid_escaping_inner_quotes

class L10n {
  L10n();

  static L10n? _current;

  static L10n get current {
    assert(
      _current != null,
      'No instance of L10n was loaded. Try to initialize the L10n delegate before accessing L10n.current.',
    );
    return _current!;
  }

  static const AppLocalizationDelegate delegate = AppLocalizationDelegate();

  static Future<L10n> load(Locale locale) {
    final name = (locale.countryCode?.isEmpty ?? false)
        ? locale.languageCode
        : locale.toString();
    final localeName = Intl.canonicalizedLocale(name);
    return initializeMessages(localeName).then((_) {
      Intl.defaultLocale = localeName;
      final instance = L10n();
      L10n._current = instance;

      return instance;
    });
  }

  static L10n of(BuildContext context) {
    final instance = L10n.maybeOf(context);
    assert(
      instance != null,
      'No instance of L10n present in the widget tree. Did you add L10n.delegate in localizationsDelegates?',
    );
    return instance!;
  }

  static L10n? maybeOf(BuildContext context) {
    return Localizations.of<L10n>(context, L10n);
  }

  /// `Agenda Platform`
  String get appTitle {
    return Intl.message(
      'Agenda Platform',
      name: 'appTitle',
      desc: '',
      args: [],
    );
  }

  /// `Agenda`
  String get navAgenda {
    return Intl.message('Agenda', name: 'navAgenda', desc: '', args: []);
  }

  /// `Clienti`
  String get navClients {
    return Intl.message('Clienti', name: 'navClients', desc: '', args: []);
  }

  /// `Servizi`
  String get navServices {
    return Intl.message('Servizi', name: 'navServices', desc: '', args: []);
  }

  /// `Team`
  String get navStaff {
    return Intl.message('Team', name: 'navStaff', desc: '', args: []);
  }

  /// `Elenco Clienti`
  String get clientsTitle {
    return Intl.message(
      'Elenco Clienti',
      name: 'clientsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Specificare almeno un builder per form factor`
  String get errorFormFactorBuilderRequired {
    return Intl.message(
      'Specificare almeno un builder per form factor',
      name: 'errorFormFactorBuilderRequired',
      desc: '',
      args: [],
    );
  }

  /// `Nessun builder disponibile per {factor}`
  String errorFormFactorBuilderMissing(String factor) {
    return Intl.message(
      'Nessun builder disponibile per $factor',
      name: 'errorFormFactorBuilderMissing',
      desc: '',
      args: [factor],
    );
  }

  /// `Errore`
  String get errorTitle {
    return Intl.message('Errore', name: 'errorTitle', desc: '', args: []);
  }

  /// `Pagina non trovata: {path}`
  String errorNotFound(String path) {
    return Intl.message(
      'Pagina non trovata: $path',
      name: 'errorNotFound',
      desc: '',
      args: [path],
    );
  }

  /// `Servizio non trovato`
  String get errorServiceNotFound {
    return Intl.message(
      'Servizio non trovato',
      name: 'errorServiceNotFound',
      desc: '',
      args: [],
    );
  }

  /// `Eccezione non trovata: {id}`
  String errorExceptionNotFound(int id) {
    return Intl.message(
      'Eccezione non trovata: $id',
      name: 'errorExceptionNotFound',
      desc: '',
      args: [id],
    );
  }

  /// `Schermata Team`
  String get staffScreenPlaceholder {
    return Intl.message(
      'Schermata Team',
      name: 'staffScreenPlaceholder',
      desc: '',
      args: [],
    );
  }

  /// `Elimina`
  String get actionDelete {
    return Intl.message('Elimina', name: 'actionDelete', desc: '', args: []);
  }

  /// `Annulla`
  String get actionCancel {
    return Intl.message('Annulla', name: 'actionCancel', desc: '', args: []);
  }

  /// `Conferma`
  String get actionConfirm {
    return Intl.message('Conferma', name: 'actionConfirm', desc: '', args: []);
  }

  /// `Conferma`
  String get actionClose {
    return Intl.message('Conferma', name: 'actionClose', desc: '', args: []);
  }

  /// `Confermi l‚Äôeliminazione?`
  String get deleteConfirmationTitle {
    return Intl.message(
      'Confermi l‚Äôeliminazione?',
      name: 'deleteConfirmationTitle',
      desc: '',
      args: [],
    );
  }

  /// `Oggi`
  String get agendaToday {
    return Intl.message('Oggi', name: 'agendaToday', desc: '', args: []);
  }

  /// `Giorno precedente`
  String get agendaPrevDay {
    return Intl.message(
      'Giorno precedente',
      name: 'agendaPrevDay',
      desc: '',
      args: [],
    );
  }

  /// `Giorno successivo`
  String get agendaNextDay {
    return Intl.message(
      'Giorno successivo',
      name: 'agendaNextDay',
      desc: '',
      args: [],
    );
  }

  /// `Settimana precedente`
  String get agendaPrevWeek {
    return Intl.message(
      'Settimana precedente',
      name: 'agendaPrevWeek',
      desc: '',
      args: [],
    );
  }

  /// `Settimana successivo`
  String get agendaNextWeek {
    return Intl.message(
      'Settimana successivo',
      name: 'agendaNextWeek',
      desc: '',
      args: [],
    );
  }

  /// `Mese precedente`
  String get agendaPrevMonth {
    return Intl.message(
      'Mese precedente',
      name: 'agendaPrevMonth',
      desc: '',
      args: [],
    );
  }

  /// `Mese successivo`
  String get agendaNextMonth {
    return Intl.message(
      'Mese successivo',
      name: 'agendaNextMonth',
      desc: '',
      args: [],
    );
  }

  /// `Nessuna sede disponibile`
  String get agendaNoLocations {
    return Intl.message(
      'Nessuna sede disponibile',
      name: 'agendaNoLocations',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona sede`
  String get agendaSelectLocation {
    return Intl.message(
      'Seleziona sede',
      name: 'agendaSelectLocation',
      desc: '',
      args: [],
    );
  }

  /// `Tutte le sedi`
  String get allLocations {
    return Intl.message(
      'Tutte le sedi',
      name: 'allLocations',
      desc: '',
      args: [],
    );
  }

  /// `Disponibilit√† settimanale`
  String get availabilityTitle {
    return Intl.message(
      'Disponibilit√† settimanale',
      name: 'availabilityTitle',
      desc: '',
      args: [],
    );
  }

  /// `Disponibilit√† ‚Äì {name}`
  String availabilityTitleFor(String name) {
    return Intl.message(
      'Disponibilit√† ‚Äì $name',
      name: 'availabilityTitleFor',
      desc: '',
      args: [name],
    );
  }

  /// `Salva modifiche`
  String get availabilitySave {
    return Intl.message(
      'Salva modifiche',
      name: 'availabilitySave',
      desc: '',
      args: [],
    );
  }

  /// `Settimana corrente`
  String get currentWeek {
    return Intl.message(
      'Settimana corrente',
      name: 'currentWeek',
      desc: '',
      args: [],
    );
  }

  /// `{hours}h {minutes}m`
  String hoursMinutesCompact(Object hours, Object minutes) {
    return Intl.message(
      '${hours}h ${minutes}m',
      name: 'hoursMinutesCompact',
      desc: '',
      args: [hours, minutes],
    );
  }

  /// `{hours}h`
  String hoursHoursOnly(Object hours) {
    return Intl.message(
      '${hours}h',
      name: 'hoursHoursOnly',
      desc: '',
      args: [hours],
    );
  }

  /// `Team:`
  String get labelStaff {
    return Intl.message('Team:', name: 'labelStaff', desc: '', args: []);
  }

  /// `Seleziona`
  String get labelSelect {
    return Intl.message('Seleziona', name: 'labelSelect', desc: '', args: []);
  }

  /// `Disponibilit√†`
  String get staffHubAvailabilityTitle {
    return Intl.message(
      'Disponibilit√†',
      name: 'staffHubAvailabilityTitle',
      desc: '',
      args: [],
    );
  }

  /// `Configura gli orari di lavoro settimanali`
  String get staffHubAvailabilitySubtitle {
    return Intl.message(
      'Configura gli orari di lavoro settimanali',
      name: 'staffHubAvailabilitySubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Team`
  String get staffHubTeamTitle {
    return Intl.message('Team', name: 'staffHubTeamTitle', desc: '', args: []);
  }

  /// `Gestione membri e ruoli`
  String get staffHubTeamSubtitle {
    return Intl.message(
      'Gestione membri e ruoli',
      name: 'staffHubTeamSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Statistiche`
  String get staffHubStatsTitle {
    return Intl.message(
      'Statistiche',
      name: 'staffHubStatsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Performance e carichi di lavoro`
  String get staffHubStatsSubtitle {
    return Intl.message(
      'Performance e carichi di lavoro',
      name: 'staffHubStatsSubtitle',
      desc: '',
      args: [],
    );
  }

  /// `Non ancora disponibile`
  String get staffHubNotYetAvailable {
    return Intl.message(
      'Non ancora disponibile',
      name: 'staffHubNotYetAvailable',
      desc: '',
      args: [],
    );
  }

  /// `Modifica orari`
  String get staffEditHours {
    return Intl.message(
      'Modifica orari',
      name: 'staffEditHours',
      desc: '',
      args: [],
    );
  }

  /// `Modifica`
  String get actionEdit {
    return Intl.message('Modifica', name: 'actionEdit', desc: '', args: []);
  }

  /// `{minutes} min`
  String durationMinute(Object minutes) {
    return Intl.message(
      '$minutes min',
      name: 'durationMinute',
      desc: '',
      args: [minutes],
    );
  }

  /// `{hours} ora`
  String durationHour(Object hours) {
    return Intl.message(
      '$hours ora',
      name: 'durationHour',
      desc: '',
      args: [hours],
    );
  }

  /// `{hours} ora {minutes} min`
  String durationHourMinute(Object hours, Object minutes) {
    return Intl.message(
      '$hours ora $minutes min',
      name: 'durationHourMinute',
      desc: '',
      args: [hours, minutes],
    );
  }

  /// `Gratis`
  String get freeLabel {
    return Intl.message('Gratis', name: 'freeLabel', desc: '', args: []);
  }

  /// `a partire da`
  String get priceStartingFromPrefix {
    return Intl.message(
      'a partire da',
      name: 'priceStartingFromPrefix',
      desc: '',
      args: [],
    );
  }

  /// `N/D`
  String get priceNotAvailable {
    return Intl.message('N/D', name: 'priceNotAvailable', desc: '', args: []);
  }

  /// `Nuovo cliente`
  String get clientsNew {
    return Intl.message(
      'Nuovo cliente',
      name: 'clientsNew',
      desc: '',
      args: [],
    );
  }

  /// `Modifica cliente`
  String get clientsEdit {
    return Intl.message(
      'Modifica cliente',
      name: 'clientsEdit',
      desc: '',
      args: [],
    );
  }

  /// `Nessun cliente`
  String get clientsEmpty {
    return Intl.message(
      'Nessun cliente',
      name: 'clientsEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Salva`
  String get actionSave {
    return Intl.message('Salva', name: 'actionSave', desc: '', args: []);
  }

  /// `Tutti`
  String get filterAll {
    return Intl.message('Tutti', name: 'filterAll', desc: '', args: []);
  }

  /// `VIP`
  String get filterVIP {
    return Intl.message('VIP', name: 'filterVIP', desc: '', args: []);
  }

  /// `Inattivi`
  String get filterInactive {
    return Intl.message('Inattivi', name: 'filterInactive', desc: '', args: []);
  }

  /// `Nuovi`
  String get filterNew {
    return Intl.message('Nuovi', name: 'filterNew', desc: '', args: []);
  }

  /// `Nome`
  String get formFirstName {
    return Intl.message('Nome', name: 'formFirstName', desc: '', args: []);
  }

  /// `Cognome`
  String get formLastName {
    return Intl.message('Cognome', name: 'formLastName', desc: '', args: []);
  }

  /// `Email`
  String get formEmail {
    return Intl.message('Email', name: 'formEmail', desc: '', args: []);
  }

  /// `Telefono`
  String get formPhone {
    return Intl.message('Telefono', name: 'formPhone', desc: '', args: []);
  }

  /// `Note (non visibili al cliente)`
  String get formNotes {
    return Intl.message(
      'Note (non visibili al cliente)',
      name: 'formNotes',
      desc: '',
      args: [],
    );
  }

  /// `Richiesto`
  String get validationRequired {
    return Intl.message(
      'Richiesto',
      name: 'validationRequired',
      desc: '',
      args: [],
    );
  }

  /// `Email non valida`
  String get validationInvalidEmail {
    return Intl.message(
      'Email non valida',
      name: 'validationInvalidEmail',
      desc: '',
      args: [],
    );
  }

  /// `Telefono non valido`
  String get validationInvalidPhone {
    return Intl.message(
      'Telefono non valido',
      name: 'validationInvalidPhone',
      desc: '',
      args: [],
    );
  }

  /// `Ultima visita: {date}`
  String lastVisitLabel(String date) {
    return Intl.message(
      'Ultima visita: $date',
      name: 'lastVisitLabel',
      desc: '',
      args: [date],
    );
  }

  /// `Inserire almeno nome o cognome`
  String get validationNameOrLastNameRequired {
    return Intl.message(
      'Inserire almeno nome o cognome',
      name: 'validationNameOrLastNameRequired',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi`
  String get agendaAdd {
    return Intl.message('Aggiungi', name: 'agendaAdd', desc: '', args: []);
  }

  /// `Aggiungi un...`
  String get agendaAddTitle {
    return Intl.message(
      'Aggiungi un...',
      name: 'agendaAddTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo appuntamento`
  String get agendaAddAppointment {
    return Intl.message(
      'Nuovo appuntamento',
      name: 'agendaAddAppointment',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo blocco`
  String get agendaAddBlock {
    return Intl.message(
      'Nuovo blocco',
      name: 'agendaAddBlock',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo appuntamento`
  String get appointmentDialogTitleNew {
    return Intl.message(
      'Nuovo appuntamento',
      name: 'appointmentDialogTitleNew',
      desc: '',
      args: [],
    );
  }

  /// `Modifica appuntamento`
  String get appointmentDialogTitleEdit {
    return Intl.message(
      'Modifica appuntamento',
      name: 'appointmentDialogTitleEdit',
      desc: '',
      args: [],
    );
  }

  /// `Data`
  String get formDate {
    return Intl.message('Data', name: 'formDate', desc: '', args: []);
  }

  /// `Servizio`
  String get formService {
    return Intl.message('Servizio', name: 'formService', desc: '', args: []);
  }

  /// `Cliente`
  String get formClient {
    return Intl.message('Cliente', name: 'formClient', desc: '', args: []);
  }

  /// `Team`
  String get formStaff {
    return Intl.message('Team', name: 'formStaff', desc: '', args: []);
  }

  /// `Dettagli prenotazione`
  String get bookingDetails {
    return Intl.message(
      'Dettagli prenotazione',
      name: 'bookingDetails',
      desc: '',
      args: [],
    );
  }

  /// `Note prenotazione`
  String get bookingNotes {
    return Intl.message(
      'Note prenotazione',
      name: 'bookingNotes',
      desc: '',
      args: [],
    );
  }

  /// `Note`
  String get appointmentNotesTitle {
    return Intl.message(
      'Note',
      name: 'appointmentNotesTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nota appuntamento`
  String get appointmentNoteLabel {
    return Intl.message(
      'Nota appuntamento',
      name: 'appointmentNoteLabel',
      desc: '',
      args: [],
    );
  }

  /// `Nota cliente`
  String get clientNoteLabel {
    return Intl.message(
      'Nota cliente',
      name: 'clientNoteLabel',
      desc: '',
      args: [],
    );
  }

  /// `Servizi`
  String get bookingItems {
    return Intl.message('Servizi', name: 'bookingItems', desc: '', args: []);
  }

  /// `Totale`
  String get bookingTotal {
    return Intl.message('Totale', name: 'bookingTotal', desc: '', args: []);
  }

  /// `Attenzione: l‚Äôorario selezionato per l‚Äôappuntamento include fasce non disponibili per il team scelto.`
  String get bookingUnavailableTimeWarningAppointment {
    return Intl.message(
      'Attenzione: l‚Äôorario selezionato per l‚Äôappuntamento include fasce non disponibili per il team scelto.',
      name: 'bookingUnavailableTimeWarningAppointment',
      desc: '',
      args: [],
    );
  }

  /// `Attenzione: l‚Äôorario di questo servizio include fasce non disponibili per il team scelto.`
  String get bookingUnavailableTimeWarningService {
    return Intl.message(
      'Attenzione: l‚Äôorario di questo servizio include fasce non disponibili per il team scelto.',
      name: 'bookingUnavailableTimeWarningService',
      desc: '',
      args: [],
    );
  }

  /// `Attenzione: il membro del team selezionato non √® abilitato per questo servizio.`
  String get bookingStaffNotEligibleWarning {
    return Intl.message(
      'Attenzione: il membro del team selezionato non √® abilitato per questo servizio.',
      name: 'bookingStaffNotEligibleWarning',
      desc: '',
      args: [],
    );
  }

  /// `Elimina prenotazione`
  String get actionDeleteBooking {
    return Intl.message(
      'Elimina prenotazione',
      name: 'actionDeleteBooking',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare l'appuntamento?`
  String get deleteAppointmentConfirmTitle {
    return Intl.message(
      'Eliminare l\'appuntamento?',
      name: 'deleteAppointmentConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `L'appuntamento verr√† rimosso. L'operazione non pu√≤ essere annullata.`
  String get deleteAppointmentConfirmMessage {
    return Intl.message(
      'L\'appuntamento verr√† rimosso. L\'operazione non pu√≤ essere annullata.',
      name: 'deleteAppointmentConfirmMessage',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare l‚Äôintera prenotazione?`
  String get deleteBookingConfirmTitle {
    return Intl.message(
      'Eliminare l‚Äôintera prenotazione?',
      name: 'deleteBookingConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `Verranno rimossi tutti i servizi collegati. L'operazione non pu√≤ essere annullata.`
  String get deleteBookingConfirmMessage {
    return Intl.message(
      'Verranno rimossi tutti i servizi collegati. L\'operazione non pu√≤ essere annullata.',
      name: 'deleteBookingConfirmMessage',
      desc: '',
      args: [],
    );
  }

  /// `Sedi`
  String get teamLocationsLabel {
    return Intl.message('Sedi', name: 'teamLocationsLabel', desc: '', args: []);
  }

  /// `Team`
  String get teamStaffLabel {
    return Intl.message('Team', name: 'teamStaffLabel', desc: '', args: []);
  }

  /// `Aggiungi membro`
  String get teamAddStaff {
    return Intl.message(
      'Aggiungi membro',
      name: 'teamAddStaff',
      desc: '',
      args: [],
    );
  }

  /// `Nessun membro in questa sede`
  String get teamNoStaffInLocation {
    return Intl.message(
      'Nessun membro in questa sede',
      name: 'teamNoStaffInLocation',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile eliminare la sede`
  String get teamDeleteLocationBlockedTitle {
    return Intl.message(
      'Impossibile eliminare la sede',
      name: 'teamDeleteLocationBlockedTitle',
      desc: '',
      args: [],
    );
  }

  /// `Rimuovi prima tutti i membri del team associati.`
  String get teamDeleteLocationBlockedMessage {
    return Intl.message(
      'Rimuovi prima tutti i membri del team associati.',
      name: 'teamDeleteLocationBlockedMessage',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare la sede?`
  String get teamDeleteLocationTitle {
    return Intl.message(
      'Eliminare la sede?',
      name: 'teamDeleteLocationTitle',
      desc: '',
      args: [],
    );
  }

  /// `La sede verr√† rimossa dal team. L'operazione non pu√≤ essere annullata.`
  String get teamDeleteLocationMessage {
    return Intl.message(
      'La sede verr√† rimossa dal team. L\'operazione non pu√≤ essere annullata.',
      name: 'teamDeleteLocationMessage',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare il membro del team?`
  String get teamDeleteStaffTitle {
    return Intl.message(
      'Eliminare il membro del team?',
      name: 'teamDeleteStaffTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il membro verr√† rimosso dal team. L'operazione non pu√≤ essere annullata.`
  String get teamDeleteStaffMessage {
    return Intl.message(
      'Il membro verr√† rimosso dal team. L\'operazione non pu√≤ essere annullata.',
      name: 'teamDeleteStaffMessage',
      desc: '',
      args: [],
    );
  }

  /// `Nuova sede`
  String get teamNewLocationTitle {
    return Intl.message(
      'Nuova sede',
      name: 'teamNewLocationTitle',
      desc: '',
      args: [],
    );
  }

  /// `Modifica sede`
  String get teamEditLocationTitle {
    return Intl.message(
      'Modifica sede',
      name: 'teamEditLocationTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nome sede`
  String get teamLocationNameLabel {
    return Intl.message(
      'Nome sede',
      name: 'teamLocationNameLabel',
      desc: '',
      args: [],
    );
  }

  /// `Indirizzo`
  String get teamLocationAddressLabel {
    return Intl.message(
      'Indirizzo',
      name: 'teamLocationAddressLabel',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo membro del team`
  String get teamNewStaffTitle {
    return Intl.message(
      'Nuovo membro del team',
      name: 'teamNewStaffTitle',
      desc: '',
      args: [],
    );
  }

  /// `Modifica membro del team`
  String get teamEditStaffTitle {
    return Intl.message(
      'Modifica membro del team',
      name: 'teamEditStaffTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nome`
  String get teamStaffNameLabel {
    return Intl.message('Nome', name: 'teamStaffNameLabel', desc: '', args: []);
  }

  /// `Cognome`
  String get teamStaffSurnameLabel {
    return Intl.message(
      'Cognome',
      name: 'teamStaffSurnameLabel',
      desc: '',
      args: [],
    );
  }

  /// `Colore`
  String get teamStaffColorLabel {
    return Intl.message(
      'Colore',
      name: 'teamStaffColorLabel',
      desc: '',
      args: [],
    );
  }

  /// `Sedi associate`
  String get teamStaffLocationsLabel {
    return Intl.message(
      'Sedi associate',
      name: 'teamStaffLocationsLabel',
      desc: '',
      args: [],
    );
  }

  /// `Se il membro lavora su pi√π sedi, ricorda di allineare disponibilit√† e orari con le sedi selezionate.`
  String get teamStaffMultiLocationWarning {
    return Intl.message(
      'Se il membro lavora su pi√π sedi, ricorda di allineare disponibilit√† e orari con le sedi selezionate.',
      name: 'teamStaffMultiLocationWarning',
      desc: '',
      args: [],
    );
  }

  /// `Team abilitato`
  String get teamEligibleStaffLabel {
    return Intl.message(
      'Team abilitato',
      name: 'teamEligibleStaffLabel',
      desc: '',
      args: [],
    );
  }

  /// `Servizi abilitati`
  String get teamEligibleServicesLabel {
    return Intl.message(
      'Servizi abilitati',
      name: 'teamEligibleServicesLabel',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona tutto`
  String get teamSelectAllServices {
    return Intl.message(
      'Seleziona tutto',
      name: 'teamSelectAllServices',
      desc: '',
      args: [],
    );
  }

  /// `{count} servizi abilitati`
  String teamEligibleServicesCount(int count) {
    return Intl.message(
      '$count servizi abilitati',
      name: 'teamEligibleServicesCount',
      desc: '',
      args: [count],
    );
  }

  /// `Nessun servizio abilitato`
  String get teamEligibleServicesNone {
    return Intl.message(
      'Nessun servizio abilitato',
      name: 'teamEligibleServicesNone',
      desc: '',
      args: [],
    );
  }

  /// `Servizi selezionati`
  String get teamSelectedServicesButton {
    return Intl.message(
      'Servizi selezionati',
      name: 'teamSelectedServicesButton',
      desc: '',
      args: [],
    );
  }

  /// `{selected} su {total}`
  String teamSelectedServicesCount(int selected, int total) {
    return Intl.message(
      '$selected su $total',
      name: 'teamSelectedServicesCount',
      desc: '',
      args: [selected, total],
    );
  }

  /// `Servizi`
  String get teamServicesLabel {
    return Intl.message(
      'Servizi',
      name: 'teamServicesLabel',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona sedi`
  String get teamChooseLocationsButton {
    return Intl.message(
      'Seleziona sedi',
      name: 'teamChooseLocationsButton',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona la sede`
  String get teamChooseLocationSingleButton {
    return Intl.message(
      'Seleziona la sede',
      name: 'teamChooseLocationSingleButton',
      desc: '',
      args: [],
    );
  }

  /// `Sede`
  String get teamLocationLabel {
    return Intl.message('Sede', name: 'teamLocationLabel', desc: '', args: []);
  }

  /// `Seleziona tutto`
  String get teamSelectAllLocations {
    return Intl.message(
      'Seleziona tutto',
      name: 'teamSelectAllLocations',
      desc: '',
      args: [],
    );
  }

  /// `Abilitato alle prenotazioni online`
  String get teamStaffBookableOnlineLabel {
    return Intl.message(
      'Abilitato alle prenotazioni online',
      name: 'teamStaffBookableOnlineLabel',
      desc: '',
      args: [],
    );
  }

  /// `Non prenotabile online`
  String get staffNotBookableOnlineTooltip {
    return Intl.message(
      'Non prenotabile online',
      name: 'staffNotBookableOnlineTooltip',
      desc: '',
      args: [],
    );
  }

  /// `Non prenotabile online`
  String get staffNotBookableOnlineTitle {
    return Intl.message(
      'Non prenotabile online',
      name: 'staffNotBookableOnlineTitle',
      desc: '',
      args: [],
    );
  }

  /// `Questo membro del team non √® abilitato alle prenotazioni online. Puoi modificare l‚Äôimpostazione dal form di modifica dello staff.`
  String get staffNotBookableOnlineMessage {
    return Intl.message(
      'Questo membro del team non √® abilitato alle prenotazioni online. Puoi modificare l‚Äôimpostazione dal form di modifica dello staff.',
      name: 'staffNotBookableOnlineMessage',
      desc: '',
      args: [],
    );
  }

  /// `{count} membri abilitati`
  String serviceEligibleStaffCount(int count) {
    return Intl.message(
      '$count membri abilitati',
      name: 'serviceEligibleStaffCount',
      desc: '',
      args: [count],
    );
  }

  /// `Nessun membro abilitato`
  String get serviceEligibleStaffNone {
    return Intl.message(
      'Nessun membro abilitato',
      name: 'serviceEligibleStaffNone',
      desc: '',
      args: [],
    );
  }

  /// `Riordina sedi e membri del team trascinandoli. Seleziona se ordinare sedi o team. L‚Äôordine sar√† lo stesso anche nella sezione agenda.`
  String get teamReorderHelpDescription {
    return Intl.message(
      'Riordina sedi e membri del team trascinandoli. Seleziona se ordinare sedi o team. L‚Äôordine sar√† lo stesso anche nella sezione agenda.',
      name: 'teamReorderHelpDescription',
      desc: '',
      args: [],
    );
  }

  /// `Nuova categoria`
  String get createCategoryButtonLabel {
    return Intl.message(
      'Nuova categoria',
      name: 'createCategoryButtonLabel',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo servizio`
  String get servicesNewServiceMenu {
    return Intl.message(
      'Nuovo servizio',
      name: 'servicesNewServiceMenu',
      desc: '',
      args: [],
    );
  }

  /// `Modifica ordinamento`
  String get reorderTitle {
    return Intl.message(
      'Modifica ordinamento',
      name: 'reorderTitle',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi servizio`
  String get addServiceTooltip {
    return Intl.message(
      'Aggiungi servizio',
      name: 'addServiceTooltip',
      desc: '',
      args: [],
    );
  }

  /// `Impossibile eliminare`
  String get cannotDeleteTitle {
    return Intl.message(
      'Impossibile eliminare',
      name: 'cannotDeleteTitle',
      desc: '',
      args: [],
    );
  }

  /// `La categoria contiene uno o pi√π servizi.`
  String get cannotDeleteCategoryContent {
    return Intl.message(
      'La categoria contiene uno o pi√π servizi.',
      name: 'cannotDeleteCategoryContent',
      desc: '',
      args: [],
    );
  }

  /// `Nessun servizio in questa categoria`
  String get noServicesInCategory {
    return Intl.message(
      'Nessun servizio in questa categoria',
      name: 'noServicesInCategory',
      desc: '',
      args: [],
    );
  }

  /// `Non prenotabile online`
  String get notBookableOnline {
    return Intl.message(
      'Non prenotabile online',
      name: 'notBookableOnline',
      desc: '',
      args: [],
    );
  }

  /// `Duplica`
  String get duplicateAction {
    return Intl.message('Duplica', name: 'duplicateAction', desc: '', args: []);
  }

  /// `Eliminare il servizio?`
  String get deleteServiceQuestion {
    return Intl.message(
      'Eliminare il servizio?',
      name: 'deleteServiceQuestion',
      desc: '',
      args: [],
    );
  }

  /// `Questa azione non pu√≤ essere annullata.`
  String get cannotUndoWarning {
    return Intl.message(
      'Questa azione non pu√≤ essere annullata.',
      name: 'cannotUndoWarning',
      desc: '',
      args: [],
    );
  }

  /// `Nuova categoria`
  String get newCategoryTitle {
    return Intl.message(
      'Nuova categoria',
      name: 'newCategoryTitle',
      desc: '',
      args: [],
    );
  }

  /// `Modifica categoria`
  String get editCategoryTitle {
    return Intl.message(
      'Modifica categoria',
      name: 'editCategoryTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nome *`
  String get fieldNameRequiredLabel {
    return Intl.message(
      'Nome *',
      name: 'fieldNameRequiredLabel',
      desc: '',
      args: [],
    );
  }

  /// `Il nome √® obbligatorio`
  String get fieldNameRequiredError {
    return Intl.message(
      'Il nome √® obbligatorio',
      name: 'fieldNameRequiredError',
      desc: '',
      args: [],
    );
  }

  /// `Esiste gi√† una categoria con questo nome`
  String get categoryDuplicateError {
    return Intl.message(
      'Esiste gi√† una categoria con questo nome',
      name: 'categoryDuplicateError',
      desc: '',
      args: [],
    );
  }

  /// `Descrizione`
  String get fieldDescriptionLabel {
    return Intl.message(
      'Descrizione',
      name: 'fieldDescriptionLabel',
      desc: '',
      args: [],
    );
  }

  /// `Colore servizio`
  String get serviceColorLabel {
    return Intl.message(
      'Colore servizio',
      name: 'serviceColorLabel',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo servizio`
  String get newServiceTitle {
    return Intl.message(
      'Nuovo servizio',
      name: 'newServiceTitle',
      desc: '',
      args: [],
    );
  }

  /// `Modifica servizio`
  String get editServiceTitle {
    return Intl.message(
      'Modifica servizio',
      name: 'editServiceTitle',
      desc: '',
      args: [],
    );
  }

  /// `Categoria *`
  String get fieldCategoryRequiredLabel {
    return Intl.message(
      'Categoria *',
      name: 'fieldCategoryRequiredLabel',
      desc: '',
      args: [],
    );
  }

  /// `Durata *`
  String get fieldDurationRequiredLabel {
    return Intl.message(
      'Durata *',
      name: 'fieldDurationRequiredLabel',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona una durata`
  String get fieldDurationRequiredError {
    return Intl.message(
      'Seleziona una durata',
      name: 'fieldDurationRequiredError',
      desc: '',
      args: [],
    );
  }

  /// `Prezzo`
  String get fieldPriceLabel {
    return Intl.message('Prezzo', name: 'fieldPriceLabel', desc: '', args: []);
  }

  /// `Tempo di lavorazione`
  String get fieldProcessingTimeLabel {
    return Intl.message(
      'Tempo di lavorazione',
      name: 'fieldProcessingTimeLabel',
      desc: '',
      args: [],
    );
  }

  /// `Tempo bloccato`
  String get fieldBlockedTimeLabel {
    return Intl.message(
      'Tempo bloccato',
      name: 'fieldBlockedTimeLabel',
      desc: '',
      args: [],
    );
  }

  /// `Tempo aggiuntivo`
  String get additionalTimeSwitch {
    return Intl.message(
      'Tempo aggiuntivo',
      name: 'additionalTimeSwitch',
      desc: '',
      args: [],
    );
  }

  /// `Tempo di lavorazione`
  String get additionalTimeOptionProcessing {
    return Intl.message(
      'Tempo di lavorazione',
      name: 'additionalTimeOptionProcessing',
      desc: '',
      args: [],
    );
  }

  /// `Tempo bloccato`
  String get additionalTimeOptionBlocked {
    return Intl.message(
      'Tempo bloccato',
      name: 'additionalTimeOptionBlocked',
      desc: '',
      args: [],
    );
  }

  /// `Prenotabile online`
  String get bookableOnlineSwitch {
    return Intl.message(
      'Prenotabile online',
      name: 'bookableOnlineSwitch',
      desc: '',
      args: [],
    );
  }

  /// `Servizio gratuito`
  String get freeServiceSwitch {
    return Intl.message(
      'Servizio gratuito',
      name: 'freeServiceSwitch',
      desc: '',
      args: [],
    );
  }

  /// `Prezzo "a partire da"`
  String get priceStartingFromSwitch {
    return Intl.message(
      'Prezzo "a partire da"',
      name: 'priceStartingFromSwitch',
      desc: '',
      args: [],
    );
  }

  /// `Imposta un prezzo per abilitarlo`
  String get setPriceToEnable {
    return Intl.message(
      'Imposta un prezzo per abilitarlo',
      name: 'setPriceToEnable',
      desc: '',
      args: [],
    );
  }

  /// `Esiste gi√† un servizio con questo nome`
  String get serviceDuplicateError {
    return Intl.message(
      'Esiste gi√† un servizio con questo nome',
      name: 'serviceDuplicateError',
      desc: '',
      args: [],
    );
  }

  /// `Riordina categorie e servizi trascinandoli: l‚Äôordine sar√† lo stesso anche nella prenotazione online. Seleziona se ordinare categorie o servizi.`
  String get reorderHelpDescription {
    return Intl.message(
      'Riordina categorie e servizi trascinandoli: l‚Äôordine sar√† lo stesso anche nella prenotazione online. Seleziona se ordinare categorie o servizi.',
      name: 'reorderHelpDescription',
      desc: '',
      args: [],
    );
  }

  /// `Categorie`
  String get reorderCategoriesLabel {
    return Intl.message(
      'Categorie',
      name: 'reorderCategoriesLabel',
      desc: '',
      args: [],
    );
  }

  /// `Servizi`
  String get reorderServicesLabel {
    return Intl.message(
      'Servizi',
      name: 'reorderServicesLabel',
      desc: '',
      args: [],
    );
  }

  /// `Le categorie senza servizi non sono riordinabili e restano in coda.`
  String get emptyCategoriesNotReorderableNote {
    return Intl.message(
      'Le categorie senza servizi non sono riordinabili e restano in coda.',
      name: 'emptyCategoriesNotReorderableNote',
      desc: '',
      args: [],
    );
  }

  /// `Trattamenti Corpo`
  String get serviceSeedCategoryBodyName {
    return Intl.message(
      'Trattamenti Corpo',
      name: 'serviceSeedCategoryBodyName',
      desc: '',
      args: [],
    );
  }

  /// `Servizi dedicati al benessere del corpo`
  String get serviceSeedCategoryBodyDescription {
    return Intl.message(
      'Servizi dedicati al benessere del corpo',
      name: 'serviceSeedCategoryBodyDescription',
      desc: '',
      args: [],
    );
  }

  /// `Trattamenti Sportivi`
  String get serviceSeedCategorySportsName {
    return Intl.message(
      'Trattamenti Sportivi',
      name: 'serviceSeedCategorySportsName',
      desc: '',
      args: [],
    );
  }

  /// `Percorsi pensati per atleti e persone attive`
  String get serviceSeedCategorySportsDescription {
    return Intl.message(
      'Percorsi pensati per atleti e persone attive',
      name: 'serviceSeedCategorySportsDescription',
      desc: '',
      args: [],
    );
  }

  /// `Trattamenti Viso`
  String get serviceSeedCategoryFaceName {
    return Intl.message(
      'Trattamenti Viso',
      name: 'serviceSeedCategoryFaceName',
      desc: '',
      args: [],
    );
  }

  /// `Cura estetica e rigenerante per il viso`
  String get serviceSeedCategoryFaceDescription {
    return Intl.message(
      'Cura estetica e rigenerante per il viso',
      name: 'serviceSeedCategoryFaceDescription',
      desc: '',
      args: [],
    );
  }

  /// `Massaggio Relax`
  String get serviceSeedServiceRelaxName {
    return Intl.message(
      'Massaggio Relax',
      name: 'serviceSeedServiceRelaxName',
      desc: '',
      args: [],
    );
  }

  /// `Trattamento rilassante da 30 minuti`
  String get serviceSeedServiceRelaxDescription {
    return Intl.message(
      'Trattamento rilassante da 30 minuti',
      name: 'serviceSeedServiceRelaxDescription',
      desc: '',
      args: [],
    );
  }

  /// `Massaggio Sportivo`
  String get serviceSeedServiceSportName {
    return Intl.message(
      'Massaggio Sportivo',
      name: 'serviceSeedServiceSportName',
      desc: '',
      args: [],
    );
  }

  /// `Trattamento decontratturante intensivo`
  String get serviceSeedServiceSportDescription {
    return Intl.message(
      'Trattamento decontratturante intensivo',
      name: 'serviceSeedServiceSportDescription',
      desc: '',
      args: [],
    );
  }

  /// `Trattamento Viso`
  String get serviceSeedServiceFaceName {
    return Intl.message(
      'Trattamento Viso',
      name: 'serviceSeedServiceFaceName',
      desc: '',
      args: [],
    );
  }

  /// `Pulizia e trattamento illuminante`
  String get serviceSeedServiceFaceDescription {
    return Intl.message(
      'Pulizia e trattamento illuminante',
      name: 'serviceSeedServiceFaceDescription',
      desc: '',
      args: [],
    );
  }

  /// `Copia`
  String get serviceDuplicateCopyWord {
    return Intl.message(
      'Copia',
      name: 'serviceDuplicateCopyWord',
      desc: '',
      args: [],
    );
  }

  /// `Confermi lo spostamento?`
  String get moveAppointmentConfirmTitle {
    return Intl.message(
      'Confermi lo spostamento?',
      name: 'moveAppointmentConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `L'appuntamento verr√† spostato alle {newTime} per {staffName}.`
  String moveAppointmentConfirmMessage(String newTime, String staffName) {
    return Intl.message(
      'L\'appuntamento verr√† spostato alle $newTime per $staffName.',
      name: 'moveAppointmentConfirmMessage',
      desc: '',
      args: [newTime, staffName],
    );
  }

  /// `Modifiche non salvate`
  String get discardChangesTitle {
    return Intl.message(
      'Modifiche non salvate',
      name: 'discardChangesTitle',
      desc: '',
      args: [],
    );
  }

  /// `Hai delle modifiche non salvate. Vuoi scartarle?`
  String get discardChangesMessage {
    return Intl.message(
      'Hai delle modifiche non salvate. Vuoi scartarle?',
      name: 'discardChangesMessage',
      desc: '',
      args: [],
    );
  }

  /// `Annulla`
  String get actionDiscard {
    return Intl.message('Annulla', name: 'actionDiscard', desc: '', args: []);
  }

  /// `Continua a modificare`
  String get actionKeepEditing {
    return Intl.message(
      'Continua a modificare',
      name: 'actionKeepEditing',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare il cliente?`
  String get deleteClientConfirmTitle {
    return Intl.message(
      'Eliminare il cliente?',
      name: 'deleteClientConfirmTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il cliente verr√† eliminato definitivamente. Questa azione non pu√≤ essere annullata.`
  String get deleteClientConfirmMessage {
    return Intl.message(
      'Il cliente verr√† eliminato definitivamente. Questa azione non pu√≤ essere annullata.',
      name: 'deleteClientConfirmMessage',
      desc: '',
      args: [],
    );
  }

  /// `Nome (A-Z)`
  String get sortByNameAsc {
    return Intl.message(
      'Nome (A-Z)',
      name: 'sortByNameAsc',
      desc: '',
      args: [],
    );
  }

  /// `Nome (Z-A)`
  String get sortByNameDesc {
    return Intl.message(
      'Nome (Z-A)',
      name: 'sortByNameDesc',
      desc: '',
      args: [],
    );
  }

  /// `Cognome (A-Z)`
  String get sortByLastNameAsc {
    return Intl.message(
      'Cognome (A-Z)',
      name: 'sortByLastNameAsc',
      desc: '',
      args: [],
    );
  }

  /// `Cognome (Z-A)`
  String get sortByLastNameDesc {
    return Intl.message(
      'Cognome (Z-A)',
      name: 'sortByLastNameDesc',
      desc: '',
      args: [],
    );
  }

  /// `Ultima visita (recenti)`
  String get sortByLastVisitDesc {
    return Intl.message(
      'Ultima visita (recenti)',
      name: 'sortByLastVisitDesc',
      desc: '',
      args: [],
    );
  }

  /// `Ultima visita (meno recenti)`
  String get sortByLastVisitAsc {
    return Intl.message(
      'Ultima visita (meno recenti)',
      name: 'sortByLastVisitAsc',
      desc: '',
      args: [],
    );
  }

  /// `Data creazione (nuovi)`
  String get sortByCreatedAtDesc {
    return Intl.message(
      'Data creazione (nuovi)',
      name: 'sortByCreatedAtDesc',
      desc: '',
      args: [],
    );
  }

  /// `Data creazione (vecchi)`
  String get sortByCreatedAtAsc {
    return Intl.message(
      'Data creazione (vecchi)',
      name: 'sortByCreatedAtAsc',
      desc: '',
      args: [],
    );
  }

  /// `Appuntamenti di {clientName}`
  String clientAppointmentsTitle(String clientName) {
    return Intl.message(
      'Appuntamenti di $clientName',
      name: 'clientAppointmentsTitle',
      desc: '',
      args: [clientName],
    );
  }

  /// `Prossimi`
  String get clientAppointmentsUpcoming {
    return Intl.message(
      'Prossimi',
      name: 'clientAppointmentsUpcoming',
      desc: '',
      args: [],
    );
  }

  /// `Passati`
  String get clientAppointmentsPast {
    return Intl.message(
      'Passati',
      name: 'clientAppointmentsPast',
      desc: '',
      args: [],
    );
  }

  /// `Nessun appuntamento`
  String get clientAppointmentsEmpty {
    return Intl.message(
      'Nessun appuntamento',
      name: 'clientAppointmentsEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Filtra team`
  String get staffFilterTooltip {
    return Intl.message(
      'Filtra team',
      name: 'staffFilterTooltip',
      desc: '',
      args: [],
    );
  }

  /// `Filtra team`
  String get staffFilterTitle {
    return Intl.message(
      'Filtra team',
      name: 'staffFilterTitle',
      desc: '',
      args: [],
    );
  }

  /// `Tutto il team`
  String get staffFilterAllTeam {
    return Intl.message(
      'Tutto il team',
      name: 'staffFilterAllTeam',
      desc: '',
      args: [],
    );
  }

  /// `Team di turno`
  String get staffFilterOnDuty {
    return Intl.message(
      'Team di turno',
      name: 'staffFilterOnDuty',
      desc: '',
      args: [],
    );
  }

  /// `Nessun membro del team di turno oggi`
  String get agendaNoOnDutyTeamTitle {
    return Intl.message(
      'Nessun membro del team di turno oggi',
      name: 'agendaNoOnDutyTeamTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessun membro del team selezionato`
  String get agendaNoSelectedTeamTitle {
    return Intl.message(
      'Nessun membro del team selezionato',
      name: 'agendaNoSelectedTeamTitle',
      desc: '',
      args: [],
    );
  }

  /// `Visualizza tutto il team`
  String get agendaShowAllTeamButton {
    return Intl.message(
      'Visualizza tutto il team',
      name: 'agendaShowAllTeamButton',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona membri del team`
  String get staffFilterSelectMembers {
    return Intl.message(
      'Seleziona membri del team',
      name: 'staffFilterSelectMembers',
      desc: '',
      args: [],
    );
  }

  /// `Nuovo blocco`
  String get blockDialogTitleNew {
    return Intl.message(
      'Nuovo blocco',
      name: 'blockDialogTitleNew',
      desc: '',
      args: [],
    );
  }

  /// `Modifica blocco`
  String get blockDialogTitleEdit {
    return Intl.message(
      'Modifica blocco',
      name: 'blockDialogTitleEdit',
      desc: '',
      args: [],
    );
  }

  /// `Giornata intera`
  String get blockAllDay {
    return Intl.message(
      'Giornata intera',
      name: 'blockAllDay',
      desc: '',
      args: [],
    );
  }

  /// `Orario inizio`
  String get blockStartTime {
    return Intl.message(
      'Orario inizio',
      name: 'blockStartTime',
      desc: '',
      args: [],
    );
  }

  /// `Orario fine`
  String get blockEndTime {
    return Intl.message(
      'Orario fine',
      name: 'blockEndTime',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona team`
  String get blockSelectStaff {
    return Intl.message(
      'Seleziona team',
      name: 'blockSelectStaff',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona almeno un team`
  String get blockSelectStaffError {
    return Intl.message(
      'Seleziona almeno un team',
      name: 'blockSelectStaffError',
      desc: '',
      args: [],
    );
  }

  /// `L'ora di fine deve essere successiva all'ora di inizio`
  String get blockTimeError {
    return Intl.message(
      'L\'ora di fine deve essere successiva all\'ora di inizio',
      name: 'blockTimeError',
      desc: '',
      args: [],
    );
  }

  /// `Motivo (opzionale)`
  String get blockReason {
    return Intl.message(
      'Motivo (opzionale)',
      name: 'blockReason',
      desc: '',
      args: [],
    );
  }

  /// `Es. Riunione, Pausa, ecc.`
  String get blockReasonHint {
    return Intl.message(
      'Es. Riunione, Pausa, ecc.',
      name: 'blockReasonHint',
      desc: '',
      args: [],
    );
  }

  /// `Ordina per`
  String get sortByTitle {
    return Intl.message('Ordina per', name: 'sortByTitle', desc: '', args: []);
  }

  /// `Seleziona team`
  String get selectStaffTitle {
    return Intl.message(
      'Seleziona team',
      name: 'selectStaffTitle',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi un cliente all'appuntamento`
  String get addClientToAppointment {
    return Intl.message(
      'Aggiungi un cliente all\'appuntamento',
      name: 'addClientToAppointment',
      desc: '',
      args: [],
    );
  }

  /// `Lascia il campo vuoto se non vuoi associare un cliente all'appuntamento`
  String get clientOptionalHint {
    return Intl.message(
      'Lascia il campo vuoto se non vuoi associare un cliente all\'appuntamento',
      name: 'clientOptionalHint',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona cliente`
  String get selectClientTitle {
    return Intl.message(
      'Seleziona cliente',
      name: 'selectClientTitle',
      desc: '',
      args: [],
    );
  }

  /// `Rimuovi cliente`
  String get removeClient {
    return Intl.message(
      'Rimuovi cliente',
      name: 'removeClient',
      desc: '',
      args: [],
    );
  }

  /// `Cerca cliente...`
  String get searchClientPlaceholder {
    return Intl.message(
      'Cerca cliente...',
      name: 'searchClientPlaceholder',
      desc: '',
      args: [],
    );
  }

  /// `Crea nuovo cliente`
  String get createNewClient {
    return Intl.message(
      'Crea nuovo cliente',
      name: 'createNewClient',
      desc: '',
      args: [],
    );
  }

  /// `Nessun cliente per l'appuntamento`
  String get noClientForAppointment {
    return Intl.message(
      'Nessun cliente per l\'appuntamento',
      name: 'noClientForAppointment',
      desc: '',
      args: [],
    );
  }

  /// `Servizi`
  String get formServices {
    return Intl.message('Servizi', name: 'formServices', desc: '', args: []);
  }

  /// `{count, plural, =1{1 servizio selezionato} other{{count} servizi selezionati}}`
  String servicesSelectedCount(int count) {
    return Intl.plural(
      count,
      one: '1 servizio selezionato',
      other: '$count servizi selezionati',
      name: 'servicesSelectedCount',
      desc: '',
      args: [count],
    );
  }

  /// `Aggiungi un servizio`
  String get addService {
    return Intl.message(
      'Aggiungi un servizio',
      name: 'addService',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona un servizio`
  String get selectService {
    return Intl.message(
      'Seleziona un servizio',
      name: 'selectService',
      desc: '',
      args: [],
    );
  }

  /// `Nessun servizio aggiunto`
  String get noServicesAdded {
    return Intl.message(
      'Nessun servizio aggiunto',
      name: 'noServicesAdded',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi almeno un servizio`
  String get atLeastOneServiceRequired {
    return Intl.message(
      'Aggiungi almeno un servizio',
      name: 'atLeastOneServiceRequired',
      desc: '',
      args: [],
    );
  }

  /// `Note sull'appuntamento...`
  String get notesPlaceholder {
    return Intl.message(
      'Note sull\'appuntamento...',
      name: 'notesPlaceholder',
      desc: '',
      args: [],
    );
  }

  /// `Nessun team disponibile`
  String get noStaffAvailable {
    return Intl.message(
      'Nessun team disponibile',
      name: 'noStaffAvailable',
      desc: '',
      args: [],
    );
  }

  /// `Orario settimanale`
  String get weeklyScheduleTitle {
    return Intl.message(
      'Orario settimanale',
      name: 'weeklyScheduleTitle',
      desc: '',
      args: [],
    );
  }

  /// `{hours} ore totale`
  String weeklyScheduleTotalHours(int hours) {
    return Intl.message(
      '$hours ore totale',
      name: 'weeklyScheduleTotalHours',
      desc: '',
      args: [hours],
    );
  }

  /// `Non lavora`
  String get weeklyScheduleNotWorking {
    return Intl.message(
      'Non lavora',
      name: 'weeklyScheduleNotWorking',
      desc: '',
      args: [],
    );
  }

  /// `-`
  String get weeklyScheduleFor {
    return Intl.message('-', name: 'weeklyScheduleFor', desc: '', args: []);
  }

  /// `Aggiungi turno`
  String get weeklyScheduleAddShift {
    return Intl.message(
      'Aggiungi turno',
      name: 'weeklyScheduleAddShift',
      desc: '',
      args: [],
    );
  }

  /// `Rimuovi turno`
  String get weeklyScheduleRemoveShift {
    return Intl.message(
      'Rimuovi turno',
      name: 'weeklyScheduleRemoveShift',
      desc: '',
      args: [],
    );
  }

  /// `luned√¨`
  String get dayMondayFull {
    return Intl.message('luned√¨', name: 'dayMondayFull', desc: '', args: []);
  }

  /// `marted√¨`
  String get dayTuesdayFull {
    return Intl.message('marted√¨', name: 'dayTuesdayFull', desc: '', args: []);
  }

  /// `mercoled√¨`
  String get dayWednesdayFull {
    return Intl.message(
      'mercoled√¨',
      name: 'dayWednesdayFull',
      desc: '',
      args: [],
    );
  }

  /// `gioved√¨`
  String get dayThursdayFull {
    return Intl.message('gioved√¨', name: 'dayThursdayFull', desc: '', args: []);
  }

  /// `venerd√¨`
  String get dayFridayFull {
    return Intl.message('venerd√¨', name: 'dayFridayFull', desc: '', args: []);
  }

  /// `sabato`
  String get daySaturdayFull {
    return Intl.message('sabato', name: 'daySaturdayFull', desc: '', args: []);
  }

  /// `domenica`
  String get daySundayFull {
    return Intl.message('domenica', name: 'daySundayFull', desc: '', args: []);
  }

  /// `Nuova eccezione`
  String get exceptionDialogTitleNew {
    return Intl.message(
      'Nuova eccezione',
      name: 'exceptionDialogTitleNew',
      desc: '',
      args: [],
    );
  }

  /// `Modifica eccezione`
  String get exceptionDialogTitleEdit {
    return Intl.message(
      'Modifica eccezione',
      name: 'exceptionDialogTitleEdit',
      desc: '',
      args: [],
    );
  }

  /// `Tipo eccezione`
  String get exceptionType {
    return Intl.message(
      'Tipo eccezione',
      name: 'exceptionType',
      desc: '',
      args: [],
    );
  }

  /// `Non disponibile`
  String get exceptionTypeUnavailable {
    return Intl.message(
      'Non disponibile',
      name: 'exceptionTypeUnavailable',
      desc: '',
      args: [],
    );
  }

  /// `Disponibile`
  String get exceptionTypeAvailable {
    return Intl.message(
      'Disponibile',
      name: 'exceptionTypeAvailable',
      desc: '',
      args: [],
    );
  }

  /// `Giornata intera`
  String get exceptionAllDay {
    return Intl.message(
      'Giornata intera',
      name: 'exceptionAllDay',
      desc: '',
      args: [],
    );
  }

  /// `Orario inizio`
  String get exceptionStartTime {
    return Intl.message(
      'Orario inizio',
      name: 'exceptionStartTime',
      desc: '',
      args: [],
    );
  }

  /// `Orario fine`
  String get exceptionEndTime {
    return Intl.message(
      'Orario fine',
      name: 'exceptionEndTime',
      desc: '',
      args: [],
    );
  }

  /// `Motivo (opzionale)`
  String get exceptionReason {
    return Intl.message(
      'Motivo (opzionale)',
      name: 'exceptionReason',
      desc: '',
      args: [],
    );
  }

  /// `Ferie`
  String get exceptionReasonVacation {
    return Intl.message(
      'Ferie',
      name: 'exceptionReasonVacation',
      desc: '',
      args: [],
    );
  }

  /// `Turno extra`
  String get exceptionReasonExtraShift {
    return Intl.message(
      'Turno extra',
      name: 'exceptionReasonExtraShift',
      desc: '',
      args: [],
    );
  }

  /// `Visita medica`
  String get exceptionReasonMedicalVisit {
    return Intl.message(
      'Visita medica',
      name: 'exceptionReasonMedicalVisit',
      desc: '',
      args: [],
    );
  }

  /// `Es. Ferie, Visita medica, Turno extra...`
  String get exceptionReasonHint {
    return Intl.message(
      'Es. Ferie, Visita medica, Turno extra...',
      name: 'exceptionReasonHint',
      desc: '',
      args: [],
    );
  }

  /// `L'ora di fine deve essere successiva all'ora di inizio`
  String get exceptionTimeError {
    return Intl.message(
      'L\'ora di fine deve essere successiva all\'ora di inizio',
      name: 'exceptionTimeError',
      desc: '',
      args: [],
    );
  }

  /// `Non puoi aggiungere una non disponibilit√† in un giorno senza disponibilit√† base.`
  String get exceptionUnavailableNoBase {
    return Intl.message(
      'Non puoi aggiungere una non disponibilit√† in un giorno senza disponibilit√† base.',
      name: 'exceptionUnavailableNoBase',
      desc: '',
      args: [],
    );
  }

  /// `La non disponibilit√† deve sovrapporsi alla disponibilit√† base.`
  String get exceptionUnavailableNoOverlap {
    return Intl.message(
      'La non disponibilit√† deve sovrapporsi alla disponibilit√† base.',
      name: 'exceptionUnavailableNoOverlap',
      desc: '',
      args: [],
    );
  }

  /// `La disponibilit√† extra deve aggiungere ore rispetto alla disponibilit√† base.`
  String get exceptionAvailableNoEffect {
    return Intl.message(
      'La disponibilit√† extra deve aggiungere ore rispetto alla disponibilit√† base.',
      name: 'exceptionAvailableNoEffect',
      desc: '',
      args: [],
    );
  }

  /// `Alcuni giorni non sono stati salvati: {dates}.`
  String exceptionPartialSaveInfo(Object dates) {
    return Intl.message(
      'Alcuni giorni non sono stati salvati: $dates.',
      name: 'exceptionPartialSaveInfo',
      desc: '',
      args: [dates],
    );
  }

  /// `Alcuni giorni non sono stati salvati: {details}.`
  String exceptionPartialSaveInfoDetailed(Object details) {
    return Intl.message(
      'Alcuni giorni non sono stati salvati: $details.',
      name: 'exceptionPartialSaveInfoDetailed',
      desc: '',
      args: [details],
    );
  }

  /// `Eccezioni non salvate`
  String get exceptionPartialSaveTitle {
    return Intl.message(
      'Eccezioni non salvate',
      name: 'exceptionPartialSaveTitle',
      desc: '',
      args: [],
    );
  }

  /// `I giorni sotto non erano congruenti e non sono stati salvati:`
  String get exceptionPartialSaveMessage {
    return Intl.message(
      'I giorni sotto non erano congruenti e non sono stati salvati:',
      name: 'exceptionPartialSaveMessage',
      desc: '',
      args: [],
    );
  }

  /// `Eliminare l'eccezione?`
  String get exceptionDeleteTitle {
    return Intl.message(
      'Eliminare l\'eccezione?',
      name: 'exceptionDeleteTitle',
      desc: '',
      args: [],
    );
  }

  /// `L'eccezione verr√† eliminata definitivamente.`
  String get exceptionDeleteMessage {
    return Intl.message(
      'L\'eccezione verr√† eliminata definitivamente.',
      name: 'exceptionDeleteMessage',
      desc: '',
      args: [],
    );
  }

  /// `Seleziona orario`
  String get exceptionSelectTime {
    return Intl.message(
      'Seleziona orario',
      name: 'exceptionSelectTime',
      desc: '',
      args: [],
    );
  }

  /// `Eccezioni`
  String get exceptionsTitle {
    return Intl.message(
      'Eccezioni',
      name: 'exceptionsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Nessuna eccezione configurata`
  String get exceptionsEmpty {
    return Intl.message(
      'Nessuna eccezione configurata',
      name: 'exceptionsEmpty',
      desc: '',
      args: [],
    );
  }

  /// `Aggiungi eccezione`
  String get exceptionsAdd {
    return Intl.message(
      'Aggiungi eccezione',
      name: 'exceptionsAdd',
      desc: '',
      args: [],
    );
  }

  /// `Periodo`
  String get exceptionPeriodMode {
    return Intl.message(
      'Periodo',
      name: 'exceptionPeriodMode',
      desc: '',
      args: [],
    );
  }

  /// `Giorno singolo`
  String get exceptionPeriodSingle {
    return Intl.message(
      'Giorno singolo',
      name: 'exceptionPeriodSingle',
      desc: '',
      args: [],
    );
  }

  /// `Da - A`
  String get exceptionPeriodRange {
    return Intl.message(
      'Da - A',
      name: 'exceptionPeriodRange',
      desc: '',
      args: [],
    );
  }

  /// `Durata`
  String get exceptionPeriodDuration {
    return Intl.message(
      'Durata',
      name: 'exceptionPeriodDuration',
      desc: '',
      args: [],
    );
  }

  /// `Data inizio`
  String get exceptionDateFrom {
    return Intl.message(
      'Data inizio',
      name: 'exceptionDateFrom',
      desc: '',
      args: [],
    );
  }

  /// `Data fine`
  String get exceptionDateTo {
    return Intl.message(
      'Data fine',
      name: 'exceptionDateTo',
      desc: '',
      args: [],
    );
  }

  /// `Durata (giorni)`
  String get exceptionDuration {
    return Intl.message(
      'Durata (giorni)',
      name: 'exceptionDuration',
      desc: '',
      args: [],
    );
  }

  /// `{count} {count, plural, =1{giorno} other{giorni}}`
  String exceptionDurationDays(int count) {
    return Intl.message(
      '$count ${Intl.plural(count, one: 'giorno', other: 'giorni')}',
      name: 'exceptionDurationDays',
      desc: '',
      args: [count],
    );
  }

  /// `Elimina solo questo turno`
  String get shiftDeleteThisOnly {
    return Intl.message(
      'Elimina solo questo turno',
      name: 'shiftDeleteThisOnly',
      desc: '',
      args: [],
    );
  }

  /// `Elimina solo la fascia oraria di {date}`
  String shiftDeleteThisOnlyDesc(String date) {
    return Intl.message(
      'Elimina solo la fascia oraria di $date',
      name: 'shiftDeleteThisOnlyDesc',
      desc: '',
      args: [date],
    );
  }

  /// `Elimina tutti questi turni`
  String get shiftDeleteAll {
    return Intl.message(
      'Elimina tutti questi turni',
      name: 'shiftDeleteAll',
      desc: '',
      args: [],
    );
  }

  /// `Elimina la fascia oraria settimanale di ogni {dayName}`
  String shiftDeleteAllDesc(String dayName) {
    return Intl.message(
      'Elimina la fascia oraria settimanale di ogni $dayName',
      name: 'shiftDeleteAllDesc',
      desc: '',
      args: [dayName],
    );
  }

  /// `Modifica solo questo turno`
  String get shiftEditThisOnly {
    return Intl.message(
      'Modifica solo questo turno',
      name: 'shiftEditThisOnly',
      desc: '',
      args: [],
    );
  }

  /// `Modifica solo la fascia oraria di {date}`
  String shiftEditThisOnlyDesc(String date) {
    return Intl.message(
      'Modifica solo la fascia oraria di $date',
      name: 'shiftEditThisOnlyDesc',
      desc: '',
      args: [date],
    );
  }

  /// `Modifica tutti questi turni`
  String get shiftEditAll {
    return Intl.message(
      'Modifica tutti questi turni',
      name: 'shiftEditAll',
      desc: '',
      args: [],
    );
  }

  /// `Modifica la fascia oraria settimanale di ogni {dayName}`
  String shiftEditAllDesc(String dayName) {
    return Intl.message(
      'Modifica la fascia oraria settimanale di ogni $dayName',
      name: 'shiftEditAllDesc',
      desc: '',
      args: [dayName],
    );
  }

  /// `Modifica turno`
  String get shiftEditTitle {
    return Intl.message(
      'Modifica turno',
      name: 'shiftEditTitle',
      desc: '',
      args: [],
    );
  }

  /// `Ora inizio`
  String get shiftStartTime {
    return Intl.message(
      'Ora inizio',
      name: 'shiftStartTime',
      desc: '',
      args: [],
    );
  }

  /// `Ora fine`
  String get shiftEndTime {
    return Intl.message('Ora fine', name: 'shiftEndTime', desc: '', args: []);
  }

  /// `Modifica eccezione`
  String get exceptionEditShift {
    return Intl.message(
      'Modifica eccezione',
      name: 'exceptionEditShift',
      desc: '',
      args: [],
    );
  }

  /// `Modifica gli orari di questa eccezione`
  String get exceptionEditShiftDesc {
    return Intl.message(
      'Modifica gli orari di questa eccezione',
      name: 'exceptionEditShiftDesc',
      desc: '',
      args: [],
    );
  }

  /// `Elimina eccezione`
  String get exceptionDeleteShift {
    return Intl.message(
      'Elimina eccezione',
      name: 'exceptionDeleteShift',
      desc: '',
      args: [],
    );
  }

  /// `Ripristina la disponibilit√† base`
  String get exceptionDeleteShiftDesc {
    return Intl.message(
      'Ripristina la disponibilit√† base',
      name: 'exceptionDeleteShiftDesc',
      desc: '',
      args: [],
    );
  }

  /// `Il cliente non pu√≤ essere modificato per questo appuntamento`
  String get clientLockedHint {
    return Intl.message(
      'Il cliente non pu√≤ essere modificato per questo appuntamento',
      name: 'clientLockedHint',
      desc: '',
      args: [],
    );
  }

  /// `Applicare il cliente a tutta la prenotazione?`
  String get applyClientToAllAppointmentsTitle {
    return Intl.message(
      'Applicare il cliente a tutta la prenotazione?',
      name: 'applyClientToAllAppointmentsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Il cliente verr√† associato anche agli altri {count} appuntamenti di questa prenotazione.`
  String applyClientToAllAppointmentsMessage(int count) {
    return Intl.message(
      'Il cliente verr√† associato anche agli altri $count appuntamenti di questa prenotazione.',
      name: 'applyClientToAllAppointmentsMessage',
      desc: '',
      args: [count],
    );
  }
}

class AppLocalizationDelegate extends LocalizationsDelegate<L10n> {
  const AppLocalizationDelegate();

  List<Locale> get supportedLocales {
    return const <Locale>[
      Locale.fromSubtags(languageCode: 'it'),
      Locale.fromSubtags(languageCode: 'en'),
    ];
  }

  @override
  bool isSupported(Locale locale) => _isSupported(locale);
  @override
  Future<L10n> load(Locale locale) => L10n.load(locale);
  @override
  bool shouldReload(AppLocalizationDelegate old) => false;

  bool _isSupported(Locale locale) {
    for (var supportedLocale in supportedLocales) {
      if (supportedLocale.languageCode == locale.languageCode) {
        return true;
      }
    }
    return false;
  }
}
--- FILE: lib/core/network/api_client.dart ---
--- FILE: lib/core/utils/color_utils.dart ---
import 'package:flutter/material.dart';

class ColorUtils {
  /// Restituisce il colore in formato esadecimale '#AARRGGBB'
  static String toHex(Color color) {
    final int argb = color.toARGB32();
    return '#${argb.toRadixString(16).padLeft(8, '0').toUpperCase()}';
  }

  /// Converte una stringa esadecimale '#AARRGGBB' o '#RRGGBB' in un Color
  static Color fromHex(String hexString) {
    final buffer = StringBuffer();
    if (hexString.length == 6 || hexString.length == 7) buffer.write('FF');
    buffer.write(hexString.replaceFirst('#', ''));
    return Color(int.parse(buffer.toString(), radix: 16));
  }
}
--- FILE: lib/core/utils/price_utils.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../features/agenda/providers/business_providers.dart';
import '../../features/agenda/providers/location_providers.dart';
import '../l10n/l10_extension.dart'; // ‚úÖ per usare context.l10n
import '../models/service_variant.dart';

/// Utility per formattazione e parsing dei prezzi, coerente con la valuta
/// effettiva del business o della location.
///
/// üîπ Integra:
/// - Formattazione localizzata tramite [Intl.NumberFormat]
/// - Fallback automatico sul locale corrente
/// - Metodo [parse] per convertire input utente (es. ‚Äú‚Ç¨45,90‚Äù) in `double`
/// - Metodo [formatService] per mostrare prezzo e label standard (‚Äúa partire da‚Ä¶‚Äù)
class PriceFormatter {
  const PriceFormatter._();

  /// Restituisce la valuta effettiva in base a location o business.
  static String effectiveCurrency(WidgetRef ref) {
    final locationCurrency = ref.watch(currentLocationProvider).currency;
    final businessCurrency = ref.watch(currentBusinessProvider).currency;
    return locationCurrency ?? businessCurrency;
  }

  /// Formatta un prezzo numerico [amount] nella valuta indicata.
  ///
  /// Utilizza sempre il simbolo della valuta e rispetta la locale dell'app.
  static String format({
    required BuildContext context,
    required double amount,
    required String currencyCode,
    String? forcedLocale,
  }) {
    // Locale derivata dal contesto o dal parametro forzato
    final localeFromContext = Localizations.localeOf(context).toString();
    final currentLocale = forcedLocale ?? localeFromContext;

    try {
      // Usa simpleCurrency per ottenere il simbolo (‚Ç¨, $, ¬£, ecc.)
      final formatter = NumberFormat.simpleCurrency(
        name: currencyCode,
        locale: currentLocale,
      );
      return formatter.format(amount);
    } catch (_) {
      // Se la locale non √® supportata, prova con la locale dell'app
      try {
        final fallbackFormatter = NumberFormat.simpleCurrency(
          name: currencyCode,
          locale: Intl.getCurrentLocale(),
        );
        return fallbackFormatter.format(amount);
      } catch (_) {
        // Ultimo fallback su 'it_IT' (anzich√© en_US)
        final lastResortFormatter = NumberFormat.simpleCurrency(
          name: currencyCode,
          locale: 'it_IT',
        );
        return lastResortFormatter.format(amount);
      }
    }
  }

  /// Converte una stringa di input (es. ‚Äú‚Ç¨ 45,90‚Äù, ‚Äú45.00‚Äù, ‚ÄúCHF 120‚Äù) in `double`.
  ///
  /// Rimuove simboli e caratteri non numerici, normalizzando la virgola in punto.
  static double? parse(String input) {
    if (input.trim().isEmpty) return null;

    final cleaned = input
        .replaceAll(RegExp(r'[^0-9,.\-]'), '')
        .replaceAll(',', '.');

    return double.tryParse(cleaned);
  }

  /// Formatta un [ServiceVariant] tenendo conto delle impostazioni di valuta e
  /// dei flag `isFree` e `isPriceStartingFrom`.
  static String formatVariant({
    required BuildContext context,
    required WidgetRef ref,
    required ServiceVariant variant,
  }) {
    final currency = variant.currency ?? effectiveCurrency(ref);

    if (variant.isFree) return context.l10n.freeLabel;
    if (variant.price <= 0) return context.l10n.priceNotAvailable;

    final formatted = format(
      context: context,
      amount: variant.price,
      currencyCode: currency,
    );

    return variant.isPriceStartingFrom
        ? '${context.l10n.priceStartingFromPrefix} $formatted'
        : formatted;
  }
}
--- FILE: lib/core/utils/string_utils.dart ---
/// Utility per la manipolazione delle stringhe
class StringUtils {
  const StringUtils._();

  /// Capitalizza la prima lettera di ogni parola (Title Case)
  /// Es: "mario rossi" ‚Üí "Mario Rossi"
  /// Es: "GIOVANNI BIANCHI" ‚Üí "Giovanni Bianchi"
  static String toTitleCase(String raw) {
    final trimmed = raw.trim();
    if (trimmed.isEmpty) return trimmed;

    final parts = trimmed.split(' ');
    return parts
        .map(
          (w) => w.isEmpty
              ? ''
              : '${w[0].toUpperCase()}${w.substring(1).toLowerCase()}',
        )
        .join(' ');
  }

  /// Capitalizza solo la prima lettera della stringa
  /// Es: "mario rossi" ‚Üí "Mario rossi"
  static String capitalize(String raw) {
    final trimmed = raw.trim();
    if (trimmed.isEmpty) return trimmed;
    return '${trimmed[0].toUpperCase()}${trimmed.substring(1).toLowerCase()}';
  }

  /// Capitalizza la prima lettera, mantenendo il resto invariato
  /// Es: "mario ROSSI" ‚Üí "Mario ROSSI"
  static String capitalizeFirst(String raw) {
    final trimmed = raw.trim();
    if (trimmed.isEmpty) return trimmed;
    return '${trimmed[0].toUpperCase()}${trimmed.substring(1)}';
  }
}
--- FILE: lib/core/utils/date_utils.dart ---
--- FILE: lib/core/models/hour_range.dart ---

--- FILE: lib/core/models/appointment.dart ---
enum ExtraMinutesType { processing, blocked }

ExtraMinutesType? _extraMinutesTypeFromJson(Object? value) {
  if (value is String) {
    for (final type in ExtraMinutesType.values) {
      if (type.name == value) {
        return type;
      }
    }
  }
  return null;
}

String? _extraMinutesTypeToJson(ExtraMinutesType? value) {
  return value?.name;
}

class Appointment {
  final int id;
  final int bookingId;
  final int businessId;
  final int locationId;
  final int staffId;
  final int serviceId;
  final int serviceVariantId;
  final int? clientId; // opzionale: collegamento al Client
  final String clientName;
  final String serviceName;
  final DateTime startTime;
  final DateTime endTime;
  final double? price; // prezzo applicato al singolo appuntamento
  // Legacy single extra fields (kept for backward compatibility)
  final int? extraMinutes;
  final ExtraMinutesType? extraMinutesType;
  // New split extras
  final int? extraBlockedMinutes;
  final int? extraProcessingMinutes;

  const Appointment({
    required this.id,
    required this.bookingId,
    required this.businessId,
    required this.locationId,
    required this.staffId,
    required this.serviceId,
    required this.serviceVariantId,
    this.clientId,
    required this.clientName,
    required this.serviceName,
    required this.startTime,
    required this.endTime,
    this.price,
    this.extraMinutes,
    this.extraMinutesType,
    this.extraBlockedMinutes,
    this.extraProcessingMinutes,
  });

  factory Appointment.fromJson(Map<String, dynamic> json) => Appointment(
    id: json['id'] as int,
    bookingId: json['booking_id'] as int,
    businessId: json['business_id'] as int,
    locationId: json['location_id'] as int,
    staffId: json['staff_id'] as int,
    serviceId: json['service_id'] as int,
    serviceVariantId: json['service_variant_id'] as int,
    clientId: json['client_id'] as int?,
    clientName: json['client_name'] as String? ?? '',
    serviceName: json['service_name'] as String? ?? '',
    startTime: DateTime.parse(json['start_time'] as String),
    endTime: DateTime.parse(json['end_time'] as String),
    price: json['price'] != null ? (json['price'] as num).toDouble() : null,
    extraMinutes: json['extra_minutes'] as int?,
    extraMinutesType: _extraMinutesTypeFromJson(
      json['extra_minutes_type'],
    ),
    extraBlockedMinutes: json['extra_blocked_minutes'] as int?,
    extraProcessingMinutes: json['extra_processing_minutes'] as int?,
  );

  Appointment copyWith({
    int? id,
    int? bookingId,
    int? businessId,
    int? locationId,
    int? staffId,
    int? serviceId,
    int? serviceVariantId,
    int? clientId,
    String? clientName,
    String? serviceName,
    DateTime? startTime,
    DateTime? endTime,
    double? price,
    int? extraMinutes,
    ExtraMinutesType? extraMinutesType,
    int? extraBlockedMinutes,
    int? extraProcessingMinutes,
  }) {
    return Appointment(
      id: id ?? this.id,
      bookingId: bookingId ?? this.bookingId,
      businessId: businessId ?? this.businessId,
      locationId: locationId ?? this.locationId,
      staffId: staffId ?? this.staffId,
      serviceId: serviceId ?? this.serviceId,
      serviceVariantId: serviceVariantId ?? this.serviceVariantId,
      clientId: clientId ?? this.clientId,
      clientName: clientName ?? this.clientName,
      serviceName: serviceName ?? this.serviceName,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      price: price ?? this.price,
      extraMinutes: extraMinutes ?? this.extraMinutes,
      extraMinutesType: extraMinutesType ?? this.extraMinutesType,
      extraBlockedMinutes: extraBlockedMinutes ?? this.extraBlockedMinutes,
      extraProcessingMinutes:
          extraProcessingMinutes ?? this.extraProcessingMinutes,
    );
  }

  Map<String, dynamic> toJson() {
    final blocked = blockedExtraMinutes;
    final processing = processingExtraMinutes;
    final legacyType = blocked > 0
        ? ExtraMinutesType.blocked
        : (processing > 0 ? ExtraMinutesType.processing : null);
    final legacyMinutes = legacyType == ExtraMinutesType.blocked
        ? blocked
        : (legacyType == ExtraMinutesType.processing ? processing : null);
    return {
      'id': id,
      'booking_id': bookingId,
      'business_id': businessId,
      'location_id': locationId,
      'staff_id': staffId,
      'service_id': serviceId,
      'service_variant_id': serviceVariantId,
      if (clientId != null) 'client_id': clientId,
      'client_name': clientName,
      'service_name': serviceName,
      'start_time': startTime.toIso8601String(),
      'end_time': endTime.toIso8601String(),
      if (price != null) 'price': price,
      if (legacyMinutes != null) 'extra_minutes': legacyMinutes,
      if (legacyType != null)
        'extra_minutes_type': _extraMinutesTypeToJson(legacyType),
      if (extraBlockedMinutes != null)
        'extra_blocked_minutes': extraBlockedMinutes,
      if (extraProcessingMinutes != null)
        'extra_processing_minutes': extraProcessingMinutes,
    };
  }

  int get blockedExtraMinutes {
    if (extraBlockedMinutes != null) return extraBlockedMinutes!;
    if (extraMinutesType == ExtraMinutesType.blocked) {
      return extraMinutes ?? 0;
    }
    return 0;
  }

  int get processingExtraMinutes {
    if (extraProcessingMinutes != null) return extraProcessingMinutes!;
    if (extraMinutesType == ExtraMinutesType.processing) {
      return extraMinutes ?? 0;
    }
    return 0;
  }

  int get totalDuration => endTime.difference(startTime).inMinutes;

  String get formattedPrice {
    if (price == null || price == 0) return '';
    return '${price!.toStringAsFixed(2)}‚Ç¨';
  }
}
--- FILE: lib/core/models/service_category.dart ---
class ServiceCategory {
  final int id;
  final int businessId;
  final String name;
  final String? description;
  final int sortOrder; // üîπ ordine di visualizzazione

  const ServiceCategory({
    required this.id,
    required this.businessId,
    required this.name,
    this.description,
    this.sortOrder = 0,
  });

  ServiceCategory copyWith({
    int? id,
    int? businessId,
    String? name,
    String? description,
    int? sortOrder,
  }) => ServiceCategory(
    id: id ?? this.id,
    businessId: businessId ?? this.businessId,
    name: name ?? this.name,
    description: description ?? this.description,
    sortOrder: sortOrder ?? this.sortOrder,
  );

  factory ServiceCategory.fromJson(Map<String, dynamic> json) =>
      ServiceCategory(
        id: json['id'] as int,
        businessId: json['business_id'] as int,
        name: json['name'] as String,
        description: json['description'] as String?,
        sortOrder: json['sort_order'] as int? ?? 0,
      );

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'name': name,
    if (description != null) 'description': description,
    'sort_order': sortOrder,
  };
}
--- FILE: lib/core/models/time_block.dart ---
/// Rappresenta un blocco di non disponibilit√† nell'agenda.
///
/// Un blocco pu√≤ essere assegnato a uno o pi√π membri dello staff
/// per una fascia oraria specifica.
class TimeBlock {
  final int id;
  final int businessId;
  final int locationId;

  /// Lista degli ID degli staff a cui √® assegnato il blocco.
  final List<int> staffIds;

  /// Inizio del blocco.
  final DateTime startTime;

  /// Fine del blocco.
  final DateTime endTime;

  /// Motivo opzionale del blocco (es. "Riunione", "Pausa pranzo", ecc.).
  final String? reason;

  /// Se true, il blocco copre l'intera giornata lavorativa.
  final bool isAllDay;

  const TimeBlock({
    required this.id,
    required this.businessId,
    required this.locationId,
    required this.staffIds,
    required this.startTime,
    required this.endTime,
    this.reason,
    this.isAllDay = false,
  });

  factory TimeBlock.fromJson(Map<String, dynamic> json) => TimeBlock(
    id: json['id'] as int,
    businessId: json['business_id'] as int,
    locationId: json['location_id'] as int,
    staffIds: (json['staff_ids'] as List<dynamic>)
        .map((id) => id as int)
        .toList(),
    startTime: DateTime.parse(json['start_time'] as String),
    endTime: DateTime.parse(json['end_time'] as String),
    reason: json['reason'] as String?,
    isAllDay: json['is_all_day'] as bool? ?? false,
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'location_id': locationId,
    'staff_ids': staffIds,
    'start_time': startTime.toIso8601String(),
    'end_time': endTime.toIso8601String(),
    if (reason != null) 'reason': reason,
    'is_all_day': isAllDay,
  };

  TimeBlock copyWith({
    int? id,
    int? businessId,
    int? locationId,
    List<int>? staffIds,
    DateTime? startTime,
    DateTime? endTime,
    String? reason,
    bool? isAllDay,
  }) {
    return TimeBlock(
      id: id ?? this.id,
      businessId: businessId ?? this.businessId,
      locationId: locationId ?? this.locationId,
      staffIds: staffIds ?? this.staffIds,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      reason: reason ?? this.reason,
      isAllDay: isAllDay ?? this.isAllDay,
    );
  }

  /// Durata del blocco in minuti.
  int get durationMinutes => endTime.difference(startTime).inMinutes;

  /// Verifica se il blocco include uno specifico staff.
  bool includesStaff(int staffId) => staffIds.contains(staffId);

  /// Verifica se il blocco si sovrappone a un intervallo di tempo.
  bool overlaps(DateTime start, DateTime end) {
    return startTime.isBefore(end) && endTime.isAfter(start);
  }

  /// Verifica se il blocco √® nella stessa data.
  bool isOnDate(DateTime date) {
    final blockDate = DateTime(startTime.year, startTime.month, startTime.day);
    final targetDate = DateTime(date.year, date.month, date.day);
    return blockDate == targetDate;
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TimeBlock && runtimeType == other.runtimeType && id == other.id;

  @override
  int get hashCode => id.hashCode;
}
--- FILE: lib/core/models/booking.dart ---
class Booking {
  final int id;
  final int businessId;
  final int locationId;
  final int? clientId;
  final String? customerName;
  final String? notes;

  const Booking({
    required this.id,
    required this.businessId,
    required this.locationId,
    this.clientId,
    this.customerName,
    this.notes,
  });

  Booking copyWith({
    int? id,
    int? businessId,
    int? locationId,
    int? clientId,
    String? customerName,
    String? notes,
  }) {
    return Booking(
      id: id ?? this.id,
      businessId: businessId ?? this.businessId,
      locationId: locationId ?? this.locationId,
      clientId: clientId ?? this.clientId,
      customerName: customerName ?? this.customerName,
      notes: notes ?? this.notes,
    );
  }

  factory Booking.fromJson(Map<String, dynamic> json) => Booking(
    id: json['id'] as int,
    businessId: json['business_id'] as int,
    locationId: json['location_id'] as int,
    clientId: json['client_id'] as int?,
    customerName: json['customer_name'] as String? ?? '',
    notes: json['notes'] as String?,
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'location_id': locationId,
    if (clientId != null) 'client_id': clientId,
    'customer_name': customerName,
    if (notes != null) 'notes': notes,
  };
}
--- FILE: lib/core/models/resource.dart ---
class Resource {
  final int id;
  final int locationId;
  final String name;
  final int quantity;
  final String? type;
  final String? note;

  const Resource({
    required this.id,
    required this.locationId,
    required this.name,
    required this.quantity,
    this.type,
    this.note,
  });

  Resource copyWith({
    int? id,
    int? locationId,
    String? name,
    int? quantity,
    String? type,
    String? note,
  }) {
    return Resource(
      id: id ?? this.id,
      locationId: locationId ?? this.locationId,
      name: name ?? this.name,
      quantity: quantity ?? this.quantity,
      type: type ?? this.type,
      note: note ?? this.note,
    );
  }

  factory Resource.fromJson(Map<String, dynamic> json) {
    return Resource(
      id: json['id'] as int,
      locationId: json['location_id'] as int,
      name: json['name'] as String,
      quantity: json['quantity'] as int,
      type: json['type'] as String?,
      note: json['note'] as String?,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'location_id': locationId,
      'name': name,
      'quantity': quantity,
      if (type != null) 'type': type,
      if (note != null) 'note': note,
    };
  }
}

--- FILE: lib/core/models/service.dart ---
class Service {
  final int id;
  final int businessId;
  final int categoryId;
  final String name;
  final String? description;
  final int sortOrder; // üîπ posizione nella categoria

  const Service({
    required this.id,
    required this.businessId,
    required this.categoryId,
    required this.name,
    this.description,
    this.sortOrder = 0,
  });

  Service copyWith({
    int? id,
    int? businessId,
    int? categoryId,
    String? name,
    String? description,
    int? sortOrder,
  }) => Service(
    id: id ?? this.id,
    businessId: businessId ?? this.businessId,
    categoryId: categoryId ?? this.categoryId,
    name: name ?? this.name,
    description: description ?? this.description,
    sortOrder: sortOrder ?? this.sortOrder,
  );

  factory Service.fromJson(Map<String, dynamic> json) => Service(
    id: json['id'] as int,
    businessId: json['business_id'] as int,
    categoryId: json['category_id'] as int,
    name: json['name'] as String,
    description: json['description'] as String?,
    sortOrder: json['sort_order'] as int? ?? 0,
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'category_id': categoryId,
    'name': name,
    if (description != null) 'description': description,
    'sort_order': sortOrder,
  };
}
--- FILE: lib/core/models/availability_exception.dart ---
import 'package:flutter/material.dart';

/// Tipo di eccezione alla disponibilit√† settimanale.
enum AvailabilityExceptionType {
  /// Lo staff √® DISPONIBILE in questa fascia (aggiunge disponibilit√†).
  available,

  /// Lo staff NON √® DISPONIBILE in questa fascia (rimuove disponibilit√†).
  unavailable,
}

/// Rappresenta un'eccezione alla disponibilit√† settimanale di uno staff.
///
/// A differenza del template settimanale che definisce gli orari ricorrenti,
/// le eccezioni permettono di:
/// - Aggiungere disponibilit√† extra in giorni/fasce specifiche
/// - Rimuovere disponibilit√† in giorni/fasce specifiche (ferie, malattia, ecc.)
///
/// Esempio:
/// - Template: Lun-Ven 09:00-18:00
/// - Eccezione "available": Sabato 14/12 dalle 10:00 alle 14:00 (lavoro extra)
/// - Eccezione "unavailable": Mercoled√¨ 18/12 tutto il giorno (ferie)
class AvailabilityException {
  final int id;
  final int staffId;

  /// Data specifica dell'eccezione.
  final DateTime date;

  /// Orario di inizio. Se null insieme a [endTime], l'eccezione copre l'intera giornata.
  final TimeOfDay? startTime;

  /// Orario di fine. Se null insieme a [startTime], l'eccezione copre l'intera giornata.
  final TimeOfDay? endTime;

  /// Tipo di eccezione: disponibile o non disponibile.
  final AvailabilityExceptionType type;

  /// Codice motivo opzionale (es. "vacation", "medical_visit", "extra_shift").
  final String? reasonCode;

  /// Motivo opzionale (es. "Ferie", "Visita medica", "Turno extra").
  final String? reason;

  const AvailabilityException({
    required this.id,
    required this.staffId,
    required this.date,
    this.startTime,
    this.endTime,
    required this.type,
    this.reasonCode,
    this.reason,
  });

  /// Se true, l'eccezione copre l'intera giornata.
  bool get isAllDay => startTime == null && endTime == null;

  /// Crea un'eccezione per l'intera giornata.
  factory AvailabilityException.allDay({
    required int id,
    required int staffId,
    required DateTime date,
    required AvailabilityExceptionType type,
    String? reasonCode,
    String? reason,
  }) {
    return AvailabilityException(
      id: id,
      staffId: staffId,
      date: DateUtils.dateOnly(date),
      startTime: null,
      endTime: null,
      type: type,
      reasonCode: reasonCode,
      reason: reason,
    );
  }

  /// Crea un'eccezione per una fascia oraria specifica.
  factory AvailabilityException.timeRange({
    required int id,
    required int staffId,
    required DateTime date,
    required TimeOfDay startTime,
    required TimeOfDay endTime,
    required AvailabilityExceptionType type,
    String? reasonCode,
    String? reason,
  }) {
    return AvailabilityException(
      id: id,
      staffId: staffId,
      date: DateUtils.dateOnly(date),
      startTime: startTime,
      endTime: endTime,
      type: type,
      reasonCode: reasonCode,
      reason: reason,
    );
  }

  AvailabilityException copyWith({
    int? id,
    int? staffId,
    DateTime? date,
    TimeOfDay? startTime,
    TimeOfDay? endTime,
    AvailabilityExceptionType? type,
    String? reasonCode,
    String? reason,
    bool clearStartTime = false,
    bool clearEndTime = false,
    bool clearReasonCode = false,
    bool clearReason = false,
  }) {
    return AvailabilityException(
      id: id ?? this.id,
      staffId: staffId ?? this.staffId,
      date: date ?? this.date,
      startTime: clearStartTime ? null : (startTime ?? this.startTime),
      endTime: clearEndTime ? null : (endTime ?? this.endTime),
      type: type ?? this.type,
      reasonCode: clearReasonCode ? null : (reasonCode ?? this.reasonCode),
      reason: clearReason ? null : (reason ?? this.reason),
    );
  }

  factory AvailabilityException.fromJson(Map<String, dynamic> json) {
    return AvailabilityException(
      id: json['id'] as int,
      staffId: json['staff_id'] as int,
      date: DateTime.parse(json['date'] as String),
      startTime: json['start_time'] != null
          ? _timeOfDayFromString(json['start_time'] as String)
          : null,
      endTime: json['end_time'] != null
          ? _timeOfDayFromString(json['end_time'] as String)
          : null,
      type: AvailabilityExceptionType.values.firstWhere(
        (e) => e.name == json['type'],
        orElse: () => AvailabilityExceptionType.unavailable,
      ),
      reasonCode: json['reason_code'] as String?,
      reason: json['reason'] as String?,
    );
  }

  Map<String, dynamic> toJson() => {
    'id': id,
    'staff_id': staffId,
    'date': date.toIso8601String().split('T').first,
    if (startTime != null) 'start_time': _timeOfDayToString(startTime!),
    if (endTime != null) 'end_time': _timeOfDayToString(endTime!),
    'type': type.name,
    if (reasonCode != null) 'reason_code': reasonCode,
    if (reason != null) 'reason': reason,
  };

  static TimeOfDay _timeOfDayFromString(String time) {
    final parts = time.split(':');
    return TimeOfDay(hour: int.parse(parts[0]), minute: int.parse(parts[1]));
  }

  static String _timeOfDayToString(TimeOfDay time) {
    return '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';
  }

  /// Verifica se l'eccezione √® per una data specifica.
  bool isOnDate(DateTime targetDate) {
    final target = DateUtils.dateOnly(targetDate);
    final excDate = DateUtils.dateOnly(date);
    return excDate == target;
  }

  /// Converte l'eccezione in un set di slot index.
  /// [minutesPerSlot] √® tipicamente 15.
  /// Per eccezioni "all day", copre tutti gli slot della giornata.
  Set<int> toSlotIndices({
    required int minutesPerSlot,
    required int totalSlotsPerDay,
  }) {
    if (isAllDay) {
      // Tutti gli slot della giornata
      return {for (int i = 0; i < totalSlotsPerDay; i++) i};
    }

    final startMinutes = startTime!.hour * 60 + startTime!.minute;
    final endMinutes = endTime!.hour * 60 + endTime!.minute;

    final startSlot = startMinutes ~/ minutesPerSlot;
    final endSlot = endMinutes ~/ minutesPerSlot;

    return {for (int i = startSlot; i < endSlot; i++) i};
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AvailabilityException &&
          runtimeType == other.runtimeType &&
          id == other.id;

  @override
  int get hashCode => id.hashCode;

  @override
  String toString() {
    final timeStr = isAllDay
        ? 'all day'
        : '${_timeOfDayToString(startTime!)}-${_timeOfDayToString(endTime!)}';
    return 'AvailabilityException(id: $id, staffId: $staffId, date: ${date.toIso8601String().split('T').first}, $timeStr, type: ${type.name}, reasonCode: $reasonCode, reason: $reason)';
  }
}
--- FILE: lib/core/models/location.dart ---
class Location {
  final int id;
  final int businessId;
  final String name;
  final String? address;
  final String? city;
  final String? region;
  final String? country;
  final String? phone;
  final String? email;
  final double? latitude;
  final double? longitude;
  final String? currency;
  final bool
  isDefault; // üîπ nuova propriet√†: indica se la sede √® quella predefinita

  const Location({
    required this.id,
    required this.businessId,
    required this.name,
    this.address,
    this.city,
    this.region,
    this.country,
    this.phone,
    this.email,
    this.latitude,
    this.longitude,
    this.currency,
    this.isDefault = false, // üîπ di default false
  });

  Location copyWith({
    int? id,
    int? businessId,
    String? name,
    String? address,
    String? city,
    String? region,
    String? country,
    String? phone,
    String? email,
    double? latitude,
    double? longitude,
    String? currency,
    bool? isDefault,
  }) {
    return Location(
      id: id ?? this.id,
      businessId: businessId ?? this.businessId,
      name: name ?? this.name,
      address: address ?? this.address,
      city: city ?? this.city,
      region: region ?? this.region,
      country: country ?? this.country,
      phone: phone ?? this.phone,
      email: email ?? this.email,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      currency: currency ?? this.currency,
      isDefault: isDefault ?? this.isDefault,
    );
  }

  factory Location.fromJson(Map<String, dynamic> json) {
    return Location(
      id: json['id'] as int,
      businessId: json['business_id'] as int,
      name: json['name'] as String,
      address: json['address'] as String?,
      city: json['city'] as String?,
      region: json['region'] as String?,
      country: json['country'] as String?,
      phone: json['phone'] as String?,
      email: json['email'] as String?,
      latitude: (json['latitude'] as num?)?.toDouble(),
      longitude: (json['longitude'] as num?)?.toDouble(),
      currency: json['currency'] as String?,
      isDefault: json['is_default'] as bool? ?? false, // üîπ compatibilit√† JSON
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'business_id': businessId,
      'name': name,
      if (address != null) 'address': address,
      if (city != null) 'city': city,
      if (region != null) 'region': region,
      if (country != null) 'country': country,
      if (phone != null) 'phone': phone,
      if (email != null) 'email': email,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (currency != null) 'currency': currency,
      'is_default': isDefault, // üîπ incluso sempre per chiarezza
    };
  }
}
--- FILE: lib/core/models/staff.dart ---
import 'package:flutter/material.dart';

import '../utils/color_utils.dart';

class Staff {
  final int id;
  final int businessId;
  final String name;
  final String surname;
  final Color color;
  final List<int> locationIds;
  final int sortOrder; // üîπ ordine in agenda
  final bool isDefault; // üîπ staff predefinito
  final bool isBookableOnline; // üîπ abilitato alle prenotazioni online

  const Staff({
    required this.id,
    required this.businessId,
    required this.name,
    required this.surname,
    required this.color,
    required this.locationIds,
    this.sortOrder = 0,
    this.isDefault = false,
    this.isBookableOnline = true,
  });

  Staff copyWith({
    int? id,
    int? businessId,
    String? name,
    String? surname,
    Color? color,
    List<int>? locationIds,
    int? sortOrder,
    bool? isDefault,
    bool? isBookableOnline,
  }) => Staff(
    id: id ?? this.id,
    businessId: businessId ?? this.businessId,
    name: name ?? this.name,
    surname: surname ?? this.surname,
    color: color ?? this.color,
    locationIds: locationIds ?? this.locationIds,
    sortOrder: sortOrder ?? this.sortOrder,
    isDefault: isDefault ?? this.isDefault,
    isBookableOnline: isBookableOnline ?? this.isBookableOnline,
  );

  factory Staff.fromJson(Map<String, dynamic> json) => Staff(
    id: json['id'] as int,
    businessId: json['business_id'] as int,
    name: json['name'] as String,
    surname: json['surname'] as String? ?? '',
    color: json['color_hex'] != null
        ? ColorUtils.fromHex(json['color_hex'] as String)
        : ColorUtils.fromHex('#FFD700'),
    locationIds: (json['location_ids'] as List<dynamic>? ?? [])
        .map((id) => id as int)
        .toList(),
    sortOrder: json['sort_order'] as int? ?? 0,
    isDefault: json['is_default'] as bool? ?? false,
    isBookableOnline: json['is_bookable_online'] as bool? ?? true,
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'business_id': businessId,
    'name': name,
    'surname': surname,
    'color_hex': ColorUtils.toHex(color),
    'location_ids': locationIds,
    'sort_order': sortOrder,
    'is_default': isDefault,
    'is_bookable_online': isBookableOnline,
  };

  bool worksAtLocation(int locationId) =>
      locationIds.isEmpty || locationIds.contains(locationId);

  String get displayName {
    if (surname.isEmpty) return name;
    return '$name $surname';
  }

  String get initials {
    final nameInitial = name.isNotEmpty
        ? name.trim().split(RegExp(r'\s+')).first[0].toUpperCase()
        : '';

    final surnameParts = surname.trim().split(RegExp(r'\s+'))
      ..removeWhere((p) => p.isEmpty);

    if (nameInitial.isEmpty && surnameParts.isEmpty) {
      return '';
    }

    var initials = nameInitial;

    if (surnameParts.isNotEmpty) {
      for (final part in surnameParts) {
        initials += part[0].toUpperCase();
        if (initials.length >= 3) break;
      }
    }

    if (initials.length < 3 && surnameParts.isEmpty) {
      final nameParts = name.trim().split(RegExp(r'\s+'))
        ..removeWhere((p) => p.isEmpty);
      if (nameParts.length > 1) {
        for (int i = 1; i < nameParts.length; i++) {
          initials += nameParts[i][0].toUpperCase();
          if (initials.length >= 3) break;
        }
      } else if (name.length > 1) {
        initials += name[1].toUpperCase();
      }
    }

    final endIndex = initials.length.clamp(1, 3).toInt();
    return initials.substring(0, endIndex);
  }
}
--- FILE: lib/core/models/service_staff_eligibility.dart ---
class ServiceStaffEligibility {
  final int serviceId;
  final int staffId;
  final int? locationId; // null => valido per tutte le location del servizio

  const ServiceStaffEligibility({
    required this.serviceId,
    required this.staffId,
    this.locationId,
  });
}

--- FILE: lib/core/models/service_variant.dart ---
import 'service_variant_resource_requirement.dart';

class ServiceVariant {
  final int id;
  final int serviceId;
  final int locationId;
  final int durationMinutes;
  final int? processingTime; // minuti opzionali post-lavorazione
  final int? blockedTime; // minuti opzionali bloccati
  final double price;
  final String? colorHex;
  final String? currency; // üîπ Valuta specifica (es. "EUR", "USD")
  final bool isBookableOnline;
  final bool isFree;
  final bool isPriceStartingFrom;
  final List<ServiceVariantResourceRequirement> resourceRequirements;

  const ServiceVariant({
    required this.id,
    required this.serviceId,
    required this.locationId,
    required this.durationMinutes,
    this.processingTime,
    this.blockedTime,
    required this.price,
    this.colorHex,
    this.currency,
    this.isBookableOnline = true,
    this.isFree = false,
    this.isPriceStartingFrom = false,
    this.resourceRequirements = const [],
  });

  ServiceVariant copyWith({
    int? id,
    int? serviceId,
    int? locationId,
    int? durationMinutes,
    int? processingTime,
    int? blockedTime,
    double? price,
    String? colorHex,
    String? currency,
    bool? isBookableOnline,
    bool? isFree,
    bool? isPriceStartingFrom,
    List<ServiceVariantResourceRequirement>? resourceRequirements,
  }) {
    return ServiceVariant(
      id: id ?? this.id,
      serviceId: serviceId ?? this.serviceId,
      locationId: locationId ?? this.locationId,
      durationMinutes: durationMinutes ?? this.durationMinutes,
      processingTime: processingTime ?? this.processingTime,
      blockedTime: blockedTime ?? this.blockedTime,
      price: price ?? this.price,
      colorHex: colorHex ?? this.colorHex,
      currency: currency ?? this.currency,
      isBookableOnline: isBookableOnline ?? this.isBookableOnline,
      isFree: isFree ?? this.isFree,
      isPriceStartingFrom: isPriceStartingFrom ?? this.isPriceStartingFrom,
      resourceRequirements:
          resourceRequirements ?? this.resourceRequirements,
    );
  }

  factory ServiceVariant.fromJson(Map<String, dynamic> json) {
    return ServiceVariant(
      id: json['id'] as int,
      serviceId: json['service_id'] as int,
      locationId: json['location_id'] as int,
      durationMinutes: json['duration_minutes'] as int,
      processingTime: json['processing_time'] as int?,
      blockedTime: json['blocked_time'] as int?,
      price: (json['price'] as num).toDouble(),
      colorHex: json['color_hex'] as String?,
      currency: json['currency'] as String?,
      isBookableOnline: json['is_bookable_online'] as bool? ?? true,
      isFree: json['is_free'] as bool? ?? false,
      isPriceStartingFrom: json['is_price_starting_from'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'service_id': serviceId,
      'location_id': locationId,
      'duration_minutes': durationMinutes,
      if (processingTime != null) 'processing_time': processingTime,
      if (blockedTime != null) 'blocked_time': blockedTime,
      'price': price,
      if (colorHex != null) 'color_hex': colorHex,
      if (currency != null) 'currency': currency,
      'is_bookable_online': isBookableOnline,
      'is_free': isFree,
      'is_price_starting_from': isPriceStartingFrom,
    };
  }
}
--- FILE: lib/core/models/service_variant_resource_requirement.dart ---
class ServiceVariantResourceRequirement {
  final int id;
  final int serviceVariantId;
  final int resourceId;
  final int unitsRequired;

  const ServiceVariantResourceRequirement({
    required this.id,
    required this.serviceVariantId,
    required this.resourceId,
    required this.unitsRequired,
  });

  ServiceVariantResourceRequirement copyWith({
    int? id,
    int? serviceVariantId,
    int? resourceId,
    int? unitsRequired,
  }) {
    return ServiceVariantResourceRequirement(
      id: id ?? this.id,
      serviceVariantId: serviceVariantId ?? this.serviceVariantId,
      resourceId: resourceId ?? this.resourceId,
      unitsRequired: unitsRequired ?? this.unitsRequired,
    );
  }

  factory ServiceVariantResourceRequirement.fromJson(
    Map<String, dynamic> json,
  ) {
    return ServiceVariantResourceRequirement(
      id: json['id'] as int,
      serviceVariantId: json['service_variant_id'] as int,
      resourceId: json['resource_id'] as int,
      unitsRequired: json['units_required'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'service_variant_id': serviceVariantId,
      'resource_id': resourceId,
      'units_required': unitsRequired,
    };
  }
}

--- FILE: lib/core/models/business.dart ---
class Business {
  final int id;
  final String name;
  final DateTime createdAt;
  final String currency;
  final String defaultPhonePrefix;

  const Business({
    required this.id,
    required this.name,
    required this.createdAt,
    this.currency = 'EUR',
    this.defaultPhonePrefix = '+39',
  });

  Business copyWith({
    int? id,
    String? name,
    DateTime? createdAt,
    String? currency,
    String? defaultPhonePrefix,
  }) {
    return Business(
      id: id ?? this.id,
      name: name ?? this.name,
      createdAt: createdAt ?? this.createdAt,
      currency: currency ?? this.currency,
      defaultPhonePrefix: defaultPhonePrefix ?? this.defaultPhonePrefix,
    );
  }

  factory Business.fromJson(Map<String, dynamic> json) {
    return Business(
      id: json['id'] as int,
      name: json['name'] as String,
      createdAt: DateTime.parse(json['created_at'] as String),
      currency: json['currency'] as String? ?? 'EUR',
      defaultPhonePrefix: json['default_phone_prefix'] as String? ?? '+39',
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'created_at': createdAt.toIso8601String(),
      'currency': currency,
      'default_phone_prefix': defaultPhonePrefix,
    };
  }
}
--- FILE: lib/core/widgets/app_bottom_sheet.dart ---
import 'dart:math' as math;

import 'package:flutter/material.dart';

/// Helper to show a modal bottom sheet with the app's default styling.
class AppBottomSheet {
  AppBottomSheet._();

  /// Altezza predefinita di tutti i bottom sheet (80% dello schermo).
  static const double defaultHeightFactor = 0.95;

  static Future<T?> show<T>({
    required BuildContext context,
    required WidgetBuilder builder,
    bool isScrollControlled = true,
    bool useSafeArea = true,
    bool useRootNavigator = true,
    EdgeInsetsGeometry? padding,

    /// Fraction of screen height (0.0 to 1.0). If provided, the bottom sheet
    /// will have a minimum height of this fraction of the screen.
    double? heightFactor = defaultHeightFactor,
  }) {
    final effectivePadding =
        padding ?? const EdgeInsets.symmetric(horizontal: 20, vertical: 16);
    return showModalBottomSheet<T>(
      context: context,
      isScrollControlled: isScrollControlled,
      backgroundColor: Colors.white,
      useSafeArea: useSafeArea,
      useRootNavigator: useRootNavigator,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (ctx) => AppBottomSheetContainer(
        padding: effectivePadding,
        heightFactor: heightFactor,
        child: builder(ctx),
      ),
    );
  }
}

/// Provides consistent padding, animation and handle for bottom sheet content.
class AppBottomSheetContainer extends StatelessWidget {
  const AppBottomSheetContainer({
    super.key,
    required this.child,
    this.padding = const EdgeInsets.symmetric(horizontal: 20, vertical: 16),
    this.showHandle = true,
    this.heightFactor,
  });

  final Widget child;
  final EdgeInsetsGeometry padding;
  final bool showHandle;

  /// If provided, the container will have a minimum height of this fraction
  /// of the screen height (0.0 to 1.0).
  final double? heightFactor;

  @override
  Widget build(BuildContext context) {
    final keyboardInset = MediaQuery.of(context).viewInsets.bottom;
    Widget content;

    // Apply height constraint if heightFactor is provided
    // Use SizedBox (not ConstrainedBox) to provide a finite height
    // so that Expanded children inside Column can work properly
    if (heightFactor != null) {
      // Ensure bottom padding is at least 50.0 to leave space above
      // system UI / controls and provide consistent spacing across sheets.
      final resolved = padding.resolve(Directionality.of(context));
      final effectivePadding = resolved.copyWith(
        bottom: math.max(resolved.bottom, 50.0),
      );
      final screenHeight = MediaQuery.of(context).size.height;
      final height = screenHeight * heightFactor!;
      content = SizedBox(
        height: height,
        child: Padding(padding: effectivePadding, child: child),
      );
    } else {
      // Quando heightFactor √® null, il contenuto si adatta all'altezza naturale
      // Usa solo il padding fornito senza forzare altezza minima
      content = Padding(padding: padding, child: child);
    }

    final body = showHandle
        ? Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const SizedBox(height: 8),
              Center(
                child: Container(
                  width: 40,
                  height: 4,
                  decoration: BoxDecoration(
                    color: Colors.grey.shade300,
                    borderRadius: BorderRadius.circular(4),
                  ),
                ),
              ),
              const SizedBox(height: 12),
              // Flexible permette al contenuto di adattarsi senza forzare
              // l'altezza massima della bottom sheet.
              Flexible(child: content),
            ],
          )
        : content;

    return AnimatedPadding(
      padding: EdgeInsets.only(bottom: keyboardInset),
      duration: const Duration(milliseconds: 180),
      curve: Curves.easeOut,
      child: body,
    );
  }
}
--- FILE: lib/core/widgets/reorder_toggle_button.dart ---
import 'package:flutter/material.dart';

/// Pulsante testuale con icona che riflette uno stato (attivo/inattivo).
class ReorderToggleButton extends StatelessWidget {
  final bool isActive;
  final VoidCallback onPressed;
  final String activeLabel;
  final String inactiveLabel;
  final IconData activeIcon;
  final IconData inactiveIcon;

  const ReorderToggleButton({
    super.key,
    required this.isActive,
    required this.onPressed,
    required this.activeLabel,
    required this.inactiveLabel,
    required this.activeIcon,
    required this.inactiveIcon,
  });

  @override
  Widget build(BuildContext context) {
    final icon = isActive ? activeIcon : inactiveIcon;
    final label = isActive ? activeLabel : inactiveLabel;

    return TextButton.icon(
      onPressed: onPressed,
      icon: Icon(icon),
      label: Text(label),
    );
  }
}
--- FILE: lib/core/widgets/no_scrollbar_behavior.dart ---
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';

/// Comportamento di scroll personalizzato per l‚Äôapp Agenda.
///
/// - Rimuove glow e scrollbar visibili.
/// - Mantiene la compatibilit√† con mouse, touch e trackpad.
/// - Usa una fisica permissiva che evita conflitti con PageView
///   e altri scroll orizzontali annidati.
///
/// Questo risolve i casi in cui il PageView esterno non riceve
/// mai il gesto perch√© la scroll view interna lo cattura completamente.
class NoScrollbarBehavior extends ScrollBehavior {
  const NoScrollbarBehavior();

  /// üîπ Disabilita completamente la scrollbar visiva.
  @override
  Widget buildScrollbar(
    BuildContext context,
    Widget child,
    ScrollableDetails details,
  ) {
    return child;
  }

  /// üîπ Abilita lo scroll con tutti i tipi di input
  /// (touch, mouse, trackpad, ecc.)
  @override
  Set<PointerDeviceKind> get dragDevices => {
    PointerDeviceKind.touch,
    PointerDeviceKind.mouse,
    PointerDeviceKind.trackpad,
  };

  /// üîπ Fisica dello scroll:
  /// - `BouncingScrollPhysics` ‚Üí effetto ‚Äúelastic‚Äù ai bordi (mobile-like).
  /// - `AlwaysScrollableScrollPhysics` ‚Üí consente lo scroll anche
  ///   quando non c‚Äô√® overflow, cos√¨ i gesti possono passare
  ///   al PageView esterno.
  ///
  /// Risultato: scroll fluido, niente blocchi, compatibile con nested scroll.
  @override
  ScrollPhysics getScrollPhysics(BuildContext context) =>
      const BouncingScrollPhysics(parent: AlwaysScrollableScrollPhysics());
}
--- FILE: lib/core/widgets/staff_picker_sheet.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/staff.dart';
import 'package:agenda_backend/core/widgets/app_dividers.dart';
import 'package:agenda_backend/core/widgets/app_bottom_sheet.dart';
import 'package:flutter/material.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Mostra un picker per la selezione dello staff.
/// Su mobile usa un bottom sheet, su desktop un dialog.
Future<int?> showStaffPickerSheet({
  required BuildContext context,
  required WidgetRef ref,
  required List<Staff> staff,
  required int? selectedId,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final l10n = context.l10n;

  if (formFactor != AppFormFactor.desktop) {
    return AppBottomSheet.show<int>(
      context: context,
      padding: EdgeInsets.zero,
      builder: (ctx) => SafeArea(
        child: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Padding(
                padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                child: Text(
                  l10n.selectStaffTitle,
                  style: Theme.of(
                    ctx,
                  ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.w600),
                ),
              ),
              const AppBottomSheetDivider(),
              StaffPickerContent(
                staff: staff,
                selectedId: selectedId,
                onSelected: (staffId) => Navigator.of(ctx).pop(staffId),
              ),
              const SizedBox(height: 8),
            ],
          ),
        ),
      ),
    );
  } else {
    return showDialog<int>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.selectStaffTitle),
        content: SizedBox(
          width: 300,
          child: ConstrainedBox(
            constraints: BoxConstraints(
              maxHeight: MediaQuery.of(ctx).size.height * 0.5,
            ),
            child: SingleChildScrollView(
              child: StaffPickerContent(
                staff: staff,
                selectedId: selectedId,
                onSelected: (staffId) => Navigator.of(ctx).pop(staffId),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

/// Content widget per la selezione dello staff (riutilizzabile)
class StaffPickerContent extends StatelessWidget {
  const StaffPickerContent({
    super.key,
    required this.staff,
    required this.selectedId,
    required this.onSelected,
  });

  final List<Staff> staff;
  final int? selectedId;
  final ValueChanged<int> onSelected;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    if (staff.isEmpty) {
      return Padding(
        padding: const EdgeInsets.all(24),
        child: Center(
          child: Text(
            l10n.noStaffAvailable,
            style: theme.textTheme.bodyMedium?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
        ),
      );
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        for (final member in staff)
          ListTile(
            leading: StaffCircleAvatar(
              height: 36,
              color: member.color,
              isHighlighted: member.id == selectedId,
              initials: member.initials,
            ),
            title: Text('${member.name} ${member.surname}'.trim()),
            trailing: member.id == selectedId
                ? Icon(Icons.check, color: theme.colorScheme.primary)
                : null,
            selected: member.id == selectedId,
            onTap: () => onSelected(member.id),
          ),
      ],
    );
  }
}
--- FILE: lib/core/widgets/app_buttons.dart ---
import 'package:flutter/material.dart';

/// Centralizes button styling so we can reuse consistent widgets across the app.
class AppButtonStyles {
  static const BorderRadiusGeometry defaultBorderRadius = BorderRadius.all(
    Radius.circular(10),
  );

  static const EdgeInsetsGeometry defaultPadding = EdgeInsets.symmetric(
    vertical: 14,
    horizontal: 16,
  );

  /// Larghezza standard per i pulsanti nei dialog (es. Annulla, Salva).
  static const double dialogButtonWidth = 120.0;

  /// Padding standard per i pulsanti nei dialog.
  static const EdgeInsetsGeometry dialogButtonPadding = EdgeInsets.symmetric(
    vertical: 12,
    horizontal: 16,
  );

  static ButtonStyle filled(
    BuildContext context, {
    Color? backgroundColor,
    Color? foregroundColor,
    EdgeInsetsGeometry? padding,
    BorderRadiusGeometry? borderRadius,
  }) {
    final colorScheme = Theme.of(context).colorScheme;
    return ElevatedButton.styleFrom(
      backgroundColor: backgroundColor ?? colorScheme.primary,
      foregroundColor: foregroundColor ?? colorScheme.onPrimary,
      padding: padding ?? defaultPadding,
      shape: RoundedRectangleBorder(
        borderRadius: borderRadius ?? defaultBorderRadius,
      ),
      textStyle: const TextStyle(fontWeight: FontWeight.w600),
    );
  }

  static ButtonStyle outlined(
    BuildContext context, {
    Color? borderColor,
    Color? foregroundColor,
    EdgeInsetsGeometry? padding,
    BorderRadiusGeometry? borderRadius,
  }) {
    final colorScheme = Theme.of(context).colorScheme;
    final resolvedBorderColor = borderColor ?? colorScheme.primary;
    return OutlinedButton.styleFrom(
      foregroundColor: foregroundColor ?? resolvedBorderColor,
      side: BorderSide(color: resolvedBorderColor, width: 1.4),
      padding: padding ?? defaultPadding,
      shape: RoundedRectangleBorder(
        borderRadius: borderRadius ?? defaultBorderRadius,
      ),
      textStyle: const TextStyle(fontWeight: FontWeight.w600),
    );
  }
}

class AppFilledButton extends StatelessWidget {
  const AppFilledButton({
    super.key,
    required this.onPressed,
    required this.child,
    this.backgroundColor,
    this.foregroundColor,
    this.padding,
    this.borderRadius,
    this.expand = false,
  });

  final VoidCallback? onPressed;
  final Widget child;
  final Color? backgroundColor;
  final Color? foregroundColor;
  final EdgeInsetsGeometry? padding;
  final BorderRadiusGeometry? borderRadius;
  final bool expand;

  @override
  Widget build(BuildContext context) {
    final button = ElevatedButton(
      onPressed: onPressed,
      style: AppButtonStyles.filled(
        context,
        backgroundColor: backgroundColor,
        foregroundColor: foregroundColor,
        padding: padding,
        borderRadius: borderRadius,
      ),
      child: child,
    );

    if (expand) {
      return SizedBox(width: double.infinity, child: button);
    }
    return button;
  }
}

class AppDangerButton extends StatelessWidget {
  const AppDangerButton({
    super.key,
    required this.onPressed,
    required this.child,
    this.expand = false,
    this.padding,
    this.borderRadius,
    this.backgroundColor,
  });

  final VoidCallback? onPressed;
  final Widget child;
  final bool expand;
  final EdgeInsetsGeometry? padding;
  final BorderRadiusGeometry? borderRadius;
  final Color? backgroundColor;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    return AppFilledButton(
      onPressed: onPressed,
      expand: expand,
      padding: padding,
      borderRadius: borderRadius,
      backgroundColor: backgroundColor ?? colorScheme.error,
      foregroundColor: colorScheme.onError,
      child: child,
    );
  }
}

class AppOutlinedActionButton extends StatelessWidget {
  const AppOutlinedActionButton({
    super.key,
    required this.onPressed,
    required this.child,
    this.borderColor,
    this.foregroundColor,
    this.padding,
    this.borderRadius,
    this.expand = false,
  });

  final VoidCallback? onPressed;
  final Widget child;
  final Color? borderColor;
  final Color? foregroundColor;
  final EdgeInsetsGeometry? padding;
  final BorderRadiusGeometry? borderRadius;
  final bool expand;

  @override
  Widget build(BuildContext context) {
    final button = OutlinedButton(
      onPressed: onPressed,
      style: AppButtonStyles.outlined(
        context,
        borderColor: borderColor,
        foregroundColor: foregroundColor,
        padding: padding,
        borderRadius: borderRadius,
      ),
      child: child,
    );

    if (expand) {
      return SizedBox(width: double.infinity, child: button);
    }
    return button;
  }
}
--- FILE: lib/core/widgets/app_dialogs.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

/// App-level dialog scaffolds to ensure consistent layout across features.
class AppFormDialog extends StatelessWidget {
  const AppFormDialog({
    super.key,
    required this.title,
    required this.content,
    required this.actions,
    this.contentPadding = const EdgeInsets.only(top: 8),
  });

  final Widget title;
  final Widget content;
  final List<Widget> actions;
  final EdgeInsetsGeometry contentPadding;

  @override
  Widget build(BuildContext context) {
    final base = Theme.of(context);
    final dialogTheme = base.copyWith(
      splashColor: Colors.transparent,
      highlightColor: Colors.transparent,
      splashFactory: NoSplash.splashFactory,
      switchTheme: base.switchTheme.copyWith(
        overlayColor: MaterialStateProperty.all(Colors.transparent),
        thumbColor: MaterialStateProperty.resolveWith((states) {
          if (states.contains(MaterialState.selected)) {
            return base.colorScheme.primary;
          }
          return null;
        }),
        trackColor: MaterialStateProperty.resolveWith((states) {
          if (states.contains(MaterialState.selected)) {
            return base.colorScheme.primary.withOpacity(0.35);
          }
          return null;
        }),
      ),
      radioTheme: base.radioTheme.copyWith(
        overlayColor: MaterialStateProperty.all(Colors.transparent),
        fillColor: MaterialStateProperty.resolveWith((states) {
          if (states.contains(MaterialState.selected)) {
            return base.colorScheme.primary;
          }
          return null;
        }),
      ),
    );
    return Theme(
      data: dialogTheme,
      child: CallbackShortcuts(
        bindings: <ShortcutActivator, VoidCallback>{
          SingleActivator(LogicalKeyboardKey.escape): () =>
              Navigator.of(context, rootNavigator: true).pop(),
        },
        child: Focus(
          autofocus: true,
          child: AlertDialog(
            title: title,
            content: SingleChildScrollView(
              padding: contentPadding,
              child: content,
            ),
            actions: actions,
          ),
        ),
      ),
    );
  }
}

Future<void> showAppConfirmDialog(
  BuildContext context, {
  required Widget title,
  Widget? content,
  required String confirmLabel,
  required VoidCallback onConfirm,
  String? cancelLabel,
  bool danger = false,
}) async {
  final colorScheme = Theme.of(context).colorScheme;
  return showDialog(
    context: context,
    builder: (_) {
      final base = Theme.of(context);
      final dialogTheme = base.copyWith(
        splashColor: Colors.transparent,
        highlightColor: Colors.transparent,
        splashFactory: NoSplash.splashFactory,
        switchTheme: base.switchTheme.copyWith(
          overlayColor: MaterialStateProperty.all(Colors.transparent),
          thumbColor: MaterialStateProperty.resolveWith((states) {
            if (states.contains(MaterialState.selected)) {
              return base.colorScheme.primary;
            }
            return null;
          }),
          trackColor: MaterialStateProperty.resolveWith((states) {
            if (states.contains(MaterialState.selected)) {
              return base.colorScheme.primary.withOpacity(0.35);
            }
            return null;
          }),
        ),
        radioTheme: base.radioTheme.copyWith(
          overlayColor: MaterialStateProperty.all(Colors.transparent),
        ),
      );
      return Theme(
        data: dialogTheme,
        child: CallbackShortcuts(
          bindings: <ShortcutActivator, VoidCallback>{
            SingleActivator(LogicalKeyboardKey.escape): () =>
                Navigator.of(context, rootNavigator: true).pop(),
            SingleActivator(LogicalKeyboardKey.enter): () {
              onConfirm();
              Navigator.of(context, rootNavigator: true).pop();
            },
          },
          child: Focus(
            autofocus: true,
            child: AlertDialog(
              title: title,
              content: content,
              actions: [
                TextButton(
                  onPressed: () =>
                      Navigator.of(context, rootNavigator: true).pop(),
                  child: Text(cancelLabel ?? 'Annulla'),
                ),
                ElevatedButton(
                  onPressed: () {
                    onConfirm();
                    Navigator.of(context, rootNavigator: true).pop();
                  },
                  style: danger
                      ? ElevatedButton.styleFrom(
                          backgroundColor: colorScheme.error,
                        )
                      : null,
                  child: Text(confirmLabel),
                ),
              ],
            ),
          ),
        ),
      );
    },
  );
}

Future<void> showAppInfoDialog(
  BuildContext context, {
  required Widget title,
  Widget? content,
  String? closeLabel,
}) {
  return showDialog(
    context: context,
    builder: (_) {
      final base = Theme.of(context);
      final dialogTheme = base.copyWith(
        splashColor: Colors.transparent,
        highlightColor: Colors.transparent,
        splashFactory: NoSplash.splashFactory,
        switchTheme: base.switchTheme.copyWith(
          overlayColor: MaterialStateProperty.all(Colors.transparent),
          thumbColor: MaterialStateProperty.resolveWith((states) {
            if (states.contains(MaterialState.selected)) {
              return base.colorScheme.primary;
            }
            return null;
          }),
          trackColor: MaterialStateProperty.resolveWith((states) {
            if (states.contains(MaterialState.selected)) {
              return base.colorScheme.primary.withOpacity(0.35);
            }
            return null;
          }),
        ),
        radioTheme: base.radioTheme.copyWith(
          overlayColor: MaterialStateProperty.all(Colors.transparent),
        ),
      );
      return Theme(
        data: dialogTheme,
        child: CallbackShortcuts(
          bindings: <ShortcutActivator, VoidCallback>{
            SingleActivator(LogicalKeyboardKey.escape): () =>
                Navigator.of(context, rootNavigator: true).pop(),
            SingleActivator(LogicalKeyboardKey.enter): () =>
                Navigator.of(context, rootNavigator: true).pop(),
          },
          child: Focus(
            autofocus: true,
            child: AlertDialog(
              title: title,
              content: content,
              actions: [
                TextButton(
                  onPressed: () =>
                      Navigator.of(context, rootNavigator: true).pop(),
                  child: Text(closeLabel ?? 'Chiudi'),
                ),
              ],
            ),
          ),
        ),
      );
    },
  );
}

/// Mostra un dialog di conferma e ritorna true se confermato, false altrimenti.
/// Utile per operazioni che richiedono conferma esplicita prima di procedere.
Future<bool> showConfirmDialog(
  BuildContext context, {
  required Widget title,
  Widget? content,
  required String confirmLabel,
  String? cancelLabel,
  bool danger = false,
}) async {
  final colorScheme = Theme.of(context).colorScheme;
  final result = await showDialog<bool>(
    context: context,
    barrierDismissible: false,
    builder: (_) {
      final base = Theme.of(context);
      final dialogTheme = base.copyWith(
        splashColor: Colors.transparent,
        highlightColor: Colors.transparent,
        splashFactory: NoSplash.splashFactory,
      );
      return Theme(
        data: dialogTheme,
        child: CallbackShortcuts(
          bindings: <ShortcutActivator, VoidCallback>{
            SingleActivator(LogicalKeyboardKey.escape): () =>
                Navigator.of(context, rootNavigator: true).pop(false),
          },
          child: Focus(
            autofocus: true,
            child: AlertDialog(
              title: title,
              content: content,
              actions: [
                TextButton(
                  onPressed: () =>
                      Navigator.of(context, rootNavigator: true).pop(false),
                  child: Text(cancelLabel ?? 'Annulla'),
                ),
                ElevatedButton(
                  onPressed: () =>
                      Navigator.of(context, rootNavigator: true).pop(true),
                  style: danger
                      ? ElevatedButton.styleFrom(
                          backgroundColor: colorScheme.error,
                        )
                      : null,
                  child: Text(confirmLabel),
                ),
              ],
            ),
          ),
        ),
      );
    },
  );
  return result ?? false;
}

/// Wrapper per dialog che gestisce automaticamente la chiusura con ESC.
/// Wrappa qualsiasi widget dialog per aggiungere supporto ESC.
class DismissibleDialog extends StatelessWidget {
  const DismissibleDialog({super.key, required this.child});

  final Widget child;

  @override
  Widget build(BuildContext context) {
    return CallbackShortcuts(
      bindings: <ShortcutActivator, VoidCallback>{
        SingleActivator(LogicalKeyboardKey.escape): () =>
            Navigator.of(context, rootNavigator: true).pop(),
      },
      child: Focus(autofocus: true, child: child),
    );
  }
}
--- FILE: lib/core/widgets/layout_config_auto_listener.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// 1. Importa il nuovo provider globale
import '../../app/providers/form_factor_provider.dart';
import '../../features/agenda/providers/layout_config_provider.dart';

class LayoutConfigAutoListener extends ConsumerStatefulWidget {
  final Widget child;

  const LayoutConfigAutoListener({super.key, required this.child});

  @override
  ConsumerState<LayoutConfigAutoListener> createState() =>
      _LayoutConfigAutoListenerState();
}

class _LayoutConfigAutoListenerState
    extends ConsumerState<LayoutConfigAutoListener>
    with WidgetsBindingObserver {
  Size? _lastSize;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);

    // üîπ FIX SAFARI DESKTOP: attendi un frame + piccolo delay
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      await Future.delayed(const Duration(milliseconds: 150));
      _updateLayoutConfig();
    });
  }

  @override
  void didChangeMetrics() {
    super.didChangeMetrics();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final newSize = MediaQuery.of(context).size;
      if (_lastSize == null || newSize != _lastSize) {
        _lastSize = newSize;
        _updateLayoutConfig();
      }
    });
  }

  void _updateLayoutConfig() {
    final size = MediaQuery.of(context).size;
    final screenWidth = size.width;
    final screenHeight = size.height;

    // üß© FIX: evita aggiornamenti con MediaQuery ancora non pronta
    if (screenWidth < 100 || screenHeight < 100) {
      return;
    }

    // üîπ Aggiorna layout per l‚Äôagenda
    ref.read(layoutConfigProvider.notifier).updateFromContext(context);

    // üîπ Aggiorna form factor globale (usato dalla shell)
    ref.read(formFactorProvider.notifier).update(screenWidth);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return widget.child;
  }
}
--- FILE: lib/core/widgets/adaptive_dropdown.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/core/widgets/app_bottom_sheet.dart';
import 'package:agenda_backend/core/widgets/desktop_popup_container.dart';
import 'dart:math' as math;

import 'package:flutter/material.dart';

import 'app_dividers.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// A dropdown item with a value and display widget.
class AdaptiveDropdownItem<T> {
  const AdaptiveDropdownItem({
    required this.value,
    required this.child,
    this.enabled = true,
  });

  final T value;
  final Widget child;
  final bool enabled;
}

/// Alignment for the desktop popup relative to the trigger.
enum AdaptiveDropdownAlignment { left, right }

/// Vertical position for the popup relative to the trigger.
enum AdaptiveDropdownVerticalPosition { below, above }

/// Adaptive dropdown that shows:
/// - A modal bottom sheet on mobile/tablet
/// - An anchored popup on desktop
class AdaptiveDropdown<T> extends ConsumerStatefulWidget {
  const AdaptiveDropdown({
    super.key,
    required this.items,
    required this.onSelected,
    required this.child,
    this.selectedValue,
    this.alignment = AdaptiveDropdownAlignment.left,
    this.verticalPosition = AdaptiveDropdownVerticalPosition.below,
    this.modalTitle,
    this.popupWidth,
    this.popupMaxHeight = 300,
    this.popupBorderRadius = 12.0,
    this.onOpened,
    this.onClosed,
    this.useRootNavigator = true,
    this.forcePopup = false,
    this.hideTriggerWhenOpen = false,
  });

  /// The list of items to display in the dropdown.
  final List<AdaptiveDropdownItem<T>> items;

  /// Called when an item is selected.
  final ValueChanged<T> onSelected;

  /// The trigger widget (typically a button or styled container).
  final Widget child;

  /// The currently selected value (for highlighting in the list).
  final T? selectedValue;

  /// Alignment of the popup on desktop (left or right).
  final AdaptiveDropdownAlignment alignment;

  /// Vertical position of the popup (above or below the trigger).
  final AdaptiveDropdownVerticalPosition verticalPosition;

  /// Optional title for the modal sheet on mobile/tablet.
  final String? modalTitle;

  /// Width of the popup on desktop. If null, matches the trigger width.
  final double? popupWidth;

  /// Maximum height of the popup on desktop.
  final double popupMaxHeight;

  /// Border radius of the popup on desktop.
  final double popupBorderRadius;

  /// Called when the dropdown is opened.
  final VoidCallback? onOpened;

  /// Called when the dropdown is closed.
  final VoidCallback? onClosed;

  /// Whether to push the mobile bottom sheet on the root navigator.
  final bool useRootNavigator;

  /// If true, always show popup instead of bottom sheet on mobile/tablet.
  final bool forcePopup;

  /// If true, hides the trigger widget when the popup is open.
  final bool hideTriggerWhenOpen;

  @override
  ConsumerState<AdaptiveDropdown<T>> createState() =>
      _AdaptiveDropdownState<T>();
}

class _AdaptiveDropdownState<T> extends ConsumerState<AdaptiveDropdown<T>> {
  final LayerLink _layerLink = LayerLink();
  OverlayEntry? _overlayEntry;
  bool _isOpen = false;

  @override
  void dispose() {
    _removeOverlay();
    super.dispose();
  }

  void _removeOverlay() {
    _overlayEntry?.remove();
    _overlayEntry = null;
    if (_isOpen) {
      _isOpen = false;
      widget.onClosed?.call();
      if (widget.hideTriggerWhenOpen) {
        setState(() {});
      }
    }
  }

  void _handleTap() {
    final formFactor = ref.read(formFactorProvider);

    if (widget.forcePopup || formFactor == AppFormFactor.desktop) {
      _showDesktopPopup();
    } else {
      _showMobileSheet();
    }
  }

  Future<void> _showMobileSheet() async {
    widget.onOpened?.call();
    _isOpen = true;

    final result = await AppBottomSheet.show<T>(
      context: context,
      heightFactor: null,
      builder: (ctx) => _MobileSheetContent<T>(
        items: widget.items,
        selectedValue: widget.selectedValue,
        title: widget.modalTitle,
        onSelected: (value) {
          Navigator.of(ctx).pop(value);
        },
      ),
      useRootNavigator: widget.useRootNavigator,
      padding: EdgeInsets.zero,
    );

    _isOpen = false;
    widget.onClosed?.call();

    if (result != null) {
      widget.onSelected(result);
    }
  }

  void _showDesktopPopup() {
    if (_overlayEntry != null) {
      _removeOverlay();
      return;
    }

    widget.onOpened?.call();
    _isOpen = true;
    if (widget.hideTriggerWhenOpen) {
      setState(() {});
    }

    final renderBox = context.findRenderObject() as RenderBox;
    final triggerSize = renderBox.size;

    _overlayEntry = OverlayEntry(
      builder: (overlayContext) => DesktopPopupContainer(
        link: _layerLink,
        triggerWidth: triggerSize.width,
        triggerHeight: triggerSize.height,
        popupWidth: widget.popupWidth,
        maxHeight: widget.popupMaxHeight,
        borderRadius: widget.popupBorderRadius,
        alignment: widget.alignment == AdaptiveDropdownAlignment.right
            ? PopupAlignment.right
            : PopupAlignment.left,
        verticalPosition:
            widget.verticalPosition == AdaptiveDropdownVerticalPosition.above
            ? PopupVerticalPosition.above
            : PopupVerticalPosition.below,
        onDismiss: _removeOverlay,
        child: _DesktopDropdownContent<T>(
          items: widget.items,
          selectedValue: widget.selectedValue,
          title: widget.modalTitle,
          onSelected: (value) {
            _removeOverlay();
            widget.onSelected(value);
          },
        ),
      ),
    );

    Overlay.of(context).insert(_overlayEntry!);
  }

  @override
  Widget build(BuildContext context) {
    return CompositedTransformTarget(
      link: _layerLink,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: _handleTap,
        child: Visibility(
          visible: !(widget.hideTriggerWhenOpen && _isOpen),
          maintainSize: true,
          maintainAnimation: true,
          maintainState: true,
          child: widget.child,
        ),
      ),
    );
  }
}

/// Mobile/tablet modal sheet content.
class _MobileSheetContent<T> extends StatelessWidget {
  const _MobileSheetContent({
    required this.items,
    required this.onSelected,
    this.selectedValue,
    this.title,
  });

  final List<AdaptiveDropdownItem<T>> items;
  final ValueChanged<T> onSelected;
  final T? selectedValue;
  final String? title;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        if (title != null) ...[
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 16, 16, 12),
            child: Text(
              title!,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          const AppBottomSheetDivider(),
        ],
        ...items.map((item) {
          final isSelected = item.value == selectedValue;
          return InkWell(
            onTap: item.enabled ? () => onSelected(item.value) : null,
            splashColor: Colors.transparent,
            highlightColor: Colors.transparent,
            child: Container(
              padding: const EdgeInsets.symmetric(vertical: 14, horizontal: 16),
              color: isSelected
                  ? colorScheme.primary.withOpacity(0.08)
                  : Colors.transparent,
              child: Row(
                children: [
                  Expanded(
                    child: DefaultTextStyle.merge(
                      style: TextStyle(
                        color: item.enabled
                            ? colorScheme.onSurface
                            : colorScheme.onSurface.withOpacity(0.38),
                        fontWeight: isSelected
                            ? FontWeight.w600
                            : FontWeight.normal,
                      ),
                      child: item.child,
                    ),
                  ),
                  if (isSelected)
                    Icon(Icons.check, size: 20, color: colorScheme.primary),
                ],
              ),
            ),
          );
        }),
        // Safe area padding for bottom with minimum inset
        SizedBox(
          height: math.max(MediaQuery.of(context).viewPadding.bottom, 15),
        ),
      ],
    );
  }
}

/// Content for the desktop dropdown popup.
class _DesktopDropdownContent<T> extends StatelessWidget {
  const _DesktopDropdownContent({
    required this.items,
    required this.onSelected,
    this.selectedValue,
    this.title,
    this.borderRadius = 12.0,
  });

  final List<AdaptiveDropdownItem<T>> items;
  final T? selectedValue;
  final String? title;
  final ValueChanged<T> onSelected;
  final double borderRadius;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        if (title != null) ...[
          Padding(
            padding: const EdgeInsets.fromLTRB(12, 10, 12, 6),
            child: Text(
              title!,
              style: theme.textTheme.labelMedium?.copyWith(
                color: colorScheme.onSurfaceVariant,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          const AppBottomSheetDivider(),
        ],
        Flexible(
          child: SingleChildScrollView(
            padding: EdgeInsets.only(top: title == null ? 4 : 0),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                for (int i = 0; i < items.length; i++)
                  _DesktopPopupItem<T>(
                    item: items[i],
                    isSelected: items[i].value == selectedValue,
                    isLast: i == items.length - 1,
                    borderRadius: borderRadius,
                    onTap: () => onSelected(items[i].value),
                  ),
              ],
            ),
          ),
        ),
      ],
    );
  }
}

/// Individual item in the desktop popup.
class _DesktopPopupItem<T> extends StatefulWidget {
  const _DesktopPopupItem({
    required this.item,
    required this.isSelected,
    required this.onTap,
    this.isLast = false,
    this.borderRadius = 12.0,
  });

  final AdaptiveDropdownItem<T> item;
  final bool isSelected;
  final VoidCallback onTap;
  final bool isLast;
  final double borderRadius;

  @override
  State<_DesktopPopupItem<T>> createState() => _DesktopPopupItemState<T>();
}

class _DesktopPopupItemState<T> extends State<_DesktopPopupItem<T>> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    final backgroundColor = widget.isSelected
        ? colorScheme.primary.withOpacity(0.08)
        : _isHovered
        ? colorScheme.primary.withOpacity(0.04)
        : Colors.transparent;

    final borderRadius = widget.isLast
        ? BorderRadius.only(
            bottomLeft: Radius.circular(widget.borderRadius),
            bottomRight: Radius.circular(widget.borderRadius),
          )
        : BorderRadius.zero;

    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      cursor: widget.item.enabled
          ? SystemMouseCursors.click
          : SystemMouseCursors.basic,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: widget.item.enabled ? widget.onTap : null,
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 100),
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
          decoration: BoxDecoration(
            color: backgroundColor,
            borderRadius: borderRadius,
          ),
          child: Row(
            children: [
              Expanded(
                child: DefaultTextStyle.merge(
                  style: TextStyle(
                    color: widget.item.enabled
                        ? colorScheme.onSurface
                        : colorScheme.onSurface.withOpacity(0.38),
                    fontWeight: widget.isSelected
                        ? FontWeight.w600
                        : FontWeight.normal,
                  ),
                  child: widget.item.child,
                ),
              ),
              if (widget.isSelected)
                Icon(Icons.check, size: 18, color: colorScheme.primary),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/core/widgets/app_switch.dart ---
import 'package:flutter/material.dart';

class AppSwitch extends StatelessWidget {
  const AppSwitch({super.key, required this.value, this.onChanged});

  final bool value;
  final ValueChanged<bool>? onChanged;

  @override
  Widget build(BuildContext context) {
    return Switch.adaptive(
      value: value,
      onChanged: onChanged,
      activeColor: Theme.of(context).colorScheme.primary,
    );
  }
}
--- FILE: lib/core/widgets/labeled_form_field.dart ---
import 'package:flutter/material.dart';

/// Widget che mostra una label sopra un campo form.
/// Usato per uniformare il layout dei form in tutta l'app.
class LabeledFormField extends StatelessWidget {
  const LabeledFormField({
    super.key,
    required this.label,
    required this.child,
    this.labelSpacing = 6.0,
  });

  /// Label del campo.
  final String label;

  /// Widget figlio (es. TextFormField, DropdownButtonFormField, ecc.).
  final Widget child;

  /// Spacing tra label e campo. Default 6.0.
  final double labelSpacing;

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(label, style: const TextStyle(fontWeight: FontWeight.w600)),
        SizedBox(height: labelSpacing),
        child,
      ],
    );
  }
}
--- FILE: lib/core/widgets/desktop_popup_container.dart ---
import 'package:flutter/material.dart';

/// Alignment for the desktop popup relative to the trigger.
enum PopupAlignment { left, right }

/// Vertical position for the popup relative to the trigger.
enum PopupVerticalPosition { below, above }

/// A reusable container for desktop anchored popups with consistent styling.
/// Provides: dismiss layer, animation, border, positioning.
class DesktopPopupContainer extends StatefulWidget {
  const DesktopPopupContainer({
    super.key,
    required this.link,
    required this.triggerWidth,
    required this.triggerHeight,
    required this.onDismiss,
    required this.child,
    this.popupWidth,
    this.maxHeight = 300,
    this.borderRadius = 12.0,
    this.alignment = PopupAlignment.left,
    this.verticalPosition = PopupVerticalPosition.below,
  });

  /// The layer link to anchor the popup to the trigger.
  final LayerLink link;

  /// The width of the trigger widget.
  final double triggerWidth;

  /// The height of the trigger widget.
  final double triggerHeight;

  /// Called when the popup should be dismissed.
  final VoidCallback onDismiss;

  /// The content of the popup.
  final Widget child;

  /// Width of the popup. If null, matches the trigger width.
  final double? popupWidth;

  /// Maximum height of the popup.
  final double maxHeight;

  /// Border radius of the popup.
  final double borderRadius;

  /// Alignment of the popup relative to the trigger.
  final PopupAlignment alignment;

  /// Vertical position of the popup (above or below the trigger).
  final PopupVerticalPosition verticalPosition;

  @override
  State<DesktopPopupContainer> createState() => _DesktopPopupContainerState();
}

class _DesktopPopupContainerState extends State<DesktopPopupContainer>
    with SingleTickerProviderStateMixin {
  late final AnimationController _animationController;
  late final Animation<double> _fadeAnimation;
  late final Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 150),
      vsync: this,
    );
    _fadeAnimation = CurvedAnimation(
      parent: _animationController,
      curve: Curves.easeOut,
    );
    _scaleAnimation = Tween<double>(begin: 0.95, end: 1.0).animate(
      CurvedAnimation(parent: _animationController, curve: Curves.easeOut),
    );
    _animationController.forward();
  }

  @override
  void dispose() {
    _animationController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final effectiveWidth = widget.popupWidth ?? widget.triggerWidth;
    final isAbove = widget.verticalPosition == PopupVerticalPosition.above;

    // Horizontal offset based on alignment
    final horizontalOffset = widget.alignment == PopupAlignment.right
        ? widget.triggerWidth - effectiveWidth
        : 0.0;

    // Vertical offset and anchors based on position
    final Alignment targetAnchor;
    final Alignment followerAnchor;
    final EdgeInsets padding;

    if (isAbove) {
      // Popup appears above the trigger, growing downward
      targetAnchor = Alignment.topLeft;
      followerAnchor = Alignment.topLeft;
      padding = const EdgeInsets.only(bottom: 4);
    } else {
      targetAnchor = Alignment.bottomLeft;
      followerAnchor = Alignment.topLeft;
      padding = const EdgeInsets.only(top: 4);
    }

    final offset = Offset(horizontalOffset, 0);

    // Scale alignment for animation
    final scaleAlignment = isAbove
        ? (widget.alignment == PopupAlignment.right
              ? Alignment.bottomRight
              : Alignment.bottomLeft)
        : (widget.alignment == PopupAlignment.right
              ? Alignment.topRight
              : Alignment.topLeft);

    return Stack(
      children: [
        // Dismiss layer
        Positioned.fill(
          child: GestureDetector(
            behavior: HitTestBehavior.translucent,
            onTap: widget.onDismiss,
            child: const ColoredBox(color: Colors.transparent),
          ),
        ),
        // Popup
        CompositedTransformFollower(
          link: widget.link,
          showWhenUnlinked: false,
          offset: offset,
          targetAnchor: targetAnchor,
          followerAnchor: followerAnchor,
          child: FadeTransition(
            opacity: _fadeAnimation,
            child: ScaleTransition(
              scale: _scaleAnimation,
              alignment: scaleAlignment,
              child: Padding(
                padding: padding,
                child: Material(
                  elevation: 8,
                  color: colorScheme.surface,
                  borderRadius: BorderRadius.circular(widget.borderRadius),
                  clipBehavior: Clip.antiAlias,
                  child: Container(
                    width: effectiveWidth,
                    constraints: BoxConstraints(maxHeight: widget.maxHeight),
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(widget.borderRadius),
                      border: Border.all(color: Colors.grey.withOpacity(0.35)),
                    ),
                    child: widget.child,
                  ),
                ),
              ),
            ),
          ),
        ),
      ],
    );
  }
}
--- FILE: lib/core/widgets/phone_input_field.dart ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../l10n/l10_extension.dart';
/// Lista dei prefissi telefonici pi√π comuni
const kPhonePrefixes = <PhonePrefix>[
  PhonePrefix('+39', 'IT', 'üáÆüáπ'),
  PhonePrefix('+1', 'US', 'üá∫üá∏'),
  PhonePrefix('+44', 'GB', 'üá¨üáß'),
  PhonePrefix('+49', 'DE', 'üá©üá™'),
  PhonePrefix('+33', 'FR', 'üá´üá∑'),
  PhonePrefix('+34', 'ES', 'üá™üá∏'),
  PhonePrefix('+41', 'CH', 'üá®üá≠'),
  PhonePrefix('+43', 'AT', 'üá¶üáπ'),
  PhonePrefix('+31', 'NL', 'üá≥üá±'),
  PhonePrefix('+32', 'BE', 'üáßüá™'),
  PhonePrefix('+351', 'PT', 'üáµüáπ'),
  PhonePrefix('+48', 'PL', 'üáµüá±'),
  PhonePrefix('+420', 'CZ', 'üá®üáø'),
  PhonePrefix('+385', 'HR', 'üá≠üá∑'),
  PhonePrefix('+386', 'SI', 'üá∏üáÆ'),
  PhonePrefix('+40', 'RO', 'üá∑üá¥'),
  PhonePrefix('+30', 'GR', 'üá¨üá∑'),
  PhonePrefix('+7', 'RU', 'üá∑üá∫'),
  PhonePrefix('+86', 'CN', 'üá®üá≥'),
  PhonePrefix('+81', 'JP', 'üáØüáµ'),
  PhonePrefix('+82', 'KR', 'üá∞üá∑'),
  PhonePrefix('+91', 'IN', 'üáÆüá≥'),
  PhonePrefix('+61', 'AU', 'üá¶üá∫'),
  PhonePrefix('+55', 'BR', 'üáßüá∑'),
  PhonePrefix('+52', 'MX', 'üá≤üáΩ'),
  PhonePrefix('+54', 'AR', 'üá¶üá∑'),
];

/// Modello per un prefisso telefonico
class PhonePrefix {
  final String code;
  final String countryCode;
  final String flag;

  const PhonePrefix(this.code, this.countryCode, this.flag);

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PhonePrefix &&
          runtimeType == other.runtimeType &&
          code == other.code;

  @override
  int get hashCode => code.hashCode;
}

/// Estrae prefisso e numero da un telefono completo
/// Ritorna (prefix, number)
(String prefix, String number) parsePhoneWithPrefix(
  String? phone, {
  String defaultPrefix = '+39',
}) {
  if (phone == null || phone.isEmpty) {
    return (defaultPrefix, '');
  }

  final cleaned = phone.replaceAll(RegExp(r'\s+'), '');

  // Cerca un prefisso conosciuto
  for (final p in kPhonePrefixes) {
    if (cleaned.startsWith(p.code)) {
      return (p.code, cleaned.substring(p.code.length));
    }
  }

  // Prova a estrarre un prefisso generico +XX o +XXX
  if (cleaned.startsWith('+')) {
    final match = RegExp(r'^\+\d{1,3}').firstMatch(cleaned);
    if (match != null) {
      return (match.group(0)!, cleaned.substring(match.end));
    }
  }

  // Nessun prefisso trovato, usa il default
  return (defaultPrefix, phone);
}

/// Combina prefisso e numero in un formato standard
String formatPhoneWithPrefix(String prefix, String number) {
  final cleanNumber = number.replaceAll(RegExp(r'\s+'), '');
  if (cleanNumber.isEmpty) return '';
  return '$prefix $cleanNumber';
}

/// Widget per input telefono con prefisso selezionabile
class PhoneInputField extends StatefulWidget {
  const PhoneInputField({
    super.key,
    this.labelText,
    required this.defaultPrefix,
    this.initialPhone,
    this.onChanged,
    this.validator,
    this.textInputAction = TextInputAction.next,
    this.isDense = false,
    this.useOutlineBorder = false,
  });

  /// Label opzionale. Se null, il campo non mostra label interna.
  final String? labelText;
  final String defaultPrefix;
  final String? initialPhone;
  final ValueChanged<String>? onChanged;
  final FormFieldValidator<String>? validator;
  final TextInputAction textInputAction;

  /// Se true, usa InputDecoration.isDense = true.
  final bool isDense;

  /// Se true, usa OutlineInputBorder invece del default UnderlineInputBorder.
  final bool useOutlineBorder;

  @override
  State<PhoneInputField> createState() => PhoneInputFieldState();
}

class PhoneInputFieldState extends State<PhoneInputField> {
  late String _selectedPrefix;
  late final TextEditingController _controller;

  @override
  void initState() {
    super.initState();
    final (prefix, number) = parsePhoneWithPrefix(
      widget.initialPhone,
      defaultPrefix: widget.defaultPrefix,
    );
    _selectedPrefix = prefix;
    _controller = TextEditingController(text: _formatNumber(number));
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  /// Ritorna il numero di telefono completo (prefisso + numero)
  String get fullPhone {
    final number = _controller.text.replaceAll(RegExp(r'\s+'), '');
    if (number.isEmpty) return '';
    return '$_selectedPrefix $number';
  }

  /// Ritorna solo il numero senza prefisso
  String get numberOnly => _controller.text.replaceAll(RegExp(r'\s+'), '');

  /// Ritorna il prefisso selezionato
  String get prefix => _selectedPrefix;

  String _formatNumber(String number) {
    final digits = number.replaceAll(RegExp(r'\s+'), '');
    if (digits.isEmpty) return '';

    final buffer = StringBuffer();
    for (var i = 0; i < digits.length; i++) {
      if (i == 3 || i == 6) {
        buffer.write(' ');
      }
      buffer.write(digits[i]);
    }
    return buffer.toString();
  }

  void _notifyChange() {
    widget.onChanged?.call(fullPhone);
  }

  @override
  Widget build(BuildContext context) {
    return TextFormField(
      controller: _controller,
      decoration: InputDecoration(
        labelText: widget.labelText,
        isDense: widget.isDense,
        border: widget.useOutlineBorder ? const OutlineInputBorder() : null,
        prefixIcon: _PrefixDropdown(
          selectedPrefix: _selectedPrefix,
          onChanged: (newPrefix) {
            setState(() => _selectedPrefix = newPrefix);
            _notifyChange();
          },
        ),
      ),
      keyboardType: TextInputType.phone,
      textInputAction: widget.textInputAction,
      inputFormatters: [
        FilteringTextInputFormatter.allow(RegExp(r'[0-9\s]')),
        _PhoneNumberFormatter(),
      ],
      onChanged: (_) => _notifyChange(),
      validator:
          widget.validator ??
          (v) {
            final t = v?.trim().replaceAll(RegExp(r'\s+'), '') ?? '';
            if (t.isEmpty) return null; // optional
            if (!RegExp(r'^\d{6,15}$').hasMatch(t)) {
              return context.l10n.validationInvalidPhone;
            }
            return null;
          },
    );
  }
}

/// Dropdown per selezionare il prefisso
class _PrefixDropdown extends StatelessWidget {
  const _PrefixDropdown({
    required this.selectedPrefix,
    required this.onChanged,
  });

  final String selectedPrefix;
  final ValueChanged<String> onChanged;

  @override
  Widget build(BuildContext context) {
    // Trova il prefisso corrente nella lista, altrimenti usa il primo
    final currentPrefix = kPhonePrefixes.firstWhere(
      (p) => p.code == selectedPrefix,
      orElse: () => kPhonePrefixes.first,
    );

    return Padding(
      padding: const EdgeInsets.only(left: 12),
      child: DropdownButtonHideUnderline(
        child: DropdownButton<String>(
          value: currentPrefix.code,
          isDense: true,
          items: kPhonePrefixes.map((p) {
            return DropdownMenuItem<String>(
              value: p.code,
              child: Text(
                '${p.flag} ${p.code}',
                style: const TextStyle(fontSize: 14),
              ),
            );
          }).toList(),
          onChanged: (value) {
            if (value != null) {
              onChanged(value);
            }
          },
          selectedItemBuilder: (context) {
            return kPhonePrefixes.map((p) {
              return Center(
                child: Text(
                  '${p.flag} ${p.code}',
                  style: const TextStyle(fontSize: 14),
                ),
              );
            }).toList();
          },
        ),
      ),
    );
  }
}

/// Formatta il numero di telefono aggiungendo spazi per leggibilit√†
class _PhoneNumberFormatter extends TextInputFormatter {
  @override
  TextEditingValue formatEditUpdate(
    TextEditingValue oldValue,
    TextEditingValue newValue,
  ) {
    final digitsOnly = newValue.text.replaceAll(RegExp(r'\s+'), '');

    if (digitsOnly.isEmpty) {
      return newValue.copyWith(text: '');
    }

    final buffer = StringBuffer();
    for (var i = 0; i < digitsOnly.length; i++) {
      if (i == 3 || i == 6) {
        buffer.write(' ');
      }
      buffer.write(digitsOnly[i]);
    }

    final formatted = buffer.toString();

    return TextEditingValue(
      text: formatted,
      selection: TextSelection.collapsed(offset: formatted.length),
    );
  }
}
--- FILE: lib/core/widgets/app_dividers.dart ---
import 'package:flutter/material.dart';

/// Divider standard per bottom sheet (stile coerente con creazione appuntamento).
class AppBottomSheetDivider extends StatelessWidget {
  const AppBottomSheetDivider({super.key});

  @override
  Widget build(BuildContext context) {
    return const Divider(height: 1, thickness: 0.5, color: Color(0x1F000000));
  }
}
--- FILE: lib/core/widgets/reorder_toggle_panel.dart ---
import 'package:flutter/material.dart';

/// Container che dispone una serie di widget con spacing orizzontale e wrap
/// automatico per evitare overflow su schermi stretti.
class ReorderTogglePanel extends StatelessWidget {
  final bool isWide;
  final List<Widget> children;

  const ReorderTogglePanel({
    super.key,
    required this.isWide,
    required this.children,
  });

  @override
  Widget build(BuildContext context) {
    return Wrap(spacing: 8, runSpacing: 8, children: children);
  }
}
--- FILE: lib/app/app_constants.dart ---
/// Flag applicativo per controllare se lo staff pu√≤ essere associato a pi√π
/// sedi contemporaneamente. Quando √® `false`, il form di creazione/modifica
/// consente una sola sede per membro del team e forza la selezione singola.
const bool kAllowStaffMultiLocationSelection = false;
--- FILE: lib/app/router.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../core/l10n/l10_extension.dart';
// Importa le nuove schermate
import '../features/agenda/presentation/agenda_screen.dart';
import '../features/clients/presentation/clients_screen.dart';
import '../features/services/presentation/services_screen.dart';
import '../features/staff/presentation/staff_week_overview_screen.dart';
import '../features/staff/presentation/team_screen.dart';
// Importa la nostra "Shell"
import 'scaffold_with_navigation.dart';

// 1. Definiamo una chiave globale per la nostra Shell (necessaria)
final _rootNavigatorKey = GlobalKey<NavigatorState>();

/// üîπ Router globale dell‚Äôapp
final GoRouter appRouter = GoRouter(
  initialLocation: '/agenda',
  navigatorKey: _rootNavigatorKey,

  debugLogDiagnostics: kDebugMode,

  errorBuilder: (context, state) => Scaffold(
    appBar: AppBar(title: Text(context.l10n.errorTitle)),
    body: Center(
      child: Text(
        context.l10n.errorNotFound(state.uri.path),
        style: const TextStyle(color: Colors.redAccent),
      ),
    ),
  ),

  // 2. Definiamo la nostra navigazione con `StatefulShellRoute`
  routes: [
    StatefulShellRoute.indexedStack(
      builder: (context, state, navigationShell) {
        return ScaffoldWithNavigation(navigationShell: navigationShell);
      },

      branches: [
        // --- Ramo 0: Agenda ---
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/agenda',
              name: 'agenda',
              builder: (BuildContext context, GoRouterState state) {
                final q = state.uri.queryParameters['clientId'];
                final initialClientId = q == null ? null : int.tryParse(q);
                return AgendaScreen(initialClientId: initialClientId);
              },
            ),
          ],
        ),

        // --- Ramo 1: Clienti ---
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/clienti',
              name: 'clienti',
              builder: (BuildContext context, GoRouterState state) =>
                  const ClientsScreen(),
            ),
          ],
        ),

        // --- Ramo 2: Servizi ---
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/servizi',
              name: 'servizi',
              builder: (BuildContext context, GoRouterState state) =>
                  const ServicesScreen(),
            ),
          ],
        ),

        // --- Ramo 3: Staff ---
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/staff',
              name: 'staff',
              builder: (BuildContext context, GoRouterState state) =>
                  const TeamScreen(),
            ),
          ],
        ),
      ],
    ),
    GoRoute(
      path: '/staff-availability',
      name: 'staff-availability',
      parentNavigatorKey: _rootNavigatorKey,
      builder: (BuildContext context, GoRouterState state) =>
          const StaffWeekOverviewScreen(),
    ),
  ],
);
--- FILE: lib/app/scaffold_with_navigation.dart ---
// Cleaned duplicate header
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/widgets/agenda_control_components.dart';
import 'package:agenda_backend/app/widgets/agenda_staff_filter_selector.dart';
import 'package:agenda_backend/app/widgets/top_controls.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/widgets/agenda_dividers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:intl/intl.dart';

import '../core/models/location.dart';
import '../core/l10n/l10_extension.dart';
import '../core/widgets/app_bottom_sheet.dart';
import '../core/widgets/adaptive_dropdown.dart';
import '../core/widgets/app_buttons.dart';
import '../features/agenda/presentation/dialogs/add_block_dialog.dart';
import '../features/agenda/presentation/widgets/agenda_top_controls.dart';
import '../features/agenda/presentation/widgets/booking_dialog.dart';
import '../features/agenda/providers/date_range_provider.dart';
import '../features/agenda/providers/layout_config_provider.dart';
import '../features/agenda/providers/location_providers.dart';
import '../features/clients/presentation/dialogs/client_edit_dialog.dart';
import '../features/services/presentation/dialogs/category_dialog.dart';
import '../features/services/presentation/dialogs/service_dialog.dart';
import '../features/services/providers/services_reorder_provider.dart';
import '../features/staff/presentation/dialogs/location_dialog.dart';
import '../features/staff/presentation/dialogs/staff_dialog.dart';
import '../features/staff/providers/staff_reorder_provider.dart';
import '../features/staff/providers/staff_providers.dart';

Widget _buildAddButtonContent({
  required bool showLabelEffective,
  required bool compact,
  required String label,
  required Color onContainer,
}) {
  if (compact) {
    return showLabelEffective
        ? Text(
            label,
            style: TextStyle(color: onContainer, fontWeight: FontWeight.w600),
          )
        : Icon(Icons.add_outlined, size: 22, color: onContainer);
  }
  if (!showLabelEffective) {
    return Icon(Icons.add_outlined, size: 22, color: onContainer);
  }
  return Row(
    mainAxisSize: MainAxisSize.min,
    children: [
      Icon(Icons.add_outlined, size: 22, color: onContainer),
      const SizedBox(width: 8),
      Text(
        label,
        style: TextStyle(color: onContainer, fontWeight: FontWeight.w600),
      ),
    ],
  );
}

class ScaffoldWithNavigation extends ConsumerWidget {
  const ScaffoldWithNavigation({super.key, required this.navigationShell});

  final StatefulNavigationShell navigationShell;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final formFactor = ref.watch(formFactorProvider);
    final isAgenda = navigationShell.currentIndex == 0;
    final isClients = navigationShell.currentIndex == 1;
    final isServices = navigationShell.currentIndex == 2;
    final isStaff = navigationShell.currentIndex == 3;
    final agendaDate = ref.watch(agendaDateProvider);
    final isToday = DateUtils.isSameDay(
      agendaDate,
      DateUtils.dateOnly(DateTime.now()),
    );

    final destinations = _ScaffoldWithNavigationHelpers.getDestinations(
      context,
    );
    final resolvedDestinations =
        isAgenda && !isToday
            ? [
                NavigationDestination(
                  iconData: Icons.today_outlined,
                  selectedIconData: Icons.today,
                  label: context.l10n.agendaToday,
                ),
                ...destinations.skip(1),
              ]
            : destinations;

    if (formFactor == AppFormFactor.desktop) {
      final layoutConfig = ref.watch(layoutConfigProvider);
      final dividerColor = Theme.of(context).dividerColor;
      const dividerThickness = 1.0;
      final railDestinations =
          _ScaffoldWithNavigationHelpers.toRailDestinations(
            resolvedDestinations,
          );

      final isTablet = formFactor == AppFormFactor.tablet;

      return Scaffold(
        appBar: AppBar(
          titleSpacing: isTablet && isAgenda
              ? 4
              : NavigationToolbar.kMiddleSpacing,
          title: isAgenda ? const AgendaTopControls() : const SizedBox.shrink(),
          centerTitle: false,
          toolbarHeight: 76,
          actionsPadding: const EdgeInsets.only(right: 6),
          actions: isAgenda
              ? [const _AgendaAddAction()]
              : (isServices
                    ? [const _ServicesAddAction()]
                    : (isClients
                          ? [const _ClientsAddAction()]
                          : (isStaff ? [const _TeamAddAction()] : null))),
        ),
        body: Row(
          children: [
            Theme(
              data: Theme.of(context).copyWith(
                splashColor: Colors.transparent,
                highlightColor: Colors.transparent,
                hoverColor: Colors.transparent,
              ),
              child: NavigationRail(
                selectedIndex: navigationShell.currentIndex,
                onDestinationSelected: (index) => _goBranch(index, ref),
                labelType: NavigationRailLabelType.none,
                useIndicator: false, // disattiva highlight di sistema su tap
                destinations: railDestinations,
              ),
            ),
            _RailDivider(
              topInset: layoutConfig.headerHeight,
              color: dividerColor,
              thickness: dividerThickness,
            ),
            Expanded(child: navigationShell),
          ],
        ),
      );
    }

    final isTablet = formFactor == AppFormFactor.tablet;
    final showBottomDateSwitcher =
        isAgenda && formFactor != AppFormFactor.desktop;
    final bottomNavColor =
        Theme.of(context).bottomNavigationBarTheme.backgroundColor ??
        Theme.of(context).colorScheme.surface;
    return Scaffold(
      appBar: AppBar(
        toolbarHeight: isTablet ? 76 : 64,
        titleSpacing: isAgenda ? 4 : NavigationToolbar.kMiddleSpacing,
        title: isAgenda
            ? const AgendaTopControls(compact: true)
            : const SizedBox.shrink(),
        centerTitle: false,
        actionsPadding: const EdgeInsets.only(right: 6),
        actions: isAgenda
            ? (formFactor == AppFormFactor.mobile
                ? const [
                    _AgendaFilterActions(
                      padding: EdgeInsets.only(left: 8),
                    ),
                    _AgendaAddAction(compact: true),
                  ]
                : const [_AgendaAddAction(compact: true)])
            : (isServices
                  ? const [_ServicesAddAction(compact: true)]
                  : (isClients
                        ? const [_ClientsAddAction(compact: true)]
                        : (isStaff
                              ? const [_TeamAddAction(compact: true)]
                              : null))),
      ),
      body: navigationShell,
      bottomNavigationBar: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (showBottomDateSwitcher) ...[
            const AgendaHorizontalDivider(),
            Padding(
              padding: const EdgeInsets.symmetric(vertical: 8.0),
              child: const _MobileAgendaDateSwitcher(),
            ),
          ],
          ColoredBox(
            color: bottomNavColor,
            child: SafeArea(
              top: false,
              left: false,
              right: false,
              minimum: const EdgeInsets.only(bottom: 15),
              child: BottomNavigationBar(
                currentIndex: navigationShell.currentIndex,
                onTap: (index) => _goBranch(index, ref),
                type: BottomNavigationBarType.fixed,
                items: resolvedDestinations
                    .map(
                      (d) => BottomNavigationBarItem(
                        icon: Icon(d.iconData),
                        activeIcon: Icon(d.selectedIconData),
                        label: d.label,
                      ),
                    )
                    .toList(),
              ),
            ),
          ),
        ],
      ),
    );
  }

  void _goBranch(int index, WidgetRef ref) {
    if (index == 0 && navigationShell.currentIndex == 0) {
      final selectedDate = ref.read(agendaDateProvider);
      final today = DateUtils.dateOnly(DateTime.now());
      if (!DateUtils.isSameDay(selectedDate, today)) {
        ref.read(agendaDateProvider.notifier).setToday();
      }
    }
    navigationShell.goBranch(
      index,
      initialLocation: index == navigationShell.currentIndex,
    );
  }
}

class _AgendaAddAction extends ConsumerWidget {
  const _AgendaAddAction({this.compact = false});
  final bool compact;
  static const double _actionButtonHeight = 40;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final agendaDate = ref.watch(agendaDateProvider);
    final scheme = Theme.of(context).colorScheme;
    final onContainer = scheme.onSecondaryContainer;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective =
        showLabel ||
        formFactor == AppFormFactor.tablet ||
        formFactor == AppFormFactor.desktop;
    const iconOnlyWidth = 46.0;
    final bool isIconOnly = !showLabelEffective;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: AdaptiveDropdown<String>(
        modalTitle: l10n.agendaAddTitle,
        alignment: AdaptiveDropdownAlignment.right,
        verticalPosition: AdaptiveDropdownVerticalPosition.above,
        forcePopup: true,
        hideTriggerWhenOpen: true,
        popupWidth: 200,
        items: [
          AdaptiveDropdownItem(
            value: 'appointment',
            child: Text(l10n.agendaAddAppointment),
          ),
          AdaptiveDropdownItem(
            value: 'block',
            child: Text(l10n.agendaAddBlock),
          ),
        ],
        onSelected: (value) {
          if (value == 'appointment') {
            showBookingDialog(
              context,
              ref,
              date: agendaDate,
              autoOpenDatePicker: true,
            );
          } else if (value == 'block') {
            showAddBlockDialog(context, ref, date: agendaDate);
          }
        },
        child: Material(
          elevation: 0,
          color: scheme.secondaryContainer,
          shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
          clipBehavior: Clip.antiAlias,
          child: SizedBox(
            height: _actionButtonHeight,
            width: isIconOnly ? iconOnlyWidth : null,
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              child: _buildAddButtonContent(
                showLabelEffective: showLabelEffective,
                compact: compact,
                label: l10n.agendaAdd,
                onContainer: onContainer,
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class _AgendaFilterActions extends ConsumerWidget {
  const _AgendaFilterActions({
    this.padding = const EdgeInsets.symmetric(horizontal: 8),
  });

  static const double _actionButtonHeight = 40;
  static const double _iconOnlyWidth = 46;
  static const double _spacing = 8;
  final EdgeInsetsGeometry padding;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final scheme = Theme.of(context).colorScheme;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective =
        showLabel ||
        formFactor == AppFormFactor.tablet ||
        formFactor == AppFormFactor.desktop;
    final staffCount = ref.watch(staffForCurrentLocationProvider).length;
    final locations = ref.watch(locationsProvider);
    final currentLocationId = ref.watch(currentLocationIdProvider);
    final showStaffSelector = staffCount > 1;
    final showLocationSelector = locations.length > 1;

    if (!showStaffSelector && !showLocationSelector) {
      return const SizedBox.shrink();
    }

    Widget buildActionLabel(IconData icon, String label) {
      return showLabelEffective
          ? Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(icon, size: 22),
                const SizedBox(width: 8),
                Text(label),
              ],
            )
          : Icon(icon, size: 22);
    }

    return Padding(
      padding: padding,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (showStaffSelector)
            AgendaStaffFilterSelector(
              compactBuilder: (context, onPressed, tooltip) {
                return Tooltip(
                  message: tooltip,
                  child: SizedBox(
                    height: _actionButtonHeight,
                    width: showLabelEffective ? null : _iconOnlyWidth,
                    child: AppOutlinedActionButton(
                      onPressed: onPressed,
                      padding: const EdgeInsets.symmetric(
                        horizontal: 12,
                        vertical: 8,
                      ),
                      borderRadius: BorderRadius.circular(8),
                      borderColor: scheme.primary,
                      foregroundColor: scheme.primary,
                      child: buildActionLabel(
                        Icons.badge_outlined,
                        l10n.staffFilterTitle,
                      ),
                    ),
                  ),
                );
              },
            ),
          if (showStaffSelector && showLocationSelector)
            const SizedBox(width: _spacing),
          if (showLocationSelector)
            Tooltip(
              message: l10n.agendaSelectLocation,
              child: SizedBox(
                height: _actionButtonHeight,
                width: showLabelEffective ? null : _iconOnlyWidth,
                child: AppOutlinedActionButton(
                  onPressed: () => _showLocationSheet(
                    context,
                    ref,
                    locations,
                    currentLocationId,
                    l10n.agendaSelectLocation,
                  ),
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  borderRadius: BorderRadius.circular(8),
                  borderColor: scheme.primary,
                  foregroundColor: scheme.primary,
                  child: buildActionLabel(
                    Icons.place_outlined,
                    l10n.agendaSelectLocation,
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }

  Future<void> _showLocationSheet(
    BuildContext context,
    WidgetRef ref,
    List<Location> locations,
    int currentLocationId,
    String title,
  ) async {
    final result = await AppBottomSheet.show<int?>(
      context: context,
      builder: (ctx) => LocationSheetContent(
        locations: locations,
        currentLocationId: currentLocationId,
        title: title,
        onSelected: (id) => Navigator.of(ctx).pop(id),
      ),
      useRootNavigator: true,
      padding: EdgeInsets.zero,
    );

    if (result != null) {
      ref.read(currentLocationIdProvider.notifier).set(result);
    }
  }
}

class _ServicesAddAction extends ConsumerWidget {
  const _ServicesAddAction({this.compact = false});
  final bool compact;
  static const double _actionButtonHeight = 40;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final scheme = Theme.of(context).colorScheme;
    final onContainer = scheme.onSecondaryContainer;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective =
        showLabel ||
        formFactor == AppFormFactor.tablet ||
        formFactor == AppFormFactor.desktop;
    const iconOnlyWidth = 46.0;
    final bool isIconOnly = !showLabelEffective;
    Widget buildActionLabel(IconData icon, String label) {
      return showLabelEffective
          ? Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(icon, size: 22),
                const SizedBox(width: 8),
                Text(label),
              ],
            )
          : Icon(icon, size: 22);
    }

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Tooltip(
            message: l10n.reorderTitle,
            child: SizedBox(
              height: _actionButtonHeight,
              width: isIconOnly ? iconOnlyWidth : null,
              child: AppOutlinedActionButton(
                onPressed: () {
                  ref.read(servicesReorderPanelProvider.notifier).toggle();
                },
                padding: const EdgeInsets.symmetric(
                  horizontal: 12,
                  vertical: 8,
                ),
                borderRadius: BorderRadius.circular(8),
                borderColor: scheme.primary,
                foregroundColor: scheme.primary,
                child: buildActionLabel(Icons.sort, l10n.reorderTitle),
              ),
            ),
          ),
          const SizedBox(width: 8),
          AdaptiveDropdown<String>(
            modalTitle: l10n.agendaAdd,
            alignment: AdaptiveDropdownAlignment.right,
            verticalPosition: AdaptiveDropdownVerticalPosition.above,
            forcePopup: true,
            hideTriggerWhenOpen: true,
            popupWidth: 200,
            items: [
              AdaptiveDropdownItem(
                value: 'category',
                child: Text(l10n.createCategoryButtonLabel),
              ),
              AdaptiveDropdownItem(
                value: 'service',
                child: Text(l10n.servicesNewServiceMenu),
              ),
            ],
            onSelected: (value) {
              if (value == 'category') {
                showCategoryDialog(context, ref);
              } else if (value == 'service') {
                showServiceDialog(context, ref, requireCategorySelection: true);
              }
            },
            child: Material(
              elevation: 0,
              color: scheme.secondaryContainer,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
              clipBehavior: Clip.antiAlias,
              child: SizedBox(
                height: _actionButtonHeight,
                width: isIconOnly ? iconOnlyWidth : null,
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  child: _buildAddButtonContent(
                    showLabelEffective: showLabelEffective,
                    compact: compact,
                    label: l10n.agendaAdd,
                    onContainer: onContainer,
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _TeamAddAction extends ConsumerWidget {
  const _TeamAddAction({this.compact = false});
  final bool compact;
  static const double _actionButtonHeight = 40;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final scheme = Theme.of(context).colorScheme;
    final onContainer = scheme.onSecondaryContainer;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective = showLabel || formFactor != AppFormFactor.mobile;
    const iconOnlyWidth = 46.0;
    final bool isIconOnly = !showLabelEffective;
    Widget buildActionLabel(IconData icon, String label) {
      return showLabelEffective
          ? Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(icon, size: 22),
                const SizedBox(width: 8),
                Text(label),
              ],
            )
          : Icon(icon, size: 22);
    }

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Tooltip(
            message: l10n.staffHubAvailabilityTitle,
            child: SizedBox(
              height: _actionButtonHeight,
              width: isIconOnly ? iconOnlyWidth : null,
              child: AppOutlinedActionButton(
                onPressed: () => context.pushNamed('staff-availability'),
                padding: const EdgeInsets.symmetric(
                  horizontal: 12,
                  vertical: 8,
                ),
                borderRadius: BorderRadius.circular(8),
                borderColor: scheme.primary,
                foregroundColor: scheme.primary,
                child: buildActionLabel(
                  Icons.schedule_outlined,
                  l10n.staffHubAvailabilityTitle,
                ),
              ),
            ),
          ),
          const SizedBox(width: 8),
          Tooltip(
            message: l10n.reorderTitle,
            child: SizedBox(
              height: _actionButtonHeight,
              width: isIconOnly ? iconOnlyWidth : null,
              child: AppOutlinedActionButton(
                onPressed: () {
                  ref.read(teamReorderPanelProvider.notifier).toggle();
                },
                padding: const EdgeInsets.symmetric(
                  horizontal: 12,
                  vertical: 8,
                ),
                borderRadius: BorderRadius.circular(8),
                borderColor: scheme.primary,
                foregroundColor: scheme.primary,
                child: buildActionLabel(Icons.sort, l10n.reorderTitle),
              ),
            ),
          ),
          const SizedBox(width: 8),
          AdaptiveDropdown<String>(
            modalTitle: l10n.agendaAdd,
            alignment: AdaptiveDropdownAlignment.right,
            verticalPosition: AdaptiveDropdownVerticalPosition.above,
            forcePopup: true,
            hideTriggerWhenOpen: true,
            popupWidth: 220,
            items: [
              AdaptiveDropdownItem(
                value: 'location',
                child: Text(l10n.teamNewLocationTitle),
              ),
              AdaptiveDropdownItem(
                value: 'staff',
                child: Text(l10n.teamNewStaffTitle),
              ),
            ],
            onSelected: (value) {
              if (value == 'location') {
                showLocationDialog(context, ref);
              } else if (value == 'staff') {
                showStaffDialog(context, ref);
              }
            },
            child: Material(
              elevation: 0,
              color: scheme.secondaryContainer,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
              clipBehavior: Clip.antiAlias,
              child: SizedBox(
                height: _actionButtonHeight,
                width: isIconOnly ? iconOnlyWidth : null,
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  child: _buildAddButtonContent(
                    showLabelEffective: showLabelEffective,
                    compact: compact,
                    label: l10n.agendaAdd,
                    onContainer: onContainer,
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class _ClientsAddAction extends ConsumerWidget {
  const _ClientsAddAction({this.compact = false});
  final bool compact;
  static const double _actionButtonHeight = 40;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final showLabel = layoutConfig.showTopbarAddLabel;
    final showLabelEffective = showLabel || formFactor != AppFormFactor.mobile;
    const iconOnlyWidth = 46.0;
    final bool isIconOnly = !showLabelEffective;
    if (compact) {
      return Padding(
        padding: const EdgeInsets.symmetric(horizontal: 8),
        child: GestureDetector(
          onTap: () async {
            await showClientEditDialog(context, ref);
          },
          child: Builder(
            builder: (buttonContext) {
              final scheme = Theme.of(buttonContext).colorScheme;
              final onContainer = scheme.onSecondaryContainer;
              return Material(
                elevation: 0,
                color: scheme.secondaryContainer,
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                ),
                clipBehavior: Clip.antiAlias,
                child: SizedBox(
                  height: _actionButtonHeight,
                  width: isIconOnly ? iconOnlyWidth : null,
                  child: Padding(
                    padding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 8,
                    ),
                    child: _buildAddButtonContent(
                      showLabelEffective: showLabelEffective,
                      compact: compact,
                      label: l10n.agendaAdd,
                      onContainer: onContainer,
                    ),
                  ),
                ),
              );
            },
          ),
        ),
      );
    }
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8),
      child: GestureDetector(
        onTap: () async {
          await showClientEditDialog(context, ref);
        },
        child: Builder(
          builder: (buttonContext) {
            final scheme = Theme.of(buttonContext).colorScheme;
            final onContainer = scheme.onSecondaryContainer;
            return Material(
              elevation: 0,
              color: scheme.secondaryContainer,
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
              clipBehavior: Clip.antiAlias,
              child: SizedBox(
                height: _actionButtonHeight,
                width: isIconOnly ? iconOnlyWidth : null,
                child: Padding(
                  padding: const EdgeInsets.fromLTRB(12, 8, 28, 8),
                  child: _buildAddButtonContent(
                    showLabelEffective: showLabelEffective,
                    compact: compact,
                    label: l10n.agendaAdd,
                    onContainer: onContainer,
                  ),
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}

class _MobileAgendaDateSwitcher extends ConsumerWidget {
  const _MobileAgendaDateSwitcher();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final agendaDate = ref.watch(agendaDateProvider);
    final dateController = ref.read(agendaDateProvider.notifier);
    final localeTag = Localizations.localeOf(context).toLanguageTag();
    final label = DateFormat('EEE d MMM', localeTag).format(agendaDate);

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: AgendaDateSwitcher(
        label: label,
        selectedDate: agendaDate,
        onPrevious: dateController.previousDay,
        onNext: dateController.nextDay,
        onPreviousWeek: dateController.previousWeek,
        onNextWeek: dateController.nextWeek,
        onPreviousMonth: dateController.previousMonth,
        onNextMonth: dateController.nextMonth,
        onSelectDate: (date) {
          dateController.set(DateUtils.dateOnly(date));
        },
        isCompact: true,
      ),
    );
  }
}


class _ScaffoldWithNavigationHelpers {
  static List<NavigationDestination> getDestinations(BuildContext context) {
    final l10n = context.l10n;
    return [
      NavigationDestination(
        iconData: Icons.calendar_month_outlined,
        selectedIconData: Icons.calendar_month,
        label: l10n.navAgenda,
      ),
      NavigationDestination(
        iconData: Icons.people_outline,
        selectedIconData: Icons.people,
        label: l10n.navClients,
      ),
      NavigationDestination(
        iconData: Icons.category_outlined,
        selectedIconData: Icons.cut,
        label: l10n.navServices,
      ),
      NavigationDestination(
        iconData: Icons.badge_outlined,
        selectedIconData: Icons.badge,
        label: l10n.navStaff,
      ),
    ];
  }

  static List<NavigationRailDestination> toRailDestinations(
    List<NavigationDestination> destinations,
  ) {
    return destinations
        .map(
          (d) => NavigationRailDestination(
            icon: _NavIcon(icon: d.iconData, label: d.label),
            selectedIcon: _NavIcon(
              icon: d.selectedIconData,
              label: d.label,
              selected: true,
            ),
            label: Text(d.label),
          ),
        )
        .toList();
  }
}

class _RailDivider extends StatelessWidget {
  const _RailDivider({
    required this.topInset,
    required this.color,
    required this.thickness,
  });

  final double topInset;
  final Color color;
  final double thickness;

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: thickness,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final availableHeight = constraints.maxHeight;
          final inset = topInset.clamp(0.0, availableHeight);

          return Column(
            children: [
              SizedBox(height: inset),
              Expanded(child: Container(color: color)),
            ],
          );
        },
      ),
    );
  }
}

class _NavIcon extends StatefulWidget {
  const _NavIcon({
    required this.icon,
    required this.label,
    this.selected = false,
  });

  final IconData icon;
  final String label;
  final bool selected;

  @override
  State<_NavIcon> createState() => _NavIconState();
}

class _NavIconState extends State<_NavIcon> {
  static const double _size = 52;
  static const double _iconSize = 24;

  bool _hovering = false;

  void _handleHover(bool hovering) {
    if (_hovering == hovering) return;
    setState(() => _hovering = hovering);
  }

  @override
  Widget build(BuildContext context) {
    final scheme = Theme.of(context).colorScheme;

    final iconColor = scheme.onSecondary.withOpacity(
      widget.selected ? 0.95 : 0.7,
    );

    final labelColor = scheme.onSecondary.withOpacity(
      widget.selected ? 0.95 : 0.65,
    );

    Color backgroundColor = Colors.transparent;

    if (widget.selected || _hovering) {
      // effetto "selected" o "hover": fill leggero
      backgroundColor = scheme.onSecondary.withOpacity(
        widget.selected ? 0.11 : 0.08,
      );
    }

    final baseTheme = Theme.of(context);

    return MouseRegion(
      onEnter: (_) => _handleHover(true),
      onExit: (_) => _handleHover(false),
      child: Theme(
        // disattiva splash / highlight di sistema su tap/long-press
        data: baseTheme.copyWith(
          splashColor: Colors.transparent,
          highlightColor: Colors.transparent,
          hoverColor: Colors.transparent,
        ),
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          curve: Curves.easeInOut,
          width: _size,
          height: _size + 16, // Altezza extra per la label
          decoration: BoxDecoration(
            color: backgroundColor,
            borderRadius: BorderRadius.circular(16),
          ),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(widget.icon, color: iconColor, size: _iconSize),
              const SizedBox(height: 2),
              Text(
                widget.label,
                style: TextStyle(
                  color: labelColor,
                  fontSize: 10,
                  fontWeight: widget.selected
                      ? FontWeight.w600
                      : FontWeight.w500,
                ),
                maxLines: 1,
                overflow: TextOverflow.ellipsis,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class NavigationDestination {
  const NavigationDestination({
    required this.iconData,
    required this.selectedIconData,
    required this.label,
  });
  final IconData iconData;
  final IconData selectedIconData;
  final String label;
}
--- FILE: lib/app/providers/form_factor_provider.dart ---
import 'dart:ui' as ui;

import 'package:flutter/widgets.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'form_factor_provider.g.dart';

// Definiamo i tre layout che ci interessano
enum AppFormFactor { mobile, tablet, desktop }

AppFormFactor _formFactorForWidth(double width) {
  if (width >= 1024) return AppFormFactor.desktop;
  if (width >= 600) return AppFormFactor.tablet;
  return AppFormFactor.mobile;
}

@riverpod
class FormFactorNotifier extends _$FormFactorNotifier {
  @override
  AppFormFactor build() {
    final binding = WidgetsFlutterBinding.ensureInitialized();
    final dispatcher = binding.platformDispatcher;
    final ui.FlutterView? view = dispatcher.views.isNotEmpty
        ? dispatcher.views.first
        : dispatcher.implicitView;

    if (view != null) {
      final logicalSize = view.physicalSize / view.devicePixelRatio;
      return _formFactorForWidth(logicalSize.width);
    }

    return AppFormFactor.mobile;
  }

  /// Aggiorna il form factor in base alla larghezza dello schermo.
  /// Usa lo stesso breakpoint di 600px che usi nel resto dell'app.
  void update(double screenWidth) {
    final newFactor = _formFactorForWidth(screenWidth);

    // Aggiorna lo stato solo se il form factor cambia
    if (state != newFactor) {
      state = newFactor;
    }
  }
}
--- FILE: lib/app/providers/form_factor_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'form_factor_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(FormFactorNotifier)
const formFactorProvider = FormFactorNotifierProvider._();

final class FormFactorNotifierProvider
    extends $NotifierProvider<FormFactorNotifier, AppFormFactor> {
  const FormFactorNotifierProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'formFactorProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$formFactorNotifierHash();

  @$internal
  @override
  FormFactorNotifier create() => FormFactorNotifier();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AppFormFactor value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AppFormFactor>(value),
    );
  }
}

String _$formFactorNotifierHash() =>
    r'c2d345138b8b938ff84a110cd4b6bf3dda7a605e';

abstract class _$FormFactorNotifier extends $Notifier<AppFormFactor> {
  AppFormFactor build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<AppFormFactor, AppFormFactor>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AppFormFactor, AppFormFactor>,
              AppFormFactor,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/app/theme/extensions.dart ---
import 'package:flutter/material.dart';

class AppInteractionColors extends ThemeExtension<AppInteractionColors> {
  const AppInteractionColors({
    required this.hoverFill,
    required this.pressedFill,
    required this.alternatingRowFill,
  });

  final Color hoverFill;
  final Color pressedFill;

  /// Colore di sfondo per righe alternate (es. liste, tabelle)
  final Color alternatingRowFill;

  @override
  AppInteractionColors copyWith({
    Color? hoverFill,
    Color? pressedFill,
    Color? alternatingRowFill,
  }) {
    return AppInteractionColors(
      hoverFill: hoverFill ?? this.hoverFill,
      pressedFill: pressedFill ?? this.pressedFill,
      alternatingRowFill: alternatingRowFill ?? this.alternatingRowFill,
    );
  }

  @override
  AppInteractionColors lerp(AppInteractionColors? other, double t) {
    if (other == null) return this;
    return AppInteractionColors(
      hoverFill: Color.lerp(hoverFill, other.hoverFill, t) ?? hoverFill,
      pressedFill: Color.lerp(pressedFill, other.pressedFill, t) ?? pressedFill,
      alternatingRowFill:
          Color.lerp(alternatingRowFill, other.alternatingRowFill, t) ??
          alternatingRowFill,
    );
  }

  @override
  int get hashCode => Object.hash(hoverFill, pressedFill, alternatingRowFill);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is AppInteractionColors &&
        other.hoverFill == hoverFill &&
        other.pressedFill == pressedFill &&
        other.alternatingRowFill == alternatingRowFill;
  }
}
--- FILE: lib/app/theme/app_spacing.dart ---
/// Costanti di spacing configurabili a livello applicativo.
/// Modifica questi valori per cambiare lo spacing in tutta l'app.
abstract class AppSpacing {
  AppSpacing._();
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // General spacing
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Spacing piccolo generico.
  static const double small = 8.0;

  /// Spacing medio generico.
  static const double medium = 12.0;

  /// Spacing grande generico.
  static const double large = 24.0;

  /// Spacing extra large generico.
  static const double xLarge = 60.0;

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Form spacing
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  /// Spacing verticale tra la prima riga dei form e il titolo.
  static const double formFirstRowSpacing = large;

  /// Spacing verticale tra le righe dei form (es. tra data/ora e servizio).
  static const double formRowSpacing = xLarge;

  /// Spacing orizzontale tra i campi sulla stessa riga (es. tra data e ora).
  static const double formFieldSpacing = medium;

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Bottom sheet spacing
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Spacing tra il contenuto del form e i pulsanti azioni.
  static const double formToActionsSpacing = xLarge;

  /// Spacing tra i pulsanti azioni.
  static const double actionButtonSpacing = small;
}
--- FILE: lib/app/theme/theme_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'theme.dart';
import 'theme_config.dart';

/// üîπ Notifier moderno per gestire il tema dinamico
class ThemeNotifier extends Notifier<AppThemeConfig> {
  @override
  AppThemeConfig build() => const AppThemeConfig(
    seedColor: colorPrimary1,
    brightness: Brightness.light,
  );

  /// Cambia il colore principale (seed color)
  void updateSeed(Color color) {
    state = state.copyWith(seedColor: color);
  }

  /// Inverte la modalit√† chiara/scura
  void toggleBrightness() {
    if (state.brightness != Brightness.light) {
      state = state.copyWith(brightness: Brightness.light);
    }
  }
}

/// üîπ Provider globale per il tema (versione Notifier)
final themeNotifierProvider = NotifierProvider<ThemeNotifier, AppThemeConfig>(
  ThemeNotifier.new,
);
--- FILE: lib/app/theme/theme_config.dart ---
import 'package:flutter/material.dart';

class AppThemeConfig {
  final Color seedColor;
  final Brightness brightness;

  const AppThemeConfig({
    required this.seedColor,
    this.brightness = Brightness.dark,
  });

  AppThemeConfig copyWith({Color? seedColor, Brightness? brightness}) {
    return AppThemeConfig(
      seedColor: seedColor ?? this.seedColor,
      brightness: brightness ?? this.brightness,
    );
  }
}
--- FILE: lib/app/theme/theme.dart ---
import 'package:flutter/material.dart';

import 'extensions.dart';
import 'theme_config.dart';

const colorPrimary1 = Color(0xFF141414); // colore base scuro
const colorPrimary2 = Color(0xFFFEFEFE); // colore contrasto chiaro

/// Crea un tema coerente partendo dal seed definito in [AppThemeConfig].
ThemeData buildTheme(AppThemeConfig _, Brightness brightness) {
  final isDark = brightness == Brightness.dark;

  //const colorPrimary3 = Color(0xFFE5B24F); // accento caldo

  final background = isDark ? colorPrimary1 : colorPrimary2;
  final surface = background;
  final primary = colorPrimary1;
  final onPrimary = colorPrimary2;
  final onBackground = isDark ? colorPrimary2 : colorPrimary1;

  final colorScheme = ColorScheme(
    brightness: brightness,
    primary: primary,
    onPrimary: onPrimary,
    secondary: primary,
    onSecondary: onPrimary,
    error: Colors.red,
    onError: colorPrimary2,
    background: background,
    onBackground: onBackground,
    surface: surface,
    onSurface: onBackground,
  );

  final base = ThemeData(
    useMaterial3: true,
    colorScheme: colorScheme,
    brightness: brightness,
    scaffoldBackgroundColor: background,
    canvasColor: surface,
  );

  final titleStyle =
      base.textTheme.titleLarge ??
      const TextStyle(fontSize: 18, fontWeight: FontWeight.w600);

  final hoverFill = isDark
      ? colorPrimary2.withOpacity(0.12)
      : colorPrimary1.withOpacity(0.01);
  final pressedFill = isDark
      ? colorPrimary2.withOpacity(0.18)
      : colorPrimary1.withOpacity(0.1);
  final alternatingRowFill = isDark
      ? colorPrimary2.withOpacity(0.05)
      : colorPrimary1.withOpacity(0.03);

  final themeWithPalette = base.copyWith(
    appBarTheme: AppBarTheme(
      backgroundColor: colorPrimary2,
      foregroundColor: colorPrimary1,
      centerTitle: true,
      surfaceTintColor: Colors.transparent,
      elevation: 0,
      iconTheme: const IconThemeData(color: colorPrimary1),
      titleTextStyle: titleStyle.copyWith(color: colorPrimary1),
    ),
    cardTheme: CardThemeData(
      color: surface,
      surfaceTintColor: Colors.transparent,
      elevation: 0,
      margin: const EdgeInsets.all(8),
      shape: RoundedRectangleBorder(
        borderRadius: const BorderRadius.all(Radius.circular(12)),
        side: BorderSide(color: onBackground.withOpacity(0.1), width: 0.5),
      ),
    ),
    textTheme: base.textTheme.apply(
      bodyColor: onBackground,
      displayColor: onBackground,
    ),
    iconTheme: IconThemeData(color: onBackground),
    dividerColor: onBackground.withOpacity(0.12),
    floatingActionButtonTheme: FloatingActionButtonThemeData(
      backgroundColor: primary,
      foregroundColor: onPrimary,
    ),
    navigationRailTheme: NavigationRailThemeData(
      backgroundColor: colorPrimary1,
      selectedIconTheme: const IconThemeData(color: colorPrimary2, size: 32),
      unselectedIconTheme: const IconThemeData(color: colorPrimary2, size: 32),
      selectedLabelTextStyle: const TextStyle(
        color: colorPrimary2,
        fontWeight: FontWeight.w600,
      ),
      unselectedLabelTextStyle: const TextStyle(color: colorPrimary2),
      minWidth: 80,
      indicatorColor: Colors.transparent,
    ),
    bottomNavigationBarTheme: BottomNavigationBarThemeData(
      backgroundColor: colorPrimary1,
      selectedItemColor: colorPrimary2,
      unselectedItemColor: colorPrimary2.withOpacity(0.5),
      selectedIconTheme: const IconThemeData(color: colorPrimary2, size: 26),
      unselectedIconTheme: IconThemeData(color: colorPrimary2.withOpacity(0.5)),
      selectedLabelStyle: const TextStyle(
        fontWeight: FontWeight.w600,
        fontSize: 12,
      ),
      unselectedLabelStyle: const TextStyle(
        fontWeight: FontWeight.w400,
        fontSize: 11,
      ),
      showUnselectedLabels: true,
      type: BottomNavigationBarType.fixed,
    ),
    // Colori ON globali per Switch/Radio in linea con il primary dell'app
    switchTheme: base.switchTheme.copyWith(
      overlayColor: MaterialStateProperty.all(Colors.transparent),
      thumbColor: MaterialStateProperty.resolveWith(
        (states) => states.contains(MaterialState.selected)
            ? colorScheme.primary
            : null,
      ),
      trackColor: MaterialStateProperty.resolveWith(
        (states) => states.contains(MaterialState.selected)
            ? colorScheme.primary.withOpacity(0.35)
            : null,
      ),
    ),
    radioTheme: base.radioTheme.copyWith(
      overlayColor: MaterialStateProperty.all(Colors.transparent),
      fillColor: MaterialStateProperty.resolveWith(
        (states) => states.contains(MaterialState.selected)
            ? colorScheme.primary
            : null,
      ),
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        backgroundColor: primary,
        foregroundColor: onPrimary,
        textStyle: const TextStyle(fontWeight: FontWeight.w600),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(10)),
      ),
    ),
  );

  return themeWithPalette.copyWith(
    extensions: <ThemeExtension<dynamic>>[
      AppInteractionColors(
        hoverFill: hoverFill,
        pressedFill: pressedFill,
        alternatingRowFill: alternatingRowFill,
      ),
    ],
  );
}
--- FILE: lib/app/app.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/l10n/l10_extension.dart';
import '/core/l10n/l10n.dart';
// 1. Importa il listener dalla sua nuova posizione (se non l'hai gi√† spostato)
// Assicurati che il percorso sia corretto.
import '../core/widgets/layout_config_auto_listener.dart';
import 'router.dart';
import 'theme/theme.dart';
import 'theme/theme_provider.dart';

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeConfig = ref.watch(themeNotifierProvider);
    return MaterialApp.router(
      debugShowCheckedModeBanner: false,
      title: 'Agenda Platform',
      routerConfig: appRouter,
      themeMode: ThemeMode.light,
      theme: buildTheme(themeConfig, Brightness.light),
      localizationsDelegates: const [
        L10n.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: L10n.delegate.supportedLocales,
      locale: const Locale('it'),

      // 2. SPOSTA IL LISTENER QUI
      builder: (context, child) {
        final localizedTitle = context.l10n.appTitle;
        return Title(
          title: localizedTitle,
          color: Theme.of(context).scaffoldBackgroundColor,
          // Questo widget ora aggiorner√† i provider globali
          // prima che qualsiasi schermata venga costruita.
          child: LayoutConfigAutoListener(
            child: child ?? const SizedBox.shrink(),
          ),
        );
      },
    );
  }
}
--- FILE: lib/app/widgets/agenda_staff_filter_selector.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/extensions.dart';
import 'package:agenda_backend/app/widgets/agenda_control_components.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/staff.dart';
import 'package:agenda_backend/core/widgets/app_dividers.dart';
import 'package:agenda_backend/core/widgets/desktop_popup_container.dart';
import 'package:agenda_backend/features/agenda/domain/staff_filter_mode.dart';
import 'package:agenda_backend/features/agenda/providers/staff_filter_providers.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Selector per filtrare lo staff visualizzato nell'agenda.
/// [isCompact] = true: solo icona (mobile/tablet)
/// [isCompact] = false: pill con icona + label + freccia (desktop)
class AgendaStaffFilterSelector extends ConsumerStatefulWidget {
  const AgendaStaffFilterSelector({
    super.key,
    this.isCompact = true,
    this.compactBuilder,
  });

  final bool isCompact;
  final Widget Function(
    BuildContext context,
    VoidCallback onPressed,
    String tooltip,
  )?
  compactBuilder;

  @override
  ConsumerState<AgendaStaffFilterSelector> createState() =>
      _AgendaStaffFilterSelectorState();
}

class _AgendaStaffFilterSelectorState
    extends ConsumerState<AgendaStaffFilterSelector> {
  bool _isHovered = false;
  final LayerLink _layerLink = LayerLink();
  OverlayEntry? _overlayEntry;
  bool _isOpen = false;

  @override
  void dispose() {
    _removeOverlay();
    super.dispose();
  }

  void _removeOverlay() {
    _overlayEntry?.remove();
    _overlayEntry = null;
    if (_isOpen) {
      _isOpen = false;
      setState(() => _isHovered = false);
    }
  }

  void _handleTap() {
    final formFactor = ref.read(formFactorProvider);

    if (formFactor == AppFormFactor.desktop) {
      _showDesktopPopup();
    } else {
      _showMobileSheet(context);
    }
  }

  void _showDesktopPopup() {
    if (_overlayEntry != null) {
      _removeOverlay();
      return;
    }

    setState(() => _isHovered = true);
    _isOpen = true;

    final renderBox = context.findRenderObject() as RenderBox;
    final triggerSize = renderBox.size;

    _overlayEntry = OverlayEntry(
      builder: (overlayContext) => DesktopPopupContainer(
        link: _layerLink,
        triggerWidth: triggerSize.width,
        triggerHeight: triggerSize.height,
        popupWidth: 280,
        maxHeight: 400,
        onDismiss: _removeOverlay,
        child: _StaffFilterPopupContent(onDismiss: _removeOverlay),
      ),
    );

    Overlay.of(context).insert(_overlayEntry!);
  }

  Future<void> _showMobileSheet(BuildContext context) async {
    setState(() => _isHovered = true);
    await showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      useRootNavigator: true,
      builder: (_) => const _StaffFilterSheet(),
    );
    setState(() => _isHovered = false);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final formFactor = ref.watch(formFactorProvider);
    if (widget.isCompact) {
      Future<void> onPressed() => _showMobileSheet(context);
      if (widget.compactBuilder != null) {
        return widget.compactBuilder!(
          context,
          onPressed,
          l10n.staffFilterTooltip,
        );
      }
      return IconButton(
        tooltip: l10n.staffFilterTooltip,
        icon: const Icon(Icons.badge_outlined),
        iconSize: formFactor == AppFormFactor.mobile ? 22 : 33,
        onPressed: onPressed,
      );
    }

    // Desktop mode: pill style like AgendaLocationSelector
    final colorScheme = Theme.of(context).colorScheme;
    final interactions = Theme.of(context).extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = _isHovered
        ? Color.alphaBlend(hoverFill, colorScheme.surface)
        : colorScheme.surface;

    final mode = ref.watch(staffFilterModeProvider);
    final label = _getModeLabel(l10n, mode);

    return CompositedTransformTarget(
      link: _layerLink,
      child: MouseRegion(
        onEnter: (_) {
          if (!_isHovered && !_isOpen) setState(() => _isHovered = true);
        },
        onExit: (_) {
          if (_isHovered && !_isOpen) setState(() => _isHovered = false);
        },
        child: GestureDetector(
          onTap: _handleTap,
          child: Semantics(
            button: true,
            label: l10n.staffFilterTooltip,
            child: ClipRRect(
              borderRadius: kAgendaPillRadius,
              child: Container(
                height: kAgendaControlHeight,
                decoration: BoxDecoration(
                  borderRadius: kAgendaPillRadius,
                  border: Border.all(color: Colors.grey.withOpacity(0.35)),
                  color: backgroundColor,
                ),
                child: Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: kAgendaControlHorizontalPadding,
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Flexible(
                        child: Text(label, overflow: TextOverflow.ellipsis),
                      ),
                      const SizedBox(width: 8),
                      const Icon(Icons.keyboard_arrow_down_rounded, size: 20),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  String _getModeLabel(dynamic l10n, StaffFilterMode mode) {
    switch (mode) {
      case StaffFilterMode.allTeam:
        return l10n.staffFilterAllTeam;
      case StaffFilterMode.onDutyTeam:
        return l10n.staffFilterOnDuty;
      case StaffFilterMode.custom:
        final selectedIds = ref.read(selectedStaffIdsProvider);
        final count = selectedIds.length;
        if (count == 0) return l10n.staffFilterAllTeam;
        return '$count';
    }
  }
}

/// Content widget for the staff filter desktop popup.
class _StaffFilterPopupContent extends ConsumerWidget {
  const _StaffFilterPopupContent({required this.onDismiss});

  final VoidCallback onDismiss;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final mode = ref.watch(staffFilterModeProvider);
    final allStaff = ref.watch(staffForCurrentLocationProvider);
    final selectedIds = ref.watch(selectedStaffIdsProvider);
    final onDutyIds = ref.watch(onDutyStaffIdsProvider);

    return SingleChildScrollView(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Padding(
            padding: const EdgeInsets.fromLTRB(12, 10, 12, 6),
            child: Text(
              l10n.staffFilterTitle,
              style: theme.textTheme.labelMedium?.copyWith(
                color: colorScheme.onSurfaceVariant,
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          const AppBottomSheetDivider(),

          // Opzione: Tutto il team
          _DesktopFilterOptionTile(
            title: l10n.staffFilterAllTeam,
            isSelected: mode == StaffFilterMode.allTeam,
            onTap: () {
              ref
                  .read(staffFilterModeProvider.notifier)
                  .set(StaffFilterMode.allTeam);
              onDismiss();
            },
          ),

          // Opzione: Team di turno
          _DesktopFilterOptionTile(
            title: l10n.staffFilterOnDuty,
            isSelected: mode == StaffFilterMode.onDutyTeam,
            onTap: () {
              ref
                  .read(staffFilterModeProvider.notifier)
                  .set(StaffFilterMode.onDutyTeam);
              onDismiss();
            },
          ),

          // Divider
          const AppBottomSheetDivider(),

          // Header staff
          Padding(
            padding: const EdgeInsets.fromLTRB(12, 8, 12, 4),
            child: Text(
              l10n.staffFilterSelectMembers,
              style: theme.textTheme.bodySmall?.copyWith(
                color: colorScheme.onSurfaceVariant,
              ),
            ),
          ),

          // Lista staff con checkbox
          for (final staff in allStaff)
            _DesktopStaffMemberTile(
              staff: staff,
              isSelected: _isStaffSelected(
                mode,
                selectedIds,
                onDutyIds,
                staff.id,
              ),
              onChanged: (selected) {
                if (mode != StaffFilterMode.custom) {
                  final ids = mode == StaffFilterMode.onDutyTeam
                      ? onDutyIds.toList()
                      : allStaff.map((s) => s.id).toList();
                  ref.read(selectedStaffIdsProvider.notifier).setFromList(ids);
                  ref
                      .read(staffFilterModeProvider.notifier)
                      .set(StaffFilterMode.custom);
                }
                ref.read(selectedStaffIdsProvider.notifier).toggle(staff.id);
              },
            ),

          const SizedBox(height: 8),
        ],
      ),
    );
  }

  bool _isStaffSelected(
    StaffFilterMode mode,
    Set<int> selectedIds,
    Set<int> onDutyIds,
    int staffId,
  ) {
    switch (mode) {
      case StaffFilterMode.allTeam:
        return true;
      case StaffFilterMode.onDutyTeam:
        return onDutyIds.contains(staffId);
      case StaffFilterMode.custom:
        return selectedIds.contains(staffId);
    }
  }
}

class _DesktopFilterOptionTile extends StatefulWidget {
  const _DesktopFilterOptionTile({
    required this.title,
    required this.isSelected,
    required this.onTap,
  });

  final String title;
  final bool isSelected;
  final VoidCallback onTap;

  @override
  State<_DesktopFilterOptionTile> createState() =>
      _DesktopFilterOptionTileState();
}

class _DesktopFilterOptionTileState extends State<_DesktopFilterOptionTile> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      cursor: SystemMouseCursors.click,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: widget.onTap,
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 100),
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
          color: widget.isSelected
              ? colorScheme.primary.withOpacity(0.08)
              : _isHovered
              ? colorScheme.primary.withOpacity(0.04)
              : Colors.transparent,
          child: Row(
            children: [
              Icon(
                widget.isSelected
                    ? Icons.radio_button_checked
                    : Icons.radio_button_unchecked,
                color: widget.isSelected ? colorScheme.primary : null,
                size: 20,
              ),
              const SizedBox(width: 12),
              Expanded(
                child: Text(
                  widget.title,
                  style: TextStyle(
                    fontWeight: widget.isSelected
                        ? FontWeight.w600
                        : FontWeight.normal,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _DesktopStaffMemberTile extends StatefulWidget {
  const _DesktopStaffMemberTile({
    required this.staff,
    required this.isSelected,
    required this.onChanged,
  });

  final Staff staff;
  final bool isSelected;
  final ValueChanged<bool> onChanged;

  @override
  State<_DesktopStaffMemberTile> createState() =>
      _DesktopStaffMemberTileState();
}

class _DesktopStaffMemberTileState extends State<_DesktopStaffMemberTile> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;

    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      cursor: SystemMouseCursors.click,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: () => widget.onChanged(!widget.isSelected),
        child: AnimatedContainer(
          duration: const Duration(milliseconds: 100),
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
          color: _isHovered
              ? colorScheme.primary.withOpacity(0.04)
              : Colors.transparent,
          child: Row(
            children: [
              StaffCircleAvatar(
                height: 28,
                color: widget.staff.color,
                isHighlighted: widget.isSelected,
                initials: widget.staff.initials,
              ),
              const SizedBox(width: 12),
              Expanded(child: Text(widget.staff.displayName)),
              Checkbox(
                value: widget.isSelected,
                onChanged: (value) => widget.onChanged(value ?? false),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// Mobile/tablet bottom sheet for staff filter.
class _StaffFilterSheet extends ConsumerWidget {
  const _StaffFilterSheet();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final mode = ref.watch(staffFilterModeProvider);
    final allStaff = ref.watch(staffForCurrentLocationProvider);
    final selectedIds = ref.watch(selectedStaffIdsProvider);
    final onDutyIds = ref.watch(onDutyStaffIdsProvider);

    return SafeArea(
      child: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Handle
            const SizedBox(height: 8),
            Center(
              child: Container(
                width: 40,
                height: 4,
                decoration: BoxDecoration(
                  color: Colors.grey.shade300,
                  borderRadius: BorderRadius.circular(4),
                ),
              ),
            ),
            const SizedBox(height: 12),

            // Header
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 8, 16, 8),
              child: Text(
                l10n.staffFilterTitle,
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
            const AppBottomSheetDivider(),

            // Opzione: Tutto il team
            _MobileFilterOptionTile(
              title: l10n.staffFilterAllTeam,
              isSelected: mode == StaffFilterMode.allTeam,
              onTap: () {
                ref
                    .read(staffFilterModeProvider.notifier)
                    .set(StaffFilterMode.allTeam);
                Navigator.of(context).pop();
              },
            ),

            // Opzione: Team di turno
            _MobileFilterOptionTile(
              title: l10n.staffFilterOnDuty,
              isSelected: mode == StaffFilterMode.onDutyTeam,
              onTap: () {
                ref
                    .read(staffFilterModeProvider.notifier)
                    .set(StaffFilterMode.onDutyTeam);
                Navigator.of(context).pop();
              },
            ),

            // Divider
            const AppBottomSheetDivider(),

            // Header staff
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 12, 16, 4),
              child: Text(
                l10n.staffFilterSelectMembers,
                style: theme.textTheme.bodySmall?.copyWith(
                  color: theme.colorScheme.onSurfaceVariant,
                ),
              ),
            ),

            // Lista staff con checkbox
            for (final staff in allStaff)
              _MobileStaffMemberTile(
                staff: staff,
                isSelected: _isStaffSelected(
                  mode,
                  selectedIds,
                  onDutyIds,
                  staff.id,
                ),
                onChanged: (selected) {
                  if (mode != StaffFilterMode.custom) {
                    final ids = mode == StaffFilterMode.onDutyTeam
                        ? onDutyIds.toList()
                        : allStaff.map((s) => s.id).toList();
                    ref
                        .read(selectedStaffIdsProvider.notifier)
                        .setFromList(ids);
                    ref
                        .read(staffFilterModeProvider.notifier)
                        .set(StaffFilterMode.custom);
                  }
                  ref.read(selectedStaffIdsProvider.notifier).toggle(staff.id);
                },
              ),

            const SizedBox(height: 16),
          ],
        ),
      ),
    );
  }

  bool _isStaffSelected(
    StaffFilterMode mode,
    Set<int> selectedIds,
    Set<int> onDutyIds,
    int staffId,
  ) {
    switch (mode) {
      case StaffFilterMode.allTeam:
        return true;
      case StaffFilterMode.onDutyTeam:
        return onDutyIds.contains(staffId);
      case StaffFilterMode.custom:
        return selectedIds.contains(staffId);
    }
  }
}

class _MobileFilterOptionTile extends StatelessWidget {
  const _MobileFilterOptionTile({
    required this.title,
    required this.isSelected,
    required this.onTap,
  });

  final String title;
  final bool isSelected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return ListTile(
      title: Text(title),
      leading: Icon(
        isSelected ? Icons.radio_button_checked : Icons.radio_button_unchecked,
        color: isSelected ? theme.colorScheme.primary : null,
      ),
      onTap: onTap,
    );
  }
}

class _MobileStaffMemberTile extends StatelessWidget {
  const _MobileStaffMemberTile({
    required this.staff,
    required this.isSelected,
    required this.onChanged,
  });

  final Staff staff;
  final bool isSelected;
  final ValueChanged<bool> onChanged;

  @override
  Widget build(BuildContext context) {
    return ListTile(
      leading: StaffCircleAvatar(
        height: 32,
        color: staff.color,
        isHighlighted: isSelected,
        initials: staff.initials,
      ),
      title: Text(staff.displayName),
      trailing: Checkbox(
        value: isSelected,
        onChanged: (value) => onChanged(value ?? false),
      ),
      onTap: () => onChanged(!isSelected),
    );
  }
}
--- FILE: lib/app/widgets/top_controls.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/widgets/agenda_control_components.dart';
import 'package:agenda_backend/app/widgets/agenda_staff_filter_selector.dart';
import 'package:agenda_backend/app/widgets/top_controls_scaffold.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/location.dart';
import 'package:agenda_backend/core/widgets/app_dividers.dart';
import 'package:agenda_backend/core/widgets/no_scrollbar_behavior.dart';
import 'package:agenda_backend/features/agenda/providers/layout_config_provider.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

enum TopControlsMode { agenda, staff }

class TopControls extends ConsumerWidget {
  const TopControls.agenda({super.key, this.compact = false})
    : mode = TopControlsMode.agenda,
      todayLabel = null,
      labelOverride = null;

  const TopControls.staff({
    super.key,
    this.todayLabel,
    this.labelOverride,
    this.compact = false,
  }) : mode = TopControlsMode.staff;

  final TopControlsMode mode;

  final bool compact;
  final String? todayLabel;
  final String? labelOverride;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final formFactor = ref.watch(formFactorProvider);

    return TopControlsScaffold(
      applyLayoutInset: formFactor == AppFormFactor.desktop,
      builder: TopControlsBuilder.adaptive(
        mobile: (context, data) => _buildMobile(context, data, ref),
        tablet: (context, data) => _buildTablet(context, data, ref),
        desktop: (context, data) => _buildDesktop(context, data, ref),
      ),
    );
  }

  Widget _buildMobile(
    BuildContext context,
    TopControlsData data,
    WidgetRef ref,
  ) {
    _StaffWeekMeta? weekMeta;
    String label;
    DateTime selectedDate;
    if (mode == TopControlsMode.agenda) {
      label = _formatSingleDate(data);
      selectedDate = data.agendaDate;
    } else {
      weekMeta = _resolveWeekMeta(data);
      label = weekMeta.label;
      selectedDate = weekMeta.effectivePickerDate;
    }
    final showTopDateSwitcher = mode != TopControlsMode.agenda;
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        if (showTopDateSwitcher) ...[
          AgendaDateSwitcher(
            label: label,
            selectedDate: selectedDate,
            onPreviousWeek: mode == TopControlsMode.staff
                ? data.dateController.previousWeek
                : null,
            onNextWeek: mode == TopControlsMode.staff
                ? data.dateController.nextWeek
                : null,
            onPreviousMonth: null,
            onNextMonth: null,
            onSelectDate: (date) {
              data.dateController.set(DateUtils.dateOnly(date));
            },
            useWeekRangePicker: mode == TopControlsMode.staff,
            isCompact: compact,
          ),
          const SizedBox(width: 8),
          if (data.locations.length > 1) ...[
            const SizedBox(width: 16),
            Align(
              alignment: AlignmentDirectional.centerStart,
              child: AgendaLocationSelector(
                locations: data.locations,
                current: data.currentLocation,
                onSelected: data.locationController.set,
                iconOnly: true,
              ),
            ),
          ],
        ],
      ],
    );
  }

  Widget _buildTablet(
    BuildContext context,
    TopControlsData data,
    WidgetRef ref,
  ) {
    _StaffWeekMeta? weekMeta;
    String label;
    DateTime selectedDate;
    if (mode == TopControlsMode.agenda) {
      label = _formatSingleDate(data);
      selectedDate = data.agendaDate;
    } else {
      weekMeta = _resolveWeekMeta(data);
      label = weekMeta.label;
      selectedDate = weekMeta.effectivePickerDate;
    }
    final showTopDateSwitcher =
        mode != TopControlsMode.agenda &&
        !(mode == TopControlsMode.staff &&
            data.formFactor == AppFormFactor.mobile);

    final layoutConfig = ref.watch(layoutConfigProvider);

    return Row(
      mainAxisSize: MainAxisSize.max,
      children: [
        if (showTopDateSwitcher) ...[
          Flexible(
            child: AgendaDateSwitcher(
              label: label,
              selectedDate: selectedDate,
              onPreviousWeek: mode == TopControlsMode.staff
                  ? data.dateController.previousWeek
                  : null,
              onNextWeek: mode == TopControlsMode.staff
                  ? data.dateController.nextWeek
                  : null,
              onSelectDate: (date) {
                data.dateController.set(DateUtils.dateOnly(date));
              },
              useWeekRangePicker: mode == TopControlsMode.staff,
              isCompact: compact,
            ),
          ),
        ],
        if (mode == TopControlsMode.agenda)
          SizedBox(width: layoutConfig.hourColumnWidth),
        if (mode == TopControlsMode.agenda &&
            ref.watch(staffForCurrentLocationProvider).length > 1) ...[
          const Align(
            alignment: AlignmentDirectional.centerStart,
            child: AgendaStaffFilterSelector(isCompact: false),
          ),
        ],
        if (data.locations.length > 1) ...[
          const SizedBox(width: 16),
          Align(
            alignment: AlignmentDirectional.centerStart,
            child: AgendaLocationSelector(
              locations: data.locations,
              current: data.currentLocation,
              onSelected: data.locationController.set,
            ),
          ),
        ],
      ],
    );
  }

  Widget _buildDesktop(
    BuildContext context,
    TopControlsData data,
    WidgetRef ref,
  ) {
    _StaffWeekMeta? weekMeta;
    String label;
    DateTime selectedDate;
    if (mode == TopControlsMode.agenda) {
      label = _formatSingleDate(data);
      selectedDate = data.agendaDate;
    } else {
      weekMeta = _resolveWeekMeta(data);
      label = weekMeta.label;
      selectedDate = weekMeta.effectivePickerDate;
    }
    final showStaffSelector =
        mode == TopControlsMode.agenda &&
        ref.watch(staffForCurrentLocationProvider).length > 1;
    final showLocationSelector = data.locations.length > 1;

    List<Widget> buildChildren({required bool allowFlex}) {
      return [
        if (allowFlex)
          Flexible(
            child: AgendaDateSwitcher(
              label: label,
              selectedDate: selectedDate,
              onPrevious: mode == TopControlsMode.agenda
                  ? data.dateController.previousDay
                  : null,
              onNext: mode == TopControlsMode.agenda
                  ? data.dateController.nextDay
                  : null,
              onPreviousWeek:
                  mode == TopControlsMode.agenda ||
                      mode == TopControlsMode.staff
                  ? data.dateController.previousWeek
                  : null,
              onNextWeek:
                  mode == TopControlsMode.agenda ||
                      mode == TopControlsMode.staff
                  ? data.dateController.nextWeek
                  : null,
              onPreviousMonth: mode == TopControlsMode.agenda
                  ? data.dateController.previousMonth
                  : null,
              onNextMonth: mode == TopControlsMode.agenda
                  ? data.dateController.nextMonth
                  : null,
              onSelectDate: (date) {
                data.dateController.set(DateUtils.dateOnly(date));
              },
              useWeekRangePicker: mode == TopControlsMode.staff,
            ),
          )
        else
          AgendaDateSwitcher(
            label: label,
            selectedDate: selectedDate,
            onPrevious: mode == TopControlsMode.agenda
                ? data.dateController.previousDay
                : null,
            onNext: mode == TopControlsMode.agenda
                ? data.dateController.nextDay
                : null,
            onPreviousWeek:
                mode == TopControlsMode.agenda || mode == TopControlsMode.staff
                ? data.dateController.previousWeek
                : null,
            onNextWeek:
                mode == TopControlsMode.agenda || mode == TopControlsMode.staff
                ? data.dateController.nextWeek
                : null,
            onPreviousMonth: mode == TopControlsMode.agenda
                ? data.dateController.previousMonth
                : null,
            onNextMonth: mode == TopControlsMode.agenda
                ? data.dateController.nextMonth
                : null,
            onSelectDate: (date) {
              data.dateController.set(DateUtils.dateOnly(date));
            },
            useWeekRangePicker: mode == TopControlsMode.staff,
          ),
        if (showStaffSelector) const SizedBox(width: 16),
        if (showStaffSelector)
          const Align(
            alignment: AlignmentDirectional.centerStart,
            child: AgendaStaffFilterSelector(isCompact: false),
          ),
        if (showLocationSelector) ...[
          const SizedBox(width: 16),
          if (mode == TopControlsMode.staff)
            Align(
              alignment: AlignmentDirectional.centerStart,
              child: StaffLocationSelector(
                locations: data.locations,
                currentLocationId: ref.watch(staffSectionLocationIdProvider),
                onSelected: ref
                    .read(staffSectionLocationIdProvider.notifier)
                    .set,
              ),
            )
          else
            Align(
              alignment: AlignmentDirectional.centerStart,
              child: AgendaLocationSelector(
                locations: data.locations,
                current: data.currentLocation,
                onSelected: data.locationController.set,
              ),
            ),
        ],
      ];
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        final useScrollFallback =
            constraints.hasBoundedWidth && constraints.maxWidth < 420;
        if (useScrollFallback) {
          return ScrollConfiguration(
            behavior: const NoScrollbarBehavior(),
            child: SingleChildScrollView(
              scrollDirection: Axis.horizontal,
              child: Row(
                mainAxisSize: MainAxisSize.min,
                children: buildChildren(allowFlex: false),
              ),
            ),
          );
        }
        return Row(children: buildChildren(allowFlex: true));
      },
    );
  }

  String _formatSingleDate(TopControlsData data) {
    final localeTag = data.locale.toLanguageTag();
    return DateFormat('EEE d MMM', localeTag).format(data.agendaDate);
  }

  _StaffWeekMeta _resolveWeekMeta(TopControlsData data) {
    final agendaDate = data.agendaDate;
    final locale = Intl.canonicalizedLocale(data.locale.toString());

    String buildWeekRangeLabel(DateTime start, DateTime end, String localeTag) {
      final sameYear = start.year == end.year;
      final sameMonth = sameYear && start.month == end.month;
      if (sameMonth) {
        final d1 = DateFormat('d', localeTag).format(start);
        final d2m = DateFormat('d MMM', localeTag).format(end);
        return '$d1‚Äì$d2m';
      }
      if (sameYear) {
        final s = DateFormat('d MMM', localeTag).format(start);
        final e = DateFormat('d MMM', localeTag).format(end);
        return '$s ‚Äì $e';
      }
      final s = DateFormat('d MMM y', localeTag).format(start);
      final e = DateFormat('d MMM y', localeTag).format(end);
      return '$s ‚Äì $e';
    }

    final deltaToMonday = (agendaDate.weekday - DateTime.monday) % 7;
    final pickerInitialDate = DateUtils.dateOnly(
      agendaDate.subtract(Duration(days: deltaToMonday)),
    );
    final todayDate = DateUtils.dateOnly(DateTime.now());
    final weekStart = pickerInitialDate;
    final weekEnd = weekStart.add(const Duration(days: 6));
    final defaultLabel = buildWeekRangeLabel(weekStart, weekEnd, locale);
    final formattedDate = labelOverride ?? defaultLabel;
    final isTodayInWeek =
        !todayDate.isBefore(weekStart) && !todayDate.isAfter(weekEnd);
    final effectivePickerDate = isTodayInWeek ? todayDate : weekEnd;

    return _StaffWeekMeta(
      label: formattedDate,
      effectivePickerDate: effectivePickerDate,
    );
  }
}

class _StaffWeekMeta {
  const _StaffWeekMeta({
    required this.label,
    required this.effectivePickerDate,
  });

  final String label;
  final DateTime effectivePickerDate;
}

/// Content widget for the location bottom sheet, consistent with other dropdowns.
class LocationSheetContent extends StatelessWidget {
  const LocationSheetContent({
    super.key,
    required this.locations,
    required this.currentLocationId,
    required this.title,
    required this.onSelected,
    this.showAllLocationsOption = false,
    this.allLocationsLabel,
  });

  final List<Location> locations;
  final int?
  currentLocationId; // null = "Tutte le sedi" se showAllLocationsOption
  final String title;
  final ValueChanged<int?> onSelected;
  final bool showAllLocationsOption;
  final String? allLocationsLabel;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    final maxHeight = MediaQuery.of(context).size.height * 0.8;
    final itemCount = locations.length + (showAllLocationsOption ? 1 : 0);

    return ConstrainedBox(
      constraints: BoxConstraints(maxHeight: maxHeight),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 16, 16, 12),
            child: Text(
              title,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          const AppBottomSheetDivider(),
          Expanded(
            child: ListView.builder(
              itemCount: itemCount,
              itemBuilder: (ctx, index) {
                // Prima voce: "Tutte le sedi" se abilitato
                if (showAllLocationsOption && index == 0) {
                  final isSelected = currentLocationId == null;
                  return InkWell(
                    onTap: () => onSelected(null),
                    splashColor: Colors.transparent,
                    highlightColor: Colors.transparent,
                    child: Container(
                      padding: const EdgeInsets.symmetric(
                        vertical: 14,
                        horizontal: 16,
                      ),
                      color: isSelected
                          ? colorScheme.primary.withOpacity(0.08)
                          : Colors.transparent,
                      child: Row(
                        children: [
                          Expanded(
                            child: Text(
                              allLocationsLabel ?? context.l10n.allLocations,
                              style: TextStyle(
                                color: colorScheme.onSurface,
                                fontWeight: isSelected
                                    ? FontWeight.w600
                                    : FontWeight.normal,
                              ),
                            ),
                          ),
                          if (isSelected)
                            Icon(
                              Icons.check,
                              size: 20,
                              color: colorScheme.primary,
                            ),
                        ],
                      ),
                    ),
                  );
                }

                final locationIndex = showAllLocationsOption
                    ? index - 1
                    : index;
                final loc = locations[locationIndex];
                final isSelected = loc.id == currentLocationId;
                return InkWell(
                  onTap: () => onSelected(loc.id),
                  splashColor: Colors.transparent,
                  highlightColor: Colors.transparent,
                  child: Container(
                    padding: const EdgeInsets.symmetric(
                      vertical: 14,
                      horizontal: 16,
                    ),
                    color: isSelected
                        ? colorScheme.primary.withOpacity(0.08)
                        : Colors.transparent,
                    child: Row(
                      children: [
                        Expanded(
                          child: Text(
                            loc.name,
                            style: TextStyle(
                              color: colorScheme.onSurface,
                              fontWeight: isSelected
                                  ? FontWeight.w600
                                  : FontWeight.normal,
                            ),
                          ),
                        ),
                        if (isSelected)
                          Icon(
                            Icons.check,
                            size: 20,
                            color: colorScheme.primary,
                          ),
                      ],
                    ),
                  ),
                );
              },
            ),
          ),
          SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
        ],
      ),
    );
  }
}
--- FILE: lib/app/widgets/agenda_control_components.dart ---
import 'package:agenda_backend/app/theme/extensions.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/location.dart';
import 'package:agenda_backend/core/widgets/adaptive_dropdown.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

const double kAgendaControlHeight = 40;
const double kAgendaControlHorizontalPadding = 20;
const double kAgendaMinDateLabelWidth = 120;
const BorderRadius kAgendaPillRadius = BorderRadius.all(Radius.circular(999));
const double kAgendaDividerWidth = 1;

class AgendaRoundedButton extends StatelessWidget {
  const AgendaRoundedButton({super.key, required this.label, this.onTap});

  final String label;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final interactions = Theme.of(context).extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final pressedFill =
        interactions?.pressedFill ?? colorScheme.primary.withOpacity(0.1);
    final disabledFill = colorScheme.surface.withOpacity(0.6);
    final disabledForeground = colorScheme.onSurface.withOpacity(0.38);
    final enabledText = colorScheme.onSurface;
    final disabledBorder = colorScheme.onSurface.withOpacity(0.12);
    final enabledBorder = Colors.grey.withOpacity(0.35);

    return SizedBox(
      height: kAgendaControlHeight,
      child: OutlinedButton(
        style:
            OutlinedButton.styleFrom(
              shape: const RoundedRectangleBorder(
                borderRadius: kAgendaPillRadius,
              ),
              padding: const EdgeInsets.symmetric(
                horizontal: kAgendaControlHorizontalPadding,
              ),
              side: BorderSide(color: enabledBorder),
            ).copyWith(
              backgroundColor: MaterialStateProperty.resolveWith((states) {
                if (states.contains(MaterialState.disabled)) {
                  return disabledFill;
                }
                if (states.contains(MaterialState.pressed)) return pressedFill;
                if (states.contains(MaterialState.hovered)) return hoverFill;
                return colorScheme.surface;
              }),
              foregroundColor: MaterialStateProperty.resolveWith((states) {
                if (states.contains(MaterialState.disabled)) {
                  return disabledForeground;
                }
                return enabledText;
              }),
              overlayColor: MaterialStateProperty.all(Colors.transparent),
              elevation: MaterialStateProperty.resolveWith(
                (states) =>
                    states.contains(MaterialState.hovered) &&
                        !states.contains(MaterialState.disabled)
                    ? 6
                    : 0,
              ),
              shadowColor: MaterialStateProperty.all(
                Colors.black.withOpacity(0.08),
              ),
              side: MaterialStateProperty.resolveWith(
                (states) => BorderSide(
                  color: states.contains(MaterialState.disabled)
                      ? disabledBorder
                      : enabledBorder,
                ),
              ),
            ),
        onPressed: onTap,
        child: Text(label),
      ),
    );
  }
}

class AgendaDateSwitcher extends StatefulWidget {
  const AgendaDateSwitcher({
    super.key,
    required this.label,
    required this.selectedDate,
    this.useWeekRangePicker = false,
    this.isCompact = false,
    this.onPrevious,
    this.onPreviousWeek,
    this.onNext,
    this.onNextWeek,
    this.onPreviousMonth,
    this.onNextMonth,
    required this.onSelectDate,
  });

  final String label;
  final DateTime selectedDate;
  // When true, tapping the label opens a DateRangePicker pre-filled with the
  // week (Mon-Sun) containing selectedDate, and normalizes user choice to that week.
  final bool useWeekRangePicker;

  /// Variante compatta: disegna solo il bottone testo+icona senza frecce laterali.
  final bool isCompact;
  final VoidCallback? onPrevious;
  final VoidCallback? onPreviousWeek;
  final VoidCallback? onNext;
  final VoidCallback? onNextWeek;
  final VoidCallback? onPreviousMonth;
  final VoidCallback? onNextMonth;
  final ValueChanged<DateTime> onSelectDate;

  @override
  State<AgendaDateSwitcher> createState() => _AgendaDateSwitcherState();
}

class _AgendaDateSwitcherState extends State<AgendaDateSwitcher> {
  Future<void> _handleTap(BuildContext context) async {
    final initialDate = widget.selectedDate;
    final firstDate = DateTime(initialDate.year - 3);
    final lastDate = DateTime(initialDate.year + 3);

    if (widget.useWeekRangePicker) {
      // Custom lightweight week picker: tap qualsiasi giorno -> settimana Mon-Dom
      final selectedMonday = await _showWeekPickerDialog(
        context: context,
        anchor: initialDate,
        firstDate: firstDate,
        lastDate: lastDate,
      );
      if (selectedMonday != null &&
          !DateUtils.isSameDay(selectedMonday, widget.selectedDate)) {
        widget.onSelectDate(selectedMonday);
      }
      return;
    }

    // Default single-date dialog
    final picked = await showGeneralDialog<DateTime>(
      context: context,
      barrierDismissible: true,
      barrierColor: Colors.black.withOpacity(0.12),
      barrierLabel: MaterialLocalizations.of(context).modalBarrierDismissLabel,
      transitionDuration: const Duration(milliseconds: 180),
      transitionBuilder: (context, animation, secondaryAnimation, child) {
        final curved = CurvedAnimation(
          parent: animation,
          curve: Curves.easeOut,
        );
        return FadeTransition(
          opacity: curved,
          child: ScaleTransition(
            scale: Tween<double>(begin: 0.96, end: 1).animate(curved),
            child: child,
          ),
        );
      },
      pageBuilder: (dialogContext, _, __) {
        final theme = Theme.of(dialogContext);
        final localizations = MaterialLocalizations.of(dialogContext);
        final borderColor = theme.dividerColor.withOpacity(0.24);
        final baseHeadline =
            theme.datePickerTheme.headerHeadlineStyle ??
            theme.textTheme.titleLarge ??
            const TextStyle(fontSize: 18);
        final datePickerTheme = theme.datePickerTheme.copyWith(
          headerHeadlineStyle: baseHeadline.copyWith(
            fontWeight: FontWeight.w700,
          ),
        );

        return Center(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 32),
            child: Material(
              elevation: 12,
              color: theme.colorScheme.surface,
              borderRadius: const BorderRadius.all(Radius.circular(12)),
              child: ConstrainedBox(
                constraints: const BoxConstraints(minWidth: 280, maxWidth: 360),
                child: DecoratedBox(
                  decoration: BoxDecoration(
                    borderRadius: const BorderRadius.all(Radius.circular(12)),
                    border: Border.all(color: borderColor, width: 1),
                  ),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Theme(
                        data: theme.copyWith(datePickerTheme: datePickerTheme),
                        child: CalendarDatePicker(
                          initialDate: initialDate,
                          firstDate: firstDate,
                          lastDate: lastDate,
                          onDateChanged: (selected) {
                            Navigator.of(
                              dialogContext,
                            ).pop(DateUtils.dateOnly(selected));
                          },
                        ),
                      ),
                      Align(
                        alignment: Alignment.centerRight,
                        child: Padding(
                          padding: const EdgeInsets.fromLTRB(0, 0, 8, 8),
                          child: TextButton(
                            onPressed: () => Navigator.of(dialogContext).pop(),
                            child: Text(localizations.cancelButtonLabel),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        );
      },
    );

    if (picked != null && !DateUtils.isSameDay(picked, widget.selectedDate)) {
      widget.onSelectDate(picked);
    }
  }

  @override
  Widget build(BuildContext context) {
    /*if (widget.isCompact) {
      return _CompactDateSwitcher(
        label: widget.label,
        onTap: () => _handleTap(context),
      );
    }*/
    final colorScheme = Theme.of(context).colorScheme;
    final textTheme = Theme.of(context).textTheme;
    final interactions = Theme.of(context).extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = colorScheme.surface;
    final l10n = context.l10n;
    final borderColor = Colors.grey.withOpacity(0.35);

    const double dividerWidth = kAgendaDividerWidth;
    final double arrowExtent = kAgendaControlHeight;
    final double navIconSize = arrowExtent <= 32 ? 16.0 : 18.0;
    const BorderRadius leftRadius = BorderRadius.only(
      topLeft: Radius.circular(999),
      bottomLeft: Radius.circular(999),
    );
    const BorderRadius rightRadius = BorderRadius.only(
      topRight: Radius.circular(999),
      bottomRight: Radius.circular(999),
    );

    return Container(
      height: kAgendaControlHeight,
      decoration: BoxDecoration(
        borderRadius: kAgendaPillRadius,
        border: Border.all(color: borderColor),
        color: backgroundColor,
      ),
      child: LayoutBuilder(
        builder: (context, constraints) {
          final maxWidth = constraints.maxWidth;
          const compactBreakpoint = 330.0;
          final isCompact =
              maxWidth.isFinite && maxWidth > 0 && maxWidth < compactBreakpoint;
          final horizontalPadding = isCompact
              ? 12.0
              : kAgendaControlHorizontalPadding;
          final labelSemantics = MaterialLocalizations.of(
            context,
          ).datePickerHelpText;

          Widget buildDivider(VoidCallback onTap) => GestureDetector(
            behavior: HitTestBehavior.opaque,
            onTap: onTap,
            child: SizedBox(
              width: dividerWidth,
              height: kAgendaControlHeight,
              child: DecoratedBox(
                decoration: BoxDecoration(color: borderColor.withOpacity(0.5)),
              ),
            ),
          );

          Widget buildStaticDivider() => SizedBox(
            width: dividerWidth,
            height: kAgendaControlHeight,
            child: DecoratedBox(
              decoration: BoxDecoration(color: borderColor.withOpacity(0.5)),
            ),
          );

          Widget buildArrowButton(
            _NavButtonSpec spec,
            BorderRadius borderRadius,
          ) {
            return _HoverableRegion(
              onTap: spec.onTap,
              semanticsLabel: spec.semanticsLabel,
              hoverColor: hoverFill,
              width: arrowExtent,
              borderRadius: borderRadius,
              child: Center(
                child: spec.iconWidget ?? Icon(spec.icon, size: navIconSize),
              ),
            );
          }

          Widget buildLabelRegion() => _HoverableRegion(
            onTap: () => _handleTap(context),
            semanticsLabel: labelSemantics,
            hoverColor: hoverFill,
            minWidth: kAgendaMinDateLabelWidth,
            padding: EdgeInsets.symmetric(horizontal: horizontalPadding),
            child: Align(
              alignment: Alignment.center,
              child: Text(
                widget.label,
                style: textTheme.titleMedium,
                overflow: TextOverflow.ellipsis,
                maxLines: 1,
              ),
            ),
          );

          List<Widget> buildNavButtons(
            List<_NavButtonSpec> specs, {
            BorderRadius? firstRadius,
            BorderRadius? lastRadius,
          }) {
            final widgets = <Widget>[];
            for (var i = 0; i < specs.length; i++) {
              if (i > 0) {
                widgets.add(buildStaticDivider());
              }
              final spec = specs[i];
              BorderRadius buttonRadius = BorderRadius.zero;
              if (i == 0 && firstRadius != null) {
                buttonRadius = firstRadius;
              }
              if (i == specs.length - 1 && lastRadius != null) {
                buttonRadius = lastRadius;
              }
              widgets.add(buildArrowButton(spec, buttonRadius));
            }
            return widgets;
          }

          final leadingSpecs = <_NavButtonSpec>[];
          if (widget.onPreviousMonth != null) {
            leadingSpecs.add(
              _NavButtonSpec(
                iconWidget: widget.onPrevious != null
                    ? _TripleArrowIcons(
                        icon: Icons.keyboard_arrow_left,
                        iconSize: navIconSize,
                        width: arrowExtent,
                      )
                    : null,

                icon: widget.onPrevious == null
                    ? Icons.keyboard_double_arrow_left
                    : null,
                onTap: widget.onPreviousMonth!,
                semanticsLabel: l10n.agendaPrevMonth,
              ),
            );
          }
          if (widget.onPreviousWeek != null) {
            leadingSpecs.add(
              _NavButtonSpec(
                icon: widget.onPrevious != null
                    ? Icons.keyboard_double_arrow_left
                    : Icons.keyboard_arrow_left,
                onTap: widget.onPreviousWeek!,
                semanticsLabel: l10n.agendaPrevWeek,
              ),
            );
          }
          if (widget.onPrevious != null) {
            leadingSpecs.add(
              _NavButtonSpec(
                icon: Icons.keyboard_arrow_left,
                onTap: widget.onPrevious ?? () {},
                semanticsLabel: l10n.agendaPrevDay,
              ),
            );
          }

          final trailingSpecs = <_NavButtonSpec>[];
          if (widget.onNext != null) {
            trailingSpecs.add(
              _NavButtonSpec(
                icon: Icons.keyboard_arrow_right,
                onTap: widget.onNext ?? () {},
                semanticsLabel: l10n.agendaNextDay,
              ),
            );
          }
          if (widget.onNextWeek != null) {
            trailingSpecs.add(
              _NavButtonSpec(
                icon: widget.onNext != null
                    ? Icons.keyboard_double_arrow_right
                    : Icons.keyboard_arrow_right,
                onTap: widget.onNextWeek!,
                semanticsLabel: l10n.agendaNextWeek,
              ),
            );
          }
          if (widget.onNextMonth != null) {
            trailingSpecs.add(
              _NavButtonSpec(
                iconWidget: widget.onNext != null
                    ? _TripleArrowIcons(
                        icon: Icons.keyboard_arrow_right,
                        iconSize: navIconSize,
                        width: arrowExtent,
                      )
                    : null,
                icon: widget.onNext == null
                    ? Icons.keyboard_double_arrow_right
                    : null,
                onTap: widget.onNextMonth!,
                semanticsLabel: l10n.agendaNextMonth,
              ),
            );
          }

          final labelRegion = buildLabelRegion();
          final children = <Widget>[
            ...buildNavButtons(
              leadingSpecs,
              firstRadius: leadingSpecs.isNotEmpty ? leftRadius : null,
            ),
            buildDivider(() => _handleTap(context)),
          ];

          if (isCompact) {
            children.add(Expanded(child: labelRegion));
          } else {
            children.add(labelRegion);
          }

          children.addAll([
            buildDivider(() => _handleTap(context)),
            ...buildNavButtons(
              trailingSpecs,
              lastRadius: trailingSpecs.isNotEmpty ? rightRadius : null,
            ),
          ]);

          return Row(
            mainAxisSize: isCompact ? MainAxisSize.max : MainAxisSize.min,
            children: children,
          );
        },
      ),
    );
  }
}

/// Shows a simple dialog with a month grid. Selecting any day returns the Monday
/// of that week. Month navigation supported. Highlights the whole week.
Future<DateTime?> _showWeekPickerDialog({
  required BuildContext context,
  required DateTime anchor,
  required DateTime firstDate,
  required DateTime lastDate,
}) async {
  return showGeneralDialog<DateTime>(
    context: context,
    barrierDismissible: true,
    barrierColor: Colors.black.withOpacity(0.12),
    barrierLabel: MaterialLocalizations.of(context).modalBarrierDismissLabel,
    transitionDuration: const Duration(milliseconds: 180),
    transitionBuilder: (context, animation, secondary, child) {
      final curved = CurvedAnimation(parent: animation, curve: Curves.easeOut);
      return FadeTransition(
        opacity: curved,
        child: ScaleTransition(
          scale: Tween<double>(begin: 0.96, end: 1).animate(curved),
          child: child,
        ),
      );
    },
    pageBuilder: (dialogContext, _, __) {
      return _WeekPickerContent(
        anchor: anchor,
        firstDate: firstDate,
        lastDate: lastDate,
      );
    },
  );
}

class _WeekPickerContent extends StatefulWidget {
  const _WeekPickerContent({
    required this.anchor,
    required this.firstDate,
    required this.lastDate,
  });
  final DateTime anchor;
  final DateTime firstDate;
  final DateTime lastDate;

  @override
  State<_WeekPickerContent> createState() => _WeekPickerContentState();
}

class _NavButtonSpec {
  const _NavButtonSpec({
    this.icon,
    this.iconWidget,
    required this.onTap,
    required this.semanticsLabel,
  }) : assert(icon != null || iconWidget != null);

  final IconData? icon;
  final Widget? iconWidget;
  final VoidCallback onTap;
  final String semanticsLabel;
}

class _TripleArrowIcons extends StatelessWidget {
  const _TripleArrowIcons({
    required this.icon,
    required this.iconSize,
    required this.width,
  });

  final IconData icon;
  final double iconSize;
  final double width;

  @override
  Widget build(BuildContext context) {
    final color = Theme.of(context).iconTheme.color;
    return SizedBox(
      width: width,
      height: iconSize,
      child: Stack(
        clipBehavior: Clip.none,
        children: List.generate(3, (index) {
          final spacing = iconSize * 0.3;
          return Positioned(
            left: (width - iconSize) / 2 + (index - 1) * spacing,
            child: Icon(icon, size: iconSize, color: color),
          );
        }),
      ),
    );
  }
}

class _WeekPickerContentState extends State<_WeekPickerContent> {
  late DateTime _focusedMonth; // first day of focused month
  DateTime? _hoverDay;
  late DateTime _selectedMonday;

  @override
  void initState() {
    super.initState();
    _focusedMonth = DateTime(widget.anchor.year, widget.anchor.month, 1);
    _selectedMonday = _mondayOf(widget.anchor);
  }

  DateTime _mondayOf(DateTime d) =>
      d.subtract(Duration(days: d.weekday - DateTime.monday));

  bool _inSameWeek(DateTime day, DateTime monday) {
    final diff = day.difference(monday).inDays;
    return diff >= 0 && diff < 7;
  }

  void _changeMonth(int delta) {
    setState(() {
      _focusedMonth = DateTime(
        _focusedMonth.year,
        _focusedMonth.month + delta,
        1,
      );
    });
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final locale = Localizations.localeOf(context).toString();
    final monthLabel = DateFormat('MMMM y', locale).format(_focusedMonth);
    final localizations = MaterialLocalizations.of(context);
    final firstGridDay = _mondayOf(_focusedMonth);
    // 6 weeks grid
    final days = List.generate(42, (i) => firstGridDay.add(Duration(days: i)));
    final hoveredWeekMonday = _hoverDay != null ? _mondayOf(_hoverDay!) : null;

    Color weekBg(bool inSelected, bool inHovered) {
      final base = theme.colorScheme.primary;
      if (inSelected) return base.withOpacity(0.18);
      if (inHovered) return base.withOpacity(0.10);
      return Colors.transparent;
    }

    return Center(
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Material(
          elevation: 12,
          color: theme.colorScheme.surface,
          borderRadius: const BorderRadius.all(Radius.circular(12)),
          child: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 320, maxWidth: 360),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                // Header
                Padding(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 8,
                  ),
                  child: Row(
                    children: [
                      IconButton(
                        tooltip: localizations.previousMonthTooltip,
                        onPressed: () => _changeMonth(-1),
                        icon: const Icon(Icons.chevron_left),
                      ),
                      Expanded(
                        child: Center(
                          child: Text(
                            monthLabel,
                            style: theme.textTheme.titleMedium?.copyWith(
                              fontWeight: FontWeight.w600,
                            ),
                          ),
                        ),
                      ),
                      IconButton(
                        tooltip: localizations.nextMonthTooltip,
                        onPressed: () => _changeMonth(1),
                        icon: const Icon(Icons.chevron_right),
                      ),
                    ],
                  ),
                ),
                const Divider(height: 1),
                // Weekday headers (Mon-Sun)
                Padding(
                  padding: const EdgeInsets.only(top: 8, left: 8, right: 8),
                  child: Row(
                    children: [
                      // Use MaterialLocalizations (shortWeekdays) starting from Monday.
                      // MaterialLocalizations non espone shortWeekdays; generiamo abbreviazioni
                      // localizzate usando DateFormat('E'). Partiamo dal luned√¨.
                      for (int i = 0; i < 7; i++)
                        Expanded(
                          child: Center(
                            child: Text(
                              DateFormat('E', locale).format(
                                _mondayOf(_focusedMonth).add(Duration(days: i)),
                              ),
                              style: theme.textTheme.labelSmall?.copyWith(
                                fontWeight: FontWeight.w600,
                              ),
                            ),
                          ),
                        ),
                      // end weekday headers
                    ],
                  ),
                ),
                const SizedBox(height: 4),
                // Grid
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 8),
                  child: Column(
                    children: [
                      for (int w = 0; w < 6; w++) ...[
                        Row(
                          children: [
                            for (int d = 0; d < 7; d++) ...[
                              Builder(
                                builder: (context) {
                                  final day = days[w * 7 + d];
                                  // final mondayOfDay = _mondayOf(day); // not needed after normalization on tap
                                  final inSelectedWeek = _inSameWeek(
                                    day,
                                    _selectedMonday,
                                  );
                                  final inHoveredWeek =
                                      hoveredWeekMonday != null &&
                                      _inSameWeek(day, hoveredWeekMonday);
                                  final isOutOfRange =
                                      day.isBefore(widget.firstDate) ||
                                      day.isAfter(widget.lastDate);
                                  final isCurrentMonth =
                                      day.month == _focusedMonth.month;

                                  return Expanded(
                                    child: GestureDetector(
                                      onTap: isOutOfRange
                                          ? null
                                          : () {
                                              final newMonday = _mondayOf(day);
                                              Navigator.of(context).pop(
                                                DateUtils.dateOnly(newMonday),
                                              );
                                            },
                                      child: MouseRegion(
                                        onEnter: (_) =>
                                            setState(() => _hoverDay = day),
                                        onExit: (_) =>
                                            setState(() => _hoverDay = null),
                                        child: AnimatedContainer(
                                          duration: const Duration(
                                            milliseconds: 120,
                                          ),
                                          margin: const EdgeInsets.symmetric(
                                            vertical: 2,
                                            horizontal: 2,
                                          ),
                                          decoration: BoxDecoration(
                                            color: weekBg(
                                              inSelectedWeek,
                                              inHoveredWeek,
                                            ),
                                            borderRadius: BorderRadius.circular(
                                              8,
                                            ),
                                          ),
                                          height: 40,
                                          alignment: Alignment.center,
                                          child: Text(
                                            '${day.day}',
                                            style: theme.textTheme.bodySmall
                                                ?.copyWith(
                                                  fontWeight: FontWeight.w500,
                                                  color: isOutOfRange
                                                      ? theme.disabledColor
                                                      : (isCurrentMonth
                                                            ? theme
                                                                  .colorScheme
                                                                  .onSurface
                                                            : theme
                                                                  .colorScheme
                                                                  .onSurface
                                                                  .withOpacity(
                                                                    0.45,
                                                                  )),
                                                ),
                                          ),
                                        ),
                                      ),
                                    ),
                                  );
                                },
                              ),
                            ],
                          ],
                        ),
                      ],
                    ],
                  ),
                ),
                const SizedBox(height: 8),
                Padding(
                  padding: const EdgeInsets.fromLTRB(12, 0, 12, 12),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      TextButton(
                        onPressed: () => Navigator.of(context).pop(),
                        child: Text(localizations.cancelButtonLabel),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class _HoverableRegion extends StatefulWidget {
  const _HoverableRegion({
    required this.onTap,
    required this.semanticsLabel,
    required this.hoverColor,
    required this.child,
    this.width,
    this.minWidth,
    this.padding,
    this.borderRadius = BorderRadius.zero,
  });

  final VoidCallback onTap;
  final String semanticsLabel;
  final Color hoverColor;
  final Widget child;
  final double? width;
  final double? minWidth;
  final EdgeInsetsGeometry? padding;
  final BorderRadius borderRadius;

  @override
  State<_HoverableRegion> createState() => _HoverableRegionState();
}

class _HoverableRegionState extends State<_HoverableRegion> {
  bool _hovered = false;

  @override
  Widget build(BuildContext context) {
    final constraints = widget.minWidth != null
        ? BoxConstraints(minWidth: widget.minWidth!)
        : const BoxConstraints();

    Widget content = widget.child;
    if (widget.padding != null) {
      content = Padding(padding: widget.padding!, child: content);
    }

    return Semantics(
      button: true,
      label: widget.semanticsLabel,
      child: MouseRegion(
        cursor: SystemMouseCursors.click,
        onEnter: (_) => setState(() => _hovered = true),
        onExit: (_) => setState(() => _hovered = false),
        child: GestureDetector(
          behavior: HitTestBehavior.opaque,
          onTap: widget.onTap,
          child: ClipRRect(
            borderRadius: widget.borderRadius,
            child: AnimatedContainer(
              duration: const Duration(milliseconds: 120),
              curve: Curves.easeOut,
              width: widget.width,
              constraints: constraints,
              height: kAgendaControlHeight,
              color: _hovered ? widget.hoverColor : Colors.transparent,
              child: content,
            ),
          ),
        ),
      ),
    );
  }
}

/// Versione compact del date switcher con stile pill.
class _CompactDateSwitcher extends StatefulWidget {
  const _CompactDateSwitcher({required this.label, required this.onTap});

  final String label;
  final VoidCallback onTap;

  @override
  State<_CompactDateSwitcher> createState() => _CompactDateSwitcherState();
}

class _CompactDateSwitcherState extends State<_CompactDateSwitcher> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final interactions = Theme.of(context).extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = _isHovered
        ? Color.alphaBlend(hoverFill, colorScheme.surface)
        : colorScheme.surface;

    return InkWell(
      onHover: (hovering) {
        if (hovering != _isHovered) {
          setState(() => _isHovered = hovering);
        }
      },
      onTap: widget.onTap,
      highlightColor: Colors.transparent,
      borderRadius: kAgendaPillRadius,
      child: ClipRRect(
        borderRadius: kAgendaPillRadius,
        child: Container(
          height: kAgendaControlHeight,
          decoration: BoxDecoration(
            borderRadius: kAgendaPillRadius,
            border: Border.all(color: Colors.grey.withOpacity(0.35)),
            color: backgroundColor,
          ),
          child: Padding(
            padding: const EdgeInsets.symmetric(
              horizontal: kAgendaControlHorizontalPadding,
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  Icons.calendar_today_outlined,
                  size: 18,
                  color: colorScheme.onSurface,
                ),
                const SizedBox(width: 8),
                Flexible(
                  child: Text(widget.label, overflow: TextOverflow.ellipsis),
                ),
                const SizedBox(width: 8),
                const Icon(Icons.keyboard_arrow_down_rounded, size: 20),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class AgendaLocationSelector extends ConsumerStatefulWidget {
  const AgendaLocationSelector({
    super.key,
    required this.locations,
    required this.current,
    required this.onSelected,
    this.iconOnly = false,
  });

  final List<Location> locations;
  final Location current;
  final void Function(int id) onSelected;
  final bool iconOnly;

  @override
  ConsumerState<AgendaLocationSelector> createState() =>
      _AgendaLocationSelectorState();
}

class _AgendaLocationSelectorState
    extends ConsumerState<AgendaLocationSelector> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final interactions = Theme.of(context).extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = _isHovered
        ? Color.alphaBlend(hoverFill, colorScheme.surface)
        : colorScheme.surface;
    final l10n = context.l10n;

    return AdaptiveDropdown<int>(
      items: [
        for (final location in widget.locations)
          AdaptiveDropdownItem<int>(
            value: location.id,
            child: Text(location.name),
          ),
      ],
      selectedValue: widget.current.id,
      onSelected: widget.onSelected,
      modalTitle: l10n.agendaSelectLocation,
      popupWidth: 200,
      useRootNavigator: true,
      onOpened: () => setState(() => _isHovered = true),
      onClosed: () => setState(() => _isHovered = false),
      child: MouseRegion(
        onEnter: (_) {
          if (!_isHovered) setState(() => _isHovered = true);
        },
        onExit: (_) {
          if (_isHovered) setState(() => _isHovered = false);
        },
        child: Semantics(
          button: true,
          label: l10n.agendaSelectLocation,
          child: widget.iconOnly
              ? Tooltip(
                  message: l10n.agendaSelectLocation,
                  child: Container(
                    height: kAgendaControlHeight,
                    width: kAgendaControlHeight,
                    alignment: Alignment.center,
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(
                        kAgendaControlHeight / 2,
                      ),
                      color: backgroundColor,
                    ),
                    child: Icon(
                      Icons.place_outlined,
                      size: 30,
                      color: colorScheme.onSurfaceVariant,
                    ),
                  ),
                )
              : ClipRRect(
                  borderRadius: kAgendaPillRadius,
                  child: Container(
                    height: kAgendaControlHeight,
                    decoration: BoxDecoration(
                      borderRadius: kAgendaPillRadius,
                      border: Border.all(color: Colors.grey.withOpacity(0.35)),
                      color: backgroundColor,
                    ),
                    child: LayoutBuilder(
                      builder: (context, constraints) {
                        const compactBreakpoint = 220.0;
                        final maxWidth = constraints.maxWidth;
                        final isCompact =
                            maxWidth.isFinite &&
                            maxWidth > 0 &&
                            maxWidth < compactBreakpoint;
                        final horizontalPadding = isCompact
                            ? 12.0
                            : kAgendaControlHorizontalPadding;

                        if (maxWidth.isFinite &&
                            maxWidth < kAgendaControlHeight) {
                          return const SizedBox.shrink();
                        }

                        return Padding(
                          padding: EdgeInsets.symmetric(
                            horizontal: horizontalPadding,
                          ),
                          child: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Flexible(
                                child: Text(
                                  widget.current.name,
                                  overflow: TextOverflow.ellipsis,
                                ),
                              ),
                              const SizedBox(width: 8),
                              const Icon(
                                Icons.keyboard_arrow_down_rounded,
                                size: 20,
                              ),
                            ],
                          ),
                        );
                      },
                    ),
                  ),
                ),
        ),
      ),
    );
  }
}

/// Selettore di location per la sezione Staff.
/// Include l'opzione "Tutte le sedi" come valore di default (null).
class StaffLocationSelector extends ConsumerStatefulWidget {
  const StaffLocationSelector({
    super.key,
    required this.locations,
    required this.currentLocationId,
    required this.onSelected,
  });

  final List<Location> locations;
  final int? currentLocationId; // null = "Tutte le sedi"
  final void Function(int? id) onSelected;

  @override
  ConsumerState<StaffLocationSelector> createState() =>
      _StaffLocationSelectorState();
}

class _StaffLocationSelectorState extends ConsumerState<StaffLocationSelector> {
  bool _isHovered = false;

  String _getDisplayName(BuildContext context) {
    if (widget.currentLocationId == null) {
      return context.l10n.allLocations;
    }
    final location = widget.locations.firstWhere(
      (l) => l.id == widget.currentLocationId,
      orElse: () => widget.locations.first,
    );
    return location.name;
  }

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final interactions = Theme.of(context).extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = _isHovered
        ? Color.alphaBlend(hoverFill, colorScheme.surface)
        : colorScheme.surface;
    final l10n = context.l10n;

    return AdaptiveDropdown<int?>(
      items: [
        // Opzione "Tutte le sedi" come prima voce
        AdaptiveDropdownItem<int?>(value: null, child: Text(l10n.allLocations)),
        // Separator
        for (final location in widget.locations)
          AdaptiveDropdownItem<int?>(
            value: location.id,
            child: Text(location.name),
          ),
      ],
      selectedValue: widget.currentLocationId,
      onSelected: widget.onSelected,
      modalTitle: l10n.agendaSelectLocation,
      popupWidth: 200,
      useRootNavigator: true,
      onOpened: () => setState(() => _isHovered = true),
      onClosed: () => setState(() => _isHovered = false),
      child: MouseRegion(
        onEnter: (_) {
          if (!_isHovered) setState(() => _isHovered = true);
        },
        onExit: (_) {
          if (_isHovered) setState(() => _isHovered = false);
        },
        child: Semantics(
          button: true,
          label: l10n.agendaSelectLocation,
          child: ClipRRect(
            borderRadius: kAgendaPillRadius,
            child: Container(
              height: kAgendaControlHeight,
              decoration: BoxDecoration(
                borderRadius: kAgendaPillRadius,
                border: Border.all(color: Colors.grey.withOpacity(0.35)),
                color: backgroundColor,
              ),
              child: LayoutBuilder(
                builder: (context, constraints) {
                  const compactBreakpoint = 220.0;
                  final maxWidth = constraints.maxWidth;
                  final isCompact =
                      maxWidth.isFinite &&
                      maxWidth > 0 &&
                      maxWidth < compactBreakpoint;
                  final horizontalPadding = isCompact
                      ? 12.0
                      : kAgendaControlHorizontalPadding;

                  return Padding(
                    padding: EdgeInsets.symmetric(
                      horizontal: horizontalPadding,
                    ),
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Flexible(
                          child: Text(
                            _getDisplayName(context),
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                        const SizedBox(width: 8),
                        const Icon(Icons.keyboard_arrow_down_rounded, size: 20),
                      ],
                    ),
                  );
                },
              ),
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/app/widgets/staff_circle_avatar.dart ---
import 'package:flutter/material.dart';

String initialsFromName(String name, {int maxChars = 3}) {
  final trimmed = name.trim();
  if (trimmed.isEmpty) return '';
  final parts = trimmed.split(RegExp(r'\s+')).where((p) => p.isNotEmpty).toList();
  var initials = '';
  if (parts.isNotEmpty) {
    initials += parts.first[0].toUpperCase();
  }
  for (int i = 1; i < parts.length && initials.length < maxChars; i++) {
    initials += parts[i][0].toUpperCase();
  }
  if (parts.length == 1 && initials.length < maxChars && trimmed.length > 1) {
    initials += trimmed[1].toUpperCase();
  }
  final end = initials.length.clamp(1, maxChars);
  return initials.substring(0, end);
}

class StaffCircleAvatar extends StatelessWidget {
  final double height;
  final Color color;
  final bool isHighlighted;
  final String initials;
  final Widget? child;

  const StaffCircleAvatar({
    super.key,
    required this.height,
    required this.color,
    required this.isHighlighted,
    required this.initials,
    this.child,
  });

  @override
  Widget build(BuildContext context) {
    final hasThreeLetterInitials = initials.length == 3;
    final initialsFontSize = height * (hasThreeLetterInitials ? 0.30 : 0.35);
    return Container(
      width: height,
      height: height,
      decoration: BoxDecoration(
        shape: BoxShape.circle,
        border: Border.all(
          color: isHighlighted ? color : color.withOpacity(0.35),
          width: isHighlighted ? 2 : 1,
        ),
      ),
      alignment: Alignment.center,
      child: Container(
        margin: const EdgeInsets.all(2),
        decoration: BoxDecoration(
          shape: BoxShape.circle,
          color: color.withOpacity(0.18),
        ),
        alignment: Alignment.center,
        child: Padding(
          padding: EdgeInsets.all(height * 0.06),
          child: FittedBox(
            fit: BoxFit.scaleDown,
            child: child ??
                Text(
                  initials,
                  style: TextStyle(
                    color: color,
                    fontWeight: FontWeight.w600,
                    fontSize: initialsFontSize,
                  ),
                ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/app/widgets/top_controls_scaffold.dart ---
import 'dart:math' as math;

import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/l10n/l10n.dart';
import 'package:agenda_backend/core/models/location.dart';
import 'package:agenda_backend/features/agenda/domain/config/layout_config.dart';
import 'package:agenda_backend/features/agenda/providers/date_range_provider.dart';
import 'package:agenda_backend/features/agenda/providers/layout_config_provider.dart';
import 'package:agenda_backend/features/agenda/providers/location_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

typedef TopControlsBuilderFn =
    Widget Function(BuildContext context, TopControlsData data);

class TopControlsBuilder {
  TopControlsBuilder.single(TopControlsBuilderFn builder)
    : _single = builder,
      mobile = null,
      tablet = null,
      desktop = null;

  TopControlsBuilder.adaptive({this.mobile, this.tablet, this.desktop})
    : _single = null,
      assert(
        mobile != null || tablet != null || desktop != null,
        L10n.current.errorFormFactorBuilderRequired,
      );

  final TopControlsBuilderFn? _single;
  final TopControlsBuilderFn? mobile;
  final TopControlsBuilderFn? tablet;
  final TopControlsBuilderFn? desktop;

  Widget build(BuildContext context, TopControlsData data) {
    if (_single != null) {
      return _single(context, data);
    }
    final builder = _resolve(data.formFactor);
    return builder(context, data);
  }

  TopControlsBuilderFn _resolve(AppFormFactor factor) {
    TopControlsBuilderFn? resolved;
    switch (factor) {
      case AppFormFactor.mobile:
        resolved = mobile ?? tablet ?? desktop;
        break;
      case AppFormFactor.tablet:
        resolved = tablet ?? desktop ?? mobile;
        break;
      case AppFormFactor.desktop:
        resolved = desktop ?? tablet ?? mobile;
        break;
    }
    if (resolved == null) {
      throw StateError(
        L10n.current.errorFormFactorBuilderMissing(factor.name),
      );
    }
    return resolved;
  }
}

class TopControlsData {
  const TopControlsData({
    required this.l10n,
    required this.locale,
    required this.agendaDate,
    required this.layoutConfig,
    required this.formFactor,
    required this.locations,
    required this.currentLocation,
    required this.dateController,
    required this.locationController,
  });

  final L10n l10n;
  final Locale locale;
  final DateTime agendaDate;
  final LayoutConfig layoutConfig;
  final AppFormFactor formFactor;
  final List<Location> locations;
  final Location currentLocation;
  final AgendaDateNotifier dateController;
  final CurrentLocationId locationController;

  bool get isToday => DateUtils.isSameDay(agendaDate, DateTime.now());
}

/// Widget wrapper riutilizzabile per i controlli superiori dell'agenda/staff.
///
/// Si occupa di:
/// - leggere i provider condivisi (data corrente, locations, ecc.)
/// - calcolare gli offset comuni (hour column + navigation rail)
/// - mostrare automaticamente il fallback se non ci sono locations
class TopControlsScaffold extends ConsumerWidget {
  const TopControlsScaffold({
    super.key,
    required this.builder,
    this.alignment = AlignmentDirectional.centerStart,
    this.padding = EdgeInsets.zero,
    this.applyLayoutInset = true,
  });

  final TopControlsBuilder builder;
  final AlignmentGeometry alignment;
  final EdgeInsetsGeometry padding;
  // Permette di applicare l'offset calcolato per allineare ai contenuti
  // principali (hour column + navigation rail). Disattivato di default per
  // far partire i controlli esattamente a sinistra nell'app bar.
  final bool applyLayoutInset;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final layoutConfig = ref.watch(layoutConfigProvider);
    final formFactor = ref.watch(formFactorProvider);
    final locations = ref.watch(locationsProvider);
    if (locations.isEmpty) {
      return Text(l10n.agendaNoLocations);
    }

    final agendaDate = ref.watch(agendaDateProvider);
    final currentLocation = ref.watch(currentLocationProvider);

    final data = TopControlsData(
      l10n: l10n,
      locale: Localizations.localeOf(context),
      agendaDate: agendaDate,
      layoutConfig: layoutConfig,
      formFactor: formFactor,
      locations: locations,
      currentLocation: currentLocation,
      dateController: ref.read(agendaDateProvider.notifier),
      locationController: ref.read(currentLocationIdProvider.notifier),
    );

    final leftInset = applyLayoutInset
        ? _computeLeftInset(context, layoutConfig, formFactor)
        : 0.0;
    Widget child = LayoutBuilder(
      builder: (context, constraints) {
        return builder.build(context, data);
      },
    );

    return Align(
      alignment: alignment,
      child: Padding(
        padding: EdgeInsetsDirectional.only(start: leftInset).add(padding),
        child: child,
      ),
    );
  }

  double _computeLeftInset(
    BuildContext context,
    LayoutConfig layoutConfig,
    AppFormFactor formFactor,
  ) {
    final railTheme = NavigationRailTheme.of(context);
    final railWidth = railTheme.minWidth ?? 72.0;
    const railDividerWidth = 1.0;
    final baseInset =
        layoutConfig.hourColumnWidth - NavigationToolbar.kMiddleSpacing;
    final railInset = formFactor != AppFormFactor.mobile
        ? railWidth + railDividerWidth
        : 0.0;

    return math.max(0.0, baseInset + railInset);
  }
}
--- FILE: lib/features/clients/providers/clients_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/appointment.dart';
import '../../agenda/providers/appointment_providers.dart';
import '../data/clients_repository.dart';
import '../data/mock_clients.dart';
import '../domain/client_sort_option.dart';
import '../domain/clients.dart';

// Repository provider (mock)
final clientsRepositoryProvider = Provider<ClientsRepository>((ref) {
  return ClientsRepository();
});

/// Notifier principale che mantiene la lista clienti.
class ClientsNotifier extends Notifier<List<Client>> {
  int _nextId = 1000;

  @override
  List<Client> build() {
    // Stato iniziale mock
    return kMockClients;
  }

  /// Aggiunge un nuovo cliente e restituisce il client con l'ID assegnato.
  Client addClient(Client client) {
    final newClient = client.copyWith(id: _nextId++, createdAt: DateTime.now());
    state = [...state, newClient];
    return newClient;
  }

  void updateClient(Client client) {
    state = [
      for (final c in state)
        if (c.id == client.id) client else c,
    ];
  }

  void deleteClient(int id) {
    // Soft delete -> isArchived
    state = [
      for (final c in state)
        if (c.id == id) c.copyWith(isArchived: true) else c,
    ];
  }
}

final clientsProvider = NotifierProvider<ClientsNotifier, List<Client>>(
  ClientsNotifier.new,
);

// Indicizzazione rapida per id
final clientsByIdProvider = Provider<Map<int, Client>>((ref) {
  final list = ref.watch(clientsProvider);
  return {for (final c in list) c.id: c};
});

/// Notifier per il criterio di ordinamento corrente
class ClientSortOptionNotifier extends Notifier<ClientSortOption> {
  @override
  ClientSortOption build() => ClientSortOption.nameAsc;

  void set(ClientSortOption option) => state = option;
}

final clientSortOptionProvider =
    NotifierProvider<ClientSortOptionNotifier, ClientSortOption>(
      ClientSortOptionNotifier.new,
    );

/// Ordina una lista di clienti secondo il criterio specificato
List<Client> _sortClients(List<Client> clients, ClientSortOption sort) {
  final sorted = List<Client>.from(clients);

  switch (sort) {
    case ClientSortOption.nameAsc:
      sorted.sort(
        (a, b) => (a.firstName ?? '').toLowerCase().compareTo(
          (b.firstName ?? '').toLowerCase(),
        ),
      );
    case ClientSortOption.nameDesc:
      sorted.sort(
        (a, b) => (b.firstName ?? '').toLowerCase().compareTo(
          (a.firstName ?? '').toLowerCase(),
        ),
      );
    case ClientSortOption.lastNameAsc:
      sorted.sort(
        (a, b) => (a.lastName ?? '').toLowerCase().compareTo(
          (b.lastName ?? '').toLowerCase(),
        ),
      );
    case ClientSortOption.lastNameDesc:
      sorted.sort(
        (a, b) => (b.lastName ?? '').toLowerCase().compareTo(
          (a.lastName ?? '').toLowerCase(),
        ),
      );
    case ClientSortOption.lastVisitDesc:
      sorted.sort((a, b) {
        if (a.lastVisit == null && b.lastVisit == null) return 0;
        if (a.lastVisit == null) return 1;
        if (b.lastVisit == null) return -1;
        return b.lastVisit!.compareTo(a.lastVisit!);
      });
    case ClientSortOption.lastVisitAsc:
      sorted.sort((a, b) {
        if (a.lastVisit == null && b.lastVisit == null) return 0;
        if (a.lastVisit == null) return 1;
        if (b.lastVisit == null) return -1;
        return a.lastVisit!.compareTo(b.lastVisit!);
      });
    case ClientSortOption.createdAtDesc:
      sorted.sort((a, b) => b.createdAt.compareTo(a.createdAt));
    case ClientSortOption.createdAtAsc:
      sorted.sort((a, b) => a.createdAt.compareTo(b.createdAt));
  }

  return sorted;
}

/// Provider che restituisce la lista clienti ordinata secondo il criterio corrente
/// Esclude i clienti archiviati (isArchived = true)
final sortedClientsProvider = Provider<List<Client>>((ref) {
  final clients = ref
      .watch(clientsProvider)
      .where((c) => !c.isArchived)
      .toList();
  final sortOption = ref.watch(clientSortOptionProvider);
  return _sortClients(clients, sortOption);
});

// Ricerca base (case-insensitive su name + email + phone) con ordinamento
// Esclude i clienti archiviati (isArchived = true)
final clientsSearchProvider = Provider.family<List<Client>, String>((ref, q) {
  final sortOption = ref.watch(clientSortOptionProvider);
  final query = q.trim().toLowerCase();

  List<Client> result;
  if (query.isEmpty) {
    result = ref.watch(clientsProvider).where((c) => !c.isArchived).toList();
  } else {
    result = ref
        .watch(clientsProvider)
        .where(
          (c) =>
              !c.isArchived &&
              (c.name.toLowerCase().contains(query) ||
                  (c.email?.toLowerCase().contains(query) ?? false) ||
                  (c.phone?.toLowerCase().contains(query) ?? false)),
        )
        .toList();
  }

  return _sortClients(result, sortOption);
});

// Segmenti
const _kInactiveDays = 90;
const _kNewDays = 45;
const _kFrequentThreshold = 10; // placeholder (in futuro basato su bookings)

DateTime _now() => DateTime.now();

final inactiveClientsProvider = Provider<List<Client>>((ref) {
  final limit = _now().subtract(const Duration(days: _kInactiveDays));
  return ref
      .watch(clientsProvider)
      .where(
        (c) =>
            !c.isArchived &&
            (c.lastVisit == null || c.lastVisit!.isBefore(limit)),
      )
      .toList();
});

final newClientsProvider = Provider<List<Client>>((ref) {
  final limit = _now().subtract(const Duration(days: _kNewDays));
  return ref
      .watch(clientsProvider)
      .where((c) => !c.isArchived && c.createdAt.isAfter(limit))
      .toList();
});

final vipClientsProvider = Provider<List<Client>>((ref) {
  return ref
      .watch(clientsProvider)
      .where((c) => !c.isArchived && (c.tags?.contains('VIP') ?? false))
      .toList();
});

final frequentClientsProvider = Provider<List<Client>>((ref) {
  // Placeholder: usa loyaltyPoints come proxy delle visite
  return ref
      .watch(clientsProvider)
      .where(
        (c) => !c.isArchived && (c.loyaltyPoints ?? 0) >= _kFrequentThreshold,
      )
      .toList();
});

// Collegamenti Booking <-> Client (stub per futura integrazione bookings reali)
final clientWithAppointmentsProvider = Provider.family<List<Appointment>, int>((
  ref,
  clientId,
) {
  final all = ref.watch(appointmentsProvider);
  return all.where((a) => a.clientId == clientId).toList();
});

final bookingIdsByClientProvider = Provider.family<Set<int>, int>((
  ref,
  clientId,
) {
  final appointments = ref.watch(clientWithAppointmentsProvider(clientId));
  return appointments.map((a) => a.bookingId).toSet();
});
--- FILE: lib/features/clients/utils/client_validators.dart ---
// Intenzionalmente vuoto: placeholder per futuri validator dei clients.
--- FILE: lib/features/clients/utils/client_formatters.dart ---
// Intenzionalmente vuoto: placeholder per futuri formatter dei clients.
--- FILE: lib/features/clients/controllers/clients_search_controller.dart ---
// Intenzionalmente vuoto: placeholder per un eventuale controller di ricerca clients (Riverpod).
--- FILE: lib/features/clients/data/clients_api.dart ---
import '../domain/clients.dart';
import 'mock_clients.dart';

/// API layer (mock) - in futuro integrer√† chiamate HTTP.
class ClientsApi {
  Future<List<Client>> fetchClients() async {
    await Future.delayed(const Duration(milliseconds: 150));
    return kMockClients;
  }

  Future<Client> createClient(Client client) async {
    await Future.delayed(const Duration(milliseconds: 120));
    return client; // mock echo
  }

  Future<Client> updateClient(Client client) async {
    await Future.delayed(const Duration(milliseconds: 120));
    return client; // mock echo
  }
}
--- FILE: lib/features/clients/data/clients_repository.dart ---
import '../domain/clients.dart';
import 'clients_api.dart';

class ClientsRepository {
  ClientsRepository({ClientsApi? api}) : _api = api ?? ClientsApi();

  final ClientsApi _api;

  Future<List<Client>> getAll() => _api.fetchClients();
  Future<Client> add(Client client) => _api.createClient(client);
  Future<Client> save(Client client) => _api.updateClient(client);
}
--- FILE: lib/features/clients/data/mock_clients.dart ---
import '../domain/clients.dart';

/// Mock iniziale per sviluppo UI/Provider
final List<Client> kMockClients = [
  Client(
    id: 1,
    businessId: 1,
    firstName: 'Mario',
    lastName: 'Rossi',
    email: 'mario.rossi@example.com',
    phone: '+39 333 1111111',
    city: 'Milano',
    notes: 'Cliente abituale, preferisce mattina',
    createdAt: DateTime.now().subtract(const Duration(days: 200)),
    lastVisit: DateTime.now().subtract(const Duration(days: 7)),
    loyaltyPoints: 120,
    tags: const ['VIP'],
  ),
  Client(
    id: 2,
    businessId: 1,
    firstName: 'Giulia',
    lastName: 'Bianchi',
    email: 'giulia.bianchi@example.com',
    phone: '+39 333 2222222',
    city: 'Torino',
    createdAt: DateTime.now().subtract(const Duration(days: 30)),
    lastVisit: DateTime.now().subtract(const Duration(days: 40)),
    loyaltyPoints: 20,
    tags: const ['Nuovo'],
  ),
  Client(
    id: 3,
    businessId: 1,
    firstName: 'Luca',
    lastName: 'Verdi',
    phone: '+39 333 3333333',
    createdAt: DateTime.now().subtract(const Duration(days: 400)),
    lastVisit: DateTime.now().subtract(const Duration(days: 190)),
    loyaltyPoints: 5,
    tags: const ['Inattivo'],
  ),
];
--- FILE: lib/features/clients/domain/client_sort_option.dart ---
/// Criteri di ordinamento per la lista clienti
enum ClientSortOption {
  /// Ordina per nome (A-Z)
  nameAsc,

  /// Ordina per nome (Z-A)
  nameDesc,

  /// Ordina per cognome (A-Z)
  lastNameAsc,

  /// Ordina per cognome (Z-A)
  lastNameDesc,

  /// Ordina per ultima visita (pi√π recenti prima)
  lastVisitDesc,

  /// Ordina per ultima visita (meno recenti prima)
  lastVisitAsc,

  /// Ordina per data creazione (nuovi prima)
  createdAtDesc,

  /// Ordina per data creazione (vecchi prima)
  createdAtAsc,
}
--- FILE: lib/features/clients/domain/clients.dart ---
class Client {
  final int id;
  final int businessId;
  final String? firstName;
  final String? lastName;
  final String? email;
  final String? phone;
  final String? gender;
  final DateTime? birthDate;
  final String? city;
  final String? notes;
  final DateTime createdAt;
  final DateTime? lastVisit;
  final int? loyaltyPoints;
  final List<String>? tags;
  final bool isArchived;

  const Client({
    required this.id,
    required this.businessId,
    this.firstName,
    this.lastName,
    this.email,
    this.phone,
    this.gender,
    this.birthDate,
    this.city,
    this.notes,
    required this.createdAt,
    this.lastVisit,
    this.loyaltyPoints,
    this.tags,
    this.isArchived = false,
  });

  /// Nome completo (firstName + lastName)
  String get name {
    final parts = <String>[];
    if (firstName != null && firstName!.isNotEmpty) parts.add(firstName!);
    if (lastName != null && lastName!.isNotEmpty) parts.add(lastName!);
    return parts.join(' ');
  }

  /// Prefissi comuni nei cognomi italiani (e alcune varianti internazionali)
  static const _lastNamePrefixes = {
    // Italiani
    'de', 'di', 'da', 'del', 'della', 'delle', 'dei', 'degli',
    'dall', "dall'", 'dalla', 'dallo', 'dalle', 'dagli',
    'la', 'lo', 'li', 'le',
    // Internazionali comuni
    'van', 'von', 'den', 'der', 'ter', 'ten',
    'mc', 'mac', "o'", 'al', 'el', 'ben', 'bin',
  };

  /// Crea un Client a partire da un nome completo, separando automaticamente
  /// nome e cognome. Riconosce cognomi composti con prefissi (es. "La Rosa", "De Luca").
  static ({String? firstName, String? lastName}) splitFullName(
    String fullName,
  ) {
    final trimmed = fullName.trim();
    if (trimmed.isEmpty) {
      return (firstName: null, lastName: null);
    }

    final parts = trimmed.split(RegExp(r'\s+'));
    if (parts.length == 1) {
      // Solo una parola: la consideriamo come firstName
      return (firstName: parts.first, lastName: null);
    }

    if (parts.length == 2) {
      // Due parole: firstName + lastName
      return (firstName: parts[0], lastName: parts[1]);
    }

    // 3+ parole: cerchiamo un prefisso di cognome
    // Partiamo dalla penultima parola e vediamo se √® un prefisso
    int lastNameStartIndex = parts.length - 1;

    for (int i = parts.length - 2; i >= 1; i--) {
      final word = parts[i].toLowerCase().replaceAll("'", "'");
      if (_lastNamePrefixes.contains(word)) {
        lastNameStartIndex = i;
      } else {
        // Se troviamo una parola che non √® un prefisso, ci fermiamo
        break;
      }
    }

    final firstName = parts.sublist(0, lastNameStartIndex).join(' ');
    final lastName = parts.sublist(lastNameStartIndex).join(' ');

    return (firstName: firstName, lastName: lastName);
  }

  Client copyWith({
    int? id,
    int? businessId,
    String? firstName,
    String? lastName,
    String? email,
    String? phone,
    String? gender,
    DateTime? birthDate,
    String? city,
    String? notes,
    DateTime? createdAt,
    DateTime? lastVisit,
    int? loyaltyPoints,
    List<String>? tags,
    bool? isArchived,
  }) {
    return Client(
      id: id ?? this.id,
      businessId: businessId ?? this.businessId,
      firstName: firstName ?? this.firstName,
      lastName: lastName ?? this.lastName,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      gender: gender ?? this.gender,
      birthDate: birthDate ?? this.birthDate,
      city: city ?? this.city,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      lastVisit: lastVisit ?? this.lastVisit,
      loyaltyPoints: loyaltyPoints ?? this.loyaltyPoints,
      tags: tags ?? this.tags,
      isArchived: isArchived ?? this.isArchived,
    );
  }
}
--- FILE: lib/features/clients/presentation/dialogs/client_appointments_dialog.dart ---
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/appointment.dart';
import '../../domain/clients.dart';
import '../../providers/clients_providers.dart';

/// Mostra il dialog con la cronologia appuntamenti del cliente.
Future<void> showClientAppointmentsDialog(
  BuildContext context,
  WidgetRef ref, {
  required Client client,
}) async {
  await showDialog(
    context: context,
    builder: (_) => ClientAppointmentsDialog(client: client),
  );
}

class ClientAppointmentsDialog extends ConsumerWidget {
  const ClientAppointmentsDialog({super.key, required this.client});

  final Client client;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final appointments = ref.watch(clientWithAppointmentsProvider(client.id));
    final now = DateTime.now();

    // Dividi in passati e futuri
    final upcoming =
        appointments.where((a) => a.startTime.isAfter(now)).toList()
          ..sort((a, b) => a.startTime.compareTo(b.startTime));
    final past =
        appointments
            .where((a) => a.startTime.isBefore(now) || a.startTime == now)
            .toList()
          ..sort(
            (a, b) => b.startTime.compareTo(a.startTime),
          ); // pi√π recenti prima

    final screenWidth = MediaQuery.of(context).size.width;
    final dialogWidth = screenWidth < 600 ? screenWidth * 0.95 : 500.0;

    return CallbackShortcuts(
      bindings: <ShortcutActivator, VoidCallback>{
        SingleActivator(LogicalKeyboardKey.escape): () =>
            Navigator.of(context, rootNavigator: true).pop(),
      },
      child: Focus(
        autofocus: true,
        child: AlertDialog(
          title: Text(l10n.clientAppointmentsTitle(client.name)),
          content: SizedBox(
            width: dialogWidth,
            height: 400,
            child: DefaultTabController(
              length: 2,
              child: Column(
                children: [
                  TabBar(
                    tabs: [
                      Tab(
                        text:
                            '${l10n.clientAppointmentsUpcoming} (${upcoming.length})',
                      ),
                      Tab(
                        text: '${l10n.clientAppointmentsPast} (${past.length})',
                      ),
                    ],
                    labelColor: theme.colorScheme.primary,
                    unselectedLabelColor: theme.colorScheme.onSurfaceVariant,
                    indicatorColor: theme.colorScheme.primary,
                  ),
                  const SizedBox(height: 8),
                  Expanded(
                    child: TabBarView(
                      children: [
                        _AppointmentList(
                          appointments: upcoming,
                          emptyMessage: l10n.clientAppointmentsEmpty,
                        ),
                        _AppointmentList(
                          appointments: past,
                          emptyMessage: l10n.clientAppointmentsEmpty,
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: Text(l10n.actionClose),
            ),
          ],
        ),
      ),
    );
  }
}

class _AppointmentList extends ConsumerWidget {
  const _AppointmentList({
    required this.appointments,
    required this.emptyMessage,
  });

  final List<Appointment> appointments;
  final String emptyMessage;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    if (appointments.isEmpty) {
      return Center(
        child: Text(
          emptyMessage,
          style: Theme.of(context).textTheme.bodyMedium?.copyWith(
            color: Theme.of(context).colorScheme.onSurfaceVariant,
          ),
        ),
      );
    }

    return ListView.separated(
      itemCount: appointments.length,
      separatorBuilder: (_, __) => const Divider(height: 1),
      itemBuilder: (context, index) {
        final appointment = appointments[index];
        return _AppointmentTile(appointment: appointment);
      },
    );
  }
}

class _AppointmentTile extends ConsumerWidget {
  const _AppointmentTile({required this.appointment});

  final Appointment appointment;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final locale = Localizations.localeOf(context).toLanguageTag();

    // Recupera staff
    final allStaff = ref.watch(sortedAllStaffProvider);
    final staff = allStaff
        .where((s) => s.id == appointment.staffId)
        .firstOrNull;

    final dateFormat = DateFormat('EEE d MMM', locale);
    final timeFormat = DateFormat('HH:mm', locale);

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Data e ora
          SizedBox(
            width: 90,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  dateFormat.format(appointment.startTime),
                  style: theme.textTheme.bodyMedium?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                Text(
                  timeFormat.format(appointment.startTime),
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(width: 12),
          // Servizio e staff
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  appointment.serviceName,
                  style: theme.textTheme.bodyMedium,
                ),
                if (staff != null)
                  Text(
                    staff.name,
                    style: theme.textTheme.bodySmall?.copyWith(
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
              ],
            ),
          ),
          // Durata
          Text(
            '${appointment.totalDuration} min',
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/clients/presentation/dialogs/client_edit_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../app/theme/app_spacing.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../domain/clients.dart';
import '../../providers/clients_providers.dart';
import '../widgets/client_form.dart';

/// Mostra il dialog per creare o modificare un cliente.
/// Su mobile usa un modal bottom sheet full-screen, su tablet/desktop un dialog.
/// Ritorna il [Client] salvato (creato o modificato), oppure null se annullato.
///
/// Se [client] ha un id <= 0, il dialog sar√† in modalit√† creazione.
/// Se [client] ha un id > 0, il dialog sar√† in modalit√† modifica.
Future<Client?> showClientEditDialog(
  BuildContext context,
  WidgetRef ref, {
  Client? client,
}) async {
  final formFactor = ref.read(formFactorProvider);

  if (formFactor == AppFormFactor.desktop) {
    return await showDialog<Client>(
      context: context,
      barrierDismissible: false,
      builder: (_) => ClientEditDialog(initial: client),
    );
  } else {
    return await AppBottomSheet.show<Client>(
      context: context,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      heightFactor: AppBottomSheet.defaultHeightFactor,
      builder: (_) => ClientEditBottomSheet(initial: client),
    );
  }
}

class ClientEditDialog extends ConsumerStatefulWidget {
  const ClientEditDialog({super.key, this.initial});

  final Client? initial;

  /// Un cliente con id > 0 √® esistente (modifica), altrimenti √® nuovo (creazione).
  bool get isExistingClient => (initial?.id ?? 0) > 0;

  @override
  ConsumerState<ClientEditDialog> createState() => _ClientEditDialogState();
}

class _ClientEditDialogState extends ConsumerState<ClientEditDialog> {
  final _form = GlobalKey<ClientFormState>();
  bool _hasChanges = false;

  @override
  Widget build(BuildContext context) {
    final isEditing = widget.isExistingClient;
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return DismissibleDialog(
      child: Dialog(
        insetPadding: const EdgeInsets.symmetric(horizontal: 32, vertical: 24),
        child: ConstrainedBox(
          constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
          child: Padding(
            padding: const EdgeInsets.all(20),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Text(
                  isEditing ? l10n.clientsEdit : l10n.clientsNew,
                  style: theme.textTheme.headlineSmall,
                ),
                const SizedBox(height: 16),
                Flexible(
                  child: SingleChildScrollView(
                    child: ClientForm(
                      key: _form,
                      initial: widget.initial,
                      onChanged: () {
                        if (!_hasChanges) setState(() => _hasChanges = true);
                      },
                    ),
                  ),
                ),
                const SizedBox(height: 24),
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    if (isEditing) ...[
                      SizedBox(
                        width: AppButtonStyles.dialogButtonWidth,
                        child: AppDangerButton(
                          onPressed: _onDelete,
                          padding: AppButtonStyles.dialogButtonPadding,
                          child: Text(l10n.actionDelete),
                        ),
                      ),
                      const Spacer(),
                    ],
                    SizedBox(
                      width: AppButtonStyles.dialogButtonWidth,
                      child: AppOutlinedActionButton(
                        onPressed: () => _onCancel(context),
                        padding: AppButtonStyles.dialogButtonPadding,
                        child: Text(l10n.actionCancel),
                      ),
                    ),
                    const SizedBox(width: 8),
                    SizedBox(
                      width: AppButtonStyles.dialogButtonWidth,
                      child: AppFilledButton(
                        onPressed: _onSave,
                        padding: AppButtonStyles.dialogButtonPadding,
                        child: Text(l10n.actionSave),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _onCancel(BuildContext context) async {
    if (_hasChanges) {
      final confirm = await showConfirmDialog(
        context,
        title: Text(context.l10n.discardChangesTitle),
        content: Text(context.l10n.discardChangesMessage),
        confirmLabel: context.l10n.actionDiscard,
        cancelLabel: context.l10n.actionKeepEditing,
      );
      if (!confirm) return;
    }
    if (context.mounted) Navigator.of(context).pop();
  }

  Future<void> _onDelete() async {
    final client = widget.initial;
    if (client == null) return;

    final confirm = await showConfirmDialog(
      context,
      title: Text(context.l10n.deleteClientConfirmTitle),
      content: Text(context.l10n.deleteClientConfirmMessage),
      confirmLabel: context.l10n.actionDelete,
      danger: true,
    );
    if (!confirm) return;

    ref.read(clientsProvider.notifier).deleteClient(client.id);
    if (mounted) Navigator.of(context).pop();
  }

  void _onSave() {
    final formState = _form.currentState;
    if (formState == null) return;
    if (!formState.validate()) return;

    final client = formState.buildClient();
    final Client savedClient;
    if (widget.isExistingClient) {
      ref.read(clientsProvider.notifier).updateClient(client);
      savedClient = client;
    } else {
      savedClient = ref.read(clientsProvider.notifier).addClient(client);
    }
    Navigator.of(context).pop(savedClient);
  }
}

/// Bottom sheet per modifica/creazione cliente su mobile.
/// Usa lo stesso layout degli altri bottom sheet dell'app.
class ClientEditBottomSheet extends ConsumerStatefulWidget {
  const ClientEditBottomSheet({super.key, this.initial});

  final Client? initial;

  /// Un cliente con id > 0 √® esistente (modifica), altrimenti √® nuovo (creazione).
  bool get isExistingClient => (initial?.id ?? 0) > 0;

  @override
  ConsumerState<ClientEditBottomSheet> createState() =>
      _ClientEditBottomSheetState();
}

class _ClientEditBottomSheetState extends ConsumerState<ClientEditBottomSheet> {
  final _form = GlobalKey<ClientFormState>();
  bool _hasChanges = false;

  @override
  Widget build(BuildContext context) {
    final isEditing = widget.isExistingClient;
    final l10n = context.l10n;
    final theme = Theme.of(context);

    final title = isEditing ? l10n.clientsEdit : l10n.clientsNew;

    // Azioni in basso - stesso stile di appointment_dialog
    final actions = <Widget>[
      if (isEditing)
        AppDangerButton(
          onPressed: _onDelete,
          padding: AppButtonStyles.dialogButtonPadding,
          child: Text(l10n.actionDelete),
        ),
      AppOutlinedActionButton(
        onPressed: () => _onCancel(context),
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppFilledButton(
        onPressed: _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionSave),
      ),
    ];

    // Usa le stesse dimensioni dei bottoni del dialog appuntamento per
    // mantenere coerenza visiva tra i form.
    final bottomActions = actions
        .map(
          (a) => SizedBox(width: AppButtonStyles.dialogButtonWidth, child: a),
        )
        .toList();

    return SafeArea(
      top: false,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final isKeyboardOpen =
              MediaQuery.of(context).viewInsets.bottom > 0;
          return SizedBox(
            height: constraints.maxHeight,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Expanded(
                  child: SingleChildScrollView(
                    padding: EdgeInsets.only(
                      bottom: 0,
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Padding(
                          padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Padding(
                                padding: const EdgeInsets.only(bottom: 12),
                                child: Text(
                                  title,
                                  style: theme.textTheme.titleLarge,
                                ),
                              ),
                              ClientForm(
                                key: _form,
                                initial: widget.initial,
                                onChanged: () {
                                  if (!_hasChanges) {
                                    setState(() => _hasChanges = true);
                                  }
                                },
                              ),
                              const SizedBox(height: 24),
                              const SizedBox(height: AppSpacing.formRowSpacing),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                if (!isKeyboardOpen) ...[
                  const AppBottomSheetDivider(),
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                    child: Align(
                      alignment: bottomActions.length == 3
                          ? Alignment.center
                          : Alignment.centerRight,
                      child: Wrap(
                        alignment: bottomActions.length == 3
                            ? WrapAlignment.center
                            : WrapAlignment.end,
                        spacing: 8,
                        runSpacing: 8,
                        children: bottomActions,
                      ),
                    ),
                  ),
                ],
                SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
              ],
            ),
          );
        },
      ),
    );
  }

  Future<void> _onCancel(BuildContext context) async {
    if (_hasChanges) {
      final confirm = await showConfirmDialog(
        context,
        title: Text(context.l10n.discardChangesTitle),
        content: Text(context.l10n.discardChangesMessage),
        confirmLabel: context.l10n.actionDiscard,
        cancelLabel: context.l10n.actionKeepEditing,
      );
      if (!confirm) return;
    }
    if (context.mounted) Navigator.of(context).pop();
  }

  Future<void> _onDelete() async {
    final client = widget.initial;
    if (client == null) return;

    final confirm = await showConfirmDialog(
      context,
      title: Text(context.l10n.deleteClientConfirmTitle),
      content: Text(context.l10n.deleteClientConfirmMessage),
      confirmLabel: context.l10n.actionDelete,
      danger: true,
    );
    if (!confirm) return;

    ref.read(clientsProvider.notifier).deleteClient(client.id);
    if (mounted) Navigator.of(context).pop();
  }

  void _onSave() {
    final formState = _form.currentState;
    if (formState == null) return;
    if (!formState.validate()) return;

    final client = formState.buildClient();
    final Client savedClient;
    if (widget.isExistingClient) {
      ref.read(clientsProvider.notifier).updateClient(client);
      savedClient = client;
    } else {
      savedClient = ref.read(clientsProvider.notifier).addClient(client);
    }
    Navigator.of(context).pop(savedClient);
  }
}
--- FILE: lib/features/clients/presentation/clients_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/l10n/l10_extension.dart'; // üåç
import '../providers/clients_providers.dart';
import 'widgets/client_list.dart';
import 'widgets/clients_search_field.dart';
import 'widgets/clients_sort_dropdown.dart';

class ClientsScreen extends ConsumerStatefulWidget {
  const ClientsScreen({super.key});

  @override
  ConsumerState<ClientsScreen> createState() => _ClientsScreenState();
}

class _ClientsScreenState extends ConsumerState<ClientsScreen> {
  String _query = '';
  // int _filterIndex = 0; // 0=all,1=VIP,2=Inactive,3=New

  @override
  Widget build(BuildContext context) {
    final sortOption = ref.watch(clientSortOptionProvider);

    return Scaffold(
      body: Padding(
        padding: const EdgeInsets.fromLTRB(16, 0, 16, 100),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            ClientsSearchField(
              hintText: context.l10n.clientsTitle,
              onChanged: (v) => setState(() => _query = v),
            ),
            const SizedBox(height: 8),
            ClientsSortDropdown(
              value: sortOption,
              onChanged: (v) =>
                  ref.read(clientSortOptionProvider.notifier).set(v),
            ),
            // const SizedBox(height: 8),
            // ClientsFilterChips(
            //   selectedIndex: _filterIndex,
            //   onSelectedIndex: (i) => setState(() => _filterIndex = i),
            //   labelAll: context.l10n.filterAll,
            //   labelVIP: context.l10n.filterVIP,
            //   labelInactive: context.l10n.filterInactive,
            //   labelNew: context.l10n.filterNew,
            // ),
            const SizedBox(height: 8),
            Expanded(child: ClientList(query: _query)),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/clients/presentation/widgets/clients_filter_chips.dart ---
import 'package:flutter/material.dart';

class ClientsFilterChips extends StatelessWidget {
  final int selectedIndex; // 0=all,1=VIP,2=Inactive,3=New
  final ValueChanged<int> onSelectedIndex;
  final String labelAll;
  final String labelVIP;
  final String labelInactive;
  final String labelNew;

  const ClientsFilterChips({
    super.key,
    required this.selectedIndex,
    required this.onSelectedIndex,
    required this.labelAll,
    required this.labelVIP,
    required this.labelInactive,
    required this.labelNew,
  });

  @override
  Widget build(BuildContext context) {
    return SingleChildScrollView(
      scrollDirection: Axis.horizontal,
      child: Wrap(
        spacing: 8,
        children: [
          ChoiceChip(
            label: Text(labelAll),
            selected: selectedIndex == 0,
            onSelected: (_) => onSelectedIndex(0),
          ),
          ChoiceChip(
            label: Text(labelVIP),
            selected: selectedIndex == 1,
            onSelected: (_) => onSelectedIndex(1),
          ),
          ChoiceChip(
            label: Text(labelInactive),
            selected: selectedIndex == 2,
            onSelected: (_) => onSelectedIndex(2),
          ),
          ChoiceChip(
            label: Text(labelNew),
            selected: selectedIndex == 3,
            onSelected: (_) => onSelectedIndex(3),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/clients/presentation/widgets/clients_sort_dropdown.dart ---
import 'package:agenda_backend/app/theme/extensions.dart';
import 'package:agenda_backend/core/widgets/adaptive_dropdown.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../domain/client_sort_option.dart';

/// Dropdown per selezionare il criterio di ordinamento della lista clienti.
class ClientsSortDropdown extends ConsumerStatefulWidget {
  const ClientsSortDropdown({
    super.key,
    required this.value,
    required this.onChanged,
  });

  final ClientSortOption value;
  final ValueChanged<ClientSortOption> onChanged;

  @override
  ConsumerState<ClientsSortDropdown> createState() =>
      _ClientsSortDropdownState();
}

class _ClientsSortDropdownState extends ConsumerState<ClientsSortDropdown> {
  bool _isHovered = false;

  String _getLabel(ClientSortOption option) {
    final l10n = context.l10n;
    switch (option) {
      case ClientSortOption.nameAsc:
        return l10n.sortByNameAsc;
      case ClientSortOption.nameDesc:
        return l10n.sortByNameDesc;
      case ClientSortOption.lastNameAsc:
        return l10n.sortByLastNameAsc;
      case ClientSortOption.lastNameDesc:
        return l10n.sortByLastNameDesc;
      case ClientSortOption.lastVisitDesc:
        return l10n.sortByLastVisitDesc;
      case ClientSortOption.lastVisitAsc:
        return l10n.sortByLastVisitAsc;
      case ClientSortOption.createdAtDesc:
        return l10n.sortByCreatedAtDesc;
      case ClientSortOption.createdAtAsc:
        return l10n.sortByCreatedAtAsc;
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final interactions = theme.extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = _isHovered
        ? Color.alphaBlend(hoverFill, colorScheme.surface)
        : colorScheme.surface;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      child: AdaptiveDropdown<ClientSortOption>(
        items: [
          AdaptiveDropdownItem(
            value: ClientSortOption.nameAsc,
            child: Text(l10n.sortByNameAsc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.nameDesc,
            child: Text(l10n.sortByNameDesc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.lastNameAsc,
            child: Text(l10n.sortByLastNameAsc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.lastNameDesc,
            child: Text(l10n.sortByLastNameDesc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.lastVisitDesc,
            child: Text(l10n.sortByLastVisitDesc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.lastVisitAsc,
            child: Text(l10n.sortByLastVisitAsc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.createdAtDesc,
            child: Text(l10n.sortByCreatedAtDesc),
          ),
          AdaptiveDropdownItem(
            value: ClientSortOption.createdAtAsc,
            child: Text(l10n.sortByCreatedAtAsc),
          ),
        ],
        selectedValue: widget.value,
        onSelected: widget.onChanged,
        modalTitle: l10n.sortByTitle,
        useRootNavigator: true,
        onOpened: () => setState(() => _isHovered = true),
        onClosed: () => setState(() => _isHovered = false),
        popupWidth: 220,
        child: MouseRegion(
          onEnter: (_) {
            if (!_isHovered) setState(() => _isHovered = true);
          },
          onExit: (_) {
            if (_isHovered) setState(() => _isHovered = false);
          },
          child: Container(
            padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            decoration: BoxDecoration(
              color: backgroundColor,
              borderRadius: BorderRadius.circular(8),
              border: Border.all(color: colorScheme.outline.withOpacity(0.2)),
            ),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(Icons.sort, size: 18, color: colorScheme.onSurfaceVariant),
                const SizedBox(width: 8),
                Flexible(
                  child: Text(
                    _getLabel(widget.value),
                    style: theme.textTheme.bodyMedium?.copyWith(
                      color: colorScheme.onSurface,
                    ),
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                const SizedBox(width: 8),
                Icon(
                  Icons.keyboard_arrow_down,
                  size: 20,
                  color: colorScheme.onSurfaceVariant,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/clients/presentation/widgets/client_form.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../app/theme/app_spacing.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/utils/string_utils.dart';
import '../../../../core/widgets/labeled_form_field.dart';
import '../../../../core/widgets/phone_input_field.dart';
import '../../../agenda/providers/business_providers.dart';
import '../../domain/clients.dart';

class ClientForm extends ConsumerStatefulWidget {
  const ClientForm({super.key, this.initial, this.onChanged});

  final Client? initial;
  final VoidCallback? onChanged;

  @override
  ConsumerState<ClientForm> createState() => ClientFormState();
}

class ClientFormState extends ConsumerState<ClientForm> {
  final _formKey = GlobalKey<FormState>();
  final _phoneFieldKey = GlobalKey<PhoneInputFieldState>();

  late final TextEditingController _firstName = TextEditingController(
    text: widget.initial?.firstName ?? '',
  );
  late final TextEditingController _lastName = TextEditingController(
    text: widget.initial?.lastName ?? '',
  );
  late final TextEditingController _email = TextEditingController(
    text: widget.initial?.email ?? '',
  );
  late final TextEditingController _notes = TextEditingController(
    text: widget.initial?.notes ?? '',
  );

  @override
  void dispose() {
    _firstName.dispose();
    _lastName.dispose();
    _email.dispose();
    _notes.dispose();
    super.dispose();
  }

  bool validate() => _formKey.currentState?.validate() ?? false;

  Client buildClient() {
    final base = widget.initial;
    final now = DateTime.now();
    final phoneState = _phoneFieldKey.currentState;
    final fullPhone = phoneState?.fullPhone;

    final firstName = _firstName.text.trim();
    final lastName = _lastName.text.trim();

    return Client(
      id: base?.id ?? -1,
      businessId: base?.businessId ?? ref.read(currentBusinessProvider).id,
      firstName: firstName.isEmpty ? null : StringUtils.toTitleCase(firstName),
      lastName: lastName.isEmpty ? null : StringUtils.toTitleCase(lastName),
      email: _email.text.trim().isEmpty ? null : _email.text.trim(),
      phone: (fullPhone == null || fullPhone.isEmpty) ? null : fullPhone,
      notes: _notes.text.trim().isEmpty ? null : _notes.text.trim(),
      createdAt: base?.createdAt ?? now,
      lastVisit: base?.lastVisit,
      loyaltyPoints: base?.loyaltyPoints,
      tags: base?.tags,
      isArchived: base?.isArchived ?? false,
    );
  }

  @override
  Widget build(BuildContext context) {
    final business = ref.watch(currentBusinessProvider);
    final l10n = context.l10n;
    final formFactor = ref.watch(formFactorProvider);
    final isSingleColumn = formFactor != AppFormFactor.desktop;

    final firstNameField = LabeledFormField(
      label: l10n.formFirstName,
      child: TextFormField(
        controller: _firstName,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        textInputAction: TextInputAction.next,
        textCapitalization: TextCapitalization.words,
        onChanged: (_) {
          _formKey.currentState?.validate();
          widget.onChanged?.call();
        },
        validator: (v) {
          final firstName = v?.trim() ?? '';
          final lastName = _lastName.text.trim();
          if (firstName.isEmpty && lastName.isEmpty) {
            return l10n.validationNameOrLastNameRequired;
          }
          return null;
        },
      ),
    );

    final lastNameField = LabeledFormField(
      label: l10n.formLastName,
      child: TextFormField(
        controller: _lastName,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        textInputAction: TextInputAction.next,
        textCapitalization: TextCapitalization.words,
        onChanged: (_) {
          _formKey.currentState?.validate();
          widget.onChanged?.call();
        },
        validator: (v) {
          final lastName = v?.trim() ?? '';
          final firstName = _firstName.text.trim();
          if (firstName.isEmpty && lastName.isEmpty) {
            return l10n.validationNameOrLastNameRequired;
          }
          return null;
        },
      ),
    );

    final emailField = LabeledFormField(
      label: l10n.formEmail,
      child: TextFormField(
        controller: _email,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        keyboardType: TextInputType.emailAddress,
        textInputAction: TextInputAction.next,
        onChanged: (_) => widget.onChanged?.call(),
        validator: (v) {
          final t = v?.trim() ?? '';
          if (t.isEmpty) return null;
          final emailRegex = RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$');
          if (!emailRegex.hasMatch(t)) {
            return l10n.validationInvalidEmail;
          }
          return null;
        },
      ),
    );

    final phoneField = LabeledFormField(
      label: l10n.formPhone,
      child: PhoneInputField(
        key: _phoneFieldKey,
        defaultPrefix: business.defaultPhonePrefix,
        initialPhone: widget.initial?.phone,
        isDense: true,
        useOutlineBorder: true,
        onChanged: (_) => widget.onChanged?.call(),
        validator: (v) {
          final t = v?.trim().replaceAll(RegExp(r'\s+'), '') ?? '';
          if (t.isEmpty) return null;
          if (!RegExp(r'^\d{6,15}$').hasMatch(t)) {
            return l10n.validationInvalidPhone;
          }
          return null;
        },
      ),
    );

    final notesField = LabeledFormField(
      label: l10n.formNotes,
      child: TextFormField(
        controller: _notes,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        maxLines: 3,
        onChanged: (_) => widget.onChanged?.call(),
      ),
    );

    return Form(
      key: _formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        mainAxisSize: MainAxisSize.min,
        children: [
          if (isSingleColumn) ...[
            firstNameField,
            const SizedBox(height: AppSpacing.formRowSpacing),
            lastNameField,
            const SizedBox(height: AppSpacing.formRowSpacing),
            emailField,
            const SizedBox(height: AppSpacing.formRowSpacing),
            phoneField,
            const SizedBox(height: AppSpacing.formRowSpacing),
            notesField,
          ] else ...[
            // Riga 1: Nome + Cognome
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(child: firstNameField),
                const SizedBox(width: AppSpacing.formFieldSpacing),
                Expanded(child: lastNameField),
              ],
            ),
            const SizedBox(height: AppSpacing.formRowSpacing),

            // Riga 2: Email + Telefono
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(child: emailField),
                const SizedBox(width: AppSpacing.formFieldSpacing),
                Expanded(child: phoneField),
              ],
            ),
            const SizedBox(height: AppSpacing.formRowSpacing),

            // Riga 3: Note (sempre full width)
            notesField,
          ],
        ],
      ),
    );
  }
}
--- FILE: lib/features/clients/presentation/widgets/clients_search_field.dart ---
import 'package:flutter/material.dart';

class ClientsSearchField extends StatelessWidget {
  final String hintText;
  final ValueChanged<String> onChanged;

  const ClientsSearchField({
    super.key,
    required this.hintText,
    required this.onChanged,
  });

  @override
  Widget build(BuildContext context) {
    return TextField(
      decoration: InputDecoration(
        prefixIcon: const Icon(Icons.search),
        hintText: hintText,
        border: const OutlineInputBorder(),
      ),
      onChanged: onChanged,
    );
  }
}
--- FILE: lib/features/clients/presentation/widgets/client_list.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../providers/clients_providers.dart';
import '../dialogs/client_edit_dialog.dart';
import 'client_card.dart';

class ClientList extends ConsumerWidget {
  const ClientList({super.key, required this.query});

  final String query;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final clients = ref.watch(clientsSearchProvider(query));

    if (clients.isEmpty) {
      return Center(child: Text(context.l10n.clientsEmpty));
    }

    final isWide = MediaQuery.of(context).size.width >= 900;
    if (isWide) {
      // Griglia responsive
      return LayoutBuilder(
        builder: (context, constraints) {
          final width = constraints.maxWidth;
          final crossAxisCount = (width / 280).floor().clamp(2, 6);
          return GridView.builder(
            padding: const EdgeInsets.all(12),
            gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: crossAxisCount,
              mainAxisSpacing: 12,
              crossAxisSpacing: 12,
              childAspectRatio: 1.6,
            ),
            itemCount: clients.length,
            itemBuilder: (_, i) {
              final c = clients[i];
              return ClientCard(
                client: c,
                onTap: () => showClientEditDialog(context, ref, client: c),
              );
            },
          );
        },
      );
    }

    // Lista verticale
    return ListView.separated(
      padding: const EdgeInsets.all(12),
      itemBuilder: (_, i) {
        final c = clients[i];
        return ClientCard(
          client: c,
          onTap: () => showClientEditDialog(context, ref, client: c),
        );
      },
      separatorBuilder: (_, __) => const SizedBox(height: 8),
      itemCount: clients.length,
    );
  }
}
--- FILE: lib/features/clients/presentation/widgets/client_card.dart ---
import 'package:flutter/material.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';
import 'package:url_launcher/url_launcher.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../domain/clients.dart';
import '../../providers/clients_providers.dart';
import '../dialogs/client_appointments_dialog.dart';

class ClientCard extends ConsumerWidget {
  const ClientCard({super.key, required this.client, this.onTap});

  final Client client;
  final VoidCallback? onTap;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final scheme = theme.colorScheme;
    //final tags = client.tags ?? const [];
    final email = client.email;
    final phone = client.phone;
    final isEmailValid = email != null && _isValidEmail(email);
    final isPhoneValid = phone != null && _isValidPhone(phone);
    final emailTap = isEmailValid ? () => _openEmail(email) : null;
    final phoneTap = isPhoneValid ? () => _openPhone(phone) : null;
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: theme.cardColor,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: theme.dividerColor.withOpacity(0.4)),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                StaffCircleAvatar(
                  height: 36,
                  color: scheme.primary,
                  isHighlighted: false,
                  initials: client.name.isNotEmpty
                      ? initialsFromName(client.name, maxChars: 2)
                      : '?',
                ),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(client.name, style: theme.textTheme.titleMedium),
                ),
                _DeleteButton(client: client),
              ],
            ),
            const SizedBox(height: 8),
            if (email != null)
              _LinkText(
                text: email,
                onTap: emailTap,
                style: theme.textTheme.bodySmall,
                linkColor: scheme.primary,
              ),
            if (client.email != null && client.phone != null)
              const SizedBox(height: 12),
            if (phone != null)
              _LinkText(
                text: phone,
                onTap: phoneTap,
                style: theme.textTheme.bodySmall,
                linkColor: scheme.primary,
              ),
            // Riga con ultima visita e icona appuntamenti
            Row(
              children: [
                if (client.lastVisit != null)
                  Expanded(
                    child: Padding(
                      padding: const EdgeInsets.only(top: 12),
                      child: Text(
                        _buildLastVisitLabel(context, client.lastVisit!),
                        style: theme.textTheme.labelSmall,
                      ),
                    ),
                  )
                else
                  const Spacer(),
                _AppointmentsButton(client: client),
              ],
            ),
            /*
            if (tags.isNotEmpty)
              Wrap(
                spacing: 4,
                runSpacing: -4,
                children: [
                  for (final t in tags)
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 6,
                        vertical: 2,
                      ),
                      decoration: BoxDecoration(
                        color: theme.colorScheme.secondary.withOpacity(0.2),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: Text(t, style: theme.textTheme.labelSmall),
                    ),
                ],
              ),
            */
          ],
        ),
      ),
    );
  }

  String _buildLastVisitLabel(BuildContext context, DateTime date) {
    final locale = Localizations.localeOf(context).toLanguageTag();
    // Esempio coerente con altre parti dell'app (e.g. staff widgets): d MMM y
    final formatted = DateFormat('d MMM y', locale).format(date);
    return context.l10n.lastVisitLabel(formatted);
  }
}

class _LinkText extends StatelessWidget {
  const _LinkText({
    required this.text,
    required this.onTap,
    required this.style,
    required this.linkColor,
  });

  final String text;
  final VoidCallback? onTap;
  final TextStyle? style;
  final Color linkColor;

  @override
  Widget build(BuildContext context) {
    final effectiveStyle = onTap == null
        ? style
        : style?.copyWith(
                color: linkColor,
                decoration: TextDecoration.underline,
                decorationColor: linkColor,
              ) ??
              TextStyle(
                color: linkColor,
                decoration: TextDecoration.underline,
                decorationColor: linkColor,
              );
    return InkWell(
      onTap: onTap,
      child: Text(text, style: effectiveStyle),
    );
  }
}

bool _isValidEmail(String email) {
  final trimmed = email.trim();
  if (trimmed.isEmpty) return false;
  final emailRegex = RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$');
  return emailRegex.hasMatch(trimmed);
}

bool _isValidPhone(String phone) {
  final trimmed = phone.trim();
  if (trimmed.isEmpty) return false;
  final normalized = trimmed.replaceAll(RegExp(r'\s+'), '');
  final phoneRegex = RegExp(r'^\+?\d{6,15}$');
  return phoneRegex.hasMatch(normalized);
}

Future<void> _openEmail(String email) async {
  final uri = Uri(scheme: 'mailto', path: email.trim());
  await launchUrl(uri, mode: LaunchMode.externalApplication);
}

Future<void> _openPhone(String phone) async {
  final normalized = phone.trim().replaceAll(RegExp(r'\s+'), '');
  final uri = Uri(scheme: 'tel', path: normalized);
  await launchUrl(uri, mode: LaunchMode.externalApplication);
}

class _AppointmentsButton extends ConsumerWidget {
  const _AppointmentsButton({required this.client});

  final Client client;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final appointments = ref.watch(clientWithAppointmentsProvider(client.id));
    final now = DateTime.now();

    final upcoming = appointments.where((a) => a.startTime.isAfter(now)).length;
    final past = appointments.length - upcoming;
    final total = appointments.length;

    return InkWell(
      onTap: () => showClientAppointmentsDialog(context, ref, client: client),
      borderRadius: BorderRadius.circular(8),
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 2),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.calendar_month_outlined,
              size: 18,
              color: theme.colorScheme.primary.withOpacity(0.7),
            ),
            if (total > 0) ...[
              const SizedBox(width: 6),
              // Badge appuntamenti futuri (verde)
              if (upcoming > 0)
                _AppointmentBadge(
                  count: upcoming,
                  color: Colors.green,
                  icon: Icons.arrow_upward,
                ),
              if (upcoming > 0 && past > 0) const SizedBox(width: 4),
              // Badge appuntamenti passati (grigio)
              if (past > 0)
                _AppointmentBadge(
                  count: past,
                  color: theme.colorScheme.onSurfaceVariant,
                  icon: Icons.arrow_downward,
                ),
            ],
          ],
        ),
      ),
    );
  }
}

class _AppointmentBadge extends StatelessWidget {
  const _AppointmentBadge({
    required this.count,
    required this.color,
    required this.icon,
  });

  final int count;
  final Color color;
  final IconData icon;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 4, vertical: 1),
      decoration: BoxDecoration(
        color: color.withOpacity(0.15),
        borderRadius: BorderRadius.circular(4),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 10, color: color),
          const SizedBox(width: 2),
          Text(
            count.toString(),
            style: TextStyle(
              fontSize: 10,
              fontWeight: FontWeight.w600,
              color: color,
            ),
          ),
        ],
      ),
    );
  }
}

class _DeleteButton extends ConsumerWidget {
  const _DeleteButton({required this.client});

  final Client client;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);

    return SizedBox(
      width: 32,
      height: 32,
      child: IconButton(
        padding: EdgeInsets.zero,
        iconSize: 18,
        icon: Icon(
          Icons.delete_outline,
          color: theme.colorScheme.error.withOpacity(0.7),
        ),
        onPressed: () => _onDelete(context, ref),
      ),
    );
  }

  Future<void> _onDelete(BuildContext context, WidgetRef ref) async {
    final confirm = await showConfirmDialog(
      context,
      title: Text(context.l10n.deleteClientConfirmTitle),
      content: Text(context.l10n.deleteClientConfirmMessage),
      confirmLabel: context.l10n.actionDelete,
      danger: true,
    );
    if (!confirm) return;

    ref.read(clientsProvider.notifier).deleteClient(client.id);
  }
}
--- FILE: lib/features/business/providers/business_providers.dart ---
--- FILE: lib/features/business/data/business_api.dart ---
--- FILE: lib/features/business/data/business_repository.dart ---
--- FILE: lib/features/business/domain/business.dart ---
--- FILE: lib/features/business/presentation/business_screen.dart ---
--- FILE: lib/features/agenda/providers/dragged_appointment_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Tiene traccia dell‚Äôappuntamento attualmente trascinato.
/// Nessun delay: il fantasma scompare subito al rilascio.
class DraggedAppointmentIdNotifier extends Notifier<int?> {
  @override
  int? build() => null;

  /// Imposta l'ID dell'appuntamento trascinato
  void set(int id) => state = id;

  /// Cancella immediatamente il fantasma
  void clear() => state = null;
}

final draggedAppointmentIdProvider =
    NotifierProvider<DraggedAppointmentIdNotifier, int?>(
      DraggedAppointmentIdNotifier.new,
    );
--- FILE: lib/features/agenda/providers/layout_config_provider.dart ---
import 'dart:async';
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../domain/config/agenda_theme.dart';
import '../domain/config/layout_config.dart';

part 'layout_config_provider.g.dart';

/// Mantiene aggiornata la configurazione del layout agenda (slot/header/hour column).
@riverpod
class LayoutConfigNotifier extends _$LayoutConfigNotifier {
  Timer? _resizeDebounce;

  @override
  LayoutConfig build() {
    ref.onDispose(() {
      _resizeDebounce?.cancel();
    });
    final dispatcher = WidgetsBinding.instance.platformDispatcher;
    final view = dispatcher.implicitView;
    final logicalSize = view != null
        ? Size(
            view.physicalSize.width / view.devicePixelRatio,
            view.physicalSize.height / view.devicePixelRatio,
          )
        : ui.window.physicalSize / ui.window.devicePixelRatio;

    final initialHeaderHeight = logicalSize.width > 0
        ? LayoutConfig.headerHeightForWidth(logicalSize.width)
        : LayoutConfig.defaultHeaderHeight;
    final initialSlotHeight = logicalSize.height > 0
        ? _deriveSlotHeight(logicalSize.height)
        : LayoutConfig.defaultSlotHeight;
    final initialHourWidth = _initialHourColumnWidth();

    return LayoutConfig.initial.copyWith(
      headerHeight: initialHeaderHeight,
      slotHeight: initialSlotHeight,
      hourColumnWidth: initialHourWidth,
    );
  }

  /// Aggiorna dinamicamente l‚Äôaltezza degli slot e dell‚Äôheader
  /// in base alle dimensioni della finestra.
  void updateFromContext(BuildContext context) {
    _resizeDebounce?.cancel();

    final size = MediaQuery.of(context).size;
    final screenWidth = size.width;
    final screenHeight = size.height;

    _resizeDebounce = Timer(const Duration(milliseconds: 100), () {
      final next = state.copyWith(
        slotHeight: _deriveSlotHeight(screenHeight),
        headerHeight: _deriveHeaderHeight(screenWidth),
        hourColumnWidth: _deriveHourColumnWidth(context),
      );

      if (next != state) {
        state = next;
      }
    });
  }

  double _deriveSlotHeight(double screenHeight) {
    if (screenHeight < 700) {
      return LayoutConfig.defaultSlotHeight * 0.8;
    }
    if (screenHeight > 1200) {
      return LayoutConfig.defaultSlotHeight * 1.2;
    }
    return LayoutConfig.defaultSlotHeight;
  }

  double _deriveHeaderHeight(double screenWidth) =>
      LayoutConfig.headerHeightForWidth(screenWidth);

  double _initialHourColumnWidth() {
    const textDirection = TextDirection.ltr;
    const style = AgendaTheme.hourTextStyle;
    return _computeHourColumnWidth(style, textDirection);
  }

  double _deriveHourColumnWidth(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final style = textTheme.bodyMedium ?? AgendaTheme.hourTextStyle;
    final textDirection = Directionality.maybeOf(context) ?? TextDirection.ltr;

    return _computeHourColumnWidth(style, textDirection);
  }

  double _computeHourColumnWidth(TextStyle style, TextDirection textDirection) {
    final painter = TextPainter(
      text: TextSpan(text: '23:59', style: style),
      textDirection: textDirection,
      maxLines: 1,
    )..layout();

    final baseWidth = painter.width;
    const extraPadding = LayoutConfig.horizontalPadding;
    const safety = 6.0; // margine ridotto oltre il testo

    final computed = baseWidth + extraPadding + safety;
    return computed.clamp(48.0, 80.0);
  }

  /// Aggiorna i minuti per slot in base alla scelta utente.
  void setMinutesPerSlot(int minutes) {
    if (!LayoutConfig.isValidSlotDuration(minutes)) {
      return;
    }

    if (state.minutesPerSlot == minutes) {
      return;
    }

    state = state.copyWith(minutesPerSlot: minutes);
  }

  /// Permette di scegliere se usare la larghezza uniforme sul picco di overlap.
  void setUseClusterMaxConcurrency(bool enabled) {
    if (state.useClusterMaxConcurrency == enabled) {
      return;
    }
    state = state.copyWith(useClusterMaxConcurrency: enabled);
  }

  /// Permette di scegliere se usare il colore del servizio per le card.
  void setUseServiceColors(bool enabled) {
    if (state.useServiceColorsForAppointments == enabled) {
      return;
    }
    state = state.copyWith(useServiceColorsForAppointments: enabled);
  }

  /// Permette di mostrare la label del pulsante "Aggiungi" in topbar.
  void setShowTopbarAddLabel(bool enabled) {
    if (state.showTopbarAddLabel == enabled) {
      return;
    }
    state = state.copyWith(showTopbarAddLabel: enabled);
  }
}
--- FILE: lib/features/agenda/providers/highlighted_staff_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Tiene traccia dello staff evidenziato durante il drag
class HighlightedStaffIdNotifier extends Notifier<int?> {
  @override
  int? build() => null;

  void set(int? id) => state = id;
  void clear() => state = null;
}

final highlightedStaffIdProvider =
    NotifierProvider<HighlightedStaffIdNotifier, int?>(
      HighlightedStaffIdNotifier.new,
    );
--- FILE: lib/features/agenda/providers/dragged_last_staff_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Tiene traccia dell'ultima colonna staff attraversata durante il drag.
class DraggedLastStaffNotifier extends Notifier<int?> {
  @override
  int? build() => null;

  void set(int staffId) => state = staffId;
  void clear() => state = null;
}

final draggedLastStaffIdProvider =
    NotifierProvider<DraggedLastStaffNotifier, int?>(
      DraggedLastStaffNotifier.new,
    );
--- FILE: lib/features/agenda/providers/drag_offset_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Distanza verticale (in px) tra il punto di presa e il bordo superiore della card
class DragOffsetNotifier extends Notifier<double?> {
  @override
  double? build() => null;

  void set(double value) => state = value;
  void clear() => state = null;
}

final dragOffsetProvider = NotifierProvider<DragOffsetNotifier, double?>(
  DragOffsetNotifier.new,
);

/// üîπ Distanza orizzontale (in px) tra il punto di presa e il bordo sinistro della card
class DragOffsetXNotifier extends Notifier<double?> {
  @override
  double? build() => null;

  void set(double value) => state = value;
  void clear() => state = null;
}

final dragOffsetXProvider = NotifierProvider<DragOffsetXNotifier, double?>(
  DragOffsetXNotifier.new,
);
--- FILE: lib/features/agenda/providers/layout_config_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'layout_config_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning
/// Mantiene aggiornata la configurazione del layout agenda (slot/header/hour column).

@ProviderFor(LayoutConfigNotifier)
const layoutConfigProvider = LayoutConfigNotifierProvider._();

/// Mantiene aggiornata la configurazione del layout agenda (slot/header/hour column).
final class LayoutConfigNotifierProvider
    extends $NotifierProvider<LayoutConfigNotifier, LayoutConfig> {
  /// Mantiene aggiornata la configurazione del layout agenda (slot/header/hour column).
  const LayoutConfigNotifierProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'layoutConfigProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$layoutConfigNotifierHash();

  @$internal
  @override
  LayoutConfigNotifier create() => LayoutConfigNotifier();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(LayoutConfig value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<LayoutConfig>(value),
    );
  }
}

String _$layoutConfigNotifierHash() =>
    r'30d9d7d00aa145e8a8d9750ddce9a06dfc207ecd';

/// Mantiene aggiornata la configurazione del layout agenda (slot/header/hour column).

abstract class _$LayoutConfigNotifier extends $Notifier<LayoutConfig> {
  LayoutConfig build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<LayoutConfig, LayoutConfig>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<LayoutConfig, LayoutConfig>,
              LayoutConfig,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/features/agenda/providers/dragged_card_size_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Tiene la dimensione (Size) della card attualmente trascinata.
/// Serve per calcolare correttamente la percentuale di overlap orizzontale.
class DraggedCardSizeNotifier extends Notifier<Size?> {
  @override
  Size? build() => null;

  void set(Size size) => state = size;
  void clear() => state = null;
}

final draggedCardSizeProvider =
    NotifierProvider<DraggedCardSizeNotifier, Size?>(
      DraggedCardSizeNotifier.new,
    );
--- FILE: lib/features/agenda/providers/drag_session_provider.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

@immutable
class DragSessionState {
  const DragSessionState({
    this.id,
    this.dropHandled = false,
  });

  final int? id;
  final bool dropHandled;

  DragSessionState copyWith({
    int? id,
    bool? dropHandled,
  }) {
    return DragSessionState(
      id: id ?? this.id,
      dropHandled: dropHandled ?? this.dropHandled,
    );
  }
}

class DragSessionNotifier extends Notifier<DragSessionState> {
  int _counter = 0;

  @override
  DragSessionState build() => const DragSessionState();

  int start() {
    final id = ++_counter;
    state = DragSessionState(id: id, dropHandled: false);
    return id;
  }

  void markHandled() {
    if (state.id == null) return;
    state = state.copyWith(dropHandled: true);
  }

  void clear() {
    state = const DragSessionState();
  }
}

final dragSessionProvider =
    NotifierProvider<DragSessionNotifier, DragSessionState>(
  DragSessionNotifier.new,
);
--- FILE: lib/features/agenda/providers/location_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/location.dart';
import '../../agenda/providers/business_providers.dart';

///
/// üîπ ELENCO LOCATIONS (mock statiche)
///
class LocationsNotifier extends Notifier<List<Location>> {
  @override
  List<Location> build() {
    final business = ref.watch(currentBusinessProvider);
    return [
      Location(
        id: 101,
        businessId: business.id,
        name: 'Sede Centrale',
        address: 'Via Roma 12',
        city: 'Roma',
        region: 'Lazio',
        country: 'Italia',
        phone: '+39 06 1234567',
        email: 'roma@azienda.it',
        latitude: 41.9028,
        longitude: 12.4964,
        currency: 'EUR', // üîπ Valuta locale per la sede
        isDefault: true, // ‚úÖ aggiunto per default
      ),
      Location(
        id: 102,
        businessId: business.id,
        name: 'Filiale Estera',
        address: 'Main Street 22',
        city: 'Lugano',
        region: 'TI',
        country: 'Svizzera',
        phone: '+41 91 654321',
        email: 'lugano@azienda.ch',
        latitude: 46.0037,
        longitude: 8.9511,
        currency: 'CHF', // üîπ Valuta diversa (franchi svizzeri)
        isDefault: false,
      ),
    ];
  }

  void add(Location location) {
    state = [...state, location];
  }

  void update(Location updated) {
    state = [
      for (final l in state)
        if (l.id == updated.id) updated else l,
    ];
  }

  void delete(int id) {
    final currentId = ref.read(currentLocationIdProvider);
    state = state.where((l) => l.id != id).toList();
    if (state.isEmpty) return;
    if (currentId == id) {
      ref.read(currentLocationIdProvider.notifier).set(state.first.id);
    }
  }

  void reorder(int oldIndex, int newIndex) {
    if (newIndex > oldIndex) newIndex -= 1;
    final list = [...state];
    final item = list.removeAt(oldIndex);
    list.insert(newIndex, item);
    state = list;
  }

  int nextId() {
    if (state.isEmpty) return 1;
    final maxId = state.map((l) => l.id).reduce((a, b) => a > b ? a : b);
    return maxId + 1;
  }
}

final locationsProvider = NotifierProvider<LocationsNotifier, List<Location>>(
  LocationsNotifier.new,
);

///
/// üîπ LOCATION CORRENTE
///
class CurrentLocationId extends Notifier<int> {
  @override
  int build() {
    final locations = ref.read(locationsProvider);
    return locations
        .firstWhere((l) => l.isDefault, orElse: () => locations.first)
        .id;
  }

  void set(int id) => state = id;
}

final currentLocationIdProvider = NotifierProvider<CurrentLocationId, int>(
  CurrentLocationId.new,
);

final currentLocationProvider = Provider<Location>((ref) {
  final locations = ref.watch(locationsProvider);
  final currentId = ref.watch(currentLocationIdProvider);
  return locations.firstWhere((l) => l.id == currentId);
});

///
/// üîπ VALUTA EFFETTIVA DELLA LOCATION CORRENTE
///
/// Se la location ha una valuta specifica, viene usata.
/// Altrimenti eredita quella del business.
///
final effectiveCurrencyProvider = Provider<String>((ref) {
  final location = ref.watch(currentLocationProvider);
  final business = ref.watch(currentBusinessProvider);
  return location.currency ?? business.currency;
});
--- FILE: lib/features/agenda/providers/business_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/business.dart';

///
/// üîπ ELENCO BUSINESS (mock statico)
///
final businessesProvider = Provider<List<Business>>((ref) {
  return [
    Business(
      id: 1,
      name: 'Centro Massaggi La Rosa',
      createdAt: DateTime(2021, 3, 12),
      currency: 'EUR',
      defaultPhonePrefix: '+39',
    ),
    Business(
      id: 2,
      name: 'Wellness Global Spa',
      createdAt: DateTime(2022, 1, 20),
      currency: 'USD',
      defaultPhonePrefix: '+1',
    ),
  ];
});

///
/// üîπ BUSINESS CORRENTE (ID)
///
class CurrentBusinessId extends Notifier<int> {
  @override
  int build() {
    final businesses = ref.read(businessesProvider);
    // ‚úÖ Imposta come default il primo business disponibile
    return businesses.first.id;
  }

  void set(int id) => state = id;
}

final currentBusinessIdProvider = NotifierProvider<CurrentBusinessId, int>(
  CurrentBusinessId.new,
);

///
/// üîπ BUSINESS CORRENTE (oggetto)
///
final currentBusinessProvider = Provider<Business>((ref) {
  final businesses = ref.watch(businessesProvider);
  final currentId = ref.watch(currentBusinessIdProvider);
  return businesses.firstWhere((b) => b.id == currentId);
});
--- FILE: lib/features/agenda/providers/appointment_providers.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/appointment.dart';
import '../../clients/providers/clients_providers.dart';
import '../../services/providers/services_provider.dart';
import 'bookings_provider.dart';
import 'business_providers.dart';
import 'date_range_provider.dart';
import 'location_providers.dart';

/// Arrotonda un DateTime ai 5 minuti pi√π vicini.
/// Es: 10:12 ‚Üí 10:10, 10:13 ‚Üí 10:15
DateTime _roundToNearestFiveMinutes(DateTime dt) {
  final minutes = dt.minute;
  final roundedMinutes = ((minutes + 2) ~/ 5) * 5;
  return DateTime(
    dt.year,
    dt.month,
    dt.day,
    dt.hour,
    0,
  ).add(Duration(minutes: roundedMinutes));
}

class AppointmentsNotifier extends Notifier<List<Appointment>> {
  bool _initialized = false;

  @override
  List<Appointment> build() {
    if (!_initialized) {
      _initialized = true;
      state = _mockAppointments();
    }
    return state;
  }

  List<Appointment> _mockAppointments() {
    final business = ref.read(currentBusinessProvider);
    final location = ref.read(currentLocationProvider);

    final now = DateTime.now();
    // Arrotonda l'orario corrente ai 5 minuti pi√π vicini
    final roundedMinute = ((now.minute + 2) ~/ 5) * 5;
    final start = DateTime(
      now.year,
      now.month,
      now.day,
      now.hour,
      0,
    ).add(Duration(minutes: roundedMinute));
    final end = start.add(const Duration(minutes: 30));
    final endWithBlocked = end.add(const Duration(minutes: 10));

    return [
      Appointment(
        id: 1,
        bookingId: 100000,
        businessId: business.id,
        locationId: location.id,
        staffId: 1,
        serviceId: 1,
        serviceVariantId: 900001,
        clientId: 1,
        clientName: 'Mario Rossi',
        serviceName: 'Massaggio Relax',
        startTime: start,
        endTime: endWithBlocked,
        price: 45,
        extraBlockedMinutes: 10,
      ),
      Appointment(
        id: 2,
        bookingId: 100001,
        businessId: business.id,
        locationId: location.id,
        staffId: 4,
        serviceId: 2,
        serviceVariantId: 900002,
        clientId: 2,
        clientName: 'Giulia Bianchi',
        serviceName: 'Massaggio Sportivo',
        startTime: start.add(const Duration(hours: 3)),
        endTime: start.add(const Duration(hours: 3, minutes: 45)),
        price: 62,
        extraMinutes: 0,
        extraMinutesType: null,
      ),
      Appointment(
        id: 3,
        bookingId: 100002,
        businessId: business.id,
        locationId: location.id,
        staffId: 1,
        serviceId: 3,
        serviceVariantId: 900003,
        clientId: 3,
        clientName: 'Luca Verdi',
        serviceName: 'Trattamento Viso',
        startTime: start.add(const Duration(hours: 4)),
        endTime: start.add(const Duration(hours: 4, minutes: 40)),
        price: 55,
        extraMinutes: 0,
        extraMinutesType: null,
      ),
      Appointment(
        id: 4,
        bookingId: 100003,
        businessId: business.id,
        locationId: location.id,
        staffId: 2,
        serviceId: 4,
        serviceVariantId: 900004,
        clientId: 4,
        clientName: 'Sara Neri',
        serviceName: 'Trattamenti Corpo 2',
        startTime: start.add(const Duration(hours: 5)),
        endTime: start.add(const Duration(hours: 5, minutes: 30)),
        price: 50,
        extraProcessingMinutes: 10,
      ),
      Appointment(
        id: 5,
        bookingId: 100004,
        businessId: business.id,
        locationId: location.id,
        staffId: 1,
        serviceId: 4,
        serviceVariantId: 900004,
        clientId: 5,
        clientName: 'Paolo Ricci',
        serviceName: 'Trattamenti Corpo 2',
        startTime: start.add(const Duration(hours: 1)),
        endTime: start.add(const Duration(hours: 1, minutes: 30)),
        price: 50,
        extraProcessingMinutes: 10,
      ),
    ];
  }

  /*
  List<Appointment> _mockAppointments() {
    final business = ref.read(currentBusinessProvider);

    const seeds = [
      _StaffScheduleSeed(
        staffId: 1,
        locationIds: [101],
        serviceId: 1,
        serviceVariantId: 900001,
        serviceName: 'Massaggio Relax',
        basePrice: 45,
      ),
      _StaffScheduleSeed(
        staffId: 2,
        locationIds: [102],
        serviceId: 1,
        serviceVariantId: 900001,
        serviceName: 'Trattamento Viso',
        basePrice: 48,
      ),
      _StaffScheduleSeed(
        staffId: 3,
        locationIds: [101, 102],
        serviceId: 2,
        serviceVariantId: 900002,
        serviceName: 'Massaggio Sportivo',
        basePrice: 60,
      ),
      _StaffScheduleSeed(
        staffId: 4,
        locationIds: [101],
        serviceId: 3,
        serviceVariantId: 900003,
        serviceName: 'Hair Styling',
        basePrice: 50,
      ),
      _StaffScheduleSeed(
        staffId: 2,
        locationIds: [102],
        serviceId: 4,
        serviceVariantId: 900004,
        serviceName: 'Taglio & Barba',
        basePrice: 42,
      ),
    ];

    final random = Random(202511);
    const int slotsPerDay = 8;
    final startDate = DateTime(2025, 11, 1);
    const int totalDays = 30;

    final appointments = <Appointment>[];
    var appointmentId = 1;
    var bookingId = 100000;

    for (int dayOffset = 0; dayOffset < totalDays; dayOffset++) {
      final dayDate = startDate.add(Duration(days: dayOffset));
      for (final seed in seeds) {
        final locationIds = seed.locationIds;
        final locationId = locationIds.length == 1
            ? locationIds.first
            : locationIds[dayOffset % locationIds.length];

        int generated = 0;
        while (generated < slotsPerDay) {
          final startMinute =
              8 * 60 + random.nextInt(10 * 60); // tra 08:00 e 18:00
          final roundedStartMinute = (startMinute / 5).round() * 5;
          final durationMinutes = 15 * (1 + random.nextInt(8)); // 15-120
          final start = dayDate.add(Duration(minutes: roundedStartMinute));
          final end = start.add(Duration(minutes: durationMinutes));

          final currentBookingId = bookingId++;
          final clientId = (generated % 3) + 1; // associa mock clientId ciclico
          final clientBaseName =
              'Cliente ${seed.staffId}-${dayDate.day}-${generated + 1}';

          appointments.add(
            Appointment(
              id: appointmentId++,
              bookingId: currentBookingId,
              businessId: business.id,
              locationId: locationId,
              staffId: seed.staffId,
              serviceId: seed.serviceId,
              serviceVariantId: seed.serviceVariantId,
              clientId: clientId,
              clientName: clientBaseName,
              serviceName: seed.serviceName,
              startTime: start,
              endTime: end,
              price: seed.basePrice + generated,
            ),
          );
          generated++;

          final bool createPair =
              generated < slotsPerDay && random.nextDouble() < 0.3;
          if (createPair) {
            final separationMinutes = 15 * random.nextInt(3); // 0,15,30
            final secondStart = end.add(Duration(minutes: separationMinutes));
            final secondDurationMinutes =
                15 * (1 + random.nextInt(8)); // 15-120 minuti
            final secondEnd = secondStart.add(
              Duration(minutes: secondDurationMinutes),
            );

            final clientId2 = ((generated + 1) % 3) + 1;
            appointments.add(
              Appointment(
                id: appointmentId++,
                bookingId: currentBookingId,
                businessId: business.id,
                locationId: locationId,
                staffId: seed.staffId,
                serviceId: seed.serviceId,
                serviceVariantId: seed.serviceVariantId,
                clientId: clientId2,
                clientName: clientBaseName,
                serviceName: '${seed.serviceName} (Follow-up)',
                startTime: secondStart,
                endTime: secondEnd,
                price: seed.basePrice + generated,
              ),
            );
            generated++;
          }
        }
      }
    }

    return appointments;
  }
*/

  /// Restituisce gli appointments associati a un booking specifico,
  /// ordinati per orario di inizio.
  List<Appointment> getByBookingId(int bookingId) {
    return state.where((a) => a.bookingId == bookingId).toList()
      ..sort((a, b) => a.startTime.compareTo(b.startTime));
  }

  void moveAppointment({
    required int appointmentId,
    required int newStaffId,
    required DateTime newStart,
    required DateTime newEnd,
  }) async {
    // Arrotonda gli orari a multipli di 5 minuti
    final roundedStart = _roundToNearestFiveMinutes(newStart);
    final duration = newEnd.difference(newStart);
    final roundedEnd = roundedStart.add(duration);

    state = [
      for (final appt in state)
        if (appt.id == appointmentId)
          _applyResizeToAppointment(
            appt,
            staffId: newStaffId,
            startTime: roundedStart,
            endTime: roundedEnd,
          )
        else
          appt,
    ];
    await Future.delayed(Duration.zero);
  }

  Appointment _applyResizeToAppointment(
    Appointment appt, {
    required int staffId,
    required DateTime startTime,
    required DateTime endTime,
  }) {
    final oldTotalMinutes = appt.endTime.difference(appt.startTime).inMinutes;
    final newTotalMinutes = endTime.difference(startTime).inMinutes;
    final oldBlocked = appt.blockedExtraMinutes;
    final baseMinutes = oldTotalMinutes - oldBlocked;

    int newBlocked = oldBlocked;
    if (newTotalMinutes <= baseMinutes) {
      newBlocked = 0;
    } else {
      newBlocked = newTotalMinutes - baseMinutes;
    }

    final processingMinutes = appt.processingExtraMinutes;
    final extraMinutesType = newBlocked > 0
        ? ExtraMinutesType.blocked
        : (processingMinutes > 0 ? ExtraMinutesType.processing : null);
    final extraMinutes = extraMinutesType == ExtraMinutesType.blocked
        ? newBlocked
        : (extraMinutesType == ExtraMinutesType.processing
              ? processingMinutes
              : null);

    return appt.copyWith(
      staffId: staffId,
      startTime: startTime,
      endTime: endTime,
      extraMinutes: extraMinutes,
      extraMinutesType: extraMinutesType,
      extraBlockedMinutes: newBlocked,
      extraProcessingMinutes: processingMinutes,
    );
  }

  void deleteAppointment(int appointmentId) {
    int? relatedBookingId;
    for (final appt in state) {
      if (appt.id == appointmentId) {
        relatedBookingId = appt.bookingId;
        break;
      }
    }

    state = [
      for (final appt in state)
        if (appt.id != appointmentId) appt,
    ];

    if (relatedBookingId != null) {
      ref.read(bookingsProvider.notifier).removeIfEmpty(relatedBookingId);
    }
  }

  /// Aggiunge un nuovo appuntamento generando id e bookingId
  Appointment addAppointment({
    int? bookingId,
    required int staffId,
    required int serviceId,
    required int serviceVariantId,
    int? clientId,
    required String clientName,
    required String serviceName,
    required DateTime start,
    required DateTime end,
    double? price,
    int? extraMinutes,
    ExtraMinutesType? extraMinutesType,
    int? extraBlockedMinutes,
    int? extraProcessingMinutes,
  }) {
    final business = ref.read(currentBusinessProvider);
    final location = ref.read(currentLocationProvider);

    // Arrotonda gli orari a multipli di 5 minuti
    final roundedStart = _roundToNearestFiveMinutes(start);
    final duration = end.difference(start);
    final roundedEnd = roundedStart.add(duration);

    final nextId = state.isEmpty
        ? 1
        : state.map((e) => e.id).reduce((a, b) => a > b ? a : b) + 1;
    final nextBookingId =
        bookingId ??
        (state.isEmpty
            ? 100000
            : state.map((e) => e.bookingId).reduce((a, b) => a > b ? a : b) +
                  1);

    final appt = Appointment(
      id: nextId,
      bookingId: nextBookingId,
      businessId: business.id,
      locationId: location.id,
      staffId: staffId,
      serviceId: serviceId,
      serviceVariantId: serviceVariantId,
      clientId: clientId,
      clientName: clientName,
      serviceName: serviceName,
      startTime: roundedStart,
      endTime: roundedEnd,
      price: price,
      extraMinutes: extraMinutes,
      extraMinutesType: extraMinutesType,
      extraBlockedMinutes: extraBlockedMinutes,
      extraProcessingMinutes: extraProcessingMinutes,
    );

    state = [...state, appt];
    // ensure booking metadata exists
    ref
        .read(bookingsProvider.notifier)
        .ensureBooking(
          bookingId: nextBookingId,
          businessId: business.id,
          locationId: location.id,
          clientId: clientId,
          customerName: clientName,
        );
    return appt;
  }

  /// Aggiorna un appuntamento esistente (match per id)
  void updateAppointment(Appointment updated) {
    // Arrotonda gli orari a multipli di 5 minuti
    final roundedStart = _roundToNearestFiveMinutes(updated.startTime);
    final duration = updated.endTime.difference(updated.startTime);
    final roundedEnd = roundedStart.add(duration);
    final roundedAppointment = updated.copyWith(
      startTime: roundedStart,
      endTime: roundedEnd,
    );

    state = [
      for (final appt in state)
        if (appt.id == updated.id) roundedAppointment else appt,
    ];
  }

  /// Aggiorna il cliente di tutti gli appuntamenti di una prenotazione.
  void updateClientForBooking({
    required int bookingId,
    required int? clientId,
    required String clientName,
  }) {
    state = [
      for (final appt in state)
        if (appt.bookingId == bookingId)
          appt.copyWith(clientId: clientId, clientName: clientName)
        else
          appt,
    ];
  }

  /// Duplica un appuntamento assegnando un nuovo id e bookingId
  Appointment duplicateAppointment(
    Appointment original, {
    bool intoSameBooking = true,
  }) {
    final nextId = state.isEmpty
        ? 1
        : state.map((e) => e.id).reduce((a, b) => a > b ? a : b) + 1;
    final nextBookingId = intoSameBooking
        ? original.bookingId
        : (state.isEmpty
              ? 100000
              : state.map((e) => e.bookingId).reduce((a, b) => a > b ? a : b) +
                    1);

    final copy = original.copyWith(
      id: nextId,
      bookingId: nextBookingId,
      clientName: original.clientName,
      serviceName: original.serviceName,
    );
    state = [...state, copy];

    if (!intoSameBooking) {
      ref
          .read(bookingsProvider.notifier)
          .ensureBooking(
            bookingId: nextBookingId,
            businessId: original.businessId,
            locationId: original.locationId,
            clientId: original.clientId,
            customerName: original.clientName,
          );
    }
    return copy;
  }

  /// Cancella tutti gli appuntamenti appartenenti a una prenotazione.
  void deleteByBooking(int bookingId) {
    state = [
      for (final appt in state)
        if (appt.bookingId != bookingId) appt,
    ];
  }

  /// Crea rapidamente una prenotazione per un client con valori di default
  /// - Usa la sede corrente e la data corrente dell'agenda
  /// - Sceglie la prima variante servizio disponibile per la sede
  /// - Sceglie il primo staff idoneo per quel servizio
  /// - Orario: prossimo slot di 15 minuti a partire da adesso (limitato al giorno corrente)
  /// Restituisce l'appuntamento creato.
  Appointment? createQuickBookingForClient(int clientId) {
    final clientsById = ref.read(clientsByIdProvider);
    final client = clientsById[clientId];
    if (client == null) return null;

    final business = ref.read(currentBusinessProvider);
    final location = ref.read(currentLocationProvider);
    final agendaDate = ref.read(agendaDateProvider);
    final variants = ref.read(serviceVariantsProvider);
    if (variants.isEmpty) return null;
    final variant = variants.first;

    // Staff idoneo per il servizio e sede corrente
    final eligibleStaff = ref.read(
      eligibleStaffForServiceProvider(variant.serviceId),
    );
    if (eligibleStaff.isEmpty) return null;
    final staffId = eligibleStaff.first;

    // Orario: prossimo quarto d'ora oggi alle max 18:00
    final now = DateTime.now();
    final dayStart = DateUtils.dateOnly(agendaDate);
    DateTime base = now.isBefore(dayStart) ? dayStart : now;
    // clamp to today end
    final dayEnd = dayStart.add(const Duration(days: 1));
    if (base.isAfter(dayEnd)) base = dayStart.add(const Duration(hours: 10));
    final minutes = base.minute;
    final rounded = minutes % 15 == 0
        ? base
        : base.add(Duration(minutes: 15 - (minutes % 15)));
    final start = DateTime(
      dayStart.year,
      dayStart.month,
      dayStart.day,
      rounded.hour,
      rounded.minute,
    );
    final end = start.add(Duration(minutes: variant.durationMinutes));

    // Genera id
    final nextId = state.isEmpty
        ? 1
        : state.map((e) => e.id).reduce((a, b) => a > b ? a : b) + 1;
    final nextBookingId = state.isEmpty
        ? 100000
        : state.map((e) => e.bookingId).reduce((a, b) => a > b ? a : b) + 1;

    final appt = Appointment(
      id: nextId,
      bookingId: nextBookingId,
      businessId: business.id,
      locationId: location.id,
      staffId: staffId,
      serviceId: variant.serviceId,
      serviceVariantId: variant.id,
      clientId: client.id,
      clientName: client.name,
      serviceName: '',
      startTime: start,
      endTime: end,
      price: variant.price,
    );

    state = [...state, appt];
    ref
        .read(bookingsProvider.notifier)
        .ensureBooking(
          bookingId: nextBookingId,
          businessId: business.id,
          locationId: location.id,
          clientId: client.id,
          customerName: client.name,
        );
    return appt;
  }
}

final appointmentsProvider =
    NotifierProvider<AppointmentsNotifier, List<Appointment>>(
      AppointmentsNotifier.new,
    );

final appointmentsForCurrentLocationProvider = Provider<List<Appointment>>((
  ref,
) {
  final location = ref.watch(currentLocationProvider);
  final currentDate = ref.watch(agendaDateProvider);
  final dayStart = DateUtils.dateOnly(currentDate);
  final dayEnd = dayStart.add(const Duration(days: 1));
  final appointments = ref.watch(appointmentsProvider);
  return [
    for (final appt in appointments)
      if (appt.locationId == location.id &&
          !appt.endTime.isBefore(dayStart) &&
          appt.startTime.isBefore(dayEnd))
        appt,
  ];
});
--- FILE: lib/features/agenda/providers/date_range_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class AgendaDateNotifier extends Notifier<DateTime> {
  @override
  DateTime build() {
    final initial = DateUtils.dateOnly(DateTime.now());
    return initial;
  }

  void set(DateTime date) {
    final next = DateUtils.dateOnly(date);
    state = next;
  }

  void nextDay() {
    final next = DateUtils.dateOnly(state.add(const Duration(days: 1)));
    state = next;
  }

  void nextWeek() {
    final next = DateUtils.dateOnly(state.add(const Duration(days: 7)));
    state = next;
  }

  void previousDay() {
    final next = DateUtils.dateOnly(state.subtract(const Duration(days: 1)));
    state = next;
  }

  void previousWeek() {
    final next = DateUtils.dateOnly(state.subtract(const Duration(days: 7)));
    state = next;
  }

  void nextMonth() => _shiftMonths(1);

  void previousMonth() => _shiftMonths(-1);

  void _shiftMonths(int delta) {
    final y = state.year;
    final m = state.month;
    final d = state.day;

    // Convert to absolute month index to avoid loop and off-by-one issues
    final abs = y * 12 + (m - 1) + delta;
    final targetYear = abs ~/ 12;
    final targetMonth = (abs % 12) + 1; // back to 1..12

    final dim = DateUtils.getDaysInMonth(targetYear, targetMonth);
    final int safeDay = d <= dim ? d : dim;
    state = DateUtils.dateOnly(DateTime(targetYear, targetMonth, safeDay));
  }

  void setToday() {
    final today = DateUtils.dateOnly(DateTime.now());
    state = today;
  }
}

final agendaDateProvider = NotifierProvider<AgendaDateNotifier, DateTime>(
  AgendaDateNotifier.new,
);
--- FILE: lib/features/agenda/providers/resource_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/appointment.dart';
import '../../../core/models/resource.dart';
import '../../../core/models/service_variant.dart';
import '../../../core/models/service_variant_resource_requirement.dart';
import '../../services/providers/services_provider.dart';
import 'appointment_providers.dart';
import 'location_providers.dart';

///
/// RISORSE (mock + CRUD in memoria)
///
class ResourcesNotifier extends Notifier<List<Resource>> {
  @override
  List<Resource> build() {
    final locations = ref.read(locationsProvider);
    if (locations.isEmpty) return const [];

    final firstLocationId = locations.first.id;
    final secondLocationId =
        locations.length > 1 ? locations[1].id : firstLocationId;

    return [
      // Risorse per sede principale
      Resource(
        id: 1,
        locationId: firstLocationId,
        name: 'Cabina Relax 1',
        quantity: 1,
        type: 'room',
        note: null,
      ),
      Resource(
        id: 2,
        locationId: firstLocationId,
        name: 'Cabina Relax 2',
        quantity: 1,
        type: 'room',
        note: null,
      ),
      Resource(
        id: 3,
        locationId: firstLocationId,
        name: 'Postazione Viso 1',
        quantity: 2,
        type: 'station',
        note: null,
      ),
      // Risorse per seconda sede
      Resource(
        id: 4,
        locationId: secondLocationId,
        name: 'Cabina Relax A',
        quantity: 1,
        type: 'room',
        note: null,
      ),
      Resource(
        id: 5,
        locationId: secondLocationId,
        name: 'Cabina Relax B',
        quantity: 1,
        type: 'room',
        note: null,
      ),
      Resource(
        id: 6,
        locationId: secondLocationId,
        name: 'Postazione Viso 2',
        quantity: 2,
        type: 'station',
        note: null,
      ),
    ];
  }

  void add(Resource resource) {
    state = [...state, resource];
  }

  void update(Resource updated) {
    state = [
      for (final r in state)
        if (r.id == updated.id) updated else r,
    ];
  }

  void delete(int id) {
    state = [
      for (final r in state)
        if (r.id != id) r,
    ];
  }
}

final resourcesProvider =
    NotifierProvider<ResourcesNotifier, List<Resource>>(ResourcesNotifier.new);

///
/// RISORSE PER LOCATION
///
final locationResourcesProvider = Provider.family<List<Resource>, int>((
  ref,
  locationId,
) {
  final resources = ref.watch(resourcesProvider);
  return [
    for (final r in resources)
      if (r.locationId == locationId) r,
  ];
});

///
/// REQUISITI RISORSE PER SERVICE VARIANT
///
final serviceVariantResourcesProvider =
    Provider.family<List<ServiceVariantResourceRequirement>, int>((
      ref,
      serviceVariantId,
    ) {
  final variant = ref.watch(serviceVariantByIdProvider(serviceVariantId));
  return variant?.resourceRequirements ?? const [];
});

typedef ResourceBookingsParams = ({int resourceId, DateTime day});

///
/// APPOINTMENT CHE OCCUPANO UNA RISORSA IN UN GIORNO
///
final resourceBookingsProvider =
    Provider.family<List<Appointment>, ResourceBookingsParams>((
      ref,
      params,
    ) {
  final resourceId = params.resourceId;
  final day = params.day;

  final dayStart = DateTime(day.year, day.month, day.day);
  final dayEnd = dayStart.add(const Duration(days: 1));

  final appointments = ref.watch(appointmentsProvider);
  final variants = ref.watch(serviceVariantsProvider);

  final variantById = <int, ServiceVariant>{
    for (final v in variants) v.id: v,
  };

  bool usesResource(Appointment appt) {
    final variant = variantById[appt.serviceVariantId];
    if (variant == null) return false;
    for (final req in variant.resourceRequirements) {
      if (req.resourceId == resourceId) return true;
    }
    return false;
  }

  return [
    for (final appt in appointments)
      if (!appt.endTime.isBefore(dayStart) &&
          appt.startTime.isBefore(dayEnd) &&
          usesResource(appt))
        appt,
  ];
});

typedef ResourceAvailabilityParams = ({
  int serviceVariantId,
  int staffId,
  DateTime start,
  DateTime end,
});

///
/// DISPONIBILIT√Ä RISORSE PER UN NUOVO APPUNTAMENTO
///
final resourceAvailabilityProvider =
    Provider.family<bool, ResourceAvailabilityParams>((
      ref,
      params,
    ) {
  final serviceVariantId = params.serviceVariantId;
  final start = params.start;
  final end = params.end;

  final variants = ref.watch(serviceVariantsProvider);
  ServiceVariant? currentVariant;
  for (final v in variants) {
    if (v.id == serviceVariantId) {
      currentVariant = v;
      break;
    }
  }

  final requirements = currentVariant?.resourceRequirements ?? const [];
  if (requirements.isEmpty) return true;

  final allResources = ref.watch(resourcesProvider);
  final resourceById = <int, Resource>{
    for (final r in allResources) r.id: r,
  };

  final requirementsByVariantId =
      <int, List<ServiceVariantResourceRequirement>>{
    for (final v in variants) v.id: v.resourceRequirements,
  };

  int unitsForAppointment(int resourceId, Appointment appt) {
    final reqs = requirementsByVariantId[appt.serviceVariantId];
    if (reqs == null) return 0;
    for (final req in reqs) {
      if (req.resourceId == resourceId) {
        return req.unitsRequired;
      }
    }
    return 0;
  }

  for (final req in requirements) {
    final resource = resourceById[req.resourceId];
    if (resource == null) {
      continue;
    }

    final bookings = ref.watch(
      resourceBookingsProvider((resourceId: req.resourceId, day: start)),
    );

    var usedUnits = 0;
    for (final appt in bookings) {
      final hasOverlap =
          appt.endTime.isAfter(start) && appt.startTime.isBefore(end);
      if (!hasOverlap) continue;

      usedUnits += unitsForAppointment(req.resourceId, appt);
    }

    if (usedUnits + req.unitsRequired > resource.quantity) {
      return false;
    }
  }

  return true;
});

--- FILE: lib/features/agenda/providers/is_resizing_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Provider che tiene traccia se si sta ridimensionando una AppointmentCard.
/// Utilizzato per bloccare lo scroll verticale delle colonne durante il resize.
class IsResizingNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  void start() => state = true;
  void stop() => state = false;
}

final isResizingProvider = NotifierProvider<IsResizingNotifier, bool>(
  IsResizingNotifier.new,
);
--- FILE: lib/features/agenda/providers/time_blocks_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/time_block.dart';
import 'business_providers.dart';
import 'date_range_provider.dart';
import 'location_providers.dart';

class TimeBlocksNotifier extends Notifier<List<TimeBlock>> {
  bool _initialized = false;

  @override
  List<TimeBlock> build() {
    if (!_initialized) {
      _initialized = true;
      state = _mockTimeBlocks();
    }
    return state;
  }

  List<TimeBlock> _mockTimeBlocks() {
    // Nessun blocco di default
    return [];
  }

  /// Aggiunge un nuovo blocco di non disponibilit√†.
  TimeBlock addBlock({
    required List<int> staffIds,
    required DateTime startTime,
    required DateTime endTime,
    String? reason,
    bool isAllDay = false,
  }) {
    final business = ref.read(currentBusinessProvider);
    final location = ref.read(currentLocationProvider);

    final nextId = state.isEmpty
        ? 1
        : state.map((e) => e.id).reduce((a, b) => a > b ? a : b) + 1;

    final block = TimeBlock(
      id: nextId,
      businessId: business.id,
      locationId: location.id,
      staffIds: staffIds,
      startTime: startTime,
      endTime: endTime,
      reason: reason,
      isAllDay: isAllDay,
    );

    state = [...state, block];
    return block;
  }

  /// Aggiorna un blocco esistente.
  void updateBlock(TimeBlock updated) {
    state = [
      for (final block in state)
        if (block.id == updated.id) updated else block,
    ];
  }

  /// Elimina un blocco per id.
  void deleteBlock(int blockId) {
    state = [
      for (final block in state)
        if (block.id != blockId) block,
    ];
  }

  /// Sposta un blocco a un nuovo orario.
  void moveBlock({
    required int blockId,
    required DateTime newStart,
    required DateTime newEnd,
  }) {
    state = [
      for (final block in state)
        if (block.id == blockId)
          block.copyWith(startTime: newStart, endTime: newEnd)
        else
          block,
    ];
  }

  /// Modifica gli staff assegnati a un blocco.
  void updateBlockStaff({required int blockId, required List<int> staffIds}) {
    state = [
      for (final block in state)
        if (block.id == blockId) block.copyWith(staffIds: staffIds) else block,
    ];
  }
}

final timeBlocksProvider =
    NotifierProvider<TimeBlocksNotifier, List<TimeBlock>>(
      TimeBlocksNotifier.new,
    );

/// Blocchi filtrati per la sede corrente e la data corrente dell'agenda.
final timeBlocksForCurrentLocationProvider = Provider<List<TimeBlock>>((ref) {
  final location = ref.watch(currentLocationProvider);
  final currentDate = ref.watch(agendaDateProvider);
  final dayStart = DateUtils.dateOnly(currentDate);
  final dayEnd = dayStart.add(const Duration(days: 1));
  final blocks = ref.watch(timeBlocksProvider);

  return [
    for (final block in blocks)
      if (block.locationId == location.id &&
          !block.endTime.isBefore(dayStart) &&
          block.startTime.isBefore(dayEnd))
        block,
  ];
});

/// Blocchi per uno staff specifico nella data corrente dell'agenda.
final timeBlocksForStaffProvider = Provider.family<List<TimeBlock>, int>((
  ref,
  staffId,
) {
  final blocks = ref.watch(timeBlocksForCurrentLocationProvider);
  return [
    for (final block in blocks)
      if (block.includesStaff(staffId)) block,
  ];
});
--- FILE: lib/features/agenda/providers/resizing_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Dati della sessione di resize per un singolo appuntamento.
class _ResizingEntry {
  final double baseHeightPx;
  final DateTime startTimeInitial;
  final DateTime endTimeInitial;
  final double currentPreviewHeightPx;
  final DateTime provisionalEndTime;

  const _ResizingEntry({
    required this.baseHeightPx,
    required this.startTimeInitial,
    required this.endTimeInitial,
    required this.currentPreviewHeightPx,
    required this.provisionalEndTime,
  });

  _ResizingEntry copyWith({
    double? baseHeightPx,
    DateTime? startTimeInitial,
    DateTime? endTimeInitial,
    double? currentPreviewHeightPx,
    DateTime? provisionalEndTime,
  }) {
    return _ResizingEntry(
      baseHeightPx: baseHeightPx ?? this.baseHeightPx,
      startTimeInitial: startTimeInitial ?? this.startTimeInitial,
      endTimeInitial: endTimeInitial ?? this.endTimeInitial,
      currentPreviewHeightPx:
          currentPreviewHeightPx ?? this.currentPreviewHeightPx,
      provisionalEndTime: provisionalEndTime ?? this.provisionalEndTime,
    );
  }
}

/// Stato globale del resize (pi√π entry contemporanee per staff multipli).
class ResizingState {
  final Map<int, _ResizingEntry> entries;
  final bool isResizing;

  const ResizingState({this.entries = const {}, this.isResizing = false});

  const ResizingState.initial() : entries = const {}, isResizing = false;

  ResizingState copyWith({
    Map<int, _ResizingEntry>? entries,
    bool? isResizing,
  }) {
    return ResizingState(
      entries: entries ?? this.entries,
      isResizing: isResizing ?? this.isResizing,
    );
  }
}

/// Gestore centralizzato dei resize attivi.
class ResizingNotifier extends Notifier<ResizingState> {
  @override
  ResizingState build() => const ResizingState.initial();

  /// Avvia una nuova sessione di resize per una card specifica.
  void startResize({
    required int appointmentId,
    required double currentHeightPx,
    required DateTime startTime,
    required DateTime endTime,
  }) {
    // üîπ Reset completo della base e altezza provvisoria
    final newEntry = _ResizingEntry(
      baseHeightPx: currentHeightPx,
      startTimeInitial: startTime,
      endTimeInitial: endTime,
      currentPreviewHeightPx: currentHeightPx,
      provisionalEndTime: endTime,
    );

    // üîπ Aggiorna solo la entry corrente senza cancellare le altre
    final updated = Map<int, _ResizingEntry>.from(state.entries);
    updated[appointmentId] = newEntry;

    state = state.copyWith(entries: updated, isResizing: true);
  }

  /// Aggiornamento live durante il drag del bordo inferiore.
  void updateDuringResize({
    required int appointmentId,
    required double deltaDy,
    required double pixelsPerMinute,
    required DateTime dayEnd,
    required int minDurationMinutes,
    required int snapMinutes,
  }) {
    final entry = state.entries[appointmentId];
    if (entry == null) return;

    // üîπ Calcola nuova altezza cumulativa a partire dall'altezza corrente
    double proposedHeightPx = entry.currentPreviewHeightPx + deltaDy;

    final minHeightPx = minDurationMinutes * pixelsPerMinute;
    final rawMaxDurationMinutes =
        dayEnd.difference(entry.startTimeInitial).inMinutes;
    final effectiveMaxDurationMinutes = rawMaxDurationMinutes <= 0
        ? minDurationMinutes
        : rawMaxDurationMinutes < minDurationMinutes
            ? minDurationMinutes
            : rawMaxDurationMinutes;
    final maxHeightPx = effectiveMaxDurationMinutes * pixelsPerMinute;

    // üîπ Applica i limiti min/max consentiti
    proposedHeightPx = proposedHeightPx.clamp(minHeightPx, maxHeightPx).toDouble();

    final proposedDurationMinutes = proposedHeightPx / pixelsPerMinute;

    // üîπ Snap ai minuti impostati solo per il calcolo dell'end time
    final lowerBoundMinutes = minDurationMinutes.toDouble();
    final upperBoundMinutes = effectiveMaxDurationMinutes.toDouble();

    final snappedMinutes = _snapToStep(
      proposedDurationMinutes,
      snapMinutes,
    ).clamp(
      lowerBoundMinutes,
      upperBoundMinutes < lowerBoundMinutes
          ? lowerBoundMinutes
          : upperBoundMinutes,
    );

    // üîπ Nuovo end provvisorio (clamp a fine giornata se necessario)
    DateTime candidateEnd = entry.startTimeInitial.add(
      Duration(minutes: snappedMinutes.round()),
    );
    if (candidateEnd.isAfter(dayEnd)) {
      candidateEnd = dayEnd;
    }

    final updatedEntry = entry.copyWith(
      currentPreviewHeightPx: proposedHeightPx,
      provisionalEndTime: candidateEnd,
    );

    final updated = Map<int, _ResizingEntry>.from(state.entries);
    updated[appointmentId] = updatedEntry;

    state = state.copyWith(entries: updated, isResizing: true);
  }

  /// Conclude il resize e restituisce il nuovo endTime definitivo.
  DateTime? commitResizeAndEnd({required int appointmentId}) {
    final entry = state.entries[appointmentId];
    final finalEnd = entry?.provisionalEndTime;
    if (entry == null) return null;

    // üîπ Prima di rimuovere, resetta la preview height alla base originale
    final resetEntry = entry.copyWith(
      currentPreviewHeightPx: entry.baseHeightPx,
    );

    final updated = Map<int, _ResizingEntry>.from(state.entries);
    updated[appointmentId] = resetEntry;
    updated.remove(appointmentId);

    state = state.copyWith(entries: updated, isResizing: updated.isNotEmpty);

    return finalEnd;
  }

  /// Annulla un resize senza commit.
  void cancelResize({required int appointmentId}) {
    final updated = Map<int, _ResizingEntry>.from(state.entries);
    updated.remove(appointmentId);
    state = state.copyWith(entries: updated, isResizing: updated.isNotEmpty);
  }

  /// Accessori utili.
  double? previewHeightFor(int appointmentId) =>
      state.entries[appointmentId]?.currentPreviewHeightPx;

  DateTime? previewEndTimeFor(int appointmentId) =>
      state.entries[appointmentId]?.provisionalEndTime;

  double _snapToStep(double minutes, int step) {
    if (step <= 1) return minutes;
    final m = minutes / step;
    final rounded = m.round();
    return (rounded * step).toDouble();
  }
}

/// Provider principale di stato di resize.
final resizingProvider = NotifierProvider<ResizingNotifier, ResizingState>(
  ResizingNotifier.new,
);

/// Provider per una singola entry di appointment.
final resizingEntryProvider = Provider.family<_ResizingEntry?, int>(
  (ref, appointmentId) => ref.watch(resizingProvider).entries[appointmentId],
);
--- FILE: lib/features/agenda/providers/fully_occupied_slots_provider.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

import 'appointment_providers.dart';
import 'date_range_provider.dart';
import 'layout_config_provider.dart';

part 'fully_occupied_slots_provider.g.dart';

/// Calcola gli indici degli slot completamente occupati per un dato staff.
/// Uno slot √® "completamente occupato" quando la somma delle frazioni di larghezza
/// degli appuntamenti che lo coprono raggiunge o supera il 100%.
@riverpod
Set<int> fullyOccupiedSlots(Ref ref, int staffId) {
  final appointments = ref
      .watch(appointmentsForCurrentLocationProvider)
      .where((a) => a.staffId == staffId)
      .toList();

  if (appointments.isEmpty) return const {};

  final layoutConfig = ref.watch(layoutConfigProvider);
  final agendaDate = ref.watch(agendaDateProvider);
  final minutesPerSlot = layoutConfig.minutesPerSlot;
  final totalSlots = layoutConfig.totalSlots;

  // Calcola la geometria degli appuntamenti per determinare le frazioni di larghezza
  final layoutEntries = appointments
      .map((a) => _LayoutEntry(id: a.id, start: a.startTime, end: a.endTime))
      .toList();

  final geometryMap = _computeLayoutGeometry(
    layoutEntries,
    useClusterMaxConcurrency: layoutConfig.useClusterMaxConcurrency,
  );

  // Per ogni slot, calcola la somma delle frazioni di larghezza coperte
  final fullyOccupied = <int>{};

  for (int slotIndex = 0; slotIndex < totalSlots; slotIndex++) {
    final slotStart = agendaDate.add(
      Duration(minutes: slotIndex * minutesPerSlot),
    );
    final slotEnd = slotStart.add(Duration(minutes: minutesPerSlot));

    // Trova tutti gli appuntamenti che coprono questo slot
    double totalWidthFraction = 0.0;

    for (final appt in appointments) {
      // Verifica se l'appuntamento copre lo slot
      if (appt.startTime.isBefore(slotEnd) && appt.endTime.isAfter(slotStart)) {
        final geometry = geometryMap[appt.id];
        if (geometry != null) {
          totalWidthFraction += geometry.widthFraction;
        }
      }
    }

    // Lo slot √® completamente occupato se la somma >= 1.0 (100%)
    if (totalWidthFraction >= 0.999) {
      fullyOccupied.add(slotIndex);
    }
  }

  return fullyOccupied;
}

// ‚îÄ‚îÄ Classi helper per il calcolo della geometria ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class _LayoutEntry {
  const _LayoutEntry({
    required this.id,
    required this.start,
    required this.end,
  });

  final int id;
  final DateTime start;
  final DateTime end;
}

class _EventGeometry {
  const _EventGeometry({
    required this.leftFraction,
    required this.widthFraction,
  });

  final double leftFraction;
  final double widthFraction;
}

/// Versione semplificata del layout geometry helper.
Map<int, _EventGeometry> _computeLayoutGeometry(
  List<_LayoutEntry> entries, {
  bool useClusterMaxConcurrency = false,
}) {
  if (entries.isEmpty) return const {};

  final sorted = entries.toList()..sort((a, b) => a.start.compareTo(b.start));

  final clusters = <List<_LayoutEntry>>[];
  var currentCluster = <_LayoutEntry>[];
  DateTime? currentMaxEnd;

  for (final entry in sorted) {
    if (currentCluster.isEmpty) {
      currentCluster = [entry];
      currentMaxEnd = entry.end;
      continue;
    }

    if (entry.start.isBefore(currentMaxEnd!)) {
      currentCluster.add(entry);
      if (entry.end.isAfter(currentMaxEnd)) {
        currentMaxEnd = entry.end;
      }
    } else {
      clusters.add(List<_LayoutEntry>.from(currentCluster));
      currentCluster = [entry];
      currentMaxEnd = entry.end;
    }
  }

  if (currentCluster.isNotEmpty) {
    clusters.add(List<_LayoutEntry>.from(currentCluster));
  }

  final geometryMap = <int, _EventGeometry>{};

  for (final cluster in clusters) {
    final concurrencyMap = _computeConcurrency(cluster);

    for (final entry in cluster) {
      final concurrency = concurrencyMap[entry.id] ?? 1;
      final widthFraction = 1 / concurrency;
      geometryMap[entry.id] = _EventGeometry(
        leftFraction: 0, // Non ci serve leftFraction per questo calcolo
        widthFraction: widthFraction,
      );
    }
  }

  return geometryMap;
}

Map<int, int> _computeConcurrency(List<_LayoutEntry> cluster) {
  final result = <int, int>{};

  for (final entry in cluster) {
    int count = 0;
    for (final other in cluster) {
      if (entry.start.isBefore(other.end) && entry.end.isAfter(other.start)) {
        count++;
      }
    }
    result[entry.id] = count;
  }

  return result;
}
--- FILE: lib/features/agenda/providers/dragged_base_range_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Mantiene l'intervallo originale (start, end) della card che sta per
/// essere trascinata. Serve per evitare fallback arbitrari durante il ghost.
class DraggedBaseRangeNotifier extends Notifier<(DateTime, DateTime)?> {
  @override
  (DateTime, DateTime)? build() => null;

  void set(DateTime start, DateTime end) => state = (start, end);
  void clear() => state = null;
}

final draggedBaseRangeProvider =
    NotifierProvider<DraggedBaseRangeNotifier, (DateTime, DateTime)?>(
      DraggedBaseRangeNotifier.new,
    );
--- FILE: lib/features/agenda/providers/bookings_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/booking.dart';
import 'appointment_providers.dart';
import 'business_providers.dart';
import 'location_providers.dart';

class BookingSummary {
  final int bookingId;
  final int itemsCount;
  final double totalPrice;
  final DateTime? start;
  final DateTime? end;

  const BookingSummary({
    required this.bookingId,
    required this.itemsCount,
    required this.totalPrice,
    required this.start,
    required this.end,
  });
}

/// Gestisce i metadati delle prenotazioni (note, customerName, ecc.) e
/// coordina le operazioni di alto livello (cancellazione prenotazione intera).
class BookingsNotifier extends Notifier<Map<int, Booking>> {
  int _nextId = 1;

  @override
  Map<int, Booking> build() => <int, Booking>{};

  /// Crea una nuova prenotazione e restituisce il suo ID.
  int createBooking({int? clientId, String? customerName, String? notes}) {
    final business = ref.read(currentBusinessProvider);
    final location = ref.read(currentLocationProvider);

    final bookingId = _nextId++;
    state = {
      ...state,
      bookingId: Booking(
        id: bookingId,
        businessId: business.id,
        locationId: location.id,
        clientId: clientId,
        customerName: customerName,
        notes: notes,
      ),
    };
    return bookingId;
  }

  /// Crea la prenotazione se non esiste gi√† (idempotente).
  void ensureBooking({
    required int bookingId,
    required int businessId,
    required int locationId,
    int? clientId,
    required String customerName,
  }) {
    final current = state;
    if (current.containsKey(bookingId)) return;
    state = {
      ...current,
      bookingId: Booking(
        id: bookingId,
        businessId: businessId,
        locationId: locationId,
        clientId: clientId,
        customerName: customerName,
        notes: null,
      ),
    };
  }

  void setNotes(int bookingId, String? notes) {
    final bk = state[bookingId];
    if (bk == null) return;
    state = {
      for (final e in state.entries)
        e.key: e.key == bookingId
            ? Booking(
                id: bk.id,
                businessId: bk.businessId,
                locationId: bk.locationId,
                clientId: bk.clientId,
                customerName: bk.customerName,
                notes: notes,
              )
            : e.value,
    };
  }

  /// Cancella l'intera prenotazione e tutti i suoi appuntamenti.
  void deleteBooking(int bookingId) {
    // Aggiorna appuntamenti in cascata
    ref.read(appointmentsProvider.notifier).deleteByBooking(bookingId);
    // Rimuovi metadati prenotazione
    final copy = Map<int, Booking>.from(state);
    copy.remove(bookingId);
    state = copy;
  }

  /// Rimuove la prenotazione se non ha pi√π appuntamenti.
  void removeIfEmpty(int bookingId) {
    final appts = ref.read(appointmentsProvider);
    if (appts.any((a) => a.bookingId == bookingId)) return;
    final copy = Map<int, Booking>.from(state);
    copy.remove(bookingId);
    state = copy;
  }
}

final bookingsProvider = NotifierProvider<BookingsNotifier, Map<int, Booking>>(
  BookingsNotifier.new,
);

/// Riepilogo calcolato su appointment per un booking.
final bookingSummaryProvider = Provider.family<BookingSummary?, int>((ref, id) {
  final appts = ref
      .watch(appointmentsProvider)
      .where((a) => a.bookingId == id)
      .toList();
  if (appts.isEmpty) return null;

  appts.sort((a, b) => a.startTime.compareTo(b.startTime));
  final totalPrice = appts.fold<double>(0.0, (sum, a) => sum + (a.price ?? 0));
  return BookingSummary(
    bookingId: id,
    itemsCount: appts.length,
    totalPrice: totalPrice,
    start: appts.first.startTime,
    end: appts.map((a) => a.endTime).reduce((a, b) => a.isAfter(b) ? a : b),
  );
});
--- FILE: lib/features/agenda/providers/agenda_scroll_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/staff.dart';

/// Stato con tutti i controller di scroll sincronizzati
class AgendaScrollState {
  final ScrollController verticalScrollCtrl;
  final ScrollController horizontalScrollCtrl;
  final Map<int, ScrollController> staffScrollCtrls;

  const AgendaScrollState({
    required this.verticalScrollCtrl,
    required this.horizontalScrollCtrl,
    required this.staffScrollCtrls,
  });
}

@immutable
class AgendaScrollKey {
  final Object identity;
  final List<Staff> staff;
  final DateTime date;
  final double initialOffset;

  const AgendaScrollKey({
    required this.identity,
    required this.staff,
    required this.date,
    required this.initialOffset,
  });

  @override
  bool operator ==(Object other) {
    return other is AgendaScrollKey && identical(other.identity, identity);
  }

  @override
  int get hashCode => identity.hashCode;
}

final agendaScrollProvider = Provider.family.autoDispose<AgendaScrollState, AgendaScrollKey>((ref, key) {
  final staffList = key.staff;
  final verticalCtrl = ScrollController(initialScrollOffset: key.initialOffset);
  final horizontalCtrl = ScrollController();
  final Map<int, ScrollController> staffCtrls = {
    for (final s in staffList) s.id: ScrollController(),
  };

  ref.onDispose(() {
    verticalCtrl.dispose();
    horizontalCtrl.dispose();
    for (final controller in staffCtrls.values) {
      controller.dispose();
    }
  });

  return AgendaScrollState(
    verticalScrollCtrl: verticalCtrl,
    horizontalScrollCtrl: horizontalCtrl,
    staffScrollCtrls: staffCtrls,
  );
});
--- FILE: lib/features/agenda/providers/agenda_interaction_lock_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'agenda_providers.dart';
import 'is_resizing_provider.dart';
import 'selected_appointment_provider.dart';

/// Stato condiviso che indica se il puntatore √® attualmente sopra una card.
class AgendaCardHoverNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  void setHovering(bool hovering) => state = hovering;

  void enter() => state = true;

  void exit() => state = false;
}

final agendaCardHoverProvider = NotifierProvider<AgendaCardHoverNotifier, bool>(
  AgendaCardHoverNotifier.new,
);

/// Restituisce `true` quando il PageView deve essere disabilitato
/// (drag, resize, hover o card selezionate).
final agendaDayScrollLockProvider = Provider<bool>((ref) {
  final isResizing = ref.watch(isResizingProvider);
  final isDragging = ref.watch(dragPositionProvider) != null;
  final hasSelection = !ref.watch(selectedAppointmentProvider).isEmpty;
  final isHovering = ref.watch(agendaCardHoverProvider);
  return isResizing || isDragging || hasSelection || isHovering;
});
--- FILE: lib/features/agenda/providers/fully_occupied_slots_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'fully_occupied_slots_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning
/// Calcola gli indici degli slot completamente occupati per un dato staff.
/// Uno slot √® "completamente occupato" quando la somma delle frazioni di larghezza
/// degli appuntamenti che lo coprono raggiunge o supera il 100%.

@ProviderFor(fullyOccupiedSlots)
const fullyOccupiedSlotsProvider = FullyOccupiedSlotsFamily._();

/// Calcola gli indici degli slot completamente occupati per un dato staff.
/// Uno slot √® "completamente occupato" quando la somma delle frazioni di larghezza
/// degli appuntamenti che lo coprono raggiunge o supera il 100%.

final class FullyOccupiedSlotsProvider
    extends $FunctionalProvider<Set<int>, Set<int>, Set<int>>
    with $Provider<Set<int>> {
  /// Calcola gli indici degli slot completamente occupati per un dato staff.
  /// Uno slot √® "completamente occupato" quando la somma delle frazioni di larghezza
  /// degli appuntamenti che lo coprono raggiunge o supera il 100%.
  const FullyOccupiedSlotsProvider._({
    required FullyOccupiedSlotsFamily super.from,
    required int super.argument,
  }) : super(
         retry: null,
         name: r'fullyOccupiedSlotsProvider',
         isAutoDispose: true,
         dependencies: null,
         $allTransitiveDependencies: null,
       );

  @override
  String debugGetCreateSourceHash() => _$fullyOccupiedSlotsHash();

  @override
  String toString() {
    return r'fullyOccupiedSlotsProvider'
        ''
        '($argument)';
  }

  @$internal
  @override
  $ProviderElement<Set<int>> $createElement($ProviderPointer pointer) =>
      $ProviderElement(pointer);

  @override
  Set<int> create(Ref ref) {
    final argument = this.argument as int;
    return fullyOccupiedSlots(ref, argument);
  }

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(Set<int> value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<Set<int>>(value),
    );
  }

  @override
  bool operator ==(Object other) {
    return other is FullyOccupiedSlotsProvider && other.argument == argument;
  }

  @override
  int get hashCode {
    return argument.hashCode;
  }
}

String _$fullyOccupiedSlotsHash() =>
    r'cac3293a238229a07421123556e10d4471801e64';

/// Calcola gli indici degli slot completamente occupati per un dato staff.
/// Uno slot √® "completamente occupato" quando la somma delle frazioni di larghezza
/// degli appuntamenti che lo coprono raggiunge o supera il 100%.

final class FullyOccupiedSlotsFamily extends $Family
    with $FunctionalFamilyOverride<Set<int>, int> {
  const FullyOccupiedSlotsFamily._()
    : super(
        retry: null,
        name: r'fullyOccupiedSlotsProvider',
        dependencies: null,
        $allTransitiveDependencies: null,
        isAutoDispose: true,
      );

  /// Calcola gli indici degli slot completamente occupati per un dato staff.
  /// Uno slot √® "completamente occupato" quando la somma delle frazioni di larghezza
  /// degli appuntamenti che lo coprono raggiunge o supera il 100%.

  FullyOccupiedSlotsProvider call(int staffId) =>
      FullyOccupiedSlotsProvider._(argument: staffId, from: this);

  @override
  String toString() => r'fullyOccupiedSlotsProvider';
}
--- FILE: lib/features/agenda/providers/staff_columns_geometry_provider.dart ---
import 'dart:ui';

import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Mappa: staffId -> Rect della colonna in coordinate BODY-LOCAL
class StaffColumnsGeometryNotifier extends Notifier<Map<int, Rect>> {
  @override
  Map<int, Rect> build() => <int, Rect>{};

  void setRect(int staffId, Rect rect) {
    final next = Map<int, Rect>.from(state)..[staffId] = rect;
    state = next;
  }

  void clearFor(int staffId) {
    if (!state.containsKey(staffId)) return;
    final next = Map<int, Rect>.from(state)..remove(staffId);
    state = next;
  }

  void clearAll() => state = <int, Rect>{};
}

final staffColumnsGeometryProvider =
    NotifierProvider<StaffColumnsGeometryNotifier, Map<int, Rect>>(
      StaffColumnsGeometryNotifier.new,
    );
--- FILE: lib/features/agenda/providers/agenda_providers.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Notifier che tiene traccia della posizione globale del drag
class DragPositionNotifier extends Notifier<Offset?> {
  @override
  Offset? build() => null;

  void update(Offset position) => state = position;

  /// ‚úÖ Nuovo metodo pubblico per aggiornare lo stato interpolato
  void set(Offset newValue) => state = newValue;

  void clear() => state = null;
}

final dragPositionProvider = NotifierProvider<DragPositionNotifier, Offset?>(
  DragPositionNotifier.new,
);
--- FILE: lib/features/agenda/providers/selected_appointment_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/appointment.dart';
import 'appointment_providers.dart';

class SelectedAppointmentsState {
  const SelectedAppointmentsState({
    this.bookingId,
    this.appointmentIds = const <int>{},
  });

  final int? bookingId;
  final Set<int> appointmentIds;

  bool contains(int appointmentId) => appointmentIds.contains(appointmentId);
  bool get isEmpty => appointmentIds.isEmpty;
}

/// üîπ Tiene traccia degli appuntamenti selezionati (tutti quelli della stessa prenotazione)
class SelectedAppointmentNotifier
    extends Notifier<SelectedAppointmentsState> {
  @override
  SelectedAppointmentsState build() => const SelectedAppointmentsState();

  /// Seleziona tutti gli appuntamenti collegati allo stesso booking dell'appuntamento dato.
  /// Se gi√† selezionati, deseleziona tutto.
  void toggleByAppointment(Appointment appointment) {
    final current = state;
    final alreadySelected =
        current.bookingId == appointment.bookingId &&
            current.contains(appointment.id);
    if (alreadySelected) {
      clear();
      return;
    }

    final allAppointments = ref.read(appointmentsProvider);
    final bookingAppointments = allAppointments
        .where((a) => a.bookingId == appointment.bookingId)
        .map((a) => a.id)
        .toSet();

    state = SelectedAppointmentsState(
      bookingId: appointment.bookingId,
      appointmentIds: bookingAppointments,
    );
  }

  /// Deseleziona tutti gli appuntamenti
  void clear() => state = const SelectedAppointmentsState();
}

final selectedAppointmentProvider =
    NotifierProvider<SelectedAppointmentNotifier, SelectedAppointmentsState>(
      SelectedAppointmentNotifier.new,
    );
--- FILE: lib/features/agenda/providers/agenda_scroll_request_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/appointment.dart';

@immutable
class AgendaScrollRequest {
  const AgendaScrollRequest(this.appointment);

  final Appointment appointment;

  DateTime get date => DateUtils.dateOnly(appointment.startTime);
}

class AgendaScrollRequestNotifier extends Notifier<AgendaScrollRequest?> {
  @override
  AgendaScrollRequest? build() => null;

  void request(Appointment appointment) {
    state = AgendaScrollRequest(appointment);
  }

  void clear() => state = null;
}

final agendaScrollRequestProvider =
    NotifierProvider<AgendaScrollRequestNotifier, AgendaScrollRequest?>(
      AgendaScrollRequestNotifier.new,
    );
--- FILE: lib/features/agenda/providers/temp_drag_time_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Mantiene in memoria temporanea l'intervallo orario stimato
/// (start, end) dell'appuntamento durante il drag.
/// Viene aggiornato in tempo reale dalla StaffColumn mentre l'utente trascina
/// e letto da AppointmentCard per mostrare orari live.
class TempDragTimeNotifier extends Notifier<(DateTime, DateTime)?> {
  @override
  (DateTime, DateTime)? build() => null;

  /// Imposta un nuovo intervallo orario (start, end)
  void setTimes(DateTime start, DateTime end) {
    // aggiorna solo se cambia effettivamente lo slot di riferimento
    if (state == null ||
        state!.$1.minute != start.minute ||
        state!.$1.hour != start.hour) {
      state = (start, end);
    }
  }

  /// Resetta lo stato (nessun drag in corso)
  void clear() => state = null;
}

final tempDragTimeProvider =
    NotifierProvider<TempDragTimeNotifier, (DateTime, DateTime)?>(
      TempDragTimeNotifier.new,
    );
--- FILE: lib/features/agenda/providers/pending_drop_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Dati di un drop in attesa di conferma.
@immutable
class PendingDropData {
  final int appointmentId;
  final int originalStaffId;
  final DateTime originalStart;
  final DateTime originalEnd;
  final int newStaffId;
  final DateTime newStart;
  final DateTime newEnd;

  const PendingDropData({
    required this.appointmentId,
    required this.originalStaffId,
    required this.originalStart,
    required this.originalEnd,
    required this.newStaffId,
    required this.newStart,
    required this.newEnd,
  });
}

/// Notifier per gestire lo stato di un drop in attesa di conferma.
class PendingDropNotifier extends Notifier<PendingDropData?> {
  @override
  PendingDropData? build() => null;

  void setPending(PendingDropData data) {
    state = data;
  }

  void clear() {
    state = null;
  }

  bool get hasPending => state != null;
}

/// Provider per lo stato di drop in attesa di conferma.
final pendingDropProvider =
    NotifierProvider<PendingDropNotifier, PendingDropData?>(
      PendingDropNotifier.new,
    );

/// Provider per verificare se un appuntamento specifico ha un drop pendente.
final isAppointmentPendingDropProvider = Provider.family<bool, int>((
  ref,
  appointmentId,
) {
  final pending = ref.watch(pendingDropProvider);
  return pending?.appointmentId == appointmentId;
});
--- FILE: lib/features/agenda/providers/drag_layer_link_provider.dart ---
import 'dart:async';

import 'package:flutter/widgets.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// üîπ Gestisce il LayerLink del body (ancora per i feedback)
class DragLayerLinkNotifier extends Notifier<LayerLink> {
  @override
  LayerLink build() => LayerLink();

  void reset() => state = LayerLink();
  void resetOnMicrotask() {
    Future.microtask(() => state = LayerLink());
  }
}

final dragLayerLinkProvider =
    NotifierProvider<DragLayerLinkNotifier, LayerLink>(
      DragLayerLinkNotifier.new,
    );

/// üîπ Gestisce il RenderBox del body (area scrollabile dell‚Äôagenda)
class DragBodyBoxNotifier extends Notifier<RenderBox?> {
  @override
  RenderBox? build() => null;

  void set(RenderBox box) => state = box;
  void scheduleClear() {
    Future.microtask(() => state = null);
  }
}

final dragBodyBoxProvider = NotifierProvider<DragBodyBoxNotifier, RenderBox?>(
  DragBodyBoxNotifier.new,
);
--- FILE: lib/features/agenda/providers/staff_slot_availability_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/availability_exception.dart';
import '../../staff/presentation/staff_availability_screen.dart';
import '../../staff/providers/availability_exceptions_provider.dart';
import 'date_range_provider.dart';
import 'layout_config_provider.dart';

/// Provider che fornisce la disponibilit√† degli slot per uno staff specifico
/// in base alla data corrente dell'agenda.
///
/// La disponibilit√† finale √® calcolata come:
/// 1. Base: template settimanale (es. Lun-Ven 09:00-18:00)
/// 2. + Eccezioni "available": aggiungono slot disponibili
/// 3. - Eccezioni "unavailable": rimuovono slot disponibili
///
/// Ritorna un `Set<int>` contenente gli indici degli slot DISPONIBILI.
/// - Set vuoto = nessuna disponibilit√† (staff non lavora quel giorno)
/// - Se non ci sono dati configurati, lo staff √® considerato NON disponibile (comportamento restrittivo)
final staffSlotAvailabilityProvider = Provider.family<Set<int>, int>((
  ref,
  staffId,
) {
  final agendaDate = ref.watch(agendaDateProvider);
  final asyncByStaff = ref.watch(staffAvailabilityByStaffProvider);
  final layoutConfig = ref.watch(layoutConfigProvider);

  // Determina il giorno della settimana (1 = Luned√¨, 7 = Domenica)
  final dayOfWeek = agendaDate.weekday;

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // 1Ô∏è‚É£ BASE: Template settimanale
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  Set<int> baseSlots;

  final allData = asyncByStaff.value;
  if (allData == null) {
    baseSlots = <int>{};
  } else {
    final staffData = allData[staffId];
    if (staffData == null || !staffData.containsKey(dayOfWeek)) {
      baseSlots = <int>{};
    } else {
      baseSlots = Set<int>.from(staffData[dayOfWeek]!);
    }
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // 2Ô∏è‚É£ ECCEZIONI: Applica modifiche per la data specifica
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  final exceptions = ref.watch(
    exceptionsForStaffOnDateProvider((staffId: staffId, date: agendaDate)),
  );

  if (exceptions.isEmpty) {
    return baseSlots;
  }

  // Applica le eccezioni in ordine
  Set<int> finalSlots = Set<int>.from(baseSlots);

  for (final exception in exceptions) {
    final exceptionSlots = exception.toSlotIndices(
      minutesPerSlot: layoutConfig.minutesPerSlot,
      totalSlotsPerDay: layoutConfig.totalSlots,
    );

    if (exception.type == AvailabilityExceptionType.available) {
      // AGGIUNGE disponibilit√† (es. turno extra)
      finalSlots = finalSlots.union(exceptionSlots);
    } else {
      // RIMUOVE disponibilit√† (es. ferie, malattia)
      finalSlots = finalSlots.difference(exceptionSlots);
    }
  }

  return finalSlots;
});

/// Provider che verifica se uno slot specifico √® disponibile.
/// Pi√π efficiente per query puntuali.
final isSlotAvailableProvider =
    Provider.family<bool, ({int staffId, int slotIndex})>((ref, params) {
      final availableSlots = ref.watch(
        staffSlotAvailabilityProvider(params.staffId),
      );

      // Se il set √® vuoto, lo staff non √® disponibile
      if (availableSlots.isEmpty) {
        return false;
      }

      return availableSlots.contains(params.slotIndex);
    });

/// Provider che raggruppa gli slot non disponibili consecutivi
/// per ottimizzare il rendering (un solo widget per range).
///
/// Ritorna una lista di (startIndex, count) per ogni range non disponibile.
final unavailableSlotRangesProvider =
    Provider.family<List<({int startIndex, int count})>, int>((ref, staffId) {
      final availableSlots = ref.watch(staffSlotAvailabilityProvider(staffId));
      final layoutConfig = ref.watch(layoutConfigProvider);
      final totalSlots = layoutConfig.totalSlots;

      // Se il set √® vuoto, l'intera giornata √® non disponibile
      if (availableSlots.isEmpty) {
        return [(startIndex: 0, count: totalSlots)];
      }

      final List<({int startIndex, int count})> ranges = [];
      int? rangeStart;
      int rangeCount = 0;

      for (int i = 0; i < totalSlots; i++) {
        final isAvailable = availableSlots.contains(i);

        if (!isAvailable) {
          // Slot non disponibile
          if (rangeStart == null) {
            rangeStart = i;
            rangeCount = 1;
          } else {
            rangeCount++;
          }
        } else {
          // Slot disponibile: chiudi il range precedente se esiste
          if (rangeStart != null) {
            ranges.add((startIndex: rangeStart, count: rangeCount));
            rangeStart = null;
            rangeCount = 0;
          }
        }
      }

      // Chiudi l'ultimo range se necessario
      if (rangeStart != null) {
        ranges.add((startIndex: rangeStart, count: rangeCount));
      }

      return ranges;
    });
--- FILE: lib/features/agenda/providers/staff_filter_providers.dart ---
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/staff.dart';
import '../domain/staff_filter_mode.dart';
import 'staff_slot_availability_provider.dart';

/// Provider per la modalit√† di filtro staff corrente.
final staffFilterModeProvider =
    NotifierProvider<StaffFilterModeNotifier, StaffFilterMode>(
      StaffFilterModeNotifier.new,
    );

class StaffFilterModeNotifier extends Notifier<StaffFilterMode> {
  @override
  StaffFilterMode build() => StaffFilterMode.onDutyTeam;

  void set(StaffFilterMode mode) {
    state = mode;
  }
}

/// Provider per gli ID degli staff selezionati manualmente.
final selectedStaffIdsProvider =
    NotifierProvider<SelectedStaffIdsNotifier, Set<int>>(
      SelectedStaffIdsNotifier.new,
    );

class SelectedStaffIdsNotifier extends Notifier<Set<int>> {
  @override
  Set<int> build() => {};

  void toggle(int staffId) {
    if (state.contains(staffId)) {
      state = {...state}..remove(staffId);
    } else {
      state = {...state, staffId};
    }
  }

  void selectAll(List<Staff> staff) {
    state = staff.map((s) => s.id).toSet();
  }

  void clear() {
    state = {};
  }

  void setFromList(List<int> ids) {
    state = ids.toSet();
  }
}

/// Provider che restituisce gli ID dello staff di turno per il giorno corrente.
final onDutyStaffIdsProvider = Provider<Set<int>>((ref) {
  final allStaff = ref.watch(staffForCurrentLocationProvider);
  final onDutyIds = <int>{};

  for (final staff in allStaff) {
    final availableSlots = ref.watch(staffSlotAvailabilityProvider(staff.id));
    // Staff √® di turno se ha almeno uno slot disponibile nel giorno,
    // incluse eventuali eccezioni.
    if (availableSlots.isNotEmpty) {
      onDutyIds.add(staff.id);
    }
  }

  return onDutyIds;
});

/// Provider che restituisce lo staff filtrato in base alla modalit√† selezionata.
final filteredStaffProvider = Provider<List<Staff>>((ref) {
  final mode = ref.watch(staffFilterModeProvider);
  final allStaff = ref.watch(staffForCurrentLocationProvider);
  final selectedIds = ref.watch(selectedStaffIdsProvider);
  final onDutyIds = ref.watch(onDutyStaffIdsProvider);

  switch (mode) {
    case StaffFilterMode.allTeam:
      return allStaff;

    case StaffFilterMode.onDutyTeam:
      // Filtra solo lo staff che ha disponibilit√† per il giorno corrente
      return allStaff.where((s) => onDutyIds.contains(s.id)).toList();

    case StaffFilterMode.custom:
      return allStaff.where((s) => selectedIds.contains(s.id)).toList();
  }
});
--- FILE: lib/features/agenda/domain/config/agenda_theme.dart ---
import 'package:flutter/material.dart';

/// Tema visivo centralizzato per l'agenda.
/// Definisce colori, spessori, altezze e stili coerenti
/// per tutti i componenti della vista agenda.
///
/// In futuro potrai adattarlo dinamicamente (dark mode, branding, ecc.)
class AgendaTheme {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üé® COLORI BASE
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Colore principale per i separatori verticali/orizzontali
  static Color get dividerColor => Colors.grey.shade300;

  /// Colore per ombre leggere o bordi di separazione
  static Color get shadowColor => Colors.black.withOpacity(0.5);

  /// Colore di sfondo per lo slot orario
  static const Color backgroundHourSlot = Colors.white;

  /// Colore di sfondo per le intestazioni staff
  static Color staffHeaderBackground(Color base) =>
      base.withValues(alpha: 0.15);

  /// Colore del testo nelle intestazioni staff
  static const Color staffHeaderTextColor = Colors.black87;

  /// Colore del bordo di un appuntamento (card)
  static Color get appointmentBorder => Colors.grey.shade400;

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üíß OMBRE & BORDI
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Ombra leggera usata nei divider verticali
  static BoxShadow get subtleShadow =>
      BoxShadow(color: shadowColor, offset: const Offset(1, 0), blurRadius: 2);

  /// Stile base per i separatori verticali
  static BoxDecoration get verticalDividerDecoration =>
      BoxDecoration(color: dividerColor, boxShadow: [subtleShadow]);

  /// Stile base per i separatori orizzontali
  static BoxDecoration get horizontalDividerDecoration =>
      const BoxDecoration(color: Colors.grey);

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üß± STILI TESTO
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  static const TextStyle staffHeaderTextStyle = TextStyle(
    fontWeight: FontWeight.bold,
    color: staffHeaderTextColor,
  );

  static const TextStyle hourTextStyle = TextStyle(
    fontSize: 13,
    fontWeight: FontWeight.bold,
    color: Colors.black87,
  );

  static const TextStyle appointmentTextStyle = TextStyle(
    fontSize: 14,
    color: Colors.black87,
  );

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üëª EFFETTO DRAG / FANTASMA
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Opacit√† del "fantasma" lasciato dalla card originale durante il drag.
  /// Regola questo valore per rendere il ghost pi√π o meno visibile.
  static const double ghostOpacity = 0.50;

  /// Durata dell'effetto fade-out del fantasma dopo il rilascio.
  /// Aumentala per una dissolvenza pi√π lenta e visibile.
  static const Duration ghostFadeDuration = Duration(milliseconds: 500);

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üö´ SLOT NON DISPONIBILI
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  /// Colore delle linee diagonali per slot non disponibili.
  static Color unavailablePatternColor(ColorScheme scheme) =>
      scheme.onSurface.withOpacity(0.25);

  /// Colore di sfondo per slot non disponibili.
  static Color unavailableBackgroundColor(ColorScheme scheme) =>
      scheme.surfaceContainerHighest.withOpacity(0.6);

  /// Spaziatura tra le linee del pattern (in pixel).
  static const double unavailablePatternSpacing = 6.0;

  /// Spessore delle linee del pattern (in pixel).
  static const double unavailablePatternLineWidth = 1.5;
}
--- FILE: lib/features/agenda/domain/config/layout_config.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:flutter/material.dart';

/// Immutable snapshot of the current layout dimensions used by the agenda.
class LayoutConfig {
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üìê Costanti strutturali
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  static const int hoursInDay = 24;
  static const List<int> slotDurationOptions = [15, 30, 60, 120];
  static const int minutesPerSlotConst = 15;

  static const double horizontalPadding = 8;
  static const double verticalPadding = 4;
  static const double columnInnerPadding = 2;
  static const double minColumnWidthMobile = 140;
  static const double minColumnWidthDesktop = 160;
  static const double borderRadius = 8;
  static const double borderWidth = 1;
  static const int maxVisibleStaff = 6;

  /// Larghezza della fascia laterale per il pulsante "+" sugli slot occupati
  static const double addButtonStripWidth = 28;

  static const double defaultHourColumnWidth = 60;
  static const double defaultHeaderHeight = 50;
  static const double defaultSlotHeight = 30;

  static const LayoutConfig initial = LayoutConfig(
    slotHeight: defaultSlotHeight,
    headerHeight: defaultHeaderHeight,
    hourColumnWidth: defaultHourColumnWidth,
    minutesPerSlot: minutesPerSlotConst,
    useClusterMaxConcurrency: true,
    useServiceColorsForAppointments: true,
    enableOccupiedSlotStrip: false,
    showTopbarAddLabel: false,
  );

  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // üìè Stato dinamico
  // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

  final double slotHeight;
  final double headerHeight;
  final double hourColumnWidth;
  final int minutesPerSlot;
  final bool useClusterMaxConcurrency;
  final bool useServiceColorsForAppointments;

  /// Se true, riserva una fascia laterale quando ci sono slot completamente occupati.
  /// Permette di cliccare sullo spazio libero per creare nuovi appuntamenti.
  final bool enableOccupiedSlotStrip;

  /// Se true, il pulsante "Aggiungi" in topbar mostra anche la label.
  final bool showTopbarAddLabel;

  const LayoutConfig({
    required this.slotHeight,
    required this.headerHeight,
    required this.hourColumnWidth,
    required this.minutesPerSlot,
    required this.useClusterMaxConcurrency,
    required this.useServiceColorsForAppointments,
    required this.enableOccupiedSlotStrip,
    required this.showTopbarAddLabel,
  });

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! LayoutConfig) return false;
    return slotHeight == other.slotHeight &&
        headerHeight == other.headerHeight &&
        hourColumnWidth == other.hourColumnWidth &&
        minutesPerSlot == other.minutesPerSlot &&
        useClusterMaxConcurrency == other.useClusterMaxConcurrency &&
        useServiceColorsForAppointments ==
            other.useServiceColorsForAppointments &&
        enableOccupiedSlotStrip == other.enableOccupiedSlotStrip &&
        showTopbarAddLabel == other.showTopbarAddLabel;
  }

  @override
  int get hashCode => Object.hash(
    slotHeight,
    headerHeight,
    hourColumnWidth,
    minutesPerSlot,
    useClusterMaxConcurrency,
    useServiceColorsForAppointments,
    enableOccupiedSlotStrip,
    showTopbarAddLabel,
  );

  LayoutConfig copyWith({
    double? slotHeight,
    double? headerHeight,
    double? hourColumnWidth,
    int? minutesPerSlot,
    bool? useClusterMaxConcurrency,
    bool? useServiceColorsForAppointments,
    bool? enableOccupiedSlotStrip,
    bool? showTopbarAddLabel,
  }) {
    return LayoutConfig(
      slotHeight: slotHeight ?? this.slotHeight,
      headerHeight: headerHeight ?? this.headerHeight,
      hourColumnWidth: hourColumnWidth ?? this.hourColumnWidth,
      minutesPerSlot: minutesPerSlot ?? this.minutesPerSlot,
      useClusterMaxConcurrency:
          useClusterMaxConcurrency ?? this.useClusterMaxConcurrency,
      useServiceColorsForAppointments:
          useServiceColorsForAppointments ??
          this.useServiceColorsForAppointments,
      enableOccupiedSlotStrip:
          enableOccupiedSlotStrip ?? this.enableOccupiedSlotStrip,
      showTopbarAddLabel: showTopbarAddLabel ?? this.showTopbarAddLabel,
    );
  }

  int get totalSlots => (hoursInDay * 60 ~/ minutesPerSlot);

  double get totalHeight => totalSlots * slotHeight;

  static bool isValidSlotDuration(int minutes) =>
      slotDurationOptions.contains(minutes);

  /// Calcola quanti staff possono essere mostrati in base alla larghezza schermo.
  int computeMaxVisibleStaff(
    double contentWidth, {
    required AppFormFactor formFactor,
  }) {
    final minWidth = formFactor == AppFormFactor.mobile
        ? minColumnWidthMobile
        : minColumnWidthDesktop;

    final usableWidth = contentWidth.clamp(0, double.infinity);
    final maxStaff = (usableWidth / minWidth).floor();
    return maxStaff.clamp(1, maxVisibleStaff);
  }

  /// Calcola dinamicamente la larghezza di ogni colonna staff.
  double computeAdaptiveColumnWidth({
    required double contentWidth,
    required int visibleStaffCount,
    required AppFormFactor formFactor,
  }) {
    final minWidth = formFactor == AppFormFactor.mobile
        ? minColumnWidthMobile
        : minColumnWidthDesktop;

    if (visibleStaffCount <= 0) {
      return minWidth;
    }

    final usableWidth = contentWidth.clamp(0, double.infinity);
    final idealWidth = usableWidth / visibleStaffCount;

    return idealWidth < minWidth ? minWidth : idealWidth;
  }

  /// Altezza header ‚Äúresponsive‚Äù basata sulla larghezza finestra.
  static double headerHeightFor(BuildContext context) {
    final width = MediaQuery.of(context).size.width;
    return headerHeightForWidth(width);
  }

  static double headerHeightForWidth(double width) {
    if (width >= 1024) return 110; // Desktop
    if (width >= 600) return 95; // Tablet
    return 80; // Mobile
  }

  /// Dimensione avatar staff "responsive" basata sulla larghezza finestra.
  static double avatarSizeFor(BuildContext context) {
    final width = MediaQuery.of(context).size.width;
    return avatarSizeForWidth(width);
  }

  static double avatarSizeForWidth(double width) {
    if (width >= 1024) return 65; // Desktop
    if (width >= 600) return 57; // Tablet
    return 52; // Mobile
  }
}
--- FILE: lib/features/agenda/domain/staff_filter_mode.dart ---
/// Modalit√† di filtro per lo staff nell'agenda.
enum StaffFilterMode {
  /// Mostra tutto il team (tutti gli staff della location).
  allTeam,

  /// Mostra solo il team di turno (staff con disponibilit√† nel giorno selezionato).
  onDutyTeam,

  /// Selezione manuale di uno o pi√π membri dello staff.
  custom,
}
--- FILE: lib/features/agenda/domain/service_item_data.dart ---
import 'package:flutter/material.dart';

/// Rappresenta un singolo servizio in una prenotazione multi-servizio.
/// Usato internamente nel form di creazione/modifica prenotazione.
class ServiceItemData {
  final String key; // Chiave univoca per identificare l'item nella lista
  final int? serviceId;
  final int? serviceVariantId;
  final int? staffId;
  final TimeOfDay startTime;
  final int durationMinutes;
  final int blockedExtraMinutes;
  final int processingExtraMinutes;

  const ServiceItemData({
    required this.key,
    this.serviceId,
    this.serviceVariantId,
    this.staffId,
    required this.startTime,
    this.durationMinutes = 30,
    this.blockedExtraMinutes = 0,
    this.processingExtraMinutes = 0,
  });

  /// Calcola l'orario di fine basato su startTime e durationMinutes
  TimeOfDay get endTime {
    final totalMinutes =
        startTime.hour * 60 + startTime.minute + durationMinutes;
    return TimeOfDay(
      hour: (totalMinutes ~/ 60) % 24,
      minute: totalMinutes % 60,
    );
  }

  /// Calcola l'orario di fine con durata opzionale esterna (es. da variant)
  TimeOfDay getEndTime([int? externalDuration]) {
    final duration = externalDuration ?? durationMinutes;
    final totalMinutes = startTime.hour * 60 + startTime.minute + duration;
    return TimeOfDay(
      hour: (totalMinutes ~/ 60) % 24,
      minute: totalMinutes % 60,
    );
  }

  /// Calcola il prossimo orario di inizio (per il servizio successivo)
  TimeOfDay get nextStartTime => endTime;

  ServiceItemData copyWith({
    String? key,
    int? serviceId,
    int? serviceVariantId,
    int? staffId,
    TimeOfDay? startTime,
    int? durationMinutes,
    int? blockedExtraMinutes,
    int? processingExtraMinutes,
  }) {
    return ServiceItemData(
      key: key ?? this.key,
      serviceId: serviceId ?? this.serviceId,
      serviceVariantId: serviceVariantId ?? this.serviceVariantId,
      staffId: staffId ?? this.staffId,
      startTime: startTime ?? this.startTime,
      durationMinutes: durationMinutes ?? this.durationMinutes,
      blockedExtraMinutes: blockedExtraMinutes ?? this.blockedExtraMinutes,
      processingExtraMinutes:
          processingExtraMinutes ?? this.processingExtraMinutes,
    );
  }

  /// Crea una copia con serviceId e staffId resettati a null
  ServiceItemData clearService() {
    return ServiceItemData(
      key: key,
      serviceId: null,
      serviceVariantId: null,
      staffId: null,
      startTime: startTime,
      durationMinutes: 30,
      blockedExtraMinutes: 0,
      processingExtraMinutes: 0,
    );
  }

  bool get hasBlockedExtra => blockedExtraMinutes > 0;
  bool get hasProcessingExtra => processingExtraMinutes > 0;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ServiceItemData &&
          runtimeType == other.runtimeType &&
          key == other.key;

  @override
  int get hashCode => key.hashCode;
}
--- FILE: lib/features/agenda/presentation/screens/helper/layout_geometry_helper.dart ---
import 'dart:math' as math;

class LayoutEntry {
  const LayoutEntry({
    required this.id,
    required this.start,
    required this.end,
  });

  final int id;
  final DateTime start;
  final DateTime end;
}

class EventGeometry {
  const EventGeometry({
    required this.leftFraction,
    required this.widthFraction,
  });

  final double leftFraction;
  final double widthFraction;
}

Map<int, EventGeometry> computeLayoutGeometry(
  List<LayoutEntry> entries, {
  bool useClusterMaxConcurrency = false,
}) {
  if (entries.isEmpty) return const {};

  final sorted = entries.toList()
    ..sort((a, b) => a.start.compareTo(b.start));
  final clusters = <List<LayoutEntry>>[];

  var currentCluster = <LayoutEntry>[];
  DateTime? currentMaxEnd;

  for (final entry in sorted) {
    if (currentCluster.isEmpty) {
      currentCluster = [entry];
      currentMaxEnd = entry.end;
      continue;
    }

    if (entry.start.isBefore(currentMaxEnd!)) {
      currentCluster.add(entry);
      if (entry.end.isAfter(currentMaxEnd)) {
        currentMaxEnd = entry.end;
      }
    } else {
      clusters.add(List<LayoutEntry>.from(currentCluster));
      currentCluster = [entry];
      currentMaxEnd = entry.end;
    }
  }

  if (currentCluster.isNotEmpty) {
    clusters.add(List<LayoutEntry>.from(currentCluster));
  }

  final geometryMap = <int, EventGeometry>{};

  for (final cluster in clusters) {
    final columnAssignments = _assignColumns(cluster);
    final concurrencyMap = _computeConcurrency(cluster);

    if (useClusterMaxConcurrency) {
      final clusterMaxConcurrency =
          concurrencyMap.values.fold<int>(1, math.max);
      final totalColumns =
          math.max(clusterMaxConcurrency, 1); // evita divisione per zero

      final columnMap = <int, List<LayoutEntry>>{};
      for (final entry in cluster) {
        final columnIndex = columnAssignments[entry.id] ?? 0;
        columnMap.putIfAbsent(columnIndex, () => []).add(entry);
      }

      for (final entry in cluster) {
        final columnIndex = columnAssignments[entry.id] ?? 0;
        int widthInColumns = 1;

        while (columnIndex + widthInColumns < totalColumns) {
          final candidateColumn = columnIndex + widthInColumns;
          final occupants = columnMap[candidateColumn];
          final hasOverlap = occupants?.any(
                (other) =>
                    _entriesOverlap(entry, other) &&
                    other.id != entry.id,
              ) ??
              false;

          if (hasOverlap) {
            break;
          }

          widthInColumns++;
        }

        for (int col = columnIndex; col < columnIndex + widthInColumns; col++) {
          final list = columnMap.putIfAbsent(col, () => []);
          if (!list.contains(entry)) {
            list.add(entry);
          }
        }

        final widthFraction = widthInColumns / totalColumns;
        final leftFraction = columnIndex / totalColumns;
        geometryMap[entry.id] = EventGeometry(
          leftFraction: leftFraction,
          widthFraction: widthFraction,
        );
      }
    } else {
      for (final entry in cluster) {
        final concurrency = concurrencyMap[entry.id] ?? 1;
        final widthFraction = 1 / concurrency;
        final columnIndex = columnAssignments[entry.id] ?? 0;
        final leftFraction = columnIndex * widthFraction;
        geometryMap[entry.id] = EventGeometry(
          leftFraction: leftFraction,
          widthFraction: widthFraction,
        );
      }
    }
  }

  return geometryMap;
}

bool _entriesOverlap(LayoutEntry a, LayoutEntry b) {
  if (identical(a, b)) return false;
  return a.start.isBefore(b.end) && a.end.isAfter(b.start);
}

Map<int, int> _assignColumns(List<LayoutEntry> cluster) {
  final assignments = <int, int>{};
  final columnEndTimes = <DateTime>[];

  final ordered = cluster.toList()
    ..sort((a, b) {
      final compareStart = a.start.compareTo(b.start);
      if (compareStart != 0) return compareStart;
      return a.end.compareTo(b.end);
    });

  for (final entry in ordered) {
    int assignedColumn = -1;
    for (int i = 0; i < columnEndTimes.length; i++) {
      if (!entry.start.isBefore(columnEndTimes[i])) {
        assignedColumn = i;
        columnEndTimes[i] = entry.end;
        break;
      }
    }

    if (assignedColumn == -1) {
      assignedColumn = columnEndTimes.length;
      columnEndTimes.add(entry.end);
    }

    assignments[entry.id] = assignedColumn;
  }

  return assignments;
}

Map<int, int> _computeConcurrency(List<LayoutEntry> cluster) {
  final concurrencyMap = <int, int>{};

  for (final entry in cluster) {
    final edges = <_Edge>[];

    for (final other in cluster) {
      final overlapStart = entry.start.isAfter(other.start)
          ? entry.start
          : other.start;
      final overlapEnd = entry.end.isBefore(other.end)
          ? entry.end
          : other.end;

      if (overlapStart.isBefore(overlapEnd)) {
        edges.add(_Edge(overlapStart, 1));
        edges.add(_Edge(overlapEnd, -1));
      }
    }

    edges.sort((a, b) {
      final compare = a.instant.compareTo(b.instant);
      if (compare != 0) return compare;
      if (a.delta == b.delta) return 0;
      return a.delta == -1 ? -1 : 1;
    });

    int active = 0;
    int maxActive = 0;
    for (final edge in edges) {
      active += edge.delta;
      if (active > maxActive) {
        maxActive = active;
      }
    }

    concurrencyMap[entry.id] = math.max(maxActive, 1);
  }

  return concurrencyMap;
}

class _Edge {
  const _Edge(this.instant, this.delta);

  final DateTime instant;
  final int delta;
}
--- FILE: lib/features/agenda/presentation/screens/helper/drag_drop_helper.dart ---
import 'package:flutter/material.dart';

import '/core/models/appointment.dart';
import '../../../domain/config/layout_config.dart';

class DropComputationParams {
  const DropComputationParams({
    required this.appointment,
    required this.layoutConfig,
    required this.columnHeight,
    required this.localPointer,
    required this.dragOffsetY,
    required this.draggedCardHeightPx,
    required this.previewTimes,
  });

  final Appointment appointment;
  final LayoutConfig layoutConfig;
  final double columnHeight;
  final Offset localPointer;
  final double dragOffsetY;
  final double draggedCardHeightPx;
  final (DateTime, DateTime)? previewTimes;
}

class DropComputationResult {
  const DropComputationResult({
    required this.newStart,
    required this.newEnd,
  });

  final DateTime newStart;
  final DateTime newEnd;
}

DropComputationResult computeDropResult(DropComputationParams params) {
  final layoutConfig = params.layoutConfig;
  final slotHeight = layoutConfig.slotHeight;
  final minutesPerSlot = layoutConfig.minutesPerSlot;

  final maxYStartPx =
      (params.columnHeight - params.draggedCardHeightPx)
          .clamp(0, params.columnHeight)
          .toDouble();
  final clampedLocalDy =
      params.localPointer.dy.clamp(0.0, params.columnHeight.toDouble());
  final effectiveDy =
      (clampedLocalDy - params.dragOffsetY).clamp(0.0, maxYStartPx).toDouble();

  final rawTop = params.localPointer.dy - params.dragOffsetY;
  final rawBottom = rawTop + params.draggedCardHeightPx;
  final isAboveBounds = rawTop < 0;
  final isBelowBounds = rawBottom > params.columnHeight;

  final appointment = params.appointment;
  final duration = appointment.endTime.difference(appointment.startTime);
  final durationMinutes = duration.inMinutes;

  final baseDate = DateTime(
    appointment.startTime.year,
    appointment.startTime.month,
    appointment.startTime.day,
  );

  DateTime newStart;
  DateTime newEnd;

  final previewTimes = params.previewTimes;
  if (previewTimes != null) {
    newStart = previewTimes.$1;
    newEnd = previewTimes.$2;
  } else {
    final minutesFromTop =
        (effectiveDy / slotHeight) * minutesPerSlot;
    double roundedMinutes = (minutesFromTop / 5).round() * 5;

    const totalMinutes = LayoutConfig.hoursInDay * 60; // 1440
    final maxStartMinutesNum =
        (totalMinutes - durationMinutes).clamp(0, totalMinutes);

    int startMinutes = roundedMinutes.toInt();
    final maxStartMinutes = maxStartMinutesNum.toInt();

    if (startMinutes > maxStartMinutes) startMinutes = maxStartMinutes;
    if (startMinutes < 0) startMinutes = 0;

    final endMinutes =
        (startMinutes + durationMinutes).clamp(0, totalMinutes).toInt();

    newStart = baseDate.add(Duration(minutes: startMinutes));

    final rawEnd = baseDate.add(Duration(minutes: endMinutes));
    final dayBoundary = baseDate.add(const Duration(days: 1));
    newEnd = rawEnd.isAfter(dayBoundary) ? dayBoundary : rawEnd;
  }

  if (isAboveBounds) {
    newStart = baseDate;
    final cappedEnd =
        baseDate.add(Duration(minutes: durationMinutes));
    final dayEnd = baseDate.add(const Duration(days: 1));
    newEnd = cappedEnd.isBefore(dayEnd) ? cappedEnd : dayEnd;
  }

  if (isBelowBounds) {
    final dayEnd = baseDate.add(const Duration(days: 1));
    newEnd = dayEnd;
    final candidateStart =
        dayEnd.subtract(Duration(minutes: durationMinutes));
    newStart = candidateStart.isAfter(baseDate)
        ? candidateStart
        : baseDate;
  }

  return DropComputationResult(
    newStart: newStart,
    newEnd: newEnd,
  );
}
--- FILE: lib/features/agenda/presentation/screens/helper/responsive_layout.dart ---
import 'dart:math' as math;

import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/config/layout_config.dart';

class ResponsiveLayout {
  final double columnWidth;
  final double slotHeight;
  final int maxVisibleStaff;
  final int totalSlots;

  const ResponsiveLayout({
    required this.columnWidth,
    required this.slotHeight,
    required this.maxVisibleStaff,
    required this.totalSlots,
  });

  static ResponsiveLayout of(
    BuildContext context, {
    required int staffCount,
    required LayoutConfig config,
    double? availableWidth,
  }) {
    final screenWidth = availableWidth ?? MediaQuery.of(context).size.width;
    final container = ProviderScope.containerOf(context, listen: false);
    final formFactor = container.read(formFactorProvider);

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // üìê Calcolo larghezza colonne staff
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    final dynamicMaxVisible = formFactor == AppFormFactor.mobile
        ? 2
        : config.computeMaxVisibleStaff(
            screenWidth,
            formFactor: formFactor,
          );
    final visibleStaff = staffCount.clamp(1, dynamicMaxVisible);

    final columnWidth = config.computeAdaptiveColumnWidth(
      contentWidth: screenWidth,
      visibleStaffCount: visibleStaff,
      formFactor: formFactor,
    );
    final devicePixelRatio = MediaQuery.of(context).devicePixelRatio;
    final snappedColumnWidth = devicePixelRatio > 0
        ? (columnWidth * devicePixelRatio).floorToDouble() / devicePixelRatio
        : columnWidth;
    final minWidth = formFactor == AppFormFactor.mobile
        ? LayoutConfig.minColumnWidthMobile
        : LayoutConfig.minColumnWidthDesktop;
    final resolvedColumnWidth = math.max(snappedColumnWidth, minWidth);

    return ResponsiveLayout(
      columnWidth: resolvedColumnWidth,
      slotHeight: config.slotHeight,
      maxVisibleStaff: dynamicMaxVisible,
      totalSlots: config.totalSlots,
    );
  }

  double get totalHeight => totalSlots * slotHeight;
}
--- FILE: lib/features/agenda/presentation/screens/helper/free_duration_helper.dart ---
import 'dart:math' as math;

import '../../../../../core/models/appointment.dart';
import '../../../domain/config/layout_config.dart';

/// Computes the amount of free minutes starting from the given [index] slot.
///
/// Behavior:
/// - If the slot is fully occupied by one or more appointments -> returns 0.
/// - If the slot is partially occupied -> returns only the free minutes
///   inside that slot (no look-ahead aggregation).
/// - If the slot is totally free -> extends over subsequent contiguous
///   free slots until the next busy slot (original behavior).
Duration computeFreeDurationForSlot(
  int index,
  List<Appointment> appointments,
  LayoutConfig layout,
) {
  final slotStart = Duration(minutes: index * layout.minutesPerSlot);
  final slotEnd = Duration(minutes: (index + 1) * layout.minutesPerSlot);
  final slotDurationMinutes = layout.minutesPerSlot;

  // Collect overlaps of appointments within the current slot.
  final overlaps =
      <(int, int)>[]; // intervals [start, end) in minutes relative to slot
  for (final a in appointments) {
    final apptStart = Duration(
      hours: a.startTime.hour,
      minutes: a.startTime.minute,
    );
    final apptEnd = Duration(hours: a.endTime.hour, minutes: a.endTime.minute);
    if (slotStart < apptEnd && slotEnd > apptStart) {
      final overlapStart = apptStart > slotStart ? apptStart : slotStart;
      final overlapEnd = apptEnd < slotEnd ? apptEnd : slotEnd;
      final relativeStart = overlapStart.inMinutes - slotStart.inMinutes;
      final relativeEnd = overlapEnd.inMinutes - slotStart.inMinutes;
      overlaps.add((
        relativeStart.clamp(0, slotDurationMinutes),
        relativeEnd.clamp(0, slotDurationMinutes),
      ));
    }
  }

  if (overlaps.isNotEmpty) {
    // Merge intervals to avoid double counting.
    overlaps.sort((a, b) => a.$1.compareTo(b.$1));
    final merged = <(int, int)>[];
    for (final o in overlaps) {
      if (merged.isEmpty) {
        merged.add(o);
      } else {
        final last = merged.last;
        if (o.$1 <= last.$2) {
          merged[merged.length - 1] = (last.$1, math.max(last.$2, o.$2));
        } else {
          merged.add(o);
        }
      }
    }
    final coveredMinutes = merged.fold<int>(
      0,
      (sum, it) => sum + (it.$2 - it.$1),
    );
    if (coveredMinutes >= slotDurationMinutes) {
      return Duration.zero;
    } else {
      return Duration(minutes: slotDurationMinutes - coveredMinutes);
    }
  }

  // Fully free slot: extend to next busy slot.
  int nextBusy = layout.totalSlots;
  for (int i = index + 1; i < layout.totalSlots; i++) {
    final sStart = Duration(minutes: i * layout.minutesPerSlot);
    final sEnd = Duration(minutes: (i + 1) * layout.minutesPerSlot);
    final isBusy = appointments.any((a) {
      final start = Duration(
        hours: a.startTime.hour,
        minutes: a.startTime.minute,
      );
      final end = Duration(hours: a.endTime.hour, minutes: a.endTime.minute);
      return sStart < end && sEnd > start;
    });
    if (isBusy) {
      nextBusy = i;
      break;
    }
  }

  final freeSlotsCount = nextBusy - index;
  final freeMinutes = freeSlotsCount * layout.minutesPerSlot;
  return Duration(minutes: freeMinutes);
}
--- FILE: lib/features/agenda/presentation/screens/widgets/appointment_card_interactive.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/models/appointment.dart';
import '../../../../../../app/providers/form_factor_provider.dart';
import '../../../../../../core/l10n/l10_extension.dart';
import '../../../../../../core/widgets/app_dialogs.dart';
import '../../../domain/config/agenda_theme.dart';
import '../../../domain/config/layout_config.dart';
import '../../../providers/agenda_interaction_lock_provider.dart';
import '../../../providers/agenda_providers.dart';
import '../../../providers/appointment_providers.dart';
import '../../../providers/drag_layer_link_provider.dart';
import '../../../providers/drag_offset_provider.dart';
import '../../../providers/drag_session_provider.dart';
import '../../../providers/dragged_appointment_provider.dart';
import '../../../providers/dragged_base_range_provider.dart';
import '../../../providers/dragged_last_staff_provider.dart';
import '../../../providers/highlighted_staff_provider.dart';
import '../../../providers/is_resizing_provider.dart';
import '../../../providers/layout_config_provider.dart';
import '../../../providers/resizing_provider.dart';
import '../../../providers/selected_appointment_provider.dart';
import '../../../providers/staff_columns_geometry_provider.dart';
import '../../../providers/temp_drag_time_provider.dart';
import '../../widgets/appointment_dialog.dart';
import '../../../../clients/providers/clients_providers.dart';
import '../../../providers/bookings_provider.dart';

/// üîπ Versione unificata per DESKTOP e MOBILE.
/// Mantiene drag, resize, ghost, select, ma cambia il comportamento del tap:
/// - Desktop ‚Üí seleziona la card.
/// - Mobile ‚Üí apre un bottom sheet con i dettagli.
class AppointmentCardInteractive extends ConsumerStatefulWidget {
  final Appointment appointment;
  final Color color;
  final double? columnWidth;
  final double? columnOffset;
  final double? dragTargetWidth;
  final bool expandToLeft;

  const AppointmentCardInteractive({
    super.key,
    required this.appointment,
    required this.color,
    this.columnWidth,
    this.columnOffset,
    this.dragTargetWidth,
    this.expandToLeft = false,
  });

  @override
  ConsumerState<AppointmentCardInteractive> createState() =>
      _AppointmentCardInteractiveState();
}

class _AppointmentCardInteractiveState
    extends ConsumerState<AppointmentCardInteractive> {
  Size? _lastSize;
  Offset? _lastPointerGlobalPosition;
  bool _isDraggingResize = false;
  bool _blockDragDuringResize = false;
  bool _selectedFromHover = false;
  int? _currentDragSessionId;
  late final AgendaCardHoverNotifier _hoverNotifier;

  static const double _dragBlockZoneHeight = 28.0;
  static const int _minSlotsForDragBlock = 3;

  LayoutConfig get _layoutConfig => ref.read(layoutConfigProvider);

  @override
  void initState() {
    super.initState();
    _hoverNotifier = ref.read(agendaCardHoverProvider.notifier);
  }

  @override
  Widget build(BuildContext context) {
    final selection = ref.watch(selectedAppointmentProvider);
    final draggedId = ref.watch(draggedAppointmentIdProvider);
    final formFactor = ref.watch(formFactorProvider);

    final isSelected = selection.contains(widget.appointment.id);
    final isDragging = draggedId == widget.appointment.id;
    final showThickBorder = isSelected || isDragging;

    return MouseRegion(
      onEnter: (_) {
        _hoverNotifier.enter();
        _selectAppointment(ref, fromHover: true);
      },
      onExit: (_) {
        _hoverNotifier.exit();
        if (_selectedFromHover &&
            ref
                .read(selectedAppointmentProvider)
                .contains(widget.appointment.id) &&
            ref.read(draggedAppointmentIdProvider) != widget.appointment.id &&
            !ref.read(isResizingProvider)) {
          ref.read(selectedAppointmentProvider.notifier).clear();
          _selectedFromHover = false;
        }
      },
      child: LayoutBuilder(
        builder: (context, constraints) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            final size = Size(constraints.maxWidth, constraints.maxHeight);
            if (mounted && (_lastSize == null || _lastSize != size)) {
              setState(() => _lastSize = size);
            }
          });

          return Listener(
            onPointerDown: (e) {
              final cardBox = context.findRenderObject() as RenderBox?;
              if (cardBox != null) {
                _lastPointerGlobalPosition = e.position;
                _evaluateDragBlock(cardBox, e.position);
                ref
                    .read(draggedBaseRangeProvider.notifier)
                    .set(
                      widget.appointment.startTime,
                      widget.appointment.endTime,
                    );
                ref
                    .read(draggedLastStaffIdProvider.notifier)
                    .set(widget.appointment.staffId);

                final bodyBox = ref.read(dragBodyBoxProvider);
                if (bodyBox != null) {
                  final cardTopLeftGlobal = cardBox.localToGlobal(Offset.zero);
                  ref
                      .read(dragOffsetProvider.notifier)
                      .set(e.position.dy - cardTopLeftGlobal.dy);
                  ref
                      .read(dragOffsetXProvider.notifier)
                      .set(e.position.dx - cardTopLeftGlobal.dx);
                  final localStart = bodyBox.globalToLocal(e.position);
                  ref.read(dragPositionProvider.notifier).set(localStart);
                }
              }
            },
            onPointerMove: (e) {
              if (_isDraggingResize) {
                _performResizeUpdate(e);
                return;
              }
              final cardBox = context.findRenderObject() as RenderBox?;
              if (cardBox != null) {
                _evaluateDragBlock(cardBox, e.position);
              }
            },
            onPointerUp: (e) {
              if (_isDraggingResize) {
                _performResizeEnd();
                return;
              }
              if (ref.read(dragPositionProvider) != null) {
                ref.read(dragPositionProvider.notifier).clear();
              }
              _updateDragBlock(false);
              ref.read(draggedBaseRangeProvider.notifier).clear();
              ref.read(draggedLastStaffIdProvider.notifier).clear();
            },
            onPointerCancel: (e) {
              if (_isDraggingResize) {
                _performResizeCancel();
                return;
              }
              if (ref.read(dragPositionProvider) != null) {
                ref.read(dragPositionProvider.notifier).clear();
              }
              _updateDragBlock(false);
              ref.read(draggedBaseRangeProvider.notifier).clear();
              ref.read(draggedLastStaffIdProvider.notifier).clear();
            },
            child: GestureDetector(
              onTap: () {
                if (formFactor == AppFormFactor.mobile) {
                  _handleMobileTap();
                } else {
                  _handleDesktopTap();
                }
              },
              child: LongPressDraggable<Appointment>(
                data: widget.appointment,
                feedback: Consumer(
                  builder: (c, r, _) =>
                      _buildFollowerFeedback(c, r, isSelected),
                ),
                feedbackOffset: Offset.zero,
                dragAnchorStrategy: childDragAnchorStrategy,
                maxSimultaneousDrags: _blockDragDuringResize ? 0 : 1,
                childWhenDragging: _buildCard(
                  isGhost: true,
                  showThickBorder: showThickBorder,
                  isSelected: isSelected,
                ),

                onDragStarted: () {
                  _currentDragSessionId = ref
                      .read(dragSessionProvider.notifier)
                      .start();
                  ref
                      .read(draggedBaseRangeProvider.notifier)
                      .set(
                        widget.appointment.startTime,
                        widget.appointment.endTime,
                      );
                  _selectAppointment(ref);
                  ref
                      .read(draggedAppointmentIdProvider.notifier)
                      .set(widget.appointment.id);

                  final bodyBox = ref.read(dragBodyBoxProvider);
                  if (bodyBox != null && _lastPointerGlobalPosition != null) {
                    final local = bodyBox.globalToLocal(
                      _lastPointerGlobalPosition!,
                    );
                    ref.read(dragPositionProvider.notifier).set(local);
                  }
                },

                onDragUpdate: (details) {
                  final prev = ref.read(dragPositionProvider);
                  final bodyBox = ref.read(dragBodyBoxProvider);
                  if (bodyBox != null) {
                    final local = bodyBox.globalToLocal(details.globalPosition);
                    ref
                        .read(dragPositionProvider.notifier)
                        .set(Offset.lerp(prev, local, 0.85)!);
                  }
                },

                onDragEnd: (details) => _handleDragEnd(ref, details),
                onDragCompleted: () => _handleEnd(ref, keepSelection: true),
                onDraggableCanceled: (_, __) =>
                    _handleEnd(ref, keepSelection: true),

                child: _buildCard(
                  showThickBorder: showThickBorder,
                  isResizingDisabled: isDragging,
                  isSelected: isSelected,
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  @override
  void dispose() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _hoverNotifier.exit();
    });
    super.dispose();
  }

  void _handleEnd(WidgetRef ref, {bool keepSelection = false}) {
    ref.read(dragSessionProvider.notifier).clear();
    _currentDragSessionId = null;
    ref.read(draggedAppointmentIdProvider.notifier).clear();
    ref.read(dragOffsetProvider.notifier).clear();
    ref.read(dragOffsetXProvider.notifier).clear();
    ref.read(dragPositionProvider.notifier).clear();
    ref.read(tempDragTimeProvider.notifier).clear();
    if (keepSelection) {
      _selectAppointment(ref);
    } else {
      ref.read(selectedAppointmentProvider.notifier).clear();
    }
    ref.read(draggedBaseRangeProvider.notifier).clear();
    ref.read(draggedLastStaffIdProvider.notifier).clear();
  }

  void _selectAppointment(WidgetRef ref, {bool fromHover = false}) {
    _selectedFromHover = fromHover;
    final sel = ref.read(selectedAppointmentProvider.notifier);
    sel.toggleByAppointment(widget.appointment);
  }

  void _handleDragEnd(WidgetRef ref, DraggableDetails details) {
    if (details.wasAccepted) {
      _handleEnd(ref, keepSelection: true);
      return;
    }

    final session = ref.read(dragSessionProvider);
    final handledByTarget =
        session.dropHandled &&
        session.id != null &&
        session.id == _currentDragSessionId;
    if (handledByTarget) {
      _handleEnd(ref, keepSelection: true);
      return;
    }

    final bodyBox = ref.read(dragBodyBoxProvider);
    final columns = ref.read(staffColumnsGeometryProvider);
    if (bodyBox == null || columns.isEmpty) {
      _handleEnd(ref, keepSelection: true);
      return;
    }

    final dragPosLocal = ref.read(dragPositionProvider);
    final lastStaffId = ref.read(draggedLastStaffIdProvider);
    final offY = ref.read(dragOffsetProvider) ?? 0;
    final offX = ref.read(dragOffsetXProvider) ?? 0;
    final pointerGlobal = details.offset + Offset(offX, offY);
    final pointerLocal = bodyBox.globalToLocal(pointerGlobal);
    final releaseOffset = dragPosLocal ?? pointerLocal;
    final bodyOffset = pointerLocal;
    const tolerance = 4.0;

    int? targetStaffId;
    Rect? targetRect;
    for (final entry in columns.entries) {
      final rect = entry.value.inflate(tolerance);
      if (releaseOffset.dx >= rect.left && releaseOffset.dx <= rect.right) {
        targetStaffId = entry.key;
        targetRect = rect;
        break;
      }
    }

    if (targetStaffId == null || targetRect == null) {
      for (final entry in columns.entries) {
        final rect = entry.value.inflate(tolerance);
        if (bodyOffset.dx >= rect.left && bodyOffset.dx <= rect.right) {
          targetStaffId = entry.key;
          targetRect = rect;
          break;
        }
      }
    }

    final int dropStaffId =
        targetStaffId ?? lastStaffId ?? widget.appointment.staffId;
    targetRect ??= columns[dropStaffId];

    if (targetRect == null) {
      _handleEnd(ref, keepSelection: true);
      return;
    }

    double localY = releaseOffset.dy - targetRect.top;
    final slotHeight = _layoutConfig.slotHeight;
    final minutesPerSlot = _layoutConfig.minutesPerSlot;
    final totalMinutes = LayoutConfig.hoursInDay * 60;

    final baseDate = DateTime(
      widget.appointment.startTime.year,
      widget.appointment.startTime.month,
      widget.appointment.startTime.day,
    );

    final durationMinutes = widget.appointment.endTime
        .difference(widget.appointment.startTime)
        .inMinutes;

    final rawMaxStart = totalMinutes - durationMinutes;
    final maxStartMinutes = rawMaxStart < 0 ? 0 : rawMaxStart;

    double minutesFromTop = (localY / slotHeight) * minutesPerSlot;
    int roundedMinutes = ((minutesFromTop / 5).round() * 5).toInt();
    if (roundedMinutes < 0) {
      roundedMinutes = 0;
    } else if (roundedMinutes > maxStartMinutes) {
      roundedMinutes = maxStartMinutes;
    }

    final newStart = baseDate.add(Duration(minutes: roundedMinutes));
    var newEnd = newStart.add(Duration(minutes: durationMinutes));
    final dayBoundary = baseDate.add(const Duration(days: 1));
    if (newEnd.isAfter(dayBoundary)) newEnd = dayBoundary;

    ref
        .read(appointmentsProvider.notifier)
        .moveAppointment(
          appointmentId: widget.appointment.id,
          newStaffId: dropStaffId,
          newStart: newStart,
          newEnd: newEnd,
        );

    _handleEnd(ref, keepSelection: true);
  }

  void _evaluateDragBlock(RenderBox cardBox, Offset globalPosition) {
    final selection = ref.read(selectedAppointmentProvider);
    if (!selection.contains(widget.appointment.id)) {
      _updateDragBlock(false);
      return;
    }

    final localPos = cardBox.globalToLocal(globalPosition);
    final cardHeight = cardBox.size.height;
    final distanceFromBottom = cardHeight - localPos.dy;

    final minHeightForBlocking =
        _layoutConfig.slotHeight * _minSlotsForDragBlock;

    final shouldBlock =
        distanceFromBottom >= 0 &&
        distanceFromBottom <= _dragBlockZoneHeight &&
        cardHeight >= minHeightForBlocking;

    _updateDragBlock(shouldBlock);
  }

  void _updateDragBlock(bool value) {
    if (_blockDragDuringResize == value) return;
    if (!mounted) {
      _blockDragDuringResize = value;
      return;
    }
    setState(() => _blockDragDuringResize = value);
  }

  // üîπ Logica per il tap su DESKTOP/TABLET
  void _handleDesktopTap() async {
    final resizingNow = ref.read(isResizingProvider);
    if (resizingNow) return;

    _selectAppointment(ref);

    ref.read(dragOffsetProvider.notifier).clear();
    ref.read(dragOffsetXProvider.notifier).clear();
    ref.read(dragPositionProvider.notifier).clear();
    ref.read(highlightedStaffIdProvider.notifier).clear();

    // Legge l'appuntamento aggiornato dal provider (potrebbe essere stato
    // modificato tramite resize o drag)
    final currentAppointment = ref
        .read(appointmentsProvider)
        .firstWhere((a) => a.id == widget.appointment.id);

    // Apre direttamente la vista di modifica dell'appuntamento
    await showAppointmentDialog(context, ref, initial: currentAppointment);

    if (!mounted) return;
    ref.read(selectedAppointmentProvider.notifier).clear();
  }

  // üîπ Logica per il tap su MOBILE (apre il dialogo di modifica come prima)
  void _handleMobileTap() async {
    final resizingNow = ref.read(isResizingProvider);
    if (resizingNow) return;

    _selectAppointment(ref);

    // Legge l'appuntamento aggiornato dal provider (potrebbe essere stato
    // modificato tramite resize o drag)
    final currentAppointment = ref
        .read(appointmentsProvider)
        .firstWhere((a) => a.id == widget.appointment.id);

    // Apre direttamente la vista di modifica dell'appuntamento
    await showAppointmentDialog(context, ref, initial: currentAppointment);

    if (!mounted) return;
    ref.read(selectedAppointmentProvider.notifier).clear();
  }

  Widget _buildCard({
    bool isGhost = false,
    bool forFeedback = false,
    bool showThickBorder = false,
    bool isResizingDisabled = false,
    required bool isSelected,
    DateTime? overrideStart,
    DateTime? overrideEnd,
  }) {
    final resizingEntry = ref.watch(
      resizingEntryProvider(widget.appointment.id),
    );
    final booking = ref.watch(bookingsProvider)[widget.appointment.bookingId];
    final bookingNotes = booking?.notes?.trim();
    final clientNotes = widget.appointment.clientId != null
        ? ref
            .watch(clientsByIdProvider)[widget.appointment.clientId!]
            ?.notes
            ?.trim()
        : null;
    final hasBookingNotes =
        bookingNotes != null && bookingNotes.isNotEmpty;
    final hasClientNotes = clientNotes != null && clientNotes.isNotEmpty;
    final hasNotes = hasBookingNotes || hasClientNotes;

    final baseColor = widget.color.withOpacity(0.15);
    const r = BorderRadius.all(Radius.circular(6));

    final startTime = overrideStart ?? widget.appointment.startTime;
    final endTime =
        resizingEntry?.provisionalEndTime ??
        overrideEnd ??
        widget.appointment.endTime;

    final start = _formatTime(startTime);
    final formattedEndTime = _formatTime(endTime);
    final client = widget.appointment.clientName;

    final pieces = <String>[];
    if (widget.appointment.serviceName.isNotEmpty) {
      pieces.add(widget.appointment.serviceName);
    }
    if (widget.appointment.formattedPrice.isNotEmpty) {
      pieces.add(widget.appointment.formattedPrice);
    }
    final info = pieces.join(' ‚Äì ');
    final borderWidth = showThickBorder ? 2.5 : 1.0;

    final animationDuration = _isDraggingResize || forFeedback
        ? Duration.zero
        : const Duration(milliseconds: 80);
    final animationCurve = _isDraggingResize || forFeedback
        ? Curves.linear
        : Curves.easeOutQuad;

    return Opacity(
      opacity: isGhost ? AgendaTheme.ghostOpacity : 1,
      child: Material(
        borderRadius: r,
        color: Colors.transparent,
        child: AnimatedContainer(
          duration: animationDuration,
          curve: animationCurve,
          decoration: BoxDecoration(
            color: Color.alphaBlend(baseColor, Colors.white),
            borderRadius: r,
            border: Border.all(color: widget.color, width: borderWidth),
            boxShadow: [
              BoxShadow(
                color: widget.color.withOpacity(showThickBorder ? 0.25 : 0.1),
                blurRadius: showThickBorder ? 8 : 4,
                offset: showThickBorder
                    ? const Offset(2, 3)
                    : const Offset(1, 1),
              ),
            ],
          ),
          child: Stack(
            children: [
              _ExtraMinutesBand(
                ratio: _extraMinutesRatio(startTime, endTime),
                color: widget.color,
              ),

              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 4),
                child: Align(
                  alignment: Alignment.topLeft,
                  child: _buildContent(
                    start,
                    formattedEndTime,
                    client,
                    info,
                    showNotes: hasNotes && !forFeedback,
                    onNotesTap: hasNotes && !forFeedback
                        ? () => _showNotesDialog(
                              bookingNotes: hasBookingNotes ? bookingNotes : null,
                              clientNotes: hasClientNotes ? clientNotes : null,
                            )
                        : null,
                  ),
                ),
              ),
              if (!forFeedback && !isResizingDisabled && isSelected)
                _buildResizeHandle(),
            ],
          ),
        ),
      ),
    );
  }

  String _formatTime(DateTime time) {
    final dayStart = DateTime(
      widget.appointment.startTime.year,
      widget.appointment.startTime.month,
      widget.appointment.startTime.day,
    );

    final dayBoundary = dayStart.add(const Duration(days: 1));
    if (time.isAtSameMomentAs(dayBoundary)) return '24:00';

    final hours = time.hour.toString().padLeft(2, '0');
    final minutes = time.minute.toString().padLeft(2, '0');
    return '$hours:$minutes';
  }

  // Menu contestuale disabilitato su desktop: rimosso

  Widget _buildContent(
    String start,
    String end,
    String client,
    String info, {
    required bool showNotes,
    VoidCallback? onNotesTap,
  }) {
    return ClipRect(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          Flexible(
            child: Row(
              children: [
                Expanded(
                  child: RichText(
                    maxLines: 1,
                    softWrap: false,
                    overflow: TextOverflow.ellipsis,
                    text: TextSpan(
                      children: [
                        TextSpan(
                          text: '$start - $end  ',
                          style: const TextStyle(
                            color: Colors.black87,
                            fontWeight: FontWeight.w700,
                          ),
                        ),
                        TextSpan(
                          text: client,
                          style: const TextStyle(
                            color: Colors.grey,
                            fontWeight: FontWeight.w600,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                if (showNotes)
                  Padding(
                    padding: const EdgeInsets.only(left: 4),
                    child: Tooltip(
                      message: context.l10n.appointmentNotesTitle,
                      child: InkWell(
                        onTap: onNotesTap,
                        borderRadius: BorderRadius.circular(6),
                        child: const Padding(
                          padding: EdgeInsets.all(2),
                          child: Icon(
                            Icons.sticky_note_2_outlined,
                            size: 14,
                            color: Colors.black54,
                          ),
                        ),
                      ),
                    ),
                  ),
              ],
            ),
          ),
          if (info.isNotEmpty)
            Flexible(
              child: Text(
                info,
                maxLines: 1,
                softWrap: false,
                overflow: TextOverflow.ellipsis,
                style: const TextStyle(
                  fontSize: 11,
                  color: Colors.black54,
                  height: 1.1,
                ),
              ),
            ),
        ],
      ),
    );
  }

  void _showNotesDialog({
    String? bookingNotes,
    String? clientNotes,
  }) {
    if ((bookingNotes == null || bookingNotes.trim().isEmpty) &&
        (clientNotes == null || clientNotes.trim().isEmpty)) {
      return;
    }
    final l10n = context.l10n;
    final sections = <Widget>[];
    if (clientNotes != null && clientNotes.trim().isNotEmpty) {
      sections.add(Text(
        l10n.clientNoteLabel,
        style: Theme.of(context).textTheme.titleSmall,
      ));
      sections.add(const SizedBox(height: 4));
      sections.add(Text(clientNotes.trim()));
    }
    if (bookingNotes != null && bookingNotes.trim().isNotEmpty) {
      if (sections.isNotEmpty) {
        sections.add(const SizedBox(height: 12));
      }
      sections.add(Text(
        l10n.appointmentNoteLabel,
        style: Theme.of(context).textTheme.titleSmall,
      ));
      sections.add(const SizedBox(height: 4));
      sections.add(Text(bookingNotes.trim()));
    }
    showAppInfoDialog(
      context,
      title: Text(l10n.appointmentNotesTitle),
      content: ConstrainedBox(
        constraints: const BoxConstraints(maxWidth: 360),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: sections,
        ),
      ),
      closeLabel: l10n.actionClose,
    );
  }

  
  double _extraMinutesRatio(DateTime start, DateTime end) {
    final totalMinutes = end.difference(start).inMinutes;
    if (totalMinutes <= 0) return 0;
    final extra = _extraMinutesForAppointment();
    if (extra <= 0) return 0;
    final ratio = extra / totalMinutes;
    if (ratio < 0) return 0;
    if (ratio > 1) return 1;
    return ratio;
  }

  int _extraMinutesForAppointment() {
    return widget.appointment.blockedExtraMinutes;
  }

  void _performResizeUpdate(PointerEvent details) {
    if (_lastPointerGlobalPosition == null) return;
    final currentGlobal = details.position;
    final deltaY = currentGlobal.dy - _lastPointerGlobalPosition!.dy;
    _lastPointerGlobalPosition = currentGlobal;

    final minutesPerPixel =
        _layoutConfig.minutesPerSlot / _layoutConfig.slotHeight;
    final pixelsPerMinute = 1 / minutesPerPixel;
    final dayEnd = DateTime(
      widget.appointment.startTime.year,
      widget.appointment.startTime.month,
      widget.appointment.startTime.day,
    ).add(const Duration(days: 1));

    ref
        .read(resizingProvider.notifier)
        .updateDuringResize(
          appointmentId: widget.appointment.id,
          deltaDy: deltaY,
          pixelsPerMinute: pixelsPerMinute,
          dayEnd: dayEnd,
          minDurationMinutes: 5,
          snapMinutes: 5,
        );
  }

  void _performResizeEnd() async {
    final newEnd = ref
        .read(resizingProvider.notifier)
        .commitResizeAndEnd(appointmentId: widget.appointment.id);

    if (newEnd != null) {
      final appt = widget.appointment;
      final minEnd = appt.startTime.add(const Duration(minutes: 5));
      ref
          .read(appointmentsProvider.notifier)
          .moveAppointment(
            appointmentId: appt.id,
            newStaffId: appt.staffId,
            newStart: appt.startTime,
            newEnd: newEnd.isAfter(minEnd) ? newEnd : minEnd,
          );
    }

    await Future.delayed(const Duration(milliseconds: 100));
    if (mounted) setState(() => _isDraggingResize = false);
    _lastPointerGlobalPosition = null;
    _updateDragBlock(false);
    ref.read(isResizingProvider.notifier).stop();
    ref.invalidate(resizingProvider);
    if (ref.read(dragPositionProvider) != null) {
      ref.read(dragPositionProvider.notifier).clear();
    }
  }

  void _performResizeCancel() {
    ref
        .read(resizingProvider.notifier)
        .cancelResize(appointmentId: widget.appointment.id);
    ref.read(isResizingProvider.notifier).stop();

    if (mounted) {
      setState(() => _isDraggingResize = false);
    }
    _updateDragBlock(false);
    if (ref.read(dragPositionProvider) != null) {
      ref.read(dragPositionProvider.notifier).clear();
    }
  }

  // üîπ Resize identico all‚Äôoriginale
  Widget _buildResizeHandle() {
    return Align(
      alignment: Alignment.bottomCenter,
      child: MouseRegion(
        cursor: SystemMouseCursors.resizeUpDown,
        child: GestureDetector(
          behavior: HitTestBehavior.opaque,
          onVerticalDragStart: (details) {
            final renderBox = context.findRenderObject() as RenderBox?;
            final currentHeightPx = renderBox?.size.height ?? 0;
            _lastPointerGlobalPosition = details.globalPosition;
            _updateDragBlock(true);

            ref
                .read(resizingProvider.notifier)
                .startResize(
                  appointmentId: widget.appointment.id,
                  currentHeightPx: currentHeightPx,
                  startTime: widget.appointment.startTime,
                  endTime: widget.appointment.endTime,
                );
            ref.read(isResizingProvider.notifier).start();
            setState(() => _isDraggingResize = true);
          },
          onVerticalDragUpdate: (details) {
            // Gestito da onPointerMove
          },
          onVerticalDragEnd: (_) {
            // Gestito da onPointerUp
          },
          onVerticalDragCancel: () {
            // Gestito da onPointerCancel
          },
          child: Container(
            height: 20,
            width: double.infinity,
            alignment: Alignment.bottomCenter,
            child: const Padding(
              padding: EdgeInsets.only(bottom: 1),
              child: Icon(Icons.drag_indicator, size: 14, color: Colors.grey),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildFollowerFeedback(
    BuildContext context,
    WidgetRef ref,
    bool isSelected,
  ) {
    final layoutConfig = ref.watch(layoutConfigProvider);
    final times = ref.watch(tempDragTimeProvider);
    final start = times?.$1;
    final end = times?.$2;

    final dragPos = ref.watch(dragPositionProvider);
    final offY = ref.watch(dragOffsetProvider) ?? 0;
    final offX = ref.watch(dragOffsetXProvider) ?? 0;
    final link = ref.watch(dragLayerLinkProvider);

    final highlightedId = ref.watch(highlightedStaffIdProvider);
    final columnsRects = ref.watch(staffColumnsGeometryProvider);

    final padding = LayoutConfig.columnInnerPadding;
    final fallbackWidth = widget.columnWidth ?? _lastSize?.width ?? 180.0;
    double effectiveWidth = widget.dragTargetWidth ?? fallbackWidth;
    if (effectiveWidth <= 0) {
      effectiveWidth = fallbackWidth > 0 ? fallbackWidth : 180.0;
    }
    final h = _lastSize?.height ?? 50.0;

    if (dragPos == null) return const SizedBox.shrink();

    final bodyBox = ref.read(dragBodyBoxProvider);
    final totalHeight = bodyBox?.size.height ?? layoutConfig.totalHeight;
    final cardHeight = h;

    final double unconstrainedTop = dragPos.dy - offY;
    double top = unconstrainedTop;
    double translateY = 0;

    double maxTop = totalHeight - cardHeight;
    if (maxTop < 0) maxTop = 0;

    if (unconstrainedTop < 0) {
      translateY = 0;
      top = 0;
    } else if (unconstrainedTop > maxTop) {
      translateY = 0;
      top = maxTop;
    }

    double left;
    final rect = highlightedId != null ? columnsRects[highlightedId] : null;

    // Limitiamo sempre la X minima all'inizio del body (0 + padding),
    // cos√¨ il feedback non entra mai nell'area della colonna oraria.
    final double globalMinLeft = padding;
    double minLeft = rect != null ? rect.left + padding : padding;
    if (minLeft < globalMinLeft) minLeft = globalMinLeft;

    if (rect != null) {
      left = rect.left + padding;
      final availableWidth = rect.width - padding * 2;
      if (availableWidth > 0 && availableWidth < effectiveWidth) {
        effectiveWidth = availableWidth;
      } else if (availableWidth > 0 && widget.dragTargetWidth == null) {
        effectiveWidth = availableWidth;
      }
      if (left < minLeft) left = minLeft;
    } else {
      left = dragPos.dx - offX - padding;
      if (widget.expandToLeft) left -= (effectiveWidth / 2);
      if (left < minLeft) left = minLeft;
    }

    final dpr = MediaQuery.of(context).devicePixelRatio;
    left = (left * dpr).round() / dpr;
    top = (top * dpr).round() / dpr;
    translateY = (translateY * dpr).round() / dpr;

    // üîπ Se non abbiamo ancora il bodyBox, evitiamo di disegnare il feedback
    if (bodyBox == null) {
      return const SizedBox.shrink();
    }

    // üîπ Clip minimo solo verticalmente, manteniamo la larghezza della card.
    return RepaintBoundary(
      child: CompositedTransformFollower(
        link: link,
        showWhenUnlinked: false,
        offset: Offset(left, top),
        child: SizedBox(
          width: effectiveWidth,
          height: h,
          child: ClipRect(
            child: Transform.translate(
              offset: Offset(0, translateY),
              child: Material(
                color: Colors.transparent,
                borderRadius: const BorderRadius.all(Radius.circular(6)),
                clipBehavior: Clip.antiAlias,
                child: _buildCard(
                  forFeedback: true,
                  showThickBorder: true,
                  overrideStart: start,
                  overrideEnd: end,
                  isSelected: isSelected,
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

} // Closing brace for _AppointmentCardInteractiveState

class _ExtraMinutesBand extends StatelessWidget {
  const _ExtraMinutesBand({required this.ratio, required this.color});

  final double ratio;
  final Color color;

  @override
  Widget build(BuildContext context) {
    if (ratio <= 0) return const SizedBox.shrink();
    return Positioned.fill(
      child: Align(
        alignment: Alignment.bottomCenter,
        child: FractionallySizedBox(
          heightFactor: ratio,
          widthFactor: 1,
          child: Container(
            decoration: BoxDecoration(
              color: color.withOpacity(0.18),
              borderRadius: const BorderRadius.vertical(
                bottom: Radius.circular(6),
              ),
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/appointment_card_base.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/models/appointment.dart';
import 'appointment_card_interactive.dart';

/// Wrapper unico che istanzia la versione interattiva
/// per entrambi i form factor (desktop e mobile).
class AppointmentCard extends ConsumerWidget {
  final Appointment appointment;
  final Color color;
  final double? columnWidth;
  final double? columnOffset;
  final double? dragTargetWidth;
  final bool expandToLeft;

  const AppointmentCard({
    super.key,
    required this.appointment,
    required this.color,
    this.columnWidth,
    this.columnOffset,
    this.dragTargetWidth,
    this.expandToLeft = false,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return AppointmentCardInteractive(
      appointment: appointment,
      color: color,
      columnWidth: columnWidth,
      columnOffset: columnOffset,
      dragTargetWidth: dragTargetWidth,
      expandToLeft: expandToLeft,
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/unavailable_slot_pattern.dart ---
import 'package:flutter/material.dart';

import '../../../domain/config/layout_config.dart';

/// Painter leggero che disegna linee diagonali.
/// Usa `isComplex: true` e `willChange: false` per caching automatico.
class _DiagonalPatternPainter extends CustomPainter {
  final Color lineColor;
  final double lineWidth;
  final double spacing;

  const _DiagonalPatternPainter({
    required this.lineColor,
    required this.lineWidth,
    required this.spacing,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = lineColor
      ..strokeWidth = lineWidth
      ..style = PaintingStyle.stroke;

    // Disegna linee diagonali da sinistra-alto a destra-basso
    final double step = spacing;
    final double maxOffset = size.width + size.height;

    for (double offset = -size.height; offset < maxOffset; offset += step) {
      canvas.drawLine(
        Offset(offset, 0),
        Offset(offset + size.height, size.height),
        paint,
      );
    }
  }

  @override
  bool shouldRepaint(covariant _DiagonalPatternPainter oldDelegate) {
    return oldDelegate.lineColor != lineColor ||
        oldDelegate.lineWidth != lineWidth ||
        oldDelegate.spacing != spacing;
  }
}

/// Widget leggero che mostra un pattern a righe diagonali per indicare
/// uno slot non disponibile nell'agenda.
///
/// Ottimizzato per performance:
/// - Nessun state, nessun async
/// - CustomPaint con caching automatico (isComplex + willChange)
/// - RepaintBoundary per isolare i repaint
class UnavailableSlotPattern extends StatelessWidget {
  final double height;
  final Color? patternColor;
  final Color? backgroundColor;
  final double lineWidth;
  final double spacing;
  final BorderRadius? borderRadius;

  const UnavailableSlotPattern({
    super.key,
    required this.height,
    this.patternColor,
    this.backgroundColor,
    this.lineWidth = 1.5,
    this.spacing = 6.0,
    this.borderRadius,
  });

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final effectivePatternColor =
        patternColor ?? colorScheme.onSurface.withOpacity(0.25);
    final effectiveBackgroundColor =
        backgroundColor ?? colorScheme.surfaceContainerHighest.withOpacity(0.6);
    final effectiveBorderRadius = borderRadius ?? BorderRadius.circular(4);

    return DecoratedBox(
      decoration: BoxDecoration(
        color: effectiveBackgroundColor,
        borderRadius: effectiveBorderRadius,
      ),
      child: ClipRRect(
        borderRadius: effectiveBorderRadius,
        child: SizedBox(
          height: height,
          width: double.infinity,
          child: RepaintBoundary(
            child: CustomPaint(
              painter: _DiagonalPatternPainter(
                lineColor: effectivePatternColor,
                lineWidth: lineWidth,
                spacing: spacing,
              ),
              isComplex: true,
              willChange: false,
            ),
          ),
        ),
      ),
    );
  }
}

/// Variante con margini coerenti con le AppointmentCard.
class UnavailableSlotOverlay extends StatelessWidget {
  final double height;
  final double margin;
  final Color? patternColor;
  final Color? backgroundColor;

  const UnavailableSlotOverlay({
    super.key,
    required this.height,
    this.margin = LayoutConfig.columnInnerPadding,
    this.patternColor,
    this.backgroundColor,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: EdgeInsets.all(margin),
      child: UnavailableSlotPattern(
        height: height - (margin * 2),
        patternColor: patternColor,
        backgroundColor: backgroundColor,
      ),
    );
  }
}

/// Widget ottimizzato per coprire un range di slot consecutivi.
class UnavailableSlotRange extends StatelessWidget {
  final int slotCount;
  final double slotHeight;
  final double margin;
  final Color? patternColor;
  final Color? backgroundColor;

  const UnavailableSlotRange({
    super.key,
    required this.slotCount,
    required this.slotHeight,
    this.margin = LayoutConfig.columnInnerPadding,
    this.patternColor,
    this.backgroundColor,
  });

  @override
  Widget build(BuildContext context) {
    final totalHeight = slotCount * slotHeight;
    return Padding(
      padding: EdgeInsets.all(margin),
      child: UnavailableSlotPattern(
        height: totalHeight - (margin * 2),
        patternColor: patternColor,
        backgroundColor: backgroundColor,
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/current_time_line.dart ---
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/config/layout_config.dart';
import '../../../providers/date_range_provider.dart';
import '../../../providers/layout_config_provider.dart';

/// üîπ Linea rossa che indica l'orario corrente.
/// - visibile solo sulla data odierna
/// - sincronizzata minuto per minuto
/// - la posizione verticale effettiva viene corretta con [verticalOffset]
///   passato da AgendaScreen (offset di scroll della giornata).
class CurrentTimeLine extends ConsumerStatefulWidget {
  static const double horizontalMargin = 4.0;

  final double hourColumnWidth;
  final double verticalOffset;
  final double horizontalOffset;

  const CurrentTimeLine({
    super.key,
    required this.hourColumnWidth,
    required this.verticalOffset,
    this.horizontalOffset = 0,
  });

  @override
  ConsumerState<CurrentTimeLine> createState() => _CurrentTimeLineState();
}

class _CurrentTimeLineState extends ConsumerState<CurrentTimeLine> {
  Timer? _minuteTimer;
  double _offset = 0;
  String _label = '';
  late final ProviderSubscription<LayoutConfig> _layoutConfigSub;

  // üîπ Definiamo l'altezza della linea come costante
  static const double _lineHeight = 1.0;
  // üîπ Definiamo il margine/gap che conterr√† la linea
  static const double _lineMargin = CurrentTimeLine.horizontalMargin;

  @override
  void initState() {
    super.initState();

    // Ascolta i cambi di LayoutConfig (slotHeight / minutesPerSlot)
    _layoutConfigSub = ref.listenManual<LayoutConfig>(
      layoutConfigProvider,
      (prev, next) => _updateLine(configOverride: next),
      fireImmediately: true,
    );

    // Aggiornamento minuto per minuto
    _scheduleMinuteSync();
  }

  void _scheduleMinuteSync() {
    final now = DateTime.now();
    final msToNextMinute = 60000 - (now.second * 1000 + now.millisecond);
    _minuteTimer = Timer(Duration(milliseconds: msToNextMinute), () {
      _updateLine();
      _minuteTimer?.cancel();
      _minuteTimer = Timer.periodic(const Duration(minutes: 1), (_) {
        _updateLine();
      });
    });
  }

  void _updateLine({LayoutConfig? configOverride}) {
    final now = DateTime.now();
    final minutesSinceMidnight = now.hour * 60 + now.minute;
    final LayoutConfig config =
        configOverride ?? ref.read(layoutConfigProvider);

    final slotHeight = config.slotHeight;
    final offset = (minutesSinceMidnight / config.minutesPerSlot) * slotHeight;
    final label =
        "${now.hour.toString().padLeft(2, '0')}:${now.minute.toString().padLeft(2, '0')}";

    if (!mounted) return;
    setState(() {
      _offset = offset;
      _label = label;
    });
  }

  @override
  void dispose() {
    _minuteTimer?.cancel();
    _layoutConfigSub.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // Mostra la linea solo se la data visualizzata √® oggi
    final selectedDate = ref.watch(agendaDateProvider);
    final today = DateUtils.dateOnly(DateTime.now());
    final isToday = DateUtils.isSameDay(selectedDate, today);
    if (!isToday) {
      return const SizedBox.shrink();
    }

    final layout = ref.read(layoutConfigProvider);

    // üîπ Calcoliamo la posizione Y del CENTRO della linea
    final lineCenterY = _offset - widget.verticalOffset + layout.headerHeight;
    // üîπ Calcoliamo il 'top' per il Positioned
    final lineTopY = lineCenterY - (_lineHeight / 2);

    return Positioned(
      top: lineTopY,
      left: widget.horizontalOffset,
      right: 0,
      child: Stack(
        clipBehavior: Clip.none,
        children: [
          // --- Linea rossa orizzontale (l'elemento di riferimento) ---
          Row(
            children: [
              // Spazio per la colonna oraria
              SizedBox(width: widget.hourColumnWidth - _lineMargin),
              // Linea dalla fine del box fino al bordo destro
              Container(
                width: _lineMargin,
                height: _lineHeight,
                color: Colors.redAccent,
              ),
              Expanded(
                child: Container(height: _lineHeight, color: Colors.redAccent),
              ),
            ],
          ),
          // --- Box dell'orario (centrato verticalmente sulla linea) ---
          Positioned(
            left: -_lineMargin - 1,
            width: widget.hourColumnWidth,
            top: 0,
            child: FractionalTranslation(
              // Sposta il box del 50% della sua altezza verso l'alto
              // cos√¨ il suo centro si allinea con la linea
              translation: const Offset(0, -0.5),
              child: Align(
                alignment: Alignment.center,
                child: Container(
                  width: double.infinity,
                  decoration: BoxDecoration(
                    color: Colors.redAccent,
                    borderRadius: BorderRadius.circular(4),
                  ),
                  padding: const EdgeInsets.symmetric(vertical: 5),
                  child: Text(
                    _label,
                    textAlign: TextAlign.center,
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 11,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/agenda_dividers.dart ---
import 'package:flutter/material.dart';

/// Divider verticale sottile tra la colonna oraria e le colonne staff
class AgendaVerticalDivider extends StatelessWidget {
  final double height;
  final Color color;
  final double thickness;

  /// Altezza della porzione superiore con sfumatura (es. headerHeight)
  final double? fadeTopHeight;

  const AgendaVerticalDivider({
    super.key,
    required this.height,
    this.color = const Color(0xFFBDBDBD),
    this.thickness = 0.5,
    this.fadeTopHeight,
  });

  @override
  Widget build(BuildContext context) {
    // Se fadeTopHeight √® specificato, usa una Column con gradiente in alto
    if (fadeTopHeight != null && fadeTopHeight! > 0) {
      return SizedBox(
        height: height,
        width: thickness,
        child: Column(
          children: [
            // Parte superiore con gradiente sfumato
            Container(
              height: fadeTopHeight,
              width: thickness,
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topCenter,
                  end: Alignment.bottomCenter,
                  colors: [color.withOpacity(0.0), color],
                  stops: const [0.0, 0.7],
                ),
              ),
            ),
            // Parte inferiore con colore pieno
            Expanded(
              child: Container(width: thickness, color: color),
            ),
          ],
        ),
      );
    }

    // Comportamento originale senza sfumatura
    return SizedBox(
      height: height,
      width: thickness,
      child: DecoratedBox(decoration: BoxDecoration(color: color)),
    );
  }
}

/// Divider orizzontale usato per le righe orarie
class AgendaHorizontalDivider extends StatelessWidget {
  final double thickness;
  final Color color;

  const AgendaHorizontalDivider({
    super.key,
    this.thickness = 0.5,
    this.color = const Color(0xFFBDBDBD),
  });

  @override
  Widget build(BuildContext context) {
    return Divider(height: thickness, thickness: thickness, color: color);
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/hover_slot.dart ---
import 'package:agenda_backend/core/l10n/date_time_formats.dart';
import 'package:flutter/material.dart';

import '../../../domain/config/layout_config.dart';

/// Slot interattivo che reagisce all'hover del mouse.
/// Usa lo stesso margin, borderRadius e spessore del bordo delle AppointmentCard.
class HoverSlot extends StatefulWidget {
  final DateTime slotTime;
  final double height;
  final Color colorPrimary1;

  const HoverSlot({
    super.key,
    required this.slotTime,
    required this.height,
    required this.colorPrimary1,
  });

  @override
  State<HoverSlot> createState() => _HoverSlotState();
}

class _HoverSlotState extends State<HoverSlot> {
  bool _hovered = false;

  @override
  Widget build(BuildContext context) {
    final timeStr = DtFmt.hm(
      context,
      widget.slotTime.hour,
      widget.slotTime.minute,
    );

    final radius = BorderRadius.circular(4);
    final margin = EdgeInsets.all(LayoutConfig.columnInnerPadding);
    final borderWidth = LayoutConfig.borderWidth;

    return MouseRegion(
      onEnter: (_) => setState(() => _hovered = true),
      onExit: (_) => setState(() => _hovered = false),
      child: Container(
        margin: margin,
        height: widget.height - LayoutConfig.columnInnerPadding * 2,
        width: double.infinity,
        decoration: BoxDecoration(
          color: _hovered
              ? widget.colorPrimary1.withOpacity(0.06)
              : Colors.transparent,
          border: Border.all(
            color: _hovered
                ? widget.colorPrimary1.withOpacity(0.1)
                : Colors.transparent,
            width: _hovered ? borderWidth : 0,
          ),
          borderRadius: radius,
        ),
        child: _hovered
            ? Padding(
                padding: const EdgeInsets.all(2),
                child: Align(
                  alignment: Alignment.centerLeft,
                  child: Text(
                    timeStr,
                    style: TextStyle(
                      fontSize: 11,
                      fontWeight: FontWeight.w600,
                      color: widget.colorPrimary1,
                    ),
                  ),
                ),
              )
            : const SizedBox.expand(),
      ),
    );
  }
}

/// Wrapper that builds [HoverSlot] only when the pointer (mouse) or touch is
/// active on the slot. This avoids constructing the (slightly heavier)
/// hover contents for every slot when not needed.
class LazyHoverSlot extends StatefulWidget {
  final DateTime slotTime;
  final double height;
  final Color colorPrimary1;
  final void Function(DateTime)? onTap;

  const LazyHoverSlot({
    super.key,
    required this.slotTime,
    required this.height,
    required this.colorPrimary1,
    this.onTap,
  });

  @override
  State<LazyHoverSlot> createState() => _LazyHoverSlotState();
}

class _LazyHoverSlotState extends State<LazyHoverSlot> {
  bool _show = false;

  void _onEnter(PointerEvent _) {
    setState(() => _show = true);
  }

  void _onExit(PointerEvent _) {
    setState(() => _show = false);
  }

  void _onTapDown(TapDownDetails _) {
    // On touch devices show the hover content while pressing.
    setState(() => _show = true);
  }

  void _onTapUp(TapUpDetails _) {
    // Hide shortly after release to mimic hover disappearing.
    Future.delayed(const Duration(milliseconds: 250), () {
      if (mounted) setState(() => _show = false);
    });
  }

  void _onTapCancel() {
    setState(() => _show = false);
  }

  @override
  Widget build(BuildContext context) {
    // We keep the same size and margin as HoverSlot so layout doesn't jump.
    return MouseRegion(
      onEnter: _onEnter,
      onExit: _onExit,
      child: GestureDetector(
        behavior: HitTestBehavior.translucent,
        onTap: () => widget.onTap?.call(widget.slotTime),
        onTapDown: _onTapDown,
        onTapUp: _onTapUp,
        onTapCancel: _onTapCancel,
        child: SizedBox(
          height: widget.height,
          width: double.infinity,
          child: _show
              ? HoverSlot(
                  slotTime: widget.slotTime,
                  height: widget.height,
                  colorPrimary1: widget.colorPrimary1,
                )
              : Container(),
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/time_block_widget.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../core/l10n/l10_extension.dart';
import '../../../../../core/models/time_block.dart';
import '../../../domain/config/layout_config.dart';
import '../../dialogs/add_block_dialog.dart';

/// Widget per visualizzare un blocco di non disponibilit√† nell'agenda.
class TimeBlockWidget extends ConsumerWidget {
  final TimeBlock block;
  final double height;
  final double width;

  const TimeBlockWidget({
    super.key,
    required this.block,
    required this.height,
    required this.width,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final colorScheme = Theme.of(context).colorScheme;
    final blockColor = colorScheme.error.withOpacity(0.15);
    final borderColor = colorScheme.error.withOpacity(0.5);

    return GestureDetector(
      onTap: () {
        showAddBlockDialog(context, ref, initial: block);
      },
      child: Container(
        width: width,
        height: height,
        decoration: BoxDecoration(
          color: blockColor,
          borderRadius: BorderRadius.circular(LayoutConfig.borderRadius),
          border: Border.all(color: borderColor, width: 1.5),
        ),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(LayoutConfig.borderRadius - 1),
          child: Stack(
            children: [
              // Pattern diagonale
              CustomPaint(
                size: Size(width, height),
                painter: _DiagonalPatternPainter(
                  color: colorScheme.error.withOpacity(0.1),
                ),
              ),
              // Contenuto
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Row(
                      children: [
                        Icon(Icons.block, size: 14, color: colorScheme.error),
                        const SizedBox(width: 4),
                        Expanded(
                          child: Text(
                            block.reason ?? 'Blocco',
                            style: TextStyle(
                              fontSize: 12,
                              fontWeight: FontWeight.w600,
                              color: colorScheme.error,
                            ),
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                          ),
                        ),
                      ],
                    ),
                    if (height > 40) ...[
                      const SizedBox(height: 2),
                      Text(
                        _formatTimeRange(context, block),
                        style: TextStyle(
                          fontSize: 10,
                          color: colorScheme.error.withOpacity(0.8),
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  String _formatTimeRange(BuildContext context, TimeBlock block) {
    if (block.isAllDay) {
      return context.l10n.blockAllDay;
    }
    final start =
        '${block.startTime.hour.toString().padLeft(2, '0')}:${block.startTime.minute.toString().padLeft(2, '0')}';
    final end =
        '${block.endTime.hour.toString().padLeft(2, '0')}:${block.endTime.minute.toString().padLeft(2, '0')}';
    return '$start - $end';
  }
}

/// Painter per il pattern diagonale del blocco.
class _DiagonalPatternPainter extends CustomPainter {
  final Color color;

  _DiagonalPatternPainter({required this.color});

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 1.0
      ..style = PaintingStyle.stroke;

    const spacing = 8.0;
    final diagonal = size.width + size.height;

    for (double i = -size.height; i < diagonal; i += spacing) {
      canvas.drawLine(
        Offset(i, 0),
        Offset(i + size.height, size.height),
        paint,
      );
    }
  }

  @override
  bool shouldRepaint(covariant _DiagonalPatternPainter oldDelegate) {
    return oldDelegate.color != color;
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/staff_column.dart ---
import 'dart:async';
import 'dart:math' as math;

import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/core/l10n/date_time_formats.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/widgets/app_dialogs.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/widgets/hover_slot.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/widgets/unavailable_slot_pattern.dart';
import 'package:agenda_backend/features/agenda/providers/dragged_card_size_provider.dart';
import 'package:agenda_backend/features/agenda/providers/pending_drop_provider.dart';
import 'package:agenda_backend/features/agenda/providers/staff_slot_availability_provider.dart';
import 'package:agenda_backend/features/services/providers/services_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/models/appointment.dart';
import '/core/models/staff.dart';
import '/core/utils/color_utils.dart';
import '../../../domain/config/agenda_theme.dart';
import '../../../domain/config/layout_config.dart';
import '../../../providers/agenda_providers.dart';
import '../../../providers/appointment_providers.dart';
import '../../../providers/date_range_provider.dart';
import '../../../providers/drag_layer_link_provider.dart';
import '../../../providers/drag_offset_provider.dart';
import '../../../providers/drag_session_provider.dart';
import '../../../providers/dragged_appointment_provider.dart';
import '../../../providers/dragged_base_range_provider.dart';
import '../../../providers/dragged_last_staff_provider.dart';
import '../../../providers/fully_occupied_slots_provider.dart';
import '../../../providers/highlighted_staff_provider.dart';
// Nota: isResizingProvider viene gestito a un livello superiore (MultiStaffDayView),
// non √® necessario importarlo qui.
import '../../../providers/layout_config_provider.dart';
import '../../../providers/resizing_provider.dart';
import '../../../providers/selected_appointment_provider.dart';
import '../../../providers/staff_columns_geometry_provider.dart';
import '../../../providers/temp_drag_time_provider.dart';
import '../../../providers/time_blocks_provider.dart';
import '../../widgets/booking_dialog.dart';
import '../helper/drag_drop_helper.dart';
import '../helper/layout_geometry_helper.dart';
import '../widgets/agenda_dividers.dart';
import '../widgets/appointment_card_base.dart';
import '../widgets/time_block_widget.dart';

class StaffColumn extends ConsumerStatefulWidget {
  final Staff staff;
  final List<Appointment> appointments;
  final double columnWidth;
  final bool showRightBorder;
  final bool isInteractionLocked;

  const StaffColumn({
    super.key,
    required this.staff,
    required this.appointments,
    required this.columnWidth,
    required this.isInteractionLocked,
    this.showRightBorder = true,
  });

  @override
  ConsumerState<StaffColumn> createState() => _StaffColumnState();
}

class _StaffColumnState extends ConsumerState<StaffColumn> {
  bool _isHighlighted = false;
  double? _hoverY;
  late final ProviderSubscription<Offset?> _dragListener;
  late final HighlightedStaffIdNotifier _highlightedNotifier;
  late final StaffColumnsGeometryNotifier _geometryNotifier;
  late final ProviderSubscription<int?> _highlightSubscription;
  int? _latestHighlightedId;

  // 1. Aggiunta sottoscrizione per il layout
  late final ProviderSubscription<LayoutConfig> _layoutConfigSub;

  @override
  void initState() {
    super.initState();

    _highlightedNotifier = ref.read(highlightedStaffIdProvider.notifier);
    _geometryNotifier = ref.read(staffColumnsGeometryProvider.notifier);
    _latestHighlightedId = ref.read(highlightedStaffIdProvider);
    _highlightSubscription = ref.listenManual<int?>(
      highlightedStaffIdProvider,
      (previous, next) => _latestHighlightedId = next,
    );

    // 2. Pianifica l'aggiornamento della geometria dopo il primo frame
    _scheduleGeometryUpdate();

    // 3. Ascolta i cambi di layout per ri-pianificare l'aggiornamento
    _layoutConfigSub = ref.listenManual<LayoutConfig>(layoutConfigProvider, (
      prev,
      next,
    ) {
      // Aggiorna la geometria solo se le dimensioni cambiano
      if (prev == null ||
          prev.slotHeight != next.slotHeight ||
          prev.headerHeight != next.headerHeight) {
        _scheduleGeometryUpdate();
      }
    });

    _dragListener = ref.listenManual<Offset?>(dragPositionProvider, (
      previous,
      next,
    ) {
      if (!mounted) return;

      final tempTimeNotifier = ref.read(tempDragTimeProvider.notifier);

      if (next == null) {
        if (_isHighlighted || _hoverY != null) {
          setState(() {
            _isHighlighted = false;
            _hoverY = null;
          });
        }
        _highlightedNotifier.clear();
        tempTimeNotifier.clear();
        return;
      }

      final box = context.findRenderObject() as RenderBox?;
      final bodyBox = ref.read(dragBodyBoxProvider);
      if (box == null || bodyBox == null) return;

      final columnTopLeftInBody = bodyBox.globalToLocal(
        box.localToGlobal(Offset.zero),
      );

      // ‚úÖ Aggiorna la geometria solo se cambia realmente (scroll o resize)
      final newRect = Rect.fromLTWH(
        columnTopLeftInBody.dx,
        columnTopLeftInBody.dy,
        box.size.width,
        box.size.height,
      );

      if (_lastGeometryRect == null ||
          (newRect.top - _lastGeometryRect!.top).abs() > 0.5 ||
          (newRect.left - _lastGeometryRect!.left).abs() > 0.5 ||
          (newRect.width - _lastGeometryRect!.width).abs() > 0.5 ||
          (newRect.height - _lastGeometryRect!.height).abs() > 0.5) {
        _lastGeometryRect = newRect;
        _geometryNotifier.setRect(widget.staff.id, newRect);
      }

      final localInColumn = Offset(
        next.dx - columnTopLeftInBody.dx,
        next.dy - columnTopLeftInBody.dy,
      );

      final withinHorizontal =
          localInColumn.dx >= 0 && localInColumn.dx <= box.size.width;
      if (withinHorizontal) {
        final dragOffset = ref.read(dragOffsetProvider);
        final layoutConfig = ref.read(layoutConfigProvider);

        // üîπ Altezza effettiva della card trascinata (fallback 50px se non nota)
        final draggedCardHeightPx =
            ref.read(draggedCardSizeProvider)?.height ?? 50.0;

        // üîπ Punto massimo CONSENTITO per l'inizio della card in pixel
        final maxYStartPx = (box.size.height - draggedCardHeightPx)
            .clamp(0, box.size.height)
            .toDouble();

        // üîπ Y effettiva del "top" della card, clampata ai limiti verticali
        final clampedLocalDy = localInColumn.dy.clamp(
          0.0,
          box.size.height.toDouble(),
        );
        final double effectiveY = (clampedLocalDy - (dragOffset ?? 0))
            .clamp(0, maxYStartPx)
            .toDouble();

        setState(() {
          _hoverY = effectiveY;
          _isHighlighted = true;
        });
        _highlightedNotifier.set(widget.staff.id);
        ref.read(draggedLastStaffIdProvider.notifier).set(widget.staff.id);

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // ‚è± Calcolo orario proposto
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        final slotHeight = layoutConfig.slotHeight;

        // minuti dall'inizio giornata (00:00)
        final minutesFromTop =
            (effectiveY / slotHeight) * layoutConfig.minutesPerSlot;

        // arrotondiamo a step di 5 minuti
        double roundedMinutes = (minutesFromTop / 5).round() * 5;

        // durata dell'appuntamento trascinato
        final draggedId = ref.read(draggedAppointmentIdProvider);
        Duration duration;
        DateTime baseDate;
        if (draggedId != null) {
          final appt = ref
              .read(appointmentsProvider)
              .firstWhere((a) => a.id == draggedId);
          duration = appt.endTime.difference(appt.startTime);
          baseDate = DateTime(
            appt.startTime.year,
            appt.startTime.month,
            appt.startTime.day,
          );
        } else {
          final baseRange = ref.read(draggedBaseRangeProvider);
          if (baseRange != null) {
            final start = baseRange.$1;
            final end = baseRange.$2;
            duration = end.difference(start);
            baseDate = DateTime(start.year, start.month, start.day);
          } else {
            duration = const Duration(minutes: 30);
            final now = DateTime.now();
            baseDate = DateTime(now.year, now.month, now.day);
          }
        }

        final durationMinutes = duration.inMinutes;

        // üîí Limiti nell'arco della giornata
        const totalMinutes = LayoutConfig.hoursInDay * 60; // 1440
        final maxStartMinutesNum = (totalMinutes - durationMinutes).clamp(
          0,
          totalMinutes,
        );

        if (roundedMinutes > maxStartMinutesNum) {
          roundedMinutes = maxStartMinutesNum.toDouble();
        } else if (roundedMinutes < 0) {
          roundedMinutes = 0;
        }

        final startMinutes = roundedMinutes.toInt();
        final endMinutes = (startMinutes + durationMinutes)
            .clamp(0, totalMinutes)
            .toInt();

        final start = baseDate.add(Duration(minutes: startMinutes));
        var end = baseDate.add(Duration(minutes: endMinutes));

        final dayBoundary = baseDate.add(const Duration(days: 1));
        if (end.isAfter(dayBoundary)) end = dayBoundary;

        // aggiorna l'anteprima oraria mostrata nella card fantasma
        tempTimeNotifier.setTimes(start, end);
      } else if (_isHighlighted) {
        final headerHeight = ref.read(layoutConfigProvider).headerHeight;
        final globalY = next.dy;
        if (globalY > headerHeight - 5) return;

        setState(() {
          _isHighlighted = false;
          _hoverY = null;
        });
        _highlightedNotifier.clear();
        tempTimeNotifier.clear();
      }
    }, fireImmediately: false);
  }

  bool _geometryInitialized = false;
  Timer? _geometryDebounce;
  Rect? _lastGeometryRect;

  void _scheduleGeometryUpdate() {
    // Se gi√† inizializzato e debounce attivo, salta
    if (_geometryInitialized && _geometryDebounce != null) return;

    _geometryDebounce?.cancel();
    _geometryDebounce = Timer(const Duration(milliseconds: 220), () {
      if (!mounted) return;
      final box = context.findRenderObject() as RenderBox?;
      final bodyBox = ref.read(dragBodyBoxProvider);
      if (box == null || bodyBox == null) return;
      if (!box.attached || !bodyBox.attached) return;

      final topLeft = bodyBox.globalToLocal(box.localToGlobal(Offset.zero));
      final newRect = Rect.fromLTWH(
        topLeft.dx,
        topLeft.dy,
        box.size.width,
        box.size.height,
      );

      // ignora microvariazioni
      if (_lastGeometryRect != null &&
          (newRect.top - _lastGeometryRect!.top).abs() < 1.0 &&
          (newRect.left - _lastGeometryRect!.left).abs() < 1.0 &&
          (newRect.width - _lastGeometryRect!.width).abs() < 1.0 &&
          (newRect.height - _lastGeometryRect!.height).abs() < 1.0) {
        return;
      }

      _lastGeometryRect = newRect;
      _geometryInitialized = true; // ‚úÖ segna come inizializzato
      _geometryNotifier.setRect(widget.staff.id, newRect);
    });
  }

  @override
  void dispose() {
    _dragListener.close();
    _highlightSubscription.close();
    _layoutConfigSub.close(); // 5. Ricorda di chiudere la sottoscrizione
    final shouldClearHighlight = _latestHighlightedId == widget.staff.id;
    final staffId = widget.staff.id;
    Future.microtask(() {
      if (shouldClearHighlight) {
        _highlightedNotifier.clear();
      }
      _geometryNotifier.clearFor(staffId);
    });
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final allAppointments = ref.watch(appointmentsForCurrentLocationProvider);
    final staffAppointments = allAppointments
        .where((a) => a.staffId == widget.staff.id)
        .toList();

    // 6. RIMOSSO il blocco addPostFrameCallback da qui

    final layoutConfig = ref.watch(layoutConfigProvider);
    final slotHeight = layoutConfig.slotHeight;
    final totalSlots = layoutConfig.totalSlots;
    final appointmentsNotifier = ref.read(appointmentsProvider.notifier);
    final agendaDate = ref.watch(agendaDateProvider);

    // Interaction lock propagated from parent (evaluated once per visible group)
    final isInteractionLocked = widget.isInteractionLocked;

    // üîπ Calcola slot pieni PRIMA del layout (solo desktop e se abilitato)
    final formFactor = ref.watch(formFactorProvider);
    final bool showAddButtonStrip =
        layoutConfig.enableOccupiedSlotStrip &&
        formFactor == AppFormFactor.desktop &&
        !isInteractionLocked;
    final fullyOccupied = showAddButtonStrip
        ? ref.watch(fullyOccupiedSlotsProvider(widget.staff.id))
        : const <int>{};
    final hasFullyOccupiedSlots = fullyOccupied.isNotEmpty;

    // Larghezza disponibile per le card (ridotta se ci sono slot pieni)
    final addButtonWidth = hasFullyOccupiedSlots
        ? LayoutConfig.addButtonStripWidth
        : 0.0;
    final effectiveColumnWidth = widget.columnWidth - addButtonWidth;

    final stackChildren = <Widget>[];

    // üîπ Griglia oraria
    stackChildren.add(
      Column(
        children: List.generate(totalSlots, (index) {
          final slotsPerHour = 60 ~/ layoutConfig.minutesPerSlot;
          final isHourStart = (index + 1) % slotsPerHour == 0;
          return SizedBox(
            height: slotHeight,
            child: Align(
              alignment: Alignment.bottomLeft,
              child: AgendaHorizontalDivider(
                color: Colors.grey.withOpacity(isHourStart ? 0.5 : 0.2),
                thickness: isHourStart ? 1 : 0.5,
              ),
            ),
          );
        }),
      ),
    );

    // üîπ Layer slot non disponibili (texture pattern)
    final unavailableRanges = ref.watch(
      unavailableSlotRangesProvider(widget.staff.id),
    );
    if (unavailableRanges.isNotEmpty) {
      final colorScheme = Theme.of(context).colorScheme;
      final totalHeight = totalSlots * slotHeight;
      stackChildren.add(
        IgnorePointer(
          child: SizedBox(
            height: totalHeight,
            width: double.infinity,
            child: Stack(
              children: [
                for (final range in unavailableRanges)
                  Positioned(
                    top: range.startIndex * slotHeight,
                    left: 0,
                    right: 0,
                    child: UnavailableSlotRange(
                      slotCount: range.count,
                      slotHeight: slotHeight,
                      patternColor: AgendaTheme.unavailablePatternColor(
                        colorScheme,
                      ),
                      backgroundColor: AgendaTheme.unavailableBackgroundColor(
                        colorScheme,
                      ),
                    ),
                  ),
              ],
            ),
          ),
        ),
      );
    }

    // üîπ Layer interattivo HoverSlot (effetto all'hover del mouse)
    stackChildren.add(
      IgnorePointer(
        ignoring: false, // permette l'hover
        child: Column(
          children: List.generate(totalSlots, (index) {
            final slotTime = agendaDate.add(
              Duration(minutes: index * layoutConfig.minutesPerSlot),
            );
            if (!isInteractionLocked) {
              return LazyHoverSlot(
                slotTime: slotTime,
                height: slotHeight,
                colorPrimary1: Theme.of(context).colorScheme.primary,
                onTap: (dt) {
                  showBookingDialog(
                    context,
                    ref,
                    date: DateUtils.dateOnly(dt),
                    time: TimeOfDay(hour: dt.hour, minute: dt.minute),
                    initialStaffId: widget.staff.id,
                  );
                },
              );
            }

            // Mantieni lo spazio vuoto per evitare salti nel layout.
            return SizedBox(height: slotHeight, width: double.infinity);
          }),
        ),
      ),
    );

    // üîπ Appuntamenti (con larghezza ridotta se ci sono slot pieni)
    stackChildren.addAll(
      _buildAppointments(slotHeight, staffAppointments, effectiveColumnWidth),
    );

    // üîπ Blocchi di non disponibilit√†
    stackChildren.addAll(_buildTimeBlocks(slotHeight));

    // La fascia laterale √® gi√† riservata riducendo effectiveColumnWidth,
    // quindi le card si restringono automaticamente lasciando spazio a destra.

    return DragTarget<Appointment>(
      onWillAcceptWithDetails: (_) {
        setState(() => _isHighlighted = true);
        ref.read(highlightedStaffIdProvider.notifier).set(widget.staff.id);
        return true;
      },
      onLeave: (_) {
        setState(() => _isHighlighted = false);
        ref.read(highlightedStaffIdProvider.notifier).clear();
      },
      onAcceptWithDetails: (details) async {
        final previewTimes = ref.read(tempDragTimeProvider);
        setState(() {
          _isHighlighted = false;
          _hoverY = null;
        });
        ref.read(highlightedStaffIdProvider.notifier).clear();
        ref.read(tempDragTimeProvider.notifier).clear();

        final box = context.findRenderObject() as RenderBox?;
        if (box == null) return;

        final dragOffsetY = ref.read(dragOffsetProvider) ?? 0.0;
        final dragOffsetX = ref.read(dragOffsetXProvider) ?? 0.0;
        final pointerGlobal = details.offset + Offset(dragOffsetX, dragOffsetY);
        final localPointer = box.globalToLocal(pointerGlobal);
        final draggedCardHeightPx =
            ref.read(draggedCardSizeProvider)?.height ?? 50.0;

        final dropResult = computeDropResult(
          DropComputationParams(
            appointment: details.data,
            layoutConfig: layoutConfig,
            columnHeight: box.size.height,
            localPointer: localPointer,
            dragOffsetY: dragOffsetY,
            draggedCardHeightPx: draggedCardHeightPx,
            previewTimes: previewTimes,
          ),
        );

        ref.read(dragSessionProvider.notifier).markHandled();

        // Verifica se l'appuntamento √® stato effettivamente spostato
        final hasStaffChanged = details.data.staffId != widget.staff.id;
        final hasTimeChanged =
            details.data.startTime != dropResult.newStart ||
            details.data.endTime != dropResult.newEnd;

        // Se non c'√® stato alcun cambiamento, non mostrare il dialog
        if (!hasStaffChanged && !hasTimeChanged) {
          return;
        }

        // Salva i dati del drop pendente per mostrare la preview
        final pendingData = PendingDropData(
          appointmentId: details.data.id,
          originalStaffId: details.data.staffId,
          originalStart: details.data.startTime,
          originalEnd: details.data.endTime,
          newStaffId: widget.staff.id,
          newStart: dropResult.newStart,
          newEnd: dropResult.newEnd,
        );
        ref.read(pendingDropProvider.notifier).setPending(pendingData);

        // Mostra dialog di conferma prima di applicare lo spostamento
        if (!mounted) {
          ref.read(pendingDropProvider.notifier).clear();
          return;
        }
        final l10n = context.l10n;
        final newTimeStr = DtFmt.hm(
          context,
          dropResult.newStart.hour,
          dropResult.newStart.minute,
        );
        final staffName = widget.staff.displayName;

        final confirmed = await showConfirmDialog(
          context,
          title: Text(l10n.moveAppointmentConfirmTitle),
          content: Text(
            l10n.moveAppointmentConfirmMessage(newTimeStr, staffName),
          ),
          confirmLabel: l10n.actionConfirm,
          cancelLabel: l10n.actionCancel,
        );

        // Pulisci sempre lo stato pendente dopo la decisione
        ref.read(pendingDropProvider.notifier).clear();

        if (confirmed && mounted) {
          appointmentsNotifier.moveAppointment(
            appointmentId: details.data.id,
            newStaffId: widget.staff.id,
            newStart: dropResult.newStart,
            newEnd: dropResult.newEnd,
          );
        }
      },
      builder: (context, candidateData, rejectedData) {
        return GestureDetector(
          onTap: () {
            ref.read(selectedAppointmentProvider.notifier).clear();
          },
          child: SizedBox(
            width: widget.columnWidth,
            child: Container(
              decoration: BoxDecoration(
                color: _isHighlighted
                    ? widget.staff.color.withOpacity(0.01)
                    : Colors.transparent,
                border: widget.showRightBorder
                    ? Border(
                        right: BorderSide(
                          color: Colors.grey.withOpacity(0.5),
                          width: 1.0,
                        ),
                      )
                    : null,
              ),
              child: Stack(children: stackChildren),
            ),
          ),
        );
      },
    );
  }

  List<Widget> _buildAppointments(
    double slotHeight,
    List<Appointment> appointments,
    double columnWidth,
  ) {
    final draggedId = ref.watch(draggedAppointmentIdProvider);
    final layoutConfig = ref.watch(layoutConfigProvider);
    // üîπ Watch fuori dal loop per evitare rebuild multipli
    final pendingDrop = ref.watch(pendingDropProvider);
    final variants = layoutConfig.useServiceColorsForAppointments
        ? ref.watch(serviceVariantsProvider)
        : <dynamic>[];
    // Pre-calcola la mappa dei colori dei servizi (da varianti)
    final serviceColorMap = <int, Color>{};
    for (final variant in variants) {
      if (variant.colorHex != null) {
        serviceColorMap[variant.serviceId] =
            ColorUtils.fromHex(variant.colorHex!);
      }
    }

    final layoutAppointments = appointments.map((appt) {
      final resizingEntry = ref.watch(resizingEntryProvider(appt.id));
      if (resizingEntry != null &&
          resizingEntry.provisionalEndTime != appt.endTime) {
        return appt.copyWith(endTime: resizingEntry.provisionalEndTime);
      }
      return appt;
    }).toList();

    final List<List<Appointment>> overlapGroups = [];
    for (final appt in layoutAppointments) {
      bool added = false;
      for (final group in overlapGroups) {
        if (group.any(
          (g) =>
              appt.startTime.isBefore(g.endTime) &&
              appt.endTime.isAfter(g.startTime),
        )) {
          group.add(appt);
          added = true;
          break;
        }
      }
      if (!added) {
        overlapGroups.add([appt]);
      }
    }

    final positionedAppointments = <Widget>[];

    final originalAppointmentsMap = {for (var a in appointments) a.id: a};
    final layoutEntries = layoutAppointments
        .map((a) => LayoutEntry(id: a.id, start: a.startTime, end: a.endTime))
        .toList();
    final layoutGeometry = computeLayoutGeometry(
      layoutEntries,
      useClusterMaxConcurrency: layoutConfig.useClusterMaxConcurrency,
    );

    for (final group in overlapGroups) {
      final groupWidgets = <Widget>[];
      final groupSize = group.length;
      group.sort((a, b) => a.startTime.compareTo(b.startTime));

      for (int i = 0; i < groupSize; i++) {
        final layoutAppt = group[i];
        final originalAppt = originalAppointmentsMap[layoutAppt.id]!;

        final isDragged = originalAppt.id == draggedId;

        final dayStart = DateTime(
          originalAppt.startTime.year,
          originalAppt.startTime.month,
          originalAppt.startTime.day,
        );

        final startMinutes = originalAppt.startTime
            .difference(dayStart)
            .inMinutes;

        final endMinutes = layoutAppt.endTime.difference(dayStart).inMinutes;

        final double top =
            (startMinutes / layoutConfig.minutesPerSlot) * slotHeight;
        double height =
            ((endMinutes - startMinutes) / layoutConfig.minutesPerSlot) *
            slotHeight;

        final entry = ref.watch(resizingEntryProvider(originalAppt.id));
        if (entry != null) {
          height = entry.currentPreviewHeightPx;
        }

        final geometry =
            layoutGeometry[originalAppt.id] ??
            const EventGeometry(leftFraction: 0, widthFraction: 1);

        // Controlla se questo appuntamento ha un drop pendente (usa variabile pre-calcolata)
        final hasPendingDrop = pendingDrop?.appointmentId == originalAppt.id;
        final isOriginalPosition =
            hasPendingDrop && pendingDrop!.originalStaffId == widget.staff.id;

        double opacity = isDragged ? AgendaTheme.ghostOpacity : 1.0;
        // Se √® la posizione originale durante un drop pendente, mostra semi-trasparente
        if (isOriginalPosition) {
          opacity = AgendaTheme.ghostOpacity;
        }

        // üîπ Costruisci la card (usa columnWidth passato, che √® gi√† ridotto se ci sono slot pieni)
        final padding = LayoutConfig.columnInnerPadding;
        final fullColumnWidth = math.max(columnWidth - padding * 2, 0.0);
        final cardLeft = columnWidth * geometry.leftFraction + padding;
        final cardWidth = math.max(
          columnWidth * geometry.widthFraction - padding * 2,
          0.0,
        );

        Color cardColor = widget.staff.color;
        if (layoutConfig.useServiceColorsForAppointments) {
          // Priorit√†: colore del servizio (configurabile dall'operatore).
          final serviceColor = serviceColorMap[originalAppt.serviceId];
          if (serviceColor != null) {
            cardColor = serviceColor;
          } else {
            final variant = ref.watch(
              serviceVariantByIdProvider(originalAppt.serviceVariantId),
            );
            if (variant != null && variant.colorHex != null) {
              cardColor = ColorUtils.fromHex(variant.colorHex!);
            }
          }
        }

        groupWidgets.add(
          Positioned(
            key: ValueKey(originalAppt.id),
            top: top,
            left: cardLeft,
            width: cardWidth,
            height: height,
            child: Opacity(
              opacity: opacity,
              child: AppointmentCard(
                appointment: originalAppt,
                color: cardColor,
                columnWidth: cardWidth,
                columnOffset: cardLeft,
                dragTargetWidth: fullColumnWidth,
                expandToLeft: i > 0,
              ),
            ),
          ),
        );
      }

      // Posizioniamo i widget del gruppo in ordine inverso, cos√¨ gli
      // appuntamenti che iniziano prima rimangono sopra e non vengono
      // parzialmente coperti da quelli iniziati dopo.
      positionedAppointments.addAll(groupWidgets.reversed);
    }

    // üîπ Aggiungi preview per drop pendente se questa √® la colonna di destinazione
    // (usa la variabile pendingDrop gi√† calcolata all'inizio del metodo)
    if (pendingDrop != null && pendingDrop.newStaffId == widget.staff.id) {
      // Trova l'appuntamento originale nel provider globale
      final allAppointments = ref.watch(appointmentsProvider);
      final originalAppt = allAppointments.cast<Appointment?>().firstWhere(
        (a) => a?.id == pendingDrop.appointmentId,
        orElse: () => null,
      );

      if (originalAppt != null) {
        final dayStart = DateTime(
          pendingDrop.newStart.year,
          pendingDrop.newStart.month,
          pendingDrop.newStart.day,
        );

        final startMinutes = pendingDrop.newStart
            .difference(dayStart)
            .inMinutes;
        final endMinutes = pendingDrop.newEnd.difference(dayStart).inMinutes;

        final double top =
            (startMinutes / layoutConfig.minutesPerSlot) * slotHeight;
        final double height =
            ((endMinutes - startMinutes) / layoutConfig.minutesPerSlot) *
            slotHeight;

        final padding = LayoutConfig.columnInnerPadding;
        final cardWidth = math.max(widget.columnWidth - padding * 2, 0.0);

        Color cardColor = widget.staff.color;
        if (layoutConfig.useServiceColorsForAppointments) {
          // Priorit√†: colore del servizio (configurabile dall'operatore).
          final serviceColor = serviceColorMap[originalAppt.serviceId];
          if (serviceColor != null) {
            cardColor = serviceColor;
          } else {
            final variant = ref.watch(
              serviceVariantByIdProvider(originalAppt.serviceVariantId),
            );
            if (variant != null && variant.colorHex != null) {
              cardColor = ColorUtils.fromHex(variant.colorHex!);
            }
          }
        }

        // Preview card con bordo tratteggiato per indicare la posizione proposta
        positionedAppointments.add(
          Positioned(
            key: const ValueKey('pending_drop_preview'),
            top: top,
            left: padding,
            width: cardWidth,
            height: height,
            child: IgnorePointer(
              child: Container(
                decoration: BoxDecoration(
                  color: cardColor.withOpacity(0.3),
                  borderRadius: BorderRadius.circular(
                    LayoutConfig.borderRadius,
                  ),
                  border: Border.all(
                    color: cardColor,
                    width: 2,
                    strokeAlign: BorderSide.strokeAlignInside,
                  ),
                ),
                child: Center(
                  child: Icon(Icons.arrow_downward, color: cardColor, size: 24),
                ),
              ),
            ),
          ),
        );
      }
    }

    return positionedAppointments;
  }

  /// Costruisce i widget per i blocchi di non disponibilit√† dello staff.
  List<Widget> _buildTimeBlocks(double slotHeight) {
    final blocks = ref.watch(timeBlocksForStaffProvider(widget.staff.id));
    if (blocks.isEmpty) return [];

    final layoutConfig = ref.watch(layoutConfigProvider);
    final agendaDate = ref.watch(agendaDateProvider);
    final dayStart = DateTime(
      agendaDate.year,
      agendaDate.month,
      agendaDate.day,
    );

    final positionedBlocks = <Widget>[];
    final padding = LayoutConfig.columnInnerPadding;
    final cardWidth = math.max(widget.columnWidth - padding * 2, 0.0);

    for (final block in blocks) {
      // Calcola posizione verticale
      final startMinutes = block.startTime.difference(dayStart).inMinutes;
      final endMinutes = block.endTime.difference(dayStart).inMinutes;

      // Clamp ai limiti della giornata visualizzata
      final clampedStartMinutes = startMinutes.clamp(
        0,
        LayoutConfig.hoursInDay * 60,
      );
      final clampedEndMinutes = endMinutes.clamp(
        0,
        LayoutConfig.hoursInDay * 60,
      );

      if (clampedEndMinutes <= clampedStartMinutes) continue;

      final double top =
          (clampedStartMinutes / layoutConfig.minutesPerSlot) * slotHeight;
      final double height =
          ((clampedEndMinutes - clampedStartMinutes) /
              layoutConfig.minutesPerSlot) *
          slotHeight;

      positionedBlocks.add(
        Positioned(
          key: ValueKey('block_${block.id}'),
          top: top,
          left: padding,
          width: cardWidth,
          height: height,
          child: TimeBlockWidget(
            block: block,
            height: height,
            width: cardWidth,
          ),
        ),
      );
    }

    return positionedBlocks;
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/components/hour_column.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../domain/config/agenda_theme.dart';
import '../../../../providers/layout_config_provider.dart';
import '../../widgets/agenda_dividers.dart';

class HourColumn extends ConsumerWidget {
  const HourColumn({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final layoutConfig = ref.watch(layoutConfigProvider);
    final slotHeight = layoutConfig.slotHeight;
    final totalSlots = layoutConfig.totalSlots;
    final slotsPerHour = (60 ~/ layoutConfig.minutesPerSlot);

    return Column(
      children: List.generate(totalSlots, (index) {
        final isHourStart = index % slotsPerHour == 0;
        final isMainLine = (index + 1) % slotsPerHour == 0;
        final hour = (index ~/ slotsPerHour);
        final minutes = (index % slotsPerHour) * layoutConfig.minutesPerSlot;

        return SizedBox(
          height: slotHeight,
          child: Stack(
            children: [
              if (isHourStart)
                Align(
                  alignment: Alignment.center,
                  child: Text(
                    "${hour.toString().padLeft(2, '0')}:${minutes.toString().padLeft(2, '0')}",
                    textAlign: TextAlign.center,
                    style: AgendaTheme.hourTextStyle,
                  ),
                ),
              Align(
                alignment: Alignment.bottomLeft,
                child: AgendaHorizontalDivider(
                  color: Colors.grey.withOpacity(isMainLine ? 0.5 : 0.2),
                  thickness: isMainLine ? 1 : 0.5,
                ),
              ),
            ],
          ),
        );
      }),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/components/agenda_staff_header.dart ---
import 'package:flutter/material.dart';

import '../../../../../../core/models/staff.dart';
import '../../../../../../core/widgets/no_scrollbar_behavior.dart';
import 'staff_header_row.dart';

class AgendaStaffHeader extends StatelessWidget {
  const AgendaStaffHeader({
    super.key,
    required this.staffList,
    required this.hourColumnWidth,
    required this.totalHeight,
    required this.headerHeight,
    required this.columnWidth,
    required this.scrollController,
  });

  final List<Staff> staffList;
  final double hourColumnWidth;
  final double totalHeight;
  final double headerHeight;
  final double columnWidth;
  final ScrollController scrollController;

  @override
  Widget build(BuildContext context) {
    return Material(
      elevation: 8,
      shadowColor: Colors.black.withOpacity(0.3),
      surfaceTintColor: Colors.transparent,
      child: DecoratedBox(
        decoration: const BoxDecoration(
          border: Border(
            bottom: BorderSide(color: Color(0x1F000000), width: 0.5),
          ),
        ),
        child: ScrollConfiguration(
          behavior: const NoScrollbarBehavior(),
          child: SingleChildScrollView(
            controller: scrollController,
            scrollDirection: Axis.horizontal,
            physics: const ClampingScrollPhysics(),
            child: StaffHeaderRow(
              staffList: staffList,
              scrollController: scrollController,
              columnWidth: columnWidth,
              hourColumnWidth: hourColumnWidth,
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/components/staff_header_row.dart ---
import 'dart:math' as math;

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../../app/widgets/staff_circle_avatar.dart';
import '../../../../../../core/l10n/l10_extension.dart';
import '../../../../../../core/models/staff.dart';
import '../../../../../../core/widgets/app_dialogs.dart';
import '../../../../domain/config/layout_config.dart';
import '../../../../providers/highlighted_staff_provider.dart';
import '../../../../providers/layout_config_provider.dart';
import '../../../../../staff/presentation/dialogs/staff_dialog.dart';

class StaffHeaderRow extends ConsumerWidget {
  final List<Staff> staffList;
  final ScrollController
  scrollController; // non usato per scrollare qui, ma utile per offset/read
  final double columnWidth;
  final double hourColumnWidth; // NON usato per lasciare spazio iniziale

  const StaffHeaderRow({
    super.key,
    required this.staffList,
    required this.scrollController,
    required this.columnWidth,
    required this.hourColumnWidth,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final headerHeight = ref.watch(layoutConfigProvider).headerHeight;
    final avatarDefault = LayoutConfig.avatarSizeFor(context);
    // Ensure avatar is not larger than available header space to avoid overflow
    final avatarSize = math.min(avatarDefault, headerHeight * 0.55);
    final highlightedId = ref.watch(highlightedStaffIdProvider);

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        ...staffList.asMap().entries.map((entry) {
          final index = entry.key;
          final staff = entry.value;
          final isLast = index == staffList.length - 1;
          final isHighlighted = highlightedId == staff.id;

          final initials = staff.initials;
          final displayName = staff.displayName;

          return Stack(
            children: [
              Container(
                width: columnWidth,
                height: headerHeight,
                padding: EdgeInsets.symmetric(horizontal: headerHeight * 0.08),
                child: Center(
                  child: _StaffHeaderCell(
                    initials: initials,
                    displayName: displayName,
                    avatarSize: avatarSize,
                    isHighlighted: isHighlighted,
                    isBookableOnline: staff.isBookableOnline,
                    color: staff.color,
                    onEdit: () => showStaffDialog(
                      context,
                      ref,
                      initial: staff,
                    ),
                  ),
                ),
              ),
              if (!isLast)
                Positioned(
                  right: 0,
                  top: 0,
                  bottom: 0,
                  child: Container(
                    width: 1,
                    decoration: BoxDecoration(
                      gradient: LinearGradient(
                        begin: Alignment.topCenter,
                        end: Alignment.bottomCenter,
                        colors: [
                          Colors.grey.withOpacity(0.0),
                          Colors.grey.withOpacity(0.25),
                        ],
                        stops: const [0.0, 0.7],
                      ),
                    ),
                  ),
                ),
            ],
          );
        }),
      ],
    );
  }
}

class _StaffHeaderCell extends StatefulWidget {
  const _StaffHeaderCell({
    required this.initials,
    required this.displayName,
    required this.avatarSize,
    required this.isHighlighted,
    required this.isBookableOnline,
    required this.color,
    required this.onEdit,
  });

  final String initials;
  final String displayName;
  final double avatarSize;
  final bool isHighlighted;
  final bool isBookableOnline;
  final Color color;
  final VoidCallback onEdit;

  @override
  State<_StaffHeaderCell> createState() => _StaffHeaderCellState();
}

class _StaffHeaderCellState extends State<_StaffHeaderCell> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    return MouseRegion(
      cursor: SystemMouseCursors.click,
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 4),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(12),
        ),
        child: Material(
          color: Colors.transparent,
          child: InkWell(
            onTap: widget.onEdit,
            splashColor: Colors.transparent,
            hoverColor: Colors.transparent,
            highlightColor: Colors.transparent,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Stack(
                  clipBehavior: Clip.none,
                  children: [
                    StaffCircleAvatar(
                      height: widget.avatarSize,
                      color: widget.color,
                      isHighlighted: widget.isHighlighted || _isHovered,
                      initials: widget.initials,
                    ),
                    if (!widget.isBookableOnline)
                      Positioned.fill(
                        child: Align(
                          alignment: const Alignment(0.78, 0.78),
                          child: Transform.translate(
                            offset: Offset(
                              widget.avatarSize * 0.02,
                              widget.avatarSize * 0.02,
                            ),
                            child: Tooltip(
                              message:
                                  context.l10n.staffNotBookableOnlineTooltip,
                              child: GestureDetector(
                                onTap: () {
                                  showAppInfoDialog(
                                    context,
                                    title: Text(
                                      context.l10n
                                          .staffNotBookableOnlineTitle,
                                    ),
                                    content: Text(
                                      context.l10n
                                          .staffNotBookableOnlineMessage,
                                    ),
                                    closeLabel: context.l10n.actionClose,
                                  );
                                },
                                child: Container(
                                  padding: const EdgeInsets.all(2),
                                  decoration: BoxDecoration(
                                    color:
                                        Theme.of(context).colorScheme.surface,
                                    shape: BoxShape.circle,
                                  ),
                                  child: Icon(
                                    Icons.cloud_off_outlined,
                                    size: 14,
                                    color:
                                        Theme.of(context).colorScheme.primary,
                                  ),
                                ),
                              ),
                            ),
                          ),
                        ),
                      ),
                  ],
                ),
                const SizedBox(height: 4),
                Text(
                  widget.displayName,
                  maxLines: 1,
                  textAlign: TextAlign.center,
                  overflow: TextOverflow.ellipsis,
                  style: const TextStyle(
                    fontWeight: FontWeight.w600,
                    fontSize: 11,
                    color: Colors.black87,
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/agenda_staff_body.dart ---
import 'package:flutter/material.dart';

import '../../../../../core/models/appointment.dart';
import '../../../../../core/models/staff.dart';
import '../../../../../core/widgets/no_scrollbar_behavior.dart';
import '../../../domain/config/layout_config.dart';
import '../helper/responsive_layout.dart';
import 'staff_column.dart';

class AgendaStaffBody extends StatelessWidget {
  const AgendaStaffBody({
    super.key,
    required this.verticalController,
    required this.horizontalController,
    required this.staffList,
    required this.appointments,
    required this.layoutConfig,
    required this.availableWidth,
    required this.isResizing,
    required this.dragLayerLink,
    required this.bodyKey,
    required this.isInteractionLocked,
  });

  final ScrollController verticalController;
  final ScrollController horizontalController;
  final List<Staff> staffList;
  final List<Appointment> appointments;
  final LayoutConfig layoutConfig;
  final double availableWidth;
  final bool isResizing;
  final LayerLink? dragLayerLink;
  final GlobalKey bodyKey;
  final bool isInteractionLocked;

  @override
  Widget build(BuildContext context) {
    final layout = ResponsiveLayout.of(
      context,
      staffCount: staffList.length,
      config: layoutConfig,
      availableWidth: availableWidth,
    );

    final totalContentWidth = layout.columnWidth * staffList.length;

    // final hourColumnWidth = layoutConfig.hourColumnWidth;

    Widget content = ScrollConfiguration(
      // mantiene l'assenza di scrollbar come prima
      behavior: const NoScrollbarBehavior(),
      child: SingleChildScrollView(
        controller: verticalController,
        physics: isResizing
            ? const NeverScrollableScrollPhysics()
            : const ClampingScrollPhysics(),
        child: Stack(
          children: [
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(
                  child: SingleChildScrollView(
                    controller: horizontalController,
                    scrollDirection: Axis.horizontal,
                    physics: const ClampingScrollPhysics(),
                    clipBehavior: Clip.hardEdge,
                    child: SizedBox(
                      width: totalContentWidth,
                      child: Stack(
                        children: [
                          // üîπ Colonne staff (come prima)
                          Row(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: staffList.asMap().entries.map((entry) {
                              final index = entry.key;
                              final staff = entry.value;
                              final isLast = index == staffList.length - 1;
                              final staffAppointments = appointments
                                  .where(
                                    (appointment) =>
                                        appointment.staffId == staff.id,
                                  )
                                  .toList();

                              return StaffColumn(
                                staff: staff,
                                appointments: staffAppointments,
                                columnWidth: layout.columnWidth,
                                isInteractionLocked: isInteractionLocked,
                                // Questo flag ora √® ignorato all'interno di StaffColumn,
                                // ma lo manteniamo per compatibilit√†.
                                showRightBorder:
                                    staffList.length > 1 && !isLast,
                              );
                            }).toList(),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
            //CurrentTimeLine(hourColumnWidth: hourColumnWidth),
          ],
        ),
      ),
    );

    if (dragLayerLink != null) {
      content = CompositedTransformTarget(
        key: bodyKey,
        link: dragLayerLink!,
        child: content,
      );
    } else {
      content = KeyedSubtree(key: bodyKey, child: content);
    }

    return content;
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/agenda_day.dart ---
import 'package:agenda_backend/features/agenda/presentation/screens/day_view/multi_staff_day_view.dart';
import 'package:agenda_backend/features/agenda/providers/date_range_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../core/models/staff.dart';
import '../../../domain/config/layout_config.dart';
import '../../../providers/layout_config_provider.dart';

class AgendaDayController {
  _AgendaDayState? _state;
  double? _pendingOffset;

  void _attach(_AgendaDayState state) {
    _state = state;
    if (_pendingOffset != null) {
      state._jumpToExternalOffset(_pendingOffset!);
      _pendingOffset = null;
    }
  }

  void _detach(_AgendaDayState state) {
    if (_state == state) _state = null;
  }

  void jumpTo(double offset) {
    final state = _state;
    if (state == null) {
      _pendingOffset = offset;
      return;
    }
    state._jumpToExternalOffset(offset);
  }

  void dispose() {
    _state = null;
    _pendingOffset = null;
  }
}

class AgendaDay extends ConsumerStatefulWidget {
  const AgendaDay({
    super.key,
    required this.staffList,
    this.onVerticalOffsetChanged,
    this.controller,
    required this.hourColumnWidth,
    required this.currentTimeVerticalOffset,
  });

  final List<Staff> staffList;
  final ValueChanged<double>? onVerticalOffsetChanged;
  final AgendaDayController? controller;
  final double hourColumnWidth;
  final double currentTimeVerticalOffset;

  @override
  ConsumerState<AgendaDay> createState() => _AgendaDayState();
}

class _AgendaDayState extends ConsumerState<AgendaDay> {
  ScrollController? _centerVerticalController;
  double _currentScrollOffset = 0;

  DateTime? _previousDate;
  bool _slideFromRight = true;

  @override
  void initState() {
    super.initState();
    widget.controller?._attach(this);

    final layoutConfig = ref.read(layoutConfigProvider);
    _currentScrollOffset = _timelineOffsetForToday(layoutConfig);
  }

  @override
  void dispose() {
    widget.controller?._detach(this);
    super.dispose();
  }

  void _handleCenterVerticalController(ScrollController controller) {
    if (_centerVerticalController == controller) return;
    _centerVerticalController = controller;

    final layoutConfig = ref.read(layoutConfigProvider);
    final initialOffset = _timelineOffsetForToday(layoutConfig);

    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted || !controller.hasClients) return;

      // Centra la timeline al centro della viewport visibile
      final viewportHeight = controller.position.viewportDimension;
      final target = (initialOffset - viewportHeight / 2)
          .clamp(
            controller.position.minScrollExtent,
            controller.position.maxScrollExtent,
          )
          .toDouble();
      controller.jumpTo(target);
      _currentScrollOffset = target;
      widget.onVerticalOffsetChanged?.call(target);
    });
  }

  void _jumpToExternalOffset(double offset) {
    final controller = _centerVerticalController;
    if (controller == null || !controller.hasClients) {
      _currentScrollOffset = offset;
      return;
    }

    final clamped = offset.clamp(
      controller.position.minScrollExtent,
      controller.position.maxScrollExtent,
    );

    if ((controller.offset - clamped).abs() < 0.5) {
      _currentScrollOffset = clamped;
      return;
    }

    controller.jumpTo(clamped);
    _currentScrollOffset = clamped;
    widget.onVerticalOffsetChanged?.call(clamped);
  }

  @override
  Widget build(BuildContext context) {
    final date = ref.watch(agendaDateProvider);

    // calcola direzione
    if (_previousDate != null && _previousDate != date) {
      _slideFromRight = date.isBefore(_previousDate!);
    }
    _previousDate = date;

    // üëá AnimatedSwitcher forza animazione visibile anche se Flutter riusa il widget
    return AnimatedSwitcher(
      duration: const Duration(milliseconds: 400),
      reverseDuration: const Duration(milliseconds: 250),
      layoutBuilder: (currentChild, previousChildren) {
        return Stack(
          clipBehavior: Clip.none,
          children: [
            ...previousChildren,
            if (currentChild != null) currentChild,
          ],
        );
      },
      transitionBuilder: (Widget child, Animation<double> animation) {
        final offsetTween = Tween<Offset>(
          begin: _slideFromRight
              ? const Offset(1.0, 0.0)
              : const Offset(-1.0, 0.0),
          end: Offset.zero,
        ).chain(CurveTween(curve: Curves.easeOutCubic));

        // üëá Fade + Slide combinati per rendere visibile la transizione
        return SlideTransition(
          position: animation.drive(offsetTween),
          child: FadeTransition(
            opacity: animation.drive(CurveTween(curve: Curves.easeInOut)),
            child: child,
          ),
        );
      },
      // üëá chiave unica e realmente diversa a ogni data
      child: _AnimatedDayContainer(
        key: ValueKey('day-${date.toIso8601String()}'),
        staffList: widget.staffList,
        currentScrollOffset: _currentScrollOffset,
        onVerticalOffsetChanged: widget.onVerticalOffsetChanged,
        onVerticalControllerChanged: _handleCenterVerticalController,
        hourColumnWidth: widget.hourColumnWidth,
        currentTimeVerticalOffset: widget.currentTimeVerticalOffset,
      ),
    );
  }

  double _timelineOffsetForToday(LayoutConfig layoutConfig) {
    final now = DateTime.now();
    final minutes = now.hour * 60 + now.minute;
    return (minutes / layoutConfig.minutesPerSlot) * layoutConfig.slotHeight;
  }
}

class _AnimatedDayContainer extends StatelessWidget {
  const _AnimatedDayContainer({
    super.key,
    required this.staffList,
    required this.currentScrollOffset,
    this.onVerticalOffsetChanged,
    required this.onVerticalControllerChanged,
    required this.hourColumnWidth,
    required this.currentTimeVerticalOffset,
  });

  final List<Staff> staffList;
  final double currentScrollOffset;
  final ValueChanged<double>? onVerticalOffsetChanged;
  final ValueChanged<ScrollController> onVerticalControllerChanged;
  final double hourColumnWidth;
  final double currentTimeVerticalOffset;

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        return MultiStaffDayView(
          staffList: staffList,
          initialScrollOffset: currentScrollOffset,
          onScrollOffsetChanged: (offset) {
            onVerticalOffsetChanged?.call(offset);
          },
          onVerticalControllerChanged: onVerticalControllerChanged,
          hourColumnWidth: hourColumnWidth,
          currentTimeVerticalOffset: currentTimeVerticalOffset,
        );
      },
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/multi_staff_day_view.dart ---
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../core/models/staff.dart';
import '../../../domain/config/layout_config.dart';
import '../../../providers/agenda_interaction_lock_provider.dart';
import '../../../providers/agenda_providers.dart';
import '../../../providers/agenda_scroll_provider.dart';
import '../../../providers/agenda_scroll_request_provider.dart';
import '../../../providers/appointment_providers.dart';
import '../../../providers/date_range_provider.dart';
import '../../../providers/drag_layer_link_provider.dart';
import '../../../providers/is_resizing_provider.dart';
import '../../../providers/layout_config_provider.dart';
import '../helper/responsive_layout.dart';
import '../widgets/current_time_line.dart';
import 'agenda_staff_body.dart';
import 'components/agenda_staff_header.dart';

class MultiStaffDayView extends ConsumerStatefulWidget {
  final List<Staff> staffList;
  final double initialScrollOffset;
  final ValueChanged<double>? onScrollOffsetChanged;
  final ValueChanged<ScrollController>? onVerticalControllerChanged;
  final double hourColumnWidth;
  final double currentTimeVerticalOffset;

  const MultiStaffDayView({
    super.key,
    required this.staffList,
    required this.initialScrollOffset,
    this.onScrollOffsetChanged,
    this.onVerticalControllerChanged,
    required this.hourColumnWidth,
    required this.currentTimeVerticalOffset,
  });

  @override
  ConsumerState<MultiStaffDayView> createState() => _MultiStaffDayViewState();
}

class _MultiStaffDayViewState extends ConsumerState<MultiStaffDayView> {
  // Auto scroll durante il drag
  Timer? _autoScrollTimer;
  static const double _scrollEdgeMargin = 100;
  static const double _scrollSpeed = 20;
  static const Duration _scrollInterval = Duration(milliseconds: 50);
  static const double _autoScrollActivationThreshold = 16;

  late final ProviderSubscription<Offset?> _dragSub;
  late final ProviderSubscription<LayoutConfig> _layoutSub;
  late final ProviderSubscription<AgendaScrollRequest?> _scrollRequestSub;

  final ScrollController _headerHCtrl = ScrollController();
  bool _isSyncing = false;
  Offset? _initialDragPosition;
  bool _autoScrollArmed = false;

  ScrollController? _bodyHorizontalCtrl;
  ScrollController? _verticalCtrl;
  List<int>? _staffSignature;

  late final DragBodyBoxNotifier _dragBodyNotifier;
  AgendaScrollRequest? _pendingScrollRequest;
  Timer? _scrollRetryTimer;

  Timer? _syncDebounce;

  final GlobalKey _bodyKey = GlobalKey();
  final GlobalKey _headerKey = GlobalKey();

  late final Object _scrollIdentity = Object();
  AgendaScrollKey get _scrollKey => AgendaScrollKey(
    identity: _scrollIdentity,
    staff: widget.staffList,
    date: DateTime.now(),
    initialOffset: widget.initialScrollOffset,
  );

  @override
  void initState() {
    super.initState();
    _dragBodyNotifier = ref.read(dragBodyBoxProvider.notifier);

    // Listener drag ‚Üí auto scroll verticale
    _dragSub = ref.listenManual<Offset?>(dragPositionProvider, (prev, next) {
      if (next != null) {
        if (prev == null) {
          _initialDragPosition = next;
          _autoScrollArmed = false;
        }
        _startAutoScroll();
      } else {
        _initialDragPosition = null;
        _autoScrollArmed = false;
        _stopAutoScroll();
      }
    });

    // Listener layoutConfig ‚Üí solo quando cambiano dimensioni rilevanti
    _layoutSub = ref.listenManual<LayoutConfig>(layoutConfigProvider, (
      prev,
      next,
    ) {
      if (prev == null ||
          prev.headerHeight != next.headerHeight ||
          prev.slotHeight != next.slotHeight ||
          prev.hourColumnWidth != next.hourColumnWidth) {
        _scheduleSyncUpdate();
      }
    });

    _scrollRequestSub = ref.listenManual<AgendaScrollRequest?>(
      agendaScrollRequestProvider,
      (prev, next) {
        if (next == null) return;
        final selectedDate = ref.read(agendaDateProvider);
        if (!DateUtils.isSameDay(selectedDate, next.date)) return;
        _pendingScrollRequest = next;
        _scheduleScrollToPending();
      },
    );

    // Prima inizializzazione
    _scheduleSyncUpdate();
  }

  void _scheduleSyncUpdate() {
    _syncDebounce?.cancel();
    _syncDebounce = Timer(const Duration(milliseconds: 180), () {
      if (!mounted) return;
      _registerBodyBox();
      _setupHorizontalSync(force: true);
    });
  }

  void _scheduleScrollToPending() {
    _scrollRetryTimer?.cancel();
    _scrollRetryTimer = Timer(const Duration(milliseconds: 60), () {
      if (!mounted) return;
      _tryScrollToPending();
    });
  }

  void _tryScrollToPending() {
    final request = _pendingScrollRequest;
    if (request == null) return;

    final selectedDate = ref.read(agendaDateProvider);
    if (!DateUtils.isSameDay(selectedDate, request.date)) return;

    final appointments = ref.read(appointmentsForCurrentLocationProvider);
    final target = appointments
        .where((a) => a.id == request.appointment.id)
        .cast()
        .toList();
    if (target.isEmpty) {
      _scheduleScrollToPending();
      return;
    }

    final appointment = target.first;
    final scrollState = ref.read(agendaScrollProvider(_scrollKey));
    final verticalCtrl = scrollState.verticalScrollCtrl;
    final horizontalCtrl = scrollState.horizontalScrollCtrl;
    if (!verticalCtrl.hasClients || !horizontalCtrl.hasClients) {
      _scheduleScrollToPending();
      return;
    }

    final layoutConfig = ref.read(layoutConfigProvider);
    final bodyBox = _bodyKey.currentContext?.findRenderObject() as RenderBox?;
    final viewportHeight =
        bodyBox?.size.height ?? verticalCtrl.position.viewportDimension;
    final viewportWidth =
        bodyBox?.size.width ?? horizontalCtrl.position.viewportDimension;

    final startMinutes =
        appointment.startTime.hour * 60 + appointment.startTime.minute;
    final startOffset =
        (startMinutes / layoutConfig.minutesPerSlot) * layoutConfig.slotHeight;
    final durationMinutes = appointment.endTime
        .difference(appointment.startTime)
        .inMinutes
        .clamp(layoutConfig.minutesPerSlot, 1440);
    final cardHeight =
        (durationMinutes / layoutConfig.minutesPerSlot) * layoutConfig.slotHeight;

    final targetY =
        startOffset - (viewportHeight - cardHeight).clamp(0, viewportHeight) / 2;
    final maxY = verticalCtrl.position.maxScrollExtent;
    final clampedY = targetY.clamp(0.0, maxY);

    final staffIndex = widget.staffList.indexWhere(
      (s) => s.id == appointment.staffId,
    );
    if (staffIndex >= 0) {
      final layout = ResponsiveLayout.of(
        context,
        staffCount: widget.staffList.length,
        config: layoutConfig,
        availableWidth: viewportWidth,
      );
      final columnWidth = layout.columnWidth;
      final targetX =
          (staffIndex * columnWidth) - (viewportWidth - columnWidth) / 2;
      final maxX = horizontalCtrl.position.maxScrollExtent;
      final clampedX = targetX.clamp(0.0, maxX);
      if ((horizontalCtrl.offset - clampedX).abs() > 0.5) {
        horizontalCtrl.jumpTo(clampedX);
      }
    }

    if ((verticalCtrl.offset - clampedY).abs() > 0.5) {
      verticalCtrl.jumpTo(clampedY);
    }

    _pendingScrollRequest = null;
    ref.read(agendaScrollRequestProvider.notifier).clear();
  }

  void _registerBodyBox() {
    final box = _bodyKey.currentContext?.findRenderObject() as RenderBox?;
    if (box != null) {
      _dragBodyNotifier.set(box);
    }
  }

  void _clearBodyBox() {
    _dragBodyNotifier.scheduleClear();
  }

  void _setupHorizontalSync({bool force = false}) {
    final newSignature = widget.staffList.map((s) => s.id).toList();
    if (!force &&
        _staffSignature != null &&
        listEquals(_staffSignature, newSignature)) {
      return;
    }
    _staffSignature = newSignature;

    final bodyCtrl = ref
        .read(agendaScrollProvider(_scrollKey))
        .horizontalScrollCtrl;

    if (!force && identical(_bodyHorizontalCtrl, bodyCtrl)) {
      return;
    }

    _bodyHorizontalCtrl?.removeListener(_onBodyHorizontalScroll);
    _headerHCtrl.removeListener(_onHeaderHorizontalScroll);

    _bodyHorizontalCtrl = bodyCtrl;
    _bodyHorizontalCtrl?.addListener(_onBodyHorizontalScroll);
    _headerHCtrl.addListener(_onHeaderHorizontalScroll);

    if (_headerHCtrl.hasClients && _bodyHorizontalCtrl!.hasClients) {
      _headerHCtrl.jumpTo(_bodyHorizontalCtrl!.offset);
    }
  }

  void _onBodyHorizontalScroll() {
    final bodyCtrl = _bodyHorizontalCtrl;
    if (_isSyncing || bodyCtrl == null) return;
    if (!bodyCtrl.hasClients || !_headerHCtrl.hasClients) return;

    _isSyncing = true;
    _headerHCtrl.jumpTo(bodyCtrl.offset);
    _isSyncing = false;
  }

  void _onHeaderHorizontalScroll() {
    final bodyCtrl = _bodyHorizontalCtrl;
    if (_isSyncing || bodyCtrl == null) return;
    if (!bodyCtrl.hasClients || !_headerHCtrl.hasClients) return;

    _isSyncing = true;
    bodyCtrl.jumpTo(_headerHCtrl.offset);
    _isSyncing = false;
  }

  void _onVerticalScrollChanged() {
    final controller = _verticalCtrl;
    if (controller == null) return;
    widget.onScrollOffsetChanged?.call(controller.offset);
  }

  void _startAutoScroll() {
    if (_autoScrollTimer != null) return;
    _autoScrollTimer = Timer.periodic(_scrollInterval, (_) {
      if (!mounted) return;

      // dragPos √® in coordinate BODY-LOCAL (DragBodyBox)
      final dragPos = ref.read(dragPositionProvider);
      if (dragPos == null) {
        _stopAutoScroll();
        return;
      }

      final bodyBox = ref.read(dragBodyBoxProvider);
      if (bodyBox == null || !bodyBox.attached) {
        return;
      }

      if (!_autoScrollArmed && _initialDragPosition != null) {
        final deltaX = (dragPos.dx - _initialDragPosition!.dx).abs();
        final deltaY = (dragPos.dy - _initialDragPosition!.dy).abs();
        final maxDelta = deltaX > deltaY ? deltaX : deltaY;
        if (maxDelta < _autoScrollActivationThreshold) return;
        _autoScrollArmed = true;
      }

      final scrollState = ref.read(agendaScrollProvider(_scrollKey));
      final verticalCtrl = scrollState.verticalScrollCtrl;
      final horizontalCtrl = scrollState.horizontalScrollCtrl;
      if (!verticalCtrl.hasClients && !horizontalCtrl.hasClients) return;

      // dragPos √® gi√† in coordinate locali del bodyBox
      final localPos = dragPos;
      final viewHeight = bodyBox.size.height;
      final viewWidth = bodyBox.size.width;

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Auto scroll verticale (comportamento esistente)
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if (verticalCtrl.hasClients) {
        final maxExtent = verticalCtrl.position.maxScrollExtent;
        final current = verticalCtrl.offset;

        double? newOffset;
        if (localPos.dy < _scrollEdgeMargin && current > 0) {
          newOffset = (current - _scrollSpeed).clamp(0, maxExtent);
        } else if (localPos.dy > viewHeight - _scrollEdgeMargin &&
            current < maxExtent) {
          newOffset = (current + _scrollSpeed).clamp(0, maxExtent);
        }

        if (newOffset != null && newOffset != current) {
          verticalCtrl.jumpTo(newOffset);
        }
      }

      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      // Auto scroll orizzontale per raggiungere colonne nascoste
      // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if (horizontalCtrl.hasClients) {
        final maxHorizontal = horizontalCtrl.position.maxScrollExtent;
        final currentX = horizontalCtrl.offset;

        // Usiamo una soglia relativa alla larghezza visibile,
        // per renderlo affidabile anche con layout molto larghi.
        const double edgeFraction = 0.18; // ~18% ai lati
        final double leftEdge = viewWidth * edgeFraction;
        final double rightEdge = viewWidth * (1 - edgeFraction);

        double? newOffsetX;
        if (localPos.dx < leftEdge && currentX > 0) {
          newOffsetX = (currentX - _scrollSpeed).clamp(0, maxHorizontal);
        } else if (localPos.dx > rightEdge && currentX < maxHorizontal) {
          newOffsetX = (currentX + _scrollSpeed).clamp(0, maxHorizontal);
        }

        if (newOffsetX != null && newOffsetX != currentX) {
          horizontalCtrl.jumpTo(newOffsetX);
        }
      }
    });
  }

  void _stopAutoScroll() {
    _autoScrollTimer?.cancel();
    _autoScrollTimer = null;
    _initialDragPosition = null;
    _autoScrollArmed = false;
  }

  @override
  void dispose() {
    _dragSub.close();
    _layoutSub.close();
    _scrollRequestSub.close();
    _stopAutoScroll();
    _syncDebounce?.cancel();
    _scrollRetryTimer?.cancel();

    _bodyHorizontalCtrl?.removeListener(_onBodyHorizontalScroll);
    _headerHCtrl.removeListener(_onHeaderHorizontalScroll);
    _verticalCtrl?.removeListener(_onVerticalScrollChanged);

    _clearBodyBox();

    _headerHCtrl.dispose();
    super.dispose();
  }

  @override
  void didUpdateWidget(MultiStaffDayView oldWidget) {
    super.didUpdateWidget(oldWidget);

    // ogni cambio staffList/date ‚Üí resync orizzontale
    _scheduleSyncUpdate();

    // stesso comportamento di prima per isPrimary
    // quando smette di essere primary: pulisce il body
    _clearBodyBox();
  }

  @override
  Widget build(BuildContext context) {
    final appointments = ref.watch(appointmentsForCurrentLocationProvider);
    final scrollState = ref.watch(agendaScrollProvider(_scrollKey));
    final layoutConfig = ref.watch(layoutConfigProvider);
    // Evaluate the interaction lock once here for the current visible group
    final isInteractionLocked = ref.watch(agendaDayScrollLockProvider);

    final verticalCtrl = scrollState.verticalScrollCtrl;
    if (_verticalCtrl != verticalCtrl) {
      _verticalCtrl?.removeListener(_onVerticalScrollChanged);
      _verticalCtrl = verticalCtrl;
      _verticalCtrl?.addListener(_onVerticalScrollChanged);
      widget.onVerticalControllerChanged?.call(verticalCtrl);
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        final availableWidth =
            constraints.hasBoundedWidth && constraints.maxWidth.isFinite
            ? constraints.maxWidth
            : MediaQuery.of(context).size.width;

        final layout = ResponsiveLayout.of(
          context,
          staffCount: widget.staffList.length,
          config: layoutConfig,
          availableWidth: availableWidth,
        );

        final totalHeight = layoutConfig.totalHeight;
        final hourW = layoutConfig.hourColumnWidth;
        final headerHeight = layoutConfig.headerHeight;
        final LayerLink? link = ref.watch(dragLayerLinkProvider);
        final selectedDate = ref.watch(agendaDateProvider);
        final isToday = DateUtils.isSameDay(
          selectedDate,
          DateUtils.dateOnly(DateTime.now()),
        );

        final isResizing = ref.watch(isResizingProvider);

        return Stack(
          clipBehavior: Clip.none,
          children: [
            // BODY scrollabile
            Positioned.fill(
              top: headerHeight,
              child: AgendaStaffBody(
                verticalController: scrollState.verticalScrollCtrl,
                horizontalController: scrollState.horizontalScrollCtrl,
                staffList: widget.staffList,
                appointments: appointments,
                layoutConfig: layoutConfig,
                availableWidth: availableWidth,
                isResizing: isResizing,
                dragLayerLink: link,
                bodyKey: _bodyKey,
                isInteractionLocked: isInteractionLocked,
              ),
            ),
            // LINEA ORARIO (solo per la data odierna)
            if (isToday)
              CurrentTimeLine(
                hourColumnWidth: widget.hourColumnWidth,
                verticalOffset: widget.currentTimeVerticalOffset,
                horizontalOffset:
                    -widget.hourColumnWidth + CurrentTimeLine.horizontalMargin,
              ),
            // HEADER staff
            Positioned(
              top: 0,
              left: 0,
              right: 0,
              height: headerHeight,
              child: KeyedSubtree(
                key: _headerKey,
                child: AgendaStaffHeader(
                  staffList: widget.staffList,
                  hourColumnWidth: hourW,
                  totalHeight: totalHeight,
                  headerHeight: headerHeight,
                  columnWidth: layout.columnWidth,
                  scrollController: _headerHCtrl,
                ),
              ),
            ),
          ],
        );
      },
    );
  }
}
--- FILE: lib/features/agenda/presentation/agenda_screen.dart ---
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/widgets/no_scrollbar_behavior.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/day_view/agenda_day.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/day_view/components/hour_column.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/widgets/agenda_dividers.dart';
import 'package:agenda_backend/features/agenda/providers/appointment_providers.dart';
import 'package:agenda_backend/features/agenda/providers/is_resizing_provider.dart';
import 'package:agenda_backend/features/agenda/providers/layout_config_provider.dart';
import 'package:agenda_backend/features/agenda/providers/staff_filter_providers.dart';
import 'package:agenda_backend/features/agenda/domain/staff_filter_mode.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../providers/agenda_scroll_request_provider.dart';
import '../providers/date_range_provider.dart';

class AgendaScreen extends ConsumerStatefulWidget {
  const AgendaScreen({super.key, this.initialClientId});

  /// Se valorizzato, crea automaticamente una prenotazione rapida per il client.
  final int? initialClientId;

  @override
  ConsumerState<AgendaScreen> createState() => _AgendaScreenState();
}

class _AgendaScreenState extends ConsumerState<AgendaScreen> {
  final ScrollController _hourColumnController = ScrollController();
  final AgendaDayController _timelineController = AgendaDayController();
  late final ProviderSubscription<AgendaScrollRequest?> _scrollRequestSub;

  double? _pendingHourOffset;
  bool _pendingApplyScheduled = false;
  bool _quickBookingTriggered = false;

  // üîπ offset verticale "master" della giornata (usato anche dalla CurrentTimeLine)
  double _verticalOffset = 0;

  @override
  void dispose() {
    _scrollRequestSub.close();
    _timelineController.dispose();
    _hourColumnController.dispose();
    super.dispose();
  }

  void _handleMasterScroll(double offset) {
    // aggiorna l'offset usato dalla CurrentTimeLine
    if (mounted) {
      setState(() {
        _verticalOffset = offset;
      });
    }

    // sincronizza lo scroll della colonna oraria con la timeline
    if (!_hourColumnController.hasClients) {
      _pendingHourOffset = offset;
      _schedulePendingApply();
      return;
    }

    final position = _hourColumnController.position;
    final target = offset.clamp(
      position.minScrollExtent,
      position.maxScrollExtent,
    );

    if ((position.pixels - target).abs() < 0.5) {
      return;
    }

    _hourColumnController.jumpTo(target);
  }

  void _applyPendingOffset() {
    if (!mounted || _pendingHourOffset == null) return;

    if (!_hourColumnController.hasClients) {
      _schedulePendingApply();
      return;
    }

    final position = _hourColumnController.position;
    final target = _pendingHourOffset!.clamp(
      position.minScrollExtent,
      position.maxScrollExtent,
    );

    _hourColumnController.jumpTo(target);
    _pendingHourOffset = null;
  }

  void _schedulePendingApply() {
    if (_pendingApplyScheduled) return;
    _pendingApplyScheduled = true;
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _pendingApplyScheduled = false;
      if (!mounted) return;
      _applyPendingOffset();
    });
  }

  @override
  void initState() {
    super.initState();
    _scrollRequestSub = ref.listenManual<AgendaScrollRequest?>(
      agendaScrollRequestProvider,
      (prev, next) {
        if (next == null) return;
        final currentDate = ref.read(agendaDateProvider);
        final targetDate = next.date;
        if (!DateUtils.isSameDay(currentDate, targetDate)) {
          ref.read(agendaDateProvider.notifier).set(targetDate);
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (!mounted) return;
            ref
                .read(agendaScrollRequestProvider.notifier)
                .request(next.appointment);
          });
        }
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    final ref = this.ref;
    final staffList = ref.watch(filteredStaffProvider);
    final staffFilterMode = ref.watch(staffFilterModeProvider);
    final hasStaff = staffList.isNotEmpty;
    final isResizing = ref.watch(isResizingProvider);
    final layoutConfig = ref.watch(layoutConfigProvider);

    final hourColumnWidth = layoutConfig.hourColumnWidth;
    final totalHeight = layoutConfig.totalHeight;

    // Se arriviamo con un clientId e non abbiamo ancora creato la prenotazione rapida
    final initialClientId = widget.initialClientId;
    if (initialClientId != null && !_quickBookingTriggered) {
      // Usa addPostFrame per evitare rebuild loop
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (!mounted) return;
        _quickBookingTriggered = true;
        ref
            .read(appointmentsProvider.notifier)
            .createQuickBookingForClient(initialClientId);
      });
    }

    final hourColumnStack = SizedBox(
      width: hourColumnWidth,
      child: Stack(
        clipBehavior: Clip.none,
        children: [
          Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              DecoratedBox(
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.surface,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.12),
                      offset: const Offset(3, 0),
                      blurRadius: 12,
                      spreadRadius: 0,
                    ),
                  ],
                ),
                child: SizedBox(
                  width: hourColumnWidth,
                  height: layoutConfig.headerHeight,
                ),
              ),
              Expanded(
                child: ScrollConfiguration(
                  behavior: const NoScrollbarBehavior(),
                  child: SingleChildScrollView(
                    controller: _hourColumnController,
                    scrollDirection: Axis.vertical,
                    physics:
                        isResizing || hasStaff
                            ? const NeverScrollableScrollPhysics()
                            : null,
                    child: SizedBox(
                      width: hourColumnWidth,
                      child: const HourColumn(),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );

    final mainRow = Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (hasStaff) hourColumnStack,
        if (hasStaff)
          AgendaVerticalDivider(
            height: totalHeight,
            thickness: 1,
            fadeTopHeight: layoutConfig.headerHeight,
          ),
        Expanded(
          child: AgendaDay(
            staffList: staffList,
            onVerticalOffsetChanged: _handleMasterScroll,
            controller: _timelineController,
            hourColumnWidth: hourColumnWidth,
            currentTimeVerticalOffset: _verticalOffset,
          ),
        ),
      ],
    );

    return Stack(
      children: [
        Positioned.fill(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                child: hasStaff
                    ? mainRow
                    : Center(
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Text(
                              staffFilterMode == StaffFilterMode.onDutyTeam
                                  ? context.l10n.agendaNoOnDutyTeamTitle
                                  : context.l10n.agendaNoSelectedTeamTitle,
                              style: Theme.of(context).textTheme.titleMedium,
                              textAlign: TextAlign.center,
                            ),
                            const SizedBox(height: 12),
                            ElevatedButton(
                              onPressed: () {
                                ref
                                    .read(staffFilterModeProvider.notifier)
                                    .set(StaffFilterMode.allTeam);
                              },
                              child: Text(
                                context.l10n.agendaShowAllTeamButton,
                              ),
                            ),
                          ],
                        ),
                      ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}
--- FILE: lib/features/agenda/presentation/dialogs/add_block_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:agenda_backend/core/widgets/app_bottom_sheet.dart';
import 'package:agenda_backend/core/widgets/labeled_form_field.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/date_time_formats.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/time_block.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/app_switch.dart';
import '../../domain/config/layout_config.dart';
import '../../providers/date_range_provider.dart';
import '../../providers/layout_config_provider.dart';
import '../../providers/time_blocks_provider.dart';

/// Mostra il dialog per creare o modificare un blocco di non disponibilit√†.
Future<void> showAddBlockDialog(
  BuildContext context,
  WidgetRef ref, {
  TimeBlock? initial,
  DateTime? date,
  TimeOfDay? time,
  int? initialStaffId,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final isDesktop = formFactor == AppFormFactor.desktop;

  final dialog = _AddBlockDialog(
    initial: initial,
    initialDate: date,
    initialTime: time,
    initialStaffId: initialStaffId,
    presentation: isDesktop
        ? _BlockDialogPresentation.dialog
        : _BlockDialogPresentation.bottomSheet,
  );

  if (isDesktop) {
    await showDialog(context: context, builder: (_) => dialog);
  } else {
    await AppBottomSheet.show(
      context: context,
      useRootNavigator: true,
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 20),
      builder: (_) => dialog,
    );
  }
}

enum _BlockDialogPresentation { dialog, bottomSheet }

class _AddBlockDialog extends ConsumerStatefulWidget {
  const _AddBlockDialog({
    this.initial,
    this.initialDate,
    this.initialTime,
    this.initialStaffId,
    required this.presentation,
  });

  final TimeBlock? initial;
  final DateTime? initialDate;
  final TimeOfDay? initialTime;
  final int? initialStaffId;
  final _BlockDialogPresentation presentation;

  @override
  ConsumerState<_AddBlockDialog> createState() => _AddBlockDialogState();
}

class _AddBlockDialogState extends ConsumerState<_AddBlockDialog> {
  late DateTime _date;
  late TimeOfDay _startTime;
  late TimeOfDay _endTime;
  late Set<int> _selectedStaffIds;
  final _reasonController = TextEditingController();
  final ScrollController _staffScrollController = ScrollController();
  bool _isAllDay = false;
  String? _staffError;
  String? _timeError;

  @override
  void initState() {
    super.initState();
    final agendaDate = ref.read(agendaDateProvider);

    if (widget.initial != null) {
      final block = widget.initial!;
      _date = DateTime(
        block.startTime.year,
        block.startTime.month,
        block.startTime.day,
      );
      _startTime = TimeOfDay(
        hour: block.startTime.hour,
        minute: block.startTime.minute,
      );
      _endTime = TimeOfDay(
        hour: block.endTime.hour,
        minute: block.endTime.minute,
      );
      _selectedStaffIds = Set.from(block.staffIds);
      _reasonController.text = block.reason ?? '';
      _isAllDay = block.isAllDay;
    } else {
      _date = DateUtils.dateOnly(widget.initialDate ?? agendaDate);
      _startTime = widget.initialTime ?? const TimeOfDay(hour: 10, minute: 0);
      _endTime = TimeOfDay(
        hour: _startTime.hour + 1,
        minute: _startTime.minute,
      );
      _selectedStaffIds = widget.initialStaffId != null
          ? {widget.initialStaffId!}
          : {};
    }
  }

  @override
  void dispose() {
    _reasonController.dispose();
    _staffScrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final isEdit = widget.initial != null;
    final staff = ref.watch(staffForCurrentLocationProvider);
    final isDialog = widget.presentation == _BlockDialogPresentation.dialog;

    final title = isEdit ? l10n.blockDialogTitleEdit : l10n.blockDialogTitleNew;
    final content = Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Data
        LabeledFormField(
          label: l10n.formDate,
          child: InkWell(
            onTap: _pickDate,
            child: InputDecorator(
              decoration: const InputDecoration(
                border: OutlineInputBorder(),
                isDense: true,
              ),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    '${_date.day.toString().padLeft(2, '0')}/${_date.month.toString().padLeft(2, '0')}/${_date.year}',
                  ),
                  const Icon(Icons.calendar_today, size: 16),
                ],
              ),
            ),
          ),
        ),
        const SizedBox(height: 12),

        // Giornata intera switch
        Row(
          children: [
            AppSwitch(
              value: _isAllDay,
              onChanged: (v) => setState(() => _isAllDay = v),
            ),
            const SizedBox(width: 8),
            Text(l10n.blockAllDay),
          ],
        ),
        const SizedBox(height: 12),

        // Orari
        if (!_isAllDay) ...[
          Row(
            children: [
              Expanded(
                child: LabeledFormField(
                  label: l10n.blockStartTime,
                  child: InkWell(
                    onTap: () => _pickTime(isStart: true),
                    child: InputDecorator(
                      decoration: InputDecoration(
                        border: const OutlineInputBorder(),
                        isDense: true,
                        errorText: null,
                        enabledBorder: _timeError != null
                            ? OutlineInputBorder(
                                borderSide: BorderSide(
                                  color: Theme.of(context).colorScheme.error,
                                ),
                              )
                            : null,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_startTime.format(context)),
                          const Icon(Icons.schedule, size: 16),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: LabeledFormField(
                  label: l10n.blockEndTime,
                  child: InkWell(
                    onTap: () => _pickTime(isStart: false),
                    child: InputDecorator(
                      decoration: InputDecoration(
                        border: const OutlineInputBorder(),
                        isDense: true,
                        enabledBorder: _timeError != null
                            ? OutlineInputBorder(
                                borderSide: BorderSide(
                                  color: Theme.of(context).colorScheme.error,
                                ),
                              )
                            : null,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_endTime.format(context)),
                          const Icon(Icons.schedule, size: 16),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
          if (_timeError != null)
            Padding(
              padding: const EdgeInsets.only(top: 6, left: 12),
              child: Text(
                _timeError!,
                style: TextStyle(
                  color: Theme.of(context).colorScheme.error,
                  fontSize: 12,
                ),
              ),
            ),
          const SizedBox(height: 12),
        ],

        // Staff selection
        LabeledFormField(
          label: l10n.blockSelectStaff,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Container(
                decoration: BoxDecoration(
                  border: Border.all(
                    color: _staffError != null
                        ? Theme.of(context).colorScheme.error
                        : Theme.of(context).dividerColor,
                  ),
                  borderRadius: BorderRadius.circular(4),
                ),
                constraints: const BoxConstraints(maxHeight: 200),
                child: Scrollbar(
                  controller: _staffScrollController,
                  thumbVisibility: staff.length * 48.0 > 200,
                  child: ListView.builder(
                    controller: _staffScrollController,
                    shrinkWrap: true,
                    itemCount: staff.length,
                    itemBuilder: (context, index) {
                      final member = staff[index];
                      final isSelected = _selectedStaffIds.contains(member.id);
                      return CheckboxListTile(
                        value: isSelected,
                        onChanged: (v) {
                          setState(() {
                            _staffError = null;
                            if (v == true) {
                              _selectedStaffIds.add(member.id);
                            } else {
                              _selectedStaffIds.remove(member.id);
                            }
                          });
                        },
                        title: Text(member.name),
                        secondary: StaffCircleAvatar(
                          height: 24,
                          color: member.color,
                          isHighlighted: _selectedStaffIds.contains(member.id),
                          initials: member.initials,
                        ),
                        dense: true,
                        controlAffinity: ListTileControlAffinity.leading,
                      );
                    },
                  ),
                ),
              ),
              if (_staffError != null)
                Padding(
                  padding: const EdgeInsets.only(top: 6, left: 12),
                  child: Text(
                    _staffError!,
                    style: TextStyle(
                      color: Theme.of(context).colorScheme.error,
                      fontSize: 12,
                    ),
                  ),
                ),
            ],
          ),
        ),
        const SizedBox(height: 12),

        // Motivo opzionale
        LabeledFormField(
          label: l10n.blockReason,
          child: TextField(
            controller: _reasonController,
            decoration: InputDecoration(
              hintText: l10n.blockReasonHint,
              border: const OutlineInputBorder(),
              isDense: true,
            ),
          ),
        ),
      ],
    );

    final actions = [
      if (isEdit)
        AppDangerButton(
          onPressed: _onDelete,
          padding: AppButtonStyles.dialogButtonPadding,
          child: Text(l10n.actionDelete),
        ),
      AppOutlinedActionButton(
        onPressed: () => Navigator.of(context).pop(),
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppFilledButton(
        onPressed: _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionSave),
      ),
    ];

    final bottomActions = actions
        .map(
          (a) => SizedBox(width: AppButtonStyles.dialogButtonWidth, child: a),
        )
        .toList();

    if (isDialog) {
      return DismissibleDialog(
        child: Dialog(
          insetPadding: const EdgeInsets.symmetric(
            horizontal: 32,
            vertical: 24,
          ),
          child: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text(title, style: Theme.of(context).textTheme.headlineSmall),
                  const SizedBox(height: 16),
                  Flexible(child: SingleChildScrollView(child: content)),
                  const SizedBox(height: 24),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      if (isEdit) ...[
                        bottomActions.first, // Delete button
                        const Spacer(),
                        bottomActions[1], // Cancel button
                      ] else
                        bottomActions[0], // Cancel button
                      const SizedBox(width: 8),
                      bottomActions.last, // Save button
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      );
    }

    return SafeArea(
      top: false,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final isKeyboardOpen =
              MediaQuery.of(context).viewInsets.bottom > 0;
          return SizedBox(
            height: constraints.maxHeight,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Expanded(
                  child: SingleChildScrollView(
                    padding: EdgeInsets.only(
                      bottom: 0,
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Padding(
                          padding: const EdgeInsets.only(bottom: 12),
                          child: Text(
                            title,
                            style: Theme.of(context).textTheme.titleLarge,
                          ),
                        ),
                        content,
                        const SizedBox(height: 24),
                        const SizedBox(height: AppSpacing.formRowSpacing),
                      ],
                    ),
                  ),
                ),
                if (!isKeyboardOpen) ...[
                  const AppBottomSheetDivider(),
                  Padding(
                    padding: const EdgeInsets.fromLTRB(0, 12, 0, 0),
                    child: Align(
                      alignment: bottomActions.length == 3
                          ? Alignment.center
                          : Alignment.centerRight,
                      child: Wrap(
                        alignment: bottomActions.length == 3
                            ? WrapAlignment.center
                            : WrapAlignment.end,
                        spacing: 8,
                        runSpacing: 8,
                        children: bottomActions,
                      ),
                    ),
                  ),
                ],
                SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
              ],
            ),
          );
        },
      ),
    );
  }

  Future<void> _pickDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _date,
      firstDate: DateTime.now().subtract(const Duration(days: 365)),
      lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
    );
    if (picked != null) {
      setState(() => _date = DateUtils.dateOnly(picked));
    }
  }

  Future<void> _pickTime({required bool isStart}) async {
    final step = ref.read(layoutConfigProvider).minutesPerSlot;
    final selected = await AppBottomSheet.show<TimeOfDay>(
      context: context,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      builder: (ctx) {
        final height = MediaQuery.of(ctx).size.height * 0.9;
        return SizedBox(
          height: height,
          child: _TimeGridPicker(
            initial: isStart ? _startTime : _endTime,
            stepMinutes: step,
          ),
        );
      },
    );
    if (selected != null) {
      setState(() {
        _timeError = null; // Reset errore quando l'utente modifica
        if (isStart) {
          _startTime = selected;
          // Aggiusta automaticamente l'end time se necessario
          final startMinutes = _startTime.hour * 60 + _startTime.minute;
          final endMinutes = _endTime.hour * 60 + _endTime.minute;
          if (endMinutes <= startMinutes) {
            _endTime = TimeOfDay(
              hour: (_startTime.hour + 1) % 24,
              minute: _startTime.minute,
            );
          }
        } else {
          _endTime = selected;
        }
      });
    }
  }

  void _onSave() {
    final l10n = context.l10n;
    bool hasError = false;

    // Reset errori
    setState(() {
      _staffError = null;
      _timeError = null;
    });

    if (_selectedStaffIds.isEmpty) {
      setState(() => _staffError = l10n.blockSelectStaffError);
      hasError = true;
    }

    // Validazione orari
    if (!_isAllDay) {
      final startMinutes = _startTime.hour * 60 + _startTime.minute;
      final endMinutes = _endTime.hour * 60 + _endTime.minute;
      if (endMinutes <= startMinutes) {
        setState(() => _timeError = l10n.blockTimeError);
        hasError = true;
      }
    }

    if (hasError) return;

    final DateTime startDateTime;
    final DateTime endDateTime;

    if (_isAllDay) {
      // Per blocchi giornata intera, usa l'intera giornata lavorativa
      startDateTime = DateTime(_date.year, _date.month, _date.day, 0, 0);
      endDateTime = DateTime(_date.year, _date.month, _date.day, 23, 59);
    } else {
      startDateTime = DateTime(
        _date.year,
        _date.month,
        _date.day,
        _startTime.hour,
        _startTime.minute,
      );
      endDateTime = DateTime(
        _date.year,
        _date.month,
        _date.day,
        _endTime.hour,
        _endTime.minute,
      );
    }

    final reason = _reasonController.text.trim().isEmpty
        ? null
        : _reasonController.text.trim();

    if (widget.initial == null) {
      // Nuovo blocco
      ref
          .read(timeBlocksProvider.notifier)
          .addBlock(
            staffIds: _selectedStaffIds.toList(),
            startTime: startDateTime,
            endTime: endDateTime,
            reason: reason,
            isAllDay: _isAllDay,
          );
    } else {
      // Aggiorna blocco esistente
      final updated = widget.initial!.copyWith(
        staffIds: _selectedStaffIds.toList(),
        startTime: startDateTime,
        endTime: endDateTime,
        reason: reason,
        isAllDay: _isAllDay,
      );
      ref.read(timeBlocksProvider.notifier).updateBlock(updated);
    }

    Navigator.of(context).pop();
  }

  void _onDelete() {
    if (widget.initial != null) {
      ref.read(timeBlocksProvider.notifier).deleteBlock(widget.initial!.id);
      Navigator.of(context).pop();
    }
  }
}

class _TimeGridPicker extends StatefulWidget {
  const _TimeGridPicker({required this.initial, required this.stepMinutes});
  final TimeOfDay initial;
  final int stepMinutes;

  @override
  State<_TimeGridPicker> createState() => _TimeGridPickerState();
}

class _TimeGridPickerState extends State<_TimeGridPicker> {
  late final ScrollController _scrollController;
  late final List<TimeOfDay?> _entries;
  late final int _scrollToIndex;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();

    // Genera la lista degli orari con 4 colonne per riga
    _entries = <TimeOfDay?>[];
    for (int m = 0; m < LayoutConfig.hoursInDay * 60; m += widget.stepMinutes) {
      final h = m ~/ 60;
      final mm = m % 60;
      _entries.add(TimeOfDay(hour: h, minute: mm));
    }

    // Verifica se l'orario iniziale √® gi√† nella lista
    int exactIndex = _entries.indexWhere(
      (t) =>
          t != null &&
          t.hour == widget.initial.hour &&
          t.minute == widget.initial.minute,
    );

    if (exactIndex >= 0) {
      // L'orario √® gi√† presente
      _scrollToIndex = exactIndex;
    } else {
      // L'orario non √® presente: inserisci una NUOVA RIGA con l'orario
      // nella colonna corretta e le altre colonne vuote
      final columnsPerRow = 60 ~/ widget.stepMinutes;
      final targetColumn = widget.initial.minute ~/ widget.stepMinutes;
      final baseIndex = (widget.initial.hour + 1) * columnsPerRow;

      // Crea la nuova riga con 4 elementi (solo uno valorizzato)
      final newRow = List<TimeOfDay?>.filled(columnsPerRow, null);
      newRow[targetColumn] = widget.initial;

      // Inserisci la nuova riga
      final insertIndex = baseIndex.clamp(0, _entries.length);
      _entries.insertAll(insertIndex, newRow);

      // L'indice dell'orario selezionato √® la posizione nella nuova riga
      _scrollToIndex = insertIndex + targetColumn;
    }

    // Scroll all'orario dopo il primo frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _scrollToSelected();
    });
  }

  void _scrollToSelected() {
    if (!_scrollController.hasClients) return;

    const crossAxisCount = 4;
    const mainAxisSpacing = 6.0;
    const childAspectRatio = 2.7;
    const padding = 12.0;

    // Usa la larghezza effettiva del context
    final screenWidth = MediaQuery.of(context).size.width;
    final availableWidth = screenWidth - padding * 2;
    final itemWidth =
        (availableWidth - (crossAxisCount - 1) * 6) / crossAxisCount;
    final itemHeight = itemWidth / childAspectRatio;
    final rowHeight = itemHeight + mainAxisSpacing;

    // Calcola la riga dell'elemento target
    final targetRow = _scrollToIndex ~/ crossAxisCount;

    // Calcola l'offset per centrare la riga target
    final viewportHeight = _scrollController.position.viewportDimension;
    // Offset aggiuntivo per centrare meglio (compensa header visivo)
    const headerOffset = 40.0;
    final targetOffset =
        (targetRow * rowHeight) -
        (viewportHeight / 2) +
        (rowHeight / 2) +
        headerOffset;

    // Limita l'offset ai bounds dello scroll
    final maxScroll = _scrollController.position.maxScrollExtent;
    final clampedOffset = targetOffset.clamp(0.0, maxScroll);

    _scrollController.animateTo(
      clampedOffset,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeOut,
    );
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.all(12),
        child: Column(
          mainAxisSize: MainAxisSize.max,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Icon(Icons.schedule, size: 18),
                const SizedBox(width: 8),
                Text(
                  MaterialLocalizations.of(context).timePickerHourLabel,
                  style: const TextStyle(fontWeight: FontWeight.w700),
                ),
              ],
            ),
            const SizedBox(height: 10),
            Expanded(
              child: GridView.builder(
                controller: _scrollController,
                gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 4,
                  mainAxisSpacing: 6,
                  crossAxisSpacing: 6,
                  childAspectRatio: 2.7,
                ),
                itemCount: _entries.length,
                itemBuilder: (context, index) {
                  final t = _entries[index];
                  // Se la cella √® vuota, mostra uno spazio vuoto
                  if (t == null) {
                    return const SizedBox.shrink();
                  }
                  // Evidenzia l'orario selezionato
                  final isSelected = index == _scrollToIndex;
                  return OutlinedButton(
                    style: OutlinedButton.styleFrom(
                      backgroundColor: isSelected
                          ? Theme.of(
                              context,
                            ).colorScheme.primary.withOpacity(0.1)
                          : null,
                      side: BorderSide(
                        color: isSelected
                            ? Theme.of(context).colorScheme.primary
                            : Theme.of(context).dividerColor,
                      ),
                      padding: const EdgeInsets.symmetric(horizontal: 8),
                    ),
                    onPressed: () => Navigator.pop(context, t),
                    child: Text(_format(context, t)),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }

  String _format(BuildContext ctx, TimeOfDay t) {
    return DtFmt.hm(ctx, t.hour, t.minute);
  }
}
--- FILE: lib/features/agenda/presentation/widgets/booking_details_overlay.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../providers/bookings_provider.dart';

Future<void> showBookingDetailsOverlay(
  BuildContext context,
  WidgetRef ref, {
  required int bookingId,
}) async {
  await showModalBottomSheet(
    context: context,
    isScrollControlled: true,
    useRootNavigator: true,
    builder: (_) => _BookingDetailsSheet(bookingId: bookingId),
  );
}

class _BookingDetailsSheet extends ConsumerWidget {
  const _BookingDetailsSheet({required this.bookingId});
  final int bookingId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final summary = ref.watch(bookingSummaryProvider(bookingId));
    final isSingleAppointment = summary?.itemsCount == 1;
    final deleteTitle = isSingleAppointment
        ? l10n.deleteAppointmentConfirmTitle
        : l10n.deleteBookingConfirmTitle;
    final deleteMessage = isSingleAppointment
        ? l10n.deleteAppointmentConfirmMessage
        : l10n.deleteBookingConfirmMessage;
    final bookings = ref.watch(bookingsProvider);
    final booking = bookings[bookingId];

    return SafeArea(
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  l10n.bookingDetails,
                  style: const TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.w700,
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.close),
                  onPressed: () => Navigator.of(context).pop(),
                ),
              ],
            ),
            const SizedBox(height: 12),
            if (summary != null) ...[
              Row(
                children: [
                  Text('${l10n.bookingItems}: '),
                  Text(
                    '${summary.itemsCount}',
                    style: const TextStyle(fontWeight: FontWeight.w600),
                  ),
                  const SizedBox(width: 16),
                  Text('${l10n.bookingTotal}: '),
                  Text(
                    '${summary.totalPrice.toStringAsFixed(2)}‚Ç¨',
                    style: const TextStyle(fontWeight: FontWeight.w600),
                  ),
                ],
              ),
            ],
            const SizedBox(height: 12),
            Text(
              l10n.bookingNotes,
              style: const TextStyle(fontWeight: FontWeight.w600),
            ),
            const SizedBox(height: 6),
            TextFormField(
              initialValue: booking?.notes ?? '',
              maxLines: 3,
              decoration: const InputDecoration(
                border: OutlineInputBorder(),
                isDense: true,
              ),
              onChanged: (v) => ref
                  .read(bookingsProvider.notifier)
                  .setNotes(bookingId, v.trim().isEmpty ? null : v),
            ),
            const SizedBox(height: 16),
            Row(
              children: [
                Expanded(
                  child: OutlinedButton(
                    onPressed: () async {
                      final confirmed = await showDialog<bool>(
                        context: context,
                        builder: (_) => AlertDialog(
                          title: Text(deleteTitle),
                          content: Text(deleteMessage),
                          actions: [
                            TextButton(
                              onPressed: () => Navigator.pop(context, false),
                              child: Text(l10n.actionCancel),
                            ),
                            TextButton(
                              onPressed: () => Navigator.pop(context, true),
                              child: Text(l10n.actionDeleteBooking),
                            ),
                          ],
                        ),
                      );
                      if (confirmed == true) {
                        ref
                            .read(bookingsProvider.notifier)
                            .deleteBooking(bookingId);
                        if (context.mounted) Navigator.of(context).pop();
                      }
                    },
                    child: Text(l10n.actionDeleteBooking),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 10),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/widgets/service_picker_field.dart ---
import 'package:flutter/material.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../app/theme/extensions.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_dividers.dart';

/// A form field for selecting a service, with services grouped by category.
///
/// On mobile: opens a bottom sheet with grouped services.
/// On desktop: opens a dialog with grouped services.
class ServicePickerField extends StatefulWidget {
  const ServicePickerField({
    super.key,
    required this.services,
    required this.categories,
    required this.formFactor,
    this.value,
    this.onChanged,
    this.onClear,
    this.validator,
    this.autovalidateMode = AutovalidateMode.disabled,
    this.autoOpenPicker = false,
    this.onAutoOpenPickerTriggered,
    this.onAutoOpenPickerCompleted,
  });

  final List<Service> services;
  final List<ServiceCategory> categories;
  final AppFormFactor formFactor;
  final int? value;
  final ValueChanged<int?>? onChanged;

  /// Callback chiamato quando l'utente preme l'icona di rimozione.
  /// Se null, l'icona non viene mostrata.
  final VoidCallback? onClear;
  final FormFieldValidator<int>? validator;
  final bool autoOpenPicker;
  final VoidCallback? onAutoOpenPickerTriggered;
  final VoidCallback? onAutoOpenPickerCompleted;

  /// Modalit√† di autovalidazione. Default: disabled (valida solo su submit).
  final AutovalidateMode autovalidateMode;

  @override
  State<ServicePickerField> createState() => _ServicePickerFieldState();
}

class _ServicePickerFieldState extends State<ServicePickerField> {
  final _formFieldKey = GlobalKey<FormFieldState<int>>();
  bool _autoPickerInvoked = false;
  bool _autoOpenInProgress = false;

  Service? get _selectedService {
    if (widget.value == null) return null;
    return widget.services.where((s) => s.id == widget.value).firstOrNull;
  }

  @override
  void didUpdateWidget(ServicePickerField oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Aggiorna lo stato del FormField quando il valore cambia
    if (oldWidget.value != widget.value) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        final state = _formFieldKey.currentState;
        if (state != null) {
          state.didChange(widget.value);
        }
      });
    }
    if (oldWidget.autoOpenPicker != widget.autoOpenPicker) {
      _autoPickerInvoked = false;
    }
  }

  @override
  Widget build(BuildContext context) {
    return FormField<int>(
      key: _formFieldKey,
      initialValue: widget.value,
      validator: widget.validator,
      autovalidateMode: widget.autovalidateMode,
      builder: (field) {
        final theme = Theme.of(context);
        final hasError = field.hasError;
        final borderColor = hasError
            ? theme.colorScheme.error
            : theme.colorScheme.outline;

        if (widget.autoOpenPicker && !_autoPickerInvoked) {
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (!mounted || _autoPickerInvoked) return;
            _autoPickerInvoked = true;
            _autoOpenInProgress = true;
            _openPicker(field);
            widget.onAutoOpenPickerTriggered?.call();
          });
        }

        return InkWell(
          onTap: () => _openPicker(field),
          borderRadius: BorderRadius.circular(4),
          child: InputDecorator(
            decoration: InputDecoration(
              labelText: _selectedService != null
                  ? context.l10n.formService
                  : null,
              contentPadding: const EdgeInsets.symmetric(
                horizontal: 12,
                vertical: 16,
              ),
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(4),
                borderSide: BorderSide(color: borderColor),
              ),
              enabledBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(4),
                borderSide: BorderSide(color: borderColor),
              ),
              errorText: field.errorText,
              suffixIcon: _selectedService != null && widget.onClear != null
                  ? IconButton(
                      icon: Icon(
                        Icons.close,
                        color: theme.colorScheme.error,
                        size: 20,
                      ),
                      onPressed: widget.onClear,
                      tooltip: context.l10n.actionDelete,
                    )
                  : const Icon(Icons.arrow_drop_down),
            ),
            child: Text(
              _selectedService?.name ?? context.l10n.selectService,
              style: theme.textTheme.bodyLarge?.copyWith(
                color: _selectedService == null
                    ? theme.colorScheme.onSurfaceVariant.withOpacity(0.7)
                    : null,
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ),
        );
      },
    );
  }

  Future<void> _openPicker(FormFieldState<int> field) async {
    if (widget.formFactor == AppFormFactor.desktop) {
      await _openDesktopDialogWithField(field);
    } else {
      await _openBottomSheetWithField(field);
    }
  }

  Future<void> _openBottomSheetWithField(FormFieldState<int> field) async {
    await AppBottomSheet.show<int>(
      context: context,
      heightFactor: AppBottomSheet.defaultHeightFactor,
      padding: EdgeInsets.zero,
      builder: (ctx) => _ServicePickerContent(
        services: widget.services,
        categories: widget.categories,
        selectedId: widget.value,
        onSelected: (id) {
          final wasAutoOpen = _autoOpenInProgress;
          Navigator.of(ctx).pop();
          field.didChange(id);
          field.validate(); // Ri-valida per rimuovere l'errore
          widget.onChanged?.call(id);
          if (wasAutoOpen) {
            _autoOpenInProgress = false;
            widget.onAutoOpenPickerCompleted?.call();
          }
        },
      ),
    );
    _autoOpenInProgress = false;
  }

  Future<void> _openDesktopDialogWithField(FormFieldState<int> field) async {
    await showDialog<int>(
      context: context,
      builder: (ctx) => Dialog(
        insetPadding: const EdgeInsets.symmetric(horizontal: 32, vertical: 24),
        child: ConstrainedBox(
          constraints: const BoxConstraints(
            minWidth: 600,
            maxWidth: 720,
            maxHeight: 500,
          ),
          child: _ServicePickerContent(
            services: widget.services,
            categories: widget.categories,
            selectedId: widget.value,
            onSelected: (id) {
              final wasAutoOpen = _autoOpenInProgress;
              Navigator.of(ctx).pop();
              field.didChange(id);
              field.validate(); // Ri-valida per rimuovere l'errore
              widget.onChanged?.call(id);
              if (wasAutoOpen) {
                _autoOpenInProgress = false;
                widget.onAutoOpenPickerCompleted?.call();
              }
            },
          ),
        ),
      ),
    );
    _autoOpenInProgress = false;
  }
}

/// Content widget for the service picker (used in both bottom sheet and popup).
class _ServicePickerContent extends StatelessWidget {
  const _ServicePickerContent({
    required this.services,
    required this.categories,
    required this.selectedId,
    required this.onSelected,
  });

  final List<Service> services;
  final List<ServiceCategory> categories;
  final int? selectedId;
  final ValueChanged<int?> onSelected;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    final servicesByCategory = <int, List<Service>>{};
    for (final service in services) {
      (servicesByCategory[service.categoryId] ??= []).add(service);
    }

    final hasServicesMap = <int, bool>{
      for (final category in categories)
        category.id: (servicesByCategory[category.id]?.isNotEmpty ?? false),
    };

    // Sort categories like services section:
    // 1) non-empty before empty, 2) sortOrder, 3) name
    final sortedCategories = [...categories]
      ..sort((a, b) {
        final aEmpty = !(hasServicesMap[a.id] ?? false);
        final bEmpty = !(hasServicesMap[b.id] ?? false);
        if (aEmpty != bEmpty) return aEmpty ? 1 : -1;
        final so = a.sortOrder.compareTo(b.sortOrder);
        return so != 0
            ? so
            : a.name.toLowerCase().compareTo(b.name.toLowerCase());
      });

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Header
        Padding(
          padding: const EdgeInsets.fromLTRB(16, 8, 16, 12),
          child: Text(
            l10n.formService,
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.w600,
            ),
          ),
        ),
        const AppBottomSheetDivider(),
        // Service list
        Expanded(
          child: ListView.builder(
            shrinkWrap: true,
            itemCount: sortedCategories.length,
            itemBuilder: (ctx, index) {
              final category = sortedCategories[index];
              final categoryServices =
                  (servicesByCategory[category.id] ?? []).toList()
                    ..sort((a, b) {
                      final so = a.sortOrder.compareTo(b.sortOrder);
                      return so != 0
                          ? so
                          : a.name.toLowerCase().compareTo(b.name.toLowerCase());
                    });

              if (categoryServices.isEmpty) {
                return const SizedBox.shrink();
              }

              return _CategorySection(
                category: category,
                services: categoryServices,
                selectedId: selectedId,
                onSelected: onSelected,
              );
            },
          ),
        ),
      ],
    );
  }
}

/// A section showing a category header and its services.
class _CategorySection extends StatelessWidget {
  const _CategorySection({
    required this.category,
    required this.services,
    required this.selectedId,
    required this.onSelected,
  });

  final ServiceCategory category;
  final List<Service> services;
  final int? selectedId;
  final ValueChanged<int?> onSelected;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    // Colore di sfondo leggero per i servizi con indice pari (even)
    final interactionColors = theme.extension<AppInteractionColors>();
    final evenBackgroundColor =
        interactionColors?.alternatingRowFill ??
        theme.colorScheme.onSurface.withOpacity(0.04);

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Category header with full-width background
        Container(
          width: double.infinity,
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 20),
          color: theme.colorScheme.primary,
          child: Center(
            child: Text(
              category.name.toUpperCase(),
              style: theme.textTheme.labelMedium?.copyWith(
                color: theme.colorScheme.onPrimary,
                fontWeight: FontWeight.bold,
                letterSpacing: 0.5,
              ),
            ),
          ),
        ),
        // Services con sfondo alternato (even)
        for (int i = 0; i < services.length; i++)
          _buildServiceTile(
            context,
            services[i],
            isEven: i.isEven,
            evenBackgroundColor: evenBackgroundColor,
            theme: theme,
          ),
      ],
    );
  }

  Widget _buildServiceTile(
    BuildContext context,
    Service service, {
    required bool isEven,
    required Color evenBackgroundColor,
    required ThemeData theme,
  }) {
    final isSelected = service.id == selectedId;
    return Material(
      color: isEven ? evenBackgroundColor : Colors.transparent,
      child: InkWell(
        onTap: () => onSelected(service.id),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          child: Row(
            children: [
              Expanded(child: Text(service.name)),
              if (isSelected)
                Icon(Icons.check, color: theme.colorScheme.primary, size: 20),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/widgets/appointment_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:agenda_backend/core/l10n/date_time_formats.dart';
import 'package:agenda_backend/core/widgets/no_scrollbar_behavior.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/appointment.dart';
import '../../../../core/models/service_variant.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../clients/domain/clients.dart';
import '../../../clients/presentation/dialogs/client_edit_dialog.dart';
import '../../../clients/providers/clients_providers.dart';
import '../../../services/providers/service_categories_provider.dart';
import '../../../services/providers/services_provider.dart';
import '../../domain/service_item_data.dart';
import '../../providers/agenda_scroll_request_provider.dart';
import '../../providers/appointment_providers.dart';
import '../../providers/bookings_provider.dart';
import '../../providers/layout_config_provider.dart';
import '../../providers/staff_slot_availability_provider.dart';
import 'service_item_card.dart';

/// Show the Appointment dialog for editing an existing appointment.
/// For creating new appointments, use [showBookingDialog] instead.
Future<void> showAppointmentDialog(
  BuildContext context,
  WidgetRef ref, {
  required Appointment initial,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final presentation = formFactor == AppFormFactor.desktop
      ? _AppointmentPresentation.dialog
      : _AppointmentPresentation.bottomSheet;

  final content = _AppointmentDialog(
    initial: initial,
    presentation: presentation,
  );

  if (presentation == _AppointmentPresentation.dialog) {
    await showDialog(context: context, builder: (_) => content);
  } else {
    await AppBottomSheet.show(
      context: context,
      useRootNavigator: true,
      builder: (_) => content,
      padding: const EdgeInsets.symmetric(horizontal: 0, vertical: 16),
      heightFactor: AppBottomSheet.defaultHeightFactor,
    );
  }
}

enum _AppointmentPresentation { dialog, bottomSheet }

class _AppointmentDialog extends ConsumerStatefulWidget {
  const _AppointmentDialog({required this.initial, required this.presentation});

  final Appointment initial;
  final _AppointmentPresentation presentation;

  @override
  ConsumerState<_AppointmentDialog> createState() => _AppointmentDialogState();
}

class _AppointmentDialogState extends ConsumerState<_AppointmentDialog> {
  final _formKey = GlobalKey<FormState>();
  final _notesController = TextEditingController();
  final ScrollController _scrollController = ScrollController();

  late DateTime _date;
  int? _clientId;
  String _clientName = '';
  late final bool _bookingHasSingleAppointment;

  /// Lista di ServiceItemData per i servizi dell'appuntamento
  final List<ServiceItemData> _serviceItems = [];

  /// Contatore per generare chiavi univoche
  int _itemKeyCounter = 0;

  bool _warningDismissed = false;
  int? _autoOpenServicePickerIndex;

  /// Stato iniziale per rilevare modifiche
  late DateTime _initialDate;
  late int? _initialClientId;
  late String _initialClientName;
  late String _initialNotes;
  late List<ServiceItemData> _initialServiceItems;

  @override
  void initState() {
    super.initState();

    final appt = widget.initial;
    _date = DateTime(
      appt.startTime.year,
      appt.startTime.month,
      appt.startTime.day,
    );
    _clientId = appt.clientId;
    _clientName = appt.clientName;
    Future.microtask(() {
      if (!mounted) return;
      ref
          .read(bookingsProvider.notifier)
          .ensureBooking(
            bookingId: appt.bookingId,
            businessId: appt.businessId,
            locationId: appt.locationId,
            clientId: appt.clientId,
            customerName: appt.clientName,
          );
    });
    // Leggi le note dalla Booking associata
    final booking = ref.read(bookingsProvider)[appt.bookingId];
    _notesController.text = booking?.notes ?? '';

    // Carica tutti gli appuntamenti della stessa prenotazione
    final bookingAppointments = ref
        .read(appointmentsProvider.notifier)
        .getByBookingId(appt.bookingId);
    _bookingHasSingleAppointment = bookingAppointments.length <= 1;

    for (final appointment in bookingAppointments) {
      final baseDuration = _baseDurationFromAppointment(appointment);
      final blockedExtraMinutes = appointment.blockedExtraMinutes;
      final processingExtraMinutes = appointment.processingExtraMinutes;
      _serviceItems.add(
        ServiceItemData(
          key: _nextItemKey(),
          startTime: TimeOfDay.fromDateTime(appointment.startTime),
          staffId: appointment.staffId,
          serviceId: appointment.serviceId,
          serviceVariantId: appointment.serviceVariantId,
          durationMinutes: baseDuration,
          blockedExtraMinutes: blockedExtraMinutes,
          processingExtraMinutes: processingExtraMinutes,
        ),
      );
    }

    // Se non ci sono appointments (caso raro), aggiungi un item vuoto
    if (_serviceItems.isEmpty) {
      final initialTime = TimeOfDay.fromDateTime(appt.startTime);
      _serviceItems.add(
        ServiceItemData(
          key: _nextItemKey(),
          startTime: initialTime,
          staffId: appt.staffId,
        ),
      );
    }

    // Salva stato iniziale per rilevare modifiche
    _initialDate = _date;
    _initialClientId = _clientId;
    _initialClientName = _clientName;
    _initialNotes = _notesController.text;
    // Copia profonda dei servizi per confronto
    _initialServiceItems = _serviceItems
        .map(
          (s) => ServiceItemData(
            key: s.key,
            startTime: s.startTime,
            staffId: s.staffId,
            serviceId: s.serviceId,
            serviceVariantId: s.serviceVariantId,
            durationMinutes: s.durationMinutes,
            blockedExtraMinutes: s.blockedExtraMinutes,
            processingExtraMinutes: s.processingExtraMinutes,
          ),
        )
        .toList();
  }

  @override
  void dispose() {
    _notesController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  String _nextItemKey() => 'item_${_itemKeyCounter++}';

  int _baseDurationFromAppointment(Appointment appointment) {
    final totalMinutes = appointment.endTime
        .difference(appointment.startTime)
        .inMinutes;
    final extraMinutes = appointment.blockedExtraMinutes;
    final base = totalMinutes - extraMinutes;
    return base > 0 ? base : 0;
  }

  /// Verifica se ci sono modifiche non salvate
  bool get _hasUnsavedChanges {
    if (_date != _initialDate) return true;
    if (_clientId != _initialClientId) return true;
    if (_clientName != _initialClientName) return true;
    if (_notesController.text != _initialNotes) return true;
    if (_serviceItems.length != _initialServiceItems.length) return true;

    // Confronto dettagliato dei servizi
    for (int i = 0; i < _serviceItems.length; i++) {
      final current = _serviceItems[i];
      final initial = _initialServiceItems[i];
      if (current.serviceId != initial.serviceId) return true;
      if (current.staffId != initial.staffId) return true;
      if (current.startTime != initial.startTime) return true;
      if (current.durationMinutes != initial.durationMinutes) return true;
      if (current.blockedExtraMinutes != initial.blockedExtraMinutes) {
        return true;
      }
      if (current.processingExtraMinutes != initial.processingExtraMinutes) {
        return true;
      }
    }

    return false;
  }

  /// Gestisce la chiusura del dialog con controllo modifiche
  Future<void> _handleClose() async {
    if (_hasUnsavedChanges) {
      final l10n = context.l10n;
      final confirmed = await showDialog<bool>(
        context: context,
        builder: (_) => AlertDialog(
          title: Text(l10n.discardChangesTitle),
          content: Text(l10n.discardChangesMessage),
          actions: [
            AppOutlinedActionButton(
              onPressed: () => Navigator.pop(context, false),
              child: Text(l10n.actionKeepEditing),
            ),
            AppDangerButton(
              onPressed: () => Navigator.pop(context, true),
              child: Text(l10n.actionDiscard),
            ),
          ],
        ),
      );
      if (confirmed != true) return;
    }
    if (mounted) Navigator.of(context).pop();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final isDialog = widget.presentation == _AppointmentPresentation.dialog;

    final formFactor = ref.watch(formFactorProvider);
    final services = ref.watch(servicesProvider);
    final serviceCategories = ref.watch(serviceCategoriesProvider);
    final variants = ref.watch(serviceVariantsProvider);
    final clients = ref.watch(clientsProvider);
    final staff = ref.watch(staffForCurrentLocationProvider);

    final title = l10n.appointmentDialogTitleEdit;

    // Il campo cliente √® bloccato se l'appuntamento
    // aveva gi√† un cliente associato (clientId != null)
    final isClientLocked = widget.initial.clientId != null;

    final conflictFlags = _serviceConflictFlags();
    final eligibleIndices = <int>[];
    for (int i = 0; i < _serviceItems.length; i++) {
      if (_isWarningEligible(_serviceItems[i])) {
        eligibleIndices.add(i);
      }
    }
    final allEligibleConflict =
        eligibleIndices.isNotEmpty &&
        eligibleIndices.every((i) => conflictFlags[i]);
    final showAppointmentWarning =
        eligibleIndices.length > 1 && allEligibleConflict;
    final showServiceWarnings = !showAppointmentWarning;

    final content = ScrollConfiguration(
      behavior: const NoScrollbarBehavior(),
      child: SingleChildScrollView(
        controller: _scrollController,
        child: Form(
          key: _formKey,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const SizedBox(height: AppSpacing.formFirstRowSpacing),
              // Client selection (first)
              _ClientSelectionField(
                clientId: _clientId,
                clientName: _clientName,
                clients: clients,
                isLocked: isClientLocked,
                onClientSelected: (id, name) {
                  setState(() {
                    _clientId = id;
                    _clientName = name;
                  });
                },
                onClientRemoved: () {
                  setState(() {
                    _clientId = null;
                    _clientName = '';
                  });
                },
              ),
              const SizedBox(height: AppSpacing.formRowSpacing),
              // Date
              InkWell(
                onTap: _pickDate,
                borderRadius: BorderRadius.circular(4),
                child: InputDecorator(
                  decoration: InputDecoration(
                    labelText: l10n.formDate,
                    contentPadding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 12,
                    ),
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(4),
                    ),
                    isDense: true,
                  ),
                  child: Text(DtFmt.shortDate(context, _date)),
                ),
              ),
              const SizedBox(height: AppSpacing.formRowSpacing),
              // Services list
              ..._buildServiceItems(
                services: services,
                categories: serviceCategories,
                variants: variants,
                allStaff: staff,
                formFactor: formFactor,
                conflictFlags: conflictFlags,
                showServiceWarnings: showServiceWarnings,
                serviceWarningMessage:
                    l10n.bookingUnavailableTimeWarningService,
              ),
              const SizedBox(height: AppSpacing.formRowSpacing),
              // Notes field
              TextFormField(
                controller: _notesController,
                decoration: InputDecoration(
                  labelText: l10n.formNotes,
                  alignLabelWithHint: true,
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(4),
                  ),
                ),
                maxLines: 3,
                minLines: 2,
              ),
              const SizedBox(height: AppSpacing.formRowSpacing),
            ],
          ),
        ),
      ),
    );

    final actions = [
      AppDangerButton(
        onPressed: () async {
          final deleteTitle = _bookingHasSingleAppointment
              ? l10n.deleteAppointmentConfirmTitle
              : l10n.deleteBookingConfirmTitle;
          final deleteMessage = _bookingHasSingleAppointment
              ? l10n.deleteAppointmentConfirmMessage
              : l10n.deleteBookingConfirmMessage;
          final confirmed = await showDialog<bool>(
            context: context,
            builder: (_) => AlertDialog(
              title: Text(deleteTitle),
              content: Text(deleteMessage),
              actions: [
                AppOutlinedActionButton(
                  onPressed: () => Navigator.pop(context, false),
                  child: Text(l10n.actionCancel),
                ),
                AppDangerButton(
                  onPressed: () => Navigator.pop(context, true),
                  child: Text(l10n.actionDelete),
                ),
              ],
            ),
          );
          if (confirmed == true) {
            ref
                .read(bookingsProvider.notifier)
                .deleteBooking(widget.initial.bookingId);
            if (context.mounted) Navigator.of(context).pop();
          }
        },
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionDelete),
      ),
      AppOutlinedActionButton(
        onPressed: _handleClose,
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppFilledButton(
        onPressed: _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionSave),
      ),
    ];

    if (isDialog) {
      return PopScope(
        canPop: false,
        onPopInvokedWithResult: (didPop, _) async {
          if (didPop) return;
          await _handleClose();
        },
        child: Dialog(
          insetPadding: const EdgeInsets.symmetric(
            horizontal: 32,
            vertical: 24,
          ),
          child: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text(title, style: Theme.of(context).textTheme.headlineSmall),
                  const SizedBox(height: 8),
                  Flexible(child: content),
                  const SizedBox(height: AppSpacing.formToActionsSpacing),
                  Padding(
                    padding: const EdgeInsets.only(
                      bottom: AppSpacing.formFirstRowSpacing,
                    ),
                    child: _warningBanner(
                      8,
                      showAppointmentWarning,
                      l10n.bookingUnavailableTimeWarningAppointment,
                    ),
                  ),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      for (int i = 0; i < actions.length; i++) ...[
                        if (i > 0) const SizedBox(width: 8),
                        SizedBox(
                          width: AppButtonStyles.dialogButtonWidth,
                          child: actions[i],
                        ),
                      ],
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      );
    }
    const horizontalPadding = 20.0;
    final isKeyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
    return PopScope(
      canPop: false,
      onPopInvokedWithResult: (didPop, _) async {
        if (didPop) return;
        await _handleClose();
      },
      child: SafeArea(
        top: false,
        left: false,
        right: false,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          mainAxisSize: MainAxisSize.min,
          children: [
            Padding(
              padding: EdgeInsets.fromLTRB(
                horizontalPadding,
                0,
                horizontalPadding,
                12,
              ),
              child: Text(title, style: Theme.of(context).textTheme.titleLarge),
            ),
            Expanded(
              child: Padding(
                padding: EdgeInsets.symmetric(horizontal: horizontalPadding),
                child: content,
              ),
            ),
            _warningBanner(
              horizontalPadding,
              showAppointmentWarning,
              l10n.bookingUnavailableTimeWarningAppointment,
            ),
            if (!isKeyboardOpen) ...[
              const AppBottomSheetDivider(),
              Padding(
                padding: EdgeInsets.fromLTRB(
                  horizontalPadding,
                  AppSpacing.formFirstRowSpacing,
                  horizontalPadding,
                  0,
                ),
                child: Row(
                  mainAxisAlignment: actions.length == 3
                      ? MainAxisAlignment.center
                      : MainAxisAlignment.end,
                  children: [
                    for (int i = 0; i < actions.length; i++) ...[
                      if (i > 0) const SizedBox(width: 8),
                      SizedBox(
                        width: AppButtonStyles.dialogButtonWidth,
                        child: actions[i],
                      ),
                    ],
                  ],
                ),
              ),
            ],
            SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
          ],
        ),
      ),
    );
  }

  Future<void> _pickDate() async {
    final picked = await showDialog<DateTime>(
      context: context,
      builder: (context) {
        return Dialog(
          child: CalendarDatePicker(
            initialDate: _date,
            firstDate: DateTime.now().subtract(const Duration(days: 365)),
            lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
            onDateChanged: (value) => Navigator.of(context).pop(value),
          ),
        );
      },
    );
    if (picked != null) {
      setState(() => _date = DateUtils.dateOnly(picked));
    }
  }

  void _scrollFormToBottom() {
    if (!_scrollController.hasClients) return;
    _scrollController.animateTo(
      _scrollController.position.maxScrollExtent,
      duration: const Duration(milliseconds: 250),
      curve: Curves.easeOut,
    );
  }

  List<Widget> _buildServiceItems({
    required List<dynamic> services,
    required List<dynamic> categories,
    required List<dynamic> variants,
    required List<dynamic> allStaff,
    required AppFormFactor formFactor,
    required List<bool> conflictFlags,
    required bool showServiceWarnings,
    required String serviceWarningMessage,
  }) {
    final widgets = <Widget>[];

    // Conta servizi effettivamente selezionati
    final selectedCount = _serviceItems
        .where((s) => s.serviceId != null)
        .length;

    for (int i = 0; i < _serviceItems.length; i++) {
      final item = _serviceItems[i];
      final TimeOfDay? suggestedStartTime = i > 0
          ? _resolveServiceEndTime(_serviceItems[i - 1], variants.cast())
          : null;
      final variant = item.serviceId != null
          ? variants.cast<ServiceVariant?>().firstWhere(
              (v) => v?.serviceId == item.serviceId,
              orElse: () => null,
            )
          : null;
      final defaultProcessing = variant?.processingTime ?? 0;
      final defaultBlocked = variant?.blockedTime ?? 0;
      final defaultExtraType = defaultBlocked > 0
          ? ExtraMinutesType.blocked
          : (defaultProcessing > 0 ? ExtraMinutesType.processing : null);
      final hasBlockedExtra = item.blockedExtraMinutes > 0;
      final hasProcessingExtra = item.processingExtraMinutes > 0;
      final canAddDefaultExtra =
          defaultExtraType == ExtraMinutesType.blocked
              ? !hasBlockedExtra
              : (defaultExtraType == ExtraMinutesType.processing
                    ? !hasProcessingExtra
                    : false);
      final showWarning =
          showServiceWarnings &&
          _isWarningEligible(item) &&
          i < conflictFlags.length &&
          conflictFlags[i];

      // Get eligible staff for this service
      final eligibleStaffIds = item.serviceId != null
          ? ref.watch(eligibleStaffForServiceProvider(item.serviceId!))
          : <int>[];
      final isStaffIneligible =
          item.serviceId != null &&
          item.staffId != null &&
          !eligibleStaffIds.contains(item.staffId);

      final isFirst = i == 0;
      final isLast = i == _serviceItems.length - 1;
      widgets.add(
        Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            if (isFirst) ...[
              Row(
                children: [
                  Text(
                    selectedCount > 0
                        ? context.l10n.servicesSelectedCount(selectedCount)
                        : context.l10n.formServices,
                    style: const TextStyle(fontWeight: FontWeight.w600),
                  ),
                ],
              ),
              const SizedBox(height: 8),
            ],
            Padding(
              padding: const EdgeInsets.only(bottom: 12),
              child: ServiceItemCard(
                index: i,
                item: item,
                services: services.cast(),
                categories: categories.cast(),
                variants: variants.cast(),
                eligibleStaff: eligibleStaffIds,
                allStaff: allStaff.cast(),
                formFactor: formFactor,
                canRemove: _serviceItems.length > 1,
                // Obbligatorio solo se non ci sono altri servizi selezionati
                isServiceRequired: selectedCount == 0,
                onChanged: (updated) => _updateServiceItem(i, updated),
                onRemove: () => _removeServiceItem(i),
                onStartTimeChanged: (time) => _updateServiceStartTime(i, time),
                onEndTimeChanged: (time) => _updateServiceEndTime(i, time),
                onDurationChanged: (duration) =>
                    _updateServiceDuration(i, duration),
                suggestedStartTime: suggestedStartTime,
                autoOpenServicePicker: _autoOpenServicePickerIndex == i,
                onServicePickerAutoOpened: _autoOpenServicePickerIndex == i
                    ? () => _onServicePickerAutoOpenedForIndex(i)
                    : null,
                onServicePickerAutoCompleted: _scrollFormToBottom,
                onAutoOpenStaffPickerCompleted: _scrollFormToBottom,
                availabilityWarningMessage: showWarning
                    ? serviceWarningMessage
                    : null,
                staffEligibilityWarningMessage: isStaffIneligible
                    ? context.l10n.bookingStaffNotEligibleWarning
                    : null,
              ),
            ),
            if (canAddDefaultExtra) ...[
              if (isLast && item.serviceId != null)
                Row(
                  children: [
                    AppOutlinedActionButton(
                      onPressed: () {
                        setState(() {
                          _serviceItems[i] = defaultExtraType ==
                                  ExtraMinutesType.blocked
                              ? _serviceItems[i].copyWith(
                                  blockedExtraMinutes: defaultBlocked,
                                )
                              : _serviceItems[i].copyWith(
                                  processingExtraMinutes: defaultProcessing,
                                );
                          _recalculateTimesFrom(i + 1, variants.cast());
                        });
                      },
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.add, size: 18),
                          const SizedBox(width: 8),
                          Text(context.l10n.additionalTimeSwitch),
                        ],
                      ),
                    ),
                    const Spacer(),
                    AppOutlinedActionButton(
                      onPressed: _addService,
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.add, size: 18),
                          const SizedBox(width: 8),
                          Text(context.l10n.addService),
                        ],
                      ),
                    ),
                  ],
                )
              else
                Align(
                  alignment: Alignment.centerRight,
                  child: AppOutlinedActionButton(
                    onPressed: () {
                      setState(() {
                        _serviceItems[i] = defaultExtraType ==
                                ExtraMinutesType.blocked
                            ? _serviceItems[i].copyWith(
                                blockedExtraMinutes: defaultBlocked,
                              )
                            : _serviceItems[i].copyWith(
                                processingExtraMinutes: defaultProcessing,
                              );
                        _recalculateTimesFrom(i + 1, variants.cast());
                      });
                    },
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const Icon(Icons.add, size: 18),
                        const SizedBox(width: 8),
                        Text(context.l10n.additionalTimeSwitch),
                      ],
                    ),
                  ),
                ),
              const SizedBox(height: 24),
            ],
            if (hasBlockedExtra) ...[
              ExtraTimeCard(
                title: context.l10n.fieldBlockedTimeLabel,
                startTime: _baseEndTime(item, variants.cast()),
                durationMinutes: item.blockedExtraMinutes,
                formFactor: formFactor,
                onStartTimeChanged: (_) {},
                onDurationChanged: (duration) {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      blockedExtraMinutes: duration,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                  });
                },
                onRemove: () {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      blockedExtraMinutes: 0,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                  });
                },
              ),
              const SizedBox(height: 8),
            ],
            if (hasProcessingExtra) ...[
              ExtraTimeCard(
                title: context.l10n.fieldProcessingTimeLabel,
                startTime: _addMinutes(
                  _baseEndTime(item, variants.cast()),
                  item.blockedExtraMinutes,
                ),
                durationMinutes: item.processingExtraMinutes,
                formFactor: formFactor,
                onStartTimeChanged: (_) {},
                onDurationChanged: (duration) {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      processingExtraMinutes: duration,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                  });
                },
                onRemove: () {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      processingExtraMinutes: 0,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                  });
                },
              ),
              const SizedBox(height: 8),
            ],
            if (isLast && item.serviceId != null &&
                !canAddDefaultExtra) ...[
              Align(
                alignment: Alignment.centerRight,
                child: AppOutlinedActionButton(
                  onPressed: _addService,
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      const Icon(Icons.add, size: 18),
                      const SizedBox(width: 8),
                      Text(context.l10n.addService),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 8),
            ],
          ],
        ),
      );
    }

    if (_serviceItems.isEmpty) {
      widgets.add(
        Container(
          padding: const EdgeInsets.all(24),
          decoration: BoxDecoration(
            border: Border.all(color: Theme.of(context).colorScheme.outline),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Center(
            child: Text(
              context.l10n.noServicesAdded,
              style: TextStyle(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ),
        ),
      );
    }

    return widgets;
  }

  Widget _warningBanner(
    double horizontalPadding,
    bool hasConflicts,
    String message,
  ) {
    if (!hasConflicts || _warningDismissed) return const SizedBox.shrink();
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.amber.withOpacity(0.18),
        borderRadius: BorderRadius.circular(8),
      ),
      padding: EdgeInsets.fromLTRB(
        horizontalPadding,
        12,
        horizontalPadding,
        12,
      ),
      child: Row(
        children: [
          const Icon(
            Icons.warning_amber_rounded,
            color: Colors.amber,
            size: 20,
          ),
          const SizedBox(width: 10),
          Expanded(
            child: Text(
              message,
              style: const TextStyle(
                color: Color(0xFF8A4D00),
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          IconButton(
            icon: const Icon(Icons.close, size: 18),
            color: const Color(0xFF8A4D00),
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints.tightFor(width: 32, height: 32),
            onPressed: () {
              setState(() => _warningDismissed = true);
            },
          ),
        ],
      ),
    );
  }

  bool _isWarningEligible(ServiceItemData item) {
    return item.serviceId != null && item.staffId != null;
  }

  List<bool> _serviceConflictFlags() {
    final layout = ref.watch(layoutConfigProvider);
    final Map<int, Set<int>> cache = {};
    final flags = <bool>[];

    for (final item in _serviceItems) {
      final staffId = item.staffId;
      if (staffId == null || item.serviceId == null) {
        flags.add(false);
        continue;
      }

      final available = cache.putIfAbsent(
        staffId,
        () => ref.watch(staffSlotAvailabilityProvider(staffId)),
      );

      if (available.isEmpty) {
        flags.add(true);
        continue;
      }

      final startMinutes = item.startTime.hour * 60 + item.startTime.minute;
      final endMinutes = startMinutes + item.durationMinutes;
      final startSlot = startMinutes ~/ layout.minutesPerSlot;
      final endSlot = (endMinutes / layout.minutesPerSlot).ceil();

      var hasConflict = false;
      for (int slot = startSlot; slot < endSlot; slot++) {
        if (!available.contains(slot)) {
          hasConflict = true;
          break;
        }
      }
      flags.add(hasConflict);
    }
    return flags;
  }

  void _addService() {
    final variants = ref.read(serviceVariantsProvider);
    // Calcola l'orario di inizio per il nuovo servizio
    TimeOfDay nextStart;
    if (_serviceItems.isEmpty) {
      // Caso raro: usa l'orario dell'appuntamento originale
      nextStart = TimeOfDay.fromDateTime(widget.initial.startTime);
    } else {
      // Prendi l'ultimo servizio e calcola il suo orario di fine
      final lastItem = _serviceItems.last;
      nextStart = _resolveServiceEndTime(lastItem, variants);
    }

    // Smart staff selection: usa lo staff dell'ultimo servizio aggiunto
    int? smartStaffId = _serviceItems.isNotEmpty
        ? _serviceItems.last.staffId
        : widget.initial.staffId;

    final newIndex = _serviceItems.length;
    setState(() {
      _serviceItems.add(
        ServiceItemData(
          key: _nextItemKey(),
          startTime: nextStart,
          staffId: smartStaffId,
        ),
      );
      _autoOpenServicePickerIndex = newIndex;
    });
  }

  void _onServicePickerAutoOpenedForIndex(int index) {
    if (_autoOpenServicePickerIndex != index) return;
    setState(() {
      _autoOpenServicePickerIndex = null;
    });
  }

  void _removeServiceItem(int index) {
    if (_serviceItems.length <= 1) return;

    final variants = ref.read(serviceVariantsProvider);

    setState(() {
      _serviceItems.removeAt(index);

      // Ricalcola gli orari per i servizi successivi
      _recalculateTimesFrom(index, variants);
    });
  }

  void _updateServiceItem(int index, ServiceItemData updated) {
    final variants = ref.read(serviceVariantsProvider);

    setState(() {
      _serviceItems[index] = updated;

      // Se cambia il servizio, potremmo dover aggiornare lo staff
      // e ricalcolare gli orari successivi
      _recalculateTimesFrom(index + 1, variants);

      // Se lo staff √® ancora null, seleziona automaticamente un eligible
      if (updated.serviceId != null && updated.staffId == null) {
        final newStaffId = _findBestStaff(updated.serviceId!);
        _serviceItems[index] = updated.copyWith(staffId: newStaffId);
      }
    });
  }

  void _updateServiceStartTime(int index, TimeOfDay newTime) {
    final variants = ref.read(serviceVariantsProvider);

    setState(() {
      final updated = _serviceItems[index].copyWith(startTime: newTime);
      _serviceItems[index] = _applyAutoExtraStart(updated, variants);

      // Ricalcola gli orari per i servizi successivi
      _recalculateTimesFrom(index + 1, variants);
    });
  }

  void _updateServiceEndTime(int index, TimeOfDay newEndTime) {
    setState(() {
      final item = _serviceItems[index];

      // Calcola la nuova durata basata sulla differenza tra end e start
      final startMinutes = item.startTime.hour * 60 + item.startTime.minute;
      final endMinutes = newEndTime.hour * 60 + newEndTime.minute;
      var newDuration = endMinutes - startMinutes;

      // Se la durata √® negativa o zero, imposta un minimo di 15 minuti
      if (newDuration <= 0) {
        newDuration = 15;
      }

      _serviceItems[index] = item.copyWith(durationMinutes: newDuration);

      // Ricalcola gli orari per i servizi successivi
      final variants = ref.read(serviceVariantsProvider);
      _serviceItems[index] = _applyAutoExtraStart(
        _serviceItems[index],
        variants,
      );
      _recalculateTimesFrom(index + 1, variants);
    });
  }

  void _updateServiceDuration(int index, int newDuration) {
    setState(() {
      _serviceItems[index] = _serviceItems[index].copyWith(
        durationMinutes: newDuration,
      );

      // Ricalcola gli orari per i servizi successivi
      final variants = ref.read(serviceVariantsProvider);
      _serviceItems[index] = _applyAutoExtraStart(
        _serviceItems[index],
        variants,
      );
      _recalculateTimesFrom(index + 1, variants);
    });
  }

  void _recalculateTimesFrom(int fromIndex, List<ServiceVariant> variants) {
    if (fromIndex <= 0 || fromIndex >= _serviceItems.length) return;

    for (int i = fromIndex; i < _serviceItems.length; i++) {
      final prevItem = _serviceItems[i - 1];
      final prevEnd = _resolveServiceEndTime(prevItem, variants);
      final updated = _serviceItems[i].copyWith(startTime: prevEnd);
      _serviceItems[i] = _applyAutoExtraStart(updated, variants);
    }
  }

  TimeOfDay _resolveServiceEndTime(
    ServiceItemData item,
    List<ServiceVariant> variants,
  ) {
    final baseEnd = _baseEndTime(item, variants);
    if (item.blockedExtraMinutes <= 0) {
      return baseEnd;
    }
    return _addMinutes(baseEnd, item.blockedExtraMinutes);
  }

  ServiceItemData _applyAutoExtraStart(
    ServiceItemData item,
    List<ServiceVariant> variants,
  ) {
    return item;
  }

  TimeOfDay _baseEndTime(ServiceItemData item, List<ServiceVariant> variants) {
    final variant = _variantForItem(item, variants);
    final baseDuration = item.durationMinutes > 0
        ? item.durationMinutes
        : (variant?.durationMinutes ?? 30);
    return item.getEndTime(baseDuration);
  }

  ServiceVariant? _variantForItem(
    ServiceItemData item,
    List<ServiceVariant> variants,
  ) {
    if (item.serviceVariantId != null) {
      for (final v in variants) {
        if (v.id == item.serviceVariantId) return v;
      }
    }
    if (item.serviceId != null) {
      for (final v in variants) {
        if (v.serviceId == item.serviceId) return v;
      }
    }
    return null;
  }

  TimeOfDay _addMinutes(TimeOfDay time, int minutes) {
    final totalMinutes = time.hour * 60 + time.minute + minutes;
    return TimeOfDay(
      hour: (totalMinutes ~/ 60) % 24,
      minute: totalMinutes % 60,
    );
  }

  /// Trova lo staff migliore per un servizio:
  /// 1. Primo staff eligible disponibile
  /// 2. null per selezione manuale
  int? _findBestStaff(int serviceId) {
    final eligibleIds = ref.read(eligibleStaffForServiceProvider(serviceId));
    if (eligibleIds.isEmpty) return null;
    return eligibleIds.first;
  }

  void _onSave() async {
    final l10n = context.l10n;
    if (!_formKey.currentState!.validate()) return;

    // Verifica che ci sia almeno un servizio selezionato
    final validItems = _serviceItems
        .where((item) => item.serviceId != null && item.staffId != null)
        .toList();

    if (validItems.isEmpty) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text(l10n.validationRequired)));
      return;
    }

    final variants = ref.read(serviceVariantsProvider);
    final services = ref.read(servicesProvider);

    // Client info (pu√≤ essere null se nessun cliente √® associato)
    final int? clientId = _clientId;
    final String clientName = _clientName.trim();
    final String? notes = _notesController.text.trim().isEmpty
        ? null
        : _notesController.text.trim();

    // Modifica appuntamento esistente
    final bookingId = widget.initial.bookingId;

    // Ottieni gli appuntamenti esistenti per questa prenotazione
    final existingAppointments = ref
        .read(appointmentsProvider.notifier)
        .getByBookingId(bookingId);

    // Verifica se il cliente √® stato aggiunto (era null e ora non lo √®)
    final initialClientId = widget.initial.clientId;
    final clientWasAdded = initialClientId == null && clientId != null;

    // Se il cliente √® stato aggiunto e ci sono altri appuntamenti
    if (clientWasAdded && existingAppointments.length > 1 && mounted) {
      final confirmed = await showDialog<bool>(
        context: context,
        builder: (_) => AlertDialog(
          title: Text(l10n.applyClientToAllAppointmentsTitle),
          content: Text(
            l10n.applyClientToAllAppointmentsMessage(
              existingAppointments.length - 1,
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context, false),
              child: Text(l10n.actionCancel),
            ),
            TextButton(
              onPressed: () => Navigator.pop(context, true),
              child: Text(l10n.actionConfirm),
            ),
          ],
        ),
      );

      if (confirmed == true) {
        // Aggiorna il cliente su tutti gli appuntamenti della prenotazione
        ref
            .read(appointmentsProvider.notifier)
            .updateClientForBooking(
              bookingId: bookingId,
              clientId: clientId,
              clientName: clientName,
            );
      } else {
        // Utente ha annullato, non salvare
        return;
      }
    }

    // Aggiorna tutti i servizi
    final existingIds = existingAppointments.map((a) => a.id).toSet();
    final processedIds = <int>{};
    Appointment? scrollTarget;

    for (int i = 0; i < validItems.length; i++) {
      final item = validItems[i];
      final selectedVariant = variants.firstWhere(
        (v) => v.serviceId == item.serviceId,
        orElse: () => variants.first,
      );
      final service = services.firstWhere((s) => s.id == item.serviceId);
      final blockedExtraMinutes = item.blockedExtraMinutes;
      final processingExtraMinutes = item.processingExtraMinutes;
      final extraMinutesType = blockedExtraMinutes > 0
          ? ExtraMinutesType.blocked
          : (processingExtraMinutes > 0
                ? ExtraMinutesType.processing
                : null);
      final extraMinutes = extraMinutesType == ExtraMinutesType.blocked
          ? blockedExtraMinutes
          : (extraMinutesType == ExtraMinutesType.processing
                ? processingExtraMinutes
                : 0);
      final effectivePrice = selectedVariant.isFree
          ? null
          : selectedVariant.price;

      final start = DateTime(
        _date.year,
        _date.month,
        _date.day,
        item.startTime.hour,
        item.startTime.minute,
      );

      final baseDuration = item.durationMinutes > 0
          ? item.durationMinutes
          : selectedVariant.durationMinutes;
      final duration =
          baseDuration + (blockedExtraMinutes > 0 ? blockedExtraMinutes : 0);
      final end = start.add(Duration(minutes: duration));

      if (i < existingAppointments.length) {
        // Aggiorna appuntamento esistente
        final existing = existingAppointments[i];
        processedIds.add(existing.id);

        final updated = existing.copyWith(
          staffId: item.staffId!,
          serviceId: service.id,
          serviceVariantId: selectedVariant.id,
          clientId: clientId,
          clientName: clientName,
          serviceName: service.name,
          startTime: start,
          endTime: end,
          price: effectivePrice,
          extraMinutes: extraMinutes,
          extraMinutesType: extraMinutesType,
          extraBlockedMinutes: blockedExtraMinutes,
          extraProcessingMinutes: processingExtraMinutes,
        );
        ref.read(appointmentsProvider.notifier).updateAppointment(updated);
        scrollTarget ??= updated;
      } else {
        // Crea nuovo appuntamento (aggiunto durante la modifica)
        final created = ref
            .read(appointmentsProvider.notifier)
            .addAppointment(
              bookingId: bookingId,
              staffId: item.staffId!,
              serviceId: service.id,
              serviceVariantId: selectedVariant.id,
              clientId: clientId,
              clientName: clientName,
              serviceName: service.name,
              start: start,
              end: end,
              price: effectivePrice,
              extraMinutes: extraMinutes,
              extraMinutesType: extraMinutesType,
              extraBlockedMinutes: blockedExtraMinutes,
              extraProcessingMinutes: processingExtraMinutes,
            );
        scrollTarget ??= created;
      }
    }

    // Elimina appuntamenti rimossi
    for (final id in existingIds.difference(processedIds)) {
      ref.read(appointmentsProvider.notifier).deleteAppointment(id);
    }

    // Aggiorna le note nella booking associata
    ref.read(bookingsProvider.notifier).setNotes(bookingId, notes);

    // Rimuovi la booking se vuota
    ref.read(bookingsProvider.notifier).removeIfEmpty(bookingId);

    if (scrollTarget != null) {
      ref.read(agendaScrollRequestProvider.notifier).request(scrollTarget);
    }
    if (mounted) {
      Navigator.of(context).pop();
    }
  }
}

class _ClientItem {
  final int id;
  final String name;
  const _ClientItem(this.id, this.name);
}

/// Widget per la selezione del cliente con link cliccabile e hint
class _ClientSelectionField extends ConsumerWidget {
  const _ClientSelectionField({
    required this.clientId,
    required this.clientName,
    required this.clients,
    required this.onClientSelected,
    required this.onClientRemoved,
    this.isLocked = false,
  });

  final int? clientId;
  final String clientName;
  final List<Client> clients;
  final void Function(int? id, String name) onClientSelected;
  final VoidCallback onClientRemoved;
  final bool isLocked;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final hasClient = clientId != null || clientName.isNotEmpty;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          l10n.formClient,
          style: const TextStyle(fontWeight: FontWeight.w600),
        ),
        const SizedBox(height: 6),
        if (hasClient)
          _SelectedClientTile(
            clientName: clientName,
            onTap: isLocked ? null : () => _showClientPicker(context, ref),
            onRemove: isLocked ? null : onClientRemoved,
          )
        else
          InkWell(
            onTap: isLocked ? null : () => _showClientPicker(context, ref),
            borderRadius: BorderRadius.circular(8),
            child: Container(
              width: double.infinity,
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 14),
              decoration: BoxDecoration(
                border: Border.all(
                  color: isLocked
                      ? theme.colorScheme.outline.withOpacity(0.5)
                      : theme.colorScheme.outline,
                ),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.person_add_outlined,
                    size: 20,
                    color: isLocked
                        ? theme.colorScheme.onSurfaceVariant
                        : theme.colorScheme.primary,
                  ),
                  const SizedBox(width: 8),
                  Text(
                    l10n.addClientToAppointment,
                    style: TextStyle(
                      color: isLocked
                          ? theme.colorScheme.onSurfaceVariant
                          : theme.colorScheme.primary,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            ),
          ),
        const SizedBox(height: 6),
        Text(
          isLocked ? l10n.clientLockedHint : l10n.clientOptionalHint,
          style: theme.textTheme.bodySmall?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
      ],
    );
  }

  Future<void> _showClientPicker(BuildContext context, WidgetRef ref) async {
    while (true) {
      final result = await AppBottomSheet.show<_ClientItem?>(
        context: context,
        useRootNavigator: true,
        padding: EdgeInsets.zero,
        heightFactor: AppBottomSheet.defaultHeightFactor,
        builder: (ctx) =>
            _ClientPickerSheet(clients: clients, selectedClientId: clientId),
      );
      if (result == null) {
        // Sheet dismissed without selection, do nothing
        return;
      }
      if (result.id == -2) {
        // "Create new client" was selected
        // result.name contains the search query to pre-populate the form
        if (context.mounted) {
          Client? initialClient;
          if (result.name.isNotEmpty) {
            // Split the search query into first name and last name
            final nameParts = Client.splitFullName(result.name);
            initialClient = Client(
              id: 0,
              businessId: 0,
              firstName: nameParts.firstName,
              lastName: nameParts.lastName,
              createdAt: DateTime.now(),
            );
          }
          final newClient = await showClientEditDialog(
            context,
            ref,
            client: initialClient,
          );
          if (newClient != null) {
            // Client saved, select it and return to appointment form
            onClientSelected(newClient.id, newClient.name);
            return;
          }
          // Client creation cancelled, loop back to show picker again
          continue;
        }
        return;
      } else if (result.id == -1) {
        // "No client for appointment" was selected
        onClientRemoved();
        return;
      } else {
        onClientSelected(result.id, result.name);
        return;
      }
    }
  }
}

/// Tile che mostra il cliente selezionato con opzione per rimuoverlo
class _SelectedClientTile extends StatelessWidget {
  const _SelectedClientTile({
    required this.clientName,
    this.onTap,
    this.onRemove,
  });

  final String clientName;
  final VoidCallback? onTap;
  final VoidCallback? onRemove;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isLocked = onTap == null && onRemove == null;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
        decoration: BoxDecoration(
          border: Border.all(
            color: isLocked
                ? theme.colorScheme.outline.withOpacity(0.5)
                : theme.colorScheme.outline,
          ),
          borderRadius: BorderRadius.circular(8),
          color: isLocked ? theme.colorScheme.surfaceContainerLow : null,
        ),
        child: Row(
          children: [
            StaffCircleAvatar(
              height: 32,
              color: theme.colorScheme.primary,
              isHighlighted: false,
              initials: clientName.isNotEmpty
                  ? initialsFromName(clientName, maxChars: 2)
                  : '?',
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
                clientName,
                style: TextStyle(
                  fontWeight: FontWeight.w500,
                  color: isLocked ? theme.colorScheme.onSurfaceVariant : null,
                ),
              ),
            ),
            if (onRemove != null)
              IconButton(
                icon: Icon(
                  Icons.close,
                  size: 20,
                  color: theme.colorScheme.error,
                ),
                onPressed: onRemove,
                tooltip: context.l10n.removeClient,
                padding: EdgeInsets.zero,
                constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
              )
            else if (isLocked)
              Icon(
                Icons.lock_outline,
                size: 18,
                color: theme.colorScheme.onSurfaceVariant.withOpacity(0.6),
              ),
          ],
        ),
      ),
    );
  }
}

/// Bottom sheet per la selezione del cliente
class _ClientPickerSheet extends ConsumerStatefulWidget {
  const _ClientPickerSheet({required this.clients, this.selectedClientId});

  final List<Client> clients;
  final int? selectedClientId;

  @override
  ConsumerState<_ClientPickerSheet> createState() => _ClientPickerSheetState();
}

class _ClientPickerSheetState extends ConsumerState<_ClientPickerSheet> {
  final _searchController = TextEditingController();
  String _searchQuery = '';

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  List<Client> get _filteredClients {
    // Use live clients from provider to get updates after creation
    final clients = ref.watch(clientsProvider);
    if (_searchQuery.isEmpty) return clients;
    final q = _searchQuery.toLowerCase();
    return clients.where((c) => c.name.toLowerCase().contains(q)).toList();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return SafeArea(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header
          Padding(
            padding: const EdgeInsets.fromLTRB(16, 16, 16, 12),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  l10n.selectClientTitle,
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.w600,
                  ),
                ),
                const SizedBox(height: AppSpacing.formFirstRowSpacing),
                // Search field
                TextField(
                  controller: _searchController,
                  decoration: InputDecoration(
                    hintText: l10n.searchClientPlaceholder,
                    prefixIcon: const Icon(Icons.search, size: 20),
                    border: const OutlineInputBorder(),
                    isDense: true,
                    contentPadding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 10,
                    ),
                  ),
                  onChanged: (value) {
                    setState(() => _searchQuery = value.trim());
                  },
                ),
              ],
            ),
          ),
          const AppBottomSheetDivider(),
          // Quick actions: Create new client / No client
          ListTile(
            leading: StaffCircleAvatar(
              height: 32,
              color: theme.colorScheme.onSurfaceVariant,
              isHighlighted: false,
              initials: '',
              child: Icon(
                Icons.person_add_outlined,
                color: theme.colorScheme.onSurface,
                size: 18,
              ),
            ),
            title: Text(l10n.createNewClient),
            onTap: () {
              // Use special marker with id = -2 to indicate "create new client"
              // Pass search query in name field to pre-populate the form
              Navigator.of(context).pop(_ClientItem(-2, _searchQuery));
            },
          ),
          ListTile(
            leading: StaffCircleAvatar(
              height: 32,
              color: theme.colorScheme.onSurfaceVariant,
              isHighlighted: false,
              initials: '',
              child: Icon(
                Icons.person_off_outlined,
                color: theme.colorScheme.onSurface,
                size: 18,
              ),
            ),
            title: Text(l10n.noClientForAppointment),
            onTap: () {
              // Use special marker with id = -1 to indicate "no client"
              Navigator.of(context).pop(const _ClientItem(-1, ''));
            },
          ),
          const AppBottomSheetDivider(),
          // Client list
          Expanded(
            child: _filteredClients.isEmpty
                ? Center(
                    child: Text(
                      l10n.clientsEmpty,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                  )
                : ListView.builder(
                    padding: const EdgeInsets.only(bottom: 8),
                    itemCount: _filteredClients.length,
                    itemBuilder: (context, index) {
                      final client = _filteredClients[index];
                      final isSelected = client.id == widget.selectedClientId;
                      return ListTile(
                        leading: StaffCircleAvatar(
                          height: 32,
                          color: theme.colorScheme.primary,
                          isHighlighted: isSelected,
                          initials: client.name.isNotEmpty
                              ? initialsFromName(client.name, maxChars: 2)
                              : '?',
                        ),
                        title: Text(client.name),
                        subtitle: client.phone != null
                            ? Text(
                                client.phone!,
                                style: theme.textTheme.bodySmall,
                              )
                            : null,
                        trailing: isSelected
                            ? Icon(
                                Icons.check_circle,
                                color: theme.colorScheme.primary,
                              )
                            : null,
                        onTap: () {
                          Navigator.of(
                            context,
                          ).pop(_ClientItem(client.id, client.name));
                        },
                      );
                    },
                  ),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/widgets/service_item_card.dart ---
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../core/l10n/date_time_formats.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';
import '../../../../core/models/service_variant.dart';
import '../../../../core/models/staff.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../domain/config/layout_config.dart';
import '../../domain/service_item_data.dart';
import 'service_picker_field.dart';

String _formatExtraDuration(int minutes) {
  if (minutes < 60) {
    return '$minutes min';
  }
  final hours = minutes ~/ 60;
  final mins = minutes % 60;
  if (mins == 0) {
    return '$hours h';
  }
  return '$hours h $mins min';
}

/// Card per visualizzare e modificare un singolo servizio nella prenotazione.
class ServiceItemCard extends ConsumerStatefulWidget {
  const ServiceItemCard({
    super.key,
    required this.item,
    required this.index,
    required this.services,
    required this.categories,
    required this.variants,
    required this.eligibleStaff,
    required this.allStaff,
    required this.formFactor,
    required this.onChanged,
    required this.onRemove,
    required this.onStartTimeChanged,
    required this.onEndTimeChanged,
    required this.onDurationChanged,
    this.suggestedStartTime,
    this.canRemove = true,
    this.isServiceRequired = true,
    this.autoOpenServicePicker = false,
    this.onServicePickerAutoOpened,
    this.onServicePickerAutoCompleted,
    this.onAutoOpenStaffPickerCompleted,
    this.availabilityWarningMessage,
    this.staffEligibilityWarningMessage,
  });

  final ServiceItemData item;
  final int index;
  final List<Service> services;
  final List<ServiceCategory> categories;
  final List<ServiceVariant> variants;
  final List<int> eligibleStaff; // Staff IDs abilitati per il servizio corrente
  final List<Staff> allStaff;
  final AppFormFactor formFactor;
  final ValueChanged<ServiceItemData> onChanged;
  final VoidCallback onRemove;
  final ValueChanged<TimeOfDay> onStartTimeChanged;
  final ValueChanged<TimeOfDay> onEndTimeChanged;
  final ValueChanged<int> onDurationChanged;
  final TimeOfDay? suggestedStartTime;
  final bool canRemove;

  /// Se true, la selezione del servizio √® obbligatoria (mostra errore di validazione).
  final bool isServiceRequired;
  final bool autoOpenServicePicker;
  final VoidCallback? onServicePickerAutoOpened;
  final VoidCallback? onServicePickerAutoCompleted;
  final VoidCallback? onAutoOpenStaffPickerCompleted;
  final String? availabilityWarningMessage;
  final String? staffEligibilityWarningMessage;

  @override
  ConsumerState<ServiceItemCard> createState() => _ServiceItemCardState();
}

class _ServiceItemCardState extends ConsumerState<ServiceItemCard> {
  bool _autoOpenStaffRequested = false;
  bool _shouldAutoOpenStaff = false;

  ServiceItemData get item => widget.item;
  int get index => widget.index;
  List<Service> get services => widget.services;
  List<ServiceCategory> get categories => widget.categories;
  List<ServiceVariant> get variants => widget.variants;
  List<int> get eligibleStaff => widget.eligibleStaff;
  List<Staff> get allStaff => widget.allStaff;
  AppFormFactor get formFactor => widget.formFactor;
  ValueChanged<ServiceItemData> get onChanged => widget.onChanged;
  VoidCallback get onRemove => widget.onRemove;
  ValueChanged<TimeOfDay> get onStartTimeChanged => widget.onStartTimeChanged;
  ValueChanged<TimeOfDay> get onEndTimeChanged => widget.onEndTimeChanged;
  ValueChanged<int> get onDurationChanged => widget.onDurationChanged;
  TimeOfDay? get suggestedStartTime => widget.suggestedStartTime;
  bool get canRemove => widget.canRemove;
  bool get isServiceRequired => widget.isServiceRequired;
  bool get autoOpenServicePicker => widget.autoOpenServicePicker;
  VoidCallback? get onServicePickerAutoOpened =>
      widget.onServicePickerAutoOpened;
  VoidCallback? get onServicePickerAutoCompleted =>
      widget.onServicePickerAutoCompleted;
  VoidCallback? get onAutoOpenStaffPickerCompleted =>
      widget.onAutoOpenStaffPickerCompleted;
  String? get availabilityWarningMessage => widget.availabilityWarningMessage;
  String? get staffEligibilityWarningMessage =>
      widget.staffEligibilityWarningMessage;

  @override
  void didUpdateWidget(covariant ServiceItemCard oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.item.serviceId != widget.item.serviceId) {
      _autoOpenStaffRequested = false;
      _shouldAutoOpenStaff =
          widget.item.serviceId != null && widget.item.staffId == null;
    }
    if (widget.item.staffId != null) {
      _autoOpenStaffRequested = false;
      _shouldAutoOpenStaff = false;
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    final selectedService = item.serviceId != null
        ? services.where((s) => s.id == item.serviceId).firstOrNull
        : null;

    final selectedStaff = item.staffId != null
        ? allStaff.where((s) => s.id == item.staffId).firstOrNull
        : null;

    // Staff disponibili per la selezione: sempre tutto lo staff della location
    // eligibleStaff serve solo per la selezione automatica, non per filtrare la lista
    final availableStaff = allStaff;

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: theme.colorScheme.outlineVariant),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Servizio
            _buildServiceSelector(context, l10n, selectedService),

            const SizedBox(height: 12),

            // Staff
            _buildStaffSelector(
              context,
              l10n,
              selectedStaff,
              availableStaff,
              theme,
            ),

            const SizedBox(height: 12),

            // Orario
            _buildTimeSelector(context, l10n, theme),

            if (availabilityWarningMessage != null) ...[
              const SizedBox(height: 12),
              _buildAvailabilityWarning(availabilityWarningMessage!),
            ],
            if (staffEligibilityWarningMessage != null) ...[
              const SizedBox(height: 12),
              _buildAvailabilityWarning(staffEligibilityWarningMessage!),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildServiceSelector(
    BuildContext context,
    dynamic l10n,
    Service? selectedService,
  ) {
    return ServicePickerField(
      services: services,
      categories: categories,
      formFactor: formFactor,
      value: item.serviceId,
      onChanged: (serviceId) {
        if (serviceId != null) {
          // Trova la variante di default per il servizio
          final variant = variants
              .where((v) => v.serviceId == serviceId)
              .firstOrNull;
          final duration = variant?.durationMinutes ?? 30;
          onChanged(
            item.copyWith(
              serviceId: serviceId,
              serviceVariantId: variant?.id,
              durationMinutes: duration,
              // Mantieni lo staff selezionato se presente
              staffId: item.staffId,
              blockedExtraMinutes: variant?.blockedTime ?? 0,
              processingExtraMinutes: variant?.processingTime ?? 0,
            ),
          );
        }
      },
      // Mostra icona rimuovi solo se canRemove e servizio selezionato
      onClear: canRemove && item.serviceId != null ? onRemove : null,
      validator: isServiceRequired
          ? (v) => v == null ? l10n.validationRequired : null
          : null,
      autoOpenPicker: autoOpenServicePicker,
      onAutoOpenPickerTriggered: onServicePickerAutoOpened,
      onAutoOpenPickerCompleted: onServicePickerAutoCompleted,
    );
  }

  Widget _buildAvailabilityWarning(String message) {
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.amber.withOpacity(0.18),
        borderRadius: BorderRadius.circular(8),
      ),
      padding: const EdgeInsets.all(12),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Icon(
            Icons.warning_amber_rounded,
            color: Colors.amber,
            size: 18,
          ),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              message,
              style: const TextStyle(
                color: Color(0xFF8A4D00),
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStaffSelector(
    BuildContext context,
    dynamic l10n,
    Staff? selectedStaff,
    List<Staff> availableStaff,
    ThemeData theme,
  ) {
    // Staff √® obbligatorio se c'√® un servizio selezionato in questa card
    final isStaffRequired = item.serviceId != null;

    return FormField<int>(
      initialValue: item.staffId,
      validator: isStaffRequired
          ? (v) => v == null ? l10n.validationRequired : null
          : null,
      builder: (field) {
        if (_shouldAutoOpenStaff && !_autoOpenStaffRequested) {
          _autoOpenStaffRequested = true;
          _shouldAutoOpenStaff = false;
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (!mounted) return;
            _showStaffPicker(context, availableStaff, field).whenComplete(() {
              if (!mounted) return;
              onAutoOpenStaffPickerCompleted?.call();
            });
          });
        }

        final hasError = field.hasError;
        final borderColor = hasError
            ? theme.colorScheme.error
            : theme.colorScheme.outline;

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            InkWell(
              onTap: () => _showStaffPicker(context, availableStaff, field),
              borderRadius: BorderRadius.circular(4),
              child: InputDecorator(
                decoration: InputDecoration(
                  labelText: l10n.formStaff,
                  contentPadding: const EdgeInsets.symmetric(
                    horizontal: 12,
                    vertical: 12,
                  ),
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(4),
                    borderSide: BorderSide(color: borderColor),
                  ),
                  enabledBorder: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(4),
                    borderSide: BorderSide(color: borderColor),
                  ),
                  suffixIcon: const Icon(Icons.arrow_drop_down),
                  enabled: true,
                ),
                child: Row(
                  children: [
                    if (selectedStaff != null) ...[
                      StaffCircleAvatar(
                        height: 32,
                        color: selectedStaff.color,
                        isHighlighted: false,
                        initials: selectedStaff.initials,
                      ),
                      const SizedBox(width: 8),
                    ],
                    Expanded(
                      child: Text(
                        selectedStaff?.name ?? l10n.selectStaffTitle,
                        style: theme.textTheme.bodyLarge,
                      ),
                    ),
                  ],
                ),
              ),
            ),
            if (field.hasError && field.errorText != null)
              Padding(
                padding: const EdgeInsets.only(left: 12, top: 8),
                child: Text(
                  field.errorText!,
                  style: theme.textTheme.bodySmall?.copyWith(
                    color: theme.colorScheme.error,
                  ),
                ),
              ),
          ],
        );
      },
    );
  }

  Widget _buildTimeSelector(
    BuildContext context,
    dynamic l10n,
    ThemeData theme,
  ) {
    final selectedService = item.serviceId != null
        ? services.where((s) => s.id == item.serviceId).firstOrNull
        : null;
    // Usa la durata dalla variante solo se item.durationMinutes non √® impostato
    final variant = item.serviceVariantId != null
        ? variants.where((v) => v.id == item.serviceVariantId).firstOrNull
        : (item.serviceId != null
              ? variants.where((v) => v.serviceId == item.serviceId).firstOrNull
              : null);
    // Priorit√†: item.durationMinutes > variant.durationMinutes > 30
    final baseDuration = item.durationMinutes > 0
        ? item.durationMinutes
        : (variant?.durationMinutes ?? 30);
    final endTime = item.getEndTime(baseDuration);

    // Costruiamo sempre tre colonne (Start, End, Duration) in modo che
    // l'elemento "Start" assuma sempre le dimensioni che avrebbe quando
    // End e Duration sono visibili. Quando il servizio non √® selezionato,
    // gli ultimi due vengono resi invisibili e non interattivi, ma mantengono
    // lo spazio.
    Widget buildInvisibleIfNoService(Widget w) {
      if (selectedService != null) return w;
      return IgnorePointer(child: Opacity(opacity: 0.0, child: w));
    }

    return Row(
      children: [
        // Start - sempre visibile
        Expanded(
          child: _TimeField(
            label: l10n.blockStartTime,
            time: item.startTime,
            onTap: () => _showStartTimePicker(context),
            theme: theme,
          ),
        ),
        const SizedBox(width: 8),

        // End - visibile solo se servizio selezionato (non modificabile, si calcola dalla durata)
        Expanded(
          child: buildInvisibleIfNoService(
            _TimeField(
              label: l10n.blockEndTime,
              time: endTime,
              onTap:
                  null, // Disabilitato: l'orario di fine si calcola da inizio + durata
              theme: theme,
            ),
          ),
        ),
        const SizedBox(width: 8),

        // Duration - visibile/interattivo solo se servizio selezionato
        Expanded(
          child: buildInvisibleIfNoService(
            _DurationField(
              label: l10n.fieldDurationRequiredLabel.replaceAll(' *', ''),
              durationMinutes: baseDuration,
              onTap: () => _showDurationPicker(context, baseDuration),
              theme: theme,
            ),
          ),
        ),
      ],
    );
  }

  void _showStartTimePicker(BuildContext context) async {
    final l10n = context.l10n;

    if (formFactor != AppFormFactor.desktop) {
      final picked = await AppBottomSheet.show<TimeOfDay>(
        context: context,
        padding: EdgeInsets.zero,
        heightFactor: AppBottomSheet.defaultHeightFactor,
        builder: (ctx) => _TimeGridPicker(
          initial: item.startTime,
          includeTime: suggestedStartTime,
          stepMinutes: 15,
          title: l10n.blockStartTime,
        ),
      );

      if (picked != null) {
        onStartTimeChanged(picked);
      }
    } else {
      final picked = await showDialog<TimeOfDay>(
        context: context,
        builder: (ctx) => Dialog(
          insetPadding: const EdgeInsets.symmetric(
            horizontal: 32,
            vertical: 24,
          ),
          child: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: _TimeGridPicker(
                initial: item.startTime,
                includeTime: suggestedStartTime,
                stepMinutes: 15,
                title: l10n.blockStartTime,
                useSafeArea: false,
              ),
            ),
          ),
        ),
      );

      if (picked != null) {
        onStartTimeChanged(picked);
      }
    }
  }

  void _showDurationPicker(BuildContext context, int currentDuration) {
    final l10n = context.l10n;

    // Calcola i minuti disponibili fino a mezzanotte (24:00)
    final startMinutes = item.startTime.hour * 60 + item.startTime.minute;
    final maxMinutesAvailable = (24 * 60) - startMinutes;

    // Durate comuni in minuti: fino a 60 con step variabili, dopo 60 con step di 15 min
    final allDurations = <int>[
      5, 10, 15, 30, 45, 60,
      // Dopo 60 minuti, incrementi di 15 fino a 6 ore (360 min)
      for (int m = 75; m <= 360; m += 15) m,
    ];
    final durations = allDurations
        .where((d) => d <= maxMinutesAvailable)
        .toList();

    // Se la durata corrente non √® nella lista ma √® valida, aggiungila
    if (currentDuration > 0 &&
        currentDuration <= maxMinutesAvailable &&
        !durations.contains(currentDuration)) {
      durations.add(currentDuration);
      durations.sort();
    }

    if (formFactor != AppFormFactor.desktop) {
      AppBottomSheet.show(
        context: context,
        padding: EdgeInsets.zero,
        builder: (ctx) => SafeArea(
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Padding(
                  padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                  child: Text(
                    l10n.fieldDurationRequiredLabel.replaceAll(' *', ''),
                    style: Theme.of(ctx).textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
                const Divider(height: 1),
                ...durations.map(
                  (d) => ListTile(
                    title: Text(_formatExtraDuration(d)),
                    trailing: d == currentDuration
                        ? Icon(
                            Icons.check,
                            color: Theme.of(ctx).colorScheme.primary,
                          )
                        : null,
                    onTap: () {
                      Navigator.of(ctx).pop();
                      onDurationChanged(d);
                    },
                  ),
                ),
                const SizedBox(height: 8),
              ],
            ),
          ),
        ),
      );
    } else {
      showDialog(
        context: context,
        builder: (ctx) => AlertDialog(
          title: Text(l10n.fieldDurationRequiredLabel.replaceAll(' *', '')),
          content: SizedBox(
            width: 300,
            child: ConstrainedBox(
              constraints: BoxConstraints(
                maxHeight: MediaQuery.of(ctx).size.height * 0.5,
              ),
              child: SingleChildScrollView(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: durations
                      .map(
                        (d) => ListTile(
                          title: Text(_formatDuration(d)),
                          trailing: d == currentDuration
                              ? Icon(
                                  Icons.check,
                                  color: Theme.of(ctx).colorScheme.primary,
                                )
                              : null,
                          onTap: () {
                            Navigator.of(ctx).pop();
                            onDurationChanged(d);
                          },
                        ),
                      )
                      .toList(),
                ),
              ),
            ),
          ),
        ),
      );
    }
  }

  String _formatDuration(int minutes) {
    if (minutes < 60) {
      return '$minutes min';
    }
    final hours = minutes ~/ 60;
    final mins = minutes % 60;
    if (mins == 0) {
      return '$hours h';
    }
    return '$hours h $mins min';
  }

  Future<void> _showStaffPicker(
    BuildContext context,
    List<Staff> availableStaff,
    FormFieldState<int> field,
  ) async {
    final l10n = context.l10n;

    if (formFactor != AppFormFactor.desktop) {
      await AppBottomSheet.show(
        context: context,
        padding: EdgeInsets.zero,
        builder: (ctx) => SafeArea(
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Padding(
                  padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                  child: Text(
                    l10n.selectStaffTitle,
                    style: Theme.of(ctx).textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
                const Divider(height: 1),
                _StaffPickerContent(
                  staff: availableStaff,
                  selectedId: item.staffId,
                  onSelected: (staffId) {
                    Navigator.of(ctx).pop();
                    field.didChange(staffId);
                    field.validate();
                    onChanged(item.copyWith(staffId: staffId));
                  },
                ),
                const SizedBox(height: 8),
              ],
            ),
          ),
        ),
      );
    } else {
      // Per desktop, usa un dialog semplice con scroll
      await showDialog(
        context: context,
        builder: (ctx) => AlertDialog(
          title: Text(l10n.selectStaffTitle),
          content: SizedBox(
            width: 300,
            child: ConstrainedBox(
              constraints: BoxConstraints(
                maxHeight: MediaQuery.of(ctx).size.height * 0.5,
              ),
              child: SingleChildScrollView(
                child: _StaffPickerContent(
                  staff: availableStaff,
                  selectedId: item.staffId,
                  onSelected: (staffId) {
                    Navigator.of(ctx).pop();
                    field.didChange(staffId);
                    field.validate();
                    onChanged(item.copyWith(staffId: staffId));
                  },
                ),
              ),
            ),
          ),
        ),
      );
    }
  }
}

/// Widget per mostrare un campo orario cliccabile
class _TimeField extends StatelessWidget {
  const _TimeField({
    required this.label,
    required this.time,
    required this.onTap,
    required this.theme,
  });

  final String label;
  final TimeOfDay time;
  final VoidCallback? onTap;
  final ThemeData theme;

  @override
  Widget build(BuildContext context) {
    final hour = time.hour.toString().padLeft(2, '0');
    final minute = time.minute.toString().padLeft(2, '0');
    final isDisabled = onTap == null;

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(4),
      child: InputDecorator(
        decoration: InputDecoration(
          labelText: label,
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 10,
            vertical: 10,
          ),
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(4)),
          isDense: true,
          enabled: !isDisabled,
        ),
        child: Text(
          '$hour:$minute',
          style: theme.textTheme.bodyMedium?.copyWith(
            color: isDisabled
                ? theme.colorScheme.onSurface.withOpacity(0.5)
                : null,
          ),
        ),
      ),
    );
  }
}

class ExtraTimeCard extends StatefulWidget {
  const ExtraTimeCard({
    super.key,
    required this.title,
    required this.startTime,
    required this.durationMinutes,
    required this.onStartTimeChanged,
    required this.onDurationChanged,
    required this.onRemove,
    required this.formFactor,
  });

  final String title;
  final TimeOfDay startTime;
  final int durationMinutes;
  final ValueChanged<TimeOfDay> onStartTimeChanged;
  final ValueChanged<int> onDurationChanged;
  final VoidCallback onRemove;
  final AppFormFactor formFactor;

  @override
  State<ExtraTimeCard> createState() => _ExtraTimeCardState();
}

class _ExtraTimeCardState extends State<ExtraTimeCard> {
  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final endTime = _addMinutes(widget.startTime, widget.durationMinutes);

    return Card(
      margin: const EdgeInsets.only(bottom: 12),
      elevation: 1,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
        side: BorderSide(color: theme.colorScheme.outlineVariant),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Expanded(
                  child: Text(
                    widget.title,
                    style: theme.textTheme.bodyMedium?.copyWith(
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                ),
                IconButton(
                  tooltip: l10n.actionClose,
                  icon: const Icon(Icons.close, size: 18),
                  onPressed: widget.onRemove,
                ),
              ],
            ),
            const SizedBox(height: 8),
            Row(
              children: [
                Expanded(
                  child: _TimeField(
                    label: l10n.blockStartTime,
                    time: widget.startTime,
                    onTap: null,
                    theme: theme,
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: _TimeField(
                    label: l10n.blockEndTime,
                    time: endTime,
                    onTap: null,
                    theme: theme,
                  ),
                ),
                const SizedBox(width: 8),
                Expanded(
                  child: _DurationField(
                    label: l10n.fieldDurationRequiredLabel.replaceAll(' *', ''),
                    durationMinutes: widget.durationMinutes,
                    onTap: () =>
                        _showDurationPicker(context, widget.durationMinutes),
                    theme: theme,
                  ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  TimeOfDay _addMinutes(TimeOfDay time, int minutes) {
    final totalMinutes = time.hour * 60 + time.minute + minutes;
    return TimeOfDay(
      hour: (totalMinutes ~/ 60) % 24,
      minute: totalMinutes % 60,
    );
  }

  void _showDurationPicker(BuildContext context, int currentDuration) {
    final l10n = context.l10n;

    // Calcola i minuti disponibili fino a mezzanotte (24:00)
    final startMinutes = widget.startTime.hour * 60 + widget.startTime.minute;
    final maxMinutesAvailable = (24 * 60) - startMinutes;

    // Durate comuni in minuti: fino a 60 con step variabili, dopo 60 con step di 15 min
    final allDurations = <int>[
      5,
      10,
      15,
      30,
      45,
      60,
      for (int m = 75; m <= 360; m += 15) m,
    ];
    final durations = allDurations
        .where((d) => d <= maxMinutesAvailable)
        .toList();

    if (currentDuration > 0 &&
        currentDuration <= maxMinutesAvailable &&
        !durations.contains(currentDuration)) {
      durations.add(currentDuration);
      durations.sort();
    }

    if (widget.formFactor != AppFormFactor.desktop) {
      AppBottomSheet.show(
        context: context,
        padding: EdgeInsets.zero,
        builder: (ctx) => SafeArea(
          child: SingleChildScrollView(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Padding(
                  padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
                  child: Text(
                    l10n.fieldDurationRequiredLabel.replaceAll(' *', ''),
                    style: Theme.of(ctx).textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ),
                const Divider(height: 1),
                ...durations.map(
                  (d) => ListTile(
                    title: Text(_formatExtraDuration(d)),
                    trailing: d == currentDuration
                        ? Icon(
                            Icons.check,
                            color: Theme.of(ctx).colorScheme.primary,
                          )
                        : null,
                    onTap: () {
                      Navigator.of(ctx).pop();
                      widget.onDurationChanged(d);
                    },
                  ),
                ),
              ],
            ),
          ),
        ),
      );
    } else {
      showDialog<void>(
        context: context,
        builder: (ctx) => AlertDialog(
          title: Text(l10n.fieldDurationRequiredLabel.replaceAll(' *', '')),
          content: SizedBox(
            width: 320,
            child: ListView.builder(
              shrinkWrap: true,
              itemCount: durations.length,
              itemBuilder: (_, index) {
                final d = durations[index];
                return ListTile(
                  title: Text(_formatExtraDuration(d)),
                  trailing: d == currentDuration
                      ? Icon(
                          Icons.check,
                          color: Theme.of(ctx).colorScheme.primary,
                        )
                      : null,
                  onTap: () {
                    Navigator.of(ctx).pop();
                    widget.onDurationChanged(d);
                  },
                );
              },
            ),
          ),
        ),
      );
    }
  }
}

/// Widget per mostrare un campo durata cliccabile
class _DurationField extends StatelessWidget {
  const _DurationField({
    required this.label,
    required this.durationMinutes,
    required this.onTap,
    required this.theme,
  });

  final String label;
  final int durationMinutes;
  final VoidCallback? onTap;
  final ThemeData theme;

  @override
  Widget build(BuildContext context) {
    String formatted;
    if (durationMinutes < 60) {
      formatted = '$durationMinutes min';
    } else {
      final hours = durationMinutes ~/ 60;
      final mins = durationMinutes % 60;
      if (mins == 0) {
        formatted = '${hours}h';
      } else {
        formatted = '${hours}h ${mins}m';
      }
    }

    final isDisabled = onTap == null;
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(4),
      child: InputDecorator(
        decoration: InputDecoration(
          labelText: label,
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 10,
            vertical: 10,
          ),
          border: OutlineInputBorder(borderRadius: BorderRadius.circular(4)),
          isDense: true,
          enabled: !isDisabled,
        ),
        child: Text(
          formatted,
          style: theme.textTheme.bodyMedium?.copyWith(
            color: isDisabled
                ? theme.colorScheme.onSurface.withOpacity(0.5)
                : null,
          ),
        ),
      ),
    );
  }
}

class _TimeGridPicker extends StatefulWidget {
  const _TimeGridPicker({
    required this.initial,
    this.includeTime,
    required this.stepMinutes,
    required this.title,
    this.useSafeArea = true,
  });

  final TimeOfDay initial;
  final TimeOfDay? includeTime;
  final int stepMinutes;
  final String title;
  final bool useSafeArea;

  @override
  State<_TimeGridPicker> createState() => _TimeGridPickerState();
}

class _TimeGridPickerState extends State<_TimeGridPicker> {
  late final ScrollController _scrollController;
  late final List<TimeOfDay?> _entries;
  late final int _scrollToIndex;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();

    _entries = <TimeOfDay?>[];
    for (int m = 0; m < LayoutConfig.hoursInDay * 60; m += widget.stepMinutes) {
      final h = m ~/ 60;
      final mm = m % 60;
      _entries.add(TimeOfDay(hour: h, minute: mm));
    }

    _scrollToIndex = _ensureTimeInEntries(widget.initial);
    if (widget.includeTime != null &&
        !_isSameTime(widget.includeTime!, widget.initial)) {
      _ensureTimeInEntries(widget.includeTime!);
    }

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _scrollToSelected();
    });
  }

  bool _isSameTime(TimeOfDay a, TimeOfDay b) =>
      a.hour == b.hour && a.minute == b.minute;

  int _ensureTimeInEntries(TimeOfDay time) {
    final existingIndex = _entries.indexWhere(
      (t) => t != null && _isSameTime(t, time),
    );
    if (existingIndex >= 0) {
      return existingIndex;
    }

    final columnsPerRow = 60 ~/ widget.stepMinutes;
    final targetColumn = time.minute ~/ widget.stepMinutes;
    final baseIndex = (time.hour + 1) * columnsPerRow;

    final newRow = List<TimeOfDay?>.filled(columnsPerRow, null);
    newRow[targetColumn] = time;

    final insertIndex = baseIndex.clamp(0, _entries.length);
    _entries.insertAll(insertIndex, newRow);
    return insertIndex + targetColumn;
  }

  void _scrollToSelected() {
    if (!_scrollController.hasClients) return;

    const crossAxisCount = 4;
    const mainAxisSpacing = 6.0;
    const childAspectRatio = 2.7;
    const padding = 12.0;

    final screenWidth = MediaQuery.of(context).size.width;
    final availableWidth = screenWidth - padding * 2;
    final itemWidth =
        (availableWidth - (crossAxisCount - 1) * 6) / crossAxisCount;
    final itemHeight = itemWidth / childAspectRatio;
    final rowHeight = itemHeight + mainAxisSpacing;

    final targetRow = _scrollToIndex ~/ crossAxisCount;

    final viewportHeight = _scrollController.position.viewportDimension;
    const headerOffset = 40.0;
    final targetOffset =
        (targetRow * rowHeight) -
        (viewportHeight / 2) +
        (rowHeight / 2) +
        headerOffset;

    final maxScroll = _scrollController.position.maxScrollExtent;
    final clampedOffset = targetOffset.clamp(0.0, maxScroll);

    _scrollController.animateTo(
      clampedOffset,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeOut,
    );
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final content = Padding(
      padding: const EdgeInsets.all(12),
      child: Column(
        mainAxisSize: MainAxisSize.max,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              const Icon(Icons.schedule, size: 18),
              const SizedBox(width: 8),
              Text(
                widget.title,
                style: const TextStyle(fontWeight: FontWeight.w700),
              ),
            ],
          ),
          const SizedBox(height: 10),
          Expanded(
            child: GridView.builder(
              controller: _scrollController,
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 4,
                mainAxisSpacing: 6,
                crossAxisSpacing: 6,
                childAspectRatio: 2.7,
              ),
              itemCount: _entries.length,
              itemBuilder: (context, index) {
                final t = _entries[index];
                if (t == null) {
                  return const SizedBox.shrink();
                }
                final isSelected = index == _scrollToIndex;
                return OutlinedButton(
                  style: OutlinedButton.styleFrom(
                    backgroundColor: isSelected
                        ? Theme.of(context).colorScheme.primary.withOpacity(0.1)
                        : null,
                    side: BorderSide(
                      color: isSelected
                          ? Theme.of(context).colorScheme.primary
                          : Theme.of(context).dividerColor,
                    ),
                    padding: const EdgeInsets.symmetric(horizontal: 8),
                  ),
                  onPressed: () => Navigator.pop(context, t),
                  child: Text(DtFmt.hm(context, t.hour, t.minute)),
                );
              },
            ),
          ),
        ],
      ),
    );

    if (!widget.useSafeArea) {
      return content;
    }
    return SafeArea(child: content);
  }
}

class _StaffPickerContent extends StatelessWidget {
  const _StaffPickerContent({
    required this.staff,
    required this.selectedId,
    required this.onSelected,
  });

  final List<Staff> staff;
  final int? selectedId;
  final ValueChanged<int> onSelected;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    if (staff.isEmpty) {
      return Padding(
        padding: const EdgeInsets.all(24),
        child: Center(
          child: Text(
            l10n.noStaffAvailable,
            style: theme.textTheme.bodyMedium?.copyWith(
              color: theme.colorScheme.onSurfaceVariant,
            ),
          ),
        ),
      );
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        for (final member in staff)
          ListTile(
            leading: StaffCircleAvatar(
              height: 36,
              color: member.color,
              isHighlighted: member.id == selectedId,
              initials: member.initials,
            ),
            title: Text('${member.name} ${member.surname}'.trim()),
            trailing: member.id == selectedId
                ? Icon(Icons.check, color: theme.colorScheme.primary)
                : null,
            selected: member.id == selectedId,
            onTap: () => onSelected(member.id),
          ),
      ],
    );
  }
}
--- FILE: lib/features/agenda/presentation/widgets/agenda_top_controls.dart ---
import 'package:agenda_backend/app/widgets/top_controls.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class AgendaTopControls extends ConsumerWidget {
  const AgendaTopControls({super.key, this.compact = false});

  final bool compact;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return TopControls.agenda(compact: compact);
  }
}
--- FILE: lib/features/agenda/presentation/widgets/booking_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:agenda_backend/core/l10n/date_time_formats.dart';
import 'package:agenda_backend/core/models/appointment.dart';
import 'package:agenda_backend/core/widgets/labeled_form_field.dart';
import 'package:agenda_backend/core/widgets/no_scrollbar_behavior.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/booking.dart';
import '../../../../core/models/service_variant.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../clients/domain/clients.dart';
import '../../../clients/presentation/dialogs/client_edit_dialog.dart';
import '../../../clients/providers/clients_providers.dart';
import '../../../services/providers/service_categories_provider.dart';
import '../../../services/providers/services_provider.dart';
import '../../domain/service_item_data.dart';
import '../../providers/agenda_scroll_request_provider.dart';
import '../../providers/appointment_providers.dart';
import '../../providers/bookings_provider.dart';
import '../../providers/date_range_provider.dart';
import '../../providers/layout_config_provider.dart';
import '../../providers/staff_slot_availability_provider.dart';
import 'service_item_card.dart';

/// Show the Booking dialog for creating a new multi-service booking.
Future<void> showBookingDialog(
  BuildContext context,
  WidgetRef ref, {
  Booking? existing,
  DateTime? date,
  TimeOfDay? time,
  int? initialStaffId,
  bool autoOpenDatePicker = false,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final presentation = formFactor == AppFormFactor.desktop
      ? _BookingPresentation.dialog
      : _BookingPresentation.bottomSheet;

  final content = _BookingDialog(
    existing: existing,
    initialDate: date,
    initialTime: time,
    initialStaffId: initialStaffId,
    autoOpenDatePicker: autoOpenDatePicker,
    presentation: presentation,
  );

  if (presentation == _BookingPresentation.dialog) {
    await showDialog(
      context: context,
      builder: (_) => content,
      barrierDismissible: false,
    );
  } else {
    await AppBottomSheet.show(
      context: context,
      useRootNavigator: true,
      padding: const EdgeInsets.symmetric(horizontal: 0, vertical: 16),
      builder: (_) => content,
      heightFactor: AppBottomSheet.defaultHeightFactor,
    );
  }
}

enum _BookingPresentation { dialog, bottomSheet }

class _BookingDialog extends ConsumerStatefulWidget {
  const _BookingDialog({
    this.existing,
    this.initialDate,
    this.initialTime,
    this.initialStaffId,
    this.autoOpenDatePicker = false,
    required this.presentation,
  });

  final Booking? existing;
  final DateTime? initialDate;
  final TimeOfDay? initialTime;
  final int? initialStaffId;
  final bool autoOpenDatePicker;
  final _BookingPresentation presentation;

  @override
  ConsumerState<_BookingDialog> createState() => _BookingDialogState();
}

class _BookingDialogState extends ConsumerState<_BookingDialog> {
  final _formKey = GlobalKey<FormState>();
  final _notesController = TextEditingController();
  final ScrollController _scrollController = ScrollController();

  late DateTime _date;
  int? _clientId;

  bool _clientPickerAutoRequested = false;
  int? _autoOpenServicePickerIndex;
  bool _shouldAutoOpenServicePicker = false;
  bool _datePickerAutoRequested = false;

  /// Nome cliente personalizzato (usato solo per clienti nuovi non ancora salvati)
  String _customClientName = '';

  /// Lista di servizi nella prenotazione
  final List<ServiceItemData> _serviceItems = [];

  /// Contatore per generare chiavi univoche
  int _itemKeyCounter = 0;

  bool _warningDismissed = false;

  @override
  void initState() {
    super.initState();
    final agendaDate = ref.read(agendaDateProvider);

    if (widget.existing != null) {
      // Editing existing booking
      _date = DateUtils.dateOnly(widget.initialDate ?? agendaDate);
      _notesController.text = widget.existing!.notes ?? '';
      _clientId = widget.existing!.clientId;
      _customClientName = widget.existing!.customerName ?? '';

      // Load existing appointments into _serviceItems
      final bookingAppointments = ref
          .read(appointmentsProvider.notifier)
          .getByBookingId(widget.existing!.id);

      for (final appointment in bookingAppointments) {
        final baseDuration = _baseDurationFromAppointment(appointment);
        final blockedExtraMinutes = appointment.blockedExtraMinutes;
        final processingExtraMinutes = appointment.processingExtraMinutes;
        _serviceItems.add(
          ServiceItemData(
            key: _nextItemKey(),
            startTime: TimeOfDay.fromDateTime(appointment.startTime),
            staffId: appointment.staffId,
            serviceId: appointment.serviceId,
            serviceVariantId: appointment.serviceVariantId,
            durationMinutes: baseDuration,
            blockedExtraMinutes: blockedExtraMinutes,
            processingExtraMinutes: processingExtraMinutes,
          ),
        );
      }

      // Se non ci sono appointments, aggiungi un item vuoto
      if (_serviceItems.isEmpty) {
        final initialTime =
            widget.initialTime ?? const TimeOfDay(hour: 10, minute: 0);
        _serviceItems.add(
          ServiceItemData(key: _nextItemKey(), startTime: initialTime),
        );
      }
    } else {
      _date = DateUtils.dateOnly(widget.initialDate ?? agendaDate);

      // Aggiungi un primo servizio vuoto
      final initialTime =
          widget.initialTime ?? const TimeOfDay(hour: 10, minute: 0);
      _serviceItems.add(
        ServiceItemData(
          key: _nextItemKey(),
          startTime: initialTime,
          staffId: widget.initialStaffId,
        ),
      );
    }

    if (widget.existing == null) {
      WidgetsBinding.instance.addPostFrameCallback((_) async {
        if (!mounted) return;
        if (widget.autoOpenDatePicker) {
          await _scheduleAutoDatePicker();
        }
        if (!mounted) return;
        _scheduleAutoClientPicker();
      });
    }
  }

  @override
  void dispose() {
    _notesController.dispose();
    _scrollController.dispose();
    super.dispose();
  }

  int _baseDurationFromAppointment(Appointment appointment) {
    final totalMinutes = appointment.endTime
        .difference(appointment.startTime)
        .inMinutes;
    final extraMinutes = appointment.blockedExtraMinutes;
    final base = totalMinutes - extraMinutes;
    return base > 0 ? base : 0;
  }

  String _nextItemKey() => 'item_${_itemKeyCounter++}';

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final isEdit = widget.existing != null;
    final isDialog = widget.presentation == _BookingPresentation.dialog;

    final formFactor = ref.watch(formFactorProvider);
    final services = ref.watch(servicesProvider);
    final serviceCategories = ref.watch(serviceCategoriesProvider);
    final variants = ref.watch(serviceVariantsProvider);
    final clients = ref.watch(clientsProvider);
    final clientsById = ref.watch(clientsByIdProvider);
    final allStaff = ref.watch(staffForCurrentLocationProvider);

    // Deriva il nome del cliente dal provider se _clientId √® impostato,
    // altrimenti usa il nome personalizzato (per clienti nuovi)
    final clientName = _clientId != null
        ? (clientsById[_clientId]?.name ?? _customClientName)
        : _customClientName;

    final title = isEdit
        ? l10n.appointmentDialogTitleEdit
        : l10n.appointmentDialogTitleNew;

    final isDesktop = widget.presentation == _BookingPresentation.dialog;
    final conflictFlags = _serviceConflictFlags();
    final eligibleIndices = <int>[];
    for (int i = 0; i < _serviceItems.length; i++) {
      if (_isWarningEligible(_serviceItems[i])) {
        eligibleIndices.add(i);
      }
    }
    final allEligibleConflict =
        eligibleIndices.isNotEmpty &&
        eligibleIndices.every((i) => conflictFlags[i]);
    final showAppointmentWarning =
        eligibleIndices.length > 1 && allEligibleConflict;
    final showServiceWarnings = !showAppointmentWarning;
    final content = Form(
      key: _formKey,
      child: ConstrainedBox(
        // Su desktop, limita la larghezza del form. Su mobile, usa tutta la larghezza.
        constraints: BoxConstraints(
          maxWidth: isDesktop ? 340 : double.infinity,
        ),
        child: ScrollConfiguration(
          behavior: const NoScrollbarBehavior(),
          child: SingleChildScrollView(
            controller: _scrollController,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                const SizedBox(height: AppSpacing.formFirstRowSpacing),

                // Client selection
                _ClientSelectionField(
                  clientId: _clientId,
                  clientName: clientName,
                  clients: clients,
                  onClientSelected: (id, name) {
                    setState(() {
                      _clientId = id;
                      _customClientName = name;
                    });
                  },
                  onClientRemoved: () {
                    setState(() {
                      _clientId = null;
                      _customClientName = '';
                    });
                  },
                  onOpenPicker: _openClientPicker,
                ),
                const SizedBox(height: AppSpacing.formRowSpacing),

                // Date and Time selector (row)
                LabeledFormField(
                  label: l10n.formDate,
                  child: InkWell(
                    onTap: _pickDate,
                    borderRadius: BorderRadius.circular(8),
                    child: InputDecorator(
                      decoration: const InputDecoration(
                        border: OutlineInputBorder(),
                        isDense: true,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(DtFmt.shortDate(context, _date)),
                          const Icon(Icons.calendar_today, size: 16),
                        ],
                      ),
                    ),
                  ),
                ),
                const SizedBox(height: AppSpacing.formRowSpacing),

                // Services section header
                // Services list
                ..._buildServiceItems(
                  services: services,
                  categories: serviceCategories,
                  variants: variants,
                  allStaff: allStaff,
                  formFactor: formFactor,
                  conflictFlags: conflictFlags,
                  showServiceWarnings: showServiceWarnings,
                  serviceWarningMessage:
                      l10n.bookingUnavailableTimeWarningService,
                ),

                const SizedBox(height: AppSpacing.formRowSpacing),

                // Notes field
                LabeledFormField(
                  label: l10n.formNotes,
                  child: TextField(
                    controller: _notesController,
                    decoration: InputDecoration(
                      hintText: l10n.notesPlaceholder,
                      border: const OutlineInputBorder(),
                      isDense: true,
                    ),
                    maxLines: 2,
                    textCapitalization: TextCapitalization.sentences,
                  ),
                ),
                const SizedBox(height: AppSpacing.formRowSpacing),
              ],
            ),
          ),
        ),
      ),
    );

    final actions = [
      AppOutlinedActionButton(
        onPressed: () => Navigator.of(context).pop(),
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppFilledButton(
        onPressed: _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionSave),
      ),
    ];

    if (isDialog) {
      return DismissibleDialog(
        child: Dialog(
          insetPadding: const EdgeInsets.symmetric(
            horizontal: 32,
            vertical: 24,
          ),
          child: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text(title, style: Theme.of(context).textTheme.headlineSmall),
                  const SizedBox(height: 8),
                  Flexible(child: content),
                  const SizedBox(height: AppSpacing.formToActionsSpacing),
                  Padding(
                    padding: const EdgeInsets.only(
                      bottom: AppSpacing.formFirstRowSpacing,
                    ),
                    child: _warningBanner(
                      20,
                      showAppointmentWarning,
                      l10n.bookingUnavailableTimeWarningAppointment,
                    ),
                  ),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      for (int i = 0; i < actions.length; i++) ...[
                        if (i > 0) const SizedBox(width: 8),
                        SizedBox(
                          width: AppButtonStyles.dialogButtonWidth,
                          child: actions[i],
                        ),
                      ],
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      );
    }

    // Bottom sheet layout
    const horizontalPadding = 20.0;
    final titlePadding = EdgeInsets.fromLTRB(
      horizontalPadding,
      0,
      horizontalPadding,
      12,
    );

    final isKeyboardOpen = MediaQuery.of(context).viewInsets.bottom > 0;
    return SafeArea(
      top: false,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        mainAxisSize: MainAxisSize.min,
        children: [
          Padding(
            padding: titlePadding,
            child: Text(title, style: Theme.of(context).textTheme.titleLarge),
          ),
          Expanded(
            child: Padding(
              padding: EdgeInsets.symmetric(horizontal: horizontalPadding),
              child: content,
            ),
          ),
          _warningBanner(
            horizontalPadding,
            showAppointmentWarning,
            l10n.bookingUnavailableTimeWarningAppointment,
          ),
          if (!isKeyboardOpen) ...[
            const AppBottomSheetDivider(),
            Padding(
              padding: EdgeInsets.fromLTRB(
                horizontalPadding,
                AppSpacing.formFirstRowSpacing,
                horizontalPadding,
                0,
              ),
              child: Row(
                mainAxisAlignment: actions.length == 3
                    ? MainAxisAlignment.center
                    : MainAxisAlignment.end,
                children: [
                  for (int i = 0; i < actions.length; i++) ...[
                    if (i > 0) const SizedBox(width: 8),
                    SizedBox(
                      width: AppButtonStyles.dialogButtonWidth,
                      child: actions[i],
                    ),
                  ],
                ],
              ),
            ),
          ],

          SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
        ],
      ),
    );
  }

  List<Widget> _buildServiceItems({
    required List<dynamic> services,
    required List<dynamic> categories,
    required List<dynamic> variants,
    required List<dynamic> allStaff,
    required AppFormFactor formFactor,
    required List<bool> conflictFlags,
    required bool showServiceWarnings,
    required String serviceWarningMessage,
  }) {
    final widgets = <Widget>[];

    // Conta servizi effettivamente selezionati
    final selectedCount = _serviceItems
        .where((s) => s.serviceId != null)
        .length;

    for (int i = 0; i < _serviceItems.length; i++) {
      final item = _serviceItems[i];
      final TimeOfDay? suggestedStartTime = i > 0
          ? _resolveServiceEndTime(_serviceItems[i - 1], variants.cast())
          : null;
      final variant = item.serviceId != null
          ? variants.cast<ServiceVariant?>().firstWhere(
              (v) => v?.serviceId == item.serviceId,
              orElse: () => null,
            )
          : null;
      final defaultProcessing = variant?.processingTime ?? 0;
      final defaultBlocked = variant?.blockedTime ?? 0;
      final defaultExtraType = defaultBlocked > 0
          ? ExtraMinutesType.blocked
          : (defaultProcessing > 0 ? ExtraMinutesType.processing : null);
      final hasBlockedExtra = item.blockedExtraMinutes > 0;
      final hasProcessingExtra = item.processingExtraMinutes > 0;
      final canAddDefaultExtra =
          defaultExtraType == ExtraMinutesType.blocked
              ? !hasBlockedExtra
              : (defaultExtraType == ExtraMinutesType.processing
                    ? !hasProcessingExtra
                    : false);
      final showWarning =
          showServiceWarnings &&
          _isWarningEligible(item) &&
          i < conflictFlags.length &&
          conflictFlags[i];

      // Get eligible staff for this service
      final eligibleStaffIds = item.serviceId != null
          ? ref.watch(eligibleStaffForServiceProvider(item.serviceId!))
          : <int>[];
      final isStaffIneligible =
          item.serviceId != null &&
          item.staffId != null &&
          !eligibleStaffIds.contains(item.staffId);

      final isFirst = i == 0;
      final isLast = i == _serviceItems.length - 1;
      widgets.add(
        Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            if (isFirst) ...[
              Row(
                children: [
                  Text(
                    selectedCount > 0
                        ? context.l10n.servicesSelectedCount(selectedCount)
                        : context.l10n.formServices,
                    style: const TextStyle(fontWeight: FontWeight.w600),
                  ),
                ],
              ),
              const SizedBox(height: 8),
            ],
            Padding(
              padding: const EdgeInsets.only(bottom: 12),
              child: ServiceItemCard(
                index: i,
                item: item,
                services: services.cast(),
                categories: categories.cast(),
                variants: variants.cast(),
                eligibleStaff: eligibleStaffIds,
                allStaff: allStaff.cast(),
                formFactor: formFactor,
                canRemove: _serviceItems.length > 1,
                // Obbligatorio solo se non ci sono altri servizi selezionati
                isServiceRequired: selectedCount == 0,
                onChanged: (updated) => _updateServiceItem(i, updated),
                onRemove: () => _removeServiceItem(i),
                onStartTimeChanged: (time) => _updateServiceStartTime(i, time),
                onEndTimeChanged: (time) => _updateServiceEndTime(i, time),
                onDurationChanged: (duration) =>
                    _updateServiceDuration(i, duration),
                suggestedStartTime: suggestedStartTime,
                autoOpenServicePicker:
                    (_shouldAutoOpenServicePicker && i == 0) ||
                    _autoOpenServicePickerIndex == i,
                onServicePickerAutoOpened:
                    (_shouldAutoOpenServicePicker && i == 0) ||
                        _autoOpenServicePickerIndex == i
                    ? () {
                        if (_shouldAutoOpenServicePicker && i == 0) {
                          _onServicePickerAutoOpened();
                        }
                        _onServicePickerAutoOpenedForIndex(i);
                      }
                    : null,
                onServicePickerAutoCompleted: _scrollFormToBottom,
                onAutoOpenStaffPickerCompleted: _scrollFormToBottom,
                availabilityWarningMessage: showWarning
                    ? serviceWarningMessage
                    : null,
                staffEligibilityWarningMessage: isStaffIneligible
                    ? context.l10n.bookingStaffNotEligibleWarning
                    : null,
              ),
            ),
            if (canAddDefaultExtra) ...[
              if (isLast && item.serviceId != null)
                Row(
                  children: [
                    AppOutlinedActionButton(
                      onPressed: () {
                        setState(() {
                          _serviceItems[i] = defaultExtraType ==
                                  ExtraMinutesType.blocked
                              ? _serviceItems[i].copyWith(
                                  blockedExtraMinutes: defaultBlocked,
                                )
                              : _serviceItems[i].copyWith(
                                  processingExtraMinutes: defaultProcessing,
                                );
                          _recalculateTimesFrom(i + 1, variants.cast());
                        });
                      },
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.add, size: 18),
                          const SizedBox(width: 8),
                          Text(context.l10n.additionalTimeSwitch),
                        ],
                      ),
                    ),
                    const Spacer(),
                    AppOutlinedActionButton(
                      onPressed: _addService,
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          const Icon(Icons.add, size: 18),
                          const SizedBox(width: 8),
                          Text(context.l10n.addService),
                        ],
                      ),
                    ),
                  ],
                )
              else
                Align(
                  alignment: Alignment.centerRight,
                  child: AppOutlinedActionButton(
                    onPressed: () {
                      setState(() {
                        _serviceItems[i] = defaultExtraType ==
                                ExtraMinutesType.blocked
                            ? _serviceItems[i].copyWith(
                                blockedExtraMinutes: defaultBlocked,
                              )
                            : _serviceItems[i].copyWith(
                                processingExtraMinutes: defaultProcessing,
                              );
                        _recalculateTimesFrom(i + 1, variants.cast());
                      });
                    },
                    child: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const Icon(Icons.add, size: 18),
                        const SizedBox(width: 8),
                        Text(context.l10n.additionalTimeSwitch),
                      ],
                    ),
                  ),
                ),
              const SizedBox(height: 16),
            ],
            if (hasBlockedExtra) ...[
              ExtraTimeCard(
                title: context.l10n.fieldBlockedTimeLabel,
                startTime: _baseEndTime(item, variants.cast()),
                durationMinutes: item.blockedExtraMinutes,
                formFactor: formFactor,
                onStartTimeChanged: (_) {},
                onDurationChanged: (duration) {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      blockedExtraMinutes: duration,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                  });
                },
                onRemove: () {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      blockedExtraMinutes: 0,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                  });
                },
              ),
              const SizedBox(height: 8),
            ],
            if (hasProcessingExtra) ...[
              ExtraTimeCard(
                title: context.l10n.fieldProcessingTimeLabel,
                startTime: _addMinutes(
                  _baseEndTime(item, variants.cast()),
                  item.blockedExtraMinutes,
                ),
                durationMinutes: item.processingExtraMinutes,
                formFactor: formFactor,
                onStartTimeChanged: (_) {},
                onDurationChanged: (duration) {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      processingExtraMinutes: duration,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                  });
                },
                onRemove: () {
                  setState(() {
                    _serviceItems[i] = _serviceItems[i].copyWith(
                      processingExtraMinutes: 0,
                    );
                    _recalculateTimesFrom(i + 1, variants.cast());
                  });
                },
              ),
              const SizedBox(height: 8),
            ],
            if (isLast && item.serviceId != null &&
                !canAddDefaultExtra) ...[
              Align(
                alignment: Alignment.centerRight,
                child: AppOutlinedActionButton(
                  onPressed: _addService,
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      const Icon(Icons.add, size: 18),
                      const SizedBox(width: 8),
                      Text(context.l10n.addService),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 8),
            ],
          ],
        ),
      );
    }

    if (_serviceItems.isEmpty) {
      widgets.add(
        Container(
          padding: const EdgeInsets.all(24),
          decoration: BoxDecoration(
            border: Border.all(color: Theme.of(context).colorScheme.outline),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Center(
            child: Text(
              context.l10n.noServicesAdded,
              style: TextStyle(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ),
        ),
      );
    }

    return widgets;
  }

  Widget _warningBanner(
    double horizontalPadding,
    bool hasConflicts,
    String message,
  ) {
    if (!hasConflicts || _warningDismissed) return const SizedBox.shrink();
    return Container(
      width: double.infinity,
      decoration: BoxDecoration(
        color: Colors.amber.withOpacity(0.18),
        borderRadius: BorderRadius.circular(8),
      ),
      padding: EdgeInsets.fromLTRB(
        horizontalPadding,
        12,
        horizontalPadding,
        12,
      ),
      child: Row(
        children: [
          const Icon(
            Icons.warning_amber_rounded,
            color: Colors.amber,
            size: 20,
          ),
          const SizedBox(width: 10),
          Expanded(
            child: Text(
              message,
              style: const TextStyle(
                color: Color(0xFF8A4D00),
                fontWeight: FontWeight.w600,
              ),
            ),
          ),
          IconButton(
            icon: const Icon(Icons.close, size: 18),
            color: const Color(0xFF8A4D00),
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints.tightFor(width: 32, height: 32),
            onPressed: () {
              setState(() => _warningDismissed = true);
            },
          ),
        ],
      ),
    );
  }

  bool _isWarningEligible(ServiceItemData item) {
    return item.serviceId != null && item.staffId != null;
  }

  List<bool> _serviceConflictFlags() {
    final layout = ref.watch(layoutConfigProvider);
    final Map<int, Set<int>> cache = {};
    final flags = <bool>[];

    for (final item in _serviceItems) {
      final staffId = item.staffId;
      if (staffId == null || item.serviceId == null) {
        flags.add(false);
        continue;
      }

      final available = cache.putIfAbsent(
        staffId,
        () => ref.watch(staffSlotAvailabilityProvider(staffId)),
      );

      if (available.isEmpty) {
        flags.add(true);
        continue;
      }

      final startMinutes = item.startTime.hour * 60 + item.startTime.minute;
      final endMinutes = startMinutes + item.durationMinutes;
      final startSlot = startMinutes ~/ layout.minutesPerSlot;
      final endSlot = (endMinutes / layout.minutesPerSlot).ceil();

      var hasConflict = false;
      for (int slot = startSlot; slot < endSlot; slot++) {
        if (!available.contains(slot)) {
          hasConflict = true;
          break;
        }
      }
      flags.add(hasConflict);
    }
    return flags;
  }

  void _scheduleAutoClientPicker() {
    if (_clientPickerAutoRequested) return;
    _clientPickerAutoRequested = true;
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;
      _openClientPicker(triggerServiceAutoOpen: true);
    });
  }

  Future<void> _scheduleAutoDatePicker() async {
    if (_datePickerAutoRequested) return;
    _datePickerAutoRequested = true;
    await _pickDate();
  }

  Future<void> _openClientPicker({bool triggerServiceAutoOpen = false}) async {
    final formFactor = ref.read(formFactorProvider);
    final isDesktop = formFactor == AppFormFactor.desktop;
    bool dismissed = false;

    while (mounted) {
      if (!mounted) return;
      final clients = ref.read(clientsProvider);
      _ClientItem? result;
      if (isDesktop) {
        result = await showDialog<_ClientItem?>(
          context: context,
          builder: (ctx) => Dialog(
            insetPadding: const EdgeInsets.symmetric(
              horizontal: 32,
              vertical: 24,
            ),
            child: ConstrainedBox(
              constraints: const BoxConstraints(
                minWidth: 600,
                maxWidth: 720,
                maxHeight: 600,
              ),
              child: _ClientPickerSheet(
                clients: clients,
                selectedClientId: _clientId,
              ),
            ),
          ),
        );
      } else {
        result = await AppBottomSheet.show<_ClientItem?>(
          context: context,
          useRootNavigator: true,
          padding: EdgeInsets.zero,
          heightFactor: AppBottomSheet.defaultHeightFactor,
          builder: (ctx) =>
              _ClientPickerSheet(clients: clients, selectedClientId: _clientId),
        );
      }

      if (result == null) {
        dismissed = true;
        break;
      }
      final selectedResult = result;
      if (selectedResult.id == -2) {
        if (!mounted) return;
        Client? initialClient;
        if (selectedResult.name.isNotEmpty) {
          final nameParts = Client.splitFullName(selectedResult.name);
          initialClient = Client(
            id: 0,
            businessId: 0,
            firstName: nameParts.firstName,
            lastName: nameParts.lastName,
            createdAt: DateTime.now(),
          );
        }
        final newClient = await showClientEditDialog(
          context,
          ref,
          client: initialClient,
        );
        if (newClient != null) {
          setState(() {
            _clientId = newClient.id;
            _customClientName = newClient.name;
          });
          break;
        }
        continue;
      } else if (selectedResult.id == -1) {
        setState(() {
          _clientId = null;
          _customClientName = '';
        });
        break;
      } else {
        setState(() {
          _clientId = selectedResult.id;
          _customClientName = selectedResult.name;
        });
        break;
      }
    }

    if (!mounted) return;
    if (triggerServiceAutoOpen && !dismissed) {
      setState(() {
        _shouldAutoOpenServicePicker = true;
      });
    }
  }

  void _onServicePickerAutoOpened() {
    if (!_shouldAutoOpenServicePicker) return;
    setState(() {
      _shouldAutoOpenServicePicker = false;
    });
  }

  void _onServicePickerAutoOpenedForIndex(int index) {
    if (_autoOpenServicePickerIndex != index) return;
    setState(() {
      _autoOpenServicePickerIndex = null;
    });
  }

  void _addService() {
    final variants = ref.read(serviceVariantsProvider);
    // Calcola l'orario di inizio per il nuovo servizio
    TimeOfDay nextStart;
    if (_serviceItems.isEmpty) {
      nextStart = widget.initialTime ?? const TimeOfDay(hour: 10, minute: 0);
    } else {
      // Prendi l'ultimo servizio e calcola il suo orario di fine
      final lastItem = _serviceItems.last;
      nextStart = _resolveServiceEndTime(lastItem, variants);
    }

    // Smart staff selection:
    // 1. Try initial staff if eligible
    // 2. Leave null for user selection
    int? smartStaffId = widget.initialStaffId;

    final newIndex = _serviceItems.length;
    setState(() {
      _serviceItems.add(
        ServiceItemData(
          key: _nextItemKey(),
          startTime: nextStart,
          staffId: smartStaffId,
        ),
      );
      _autoOpenServicePickerIndex = newIndex;
    });
  }

  void _removeServiceItem(int index) {
    if (_serviceItems.length <= 1) return;

    final variants = ref.read(serviceVariantsProvider);

    setState(() {
      _serviceItems.removeAt(index);

      // Ricalcola gli orari per i servizi successivi
      _recalculateTimesFrom(index, variants);
    });
  }

  void _updateServiceItem(int index, ServiceItemData updated) {
    final variants = ref.read(serviceVariantsProvider);

    setState(() {
      _serviceItems[index] = updated;

      // Se cambia il servizio, potremmo dover aggiornare lo staff
      // e ricalcolare gli orari successivi
      _recalculateTimesFrom(index + 1, variants);

      // Se lo staff √® ancora null, seleziona automaticamente un eligible
      if (updated.serviceId != null && updated.staffId == null) {
        final newStaffId = _findBestStaff(updated.serviceId!);
        _serviceItems[index] = updated.copyWith(staffId: newStaffId);
      }
    });
  }

  void _updateServiceStartTime(int index, TimeOfDay newTime) {
    final variants = ref.read(serviceVariantsProvider);

    setState(() {
      final updated = _serviceItems[index].copyWith(startTime: newTime);
      _serviceItems[index] = _applyAutoExtraStart(updated, variants);

      // Ricalcola gli orari per i servizi successivi
      _recalculateTimesFrom(index + 1, variants);
    });
  }

  void _updateServiceEndTime(int index, TimeOfDay newEndTime) {
    setState(() {
      final item = _serviceItems[index];

      // Calcola la nuova durata basata sulla differenza tra end e start
      final startMinutes = item.startTime.hour * 60 + item.startTime.minute;
      final endMinutes = newEndTime.hour * 60 + newEndTime.minute;
      var newDuration = endMinutes - startMinutes;

      // Se la durata √® negativa o zero, imposta un minimo di 15 minuti
      if (newDuration <= 0) {
        newDuration = 15;
      }

      _serviceItems[index] = item.copyWith(durationMinutes: newDuration);

      // Ricalcola gli orari per i servizi successivi
      final variants = ref.read(serviceVariantsProvider);
      _serviceItems[index] = _applyAutoExtraStart(
        _serviceItems[index],
        variants,
      );
      _recalculateTimesFrom(index + 1, variants);
    });
  }

  void _updateServiceDuration(int index, int newDuration) {
    setState(() {
      _serviceItems[index] = _serviceItems[index].copyWith(
        durationMinutes: newDuration,
      );

      // Ricalcola gli orari per i servizi successivi
      final variants = ref.read(serviceVariantsProvider);
      _serviceItems[index] = _applyAutoExtraStart(
        _serviceItems[index],
        variants,
      );
      _recalculateTimesFrom(index + 1, variants);
    });
  }

  void _recalculateTimesFrom(int fromIndex, List<ServiceVariant> variants) {
    if (fromIndex <= 0 || fromIndex >= _serviceItems.length) return;

    for (int i = fromIndex; i < _serviceItems.length; i++) {
      final prevItem = _serviceItems[i - 1];
      final prevEnd = _resolveServiceEndTime(prevItem, variants);
      final updated = _serviceItems[i].copyWith(startTime: prevEnd);
      _serviceItems[i] = _applyAutoExtraStart(updated, variants);
    }
  }

  TimeOfDay _resolveServiceEndTime(
    ServiceItemData item,
    List<ServiceVariant> variants,
  ) {
    final baseEnd = _baseEndTime(item, variants);
    if (item.blockedExtraMinutes <= 0) {
      return baseEnd;
    }
    return _addMinutes(baseEnd, item.blockedExtraMinutes);
  }

  ServiceItemData _applyAutoExtraStart(
    ServiceItemData item,
    List<ServiceVariant> variants,
  ) {
    return item;
  }

  TimeOfDay _baseEndTime(ServiceItemData item, List<ServiceVariant> variants) {
    final variant = _variantForItem(item, variants);
    final baseDuration = item.durationMinutes > 0
        ? item.durationMinutes
        : (variant?.durationMinutes ?? 30);
    return item.getEndTime(baseDuration);
  }

  ServiceVariant? _variantForItem(
    ServiceItemData item,
    List<ServiceVariant> variants,
  ) {
    if (item.serviceVariantId != null) {
      for (final v in variants) {
        if (v.id == item.serviceVariantId) return v;
      }
    }
    if (item.serviceId != null) {
      for (final v in variants) {
        if (v.serviceId == item.serviceId) return v;
      }
    }
    return null;
  }

  TimeOfDay _addMinutes(TimeOfDay time, int minutes) {
    final totalMinutes = time.hour * 60 + time.minute + minutes;
    return TimeOfDay(
      hour: (totalMinutes ~/ 60) % 24,
      minute: totalMinutes % 60,
    );
  }

  /// Trova lo staff migliore per un servizio:
  /// 1. Primo staff eligible disponibile
  /// 2. null per selezione manuale
  int? _findBestStaff(int serviceId) {
    final eligibleIds = ref.read(eligibleStaffForServiceProvider(serviceId));
    if (eligibleIds.isEmpty) return null;
    return eligibleIds.first;
  }

  Future<void> _pickDate() async {
    final picked = await showDialog<DateTime>(
      context: context,
      builder: (context) {
        return Dialog(
          child: CalendarDatePicker(
            initialDate: _date,
            firstDate: DateTime.now().subtract(const Duration(days: 365)),
            lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
            onDateChanged: (value) => Navigator.of(context).pop(value),
          ),
        );
      },
    );
    if (picked != null) {
      setState(() => _date = DateUtils.dateOnly(picked));
    }
  }

  void _scrollFormToBottom() {
    if (!_scrollController.hasClients) return;
    _scrollController.animateTo(
      _scrollController.position.maxScrollExtent,
      duration: const Duration(milliseconds: 250),
      curve: Curves.easeOut,
    );
  }

  void _onSave() {
    final l10n = context.l10n;
    if (!_formKey.currentState!.validate()) return;

    // Verifica che ci sia almeno un servizio con dati completi
    final validItems = _serviceItems
        .where((item) => item.serviceId != null && item.staffId != null)
        .toList();

    if (validItems.isEmpty) {
      ScaffoldMessenger.of(
        context,
      ).showSnackBar(SnackBar(content: Text(l10n.atLeastOneServiceRequired)));
      return;
    }

    final variants = ref.read(serviceVariantsProvider);
    final services = ref.read(servicesProvider);
    final clientsById = ref.read(clientsByIdProvider);
    final appointmentsNotifier = ref.read(appointmentsProvider.notifier);
    final bookingsNotifier = ref.read(bookingsProvider.notifier);

    // Deriva il nome del cliente dal provider se _clientId √® impostato
    final clientName = _clientId != null
        ? (clientsById[_clientId]?.name ?? _customClientName)
        : _customClientName;

    // Create a new booking
    final bookingId = bookingsNotifier.createBooking(
      clientId: _clientId,
      customerName: clientName.isNotEmpty ? clientName : null,
      notes: _notesController.text.isNotEmpty ? _notesController.text : null,
    );

    Appointment? scrollTarget;

    // Add appointments for each service
    for (final item in validItems) {
      final variant = variants.firstWhere(
        (v) => v.serviceId == item.serviceId,
        orElse: () => variants.first,
      );
      final service = services.firstWhere((s) => s.id == item.serviceId);
      final blockedExtraMinutes = item.blockedExtraMinutes;
      final processingExtraMinutes = item.processingExtraMinutes;
      final extraMinutesType = blockedExtraMinutes > 0
          ? ExtraMinutesType.blocked
          : (processingExtraMinutes > 0
                ? ExtraMinutesType.processing
                : null);
      final extraMinutes = extraMinutesType == ExtraMinutesType.blocked
          ? blockedExtraMinutes
          : (extraMinutesType == ExtraMinutesType.processing
                ? processingExtraMinutes
                : 0);
      final effectivePrice = variant.isFree ? null : variant.price;

      final start = DateTime(
        _date.year,
        _date.month,
        _date.day,
        item.startTime.hour,
        item.startTime.minute,
      );
      final baseDuration = item.durationMinutes > 0
          ? item.durationMinutes
          : variant.durationMinutes;
      final durationMinutes =
          (baseDuration + (blockedExtraMinutes > 0 ? blockedExtraMinutes : 0))
              .toInt();
      final end = start.add(Duration(minutes: durationMinutes));

      final created = appointmentsNotifier.addAppointment(
        bookingId: bookingId,
        staffId: item.staffId!,
        serviceId: service.id,
        serviceVariantId: variant.id,
        clientId: _clientId,
        clientName: clientName,
        serviceName: service.name,
        start: start,
        end: end,
        price: effectivePrice,
        extraMinutes: extraMinutes,
        extraMinutesType: extraMinutesType,
        extraBlockedMinutes: blockedExtraMinutes,
        extraProcessingMinutes: processingExtraMinutes,
      );
      scrollTarget ??= created;
    }

    if (scrollTarget != null) {
      ref.read(agendaScrollRequestProvider.notifier).request(scrollTarget);
    }
    Navigator.of(context).pop();
  }
}

// ============================================================================
// Helper Widgets
// ============================================================================

class _ClientItem {
  final int id;
  final String name;
  const _ClientItem(this.id, this.name);
}

/// Widget per la selezione del cliente con link cliccabile e hint
class _ClientSelectionField extends ConsumerWidget {
  const _ClientSelectionField({
    required this.clientId,
    required this.clientName,
    required this.clients,
    required this.onClientSelected,
    required this.onClientRemoved,
    required this.onOpenPicker,
  });

  final int? clientId;
  final String clientName;
  final List<Client> clients;
  final void Function(int? id, String name) onClientSelected;
  final VoidCallback onClientRemoved;
  final Future<void> Function()? onOpenPicker;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final hasClient = clientId != null || clientName.isNotEmpty;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          l10n.formClient,
          style: const TextStyle(fontWeight: FontWeight.w600),
        ),
        const SizedBox(height: 6),
        if (hasClient)
          _SelectedClientTile(
            clientName: clientName,
            onTap: () => onOpenPicker?.call(),
            onRemove: onClientRemoved,
          )
        else
          InkWell(
            onTap: () => onOpenPicker?.call(),
            borderRadius: BorderRadius.circular(8),
            child: Container(
              width: double.infinity,
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 14),
              decoration: BoxDecoration(
                border: Border.all(color: theme.colorScheme.outline),
                borderRadius: BorderRadius.circular(8),
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.person_add_outlined,
                    size: 20,
                    color: theme.colorScheme.primary,
                  ),
                  const SizedBox(width: 8),
                  Text(
                    l10n.addClientToAppointment,
                    style: TextStyle(
                      color: theme.colorScheme.primary,
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ],
              ),
            ),
          ),
        const SizedBox(height: 6),
        Text(
          l10n.clientOptionalHint,
          style: theme.textTheme.bodySmall?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
      ],
    );
  }
}

/// Tile che mostra il cliente selezionato con opzione per rimuoverlo
class _SelectedClientTile extends StatelessWidget {
  const _SelectedClientTile({
    required this.clientName,
    required this.onTap,
    required this.onRemove,
  });

  final String clientName;
  final VoidCallback onTap;
  final VoidCallback onRemove;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 10),
        decoration: BoxDecoration(
          border: Border.all(color: theme.colorScheme.outline),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Row(
          children: [
            StaffCircleAvatar(
              height: 32,
              color: theme.colorScheme.primary,
              isHighlighted: false,
              initials: clientName.isNotEmpty
                  ? initialsFromName(clientName, maxChars: 2)
                  : '?',
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Text(
                clientName,
                style: const TextStyle(fontWeight: FontWeight.w500),
              ),
            ),
            IconButton(
              icon: Icon(Icons.close, size: 20, color: theme.colorScheme.error),
              onPressed: onRemove,
              tooltip: context.l10n.removeClient,
              padding: EdgeInsets.zero,
              constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
            ),
          ],
        ),
      ),
    );
  }
}

/// Bottom sheet per la selezione del cliente
class _ClientPickerSheet extends ConsumerStatefulWidget {
  const _ClientPickerSheet({required this.clients, this.selectedClientId});

  final List<Client> clients;
  final int? selectedClientId;

  @override
  ConsumerState<_ClientPickerSheet> createState() => _ClientPickerSheetState();
}

class _ClientPickerSheetState extends ConsumerState<_ClientPickerSheet> {
  final _searchController = TextEditingController();
  String _searchQuery = '';

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  List<Client> get _filteredClients {
    final clients = ref
        .watch(clientsProvider)
        .where((c) => !c.isArchived)
        .toList();
    if (_searchQuery.isEmpty) return clients;
    final q = _searchQuery.toLowerCase();
    return clients.where((c) => c.name.toLowerCase().contains(q)).toList();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    final maxHeight = MediaQuery.of(context).size.height * 0.8;
    return SafeArea(
      child: ConstrainedBox(
        constraints: BoxConstraints(maxHeight: maxHeight),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Header
            Padding(
              padding: const EdgeInsets.fromLTRB(16, 16, 16, 12),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    l10n.selectClientTitle,
                    style: theme.textTheme.titleLarge?.copyWith(
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  const SizedBox(height: AppSpacing.formFirstRowSpacing),
                  TextField(
                    controller: _searchController,
                    decoration: InputDecoration(
                      hintText: l10n.searchClientPlaceholder,
                      prefixIcon: const Icon(Icons.search, size: 20),
                      border: const OutlineInputBorder(),
                      isDense: true,
                      contentPadding: const EdgeInsets.symmetric(
                        horizontal: 12,
                        vertical: 10,
                      ),
                    ),
                    onChanged: (value) {
                      setState(() => _searchQuery = value.trim());
                    },
                  ),
                ],
              ),
            ),
            const AppBottomSheetDivider(),
            // Quick actions
            ListTile(
              leading: StaffCircleAvatar(
                height: 32,
                color: theme.colorScheme.primary,
                isHighlighted: false,
                initials: '',
                child: Icon(
                  Icons.person_add_outlined,
                  color: theme.colorScheme.onSurface,
                  size: 18,
                ),
              ),
              title: Text(l10n.createNewClient),
              onTap: () {
                Navigator.of(context).pop(_ClientItem(-2, _searchQuery));
              },
            ),
            ListTile(
              leading: StaffCircleAvatar(
                height: 32,
                color: theme.colorScheme.onSurfaceVariant,
                isHighlighted: false,
                initials: '',
                child: Icon(
                  Icons.person_off_outlined,
                  color: theme.colorScheme.onSurface,
                  size: 18,
                ),
              ),
              title: Text(l10n.noClientForAppointment),
              onTap: () {
                Navigator.of(context).pop(const _ClientItem(-1, ''));
              },
            ),
            const AppBottomSheetDivider(),
            // Client list
            Flexible(
              child: _filteredClients.isEmpty
                  ? Center(
                      child: Text(
                        l10n.clientsEmpty,
                        style: theme.textTheme.bodyMedium?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                      ),
                    )
                  : ListView.builder(
                      padding: const EdgeInsets.only(bottom: 8),
                      itemCount: _filteredClients.length,
                      itemBuilder: (context, index) {
                        final client = _filteredClients[index];
                        final isSelected = client.id == widget.selectedClientId;
                        return ListTile(
                          leading: StaffCircleAvatar(
                            height: 32,
                            color: isSelected
                                ? theme.colorScheme.primary
                                : theme.colorScheme.primary,
                            isHighlighted: isSelected,
                            initials: client.name.isNotEmpty
                                ? initialsFromName(client.name, maxChars: 2)
                                : '?',
                          ),
                          title: Text(client.name),
                          subtitle: client.phone != null
                              ? Text(
                                  client.phone!,
                                  style: theme.textTheme.bodySmall,
                                )
                              : null,
                          trailing: Row(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              IconButton(
                                icon: Icon(
                                  Icons.edit_outlined,
                                  size: 20,
                                  color: theme.colorScheme.onSurfaceVariant,
                                ),
                                onPressed: () async {
                                  await showClientEditDialog(
                                    context,
                                    ref,
                                    client: client,
                                  );
                                },
                                tooltip: l10n.clientsEdit,
                              ),
                              if (isSelected)
                                Icon(
                                  Icons.check_circle,
                                  color: theme.colorScheme.primary,
                                ),
                            ],
                          ),
                          onTap: () {
                            Navigator.of(
                              context,
                            ).pop(_ClientItem(client.id, client.name));
                          },
                        );
                      },
                    ),
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/agenda_feature.dart ---
/// Entry point modulare per la feature "Agenda"
/// Importa qui tutti i componenti pubblici dell'agenda.
/// Cos√¨ altrove potrai scrivere semplicemente:
///   import 'package:agenda/features/agenda/agenda_feature.dart';

library;

export 'domain/config/agenda_theme.dart'; // se aggiungi un tema centralizzato
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ÔøΩ Domain & Config
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
export 'domain/config/layout_config.dart';
// Schermata di agenda (entry screen)
export 'presentation/agenda_screen.dart';
export 'presentation/screens/day_view/components/hour_column.dart';
export 'presentation/screens/day_view/components/staff_header_row.dart';
// Vista principale (giornaliera multi-staff)
export 'presentation/screens/day_view/multi_staff_day_view.dart';
export 'presentation/screens/day_view/staff_column.dart';
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üé® Presentation layer
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Layout e componenti core
export 'presentation/screens/helper/responsive_layout.dart';
export 'presentation/screens/widgets/agenda_dividers.dart';
export 'presentation/screens/widgets/unavailable_slot_pattern.dart';
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ÔøΩ Application (providers, notifiers, stato)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
export 'providers/agenda_scroll_provider.dart';
export 'providers/pending_drop_provider.dart';
--- FILE: lib/features/staff/providers/staff_providers.dart ---
import 'package:agenda_backend/features/agenda/providers/business_providers.dart';
import 'package:agenda_backend/features/agenda/providers/location_providers.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/staff.dart';

class StaffNotifier extends Notifier<List<Staff>> {
  @override
  List<Staff> build() {
    final business = ref.watch(currentBusinessProvider);
    return [
      Staff(
        id: 1,
        businessId: business.id,
        name: 'Dario',
        surname: 'La Rosa',
        color: const Color(0xFF2962FF),
        locationIds: const [101],
        sortOrder: 0,
        isBookableOnline: true,
      ),
      Staff(
        id: 2,
        businessId: business.id,
        name: 'Luca',
        surname: 'Bianchi',
        color: const Color(0xFF536DFE),
        locationIds: const [102],
        sortOrder: 1,
        isBookableOnline: true,
      ),
      Staff(
        id: 3,
        businessId: business.id,
        name: 'Sara',
        surname: 'Verdi',
        color: const Color(0xFFF50057),
        locationIds: const [101],
        sortOrder: 2,
        isBookableOnline: false,
      ),
      Staff(
        id: 4,
        businessId: business.id,
        name: 'Alessia',
        surname: 'Neri',
        color: const Color(0xFFFF4081),
        locationIds: const [101],
        sortOrder: 3,
        isBookableOnline: true,
      ),
    ];
  }

  void add(Staff staff) {
    state = [...state, staff];
  }

  void update(Staff updated) {
    state = [
      for (final s in state)
        if (s.id == updated.id) updated else s,
    ];
  }

  void delete(int id) {
    state = state.where((s) => s.id != id).toList();
  }

  void duplicate(Staff original) {
    final newId = _nextId();
    final existingNames = state.map((s) => s.displayName).toSet();
    var base = original.displayName;
    var candidate = '$base Copia';
    var i = 1;
    while (existingNames.contains(candidate)) {
      candidate = '$base Copia $i';
      i++;
    }
    final parts = candidate.split(' ');
    final name = parts.first;
    final surname =
        parts.length > 1 ? parts.sublist(1).join(' ') : original.surname;
    add(
      original.copyWith(
        id: newId,
        name: name,
        surname: surname,
      ),
    );
  }

  int nextId() => _nextId();

  int nextSortOrderForLocations(Iterable<int> locationIds) {
    if (state.isEmpty) return 0;
    final ids = locationIds.toSet();
    final relevant = ids.isEmpty
        ? state
        : state.where((s) => s.locationIds.any(ids.contains));
    final base = relevant.isEmpty ? state : relevant;
    final maxSort = base
        .map((s) => s.sortOrder)
        .reduce((a, b) => a > b ? a : b);
    return maxSort + 1;
  }

  void reorderForLocation(int locationId, int oldIndex, int newIndex) {
    final inLocation = state
        .where((s) => s.worksAtLocation(locationId))
        .toList()
      ..sort((a, b) => a.sortOrder.compareTo(b.sortOrder));

    if (newIndex > oldIndex) newIndex -= 1;
    final item = inLocation.removeAt(oldIndex);
    inLocation.insert(newIndex, item);

    final updated = <Staff>[];
    for (int i = 0; i < inLocation.length; i++) {
      updated.add(inLocation[i].copyWith(sortOrder: i));
    }

    final updatedAll = [
      for (final s in state)
        if (s.worksAtLocation(locationId))
          updated.firstWhere((u) => u.id == s.id)
        else
          s,
    ];

    state = updatedAll;
  }

  int _nextId() {
    if (state.isEmpty) return 1;
    final maxId = state.map((s) => s.id).reduce((a, b) => a > b ? a : b);
    return maxId + 1;
  }
}

final allStaffProvider = NotifierProvider<StaffNotifier, List<Staff>>(
  StaffNotifier.new,
);

List<Staff> _sortStaff(List<Staff> staff) {
  final list = [...staff];
  list.sort((a, b) {
    final so = a.sortOrder.compareTo(b.sortOrder);
    return so != 0 ? so : a.displayName.compareTo(b.displayName);
  });
  return list;
}

final sortedAllStaffProvider = Provider<List<Staff>>((ref) {
  final staff = ref.watch(allStaffProvider);
  return _sortStaff(staff);
});

final staffForCurrentLocationProvider = Provider<List<Staff>>((ref) {
  final location = ref.watch(currentLocationProvider);
  final staff = ref.watch(allStaffProvider);
  return _sortStaff([
    for (final member in staff)
      if (member.worksAtLocation(location.id)) member,
  ]);
});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üè¢ Location provider separato per la sezione Staff
// null = "Tutte le sedi" (default)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class StaffSectionLocationNotifier extends Notifier<int?> {
  @override
  int? build() => null; // Default: tutte le sedi

  void set(int? locationId) => state = locationId;

  void setAll() => state = null;
}

final staffSectionLocationIdProvider =
    NotifierProvider<StaffSectionLocationNotifier, int?>(
      StaffSectionLocationNotifier.new,
    );

/// Staff filtrato per la location selezionata nella sezione Staff.
/// Se locationId √® null (tutte le sedi), restituisce tutti gli staff.
final staffForStaffSectionProvider = Provider<List<Staff>>((ref) {
  final locationId = ref.watch(staffSectionLocationIdProvider);
  final staff = ref.watch(allStaffProvider);

  if (locationId == null) {
    // Tutte le sedi: restituisci tutti gli staff
    return _sortStaff(staff);
  }

  return _sortStaff([
    for (final member in staff)
      if (member.worksAtLocation(locationId)) member,
  ]);
});

/// Holds the staffId that should be pre-selected when navigating to
/// the single-staff availability edit screen. Cleared after consumption.
final initialStaffToEditProvider = Provider<ValueNotifier<int?>>((ref) {
  final vn = ValueNotifier<int?>(null);
  ref.onDispose(vn.dispose);
  return vn;
});
--- FILE: lib/features/staff/providers/staff_sorted_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/location.dart';
import '../../../core/models/staff.dart';
import '../../agenda/providers/location_providers.dart';
import 'staff_providers.dart';

final sortedLocationsProvider = Provider<List<Location>>((ref) {
  // usa l'ordine della lista nello stato
  return [...ref.watch(locationsProvider)];
});

final staffByLocationProvider = Provider.family<List<Staff>, int>((
  ref,
  locationId,
) {
  final staff = ref.watch(allStaffProvider);
  final list = [
    for (final s in staff)
      if (s.worksAtLocation(locationId)) s,
  ];
  list.sort((a, b) {
    final so = a.sortOrder.compareTo(b.sortOrder);
    return so != 0 ? so : a.displayName.compareTo(b.displayName);
  });
  return list;
});
--- FILE: lib/features/staff/providers/staff_reorder_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../agenda/providers/location_providers.dart';
import 'staff_providers.dart';

class TeamReorderNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  void toggle() => state = !state;

  void setReordering(bool value) => state = value;

  void reorderLocations(int oldIndex, int newIndex) {
    ref.read(locationsProvider.notifier).reorder(oldIndex, newIndex);
  }

  void reorderStaffForLocation(int locationId, int oldIndex, int newIndex) {
    ref.read(allStaffProvider.notifier).reorderForLocation(
          locationId,
          oldIndex,
          newIndex,
        );
  }
}

final teamReorderProvider = NotifierProvider<TeamReorderNotifier, bool>(
  TeamReorderNotifier.new,
);

class TeamReorderPanelNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  void toggle() => state = !state;

  void setVisible(bool value) => state = value;
}

final teamReorderPanelProvider =
    NotifierProvider<TeamReorderPanelNotifier, bool>(
      TeamReorderPanelNotifier.new,
    );
--- FILE: lib/features/staff/providers/weekly_availability_provider.dart ---

--- FILE: lib/features/staff/providers/availability_exceptions_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/availability_exception.dart';
import '../data/availability_exceptions_repository.dart';

/// Provider per il repository delle eccezioni.
/// Utilizza un'implementazione mock, sostituibile con API reale.
final availabilityExceptionsRepositoryProvider =
    Provider<AvailabilityExceptionsRepository>((ref) {
      return MockAvailabilityExceptionsRepository();
    });

/// Provider per la gestione dello stato delle eccezioni.
///
/// Stato: `Map<staffId, List<AvailabilityException>>`
/// Carica le eccezioni on-demand quando richieste per uno staff specifico.
class AvailabilityExceptionsNotifier
    extends AsyncNotifier<Map<int, List<AvailabilityException>>> {
  @override
  Future<Map<int, List<AvailabilityException>>> build() async {
    // Inizialmente vuoto, le eccezioni vengono caricate on-demand
    return {};
  }

  AvailabilityExceptionsRepository get _repository =>
      ref.read(availabilityExceptionsRepositoryProvider);

  /// Carica le eccezioni per uno staff specifico in un range di date.
  /// Se [fromDate] e [toDate] non sono specificati, carica tutte le eccezioni.
  Future<void> loadExceptionsForStaff(
    int staffId, {
    DateTime? fromDate,
    DateTime? toDate,
  }) async {
    final exceptions = await _repository.getExceptionsForStaff(
      staffId,
      fromDate: fromDate,
      toDate: toDate,
    );

    final current = state.value ?? {};
    state = AsyncData({...current, staffId: exceptions});
  }

  /// Aggiunge una nuova eccezione.
  Future<AvailabilityException> addException({
    required int staffId,
    required DateTime date,
    TimeOfDay? startTime,
    TimeOfDay? endTime,
    required AvailabilityExceptionType type,
    String? reason,
  }) async {
    final exception = startTime != null && endTime != null
        ? AvailabilityException.timeRange(
            id: 0, // Il repository assegner√† l'ID reale
            staffId: staffId,
            date: date,
            startTime: startTime,
            endTime: endTime,
            type: type,
            reason: reason,
          )
        : AvailabilityException.allDay(
            id: 0,
            staffId: staffId,
            date: date,
            type: type,
            reason: reason,
          );

    final saved = await _repository.addException(exception);

    // Aggiorna lo stato locale
    final current = state.value ?? {};
    final staffExceptions = List<AvailabilityException>.from(
      current[staffId] ?? [],
    );
    staffExceptions.add(saved);

    state = AsyncData({...current, staffId: staffExceptions});

    return saved;
  }

  /// Aggiunge eccezioni per un periodo (batch).
  /// Crea un'eccezione per ogni giorno nel range [startDate, endDate].
  Future<List<AvailabilityException>> addExceptionsForPeriod({
    required int staffId,
    required DateTime startDate,
    required DateTime endDate,
    TimeOfDay? startTime,
    TimeOfDay? endTime,
    required AvailabilityExceptionType type,
    String? reason,
  }) async {
    final List<AvailabilityException> created = [];

    // Normalizza le date
    var currentDate = DateUtils.dateOnly(startDate);
    final lastDate = DateUtils.dateOnly(endDate);

    // Crea un'eccezione per ogni giorno
    while (!currentDate.isAfter(lastDate)) {
      final exception = startTime != null && endTime != null
          ? AvailabilityException.timeRange(
              id: 0,
              staffId: staffId,
              date: currentDate,
              startTime: startTime,
              endTime: endTime,
              type: type,
              reason: reason,
            )
          : AvailabilityException.allDay(
              id: 0,
              staffId: staffId,
              date: currentDate,
              type: type,
              reason: reason,
            );

      final saved = await _repository.addException(exception);
      created.add(saved);

      currentDate = currentDate.add(const Duration(days: 1));
    }

    // Aggiorna lo stato locale con tutte le eccezioni create
    final current = state.value ?? {};
    final staffExceptions = List<AvailabilityException>.from(
      current[staffId] ?? [],
    );
    staffExceptions.addAll(created);

    state = AsyncData({...current, staffId: staffExceptions});

    return created;
  }

  /// Aggiorna un'eccezione esistente.
  Future<AvailabilityException> updateException(
    AvailabilityException exception,
  ) async {
    final updated = await _repository.updateException(exception);

    // Aggiorna lo stato locale
    final current = state.value ?? {};
    final staffExceptions = List<AvailabilityException>.from(
      current[exception.staffId] ?? [],
    );
    final index = staffExceptions.indexWhere((e) => e.id == exception.id);
    if (index != -1) {
      staffExceptions[index] = updated;
    }

    state = AsyncData({...current, exception.staffId: staffExceptions});

    return updated;
  }

  /// Elimina un'eccezione.
  Future<void> deleteException(int staffId, int exceptionId) async {
    await _repository.deleteException(exceptionId);

    // Aggiorna lo stato locale
    final current = state.value ?? {};
    final staffExceptions = List<AvailabilityException>.from(
      current[staffId] ?? [],
    );
    staffExceptions.removeWhere((e) => e.id == exceptionId);

    state = AsyncData({...current, staffId: staffExceptions});
  }

  /// Ottiene le eccezioni per uno staff in una data specifica (sincronamente dallo stato).
  List<AvailabilityException> getExceptionsForStaffOnDate(
    int staffId,
    DateTime date,
  ) {
    final current = state.value ?? {};
    final staffExceptions = current[staffId] ?? [];
    return staffExceptions.where((e) => e.isOnDate(date)).toList();
  }
}

final availabilityExceptionsProvider =
    AsyncNotifierProvider<
      AvailabilityExceptionsNotifier,
      Map<int, List<AvailabilityException>>
    >(AvailabilityExceptionsNotifier.new);

/// Provider derivato: eccezioni per uno staff specifico in una data specifica.
/// Utile per query puntuali nella UI.
final exceptionsForStaffOnDateProvider =
    Provider.family<
      List<AvailabilityException>,
      ({int staffId, DateTime date})
    >((ref, params) {
      final allExceptions = ref.watch(availabilityExceptionsProvider);

      return allExceptions.maybeWhen(
        data: (data) {
          final staffExceptions = data[params.staffId] ?? [];
          return staffExceptions.where((e) => e.isOnDate(params.date)).toList();
        },
        orElse: () => [],
      );
    });

/// Provider derivato: verifica se ci sono eccezioni per uno staff in una data.
final hasExceptionsForStaffOnDateProvider =
    Provider.family<bool, ({int staffId, DateTime date})>((ref, params) {
      final exceptions = ref.watch(exceptionsForStaffOnDateProvider(params));
      return exceptions.isNotEmpty;
    });

/// Provider derivato: tutte le eccezioni per uno staff (lista flat).
final allExceptionsForStaffProvider =
    Provider.family<List<AvailabilityException>, int>((ref, staffId) {
      final allExceptions = ref.watch(availabilityExceptionsProvider);

      return allExceptions.maybeWhen(
        data: (data) => data[staffId] ?? [],
        orElse: () => [],
      );
    });
--- FILE: lib/features/staff/utils/staff_formatters.dart ---
// Placeholder per futuri formatter relativi allo staff.
--- FILE: lib/features/staff/utils/staff_validators.dart ---
// Placeholder per futuri validator relativi allo staff.
--- FILE: lib/features/staff/data/weekly_availability_repository.dart ---

--- FILE: lib/features/staff/data/staff_api.dart ---
--- FILE: lib/features/staff/data/availability_exceptions_repository.dart ---
import 'package:flutter/material.dart';

import '../../../core/models/availability_exception.dart';

/// Repository per la gestione delle eccezioni alla disponibilit√†.
///
/// Implementazione mock locale. In futuro pu√≤ essere sostituita
/// con un'implementazione che comunica con il backend API.
abstract class AvailabilityExceptionsRepository {
  /// Carica tutte le eccezioni per uno staff in un range di date.
  Future<List<AvailabilityException>> getExceptionsForStaff(
    int staffId, {
    DateTime? fromDate,
    DateTime? toDate,
  });

  /// Carica tutte le eccezioni per una data specifica (tutti gli staff).
  Future<List<AvailabilityException>> getExceptionsForDate(DateTime date);

  /// Carica un'eccezione per ID.
  Future<AvailabilityException?> getException(int id);

  /// Aggiunge una nuova eccezione.
  Future<AvailabilityException> addException(AvailabilityException exception);

  /// Aggiorna un'eccezione esistente.
  Future<AvailabilityException> updateException(
    AvailabilityException exception,
  );

  /// Elimina un'eccezione.
  Future<void> deleteException(int id);
}

/// Implementazione mock del repository per le eccezioni.
class MockAvailabilityExceptionsRepository
    implements AvailabilityExceptionsRepository {
  final List<AvailabilityException> _exceptions = [];
  int _nextId = 1;

  MockAvailabilityExceptionsRepository() {
    _initMockData();
  }

  void _initMockData() {
    // Dati mock di esempio
    final today = DateTime.now();
    DateTime nextWorkingDay(DateTime from) {
      var d = from;
      while (d.weekday == DateTime.sunday) {
        d = d.add(const Duration(days: 1));
      }
      return d;
    }

    // Eccezione: Dario non lavora domani mattina (dentro orario base)
    final darioExceptionDate = nextWorkingDay(
      today.add(const Duration(days: 1)),
    );
    _exceptions.add(
      AvailabilityException.timeRange(
        id: _nextId++,
        staffId: 1,
        date: darioExceptionDate,
        startTime: const TimeOfDay(hour: 9, minute: 0),
        endTime: const TimeOfDay(hour: 12, minute: 0),
        type: AvailabilityExceptionType.unavailable,
        reasonCode: 'vacation',
      ),
    );

    // Eccezione: Sara lavora sabato prossimo nel buco 13:00-14:00 (fuori orario base)
    final nextSaturday = today.add(Duration(days: (6 - today.weekday + 7) % 7));
    _exceptions.add(
      AvailabilityException.timeRange(
        id: _nextId++,
        staffId: 3,
        date: nextSaturday,
        startTime: const TimeOfDay(hour: 13, minute: 0),
        endTime: const TimeOfDay(hour: 14, minute: 0),
        type: AvailabilityExceptionType.available,
        reasonCode: 'extra_shift',
      ),
    );

    // Eccezione: Luca visita medica in un giorno lavorativo (dentro orario base)
    final lucaExceptionDate = nextWorkingDay(
      today.add(const Duration(days: 3)),
    );
    _exceptions.add(
      AvailabilityException.timeRange(
        id: _nextId++,
        staffId: 2,
        date: lucaExceptionDate,
        startTime: const TimeOfDay(hour: 9, minute: 0),
        endTime: const TimeOfDay(hour: 12, minute: 0),
        type: AvailabilityExceptionType.unavailable,
        reasonCode: 'medical_visit',
      ),
    );
  }

  @override
  Future<List<AvailabilityException>> getExceptionsForStaff(
    int staffId, {
    DateTime? fromDate,
    DateTime? toDate,
  }) async {
    await Future.delayed(const Duration(milliseconds: 100));

    return _exceptions.where((e) {
      if (e.staffId != staffId) return false;
      if (fromDate != null && e.date.isBefore(fromDate)) return false;
      if (toDate != null && e.date.isAfter(toDate)) return false;
      return true;
    }).toList();
  }

  @override
  Future<List<AvailabilityException>> getExceptionsForDate(
    DateTime date,
  ) async {
    await Future.delayed(const Duration(milliseconds: 50));

    final targetDate = DateUtils.dateOnly(date);
    return _exceptions.where((e) => e.isOnDate(targetDate)).toList();
  }

  @override
  Future<AvailabilityException?> getException(int id) async {
    await Future.delayed(const Duration(milliseconds: 50));

    try {
      return _exceptions.firstWhere((e) => e.id == id);
    } catch (_) {
      return null;
    }
  }

  @override
  Future<AvailabilityException> addException(
    AvailabilityException exception,
  ) async {
    await Future.delayed(const Duration(milliseconds: 100));

    final newException = exception.copyWith(id: _nextId++);
    _exceptions.add(newException);
    return newException;
  }

  @override
  Future<AvailabilityException> updateException(
    AvailabilityException exception,
  ) async {
    await Future.delayed(const Duration(milliseconds: 100));

    final index = _exceptions.indexWhere((e) => e.id == exception.id);
    if (index == -1) {
      throw Exception('Exception not found: ${exception.id}');
    }

    _exceptions[index] = exception;
    return exception;
  }

  @override
  Future<void> deleteException(int id) async {
    await Future.delayed(const Duration(milliseconds: 100));

    _exceptions.removeWhere((e) => e.id == id);
  }
}
--- FILE: lib/features/staff/data/staff_repository.dart ---
--- FILE: lib/features/staff/presentation/staff_availability_screen.dart ---
/*
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üéØ FUNZIONALIT√Ä COMPLETA: Gestione disponibilit√† staff
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

CONTESTO:
Progetto Flutter web "Agenda Platform".
Architettura basata su:
- Riverpod per lo stato e provider
- Widget principali: MultiStaffDayView, StaffColumn, AppointmentCard
- Configurazione: LayoutConfig e AgendaTheme

OBIETTIVO:
Schermata per gestire disponibilit√† settimanali dello staff.

AGGIORNAMENTI RECENTI:
- Copertura 24h (00:00‚Äì24:00)
- Scroll verticale sincronizzato tra colonna orari e griglia giorni
- Etichetta oraria centrata in ogni cella (HH:MM)

*/

import 'dart:async';

import 'package:agenda_backend/app/theme/extensions.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/staff.dart';
import 'package:agenda_backend/core/widgets/staff_picker_sheet.dart';
import 'package:agenda_backend/features/agenda/providers/layout_config_provider.dart';
import 'package:agenda_backend/features/staff/presentation/widgets/exception_calendar_view.dart';
import 'package:agenda_backend/features/staff/presentation/widgets/weekly_schedule_editor.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:flutter/material.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üì¶ MODEL: TimeRange (ore intere)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class TimeRange {
  final int startHour; // incluso
  final int endHour; // escluso

  const TimeRange(this.startHour, this.endHour)
    : assert(startHour >= 0 && startHour <= 23),
      assert(endHour >= 1 && endHour <= 24),
      assert(endHour > startHour);

  @override
  String toString() => 'TimeRange($startHour-$endHour)';

  TimeRange copyWith({int? startHour, int? endHour}) =>
      TimeRange(startHour ?? this.startHour, endHour ?? this.endHour);
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üß† PROVIDER MOCK: StaffAvailabilityNotifier
// Stato: AsyncValue<Map<int, List<TimeRange>>>
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// Nuovo provider per persistenza per-staff: staffId -> day -> slots (Set<int>)
class StaffAvailabilityByStaffNotifier
    extends AsyncNotifier<Map<int, Map<int, Set<int>>>> {
  @override
  FutureOr<Map<int, Map<int, Set<int>>>> build() async {
    // Mock iniziale: per TUTTI gli staff (verr√† sovrascritto quando si salva)
    // Turni standard: 09:00‚Äì13:00 e 14:00‚Äì19:00 dal luned√¨ al sabato, domenica vuoto.
    // Rappresentiamo gli slot attivi usando step di minutesPerSlot = 15 (assunto).
    const minutesPerSlot = 15; // Assunzione coerente con layout corrente.
    int slotIndexOf(int hour, int minute) =>
        (hour * 60 + minute) ~/ minutesPerSlot;

    // Genera set di slot per un turno con semantica [start, end) - estremo finale ESCLUSIVO.
    // Esempio: 09:00..13:00 => slot 36..51 (09:00, 09:15, ..., 12:45)
    // Lo slot 52 (13:00) NON √® incluso, quindi sar√† marcato come non disponibile.
    Set<int> rangeSlots(
      int startHour,
      int startMinute,
      int endHour,
      int endMinute,
    ) {
      final start = slotIndexOf(startHour, startMinute);
      final end = slotIndexOf(endHour, endMinute); // esclusivo
      return {for (int i = start; i < end; i++) i};
    }

    final morning = rangeSlots(9, 0, 13, 0); // 9:00 -> 12:45 (13:00 escluso)
    final afternoon = rangeSlots(
      14,
      0,
      19,
      0,
    ); // 14:00 -> 18:45 (19:00 escluso)
    final combined = {...morning, ...afternoon};

    Map<int, Set<int>> weekTemplate() => {
      // Days: 1 Mon .. 6 Sat -> combined, 7 Sun empty
      for (int d = 1; d <= 6; d++) d: Set<int>.from(combined),
      7: <int>{},
    };

    // Recupera elenco staff per applicare il template a tutti
    // (Se non disponibile nel build, creiamo un set minimo.)
    // Nota: non abbiamo accesso diretto ai provider qui, quindi ipotizziamo id staff 1..4 come mock.
    final staffIds = [for (int i = 1; i <= 4; i++) i];
    return {for (final id in staffIds) id: weekTemplate()};
  }

  Future<void> saveForStaff(int staffId, Map<int, Set<int>> weeklySlots) async {
    state = const AsyncLoading();
    await Future.delayed(const Duration(milliseconds: 300));
    final current = Map<int, Map<int, Set<int>>>.from(state.value ?? {});
    current[staffId] = {
      for (final e in weeklySlots.entries) e.key: Set<int>.from(e.value),
    };
    state = AsyncData(current);
    // ignore: avoid_print
    print(
      '[StaffAvailabilityByStaff] Saved for staff $staffId: ${current[staffId]}',
    );
  }
}

final staffAvailabilityByStaffProvider =
    AsyncNotifierProvider<
      StaffAvailabilityByStaffNotifier,
      Map<int, Map<int, Set<int>>>
    >(StaffAvailabilityByStaffNotifier.new);

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// üñ•Ô∏è Schermata principale: StaffAvailabilityScreen
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

class StaffAvailabilityScreen extends ConsumerStatefulWidget {
  const StaffAvailabilityScreen({super.key});

  @override
  ConsumerState<StaffAvailabilityScreen> createState() =>
      _StaffAvailabilityScreenState();
}

class _StaffAvailabilityScreenState
    extends ConsumerState<StaffAvailabilityScreen>
    with SingleTickerProviderStateMixin {
  // Stato locale per staff corrente: selezioni per giorno (slot assoluti)
  Map<int, Set<int>> _weeklySelections = {
    for (int d = 1; d <= 7; d++) d: <int>{},
  };
  // Stato salvato originale per confronto (traccia modifiche non salvate)
  Map<int, Set<int>> _savedWeeklySelections = {
    for (int d = 1; d <= 7; d++) d: <int>{},
  };
  // Mappa staffId -> disponibilit√† settimanale (slots)
  final Map<int, Map<int, Set<int>>> _staffSelections = {};
  int? _selectedStaffId; // definito dopo aver caricato staff list
  bool _initializedFromProvider = false;

  // Tab controller per navigare tra orario settimanale ed eccezioni
  late TabController _tabController;

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  /// Verifica se ci sono modifiche non salvate.
  bool get _hasUnsavedChanges {
    if (_weeklySelections.length != _savedWeeklySelections.length) return true;
    for (final entry in _weeklySelections.entries) {
      final saved = _savedWeeklySelections[entry.key];
      if (saved == null) return true;
      if (!_setEquals(entry.value, saved)) return true;
    }
    return false;
  }

  bool _setEquals(Set<int> a, Set<int> b) {
    if (a.length != b.length) return false;
    return a.containsAll(b);
  }

  void _ensureCurrentStaffInit(int staffId) {
    _staffSelections.putIfAbsent(staffId, () {
      // Clona la struttura vuota
      return {for (int d = 1; d <= 7; d++) d: <int>{}};
    });
  }

  void _switchStaff(
    int newStaffId, {
    bool updateWeeklyState = true,
  }) {
    final currentId = _selectedStaffId;
    if (currentId == newStaffId) return;
    // Salva lo stato corrente nello staff precedente
    if (currentId != null) {
      _staffSelections[currentId] = {
        for (final entry in _weeklySelections.entries)
          entry.key: Set<int>.from(entry.value),
      };
    }
    // Carica stato per nuovo staff (o crea vuoto)
    _ensureCurrentStaffInit(newStaffId);
    final loaded = _staffSelections[newStaffId]!;
    setState(() {
      _selectedStaffId = newStaffId;
      if (updateWeeklyState) {
        _weeklySelections = {
          for (final entry in loaded.entries)
            entry.key: Set<int>.from(entry.value),
        };
        _savedWeeklySelections = {
          for (final entry in loaded.entries)
            entry.key: Set<int>.from(entry.value),
        };
      }
    });
  }

  Future<void> _save(WidgetRef ref, int minutesPerSlot) async {
    // Prima di salvare, unifica le fasce orarie contigue
    final currentSchedule = WeeklySchedule.fromSlots(
      _weeklySelections,
      minutesPerSlot: minutesPerSlot,
    );
    final mergedSchedule = currentSchedule.mergeContiguousShifts();
    final mergedSlots = mergedSchedule.toSlots(minutesPerSlot: minutesPerSlot);

    // Aggiorna lo stato locale con le fasce unificate
    setState(() {
      _weeklySelections = mergedSlots;
    });

    // Persisti nello storage locale per staff corrente
    if (_selectedStaffId != null) {
      _staffSelections[_selectedStaffId!] = {
        for (final entry in mergedSlots.entries)
          entry.key: Set<int>.from(entry.value),
      };
    }
    if (_selectedStaffId != null) {
      await ref
          .read(staffAvailabilityByStaffProvider.notifier)
          .saveForStaff(_selectedStaffId!, mergedSlots);
    }
    // Aggiorna lo stato salvato dopo il salvataggio
    _savedWeeklySelections = {
      for (final entry in mergedSlots.entries)
        entry.key: Set<int>.from(entry.value),
    };
  }

  @override
  Widget build(BuildContext context) {
    final layout = ref.watch(layoutConfigProvider);
    final availabilityByStaff = ref.watch(staffAvailabilityByStaffProvider);
    // Usa lo staff filtrato per la location selezionata nella sezione staff
    final staffList = ref.watch(staffForStaffSectionProvider);

    // If a staffId was requested from another screen, pre-select it once
    final requested = ref.read(initialStaffToEditProvider).value;
    if (_selectedStaffId == null && requested != null && staffList.isNotEmpty) {
      _switchStaff(requested);
      // clear the request to avoid re-applying
      ref.read(initialStaffToEditProvider).value = null;
    }

    // Imposta staff iniziale se non selezionato
    if (_selectedStaffId == null && staffList.isNotEmpty) {
      _switchStaff(staffList.first.id);
    }

    availabilityByStaff.whenOrNull(
      data: (all) {
        if (_initializedFromProvider) return;
        final currentWeekly = (_selectedStaffId != null)
            ? (all[_selectedStaffId!] ?? const <int, Set<int>>{})
            : const <int, Set<int>>{};
        setState(() {
          _weeklySelections = {
            for (final e in currentWeekly.entries)
              e.key: Set<int>.from(e.value),
          };
          // Salva lo stato originale per tracciare modifiche
          _savedWeeklySelections = {
            for (final e in currentWeekly.entries)
              e.key: Set<int>.from(e.value),
          };
          _initializedFromProvider = true;
        });
      },
    );

    final isSaving = availabilityByStaff.isLoading;

    String? staffName;
    if (_selectedStaffId != null && staffList.isNotEmpty) {
      final staff = staffList.firstWhere(
        (s) => s.id == _selectedStaffId,
        orElse: () => staffList.first,
      );
      staffName = '${staff.name} ${staff.surname}'.trim();
    }

    return PopScope(
      canPop: !_hasUnsavedChanges,
      onPopInvokedWithResult: (didPop, result) async {
        if (didPop) return;
        final navigator = Navigator.of(context);
        final shouldPop = await _showDiscardChangesDialog();
        if (shouldPop && mounted) {
          navigator.pop();
        }
      },
      child: Scaffold(
        appBar: AppBar(
          title: Text(
            staffName == null
                ? context.l10n.availabilityTitle
                : context.l10n.availabilityTitleFor(staffName),
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
          ),
          bottom: TabBar(
            controller: _tabController,
            tabs: [
              Tab(text: context.l10n.weeklyScheduleTitle),
              Tab(text: context.l10n.exceptionsTitle),
            ],
          ),
        ),
        body: Column(
          children: [
            // ‚îÄ‚îÄ Toolbar azioni ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // Toolbar semplificata: solo selezione staff e salvataggio
            Padding(
              padding: const EdgeInsets.all(12.0),
              child: Wrap(
                spacing: 12,
                runSpacing: 12,
                crossAxisAlignment: WrapCrossAlignment.center,
                children: [
                  Text(context.l10n.labelStaff),
                  _StaffSelectorDropdown(
                    staffList: staffList,
                    selectedStaffId: _selectedStaffId,
                    onSelected: (staffId) => _switchStaff(
                      staffId,
                      updateWeeklyState: _tabController.index == 0,
                    ),
                  ),
                  // Mostra pulsante salva solo nella tab orario settimanale
                  AnimatedBuilder(
                    animation: _tabController,
                    builder: (context, _) {
                      if (_tabController.index != 0) {
                        return const SizedBox.shrink();
                      }
                      return FilledButton(
                        onPressed: (_selectedStaffId == null || isSaving)
                            ? null
                            : () => _save(ref, layout.minutesPerSlot),
                        child: isSaving
                            ? const SizedBox(
                                width: 18,
                                height: 18,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                ),
                              )
                            : Text(context.l10n.availabilitySave),
                      );
                    },
                  ),
                ],
              ),
            ),

            const Divider(height: 1),

            // ‚îÄ‚îÄ TabBarView con editor settimanale ed eccezioni ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            Expanded(
              child: TabBarView(
                controller: _tabController,
                children: [
                  // Tab 1: Editor orario settimanale
                  _buildWeeklyScheduleTab(layout),
                  // Tab 2: Calendario eccezioni
                  if (_selectedStaffId != null)
                    SingleChildScrollView(
                      child: ExceptionCalendarView(staffId: _selectedStaffId!),
                    )
                  else
                    const Center(child: CircularProgressIndicator()),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// Costruisce il tab dell'editor settimanale.
  Widget _buildWeeklyScheduleTab(dynamic layout) {
    final schedule = WeeklySchedule.fromSlots(
      _weeklySelections,
      minutesPerSlot: layout.minutesPerSlot,
    );

    return LayoutBuilder(
      builder: (context, constraints) {
        return Stack(
          children: [
            // Editor turni settimanali (scrollabile) - sotto
            Positioned.fill(
              child: SingleChildScrollView(
                padding: const EdgeInsets.only(
                  top: 80, // Spazio per l'header
                ),
                child: WeeklyScheduleEditor(
                  initialSchedule: WeeklySchedule.fromSlots(
                    _weeklySelections,
                    minutesPerSlot: layout.minutesPerSlot,
                  ),
                  showHeader: false,
                  onChanged: (newSchedule) {
                    final newSlots = newSchedule.toSlots(
                      minutesPerSlot: layout.minutesPerSlot,
                    );
                    setState(() {
                      _weeklySelections = newSlots;
                    });
                  },
                ),
              ),
            ),

            // Header fisso con ombra - sopra
            Positioned(
              top: 0,
              left: 0,
              right: 0,
              child: DecoratedBox(
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.surface,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.1),
                      offset: const Offset(0, 4),
                      blurRadius: 8,
                    ),
                  ],
                ),
                child: Padding(
                  padding: const EdgeInsets.all(16),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text(
                        context.l10n.weeklyScheduleTitle,
                        style: Theme.of(context).textTheme.titleLarge?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        context.l10n.weeklyScheduleTotalHours(
                          schedule.totalHours,
                        ),
                        style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                          color: Theme.of(context).colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ],
        );
      },
    );
  }

  /// Mostra dialog di conferma per scartare le modifiche non salvate.
  Future<bool> _showDiscardChangesDialog() async {
    final l10n = context.l10n;
    final result = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.discardChangesTitle),
        content: Text(l10n.discardChangesMessage),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: Text(l10n.actionDiscard),
          ),
          FilledButton(
            onPressed: () => Navigator.of(context).pop(true),
            child: Text(l10n.actionConfirm),
          ),
        ],
      ),
    );
    return result ?? false;
  }
}

/// Widget per selezione staff con bottom sheet/dialog (come nel form appuntamento)
class _StaffSelectorDropdown extends ConsumerStatefulWidget {
  const _StaffSelectorDropdown({
    required this.staffList,
    required this.selectedStaffId,
    required this.onSelected,
  });

  final List<Staff> staffList;
  final int? selectedStaffId;
  final ValueChanged<int> onSelected;

  @override
  ConsumerState<_StaffSelectorDropdown> createState() =>
      _StaffSelectorDropdownState();
}

class _StaffSelectorDropdownState
    extends ConsumerState<_StaffSelectorDropdown> {
  bool _isHovered = false;

  String _getSelectedLabel() {
    if (widget.selectedStaffId == null) {
      return context.l10n.labelSelect;
    }
    final staff = widget.staffList.firstWhere(
      (s) => s.id == widget.selectedStaffId,
      orElse: () => widget.staffList.first,
    );
    return '${staff.name} ${staff.surname}'.trim();
  }

  Staff? _getSelectedStaff() {
    if (widget.selectedStaffId == null) return null;
    return widget.staffList.firstWhere(
      (s) => s.id == widget.selectedStaffId,
      orElse: () => widget.staffList.first,
    );
  }

  Future<void> _showPicker() async {
    final result = await showStaffPickerSheet(
      context: context,
      ref: ref,
      staff: widget.staffList,
      selectedId: widget.selectedStaffId,
    );
    if (result != null) {
      widget.onSelected(result);
    }
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;
    final interactions = theme.extension<AppInteractionColors>();
    final hoverFill =
        interactions?.hoverFill ?? colorScheme.primary.withOpacity(0.06);
    final backgroundColor = _isHovered
        ? Color.alphaBlend(hoverFill, colorScheme.surface)
        : colorScheme.surface;

    final selectedStaff = _getSelectedStaff();

    return MouseRegion(
      onEnter: (_) {
        if (!_isHovered) setState(() => _isHovered = true);
      },
      onExit: (_) {
        if (_isHovered) setState(() => _isHovered = false);
      },
      child: GestureDetector(
        onTap: _showPicker,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
          decoration: BoxDecoration(
            color: backgroundColor,
            borderRadius: BorderRadius.circular(8),
            border: Border.all(color: colorScheme.outline.withOpacity(0.3)),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              if (selectedStaff != null) ...[
                StaffCircleAvatar(
                  height: 28,
                  color: selectedStaff.color,
                  isHighlighted: false,
                  initials: selectedStaff.initials,
                ),
                const SizedBox(width: 8),
              ],
              Text(_getSelectedLabel(), style: theme.textTheme.bodyMedium),
              const SizedBox(width: 8),
              Icon(
                Icons.keyboard_arrow_down,
                size: 20,
                color: colorScheme.onSurfaceVariant,
              ),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/staff_screen.dart ---
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

import '../../../core/l10n/l10_extension.dart';
import 'widgets/staff_hub_card.dart';

class StaffScreen extends StatelessWidget {
  const StaffScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    return Scaffold(
      body: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              l10n.staffScreenPlaceholder,
              style: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 24),
            Wrap(
              spacing: 16,
              runSpacing: 16,
              children: [
                StaffHubCard(
                  icon: Icons.schedule,
                  title: l10n.staffHubAvailabilityTitle,
                  subtitle: l10n.staffHubAvailabilitySubtitle,
                  onTap: () => context.go('/staff/availability'),
                ),
                StaffHubCard(
                  icon: Icons.group,
                  title: l10n.staffHubTeamTitle,
                  subtitle: l10n.staffHubTeamSubtitle,
                  onTap: () {},
                  disabled: true,
                ),
                StaffHubCard(
                  icon: Icons.insights,
                  title: l10n.staffHubStatsTitle,
                  subtitle: l10n.staffHubStatsSubtitle,
                  onTap: () {},
                  disabled: true,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/team_screen.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/location.dart';
import 'package:agenda_backend/core/models/staff.dart';
import 'package:agenda_backend/core/widgets/app_dialogs.dart';
import 'package:agenda_backend/core/widgets/reorder_toggle_button.dart';
import 'package:agenda_backend/core/widgets/reorder_toggle_panel.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../agenda/providers/location_providers.dart';
import '../providers/staff_providers.dart';
import '../providers/staff_reorder_provider.dart';
import '../providers/staff_sorted_providers.dart';
import 'dialogs/location_dialog.dart';
import 'dialogs/staff_dialog.dart';
import 'widgets/location_item.dart';

class TeamScreen extends ConsumerStatefulWidget {
  const TeamScreen({super.key});

  @override
  ConsumerState<TeamScreen> createState() => _TeamScreenState();
}

class _TeamScreenState extends ConsumerState<TeamScreen> {
  final ScrollController _scrollController = ScrollController();
  bool isReorderLocations = false;
  bool isReorderStaff = false;

  void _toggleLocationReorder() {
    setState(() {
      isReorderLocations = !isReorderLocations;
      if (isReorderLocations) isReorderStaff = false;
    });
    if (!isReorderLocations) {
      ref.read(teamReorderPanelProvider.notifier).setVisible(false);
    }
  }

  void _toggleStaffReorder() {
    setState(() {
      isReorderStaff = !isReorderStaff;
      if (isReorderStaff) isReorderLocations = false;
    });
    if (!isReorderStaff) {
      ref.read(teamReorderPanelProvider.notifier).setVisible(false);
    }
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final locations = ref.watch(sortedLocationsProvider);
    final isWide = ref.watch(formFactorProvider) != AppFormFactor.mobile;
    final showReorderPanel = ref.watch(teamReorderPanelProvider);

    ref.listen<bool>(teamReorderPanelProvider, (previous, next) {
      if (!next && (isReorderLocations || isReorderStaff)) {
        setState(() {
          isReorderLocations = false;
          isReorderStaff = false;
        });
      }
    });

    if (locations.isEmpty) {
      return const SizedBox.shrink();
    }

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: () {},
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (showReorderPanel) ...[
            Padding(
              padding: const EdgeInsets.all(16),
              child: Center(
                child: Column(
                  children: [
                    Text(
                      context.l10n.reorderTitle,
                      style: Theme.of(context).textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(0, 4, 0, 8),
                      child: Text(
                        context.l10n.teamReorderHelpDescription,
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          color: Theme.of(context).colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ),
                    ReorderTogglePanel(
                      isWide: isWide,
                      children: [
                        ReorderToggleButton(
                          isActive: isReorderLocations,
                          onPressed: _toggleLocationReorder,
                          activeLabel: context.l10n.teamLocationsLabel,
                          inactiveLabel: context.l10n.teamLocationsLabel,
                          activeIcon: Icons.check,
                          inactiveIcon: Icons.drag_indicator,
                        ),
                        ReorderToggleButton(
                          isActive: isReorderStaff,
                          onPressed: _toggleStaffReorder,
                          activeLabel: context.l10n.teamStaffLabel,
                          inactiveLabel: context.l10n.teamStaffLabel,
                          activeIcon: Icons.check,
                          inactiveIcon: Icons.drag_indicator,
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ],
          Expanded(
            child: isReorderLocations
                ? _buildReorderLocations(context, ref, locations)
                : isReorderStaff
                ? _buildReorderStaff(context, ref, locations)
                : _buildNormalList(context, ref, locations, isWide),
          ),
        ],
      ),
    );
  }

  Widget _buildReorderLocations(
    BuildContext context,
    WidgetRef ref,
    List<Location> locations,
  ) {
    final notifier = ref.read(teamReorderProvider.notifier);
    final colorScheme = Theme.of(context).colorScheme;
    return ReorderableListView.builder(
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 100),
      buildDefaultDragHandles: false,
      proxyDecorator: (child, index, animation) => child,
      itemCount: locations.length,
      onReorder: (oldIndex, newIndex) =>
          notifier.reorderLocations(oldIndex, newIndex),
      itemBuilder: (context, index) {
        final loc = locations[index];
        return Container(
          key: ValueKey('loc-${loc.id}'),
          margin: const EdgeInsets.only(bottom: 16),
          decoration: BoxDecoration(
            color: colorScheme.surface,
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: colorScheme.outlineVariant.withOpacity(0.4),
            ),
          ),
          child: ListTile(
            leading: ReorderableDragStartListener(
              index: index,
              child: const Icon(Icons.drag_indicator),
            ),
            title: Text(loc.name),
          ),
        );
      },
    );
  }

  Widget _buildReorderStaff(
    BuildContext context,
    WidgetRef ref,
    List<Location> locations,
  ) {
    final notifier = ref.read(teamReorderProvider.notifier);
    final colorScheme = Theme.of(context).colorScheme;

    final staffByLocation = <int, List<Staff>>{
      for (final loc in locations)
        loc.id: ref.watch(staffByLocationProvider(loc.id)),
    };

    final rows = <({bool isHeader, int locationId, Staff? staff})>[];
    for (final loc in locations) {
      rows.add((isHeader: true, locationId: loc.id, staff: null));
      for (final member in staffByLocation[loc.id] ?? const <Staff>[]) {
        rows.add((isHeader: false, locationId: loc.id, staff: member));
      }
    }

    int indexInLocation(int rowIndex) {
      final locationId = rows[rowIndex].locationId;
      int count = 0;
      for (int i = 0; i < rowIndex; i++) {
        final row = rows[i];
        if (!row.isHeader && row.locationId == locationId) count++;
      }
      return count;
    }

    return ReorderableListView.builder(
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 100),
      buildDefaultDragHandles: false,
      proxyDecorator: (child, index, animation) => child,
      itemCount: rows.length,
      onReorder: (oldIndex, newIndex) {
        if (newIndex > oldIndex) newIndex -= 1;
        if (newIndex >= rows.length) newIndex = rows.length - 1;
        final moving = rows[oldIndex];
        if (moving.isHeader) return;
        if (rows[newIndex].isHeader) {
          if (rows[newIndex].locationId == moving.locationId) {
            newIndex = (newIndex + 1).clamp(0, rows.length - 1);
          } else {
            return;
          }
        }
        final target = rows[newIndex];
        if (target.locationId != moving.locationId) return;
        notifier.reorderStaffForLocation(
          moving.locationId,
          indexInLocation(oldIndex),
          indexInLocation(newIndex),
        );
      },
      itemBuilder: (context, index) {
        final row = rows[index];
        if (row.isHeader) {
          final loc = locations.firstWhere((l) => l.id == row.locationId);
          return Container(
            key: ValueKey('header-${loc.id}'),
            width: double.infinity,
            margin: const EdgeInsets.only(top: 16, bottom: 6),
            decoration: BoxDecoration(
              color: colorScheme.primaryContainer,
              borderRadius: const BorderRadius.vertical(
                top: Radius.circular(16),
              ),
            ),
            padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),
            child: Text(
              loc.name,
              style: Theme.of(context).textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w600,
                color: colorScheme.onPrimaryContainer,
              ),
            ),
          );
        }

        final member = row.staff!;
        return Container(
          key: ValueKey('staff-${row.locationId}-${member.id}'),
          margin: const EdgeInsets.only(bottom: 6),
          decoration: BoxDecoration(
            color: colorScheme.surface,
            borderRadius: BorderRadius.circular(10),
            border: Border.all(
              color: colorScheme.outlineVariant.withOpacity(0.7),
            ),
          ),
          child: ListTile(
            leading: ReorderableDragStartListener(
              index: index,
              child: const Icon(Icons.drag_indicator),
            ),
            title: Text(member.displayName),
            dense: true,
            contentPadding: const EdgeInsets.symmetric(
              horizontal: 12,
              vertical: 4,
            ),
          ),
        );
      },
    );
  }

  Widget _buildNormalList(
    BuildContext context,
    WidgetRef ref,
    List<Location> locations,
    bool isWide,
  ) {
    return ListView.builder(
      controller: _scrollController,
      padding: const EdgeInsets.fromLTRB(16, 0, 16, 24),
      itemCount: locations.length,
      itemBuilder: (context, index) {
        final loc = locations[index];
        final staff = ref.watch(staffByLocationProvider(loc.id));
        return LocationItem(
          location: loc,
          staff: staff,
          isWide: isWide,
          onAddStaff: () =>
              showStaffDialog(context, ref, initialLocationId: loc.id),
          onEditLocation: () => showLocationDialog(context, ref, initial: loc),
          onDeleteLocation: () async {
            if (staff.isNotEmpty) {
              await showAppInfoDialog(
                context,
                title: Text(context.l10n.teamDeleteLocationBlockedTitle),
                content: Text(context.l10n.teamDeleteLocationBlockedMessage),
              );
              return;
            }
            final confirmed = await showConfirmDialog(
              context,
              title: Text(context.l10n.teamDeleteLocationTitle),
              content: Text(context.l10n.teamDeleteLocationMessage),
              confirmLabel: context.l10n.actionConfirm,
              cancelLabel: context.l10n.actionCancel,
            );
            if (confirmed == true) {
              ref.read(locationsProvider.notifier).delete(loc.id);
            }
          },
          onEditStaff: (staff) => showStaffDialog(context, ref, initial: staff),
          onDuplicateStaff: (staff) => showStaffDialog(
            context,
            ref,
            initial: staff,
            duplicateFrom: true,
          ),
          onDeleteStaff: (staff) async {
            final confirmed = await showConfirmDialog(
              context,
              title: Text(context.l10n.teamDeleteStaffTitle),
              content: Text(context.l10n.teamDeleteStaffMessage),
              confirmLabel: context.l10n.actionConfirm,
              cancelLabel: context.l10n.actionCancel,
            );
            if (confirmed == true) {
              ref.read(allStaffProvider.notifier).delete(staff.id);
            }
          },
        );
      },
    );
  }
}
--- FILE: lib/features/staff/presentation/dialogs/add_exception_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:agenda_backend/core/widgets/app_bottom_sheet.dart';
import 'package:agenda_backend/core/widgets/labeled_form_field.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/availability_exception.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../agenda/providers/layout_config_provider.dart';
import '../../presentation/staff_availability_screen.dart';
import '../../providers/availability_exceptions_provider.dart';
import 'package:intl/intl.dart';

/// Mostra il dialog per creare o modificare un'eccezione alla disponibilit√†.
Future<void> showAddExceptionDialog(
  BuildContext context,
  WidgetRef ref, {
  AvailabilityException? initial,
  DateTime? date,
  TimeOfDay? time,
  required int staffId,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final isDesktop = formFactor == AppFormFactor.desktop;

  final dialog = _AddExceptionDialog(
    initial: initial,
    initialDate: date,
    initialTime: time,
    staffId: staffId,
    presentation: isDesktop
        ? _ExceptionDialogPresentation.dialog
        : _ExceptionDialogPresentation.bottomSheet,
  );

  if (isDesktop) {
    await showDialog(context: context, builder: (_) => dialog);
  } else {
    await AppBottomSheet.show(
      context: context,
      useRootNavigator: true,
      padding: const EdgeInsets.fromLTRB(16, 12, 16, 20),
      builder: (_) => dialog,
    );
  }
}

enum _ExceptionDialogPresentation { dialog, bottomSheet }

/// Modalit√† di selezione del periodo
enum _PeriodMode { single, range, duration }

class _AddExceptionDialog extends ConsumerStatefulWidget {
  const _AddExceptionDialog({
    this.initial,
    this.initialDate,
    this.initialTime,
    required this.staffId,
    required this.presentation,
  });

  final AvailabilityException? initial;
  final DateTime? initialDate;
  final TimeOfDay? initialTime;
  final int staffId;
  final _ExceptionDialogPresentation presentation;

  @override
  ConsumerState<_AddExceptionDialog> createState() =>
      _AddExceptionDialogState();
}

class _AddExceptionDialogState extends ConsumerState<_AddExceptionDialog> {
  // Modalit√† periodo (solo per nuove eccezioni)
  _PeriodMode _periodMode = _PeriodMode.single;

  // Date
  late DateTime _date; // Per singolo giorno
  late DateTime _startDate; // Per range/durata
  late DateTime _endDate; // Per range
  int _durationDays = 7; // Per durata

  // Orari
  late TimeOfDay _startTime;
  late TimeOfDay _endTime;
  late AvailabilityExceptionType _type;
  final _reasonController = TextEditingController();
  String? _timeError;
  String? _validationError;
  bool _isSaving = false;
  Map<DateTime, String> _lastSkippedReasons = {};

  @override
  void initState() {
    super.initState();

    if (widget.initial != null) {
      final exc = widget.initial!;
      _date = DateTime(exc.date.year, exc.date.month, exc.date.day);
      _startDate = _date;
      _endDate = _date;
      if (exc.isAllDay) {
        _startTime = const TimeOfDay(hour: 0, minute: 0);
        _endTime = const TimeOfDay(hour: 24, minute: 0);
      } else {
        _startTime = exc.startTime ?? const TimeOfDay(hour: 9, minute: 0);
        _endTime = exc.endTime ?? const TimeOfDay(hour: 18, minute: 0);
      }
      _type = exc.type;
      _reasonController.text = exc.reason ?? '';
    } else {
      _date = DateUtils.dateOnly(widget.initialDate ?? DateTime.now());
      _startDate = _date;
      _endDate = _date.add(const Duration(days: 6)); // Default 1 settimana
      _startTime = widget.initialTime ?? const TimeOfDay(hour: 9, minute: 0);
      _endTime = TimeOfDay(
        hour: _startTime.hour + 1,
        minute: _startTime.minute,
      );
      _type = AvailabilityExceptionType.unavailable;
    }
  }

  @override
  void dispose() {
    _reasonController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final isEdit = widget.initial != null;
    final isDialog = widget.presentation == _ExceptionDialogPresentation.dialog;

    final title = isEdit
        ? l10n.exceptionDialogTitleEdit
        : l10n.exceptionDialogTitleNew;

    final content = Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Tipo eccezione
        LabeledFormField(
          label: l10n.exceptionType,
          child: SegmentedButton<AvailabilityExceptionType>(
            segments: [
              ButtonSegment(
                value: AvailabilityExceptionType.unavailable,
                label: Text(l10n.exceptionTypeUnavailable),
                icon: const Icon(Icons.block, size: 18),
              ),
              ButtonSegment(
                value: AvailabilityExceptionType.available,
                label: Text(l10n.exceptionTypeAvailable),
                icon: const Icon(Icons.check_circle_outline, size: 18),
              ),
            ],
            selected: {_type},
            onSelectionChanged: (selected) {
              setState(() {
                _type = selected.first;
                _validationError = null;
              });
            },
          ),
        ),
        const SizedBox(height: 16),

        // Modalit√† periodo (solo per nuove eccezioni)
        if (!isEdit) ...[
          LabeledFormField(
            label: l10n.exceptionPeriodMode,
            child: SegmentedButton<_PeriodMode>(
              segments: [
                ButtonSegment(
                  value: _PeriodMode.single,
                  label: Text(l10n.exceptionPeriodSingle),
                ),
                ButtonSegment(
                  value: _PeriodMode.range,
                  label: Text(l10n.exceptionPeriodRange),
                ),
                ButtonSegment(
                  value: _PeriodMode.duration,
                  label: Text(l10n.exceptionPeriodDuration),
                ),
              ],
              selected: {_periodMode},
              onSelectionChanged: (selected) {
                setState(() {
                  _periodMode = selected.first;
                  _validationError = null;
                });
              },
            ),
          ),
          const SizedBox(height: 16),
        ],

        // Sezione date in base alla modalit√†
        if (isEdit || _periodMode == _PeriodMode.single) ...[
          // Data singola
          LabeledFormField(
            label: l10n.formDate,
            child: InkWell(
              onTap: () => _pickSingleDate(),
              child: InputDecorator(
                decoration: const InputDecoration(
                  border: OutlineInputBorder(),
                  isDense: true,
                ),
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(_formatDate(_date)),
                    const Icon(Icons.calendar_today, size: 16),
                  ],
                ),
              ),
            ),
          ),
        ] else if (_periodMode == _PeriodMode.range) ...[
          // Range date: Da - A
          Row(
            children: [
              Expanded(
                child: LabeledFormField(
                  label: l10n.exceptionDateFrom,
                  child: InkWell(
                    onTap: () => _pickStartDate(),
                    child: InputDecorator(
                      decoration: const InputDecoration(
                        border: OutlineInputBorder(),
                        isDense: true,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_formatDate(_startDate)),
                          const Icon(Icons.calendar_today, size: 16),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: LabeledFormField(
                  label: l10n.exceptionDateTo,
                  child: InkWell(
                    onTap: () => _pickEndDate(),
                    child: InputDecorator(
                      decoration: const InputDecoration(
                        border: OutlineInputBorder(),
                        isDense: true,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_formatDate(_endDate)),
                          const Icon(Icons.calendar_today, size: 16),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
          // Info giorni totali
          Padding(
            padding: const EdgeInsets.only(top: 8),
            child: Text(
              l10n.exceptionDurationDays(_calculateDays()),
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.primary,
              ),
            ),
          ),
        ] else if (_periodMode == _PeriodMode.duration) ...[
          // Durata: Data inizio + numero giorni
          Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Expanded(
                flex: 2,
                child: LabeledFormField(
                  label: l10n.exceptionDateFrom,
                  child: InkWell(
                    onTap: () => _pickStartDate(),
                    child: InputDecorator(
                      decoration: const InputDecoration(
                        border: OutlineInputBorder(),
                        isDense: true,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_formatDate(_startDate)),
                          const Icon(Icons.calendar_today, size: 16),
                        ],
                      ),
                    ),
                  ),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: LabeledFormField(
                  label: l10n.exceptionDuration,
                  child: _DurationDropdown(
                    value: _durationDays,
                    onChanged: (v) => setState(() {
                      _durationDays = v;
                      _validationError = null;
                    }),
                  ),
                ),
              ),
            ],
          ),
          // Info data fine calcolata
          Padding(
            padding: const EdgeInsets.only(top: 8),
            child: Text(
              '‚Üí ${_formatDate(_startDate.add(Duration(days: _durationDays - 1)))}',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.primary,
              ),
            ),
          ),
        ],
        const SizedBox(height: 12),

        // Orari
        Row(
          children: [
            Expanded(
              child: LabeledFormField(
                label: l10n.exceptionStartTime,
                child: InkWell(
                  onTap: () => _pickTime(isStart: true),
                  child: InputDecorator(
                    decoration: InputDecoration(
                      border: const OutlineInputBorder(),
                      isDense: true,
                      enabledBorder: _timeError != null
                          ? OutlineInputBorder(
                              borderSide: BorderSide(
                                color: Theme.of(context).colorScheme.error,
                              ),
                            )
                          : null,
                    ),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Text(_formatTime(_startTime)),
                        const Icon(Icons.schedule, size: 16),
                      ],
                    ),
                  ),
                ),
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: LabeledFormField(
                label: l10n.exceptionEndTime,
                child: InkWell(
                  onTap: () => _pickTime(isStart: false),
                  child: InputDecorator(
                    decoration: InputDecoration(
                      border: const OutlineInputBorder(),
                      isDense: true,
                      enabledBorder: _timeError != null
                          ? OutlineInputBorder(
                              borderSide: BorderSide(
                                color: Theme.of(context).colorScheme.error,
                              ),
                            )
                          : null,
                    ),
                    child: Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Text(_formatTime(_endTime)),
                        const Icon(Icons.schedule, size: 16),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ],
        ),
        if (_timeError != null)
          Padding(
            padding: const EdgeInsets.only(top: 6, left: 12),
            child: Text(
              _timeError!,
              style: TextStyle(
                color: Theme.of(context).colorScheme.error,
                fontSize: 12,
              ),
            ),
          ),
        if (_validationError != null)
          Padding(
            padding: const EdgeInsets.only(top: 6, left: 12),
            child: Text(
              _validationError!,
              style: TextStyle(
                color: Theme.of(context).colorScheme.error,
                fontSize: 12,
              ),
            ),
          ),
        const SizedBox(height: 12),

        // Motivo opzionale
        LabeledFormField(
          label: l10n.exceptionReason,
          child: TextField(
            controller: _reasonController,
            decoration: InputDecoration(
              hintText: l10n.exceptionReasonHint,
              border: const OutlineInputBorder(),
              isDense: true,
            ),
          ),
        ),
      ],
    );

    final actions = [
      if (isEdit)
        AppDangerButton(
          onPressed: _isSaving ? null : _onDelete,
          padding: AppButtonStyles.dialogButtonPadding,
          child: Text(l10n.actionDelete),
        ),
      AppOutlinedActionButton(
        onPressed: _isSaving ? null : () => Navigator.of(context).pop(),
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppFilledButton(
        onPressed: _isSaving ? null : _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        child: _isSaving
            ? const SizedBox(
                width: 16,
                height: 16,
                child: CircularProgressIndicator(strokeWidth: 2),
              )
            : Text(l10n.actionSave),
      ),
    ];

    final bottomActions = actions
        .map(
          (a) => SizedBox(width: AppButtonStyles.dialogButtonWidth, child: a),
        )
        .toList();

    if (isDialog) {
      return DismissibleDialog(
        child: Dialog(
          insetPadding: const EdgeInsets.symmetric(
            horizontal: 32,
            vertical: 24,
          ),
          child: ConstrainedBox(
            constraints: const BoxConstraints(minWidth: 500, maxWidth: 600),
            child: Padding(
              padding: const EdgeInsets.all(20),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Text(title, style: Theme.of(context).textTheme.headlineSmall),
                  const SizedBox(height: 16),
                  Flexible(child: SingleChildScrollView(child: content)),
                  const SizedBox(height: 24),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      if (isEdit) ...[
                        bottomActions.first,
                        const Spacer(),
                        bottomActions[1],
                      ] else
                        bottomActions[0],
                      const SizedBox(width: 8),
                      bottomActions.last,
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      );
    }

    return SafeArea(
      top: false,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final isKeyboardOpen =
              MediaQuery.of(context).viewInsets.bottom > 0;
          return SizedBox(
            height: constraints.maxHeight,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Expanded(
                  child: SingleChildScrollView(
                    padding: EdgeInsets.zero,
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Padding(
                          padding: const EdgeInsets.only(bottom: 12),
                          child: Text(
                            title,
                            style: Theme.of(context).textTheme.titleLarge,
                          ),
                        ),
                        content,
                        const SizedBox(height: 24),
                        const SizedBox(height: AppSpacing.formRowSpacing),
                      ],
                    ),
                  ),
                ),
                if (!isKeyboardOpen) ...[
                  const AppBottomSheetDivider(),
                  Padding(
                    padding: const EdgeInsets.fromLTRB(0, 12, 0, 0),
                    child: Align(
                      alignment: bottomActions.length == 3
                          ? Alignment.center
                          : Alignment.centerRight,
                      child: Wrap(
                        alignment: bottomActions.length == 3
                            ? WrapAlignment.center
                            : WrapAlignment.end,
                        spacing: 8,
                        runSpacing: 8,
                        children: bottomActions,
                      ),
                    ),
                  ),
                ],
                SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
              ],
            ),
          );
        },
      ),
    );
  }

  String _formatTime(TimeOfDay time) {
    return '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';
  }

  String _formatDate(DateTime date) {
    return '${date.day.toString().padLeft(2, '0')}/${date.month.toString().padLeft(2, '0')}/${date.year}';
  }

  int _calculateDays() {
    return _endDate.difference(_startDate).inDays + 1;
  }

  Future<void> _pickSingleDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _date,
      firstDate: DateTime.now().subtract(const Duration(days: 30)),
      lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
    );
    if (picked != null) {
      setState(() {
        _date = DateUtils.dateOnly(picked);
        _validationError = null;
      });
    }
  }

  Future<void> _pickStartDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _startDate,
      firstDate: DateTime.now().subtract(const Duration(days: 30)),
      lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
    );
    if (picked != null) {
      setState(() {
        _startDate = DateUtils.dateOnly(picked);
        _validationError = null;
        // Se la data di fine √® prima della data di inizio, aggiornala
        if (_endDate.isBefore(_startDate)) {
          _endDate = _startDate.add(Duration(days: _durationDays - 1));
        }
      });
    }
  }

  Future<void> _pickEndDate() async {
    final picked = await showDatePicker(
      context: context,
      initialDate: _endDate.isBefore(_startDate) ? _startDate : _endDate,
      firstDate: _startDate,
      lastDate: DateTime.now().add(const Duration(days: 365 * 2)),
    );
    if (picked != null) {
      setState(() {
        _endDate = DateUtils.dateOnly(picked);
        _validationError = null;
      });
    }
  }

  Future<void> _pickTime({required bool isStart}) async {
    final step = ref.read(layoutConfigProvider).minutesPerSlot;
    final selected = await AppBottomSheet.show<TimeOfDay>(
      context: context,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      builder: (ctx) {
        final height = MediaQuery.of(ctx).size.height * 0.7;
        return SizedBox(
          height: height,
          child: _TimeGridPicker(
            initial: isStart ? _startTime : _endTime,
            stepMinutes: step,
          ),
        );
      },
    );
    if (selected != null) {
      setState(() {
        _timeError = null;
        _validationError = null;
        if (isStart) {
          _startTime = selected;
          // Se l'orario di fine √® prima dell'inizio, aggiustalo
          final startMinutes = _startTime.hour * 60 + _startTime.minute;
          final endMinutes = _endTime.hour * 60 + _endTime.minute;
          if (endMinutes <= startMinutes) {
            _endTime = TimeOfDay(
              hour: (_startTime.hour + 1).clamp(0, 23),
              minute: _startTime.minute,
            );
          }
        } else {
          _endTime = selected;
        }
      });
    }
  }

  List<DateTime>? _validatedDates() {
    final l10n = context.l10n;
    setState(() {
      _validationError = null;
      _timeError = null;
    });

    final startMinutes = _startTime.hour * 60 + _startTime.minute;
    final endMinutes = _endTime.hour * 60 + _endTime.minute;
    if (endMinutes <= startMinutes) {
      setState(() => _timeError = l10n.exceptionTimeError);
      return null;
    }

    final availabilityByStaff =
        ref.read(staffAvailabilityByStaffProvider).value;
    if (availabilityByStaff == null) {
      if (widget.initial != null || _periodMode == _PeriodMode.single) {
        return <DateTime>[_date];
      }
      final DateTime startDate;
      final DateTime endDate;
      if (_periodMode == _PeriodMode.range) {
        startDate = _startDate;
        endDate = _endDate;
      } else {
        startDate = _startDate;
        endDate = _startDate.add(Duration(days: _durationDays - 1));
      }
      final dates = <DateTime>[];
      for (var d = startDate;
          !d.isAfter(endDate);
          d = d.add(const Duration(days: 1))) {
        dates.add(d);
      }
      return dates;
    }

    final layout = ref.read(layoutConfigProvider);
    final minutesPerSlot = layout.minutesPerSlot;

    Set<int> exceptionSlots() {
      final startMinutes = _startTime.hour * 60 + _startTime.minute;
      final endMinutes = _endTime.hour * 60 + _endTime.minute;
      final startSlot = startMinutes ~/ minutesPerSlot;
      final endSlot = endMinutes ~/ minutesPerSlot;
      return {for (int i = startSlot; i < endSlot; i++) i};
    }

    String? validateDate(DateTime date) {
      final baseSlots =
          availabilityByStaff[widget.staffId]?[date.weekday] ?? <int>{};
      final excSlots = exceptionSlots();
      if (_type == AvailabilityExceptionType.unavailable) {
        if (baseSlots.isEmpty) {
          return l10n.exceptionUnavailableNoBase;
        }
        if (baseSlots.intersection(excSlots).isEmpty) {
          return l10n.exceptionUnavailableNoOverlap;
        }
      } else {
        if (excSlots.difference(baseSlots).isEmpty) {
          return l10n.exceptionAvailableNoEffect;
        }
      }
      return null;
    }

    if (widget.initial != null || _periodMode == _PeriodMode.single) {
      final error = validateDate(_date);
      if (error != null) {
        setState(() => _validationError = error);
        return null;
      }
      return <DateTime>[_date];
    }

    final DateTime startDate;
    final DateTime endDate;
    if (_periodMode == _PeriodMode.range) {
      startDate = _startDate;
      endDate = _endDate;
    } else {
      startDate = _startDate;
      endDate = _startDate.add(Duration(days: _durationDays - 1));
    }

    final validDates = <DateTime>[];
    final skippedReasons = <DateTime, String>{};
    String? firstError;
    for (var d = startDate;
        !d.isAfter(endDate);
        d = d.add(const Duration(days: 1))) {
      final error = validateDate(d);
      if (error == null) {
        validDates.add(d);
      } else {
        firstError ??= error;
        skippedReasons[d] = error;
      }
    }

    if (validDates.isEmpty) {
      setState(() => _validationError = firstError);
      return null;
    }

    _lastSkippedReasons = {
      for (final entry in skippedReasons.entries)
        DateUtils.dateOnly(entry.key): entry.value,
    };
    return validDates;
  }

  Future<void> _onSave() async {
    final validDates = _validatedDates();
    if (validDates == null || validDates.isEmpty) return;

    setState(() => _isSaving = true);

    try {
      final notifier = ref.read(availabilityExceptionsProvider.notifier);
      final reason = _reasonController.text.trim();

      if (widget.initial != null) {
        // Modifica eccezione esistente (solo singolo giorno)
        final updated = widget.initial!.copyWith(
          date: validDates.first,
          startTime: _startTime,
          endTime: _endTime,
          type: _type,
          reason: reason.isEmpty ? null : reason,
          clearReason: reason.isEmpty,
        );
        await notifier.updateException(updated);
      } else {
        // Nuova eccezione - gestisci in base alla modalit√†
        if (_periodMode == _PeriodMode.single) {
          // Singolo giorno
          await notifier.addException(
            staffId: widget.staffId,
            date: validDates.first,
            startTime: _startTime,
            endTime: _endTime,
            type: _type,
            reason: reason.isEmpty ? null : reason,
          );
        } else {
          // Periodo (range o durata) - salva solo le date congruenti
          final DateTime startDate;
          final DateTime endDate;
          if (_periodMode == _PeriodMode.range) {
            startDate = _startDate;
            endDate = _endDate;
          } else {
            startDate = _startDate;
            endDate = _startDate.add(Duration(days: _durationDays - 1));
          }
          var totalDays = 0;
          final skippedDates = <DateTime>[];
          final skippedDetails = <String>[];
          for (var d = startDate;
              !d.isAfter(endDate);
              d = d.add(const Duration(days: 1))) {
            totalDays++;
          }
          for (final d in validDates) {
            await notifier.addException(
              staffId: widget.staffId,
              date: d,
              startTime: _startTime,
              endTime: _endTime,
              type: _type,
              reason: reason.isEmpty ? null : reason,
            );
          }
          if (validDates.length < totalDays) {
            for (var d = startDate;
                !d.isAfter(endDate);
                d = d.add(const Duration(days: 1))) {
              final isValid = validDates.any(
                (v) => DateUtils.isSameDay(v, d),
              );
              if (!isValid) {
                skippedDates.add(d);
              }
            }
          }
          if (mounted && skippedDates.isNotEmpty) {
            final locale = Localizations.localeOf(context).toLanguageTag();
            final formatter = DateFormat('d MMM', locale);
            for (final d in skippedDates) {
              final reason =
                  _lastSkippedReasons[DateUtils.dateOnly(d)] ?? '';
              final dateLabel = formatter.format(d);
              if (reason.isEmpty) {
                skippedDetails.add(dateLabel);
              } else {
                skippedDetails.add('$dateLabel ‚Äî $reason');
              }
            }
            await showDialog<void>(
              context: context,
              builder: (ctx) => AlertDialog(
                title: Text(ctx.l10n.exceptionPartialSaveTitle),
                content: SizedBox(
                  width: 420,
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(ctx.l10n.exceptionPartialSaveMessage),
                      const SizedBox(height: 12),
                      ConstrainedBox(
                        constraints: const BoxConstraints(maxHeight: 240),
                        child: ListView.separated(
                          shrinkWrap: true,
                          itemCount: skippedDetails.length,
                          separatorBuilder: (_, __) => const SizedBox(height: 6),
                          itemBuilder: (context, index) => Text(
                            '‚Ä¢ ${skippedDetails[index]}',
                            style: Theme.of(context).textTheme.bodySmall,
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
                actions: [
                  TextButton(
                    onPressed: () => Navigator.of(ctx).pop(),
                    child: Text(ctx.l10n.actionConfirm),
                  ),
                ],
              ),
            );
          }
        }
      }

      if (mounted) {
        Navigator.of(context).pop();
      }
    } finally {
      if (mounted) {
        setState(() => _isSaving = false);
      }
    }
  }

  Future<void> _onDelete() async {
    if (widget.initial == null) return;

    final l10n = context.l10n;
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: Text(l10n.exceptionDeleteTitle),
        content: Text(l10n.exceptionDeleteMessage),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(false),
            child: Text(l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () => Navigator.of(ctx).pop(true),
            style: FilledButton.styleFrom(
              backgroundColor: Theme.of(ctx).colorScheme.error,
            ),
            child: Text(l10n.actionDelete),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await ref
          .read(availabilityExceptionsProvider.notifier)
          .deleteException(widget.staffId, widget.initial!.id);

      if (mounted) {
        Navigator.of(context).pop();
      }
    }
  }
}

/// Semplice picker griglia per selezionare un orario.
class _TimeGridPicker extends StatefulWidget {
  const _TimeGridPicker({required this.initial, required this.stepMinutes});

  final TimeOfDay initial;
  final int stepMinutes;

  @override
  State<_TimeGridPicker> createState() => _TimeGridPickerState();
}

class _TimeGridPickerState extends State<_TimeGridPicker> {
  late TimeOfDay _selected;
  late final ScrollController _scrollController;
  late final List<TimeOfDay?> _times;
  late final int _scrollToIndex;

  @override
  void initState() {
    super.initState();
    _selected = widget.initial;
    _scrollController = ScrollController();

    // Genera tutte le opzioni di orario con 4 colonne per riga
    _times = <TimeOfDay?>[];
    for (int h = 0; h < 24; h++) {
      for (int m = 0; m < 60; m += widget.stepMinutes) {
        _times.add(TimeOfDay(hour: h, minute: m));
      }
    }
    // Aggiungi 24:00 come opzione finale
    _times.add(const TimeOfDay(hour: 24, minute: 0));

    // Verifica se l'orario iniziale √® gi√† nella lista
    int exactIndex = _times.indexWhere(
      (t) =>
          t != null &&
          t.hour == widget.initial.hour &&
          t.minute == widget.initial.minute,
    );

    if (exactIndex >= 0) {
      // L'orario √® gi√† presente
      _scrollToIndex = exactIndex;
    } else {
      // L'orario non √® presente: inserisci una NUOVA RIGA con l'orario
      // nella colonna corretta e le altre colonne vuote
      final columnsPerRow = 60 ~/ widget.stepMinutes;
      final targetColumn = widget.initial.minute ~/ widget.stepMinutes;
      final baseIndex = (widget.initial.hour + 1) * columnsPerRow;

      // Crea la nuova riga con 4 elementi (solo uno valorizzato)
      final newRow = List<TimeOfDay?>.filled(columnsPerRow, null);
      newRow[targetColumn] = widget.initial;

      // Inserisci la nuova riga
      final insertIndex = baseIndex.clamp(0, _times.length);
      _times.insertAll(insertIndex, newRow);

      // L'indice dell'orario selezionato √® la posizione nella nuova riga
      _scrollToIndex = insertIndex + targetColumn;
    }

    // Scroll all'orario dopo il primo frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _scrollToSelected();
    });
  }

  void _scrollToSelected() {
    if (!_scrollController.hasClients) return;

    const crossAxisCount = 4;
    const mainAxisSpacing = 8.0;
    const childAspectRatio = 2.5;
    const padding = 8.0;

    // Usa la larghezza effettiva del context
    final screenWidth = MediaQuery.of(context).size.width;
    final availableWidth = screenWidth - padding * 2;
    final itemWidth =
        (availableWidth - (crossAxisCount - 1) * 8) / crossAxisCount;
    final itemHeight = itemWidth / childAspectRatio;
    final rowHeight = itemHeight + mainAxisSpacing;

    final targetRow = _scrollToIndex ~/ crossAxisCount;

    final viewportHeight = _scrollController.position.viewportDimension;
    // Offset aggiuntivo per centrare meglio (compensa header visivo)
    const headerOffset = 40.0;
    final targetOffset =
        (targetRow * rowHeight) -
        (viewportHeight / 2) +
        (rowHeight / 2) +
        headerOffset;

    final maxScroll = _scrollController.position.maxScrollExtent;
    final clampedOffset = targetOffset.clamp(0.0, maxScroll);

    _scrollController.animateTo(
      clampedOffset,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeOut,
    );
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Text(
                context.l10n.exceptionSelectTime,
                style: theme.textTheme.titleMedium,
              ),
              const SizedBox.shrink(),
            ],
          ),
        ),
        const AppBottomSheetDivider(),
        Expanded(
          child: GridView.builder(
            controller: _scrollController,
            padding: const EdgeInsets.all(8),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 4,
              childAspectRatio: 2.5,
              crossAxisSpacing: 8,
              mainAxisSpacing: 8,
            ),
            itemCount: _times.length,
            itemBuilder: (context, index) {
              final time = _times[index];
              // Se la cella √® vuota, mostra uno spazio vuoto
              if (time == null) {
                return const SizedBox.shrink();
              }
              final isSelected =
                  time.hour == _selected.hour && time.minute == _selected.minute;
              final label = time.hour == 24
                  ? '24:00'
                  : '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';

              return Material(
                color: isSelected
                    ? colorScheme.primaryContainer
                    : colorScheme.surfaceContainerHighest,
                borderRadius: BorderRadius.circular(8),
                child: InkWell(
                  onTap: () => Navigator.of(context).pop(time),
                  borderRadius: BorderRadius.circular(8),
                  child: Center(
                    child: Text(
                      label,
                      style: TextStyle(
                        fontWeight: isSelected
                            ? FontWeight.bold
                            : FontWeight.normal,
                        color: isSelected
                            ? colorScheme.onPrimaryContainer
                            : colorScheme.onSurface,
                      ),
                    ),
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }
}

/// Widget dropdown per selezionare la durata in giorni.
class _DurationDropdown extends StatelessWidget {
  const _DurationDropdown({required this.value, required this.onChanged});

  final int value;
  final ValueChanged<int> onChanged;

  static const List<int> _options = [
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    10,
    14,
    21,
    30,
    60,
    90,
  ];

  @override
  Widget build(BuildContext context) {
    return DropdownButtonFormField<int>(
      value: _options.contains(value) ? value : 7,
      decoration: const InputDecoration(
        border: OutlineInputBorder(),
        isDense: true,
        contentPadding: EdgeInsets.symmetric(horizontal: 12, vertical: 12),
      ),
      items: _options.map((days) {
        return DropdownMenuItem(value: days, child: Text('$days'));
      }).toList(),
      onChanged: (v) {
        if (v != null) onChanged(v);
      },
    );
  }
}
--- FILE: lib/features/staff/presentation/dialogs/location_dialog.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/providers/form_factor_provider.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/location.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/labeled_form_field.dart';
import '../../../../app/theme/app_spacing.dart';
import '../../../agenda/providers/business_providers.dart';
import '../../../agenda/providers/location_providers.dart';

Future<void> showLocationDialog(
  BuildContext context,
  WidgetRef ref, {
  Location? initial,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final isDesktop = formFactor == AppFormFactor.desktop;

  final dialog = _LocationDialog(initial: initial);

  if (isDesktop) {
    await showDialog(context: context, builder: (_) => dialog);
  } else {
    await AppBottomSheet.show(
      context: context,
      builder: (_) => dialog,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      heightFactor: AppBottomSheet.defaultHeightFactor,
    );
  }
}

class _LocationDialog extends ConsumerStatefulWidget {
  const _LocationDialog({this.initial});

  final Location? initial;

  bool get isEditing => initial != null;

  @override
  ConsumerState<_LocationDialog> createState() => _LocationDialogState();
}

class _LocationDialogState extends ConsumerState<_LocationDialog> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _addressController = TextEditingController();

  @override
  void initState() {
    super.initState();
    if (widget.initial != null) {
      _nameController.text = widget.initial!.name;
      _addressController.text = widget.initial!.address ?? '';
    }
  }

  @override
  void dispose() {
    _nameController.dispose();
    _addressController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final title = widget.isEditing
        ? l10n.teamEditLocationTitle
        : l10n.teamNewLocationTitle;

    final actions = [
      AppOutlinedActionButton(
        onPressed: () => Navigator.of(context).pop(),
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppFilledButton(
        onPressed: _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionSave),
      ),
    ];

    final bottomActions = actions
        .map(
          (a) => SizedBox(width: AppButtonStyles.dialogButtonWidth, child: a),
        )
        .toList();

    final nameField = LabeledFormField(
      label: l10n.teamLocationNameLabel,
      child: TextFormField(
        controller: _nameController,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        validator: (v) =>
            v == null || v.trim().isEmpty ? l10n.validationRequired : null,
      ),
    );

    final addressField = LabeledFormField(
      label: l10n.teamLocationAddressLabel,
      child: TextFormField(
        controller: _addressController,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
      ),
    );

    final content = Form(
      key: _formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        mainAxisSize: MainAxisSize.min,
        children: [
          nameField,
          const SizedBox(height: AppSpacing.formRowSpacing),
          addressField,
        ],
      ),
    );

    if (ref.read(formFactorProvider) == AppFormFactor.desktop) {
      return Dialog(
        insetPadding: const EdgeInsets.symmetric(horizontal: 32, vertical: 24),
        child: ConstrainedBox(
          constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
          child: Padding(
            padding: const EdgeInsets.all(20),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Text(title, style: Theme.of(context).textTheme.headlineSmall),
                const SizedBox(height: 16),
                Flexible(child: SingleChildScrollView(child: content)),
                const SizedBox(height: 24),
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    for (int i = 0; i < bottomActions.length; i++) ...[
                      if (i > 0) const SizedBox(width: 8),
                      bottomActions[i],
                    ],
                  ],
                ),
              ],
            ),
          ),
        ),
      );
    }

    return SafeArea(
      top: false,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final isKeyboardOpen =
              MediaQuery.of(context).viewInsets.bottom > 0;
          return SizedBox(
            height: constraints.maxHeight,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Expanded(
                  child: SingleChildScrollView(
                    child: Padding(
                      padding: EdgeInsets.only(
                        left: 16,
                        right: 16,
                        top: 12,
                        bottom: 0,
                      ),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Padding(
                            padding: const EdgeInsets.only(bottom: 12),
                            child: Text(
                              title,
                              style: Theme.of(context).textTheme.titleLarge,
                            ),
                          ),
                          content,
                          const SizedBox(height: 24),
                        ],
                      ),
                    ),
                  ),
                ),
                if (!isKeyboardOpen) ...[
                  const AppBottomSheetDivider(),
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                    child: Align(
                      alignment: bottomActions.length == 3
                          ? Alignment.center
                          : Alignment.centerRight,
                      child: Wrap(
                        alignment: bottomActions.length == 3
                            ? WrapAlignment.center
                            : WrapAlignment.end,
                        spacing: 8,
                        runSpacing: 8,
                        children: bottomActions,
                      ),
                    ),
                  ),
                ],
                SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
              ],
            ),
          );
        },
      ),
    );
  }

  void _onSave() {
    if (!_formKey.currentState!.validate()) return;
    final notifier = ref.read(locationsProvider.notifier);
    final business = ref.read(currentBusinessProvider);
    final name = _nameController.text.trim();
    final address = _addressController.text.trim();

    if (widget.initial != null) {
      notifier.update(
        widget.initial!.copyWith(
          name: name,
          address: address.isEmpty ? null : address,
        ),
      );
    } else {
      notifier.add(
        Location(
          id: notifier.nextId(),
          businessId: business.id,
          name: name,
          address: address.isEmpty ? null : address,
        ),
      );
    }
    Navigator.of(context).pop();
  }
}
--- FILE: lib/features/staff/presentation/dialogs/staff_dialog.dart ---
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/app_constants.dart';
import '../../../../app/providers/form_factor_provider.dart';
import '../../../../app/theme/app_spacing.dart';
import '../../../../app/widgets/staff_circle_avatar.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/staff.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/app_switch.dart';
import '../../../../core/widgets/labeled_form_field.dart';
import '../../../agenda/providers/business_providers.dart';
import '../../../agenda/providers/location_providers.dart';
import '../../../services/presentation/widgets/service_eligibility_selector.dart';
import '../../../services/providers/service_categories_provider.dart';
import '../../../services/providers/services_provider.dart';
import '../../providers/staff_providers.dart';

Future<void> showStaffDialog(
  BuildContext context,
  WidgetRef ref, {
  Staff? initial,
  int? initialLocationId,
  bool duplicateFrom = false,
}) async {
  final formFactor = ref.read(formFactorProvider);
  final isDesktop = formFactor == AppFormFactor.desktop;

  final dialog = _StaffDialog(
    initial: initial,
    initialLocationId: initialLocationId,
    isDuplicating: duplicateFrom,
  );

  if (isDesktop) {
    await showDialog(context: context, builder: (_) => dialog);
  } else {
    await AppBottomSheet.show(
      context: context,
      builder: (_) => dialog,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      heightFactor: AppBottomSheet.defaultHeightFactor,
    );
  }
}

class _StaffDialog extends ConsumerStatefulWidget {
  const _StaffDialog({
    this.initial,
    this.initialLocationId,
    this.isDuplicating = false,
  });

  final Staff? initial;
  final int? initialLocationId;
  final bool isDuplicating;

  bool get isEditing => initial != null && !isDuplicating;

  @override
  ConsumerState<_StaffDialog> createState() => _StaffDialogState();
}

class _StaffDialogState extends ConsumerState<_StaffDialog> {
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _surnameController = TextEditingController();

  late Color _selectedColor;
  final ScrollController _colorScrollController = ScrollController();
  final Set<int> _selectedLocationIds = {};
  final Set<int> _selectedServiceIds = {};
  String? _locationsError;
  bool _isSelectingServices = false;
  bool _isSelectingLocations = false;
  bool _isBookableOnline = true;
  bool _didAutoScrollColor = false;

  static const List<Color> _palette = [
    // Gialli / Amber (alto contrasto)
    Color(0xFFFFC400),
    Color(0xFFFFA000),
    // Arancioni
    Color(0xFFFF6D00),
    Color(0xFFFF3D00),
    // Rossi
    Color(0xFFD50000),
    Color(0xFFB71C1C),
    // Magenta / Rosa
    Color(0xFFF50057),
    Color(0xFFC51162),
    // Viola
    Color(0xFFAA00FF),
    Color(0xFF6200EA),
    // Indaco
    Color(0xFF304FFE),
    Color(0xFF1A237E),
    // Blu
    Color(0xFF2962FF),
    Color(0xFF1565C0),
    // Azzurro
    Color(0xFF0091EA),
    Color(0xFF00B0FF),
    // Ciano
    Color(0xFF00B8D4),
    Color(0xFF00838F),
    // Teal / Turchese
    Color(0xFF00BFA5),
    Color(0xFF00796B),
    // Verdi
    Color(0xFF00C853),
    Color(0xFF2E7D32),
    // Lime / Verde acido
    Color(0xFF76FF03),
    Color(0xFFAEEA00),
    // Extra diversit√†
    Color(0xFFFF9100),
    Color(0xFFE65100),
    Color(0xFFAD1457),
    Color(0xFF7B1FA2),
    Color(0xFF3949AB),
    Color(0xFF00897B),
    Color(0xFF43A047),
    Color(0xFF558B2F),
    Color(0xFF01579B),
    Color(0xFF006064),
    Color(0xFF4E342E),
    Color(0xFF37474F),
  ];

  @override
  void initState() {
    super.initState();
    final initial = widget.initial;
    _selectedColor = initial?.color ?? _palette.first;
    if (initial != null) {
      if (widget.isDuplicating) {
        _nameController.clear();
        _surnameController.clear();
      } else {
        _nameController.text = initial.name;
        _surnameController.text = initial.surname;
      }
      if (kAllowStaffMultiLocationSelection) {
        _selectedLocationIds.addAll(initial.locationIds);
      } else if (initial.locationIds.isNotEmpty) {
        _selectedLocationIds.add(initial.locationIds.first);
      }
      _isBookableOnline = initial.isBookableOnline;
      _selectedServiceIds.addAll(
        ref.read(eligibleServicesForStaffProvider(initial.id)),
      );
    } else if (widget.initialLocationId != null) {
      _selectedLocationIds.add(widget.initialLocationId!);
    }
    _nameController.addListener(_handleNameChange);
    _surnameController.addListener(_handleNameChange);
  }

  @override
  void dispose() {
    _nameController.removeListener(_handleNameChange);
    _surnameController.removeListener(_handleNameChange);
    _nameController.dispose();
    _surnameController.dispose();
    _colorScrollController.dispose();
    super.dispose();
  }

  void _handleNameChange() {
    if (!mounted) return;
    setState(() {});
  }

  String _buildInitials() {
    final name = _nameController.text.trim();
    final surname = _surnameController.text.trim();
    final fullName = [name, surname].where((p) => p.isNotEmpty).join(' ');
    return initialsFromName(fullName, maxChars: 3);
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final title = widget.isEditing
        ? l10n.teamEditStaffTitle
        : l10n.teamNewStaffTitle;
    final formFactor = ref.read(formFactorProvider);
    final isSingleColumn = formFactor != AppFormFactor.desktop;
    final locations = ref.watch(locationsProvider);
    final totalServicesCount = ref.watch(servicesProvider).length;
    final totalLocationsCount = locations.length;
    final selectedLocationName =
        !kAllowStaffMultiLocationSelection && _selectedLocationIds.isNotEmpty
        ? locations
              .firstWhere(
                (loc) => loc.id == _selectedLocationIds.first,
                orElse: () => locations.first,
              )
              .name
        : null;
    if (!_didAutoScrollColor) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (!_colorScrollController.hasClients) return;
        final index = _palette.indexWhere(
          (c) => c.value == _selectedColor.value,
        );
        if (index < 0) return;
        const double colorItemSize = 36;
        const double colorItemSpacing = 10;
        const double colorListPadding = 4;
        final viewport = _colorScrollController.position.viewportDimension;
        final target =
            index * (colorItemSize + colorItemSpacing) -
            (viewport - colorItemSize) / 2 -
            colorListPadding;
        final max = _colorScrollController.position.maxScrollExtent;
        _colorScrollController.jumpTo(target.clamp(0.0, max));
      });
      _didAutoScrollColor = true;
    }

    final editAvatar = widget.isEditing
        ? Center(
            child: StaffCircleAvatar(
              height: 64,
              color: _selectedColor,
              isHighlighted: false,
              initials: _buildInitials(),
            ),
          )
        : null;

    final actions = [
      AppOutlinedActionButton(
        onPressed: () => Navigator.of(context).pop(),
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionCancel),
      ),
      AppFilledButton(
        onPressed: _onSave,
        padding: AppButtonStyles.dialogButtonPadding,
        child: Text(l10n.actionSave),
      ),
    ];

    final bottomActions = actions
        .map(
          (a) => SizedBox(width: AppButtonStyles.dialogButtonWidth, child: a),
        )
        .toList();

    final nameField = LabeledFormField(
      label: l10n.teamStaffNameLabel,
      child: TextFormField(
        controller: _nameController,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        textInputAction: TextInputAction.next,
        textCapitalization: TextCapitalization.words,
        validator: (v) =>
            v == null || v.trim().isEmpty ? l10n.validationRequired : null,
      ),
    );

    final surnameField = LabeledFormField(
      label: l10n.teamStaffSurnameLabel,
      child: TextFormField(
        controller: _surnameController,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
          isDense: true,
        ),
        textInputAction: TextInputAction.next,
        textCapitalization: TextCapitalization.words,
      ),
    );

    final content = Form(
      key: _formKey,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        mainAxisSize: MainAxisSize.min,
        children: [
          if (isSingleColumn) ...[
            nameField,
            const SizedBox(height: AppSpacing.formRowSpacing),
            surnameField,
          ] else ...[
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(child: nameField),
                const SizedBox(width: AppSpacing.formFieldSpacing),
                Expanded(child: surnameField),
              ],
            ),
          ],
          const SizedBox(height: AppSpacing.formRowSpacing),
          Text(
            l10n.teamStaffColorLabel,
            style: Theme.of(context).textTheme.titleSmall,
          ),
          const SizedBox(height: 8),
          SizedBox(
            height: 44,
            child: Row(
              children: [
                Expanded(
                  child: ShaderMask(
                    shaderCallback: (rect) {
                      return const LinearGradient(
                        begin: Alignment.centerLeft,
                        end: Alignment.centerRight,
                        colors: [
                          Colors.transparent,
                          Colors.black,
                          Colors.black,
                          Colors.transparent,
                        ],
                        stops: [0.0, 0.01, 0.99, 1.0],
                      ).createShader(rect);
                    },
                    blendMode: BlendMode.dstIn,
                    child: ScrollConfiguration(
                      behavior: const ScrollBehavior().copyWith(
                        dragDevices: {
                          PointerDeviceKind.touch,
                          PointerDeviceKind.mouse,
                          PointerDeviceKind.trackpad,
                        },
                      ),
                      child: ListView.separated(
                        controller: _colorScrollController,
                        padding: const EdgeInsets.symmetric(horizontal: 4),
                        scrollDirection: Axis.horizontal,
                        physics: const BouncingScrollPhysics(),
                        itemCount: _palette.length,
                        separatorBuilder: (_, __) => const SizedBox(width: 10),
                        itemBuilder: (context, index) {
                          final color = _palette[index];
                          final initials = _buildInitials();
                          return GestureDetector(
                            onTap: () => setState(() => _selectedColor = color),
                            child: AnimatedContainer(
                              duration: const Duration(milliseconds: 150),
                              child: StaffCircleAvatar(
                                height: 36,
                                color: color,
                                isHighlighted: _selectedColor == color,
                                initials: initials,
                              ),
                            ),
                          );
                        },
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
          const SizedBox(height: AppSpacing.formRowSpacing),
          if (!kAllowStaffMultiLocationSelection) ...[
            Text(
              l10n.teamLocationLabel,
              style: Theme.of(context).textTheme.titleSmall,
            ),
            const SizedBox(height: 8),
          ],
          SizedBox(
            height: 48,
            child: AppOutlinedActionButton(
              onPressed: _openLocationsSelector,
              expand: true,
              padding: AppButtonStyles.defaultPadding,
              child: Row(
                children: [
                  Expanded(
                    child: Align(
                      alignment: Alignment.centerLeft,
                      child: Text(
                        kAllowStaffMultiLocationSelection
                            ? l10n.teamChooseLocationsButton
                            : (selectedLocationName ??
                                  l10n.teamChooseLocationSingleButton),
                      ),
                    ),
                  ),
                  if (kAllowStaffMultiLocationSelection)
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 10,
                        vertical: 4,
                      ),
                      decoration: BoxDecoration(
                        color: Theme.of(
                          context,
                        ).colorScheme.primary.withOpacity(0.12),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        '${_selectedLocationIds.length}/$totalLocationsCount',
                        style: Theme.of(context).textTheme.labelSmall?.copyWith(
                          color: Theme.of(context).colorScheme.primary,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                ],
              ),
            ),
          ),
          if (_locationsError != null)
            Padding(
              padding: const EdgeInsets.only(top: 4),
              child: Text(
                _locationsError!,
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.error,
                ),
              ),
            ),
          const SizedBox(height: AppSpacing.formRowSpacing),
          Text(
            l10n.teamServicesLabel,
            style: Theme.of(context).textTheme.titleSmall,
          ),
          const SizedBox(height: 8),
          SizedBox(
            height: 48,
            child: AppOutlinedActionButton(
              onPressed: _openServicesSelector,
              expand: true,
              padding: AppButtonStyles.defaultPadding,
              child: Align(
                alignment: Alignment.centerLeft,
                child: Wrap(
                  crossAxisAlignment: WrapCrossAlignment.center,
                  spacing: 8,
                  runSpacing: 6,
                  children: [
                    Text(l10n.teamSelectedServicesButton),
                    Container(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 10,
                        vertical: 4,
                      ),
                      decoration: BoxDecoration(
                        color: Theme.of(
                          context,
                        ).colorScheme.primary.withOpacity(0.12),
                        borderRadius: BorderRadius.circular(12),
                      ),
                      child: Text(
                        l10n.teamSelectedServicesCount(
                          _selectedServiceIds.length,
                          totalServicesCount,
                        ),
                        style: Theme.of(context).textTheme.labelSmall?.copyWith(
                          color: Theme.of(context).colorScheme.primary,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
          const SizedBox(height: AppSpacing.formRowSpacing),
          _SwitchTile(
            title: l10n.teamStaffBookableOnlineLabel,
            value: _isBookableOnline,
            onChanged: (v) => setState(() => _isBookableOnline = v),
          ),
          const SizedBox(height: AppSpacing.formRowSpacing),
          if (kAllowStaffMultiLocationSelection)
            Text(
              l10n.teamStaffMultiLocationWarning,
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
        ],
      ),
    );

    if (ref.read(formFactorProvider) == AppFormFactor.desktop) {
      return Dialog(
        insetPadding: const EdgeInsets.symmetric(horizontal: 32, vertical: 24),
        child: ConstrainedBox(
          constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
          child: Padding(
            padding: const EdgeInsets.all(20),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Text(title, style: Theme.of(context).textTheme.headlineSmall),
                if (editAvatar != null) ...[
                  const SizedBox(height: 12),
                  editAvatar,
                ],
                const SizedBox(height: 16),
                Flexible(child: SingleChildScrollView(child: content)),
                const SizedBox(height: 24),
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    for (int i = 0; i < bottomActions.length; i++) ...[
                      if (i > 0) const SizedBox(width: 8),
                      bottomActions[i],
                    ],
                  ],
                ),
              ],
            ),
          ),
        ),
      );
    }

    return SafeArea(
      top: false,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final isKeyboardOpen =
              MediaQuery.of(context).viewInsets.bottom > 0;
          return SizedBox(
            height: constraints.maxHeight,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                Expanded(
                  child: SingleChildScrollView(
                    padding: EdgeInsets.zero,
                    child: Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Padding(
                            padding: const EdgeInsets.only(bottom: 12),
                            child: Text(
                              title,
                              style: Theme.of(context).textTheme.titleLarge,
                            ),
                          ),
                          if (editAvatar != null) ...[
                            editAvatar,
                            const SizedBox(height: 12),
                          ],
                          content,
                          const SizedBox(height: 24),
                          const SizedBox(height: AppSpacing.formRowSpacing),
                        ],
                      ),
                    ),
                  ),
                ),
                if (!isKeyboardOpen) ...[
                  const AppBottomSheetDivider(),
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                    child: Align(
                      alignment: bottomActions.length == 3
                          ? Alignment.center
                          : Alignment.centerRight,
                      child: Wrap(
                        alignment: bottomActions.length == 3
                            ? WrapAlignment.center
                            : WrapAlignment.end,
                        spacing: 8,
                        runSpacing: 8,
                        children: bottomActions,
                      ),
                    ),
                  ),
                ],
                SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
              ],
            ),
          );
        },
      ),
    );
  }

  void _onSave() {
    if (!_formKey.currentState!.validate()) return;
    if (_selectedLocationIds.isEmpty) {
      setState(() => _locationsError = context.l10n.validationRequired);
      return;
    }
    if (!kAllowStaffMultiLocationSelection && _selectedLocationIds.length > 1) {
      final firstId = _selectedLocationIds.first;
      _selectedLocationIds
        ..clear()
        ..add(firstId);
    }
    final notifier = ref.read(allStaffProvider.notifier);
    final business = ref.read(currentBusinessProvider);
    final name = _nameController.text.trim();
    final surname = _surnameController.text.trim();
    final isEditing = widget.isEditing;
    final staffId = isEditing ? widget.initial!.id : notifier.nextId();

    if (isEditing) {
      notifier.update(
        widget.initial!.copyWith(
          name: name,
          surname: surname,
          color: _selectedColor,
          locationIds: _selectedLocationIds.toList(),
          isBookableOnline: _isBookableOnline,
        ),
      );
    } else {
      notifier.add(
        Staff(
          id: staffId,
          businessId: business.id,
          name: name,
          surname: surname,
          color: _selectedColor,
          locationIds: _selectedLocationIds.toList(),
          sortOrder: notifier.nextSortOrderForLocations(_selectedLocationIds),
          isBookableOnline: _isBookableOnline,
        ),
      );
    }
    ref
        .read(serviceStaffEligibilityProvider.notifier)
        .setEligibleServicesForStaff(
          staffId: staffId,
          locationId: ref.read(currentLocationProvider).id,
          serviceIds: _selectedServiceIds,
        );
    Navigator.of(context).pop();
  }

  Future<void> _openServicesSelector() async {
    if (_isSelectingServices) return;
    setState(() => _isSelectingServices = true);
    final l10n = context.l10n;
    final services = ref.read(servicesProvider);
    final categories = ref.read(serviceCategoriesProvider);
    final formFactor = ref.read(formFactorProvider);
    Set<int> current = {..._selectedServiceIds};

    Future<void> openDialog(BuildContext ctx) async {
      await showDialog<void>(
        context: ctx,
        builder: (dialogCtx) => StatefulBuilder(
          builder: (context, setStateLocal) {
            return Dialog(
              insetPadding: const EdgeInsets.symmetric(
                horizontal: 32,
                vertical: 24,
              ),
              child: ConstrainedBox(
                constraints: const BoxConstraints(
                  minWidth: 600,
                  maxWidth: 720,
                  maxHeight: 560,
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Padding(
                      padding: const EdgeInsets.fromLTRB(20, 16, 20, 8),
                      child: Text(
                        l10n.teamEligibleServicesLabel,
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                    ),
                    const AppBottomSheetDivider(),
                    Expanded(
                      child: SingleChildScrollView(
                        child: Padding(
                          padding: const EdgeInsets.fromLTRB(0, 12, 0, 16),
                          child: ServiceEligibilitySelector(
                            services: services,
                            categories: categories,
                            selectedServiceIds: current,
                            onChanged: (value) => setStateLocal(() {
                              current = {...value};
                            }),
                          ),
                        ),
                      ),
                    ),
                    const AppBottomSheetDivider(),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                      child: Align(
                        alignment: Alignment.centerRight,
                        child: AppFilledButton(
                          onPressed: () => Navigator.of(dialogCtx).pop(),
                          padding: AppButtonStyles.dialogButtonPadding,
                          child: Text(l10n.actionConfirm),
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            );
          },
        ),
      );
    }

    Future<void> openSheet(BuildContext ctx) async {
      await AppBottomSheet.show<void>(
        context: ctx,
        heightFactor: AppBottomSheet.defaultHeightFactor,
        padding: EdgeInsets.zero,
        builder: (sheetCtx) => StatefulBuilder(
          builder: (context, setStateLocal) {
            return SafeArea(
              top: false,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
                    child: Text(
                      l10n.teamEligibleServicesLabel,
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                  ),
                  const AppBottomSheetDivider(),
                  Expanded(
                    child: SingleChildScrollView(
                      child: Padding(
                        padding: const EdgeInsets.fromLTRB(0, 12, 0, 16),
                        child: ServiceEligibilitySelector(
                          services: services,
                          categories: categories,
                          selectedServiceIds: current,
                          onChanged: (value) => setStateLocal(() {
                            current = {...value};
                          }),
                        ),
                      ),
                    ),
                  ),
                  const AppBottomSheetDivider(),
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                    child: Align(
                      alignment: Alignment.centerRight,
                      child: AppFilledButton(
                        onPressed: () => Navigator.of(sheetCtx).pop(),
                        padding: AppButtonStyles.dialogButtonPadding,
                        child: Text(l10n.actionConfirm),
                      ),
                    ),
                  ),
                  SizedBox(height: MediaQuery.of(ctx).viewPadding.bottom),
                ],
              ),
            );
          },
        ),
      );
    }

    if (formFactor == AppFormFactor.desktop) {
      await openDialog(context);
    } else {
      await openSheet(context);
    }

    setState(() {
      _selectedServiceIds
        ..clear()
        ..addAll(current);
      _isSelectingServices = false;
    });
  }

  Future<void> _openLocationsSelector() async {
    if (_isSelectingLocations) return;
    setState(() => _isSelectingLocations = true);
    final l10n = context.l10n;
    final locations = ref.read(locationsProvider);
    final formFactor = ref.read(formFactorProvider);
    Set<int> current = {..._selectedLocationIds};

    Widget buildLocationRows(void Function(VoidCallback) setStateLocal) {
      final allIds = [for (final l in locations) l.id];
      final allSelected = allIds.isNotEmpty && allIds.every(current.contains);
      return Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          if (kAllowStaffMultiLocationSelection) ...[
            _SelectableRow(
              label: l10n.teamSelectAllLocations,
              selected: allSelected,
              onTap: () {
                if (allSelected) {
                  current.clear();
                } else {
                  current
                    ..clear()
                    ..addAll(allIds);
                }
                setStateLocal(() {});
              },
            ),
            const AppBottomSheetDivider(),
          ],
          for (final loc in locations)
            _SelectableRow(
              label: loc.name,
              selected: current.contains(loc.id),
              onTap: () {
                if (kAllowStaffMultiLocationSelection) {
                  if (current.contains(loc.id)) {
                    current.remove(loc.id);
                  } else {
                    current.add(loc.id);
                  }
                } else {
                  current
                    ..clear()
                    ..add(loc.id);
                }
                setStateLocal(() {});
                if (!kAllowStaffMultiLocationSelection) {
                  Navigator.of(context).pop();
                }
              },
            ),
        ],
      );
    }

    Future<void> openDialog(BuildContext ctx) async {
      await showDialog<void>(
        context: ctx,
        builder: (dialogCtx) => StatefulBuilder(
          builder: (context, setStateLocal) {
            return Dialog(
              insetPadding: const EdgeInsets.symmetric(
                horizontal: 32,
                vertical: 24,
              ),
              child: ConstrainedBox(
                constraints: const BoxConstraints(
                  minWidth: 600,
                  maxWidth: 720,
                  maxHeight: 560,
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Padding(
                      padding: const EdgeInsets.fromLTRB(20, 16, 20, 8),
                      child: Text(
                        kAllowStaffMultiLocationSelection
                            ? l10n.teamChooseLocationsButton
                            : l10n.teamChooseLocationSingleButton,
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                    ),
                    const AppBottomSheetDivider(),
                    Expanded(
                      child: SingleChildScrollView(
                        child: Padding(
                          padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                          child: buildLocationRows(setStateLocal),
                        ),
                      ),
                    ),
                    if (kAllowStaffMultiLocationSelection) ...[
                      const AppBottomSheetDivider(),
                      Padding(
                        padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                        child: Align(
                          alignment: Alignment.centerRight,
                          child: AppFilledButton(
                            onPressed: () => Navigator.of(dialogCtx).pop(),
                            padding: AppButtonStyles.dialogButtonPadding,
                            child: Text(l10n.actionConfirm),
                          ),
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            );
          },
        ),
      );
    }

    Future<void> openSheet(BuildContext ctx) async {
      await AppBottomSheet.show<void>(
        context: ctx,
        heightFactor: AppBottomSheet.defaultHeightFactor,
        padding: EdgeInsets.zero,
        builder: (sheetCtx) => StatefulBuilder(
          builder: (context, setStateLocal) {
            return SafeArea(
              top: false,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
                    child: Text(
                      kAllowStaffMultiLocationSelection
                          ? l10n.teamChooseLocationsButton
                          : l10n.teamChooseLocationSingleButton,
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                  ),
                  const AppBottomSheetDivider(),
                  Expanded(
                    child: SingleChildScrollView(
                      child: Padding(
                        padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                        child: buildLocationRows(setStateLocal),
                      ),
                    ),
                  ),
                  if (kAllowStaffMultiLocationSelection) ...[
                    const AppBottomSheetDivider(),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                      child: Align(
                        alignment: Alignment.centerRight,
                        child: AppFilledButton(
                          onPressed: () => Navigator.of(sheetCtx).pop(),
                          padding: AppButtonStyles.dialogButtonPadding,
                          child: Text(l10n.actionConfirm),
                        ),
                      ),
                    ),
                    SizedBox(height: MediaQuery.of(ctx).viewPadding.bottom),
                  ],
                ],
              ),
            );
          },
        ),
      );
    }

    if (formFactor == AppFormFactor.desktop) {
      await openDialog(context);
    } else {
      await openSheet(context);
    }

    setState(() {
      _selectedLocationIds
        ..clear()
        ..addAll(current);
      _locationsError = null;
      _isSelectingLocations = false;
    });
  }
}

class _SwitchTile extends StatelessWidget {
  const _SwitchTile({
    required this.title,
    required this.value,
    required this.onChanged,
  });

  final String title;
  final bool value;
  final ValueChanged<bool>? onChanged;

  @override
  Widget build(BuildContext context) {
    final titleStyle = Theme.of(context).textTheme.titleSmall;
    final borderRadius = AppButtonStyles.defaultBorderRadius;
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 5),
      decoration: BoxDecoration(
        border: Border.all(
          color: Theme.of(context).colorScheme.primary,
          width: 1.4,
        ),
        borderRadius: borderRadius,
      ),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: onChanged == null ? null : () => onChanged!(!value),
          splashColor: Colors.transparent,
          hoverColor: Colors.transparent,
          highlightColor: Colors.transparent,
          child: Row(
            children: [
              Expanded(child: Text(title, style: titleStyle)),
              AppSwitch(
                value: value,
                onChanged: onChanged,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _SelectableRow extends StatelessWidget {
  const _SelectableRow({
    required this.label,
    required this.selected,
    required this.onTap,
  });

  final String label;
  final bool selected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          child: Row(
            children: [
              Expanded(child: Text(label)),
              if (selected)
                Icon(
                  Icons.check,
                  color: Theme.of(context).colorScheme.primary,
                  size: 20,
                ),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/staff_week_overview_screen.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/widgets/agenda_control_components.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:agenda_backend/core/l10n/date_time_formats.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/core/models/availability_exception.dart';
import 'package:agenda_backend/core/models/staff.dart';
import 'package:agenda_backend/core/widgets/app_bottom_sheet.dart';
import 'package:agenda_backend/core/widgets/app_buttons.dart';
import 'package:agenda_backend/core/widgets/app_dialogs.dart';
import 'package:agenda_backend/core/widgets/no_scrollbar_behavior.dart';
import 'package:agenda_backend/features/agenda/domain/config/agenda_theme.dart';
import 'package:agenda_backend/features/agenda/presentation/screens/widgets/agenda_dividers.dart';
import 'package:agenda_backend/features/agenda/providers/date_range_provider.dart';
import 'package:agenda_backend/features/agenda/providers/layout_config_provider.dart';
import 'package:agenda_backend/features/staff/presentation/staff_availability_screen.dart';
import 'package:agenda_backend/features/staff/presentation/dialogs/add_exception_dialog.dart';
import 'package:agenda_backend/features/staff/providers/availability_exceptions_provider.dart';
import 'package:agenda_backend/features/staff/providers/staff_providers.dart';
import 'package:agenda_backend/features/staff/widgets/staff_top_controls.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

// Lightweight range used only for the overview chips
class HourRange {
  final int startHour;
  final int startMinute;
  final int endHour;
  final int endMinute;
  const HourRange(
    this.startHour,
    this.startMinute,
    this.endHour,
    this.endMinute,
  );

  int get minutes =>
      (endHour * 60 + endMinute) - (startHour * 60 + startMinute);
  String label(BuildContext context) =>
      '${DtFmt.hm(context, startHour, startMinute)} - ${DtFmt.hm(context, endHour, endMinute)}';
}

class _DisplayRange {
  _DisplayRange({
    required this.startMinutes,
    required this.endMinutes,
    required this.label,
    required this.isException,
    this.exceptionType,
    this.hourRange,
  });

  final int startMinutes;
  final int endMinutes;
  final String label;
  final bool isException;
  final AvailabilityExceptionType? exceptionType;
  final HourRange? hourRange;
}

class _DashedRoundedRectPainter extends CustomPainter {
  _DashedRoundedRectPainter({
    required this.color,
    required this.radius,
  });

  final Color color;
  final double radius;

  @override
  void paint(Canvas canvas, Size size) {
    const strokeWidth = 0.6;
    const dashLength = 4.0;
    const gapLength = 3.0;
    final rect = Offset.zero & size;
    final rrect = RRect.fromRectAndRadius(rect, Radius.circular(radius));
    final path = Path()..addRRect(rrect);
    final paint = Paint()
      ..color = color
      ..strokeWidth = strokeWidth
      ..style = PaintingStyle.stroke;

    for (final metric in path.computeMetrics()) {
      var distance = 0.0;
      while (distance < metric.length) {
        final next = (distance + dashLength).clamp(0.0, metric.length);
        canvas.drawPath(metric.extractPath(distance, next), paint);
        distance += dashLength + gapLength;
      }
    }
  }

  @override
  bool shouldRepaint(covariant _DashedRoundedRectPainter oldDelegate) {
    return oldDelegate.color != color ||
        oldDelegate.radius != radius;
  }
}

List<_DisplayRange> _mergeRangesForDisplay(
  List<HourRange> baseRanges,
  List<AvailabilityException> exceptions,
  BuildContext context, {
  bool applyUnavailableSplit = true,
  bool subtractAvailableFromBase = false,
}) {
  final items = <_DisplayRange>[];

  final availableToSubtract = subtractAvailableFromBase
      ? exceptions
          .where(
            (e) =>
                e.type == AvailabilityExceptionType.available &&
                e.startTime != null &&
                e.endTime != null,
          )
          .map<({int start, int end})>(
            (e) => (
              start: e.startTime!.hour * 60 + e.startTime!.minute,
              end: e.endTime!.hour * 60 + e.endTime!.minute,
            ),
          )
          .toList()
      : const <({int start, int end})>[];

  final unavailable = applyUnavailableSplit
      ? exceptions
          .where(
            (e) =>
                e.type == AvailabilityExceptionType.unavailable &&
                e.startTime != null &&
                e.endTime != null,
          )
          .map<({int start, int end})>(
            (e) => (
              start: e.startTime!.hour * 60 + e.startTime!.minute,
              end: e.endTime!.hour * 60 + e.endTime!.minute,
            ),
          )
          .toList()
      : const <({int start, int end})>[];

  for (final r in baseRanges) {
    final baseStart = r.startHour * 60 + r.startMinute;
    final baseEnd = r.endHour * 60 + r.endMinute;
    var segments = <({int start, int end})>[
      (start: baseStart, end: baseEnd),
    ];

    if (availableToSubtract.isNotEmpty) {
      for (final a in availableToSubtract) {
        final next = <({int start, int end})>[];
        for (final seg in segments) {
          if (a.end <= seg.start || a.start >= seg.end) {
            next.add(seg);
            continue;
          }
          if (a.start > seg.start) {
            final leftEnd = a.start < seg.end ? a.start : seg.end;
            if (leftEnd > seg.start) {
              next.add((start: seg.start, end: leftEnd));
            }
          }
          if (a.end < seg.end) {
            final rightStart = a.end > seg.start ? a.end : seg.start;
            if (seg.end > rightStart) {
              next.add((start: rightStart, end: seg.end));
            }
          }
        }
        segments = next;
        if (segments.isEmpty) break;
      }
    }

    if (unavailable.isNotEmpty) {
      for (final u in unavailable) {
        final next = <({int start, int end})>[];
        for (final seg in segments) {
          if (u.end <= seg.start || u.start >= seg.end) {
            next.add(seg);
            continue;
          }
          if (u.start > seg.start) {
            final leftEnd = u.start < seg.end ? u.start : seg.end;
            if (leftEnd > seg.start) {
              next.add((start: seg.start, end: leftEnd));
            }
          }
          if (u.end < seg.end) {
            final rightStart = u.end > seg.start ? u.end : seg.start;
            if (seg.end > rightStart) {
              next.add((start: rightStart, end: seg.end));
            }
          }
        }
        segments = next;
        if (segments.isEmpty) break;
      }
    }

    for (final seg in segments) {
      final isAllDay = seg.start == 0 && seg.end == 24 * 60;
      final label = isAllDay
          ? context.l10n.exceptionAllDay
          : '${DtFmt.hm(context, seg.start ~/ 60, seg.start % 60)} - ${DtFmt.hm(context, seg.end ~/ 60, seg.end % 60)}';
      items.add(
        _DisplayRange(
          startMinutes: seg.start,
          endMinutes: seg.end,
          label: label,
          isException: false,
          exceptionType: null,
          hourRange: HourRange(
            seg.start ~/ 60,
            seg.start % 60,
            seg.end ~/ 60,
            seg.end % 60,
          ),
        ),
      );
    }
  }

  final allDayExceptions = exceptions.where(
    (e) => e.startTime == null && e.endTime == null,
  );
  for (final e in allDayExceptions) {
    items.add(
      _DisplayRange(
        startMinutes: 0,
        endMinutes: 24 * 60,
        label: context.l10n.exceptionAllDay,
        isException: true,
        exceptionType: e.type,
        hourRange: const HourRange(0, 0, 24, 0),
      ),
    );
  }

  for (final e in exceptions) {
    if (e.startTime == null || e.endTime == null) continue;
    final label =
        '${DtFmt.hm(context, e.startTime!.hour, e.startTime!.minute)} - ${DtFmt.hm(context, e.endTime!.hour, e.endTime!.minute)}';
    items.add(
      _DisplayRange(
        startMinutes: e.startTime!.hour * 60 + e.startTime!.minute,
        endMinutes: e.endTime!.hour * 60 + e.endTime!.minute,
        label: label,
        isException: true,
        exceptionType: e.type,
        hourRange: HourRange(
          e.startTime!.hour,
          e.startTime!.minute,
          e.endTime!.hour,
          e.endTime!.minute,
        ),
      ),
    );
  }

  // De-duplicate exact same ranges, prefer exception styling if present.
  final Map<String, _DisplayRange> unique = {};
  for (final item in items) {
    final key = '${item.startMinutes}-${item.endMinutes}';
    final existing = unique[key];
    if (existing == null) {
      unique[key] = item;
      continue;
    }
    if (!existing.isException && item.isException) {
      unique[key] = item;
    }
  }

  final result = unique.values.toList()
    ..sort((a, b) => a.startMinutes.compareTo(b.startMinutes));
  return result;
}

int _countSegmentsForDay(
  BuildContext context,
  List<HourRange> ranges,
  List<AvailabilityException> exceptions,
) {
  final displayRanges = _mergeRangesForDisplay(
    ranges,
    exceptions,
    context,
    applyUnavailableSplit: false,
    subtractAvailableFromBase: true,
  );
  // +1 per il chip "aggiungi eccezione"
  return displayRanges.length + 1;
}

/// Mock provider: staffId -> day(1..7) -> ranges
final weeklyStaffAvailabilityMockProvider =
    Provider<Map<int, Map<int, List<HourRange>>>>((ref) {
      // Simple sample data
      return {
        1: {
          1: const [HourRange(9, 30, 13, 30), HourRange(14, 0, 19, 30)],
          2: const [HourRange(9, 30, 13, 30), HourRange(14, 0, 19, 30)],
          3: const [HourRange(10, 30, 13, 30), HourRange(14, 0, 19, 30)],
          4: const [HourRange(9, 30, 13, 30), HourRange(14, 0, 19, 30)],
          5: const [HourRange(10, 30, 13, 30), HourRange(14, 0, 19, 30)],
          6: const [HourRange(9, 30, 13, 30)],
          7: const [],
        },
      };
    });

/// Real data bridge: maps the editor's weekly availability (per day) to
/// the overview shape, including exceptions for the specific week being displayed.
///
/// La disponibilit√† finale per ogni giorno √® calcolata come:
/// 1. Base: template settimanale (es. Lun-Ven 09:00-18:00)
/// 2. + Eccezioni "available": aggiungono slot disponibili
/// 3. - Eccezioni "unavailable": rimuovono slot disponibili
class WeeklyExceptionsLoadKeyNotifier extends Notifier<String?> {
  @override
  String? build() => null;

  void setKey(String? value) => state = value;
}

final weeklyExceptionsLoadKeyProvider =
    NotifierProvider<WeeklyExceptionsLoadKeyNotifier, String?>(
      WeeklyExceptionsLoadKeyNotifier.new,
    );

void _ensureExceptionsLoadedForWeekWithKey(
  String? lastKey,
  void Function(String? value) setKey,
  Future<void> Function(int staffId, {DateTime? fromDate, DateTime? toDate})
  loadForStaff,
  DateTime agendaDate,
  List<Staff> staffList,
) {
  if (staffList.isEmpty) return;
  final monday = _mondayOfWeek(agendaDate);
  final staffIds = staffList.map((s) => s.id).toList()..sort();
  final key =
      '${monday.toIso8601String().split('T').first}|${staffIds.join(",")}';
  if (lastKey == key) return;
  final fromDate = monday;
  final toDate = monday.add(const Duration(days: 6));
  for (final staff in staffList) {
    loadForStaff(staff.id, fromDate: fromDate, toDate: toDate);
  }
}

final weeklyStaffAvailabilityFromEditorProvider =
    Provider<Map<int, Map<int, List<HourRange>>>>((ref) {
      final staffList = ref.watch(staffForStaffSectionProvider);
      final asyncByStaff = ref.watch(staffAvailabilityByStaffProvider);
      final layout = ref.watch(layoutConfigProvider);
      final minutesPerSlot = layout.minutesPerSlot;
      final totalSlots = layout.totalSlots;

      // Ottieni la data corrente dell'agenda per calcolare la settimana mostrata
      final agendaDate = ref.watch(agendaDateProvider);
      _ensureExceptionsLoadedForWeekWithKey(
        ref.watch(weeklyExceptionsLoadKeyProvider),
        ref.read(weeklyExceptionsLoadKeyProvider.notifier).setKey,
        ref
            .read(availabilityExceptionsProvider.notifier)
            .loadExceptionsForStaff,
        agendaDate,
        staffList,
      );
      final monday = _mondayOfWeek(agendaDate);

      List<HourRange> slotsToHourRanges(Set<int> slots) {
        if (slots.isEmpty) return const [];
        final sorted = slots.toList()..sort();
        final List<List<int>> clusters = [];
        var current = <int>[sorted.first];
        for (int i = 1; i < sorted.length; i++) {
          if (sorted[i] == sorted[i - 1] + 1) {
            current.add(sorted[i]);
          } else {
            clusters.add(current);
            current = <int>[sorted[i]];
          }
        }
        clusters.add(current);

        final List<HourRange> ranges = [];
        for (final c in clusters) {
          final startMin = c.first * minutesPerSlot;
          // La fine √® l'inizio dell'ultimo slot + la durata di uno slot
          final endMin = (c.last + 1) * minutesPerSlot;
          final sh = startMin ~/ 60;
          final sm = startMin % 60;
          final eh = endMin ~/ 60;
          final em = endMin % 60;
          ranges.add(HourRange(sh, sm, eh, em));
        }
        return ranges;
      }

      final all = asyncByStaff.value ?? const <int, Map<int, Set<int>>>{};

      // Build per-staff availability with exceptions applied for each specific date
      final Map<int, Map<int, List<HourRange>>> result = {};

      for (final s in staffList) {
        final Map<int, List<HourRange>> staffWeek = {};

        for (int d = 1; d <= 7; d++) {
          // Calcola la data specifica per questo giorno della settimana
          final specificDate = monday.add(Duration(days: d - 1));

          // 1Ô∏è‚É£ BASE: Template settimanale
          Set<int> baseSlots = Set<int>.from(all[s.id]?[d] ?? const <int>{});

          // 2Ô∏è‚É£ ECCEZIONI: Applica modifiche per la data specifica
          final exceptions = ref.watch(
            exceptionsForStaffOnDateProvider((
              staffId: s.id,
              date: specificDate,
            )),
          );

          if (exceptions.isEmpty) {
            staffWeek[d] = slotsToHourRanges(baseSlots);
          } else {
            // Applica le eccezioni in ordine
            Set<int> finalSlots = Set<int>.from(baseSlots);

            for (final exception in exceptions) {
              final exceptionSlots = exception.toSlotIndices(
                minutesPerSlot: minutesPerSlot,
                totalSlotsPerDay: totalSlots,
              );

              if (exception.type == AvailabilityExceptionType.available) {
                // AGGIUNGE disponibilit√† (es. turno extra)
                finalSlots = finalSlots.union(exceptionSlots);
              } else {
                // RIMUOVE disponibilit√† (es. ferie, malattia)
                finalSlots = finalSlots.difference(exceptionSlots);
              }
            }

            staffWeek[d] = slotsToHourRanges(finalSlots);
          }
        }

        result[s.id] = staffWeek;
      }

      return result;
    });

/// Provider che fornisce la disponibilit√† BASE (template settimanale) senza eccezioni.
/// Usato per confrontare con la disponibilit√† effettiva e identificare i turni modificati.
final weeklyStaffBaseAvailabilityProvider =
    Provider<Map<int, Map<int, List<HourRange>>>>((ref) {
      final staffList = ref.watch(staffForStaffSectionProvider);
      final asyncByStaff = ref.watch(staffAvailabilityByStaffProvider);
      final layout = ref.watch(layoutConfigProvider);
      final minutesPerSlot = layout.minutesPerSlot;

      List<HourRange> slotsToHourRanges(Set<int> slots) {
        if (slots.isEmpty) return const [];
        final sorted = slots.toList()..sort();
        final List<List<int>> clusters = [];
        var current = <int>[sorted.first];
        for (int i = 1; i < sorted.length; i++) {
          if (sorted[i] == sorted[i - 1] + 1) {
            current.add(sorted[i]);
          } else {
            clusters.add(current);
            current = <int>[sorted[i]];
          }
        }
        clusters.add(current);

        final List<HourRange> ranges = [];
        for (final c in clusters) {
          final startMin = c.first * minutesPerSlot;
          final endMin = (c.last + 1) * minutesPerSlot;
          final sh = startMin ~/ 60;
          final sm = startMin % 60;
          final eh = endMin ~/ 60;
          final em = endMin % 60;
          ranges.add(HourRange(sh, sm, eh, em));
        }
        return ranges;
      }

      final all = asyncByStaff.value ?? const <int, Map<int, Set<int>>>{};

      return {
        for (final s in staffList)
          s.id: {
            for (int d = 1; d <= 7; d++)
              d: slotsToHourRanges(all[s.id]?[d] ?? const <int>{}),
          },
      };
    });

/// Provider che traccia quali giorni della settimana hanno eccezioni per ogni staff.
/// Ritorna: `Map<staffId, Set<weekday>>` dove weekday = 1..7
final weeklyExceptionDaysProvider = Provider<Map<int, Set<int>>>((ref) {
  final staffList = ref.watch(staffForStaffSectionProvider);
  final agendaDate = ref.watch(agendaDateProvider);
  _ensureExceptionsLoadedForWeekWithKey(
    ref.watch(weeklyExceptionsLoadKeyProvider),
    ref.read(weeklyExceptionsLoadKeyProvider.notifier).setKey,
    ref.read(availabilityExceptionsProvider.notifier).loadExceptionsForStaff,
    agendaDate,
    staffList,
  );
  final monday = _mondayOfWeek(agendaDate);

  final Map<int, Set<int>> result = {};

  for (final s in staffList) {
    final Set<int> daysWithExceptions = {};

    for (int d = 1; d <= 7; d++) {
      final specificDate = monday.add(Duration(days: d - 1));
      final exceptions = ref.watch(
        exceptionsForStaffOnDateProvider((staffId: s.id, date: specificDate)),
      );

      if (exceptions.isNotEmpty) {
        daysWithExceptions.add(d);
      }
    }

    result[s.id] = daysWithExceptions;
  }

  return result;
});

DateTime _mondayOfWeek(DateTime date) {
  final d = DateTime(date.year, date.month, date.day);
  return d.subtract(Duration(days: d.weekday - DateTime.monday));
}

String _dayHeaderLabel(BuildContext context, DateTime day) {
  final locale = Intl.getCurrentLocale();
  return DateFormat('EEE, d MMM', locale).format(day);
}

int _totalMinutesForDay(Iterable<List<HourRange>> rangesPerStaff) {
  int total = 0;
  for (final list in rangesPerStaff) {
    for (final r in list) {
      total += r.minutes;
    }
  }
  return total;
}

int _totalMinutesForStaff(Map<int, List<HourRange>> byDay) {
  int total = 0;
  for (final list in byDay.values) {
    for (final r in list) {
      total += r.minutes;
    }
  }
  return total;
}

String _formatTotalHM(BuildContext context, int minutes) {
  if (minutes == 0) return '';
  final h = minutes ~/ 60;
  final m = minutes % 60;
  if (m == 0) return context.l10n.hoursHoursOnly(h);
  return context.l10n.hoursMinutesCompact(h, m);
}

class StaffWeekOverviewScreen extends ConsumerStatefulWidget {
  const StaffWeekOverviewScreen({super.key});

  @override
  ConsumerState<StaffWeekOverviewScreen> createState() =>
      _StaffWeekOverviewScreenState();
}

class _StaffWeekOverviewScreenState
    extends ConsumerState<StaffWeekOverviewScreen> {
  // Inizializzazione immediata per evitare LateInitializationError
  final ScrollController _headerHController = ScrollController();
  final ScrollController _bodyHController = ScrollController();
  final ScrollController _vScrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    // Sync header position from body only (unidirectional) per evitare conflitti di inerzia.
    _bodyHController.addListener(() {
      if (!_bodyHController.hasClients) return;
      final off = _bodyHController.offset;
      if (_headerHController.hasClients && _headerHController.offset != off) {
        // jumpTo √® immediato: per una transizione pi√π fluida si potrebbe usare animateTo con durata breve.
        _headerHController.jumpTo(off);
      }
    });
  }

  @override
  void dispose() {
    _headerHController.dispose();
    _bodyHController.dispose();
    _vScrollController.dispose();
    super.dispose();
  }

  // Caricamento eccezioni gestito dai provider

  @override
  Widget build(BuildContext context) {
    // Data sources
    final selectedDate = ref.watch(agendaDateProvider);
    // Current location could influence future filtering (kept for clarity)
    // final location = ref.watch(currentLocationProvider); // not used yet
    final staffList = ref.watch(staffForStaffSectionProvider);
    // Use real availability coming from the editor provider, mapped to overview ranges
    final availability = ref.watch(weeklyStaffAvailabilityFromEditorProvider);
    // Track which staff/day combinations have exceptions applied
    final exceptionDays = ref.watch(weeklyExceptionDaysProvider);
    final formFactor = ref.watch(formFactorProvider);
    _ensureExceptionsLoadedForWeekWithKey(
      ref.watch(weeklyExceptionsLoadKeyProvider),
      ref.read(weeklyExceptionsLoadKeyProvider.notifier).setKey,
      ref.read(availabilityExceptionsProvider.notifier).loadExceptionsForStaff,
      selectedDate,
      staffList,
    );

    // Week days (Mon..Sun)
    final weekStart = _mondayOfWeek(selectedDate);
    final days = [for (int i = 0; i < 7; i++) weekStart.add(Duration(days: i))];

    // Week label builder: include year on boundaries
    String buildWeekRangeLabel() {
      final weekEnd = weekStart.add(const Duration(days: 6));
      final locale = Intl.getCurrentLocale();
      final sameMonth =
          weekStart.month == weekEnd.month && weekStart.year == weekEnd.year;
      final sameYear = weekStart.year == weekEnd.year;

      if (sameMonth) {
        final startDay = DateFormat('d', locale).format(weekStart);
        final endDay = DateFormat('d', locale).format(weekEnd);
        final endMonthShort = DateFormat('MMM', locale).format(weekEnd);
        return '$startDay‚Äì$endDay $endMonthShort';
      }
      if (sameYear) {
        final startDay = DateFormat('d', locale).format(weekStart);
        final endDay = DateFormat('d', locale).format(weekEnd);
        final startMonthShort = DateFormat('MMM', locale).format(weekStart);
        final endMonthShort = DateFormat('MMM', locale).format(weekEnd);
        return '$startDay $startMonthShort ‚Äì $endDay $endMonthShort';
      }
      final startFull = DateFormat('d MMM y', locale).format(weekStart);
      final endFull = DateFormat('d MMM y', locale).format(weekEnd);
      return '$startFull ‚Äì $endFull';
    }

    final weekLabel = buildWeekRangeLabel();
    final weekEnd = weekStart.add(const Duration(days: 6));
    final todayDate = DateUtils.dateOnly(DateTime.now());
    final isTodayInWeek =
        !todayDate.isBefore(weekStart) && !todayDate.isAfter(weekEnd);
    final effectivePickerDate = isTodayInWeek ? todayDate : weekEnd;

    // Layout constants - responsive per mobile
    final isMobileLayout = formFactor == AppFormFactor.mobile;
    final staffColWidth = isMobileLayout ? 120.0 : 200.0;
    final headerHeight = 60.0;
    const chipColor = Color(0xFFECEBFF);
    const chipColorWithException = Color(
      0xFFFFE4B5,
    ); // Moccasin - colore arancione chiaro per eccezioni
    const chipColorWithAvailableException = Color(0xFFDFF5D8);
    const chipTextColorWithAvailableException = Color(0xFF0F6A36);
    const chipDisabledTextColor = Color(0xFF6B6B6B);
    const double chipHeight = 40.0;
    const double chipVGap = 3.0;
    const double chipTopPadding = 4.0;
    const double baseRowHeight = chipHeight * 2 + (chipVGap * 3) + 36.0;
    const double staffRowGap = 24.0;
    const double dayColumnWidth = 100.0;
    const double rightPadding = 5.0;
    final dividerColor = Colors.transparent; // vertical separators
    final divider = Container(height: 0.5, color: dividerColor);
    // Controller gi√† inizializzati in state

    Widget buildDayHeaderCell(DateTime day) {
      final dayIndex = day.weekday; // 1..7
      final totalMin = _totalMinutesForDay(
        availability.values.map((byDay) {
          return byDay[dayIndex] ?? const <HourRange>[];
        }),
      );
      final hasAny = totalMin > 0;
      // Center widget per centrare l'header nella colonna
      return Center(
        child: ConstrainedBox(
          constraints: const BoxConstraints(minWidth: dayColumnWidth),
          child: Container(
            height: headerHeight,
            padding: const EdgeInsets.symmetric(horizontal: 10),
            decoration: BoxDecoration(
              color: AgendaTheme.staffHeaderBackground(
                hasAny ? Colors.teal : Colors.blueGrey,
              ),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(
                  _dayHeaderLabel(context, day),
                  style: AgendaTheme.staffHeaderTextStyle,
                  textAlign: TextAlign.center,
                ),
                if (hasAny)
                  Padding(
                    padding: const EdgeInsets.only(top: 2),
                    child: Text(
                      _formatTotalHM(context, totalMin),
                      style: Theme.of(context).textTheme.labelSmall?.copyWith(
                        color: Colors.black87,
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                  ),
              ],
            ),
          ),
        ),
      );
    }

    double rowHeightForStaff(int staffId) {
      int maxRanges = 0;
      for (final d in days) {
        final exceptions = ref.watch(
          exceptionsForStaffOnDateProvider((staffId: staffId, date: d)),
        );
        final dayRanges =
            availability[staffId]?[d.weekday] ?? const <HourRange>[];
        var count = _countSegmentsForDay(context, dayRanges, exceptions);
        if (count == 0) count = 1;
        if (count > maxRanges) maxRanges = count;
      }
      if (maxRanges <= 1) return baseRowHeight; // 0 o 1 chip: altezza base
      final required =
          chipTopPadding + maxRanges * chipHeight + (maxRanges - 1) * chipVGap;
      return required > baseRowHeight ? required : baseRowHeight;
    }

    Widget buildStaffHeaderCell(int staffId) {
      final staff = staffList.firstWhere(
        (s) => s.id == staffId,
        orElse: () => staffList.first,
      );
      final minutes = _totalMinutesForStaff(availability[staffId] ?? const {});
      final isMobile = formFactor == AppFormFactor.mobile;
      void openStaffAvailability() {
        final vn = ref.read(initialStaffToEditProvider);
        vn.value = staffId;
        Navigator.of(context).push(
          MaterialPageRoute(builder: (_) => const StaffAvailabilityScreen()),
        );
      }

      if (isMobile) {
        // Mobile: avatar, nome e totale ore raggruppati al centro
        return GestureDetector(
          onTap: openStaffAvailability,
          child: Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Stack(
                  children: [
                    StaffCircleAvatar(
                      height: 40,
                      color: staff.color,
                      isHighlighted: false,
                      initials: staff.initials,
                    ),
                    Positioned(
                      right: -4,
                      bottom: -4,
                      child: Container(
                        padding: const EdgeInsets.all(2),
                        decoration: BoxDecoration(
                          color: Theme.of(context).colorScheme.surface,
                          shape: BoxShape.circle,
                          boxShadow: [
                            BoxShadow(
                              color: Colors.black.withValues(alpha: 0.1),
                              blurRadius: 2,
                            ),
                          ],
                        ),
                        child: Icon(
                          Icons.edit_outlined,
                          size: 14,
                          color: Theme.of(context).colorScheme.primary,
                        ),
                      ),
                    ),
                  ],
                ),
                const SizedBox(height: 6),
                Text(
                  staff.displayName,
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                  style: Theme.of(context).textTheme.bodySmall,
                  textAlign: TextAlign.center,
                ),
                if (minutes > 0)
                  Text(
                    _formatTotalHM(context, minutes),
                    style: Theme.of(context).textTheme.labelSmall?.copyWith(
                      color: Colors.black54,
                    ),
                  ),
              ],
            ),
          ),
        );
      }

      // Desktop/Tablet: layout orizzontale
      return GestureDetector(
        onTap: openStaffAvailability,
        child: Row(
          children: [
            StaffCircleAvatar(
              height: 42,
              color: staff.color,
              isHighlighted: false,
              initials: staff.initials,
            ),
            const SizedBox(width: 8),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Text(
                    staff.displayName,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  if (minutes > 0)
                    Text(
                      _formatTotalHM(context, minutes),
                      style: Theme.of(
                        context,
                      ).textTheme.labelSmall?.copyWith(color: Colors.black54),
                    ),
                ],
              ),
            ),
            IconButton(
              tooltip: context.l10n.staffEditHours,
              iconSize: 20,
              padding: const EdgeInsets.all(4),
              onPressed: openStaffAvailability,
              icon: const Icon(Icons.edit_outlined),
            ),
          ],
        ),
      );
    }

    // Helper: converte slots in HourRange list
    List<HourRange> slotsToRanges(Set<int> slots, int minutesPerSlot) {
      if (slots.isEmpty) return const [];
      final sorted = slots.toList()..sort();
      final List<List<int>> clusters = [];
      var current = <int>[sorted.first];
      for (int i = 1; i < sorted.length; i++) {
        if (sorted[i] == sorted[i - 1] + 1) {
          current.add(sorted[i]);
        } else {
          clusters.add(current);
          current = <int>[sorted[i]];
        }
      }
      clusters.add(current);

      final List<HourRange> ranges = [];
      for (final c in clusters) {
        final startMin = c.first * minutesPerSlot;
        final endMin = (c.last + 1) * minutesPerSlot;
        final sh = startMin ~/ 60;
        final sm = startMin % 60;
        final eh = endMin ~/ 60;
        final em = endMin % 60;
        ranges.add(HourRange(sh, sm, eh, em));
      }
      return ranges;
    }

    // Helper: elimina una fascia oraria
    Future<void> deleteShift(int staffId, int weekday, int shiftIndex) async {
      final layout = ref.read(layoutConfigProvider);
      final asyncByStaff = ref.read(staffAvailabilityByStaffProvider);
      final allData = asyncByStaff.value;
      if (allData == null) return;

      final staffData = allData[staffId];
      if (staffData == null) return;

      final daySlots = staffData[weekday];
      if (daySlots == null || daySlots.isEmpty) return;

      // Converti slots in ranges per identificare quale eliminare
      final ranges = slotsToRanges(daySlots, layout.minutesPerSlot);
      if (shiftIndex >= ranges.length) return;

      final rangeToDelete = ranges[shiftIndex];

      // Rimuovi gli slot corrispondenti a questa fascia
      final newSlots = Set<int>.from(daySlots);
      final startSlot =
          (rangeToDelete.startHour * 60 + rangeToDelete.startMinute) ~/
          layout.minutesPerSlot;
      final endSlot =
          (rangeToDelete.endHour * 60 + rangeToDelete.endMinute) ~/
          layout.minutesPerSlot;
      for (int slot = startSlot; slot < endSlot; slot++) {
        newSlots.remove(slot);
      }

      // Aggiorna il provider
      final newStaffData = Map<int, Set<int>>.from(staffData);
      newStaffData[weekday] = newSlots;

      await ref
          .read(staffAvailabilityByStaffProvider.notifier)
          .saveForStaff(staffId, newStaffData);
    }

    // Helper: mostra menu per eccezione "tutto il giorno"
    void showAllDayExceptionMenu(int staffId, int weekday, DateTime date) {
      final l10n = context.l10n;
      final isMobile = formFactor == AppFormFactor.mobile;
      final locale = Intl.getCurrentLocale();
      final dateLabel = DateFormat('EEEE d MMMM', locale).format(date);
      final staff = staffList.firstWhere(
        (s) => s.id == staffId,
        orElse: () => staffList.first,
      );
      final staffName = staff.displayName;

      // Trova tutte le eccezioni per questa data
      AvailabilityException? findAllDayException() {
        final exceptions = ref.read(
          exceptionsForStaffOnDateProvider((staffId: staffId, date: date)),
        );
        for (final exc in exceptions) {
          if (exc.isAllDay) return exc;
        }
        return null;
      }

      Future<void> deleteAllDayException() async {
        final exceptions = ref.read(
          exceptionsForStaffOnDateProvider((staffId: staffId, date: date)),
        );
        // Elimina tutte le eccezioni per questa data
        for (final exc in exceptions) {
          await ref
              .read(availabilityExceptionsProvider.notifier)
              .deleteException(staffId, exc.id);
        }
      }

      Widget buildContent(BuildContext ctx) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            ListTile(
              leading: const Icon(Icons.edit_calendar_outlined),
              title: Text(l10n.exceptionEditShift),
              subtitle: Text(
                l10n.exceptionEditShiftDesc,
                style: Theme.of(ctx).textTheme.bodySmall,
              ),
              onTap: () async {
                final exc = findAllDayException();
                if (exc == null) return;
                Navigator.pop(ctx);
                await showAddExceptionDialog(
                  context,
                  ref,
                  staffId: staffId,
                  initial: exc,
                );
              },
            ),
            const Divider(height: 1),
            ListTile(
              leading: Icon(
                Icons.restore_outlined,
                color: Theme.of(ctx).colorScheme.error,
              ),
              title: Text(
                l10n.exceptionDeleteShift,
                style: TextStyle(color: Theme.of(ctx).colorScheme.error),
              ),
              subtitle: Text(
                l10n.exceptionDeleteShiftDesc,
                style: Theme.of(ctx).textTheme.bodySmall,
              ),
              onTap: () async {
                Navigator.pop(ctx);
                await deleteAllDayException();
              },
            ),
          ],
        );
      }

      if (isMobile) {
        AppBottomSheet.show(
          context: context,
          heightFactor: null,
          builder: (ctx) => Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              Center(
                child: Column(
                  children: [
                    StaffCircleAvatar(
                      height: 48,
                      color: staff.color,
                      isHighlighted: false,
                      initials: staff.initials,
                    ),
                    const SizedBox(height: 8),
                    Text(
                      staffName,
                      style: Theme.of(ctx).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                      textAlign: TextAlign.center,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 4),
              Text(
                dateLabel,
                style: Theme.of(ctx).textTheme.bodySmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              buildContent(ctx),
            ],
          ),
        );
      } else {
        showDialog(
          context: context,
          builder: (ctx) => AppFormDialog(
            title: Center(
              child: Column(
                children: [
                  StaffCircleAvatar(
                    height: 48,
                    color: staff.color,
                    isHighlighted: false,
                    initials: staff.initials,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    staffName,
                    style: Theme.of(ctx).textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                    textAlign: TextAlign.center,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 4),
                  Text(
                    dateLabel,
                    style: Theme.of(ctx).textTheme.bodySmall,
                    textAlign: TextAlign.center,
                  ),
                ],
              ),
            ),
            content: buildContent(ctx),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(ctx),
                child: Text(l10n.actionCancel),
              ),
            ],
          ),
        );
      }
    }

    // Helper: mostra menu opzioni per una fascia oraria
    void showShiftOptionsMenu(
      int staffId,
      int weekday,
      int shiftIndex,
      HourRange range,
      DateTime date, {
      bool isException = false,
    }) {
      final l10n = context.l10n;
      final isMobile = formFactor == AppFormFactor.mobile;
      final locale = Intl.getCurrentLocale();
      // Data in formato completo: "luned√¨ 1 dicembre"
      final dateLabel = DateFormat('EEEE d MMMM', locale).format(date);
      final dayName = DateFormat(
        'EEEE',
        locale,
      ).format(date); // Nome giorno completo
      // Nome completo dello staff
      final staff = staffList.firstWhere(
        (s) => s.id == staffId,
        orElse: () => staffList.first,
      );
      final staffName = staff.displayName;

      // Helper per eliminare solo questo turno (crea eccezione)
      Future<void> deleteThisOnly() async {
        await ref
            .read(availabilityExceptionsProvider.notifier)
            .addException(
              staffId: staffId,
              date: date,
              startTime: TimeOfDay(
                hour: range.startHour,
                minute: range.startMinute,
              ),
              endTime: TimeOfDay(hour: range.endHour, minute: range.endMinute),
              type: AvailabilityExceptionType.unavailable,
              reason: null,
            );
      }

      // Helper per eliminare tutti i turni (dalla disponibilit√† settimanale)
      Future<void> deleteAll() async {
        await deleteShift(staffId, weekday, shiftIndex);
      }

      // Helper per modificare solo questo turno (apre dialog per eccezione)
      Future<void> editThisOnly() async {
        final result = await _showEditShiftDialog(
          context: context,
          ref: ref,
          range: range,
          dateLabel: dateLabel,
          formFactor: formFactor,
        );
        if (result != null) {
          Future<void> addDeltaException(
            int startMinutes,
            int endMinutes,
            AvailabilityExceptionType type,
          ) async {
            if (endMinutes <= startMinutes) return;
            await ref
                .read(availabilityExceptionsProvider.notifier)
                .addException(
                  staffId: staffId,
                  date: date,
                  startTime: TimeOfDay(
                    hour: startMinutes ~/ 60,
                    minute: startMinutes % 60,
                  ),
                  endTime: TimeOfDay(
                    hour: endMinutes ~/ 60,
                    minute: endMinutes % 60,
                  ),
                  type: type,
                  reason: null,
                );
          }

          final baseStartMinutes = range.startHour * 60 + range.startMinute;
          final baseEndMinutes = range.endHour * 60 + range.endMinute;
          final newStartMinutes =
              result.startTime.hour * 60 + result.startTime.minute;
          final newEndMinutes =
              result.endTime.hour * 60 + result.endTime.minute;

          // Rimuovi le ore tolte rispetto al turno base
          if (newStartMinutes > baseStartMinutes) {
            await addDeltaException(
              baseStartMinutes,
              newStartMinutes,
              AvailabilityExceptionType.unavailable,
            );
          }
          if (newEndMinutes < baseEndMinutes) {
            await addDeltaException(
              newEndMinutes,
              baseEndMinutes,
              AvailabilityExceptionType.unavailable,
            );
          }

          // Aggiungi eventuali estensioni rispetto al turno base
          if (newStartMinutes < baseStartMinutes) {
            await addDeltaException(
              newStartMinutes,
              baseStartMinutes,
              AvailabilityExceptionType.available,
            );
          }
          if (newEndMinutes > baseEndMinutes) {
            await addDeltaException(
              baseEndMinutes,
              newEndMinutes,
              AvailabilityExceptionType.available,
            );
          }
        }
      }

      // Helper per modificare tutti i turni (naviga all'editor settimanale)
      void editAll() {
        final vn = ref.read(initialStaffToEditProvider);
        vn.value = staffId;
        Navigator.of(context).push(
          MaterialPageRoute(builder: (_) => const StaffAvailabilityScreen()),
        );
      }

      // Helper per trovare l'eccezione corrispondente a questo range
      AvailabilityException? findMatchingException() {
        final monday = _mondayOfWeek(ref.read(agendaDateProvider));
        final specificDate = monday.add(Duration(days: weekday - 1));
        final exceptions = ref.read(
          exceptionsForStaffOnDateProvider((
            staffId: staffId,
            date: specificDate,
          )),
        );
        final isAllDayRange =
            range.startHour == 0 &&
            range.startMinute == 0 &&
            range.endHour == 24 &&
            range.endMinute == 0;
        // Cerca l'eccezione che corrisponde a questo range orario
        for (final exc in exceptions) {
          if (isAllDayRange && exc.isAllDay) return exc;
          if (exc.startTime != null &&
              exc.endTime != null &&
              exc.startTime!.hour == range.startHour &&
              exc.startTime!.minute == range.startMinute &&
              exc.endTime!.hour == range.endHour &&
              exc.endTime!.minute == range.endMinute) {
            return exc;
          }
        }
        return null;
      }

      // Helper per eliminare un'eccezione
      Future<void> deleteException() async {
        final exc = findMatchingException();
        if (exc != null) {
          await ref
              .read(availabilityExceptionsProvider.notifier)
              .deleteException(staffId, exc.id);
        }
      }

      // Helper per modificare un'eccezione
      Future<void> editException() async {
        final exc = findMatchingException();
        if (exc == null) return;

        if (exc.isAllDay) {
          await showAddExceptionDialog(
            context,
            ref,
            staffId: staffId,
            initial: exc,
          );
          return;
        }

        final result = await _showEditShiftDialog(
          context: context,
          ref: ref,
          range: range,
          dateLabel: dateLabel,
          formFactor: formFactor,
        );
        if (result != null) {
          // Aggiorna l'eccezione esistente con i nuovi orari
          final updatedExc = exc.copyWith(
            startTime: result.startTime,
            endTime: result.endTime,
          );
          await ref
              .read(availabilityExceptionsProvider.notifier)
              .updateException(updatedExc);
        }
      }

      // Lista opzioni
      Widget buildOptionsList(BuildContext ctx) {
        // Se √® un'eccezione, mostra solo modifica/elimina eccezione
        if (isException) {
          return Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Modifica eccezione
              ListTile(
                leading: const Icon(Icons.edit_calendar_outlined),
                title: Text(l10n.exceptionEditShift),
                subtitle: Text(
                  l10n.exceptionEditShiftDesc,
                  style: Theme.of(ctx).textTheme.bodySmall,
                ),
                onTap: () async {
                  Navigator.pop(ctx);
                  await editException();
                },
              ),
              const Divider(height: 1),
              // Elimina eccezione
              ListTile(
                leading: Icon(
                  Icons.restore_outlined,
                  color: Theme.of(ctx).colorScheme.error,
                ),
                title: Text(
                  l10n.exceptionDeleteShift,
                  style: TextStyle(color: Theme.of(ctx).colorScheme.error),
                ),
                subtitle: Text(
                  l10n.exceptionDeleteShiftDesc,
                  style: Theme.of(ctx).textTheme.bodySmall,
                ),
                onTap: () async {
                  Navigator.pop(ctx);
                  await deleteException();
                },
              ),
            ],
          );
        }

        // Menu standard per turni base
        return Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Modifica solo questo turno
            ListTile(
              leading: const Icon(Icons.edit_calendar_outlined),
              title: Text(l10n.shiftEditThisOnly),
              subtitle: Text(
                l10n.shiftEditThisOnlyDesc(dateLabel),
                style: Theme.of(ctx).textTheme.bodySmall,
              ),
              onTap: () async {
                Navigator.pop(ctx);
                await editThisOnly();
              },
            ),
            // Modifica tutti questi turni
            ListTile(
              leading: const Icon(Icons.edit_outlined),
              title: Text(l10n.shiftEditAll),
              subtitle: Text(
                l10n.shiftEditAllDesc(dayName),
                style: Theme.of(ctx).textTheme.bodySmall,
              ),
              onTap: () {
                Navigator.pop(ctx);
                editAll();
              },
            ),
            const Divider(height: 1),
            // Elimina solo questo turno
            ListTile(
              leading: Icon(
                Icons.event_busy_outlined,
                color: Theme.of(ctx).colorScheme.error,
              ),
              title: Text(
                l10n.shiftDeleteThisOnly,
                style: TextStyle(color: Theme.of(ctx).colorScheme.error),
              ),
              subtitle: Text(
                l10n.shiftDeleteThisOnlyDesc(dateLabel),
                style: Theme.of(ctx).textTheme.bodySmall,
              ),
              onTap: () async {
                Navigator.pop(ctx);
                await deleteThisOnly();
              },
            ),
            // Elimina tutti questi turni
            ListTile(
              leading: Icon(
                Icons.delete_outline,
                color: Theme.of(ctx).colorScheme.error,
              ),
              title: Text(
                l10n.shiftDeleteAll,
                style: TextStyle(color: Theme.of(ctx).colorScheme.error),
              ),
              subtitle: Text(
                l10n.shiftDeleteAllDesc(dayName),
                style: Theme.of(ctx).textTheme.bodySmall,
              ),
              onTap: () async {
                Navigator.pop(ctx);
                await deleteAll();
              },
            ),
          ],
        );
      }

      if (isMobile) {
        // Mobile: AppBottomSheet con avatar e nome
        AppBottomSheet.show(
          context: context,
          heightFactor: null, // Auto-size
          builder: (ctx) => Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Avatar con nome sotto
              Center(
                child: Column(
                  children: [
                    StaffCircleAvatar(
                      height: 48,
                      color: staff.color,
                      isHighlighted: false,
                      initials: staff.initials,
                    ),
                    const SizedBox(height: 8),
                    Text(
                      staffName,
                      style: Theme.of(ctx).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                      textAlign: TextAlign.center,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ],
                ),
              ),
              const SizedBox(height: 4),
              Text(
                '${range.label(ctx)} ‚Ä¢ $dateLabel',
                style: Theme.of(ctx).textTheme.bodySmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              buildOptionsList(ctx),
            ],
          ),
        );
      } else {
        // Desktop/Tablet: AppFormDialog con avatar centrato
        showDialog(
          context: context,
          builder: (ctx) => AppFormDialog(
            title: Center(
              child: Column(
                children: [
                  StaffCircleAvatar(
                    height: 48,
                    color: staff.color,
                    isHighlighted: false,
                    initials: staff.initials,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    staffName,
                    style: Theme.of(ctx).textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                    textAlign: TextAlign.center,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 4),
                  Text(
                    '${range.label(ctx)} ‚Ä¢ $dateLabel',
                    style: Theme.of(ctx).textTheme.bodySmall,
                    textAlign: TextAlign.center,
                  ),
                ],
              ),
            ),
            content: buildOptionsList(ctx),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(ctx),
                child: Text(l10n.actionCancel),
              ),
            ],
          ),
        );
      }
    }

    // _DisplayRange √® definita a livello di file per poter essere usata nel sort.

    Widget buildDayCell(
      List<HourRange> ranges,
      List<AvailabilityException> exceptions,
      int staffId,
      int weekday,
      DateTime date, {
      bool hasException = false,
    }) {
      final displayRanges = _mergeRangesForDisplay(
        ranges,
        exceptions,
        context,
        applyUnavailableSplit: false,
        subtractAvailableFromBase: true,
      );
      final hasAllDayAvailable = exceptions.any(
        (e) =>
            e.type == AvailabilityExceptionType.available &&
            e.startTime == null &&
            e.endTime == null,
      );

      Widget buildAllDayChip() {
        final bgColor = hasAllDayAvailable
            ? chipColorWithAvailableException
            : chipColorWithException.withOpacity(0.45);
        final textColor = hasAllDayAvailable
            ? chipTextColorWithAvailableException
            : chipDisabledTextColor.withOpacity(0.7);
        final borderRadius = BorderRadius.circular(6);
        final borderColor = AgendaTheme.appointmentBorder.withOpacity(0.4);
        return Material(
          color: Colors.transparent,
          child: InkWell(
            borderRadius: BorderRadius.circular(6),
            onTap: () {
              // Mostra menu per eccezione "tutto il giorno"
              showAllDayExceptionMenu(staffId, weekday, date);
            },
            child: CustomPaint(
              painter: hasAllDayAvailable
                  ? null
                  : _DashedRoundedRectPainter(
                      color: borderColor,
                      radius: 6,
                    ),
              child: Container(
                height: chipHeight,
                padding: const EdgeInsets.symmetric(horizontal: 8),
                alignment: Alignment.center,
                decoration: BoxDecoration(
                  color: bgColor,
                  borderRadius: borderRadius,
                  border: hasAllDayAvailable
                      ? Border.all(
                          color: AgendaTheme.appointmentBorder,
                          width: 0.6,
                        )
                      : null,
                ),
                child: Text(
                  context.l10n.exceptionAllDay,
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.w600,
                    color: textColor,
                  ),
                ),
              ),
            ),
          ),
        );
      }

      Widget buildChipForRange(_DisplayRange range) {
        final isAvailableException =
            range.exceptionType == AvailabilityExceptionType.available;
        final isUnavailableException =
            range.exceptionType == AvailabilityExceptionType.unavailable;
        final bgColor = range.isException
            ? (isAvailableException
                  ? chipColorWithAvailableException
                  : chipColorWithException.withOpacity(0.45))
            : chipColor;
        final textColor = range.isException
            ? (isAvailableException
                  ? chipTextColorWithAvailableException
                  : chipDisabledTextColor.withOpacity(0.7))
            : Colors.black87;
        final borderRadius = BorderRadius.circular(6);
        final borderColor = AgendaTheme.appointmentBorder.withOpacity(0.4);
        return Material(
          color: Colors.transparent,
          child: InkWell(
            borderRadius: BorderRadius.circular(6),
            onTap: () {
              if (range.hourRange != null) {
                final isAllDayRange =
                    range.hourRange!.startHour == 0 &&
                    range.hourRange!.startMinute == 0 &&
                    range.hourRange!.endHour == 24 &&
                    range.hourRange!.endMinute == 0;
                if (range.isException && isAllDayRange) {
                  AvailabilityException? exc;
                  for (final e in exceptions) {
                    if (e.isAllDay) {
                      exc = e;
                      break;
                    }
                  }
                  if (exc != null) {
                    showAddExceptionDialog(
                      context,
                      ref,
                      staffId: staffId,
                      initial: exc,
                    );
                    return;
                  }
                }
                if (range.isException && !isAllDayRange) {
                  AvailabilityException? exc;
                  for (final e in exceptions) {
                    if (e.startTime == null || e.endTime == null) continue;
                    if (e.startTime!.hour == range.hourRange!.startHour &&
                        e.startTime!.minute == range.hourRange!.startMinute &&
                        e.endTime!.hour == range.hourRange!.endHour &&
                        e.endTime!.minute == range.hourRange!.endMinute) {
                      exc = e;
                      break;
                    }
                  }
                  if (exc != null) {
                    showAddExceptionDialog(
                      context,
                      ref,
                      staffId: staffId,
                      initial: exc,
                    );
                    return;
                  }
                }
                showShiftOptionsMenu(
                  staffId,
                  weekday,
                  0,
                  range.hourRange!,
                  date,
                  isException: range.isException,
                );
              }
            },
            child: CustomPaint(
              painter: isUnavailableException
                  ? _DashedRoundedRectPainter(color: borderColor, radius: 6)
                  : null,
              child: Container(
                height: chipHeight,
                padding: const EdgeInsets.symmetric(horizontal: 8),
                alignment: Alignment.center,
                decoration: BoxDecoration(
                  color: bgColor,
                  borderRadius: borderRadius,
                  border: isUnavailableException
                      ? null
                      : Border.all(
                          color: AgendaTheme.appointmentBorder,
                          width: 0.6,
                        ),
                ),
                child: Text(
                  range.label,
                  maxLines: 1,
                  style: TextStyle(
                    fontSize: 12,
                    fontWeight: FontWeight.w600,
                    color: textColor,
                  ),
                ),
              ),
            ),
          ),
        );
      }

      return Column(
        crossAxisAlignment: CrossAxisAlignment.center,
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const SizedBox(height: chipTopPadding),
          if (displayRanges.isEmpty && hasException) ...[
            buildAllDayChip(),
            SizedBox(height: chipVGap),
          ],
          for (int i = 0; i < displayRanges.length; i++) ...[
            buildChipForRange(displayRanges[i]),
            SizedBox(height: chipVGap),
          ],
          Material(
            color: Colors.transparent,
            child: InkWell(
              borderRadius: BorderRadius.circular(6),
              onTap: () {
                showAddExceptionDialog(
                  context,
                  ref,
                  staffId: staffId,
                  date: date,
                );
              },
              child: Container(
                height: chipHeight,
                padding: const EdgeInsets.symmetric(horizontal: 8),
                alignment: Alignment.center,
                decoration: BoxDecoration(
                  color: Colors.transparent,
                  borderRadius: BorderRadius.circular(6),
                  border: Border.all(
                    color: AgendaTheme.appointmentBorder.withOpacity(0.6),
                    width: 0.6,
                  ),
                ),
                child: Icon(
                  Icons.add,
                  size: 18,
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
              ),
            ),
          ),
        ],
      );
    }

    return Scaffold(
      appBar: AppBar(
        centerTitle: true,
        leading: const BackButton(),
        title: Padding(
          padding: EdgeInsets.only(
            left: formFactor == AppFormFactor.mobile ? staffColWidth - 64.0 : 0,
          ),
          child: StaffTopControls(
            todayLabel: context.l10n.currentWeek,
            labelOverride: weekLabel,
            compact: formFactor != AppFormFactor.desktop,
          ),
        ),
      ),
      body: ScrollConfiguration(
        behavior: const NoScrollbarBehavior(),
        child: Column(
          children: [
            const SizedBox(height: 24),
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SizedBox(width: staffColWidth),
                const SizedBox(width: 8),
                Expanded(
                  child: SingleChildScrollView(
                    controller: _headerHController,
                    physics: const NeverScrollableScrollPhysics(),
                    scrollDirection: Axis.horizontal,
                    child: Row(
                      children: [
                        for (final d in days) ...[
                          SizedBox(
                            width: dayColumnWidth,
                            child: buildDayHeaderCell(d),
                          ),
                          if (d != days.last) const SizedBox(width: 8),
                        ],
                        const SizedBox(width: rightPadding),
                      ],
                    ),
                  ),
                ),
              ],
            ),
            const SizedBox(height: 12),
            // Body
            Expanded(
              child: SingleChildScrollView(
                controller: _vScrollController,
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Staff column
                    SizedBox(
                      width: staffColWidth,
                      child: Column(
                        children: [
                          for (int i = 0; i < staffList.length; i++) ...[
                            Container(
                              height: rowHeightForStaff(staffList[i].id),
                              padding: const EdgeInsets.symmetric(
                                horizontal: 8,
                              ),
                              alignment: Alignment.centerLeft,
                              child: buildStaffHeaderCell(staffList[i].id),
                            ),
                            divider,
                            if (i < staffList.length - 1)
                              const SizedBox(height: staffRowGap),
                          ],
                        ],
                      ),
                    ),
                    // Gap column with matching row dividers
                    SizedBox(
                      width: 8,
                      child: Column(
                        children: [
                          for (int i = 0; i < staffList.length; i++) ...[
                            SizedBox(
                              height: rowHeightForStaff(staffList[i].id),
                            ),
                            divider,
                            if (i < staffList.length - 1)
                              const SizedBox(height: staffRowGap),
                          ],
                        ],
                      ),
                    ),
                    // Days grid (with vertical separators between columns)
                    Expanded(
                      child: SingleChildScrollView(
                        controller: _bodyHController,
                        physics: const ClampingScrollPhysics(),
                        scrollDirection: Axis.horizontal,
                        child: Column(
                          children: [
                            for (int i = 0; i < staffList.length; i++) ...[
                              // Row of day cells + vertical gaps
                              Row(
                                children: [
                                  for (final d in days) ...[
                                    SizedBox(
                                      width: dayColumnWidth,
                                      height: rowHeightForStaff(
                                        staffList[i].id,
                                      ),
                                      child: buildDayCell(
                                        (availability[staffList[i].id]?[d.weekday]) ??
                                            const <HourRange>[],
                                        ref.watch(
                                          exceptionsForStaffOnDateProvider((
                                            staffId: staffList[i].id,
                                            date: d,
                                          )),
                                        ),
                                        staffList[i].id,
                                        d.weekday,
                                        d,
                                        hasException:
                                            exceptionDays[staffList[i].id]?.contains(
                                              d.weekday,
                                            ) ??
                                            false,
                                      ),
                                    ),
                                    if (d != days.last)
                                      SizedBox(
                                        width: 8,
                                        height: rowHeightForStaff(
                                          staffList[i].id,
                                        ),
                                      ),
                                  ],
                                  SizedBox(
                                    width: rightPadding,
                                    height: rowHeightForStaff(
                                      staffList[i].id,
                                    ),
                                  ),
                                ],
                              ),
                              // Single full-width horizontal divider spanning day cells + gaps
                              Builder(
                                builder: (context) {
                                  final daysRowWidth =
                                      days.length * dayColumnWidth +
                                      (days.length - 1) * 8 +
                                      rightPadding;
                                  return SizedBox(
                                    width: daysRowWidth,
                                    child: divider,
                                  );
                                },
                              ),
                              if (i < staffList.length - 1)
                                const SizedBox(height: staffRowGap),
                            ],
                          ],
                        ),
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
      bottomNavigationBar: formFactor != AppFormFactor.mobile
          ? null
          : SafeArea(
              top: false,
              bottom: true,
              minimum: const EdgeInsets.only(bottom: 15),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const AgendaHorizontalDivider(),
                  Padding(
                    padding: EdgeInsetsDirectional.only(
                      start: formFactor == AppFormFactor.mobile
                          ? 0
                          : staffColWidth + 8,
                      top: 15,
                      bottom: 1,
                    ),
                    child: AgendaDateSwitcher(
                      label: weekLabel,
                      selectedDate: effectivePickerDate,
                      onPreviousWeek: ref
                          .read(agendaDateProvider.notifier)
                          .previousWeek,
                      onNextWeek: ref
                          .read(agendaDateProvider.notifier)
                          .nextWeek,
                      onSelectDate: (date) {
                        ref
                            .read(agendaDateProvider.notifier)
                            .set(DateUtils.dateOnly(date));
                      },
                      useWeekRangePicker: true,
                      isCompact: true,
                    ),
                  ),
                ],
              ),
            ),
    );
  }
}

/// Risultato della modifica di un turno.
class _EditShiftResult {
  final TimeOfDay startTime;
  final TimeOfDay endTime;

  const _EditShiftResult({required this.startTime, required this.endTime});
}

/// Mostra il dialog per modificare un turno (solo gli orari).
Future<_EditShiftResult?> _showEditShiftDialog({
  required BuildContext context,
  required WidgetRef ref,
  required HourRange range,
  required String dateLabel,
  required AppFormFactor formFactor,
}) async {
  final isMobile = formFactor == AppFormFactor.mobile;

  if (isMobile) {
    return AppBottomSheet.show<_EditShiftResult>(
      context: context,
      heightFactor: null,
      builder: (ctx) => _EditShiftContent(range: range, dateLabel: dateLabel),
    );
  } else {
    return showDialog<_EditShiftResult>(
      context: context,
      builder: (ctx) => Dialog(
        child: ConstrainedBox(
          constraints: const BoxConstraints(maxWidth: 400),
          child: _EditShiftContent(
            range: range,
            dateLabel: dateLabel,
            isDialog: true,
          ),
        ),
      ),
    );
  }
}

/// Widget per il contenuto del dialog di modifica turno.
class _EditShiftContent extends ConsumerStatefulWidget {
  const _EditShiftContent({
    required this.range,
    required this.dateLabel,
    this.isDialog = false,
  });

  final HourRange range;
  final String dateLabel;
  final bool isDialog;

  @override
  ConsumerState<_EditShiftContent> createState() => _EditShiftContentState();
}

class _EditShiftContentState extends ConsumerState<_EditShiftContent> {
  late TimeOfDay _startTime;
  late TimeOfDay _endTime;
  String? _timeError;

  @override
  void initState() {
    super.initState();
    _startTime = TimeOfDay(
      hour: widget.range.startHour,
      minute: widget.range.startMinute,
    );
    _endTime = TimeOfDay(
      hour: widget.range.endHour,
      minute: widget.range.endMinute,
    );
  }

  String _formatTime(TimeOfDay time) {
    return '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';
  }

  Future<void> _pickTime({required bool isStart}) async {
    final layout = ref.read(layoutConfigProvider);
    final step = layout.minutesPerSlot;
    final selected = await AppBottomSheet.show<TimeOfDay>(
      context: context,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
      builder: (ctx) {
        final height = MediaQuery.of(ctx).size.height * 0.7;
        return SizedBox(
          height: height,
          child: _TimeGridPicker(
            initial: isStart ? _startTime : _endTime,
            stepMinutes: step,
          ),
        );
      },
    );
    if (selected != null) {
      setState(() {
        _timeError = null;
        if (isStart) {
          _startTime = selected;
          // Se l'orario di fine √® prima dell'inizio, aggiustalo
          final startMinutes = _startTime.hour * 60 + _startTime.minute;
          final endMinutes = _endTime.hour * 60 + _endTime.minute;
          if (endMinutes <= startMinutes) {
            _endTime = TimeOfDay(
              hour: (_startTime.hour + 1).clamp(0, 23),
              minute: _startTime.minute,
            );
          }
        } else {
          _endTime = selected;
        }
      });
    }
  }

  bool _validate() {
    final l10n = context.l10n;
    final startMinutes = _startTime.hour * 60 + _startTime.minute;
    final endMinutes = _endTime.hour * 60 + _endTime.minute;
    if (endMinutes <= startMinutes) {
      setState(() => _timeError = l10n.exceptionTimeError);
      return false;
    }
    return true;
  }

  void _onSave() {
    if (!_validate()) return;
    Navigator.of(
      context,
    ).pop(_EditShiftResult(startTime: _startTime, endTime: _endTime));
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;

    final content = Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // Riga orari
        Row(
          children: [
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    l10n.shiftStartTime,
                    style: Theme.of(context).textTheme.labelMedium,
                  ),
                  const SizedBox(height: 4),
                  InkWell(
                    onTap: () => _pickTime(isStart: true),
                    child: InputDecorator(
                      decoration: InputDecoration(
                        border: const OutlineInputBorder(),
                        isDense: true,
                        enabledBorder: _timeError != null
                            ? OutlineInputBorder(
                                borderSide: BorderSide(
                                  color: colorScheme.error,
                                ),
                              )
                            : null,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_formatTime(_startTime)),
                          const Icon(Icons.access_time, size: 16),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(width: 12),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    l10n.shiftEndTime,
                    style: Theme.of(context).textTheme.labelMedium,
                  ),
                  const SizedBox(height: 4),
                  InkWell(
                    onTap: () => _pickTime(isStart: false),
                    child: InputDecorator(
                      decoration: InputDecoration(
                        border: const OutlineInputBorder(),
                        isDense: true,
                        enabledBorder: _timeError != null
                            ? OutlineInputBorder(
                                borderSide: BorderSide(
                                  color: colorScheme.error,
                                ),
                              )
                            : null,
                      ),
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          Text(_formatTime(_endTime)),
                          const Icon(Icons.access_time, size: 16),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
        if (_timeError != null) ...[
          const SizedBox(height: 8),
          Text(
            _timeError!,
            style: TextStyle(color: colorScheme.error, fontSize: 12),
          ),
        ],
        const SizedBox(height: 24),
        // Bottoni
        Row(
          mainAxisAlignment: MainAxisAlignment.end,
          children: [
            AppOutlinedActionButton(
              onPressed: () => Navigator.of(context).pop(),
              padding: AppButtonStyles.dialogButtonPadding,
              child: Text(l10n.actionCancel),
            ),
            const SizedBox(width: 8),
            AppFilledButton(
              onPressed: _onSave,
              padding: AppButtonStyles.dialogButtonPadding,
              child: Text(l10n.actionSave),
            ),
          ],
        ),
      ],
    );

    if (widget.isDialog) {
      return Padding(
        padding: const EdgeInsets.all(20),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              l10n.shiftEditTitle,
              style: Theme.of(context).textTheme.titleLarge,
            ),
            Text(
              widget.dateLabel,
              style: Theme.of(context).textTheme.bodySmall,
            ),
            const SizedBox(height: 16),
            content,
          ],
        ),
      );
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          l10n.shiftEditTitle,
          style: Theme.of(
            context,
          ).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
          textAlign: TextAlign.center,
        ),
        Text(widget.dateLabel, style: Theme.of(context).textTheme.bodySmall),
        const SizedBox(height: 16),
        content,
      ],
    );
  }
}

/// Widget per la selezione dell'orario con griglia.
class _TimeGridPicker extends StatefulWidget {
  const _TimeGridPicker({required this.initial, required this.stepMinutes});

  final TimeOfDay initial;
  final int stepMinutes;

  @override
  State<_TimeGridPicker> createState() => _TimeGridPickerState();
}

class _TimeGridPickerState extends State<_TimeGridPicker> {
  final ScrollController _scrollController = ScrollController();
  late final List<TimeOfDay?> _times;
  late final int _scrollToIndex;

  @override
  void initState() {
    super.initState();

    // Genera lista di orari con step specificato (da 00:00 a 24:00)
    _times = <TimeOfDay?>[];
    for (int m = 0; m <= 24 * 60; m += widget.stepMinutes) {
      final h = m ~/ 60;
      final min = m % 60;
      _times.add(TimeOfDay(hour: h, minute: min));
    }

    // Verifica se l'orario iniziale √® gi√† nella lista
    int exactIndex = _times.indexWhere(
      (t) =>
          t != null &&
          t.hour == widget.initial.hour &&
          t.minute == widget.initial.minute,
    );

    if (exactIndex >= 0) {
      // L'orario √® gi√† presente
      _scrollToIndex = exactIndex;
    } else {
      // L'orario non √® presente: inserisci una NUOVA RIGA con l'orario
      // nella colonna corretta e le altre colonne vuote
      final columnsPerRow = 60 ~/ widget.stepMinutes;
      final targetColumn = widget.initial.minute ~/ widget.stepMinutes;
      final baseIndex = (widget.initial.hour + 1) * columnsPerRow;

      // Crea la nuova riga con 4 elementi (solo uno valorizzato)
      final newRow = List<TimeOfDay?>.filled(columnsPerRow, null);
      newRow[targetColumn] = widget.initial;

      // Inserisci la nuova riga
      final insertIndex = baseIndex.clamp(0, _times.length);
      _times.insertAll(insertIndex, newRow);

      // L'indice dell'orario selezionato √® la posizione nella nuova riga
      _scrollToIndex = insertIndex + targetColumn;
    }

    // Scrolla all'orario preimpostato dopo il primo frame
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _scrollToSelected();
    });
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  void _scrollToSelected() {
    const crossAxisCount = 4;
    const mainAxisSpacing = 8.0;
    const crossAxisSpacing = 8.0;
    const padding = 8.0;

    // Calcola la riga in cui si trova l'elemento selezionato
    final row = _scrollToIndex ~/ crossAxisCount;

    // Stima l'altezza di ogni cella basandosi su una larghezza ragionevole
    if (_scrollController.hasClients) {
      final viewportWidth = _scrollController.position.viewportDimension > 0
          ? MediaQuery.of(context).size.width - padding * 2
          : 300.0;
      final cellWidth =
          (viewportWidth - crossAxisSpacing * (crossAxisCount - 1)) /
          crossAxisCount;
      final cellHeight = cellWidth / 2.5; // childAspectRatio = 2.5
      final rowHeight = cellHeight + mainAxisSpacing;

      // Calcola l'offset per centrare l'elemento selezionato
      final targetOffset = row * rowHeight;
      final maxScroll = _scrollController.position.maxScrollExtent;
      final scrollTo = targetOffset.clamp(0.0, maxScroll);

      _scrollController.animateTo(
        scrollTo,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final colorScheme = Theme.of(context).colorScheme;

    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.all(16),
          child: Text(
            l10n.exceptionSelectTime,
            style: Theme.of(context).textTheme.titleMedium,
          ),
        ),
        Expanded(
          child: GridView.builder(
            controller: _scrollController,
            padding: const EdgeInsets.all(8),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 4,
              childAspectRatio: 2.5,
              crossAxisSpacing: 8,
              mainAxisSpacing: 8,
            ),
            itemCount: _times.length,
            itemBuilder: (context, index) {
              final time = _times[index];
              // Se la cella √® vuota, mostra uno spazio vuoto
              if (time == null) {
                return const SizedBox.shrink();
              }
              final isSelected = index == _scrollToIndex;
              final label = time.hour == 24
                  ? '24:00'
                  : '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';

              return Material(
                color: isSelected
                    ? colorScheme.primaryContainer
                    : colorScheme.surfaceContainerHighest,
                borderRadius: BorderRadius.circular(8),
                child: InkWell(
                  onTap: () {
                    // Chiudi immediatamente con il valore selezionato
                    Navigator.of(context).pop(time);
                  },
                  borderRadius: BorderRadius.circular(8),
                  child: Center(
                    child: Text(
                      label,
                      style: TextStyle(
                        fontWeight: isSelected
                            ? FontWeight.bold
                            : FontWeight.normal,
                        color: isSelected
                            ? colorScheme.onPrimaryContainer
                            : colorScheme.onSurface,
                      ),
                    ),
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }
}
--- FILE: lib/features/staff/presentation/widgets/weekly_schedule_editor.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/extensions.dart';
import 'package:agenda_backend/core/l10n/l10_extension.dart';
import 'package:agenda_backend/features/agenda/domain/config/layout_config.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Rappresenta un singolo turno di lavoro (orario inizio - orario fine).
class WorkShift {
  final TimeOfDay startTime;
  final TimeOfDay endTime;

  const WorkShift({required this.startTime, required this.endTime});

  WorkShift copyWith({TimeOfDay? startTime, TimeOfDay? endTime}) {
    return WorkShift(
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
    );
  }

  /// Durata in minuti del turno.
  int get durationMinutes {
    final startMinutes = startTime.hour * 60 + startTime.minute;
    final endMinutes = endTime.hour * 60 + endTime.minute;
    return endMinutes - startMinutes;
  }

  /// Durata in ore (arrotondata).
  double get durationHours => durationMinutes / 60.0;
}

/// Rappresenta la disponibilit√† di un singolo giorno.
class DaySchedule {
  final bool isEnabled;
  final List<WorkShift> shifts;

  const DaySchedule({this.isEnabled = false, this.shifts = const []});

  DaySchedule copyWith({bool? isEnabled, List<WorkShift>? shifts}) {
    return DaySchedule(
      isEnabled: isEnabled ?? this.isEnabled,
      shifts: shifts ?? this.shifts,
    );
  }

  /// Totale ore lavorate nel giorno.
  int get totalHours {
    if (!isEnabled || shifts.isEmpty) return 0;
    final totalMinutes = shifts.fold<int>(
      0,
      (sum, shift) => sum + shift.durationMinutes,
    );
    return (totalMinutes / 60).round();
  }
}

/// Rappresenta la pianificazione settimanale completa.
class WeeklySchedule {
  /// Mappa giorno (1=luned√¨, 7=domenica) -> DaySchedule
  final Map<int, DaySchedule> days;

  const WeeklySchedule({required this.days});

  factory WeeklySchedule.empty() {
    return WeeklySchedule(
      days: {for (int i = 1; i <= 7; i++) i: const DaySchedule()},
    );
  }

  /// Crea una pianificazione con valori di default (lun-sab 09:00-18:00).
  factory WeeklySchedule.defaultSchedule() {
    return WeeklySchedule(
      days: {
        for (int i = 1; i <= 6; i++)
          i: DaySchedule(
            isEnabled: true,
            shifts: [
              const WorkShift(
                startTime: TimeOfDay(hour: 9, minute: 0),
                endTime: TimeOfDay(hour: 18, minute: 0),
              ),
            ],
          ),
        7: const DaySchedule(isEnabled: false, shifts: []),
      },
    );
  }

  WeeklySchedule copyWith({Map<int, DaySchedule>? days}) {
    return WeeklySchedule(days: days ?? this.days);
  }

  /// Totale ore settimanali.
  int get totalHours {
    return days.values.fold<int>(0, (sum, day) => sum + day.totalHours);
  }

  /// Unifica le fasce orarie contigue (dove la fine di una coincide con l'inizio della successiva).
  /// Ritorna una nuova WeeklySchedule con le fasce unificate.
  WeeklySchedule mergeContiguousShifts() {
    final Map<int, DaySchedule> mergedDays = {};

    for (final entry in days.entries) {
      final day = entry.key;
      final schedule = entry.value;

      if (!schedule.isEnabled || schedule.shifts.length <= 1) {
        // Nessuna unificazione necessaria
        mergedDays[day] = schedule;
        continue;
      }

      // Ordina le fasce per orario di inizio
      final sortedShifts = List<WorkShift>.from(schedule.shifts)
        ..sort((a, b) {
          final aMinutes = a.startTime.hour * 60 + a.startTime.minute;
          final bMinutes = b.startTime.hour * 60 + b.startTime.minute;
          return aMinutes.compareTo(bMinutes);
        });

      // Unifica fasce contigue
      final List<WorkShift> mergedShifts = [];
      WorkShift? current;

      for (final shift in sortedShifts) {
        if (current == null) {
          current = shift;
        } else {
          // Controlla se la fine di current coincide con l'inizio di shift
          final currentEndMinutes =
              current.endTime.hour * 60 + current.endTime.minute;
          final shiftStartMinutes =
              shift.startTime.hour * 60 + shift.startTime.minute;

          if (currentEndMinutes == shiftStartMinutes) {
            // Fasce contigue: unisci
            current = WorkShift(
              startTime: current.startTime,
              endTime: shift.endTime,
            );
          } else {
            // Non contigue: salva current e inizia nuovo
            mergedShifts.add(current);
            current = shift;
          }
        }
      }

      // Aggiungi l'ultima fascia
      if (current != null) {
        mergedShifts.add(current);
      }

      mergedDays[day] = DaySchedule(
        isEnabled: schedule.isEnabled,
        shifts: mergedShifts,
      );
    }

    return WeeklySchedule(days: mergedDays);
  }

  /// Converte da formato slot a WeeklySchedule.
  /// [minutesPerSlot] √® tipicamente 15.
  factory WeeklySchedule.fromSlots(
    Map<int, Set<int>> slots, {
    int minutesPerSlot = 15,
  }) {
    final Map<int, DaySchedule> days = {};

    for (int day = 1; day <= 7; day++) {
      final daySlots = slots[day] ?? <int>{};
      if (daySlots.isEmpty) {
        days[day] = const DaySchedule(isEnabled: false, shifts: []);
        continue;
      }

      // Ordina e raggruppa slot consecutivi in turni
      final sortedSlots = daySlots.toList()..sort();
      final List<WorkShift> shifts = [];

      int? rangeStart;
      int? rangePrev;

      for (final slot in sortedSlots) {
        if (rangeStart == null) {
          rangeStart = slot;
          rangePrev = slot;
        } else if (slot == rangePrev! + 1) {
          // Slot consecutivo
          rangePrev = slot;
        } else {
          // Gap trovato, chiudi range precedente
          shifts.add(_slotsToShift(rangeStart, rangePrev, minutesPerSlot));
          rangeStart = slot;
          rangePrev = slot;
        }
      }

      // Aggiungi ultimo range
      if (rangeStart != null && rangePrev != null) {
        shifts.add(_slotsToShift(rangeStart, rangePrev, minutesPerSlot));
      }

      days[day] = DaySchedule(isEnabled: shifts.isNotEmpty, shifts: shifts);
    }

    return WeeklySchedule(days: days);
  }

  static WorkShift _slotsToShift(
    int startSlot,
    int endSlot,
    int minutesPerSlot,
  ) {
    final startMinutes = startSlot * minutesPerSlot;
    final endMinutes =
        (endSlot + 1) * minutesPerSlot; // +1 perch√© endSlot √® incluso
    return WorkShift(
      startTime: TimeOfDay(hour: startMinutes ~/ 60, minute: startMinutes % 60),
      endTime: TimeOfDay(hour: endMinutes ~/ 60, minute: endMinutes % 60),
    );
  }

  /// Converte WeeklySchedule a formato slot.
  Map<int, Set<int>> toSlots({int minutesPerSlot = 15}) {
    final Map<int, Set<int>> result = {};

    for (final entry in days.entries) {
      final day = entry.key;
      final schedule = entry.value;

      if (!schedule.isEnabled || schedule.shifts.isEmpty) {
        result[day] = <int>{};
        continue;
      }

      final Set<int> daySlots = {};
      for (final shift in schedule.shifts) {
        final startMinutes = shift.startTime.hour * 60 + shift.startTime.minute;
        final endMinutes = shift.endTime.hour * 60 + shift.endTime.minute;

        // Converti range di minuti a slot
        for (int m = startMinutes; m < endMinutes; m += minutesPerSlot) {
          daySlots.add(m ~/ minutesPerSlot);
        }
      }
      result[day] = daySlots;
    }

    return result;
  }
}

/// Widget per la modifica della pianificazione settimanale.
class WeeklyScheduleEditor extends StatefulWidget {
  final WeeklySchedule initialSchedule;
  final ValueChanged<WeeklySchedule>? onChanged;
  final bool showHeader;

  const WeeklyScheduleEditor({
    super.key,
    required this.initialSchedule,
    this.onChanged,
    this.showHeader = true,
  });

  @override
  State<WeeklyScheduleEditor> createState() => _WeeklyScheduleEditorState();
}

class _WeeklyScheduleEditorState extends State<WeeklyScheduleEditor> {
  late WeeklySchedule _schedule;

  @override
  void initState() {
    super.initState();
    _schedule = widget.initialSchedule;
  }

  @override
  void didUpdateWidget(WeeklyScheduleEditor oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.initialSchedule != oldWidget.initialSchedule) {
      _schedule = widget.initialSchedule;
    }
  }

  void _updateSchedule(WeeklySchedule newSchedule) {
    setState(() => _schedule = newSchedule);
    widget.onChanged?.call(newSchedule);
  }

  void _toggleDay(int day) {
    final currentDay = _schedule.days[day]!;
    final newDay = currentDay.copyWith(
      isEnabled: !currentDay.isEnabled,
      shifts: !currentDay.isEnabled && currentDay.shifts.isEmpty
          ? [
              const WorkShift(
                startTime: TimeOfDay(hour: 9, minute: 0),
                endTime: TimeOfDay(hour: 18, minute: 0),
              ),
            ]
          : currentDay.shifts,
    );
    _updateSchedule(_schedule.copyWith(days: {..._schedule.days, day: newDay}));
  }

  void _updateShift(int day, int shiftIndex, WorkShift newShift) {
    final currentDay = _schedule.days[day]!;
    final newShifts = List<WorkShift>.from(currentDay.shifts);
    newShifts[shiftIndex] = newShift;
    _updateSchedule(
      _schedule.copyWith(
        days: {
          ..._schedule.days,
          day: currentDay.copyWith(shifts: newShifts),
        },
      ),
    );
  }

  void _addShift(int day) {
    final currentDay = _schedule.days[day]!;
    final lastShift = currentDay.shifts.isNotEmpty
        ? currentDay.shifts.last
        : null;
    final newStartHour = lastShift != null ? lastShift.endTime.hour + 1 : 9;
    final newShift = WorkShift(
      startTime: TimeOfDay(hour: newStartHour.clamp(0, 22), minute: 0),
      endTime: TimeOfDay(hour: (newStartHour + 1).clamp(1, 23), minute: 0),
    );
    _updateSchedule(
      _schedule.copyWith(
        days: {
          ..._schedule.days,
          day: currentDay.copyWith(shifts: [...currentDay.shifts, newShift]),
        },
      ),
    );
  }

  void _removeShift(int day, int shiftIndex) {
    final currentDay = _schedule.days[day]!;
    final newShifts = List<WorkShift>.from(currentDay.shifts)
      ..removeAt(shiftIndex);
    // Se non ci sono pi√π turni, disabilita il giorno
    final isEnabled = newShifts.isNotEmpty;
    _updateSchedule(
      _schedule.copyWith(
        days: {
          ..._schedule.days,
          day: currentDay.copyWith(shifts: newShifts, isEnabled: isEnabled),
        },
      ),
    );
  }

  List<String> _getDayNames(BuildContext context) {
    final l10n = context.l10n;
    return [
      l10n.dayMondayFull,
      l10n.dayTuesdayFull,
      l10n.dayWednesdayFull,
      l10n.dayThursdayFull,
      l10n.dayFridayFull,
      l10n.daySaturdayFull,
      l10n.daySundayFull,
    ];
  }

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final dayNames = _getDayNames(context);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.min,
      children: [
        // Header con titolo e ore totali (opzionale)
        if (widget.showHeader)
          Padding(
            padding: const EdgeInsets.only(bottom: 16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  l10n.weeklyScheduleTitle,
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 4),
                Text(
                  l10n.weeklyScheduleTotalHours(_schedule.totalHours),
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.onSurfaceVariant,
                  ),
                ),
              ],
            ),
          ),

        // Lista dei giorni - sfondo a tutta larghezza, contenuto centrato
        Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: List.generate(7, (index) {
            final day = index + 1;
            final daySchedule = _schedule.days[day]!;
            final dayName = dayNames[index];

            return _DayRow(
              day: day,
              dayName: dayName,
              allDayNames: dayNames,
              schedule: daySchedule,
              onToggle: () => _toggleDay(day),
              onShiftChanged: (shiftIndex, shift) =>
                  _updateShift(day, shiftIndex, shift),
              onAddShift: () => _addShift(day),
              onRemoveShift: (shiftIndex) => _removeShift(day, shiftIndex),
              isFirst: index == 0,
            );
          }),
        ),
      ],
    );
  }
}

/// Riga per un singolo giorno.
class _DayRow extends ConsumerWidget {
  final int day;
  final String dayName;
  final List<String> allDayNames;
  final DaySchedule schedule;
  final VoidCallback onToggle;
  final void Function(int shiftIndex, WorkShift shift) onShiftChanged;
  final VoidCallback onAddShift;
  final void Function(int shiftIndex) onRemoveShift;
  final bool isFirst;

  const _DayRow({
    required this.day,
    required this.dayName,
    required this.allDayNames,
    required this.schedule,
    required this.onToggle,
    required this.onShiftChanged,
    required this.onAddShift,
    required this.onRemoveShift,
    this.isFirst = false,
  });

  /// Calcola la larghezza massima tra tutti i nomi dei giorni
  double _getMaxDayNameWidth(BuildContext context, TextStyle? style) {
    double maxWidth = 0;
    final textPainter = TextPainter(textDirection: TextDirection.ltr);
    for (final name in allDayNames) {
      textPainter.text = TextSpan(text: name, style: style);
      textPainter.layout();
      if (textPainter.width > maxWidth) {
        maxWidth = textPainter.width;
      }
    }
    return maxWidth;
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final l10n = context.l10n;
    final theme = Theme.of(context);
    final formFactor = ref.watch(formFactorProvider);
    final isMobile = formFactor == AppFormFactor.mobile;

    if (isMobile) {
      return _buildMobileLayout(context, l10n, theme);
    }
    return _buildDesktopLayout(context, l10n, theme);
  }

  /// Layout mobile: verticale (header sopra, turni sotto)
  Widget _buildMobileLayout(
    BuildContext context,
    dynamic l10n,
    ThemeData theme,
  ) {
    // Sfondo alternato: trasparente per dispari, colorato per pari
    final interactionColors = theme.extension<AppInteractionColors>();
    final backgroundColor = day.isEven
        ? interactionColors?.alternatingRowFill
        : null;

    final dayNameStyle = theme.textTheme.bodyLarge?.copyWith(
      fontWeight: FontWeight.w500,
    );
    final maxDayNameWidth = _getMaxDayNameWidth(context, dayNameStyle);

    return Container(
      color: backgroundColor,
      padding: EdgeInsets.only(top: isFirst ? 16 : 8, bottom: 8),
      child: Center(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: IntrinsicWidth(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                // Header: checkbox + nome giorno + ore + icone
                Row(
                  mainAxisAlignment: MainAxisAlignment.start,
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    // Checkbox inline con il nome
                    Transform.scale(
                      scale: 1.1,
                      child: Checkbox(
                        value: schedule.isEnabled,
                        onChanged: (_) => onToggle(),
                        activeColor: theme.colorScheme.primary,
                        visualDensity: VisualDensity.compact,
                        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                      ),
                    ),

                    // Nome giorno con larghezza fissa (calcolata dinamicamente)
                    SizedBox(
                      width: maxDayNameWidth,
                      child: Text(dayName, style: dayNameStyle),
                    ),
                    if (schedule.isEnabled && schedule.totalHours > 0) ...[
                      const SizedBox(width: 8),
                      Text(
                        '${schedule.totalHours}h',
                        style: theme.textTheme.bodySmall?.copyWith(
                          color: theme.colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ],

                    // Icone azioni (solo se abilitato)
                    if (schedule.isEnabled) ...[
                      const SizedBox(width: 8),
                      IconButton(
                        onPressed: onAddShift,
                        icon: Icon(
                          Icons.add_circle_outline,
                          color: theme.colorScheme.primary,
                        ),
                        tooltip: l10n.weeklyScheduleAddShift,
                        constraints: const BoxConstraints(
                          minWidth: 36,
                          minHeight: 36,
                        ),
                        padding: EdgeInsets.zero,
                        iconSize: 22,
                      ),
                    ],
                  ],
                ),

                // Contenuto turni o "Non lavora"
                if (schedule.isEnabled)
                  Padding(
                    padding: const EdgeInsets.only(top: 8),
                    child: Column(
                      children: [
                        for (int i = 0; i < schedule.shifts.length; i++)
                          Padding(
                            padding: EdgeInsets.only(
                              bottom: i < schedule.shifts.length - 1 ? 8 : 0,
                            ),
                            child: _ShiftRowMobile(
                              shift: schedule.shifts[i],
                              onChanged: (shift) => onShiftChanged(i, shift),
                              onRemove: () => onRemoveShift(i),
                              previousShiftEndTime: i > 0
                                  ? schedule.shifts[i - 1].endTime
                                  : null,
                            ),
                          ),
                      ],
                    ),
                  )
                else
                  Padding(
                    padding: const EdgeInsets.only(top: 4),
                    child: Text(
                      l10n.weeklyScheduleNotWorking,
                      style: theme.textTheme.bodyMedium?.copyWith(
                        color: theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  /// Layout desktop/tablet: orizzontale
  Widget _buildDesktopLayout(
    BuildContext context,
    dynamic l10n,
    ThemeData theme,
  ) {
    // Sfondo alternato: trasparente per dispari, colorato per pari
    final interactionColors = theme.extension<AppInteractionColors>();
    final backgroundColor = day.isEven
        ? interactionColors?.alternatingRowFill
        : null;

    final dayNameStyle = theme.textTheme.bodyLarge?.copyWith(
      fontWeight: FontWeight.w500,
    );
    final maxDayNameWidth = _getMaxDayNameWidth(context, dayNameStyle);

    return Container(
      color: backgroundColor,
      padding: EdgeInsets.only(top: isFirst ? 16 : 8, bottom: 8),
      child: Center(
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: IntrinsicWidth(
            child: Row(
              mainAxisAlignment: MainAxisAlignment.start,
              crossAxisAlignment: CrossAxisAlignment.center,
              children: [
                // Checkbox
                Checkbox(
                  value: schedule.isEnabled,
                  onChanged: (_) => onToggle(),
                  activeColor: theme.colorScheme.primary,
                ),
                const SizedBox(width: 12),

                // Nome giorno e ore con larghezza fissa (calcolata dinamicamente)
                SizedBox(
                  width: maxDayNameWidth,
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    mainAxisAlignment: MainAxisAlignment.center,
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Text(dayName, style: dayNameStyle),
                      if (schedule.isEnabled && schedule.totalHours > 0)
                        Text(
                          '${schedule.totalHours}h',
                          style: theme.textTheme.bodySmall?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                        ),
                    ],
                  ),
                ),
                const SizedBox(width: 16),

                // Contenuto turni o "Non lavora" - larghezza minima fissa per allineamento
                // Larghezza: 2 dropdown (100*2) + 3 spacing (12*3) + testo "per" (~30) + 2 pulsanti (40*2)
                ConstrainedBox(
                  constraints: const BoxConstraints(
                    minWidth:
                        _TimeDropdown.dropdownWidth * 2 + 12 * 3 + 30 + 40 * 2,
                  ),
                  child: schedule.isEnabled
                      ? Column(
                          crossAxisAlignment: CrossAxisAlignment.start,
                          children: [
                            for (int i = 0; i < schedule.shifts.length; i++)
                              Padding(
                                padding: EdgeInsets.only(
                                  bottom: i < schedule.shifts.length - 1
                                      ? 8
                                      : 0,
                                ),
                                child: _ShiftRow(
                                  shift: schedule.shifts[i],
                                  onChanged: (shift) =>
                                      onShiftChanged(i, shift),
                                  onAdd: onAddShift,
                                  onRemove: () => onRemoveShift(i),
                                  showAddButton:
                                      i == schedule.shifts.length - 1,
                                  previousShiftEndTime: i > 0
                                      ? schedule.shifts[i - 1].endTime
                                      : null,
                                ),
                              ),
                          ],
                        )
                      : Text(
                          l10n.weeklyScheduleNotWorking,
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: theme.colorScheme.onSurfaceVariant,
                          ),
                        ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

/// Riga turno per layout mobile (senza icona add, con delete)
class _ShiftRowMobile extends StatelessWidget {
  final WorkShift shift;
  final ValueChanged<WorkShift> onChanged;
  final VoidCallback onRemove;

  /// Orario di fine della fascia precedente (se esiste).
  /// Usato per impostare il minimo dell'orario di inizio.
  final TimeOfDay? previousShiftEndTime;

  const _ShiftRowMobile({
    required this.shift,
    required this.onChanged,
    required this.onRemove,
    this.previousShiftEndTime,
  });

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        // Orario inizio - minimo = fine fascia precedente (se esiste)
        _TimeDropdown(
          value: shift.startTime,
          minTime: previousShiftEndTime,
          onChanged: (time) => onChanged(shift.copyWith(startTime: time)),
        ),
        const SizedBox(width: 8),

        // "per"
        Text(
          l10n.weeklyScheduleFor,
          style: theme.textTheme.bodyMedium?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
        const SizedBox(width: 8),

        // Orario fine - minimo = orario inizio corrente
        _TimeDropdown(
          value: shift.endTime,
          minTime: shift.startTime,
          onChanged: (time) => onChanged(shift.copyWith(endTime: time)),
        ),
        const SizedBox(width: 8),

        // Pulsante rimuovi
        IconButton(
          onPressed: onRemove,
          icon: Icon(
            Icons.delete_outline,
            color: theme.colorScheme.error,
            size: 20,
          ),
          tooltip: l10n.weeklyScheduleRemoveShift,
          constraints: const BoxConstraints(minWidth: 32, minHeight: 32),
          padding: EdgeInsets.zero,
        ),
      ],
    );
  }
}

/// Riga per un singolo turno con dropdown orari.
class _ShiftRow extends StatelessWidget {
  final WorkShift shift;
  final ValueChanged<WorkShift> onChanged;
  final VoidCallback onAdd;
  final VoidCallback onRemove;
  final bool showAddButton;

  /// Orario di fine della fascia precedente (se esiste).
  /// Usato per impostare il minimo dell'orario di inizio.
  final TimeOfDay? previousShiftEndTime;

  const _ShiftRow({
    required this.shift,
    required this.onChanged,
    required this.onAdd,
    required this.onRemove,
    this.showAddButton = false,
    this.previousShiftEndTime,
  });

  @override
  Widget build(BuildContext context) {
    final l10n = context.l10n;
    final theme = Theme.of(context);

    return Row(
      mainAxisAlignment: MainAxisAlignment.center,
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        // Orario inizio - minimo = fine fascia precedente (se esiste)
        _TimeDropdown(
          value: shift.startTime,
          minTime: previousShiftEndTime,
          onChanged: (time) => onChanged(shift.copyWith(startTime: time)),
        ),
        const SizedBox(width: 12),

        // "per"
        Text(
          l10n.weeklyScheduleFor,
          style: theme.textTheme.bodyMedium?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
        const SizedBox(width: 12),

        // Orario fine - minimo = orario inizio corrente
        _TimeDropdown(
          value: shift.endTime,
          minTime: shift.startTime,
          onChanged: (time) => onChanged(shift.copyWith(endTime: time)),
        ),
        const SizedBox(width: 12),

        // Pulsante aggiungi (solo sull'ultimo turno)
        if (showAddButton)
          IconButton(
            onPressed: onAdd,
            icon: Icon(
              Icons.add_circle_outline,
              color: theme.colorScheme.primary,
            ),
            tooltip: l10n.weeklyScheduleAddShift,
            constraints: const BoxConstraints(minWidth: 40, minHeight: 40),
            padding: EdgeInsets.zero,
          )
        else
          const SizedBox(width: 40),

        // Pulsante rimuovi
        IconButton(
          onPressed: onRemove,
          icon: Icon(Icons.delete_outline, color: theme.colorScheme.error),
          tooltip: l10n.weeklyScheduleRemoveShift,
          constraints: const BoxConstraints(minWidth: 40, minHeight: 40),
          padding: EdgeInsets.zero,
        ),
      ],
    );
  }
}

/// Dropdown per la selezione dell'orario.
class _TimeDropdown extends StatelessWidget {
  final TimeOfDay value;
  final ValueChanged<TimeOfDay> onChanged;

  /// Orario minimo selezionabile (incluso). Se null, parte da 00:00.
  final TimeOfDay? minTime;

  /// Larghezza del dropdown (formato HH:MM + padding + icona)
  static const double dropdownWidth = 100.0;

  const _TimeDropdown({
    required this.value,
    required this.onChanged,
    this.minTime,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    // Genera opzioni con incremento pari a minutesPerSlotConst
    final allOptions = <TimeOfDay>[];
    for (int hour = 0; hour < 24; hour++) {
      for (
        int minute = 0;
        minute < 60;
        minute += LayoutConfig.minutesPerSlotConst
      ) {
        allOptions.add(TimeOfDay(hour: hour, minute: minute));
      }
    }

    // Filtra le opzioni in base a minTime
    final options = allOptions.where((time) {
      final timeMinutes = time.hour * 60 + time.minute;
      if (minTime != null) {
        final minMinutes = minTime!.hour * 60 + minTime!.minute;
        if (timeMinutes < minMinutes) return false;
      }
      return true;
    }).toList();

    // Se non ci sono opzioni valide, usa tutte le opzioni
    final effectiveOptions = options.isEmpty ? allOptions : options;

    return SizedBox(
      width: dropdownWidth,
      child: Container(
        decoration: BoxDecoration(
          border: Border.all(color: theme.colorScheme.outline.withOpacity(0.5)),
          borderRadius: BorderRadius.circular(8),
        ),
        child: DropdownButtonHideUnderline(
          child: DropdownButton<TimeOfDay>(
            value: _findClosestOption(value, effectiveOptions),
            isExpanded: true,
            alignment: Alignment.center,
            borderRadius: BorderRadius.circular(8),
            icon: const SizedBox.shrink(),
            items: effectiveOptions.map((time) {
              return DropdownMenuItem(
                value: time,
                alignment: Alignment.center,
                child: Text(_formatTime(time)),
              );
            }).toList(),
            onChanged: (time) {
              if (time != null) onChanged(time);
            },
          ),
        ),
      ),
    );
  }

  TimeOfDay _findClosestOption(TimeOfDay value, List<TimeOfDay> options) {
    // Trova l'opzione pi√π vicina al valore attuale
    TimeOfDay closest = options.first;
    int minDiff = _timeDiff(value, closest).abs();

    for (final option in options) {
      final diff = _timeDiff(value, option).abs();
      if (diff < minDiff) {
        minDiff = diff;
        closest = option;
      }
    }
    return closest;
  }

  int _timeDiff(TimeOfDay a, TimeOfDay b) {
    return (a.hour * 60 + a.minute) - (b.hour * 60 + b.minute);
  }

  String _formatTime(TimeOfDay time) {
    final hour = time.hour.toString().padLeft(2, '0');
    final minute = time.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }
}
--- FILE: lib/features/staff/presentation/widgets/staff_item.dart ---
import 'package:flutter/material.dart';
import 'package:agenda_backend/app/widgets/staff_circle_avatar.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/theme/extensions.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/staff.dart';
import '../../../services/providers/services_provider.dart';

class StaffItem extends ConsumerStatefulWidget {
  const StaffItem({
    super.key,
    required this.staff,
    required this.isLast,
    required this.isEvenRow,
    required this.isWide,
    required this.onEdit,
    required this.onDuplicate,
    required this.onDelete,
    this.trailingOverride,
  });

  final Staff staff;
  final bool isLast;
  final bool isEvenRow;
  final bool isWide;
  final VoidCallback onEdit;
  final VoidCallback onDuplicate;
  final VoidCallback onDelete;
  final Widget? trailingOverride;

  @override
  ConsumerState<StaffItem> createState() => _StaffItemState();
}

class _StaffItemState extends ConsumerState<StaffItem> {
  bool _isHovered = false;

  @override
  Widget build(BuildContext context) {
    final interactionColors =
        Theme.of(context).extension<AppInteractionColors>();
    final colorScheme = Theme.of(context).colorScheme;
    final baseColor = widget.isEvenRow
        ? (interactionColors?.alternatingRowFill ??
            colorScheme.onSurface.withOpacity(0.04))
        : Colors.transparent;
    final hoverFill = interactionColors?.hoverFill ??
        colorScheme.primaryContainer.withOpacity(0.1);
    final bgColor = _isHovered ? hoverFill : baseColor;

    final eligibleServices = ref.watch(
      eligibleServicesForStaffProvider(widget.staff.id),
    );
    final eligibleServicesCount = eligibleServices.length;

    return MouseRegion(
      cursor: SystemMouseCursors.click,
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: Container(
        decoration: BoxDecoration(
          color: bgColor,
          borderRadius: BorderRadius.only(
            bottomLeft: widget.isLast ? const Radius.circular(16) : Radius.zero,
            bottomRight:
                widget.isLast ? const Radius.circular(16) : Radius.zero,
          ),
        ),
        child: ListTile(
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 10,
          ),
          minVerticalPadding: 0,
          leading: StaffCircleAvatar(
            height: 36,
            color: widget.staff.color,
            isHighlighted: false,
            initials: widget.staff.initials,
          ),
          title: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                widget.staff.displayName,
                style: Theme.of(context)
                    .textTheme
                    .titleMedium
                    ?.copyWith(fontWeight: FontWeight.w500),
              ),
              if (eligibleServicesCount == 0) ...[
                const SizedBox(height: 2),
                Text(
                  context.l10n.teamEligibleServicesNone,
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Theme.of(context).colorScheme.error,
                        fontStyle: FontStyle.italic,
                      ),
                ),
              ],
              if (!widget.staff.isBookableOnline) ...[
                const SizedBox(height: 2),
                Text(
                  context.l10n.staffNotBookableOnlineTooltip,
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(
                        color: Theme.of(context).colorScheme.error,
                        fontStyle: FontStyle.italic,
                      ),
                ),
              ],
            ],
          ),
          onTap: widget.onEdit,
          mouseCursor: SystemMouseCursors.click,
          trailing: widget.trailingOverride ??
              (widget.isWide
                  ? Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        IconButton(
                          tooltip: context.l10n.actionEdit,
                          icon: const Icon(Icons.edit_outlined),
                          onPressed: widget.onEdit,
                        ),
                        IconButton(
                          tooltip: context.l10n.duplicateAction,
                          icon: const Icon(Icons.copy_outlined),
                          onPressed: widget.onDuplicate,
                        ),
                        IconButton(
                          tooltip: context.l10n.actionDelete,
                          icon: const Icon(Icons.delete_outline),
                          onPressed: widget.onDelete,
                        ),
                      ],
                    )
                  : PopupMenuButton<String>(
                      onSelected: (value) {
                        if (value == 'edit') widget.onEdit();
                        if (value == 'duplicate') widget.onDuplicate();
                        if (value == 'delete') widget.onDelete();
                      },
                      itemBuilder: (context) => [
                        PopupMenuItem(
                          value: 'edit',
                          child: Text(context.l10n.actionEdit),
                        ),
                        PopupMenuItem(
                          value: 'duplicate',
                          child: Text(context.l10n.duplicateAction),
                        ),
                        PopupMenuItem(
                          value: 'delete',
                          child: Text(context.l10n.actionDelete),
                        ),
                      ],
                    )),
        ),
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/widgets/staff_hub_card.dart ---
import 'package:flutter/material.dart';

import '../../../../core/l10n/l10_extension.dart';

class StaffHubCard extends StatelessWidget {
  const StaffHubCard({
    super.key,
    required this.icon,
    required this.title,
    required this.subtitle,
    required this.onTap,
    this.disabled = false,
  });

  final IconData icon;
  final String title;
  final String subtitle;
  final VoidCallback onTap;
  final bool disabled;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final baseColor = disabled
        ? colorScheme.surfaceVariant
        : colorScheme.secondaryContainer;
    final fgColor = disabled
        ? colorScheme.onSurfaceVariant.withOpacity(0.6)
        : colorScheme.onSecondaryContainer;

    return InkWell(
      onTap: disabled ? null : onTap,
      borderRadius: BorderRadius.circular(12),
      child: AnimatedContainer(
        duration: const Duration(milliseconds: 180),
        padding: const EdgeInsets.all(18),
        width: 260,
        decoration: BoxDecoration(
          color: baseColor,
          borderRadius: BorderRadius.circular(12),
          boxShadow: [
            BoxShadow(
              color: Colors.black.withOpacity(0.08),
              blurRadius: 6,
              offset: const Offset(0, 2),
            ),
          ],
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Icon(icon, size: 32, color: fgColor),
            const SizedBox(height: 12),
            Text(
              title,
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.w600,
                color: fgColor,
              ),
            ),
            const SizedBox(height: 6),
            Text(
              subtitle,
              style: TextStyle(fontSize: 14, color: fgColor.withOpacity(0.85)),
            ),
            if (disabled)
              Padding(
                padding: const EdgeInsets.only(top: 8.0),
                child: Text(
                  context.l10n.staffHubNotYetAvailable,
                  style: const TextStyle(
                    fontSize: 12,
                    fontStyle: FontStyle.italic,
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/widgets/location_item.dart ---
import 'package:flutter/material.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/location.dart';
import '../../../../core/models/staff.dart';
import '../../../services/presentation/widgets/empty_state.dart';
import 'staff_item.dart';

class LocationItem extends StatelessWidget {
  const LocationItem({
    super.key,
    required this.location,
    required this.staff,
    required this.isWide,
    required this.onAddStaff,
    required this.onEditLocation,
    required this.onDeleteLocation,
    required this.onEditStaff,
    required this.onDuplicateStaff,
    required this.onDeleteStaff,
    this.headerTrailing,
    this.staffListOverride,
    this.showDefaultActions = true,
  });

  final Location location;
  final List<Staff> staff;
  final bool isWide;
  final VoidCallback onAddStaff;
  final VoidCallback onEditLocation;
  final VoidCallback onDeleteLocation;
  final ValueChanged<Staff> onEditStaff;
  final ValueChanged<Staff> onDuplicateStaff;
  final ValueChanged<Staff> onDeleteStaff;
  final Widget? headerTrailing;
  final Widget? staffListOverride;
  final bool showDefaultActions;

  @override
  Widget build(BuildContext context) {
    final colorScheme = Theme.of(context).colorScheme;
    final isEmptyLocation = staff.isEmpty;

    return Container(
      margin: const EdgeInsets.only(bottom: 24),
      decoration: BoxDecoration(
        color: colorScheme.surface,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 6,
            offset: const Offset(0, 3),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            width: double.infinity,
            decoration: BoxDecoration(
              color: colorScheme.primaryContainer,
              borderRadius: const BorderRadius.vertical(
                top: Radius.circular(16),
              ),
            ),
            padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),
            child: Row(
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        location.name,
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                        style: Theme.of(context).textTheme.titleMedium?.copyWith(
                              fontWeight: FontWeight.w600,
                              color: colorScheme.onPrimaryContainer,
                            ),
                      ),
                      if (location.address != null &&
                          location.address!.isNotEmpty)
                        Padding(
                          padding: const EdgeInsets.only(top: 4),
                          child: Text(
                            location.address!,
                            maxLines: 2,
                            overflow: TextOverflow.ellipsis,
                            style: Theme.of(context)
                                .textTheme
                                .bodySmall
                                ?.copyWith(
                                  color: colorScheme.onPrimaryContainer
                                      .withOpacity(0.8),
                                ),
                          ),
                        ),
                    ],
                  ),
                ),
                const SizedBox(width: 12),
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    if (showDefaultActions) ...[
                      IconButton(
                        tooltip: context.l10n.teamAddStaff,
                        icon: Icon(
                          Icons.person_add_alt_1,
                          color: colorScheme.onPrimaryContainer,
                        ),
                        onPressed: onAddStaff,
                      ),
                      IconButton(
                        tooltip: context.l10n.actionEdit,
                        icon: Icon(
                          Icons.edit_outlined,
                          color: colorScheme.onPrimaryContainer,
                        ),
                        onPressed: onEditLocation,
                      ),
                      if (isEmptyLocation)
                        IconButton(
                          tooltip: context.l10n.actionDelete,
                          icon: const Icon(Icons.delete_outline),
                          color: colorScheme.onPrimaryContainer,
                          onPressed: onDeleteLocation,
                        ),
                    ],
                    if (headerTrailing != null) headerTrailing!,
                  ],
                ),
              ],
            ),
          ),
          ClipRRect(
            borderRadius: const BorderRadius.vertical(
              bottom: Radius.circular(16),
            ),
            child: staffListOverride ??
                (isEmptyLocation
                    ? ServicesEmptyState(
                        message: context.l10n.teamNoStaffInLocation,
                      )
                    : Column(
                        children: [
                          for (int i = 0; i < staff.length; i++)
                            StaffItem(
                              staff: staff[i],
                              isLast: i == staff.length - 1,
                              isEvenRow: i.isEven,
                              isWide: isWide,
                              onEdit: () => onEditStaff(staff[i]),
                              onDuplicate: () => onDuplicateStaff(staff[i]),
                              onDelete: () => onDeleteStaff(staff[i]),
                            ),
                        ],
                      )),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/staff/presentation/widgets/exception_calendar_view.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/availability_exception.dart';
import '../../providers/availability_exceptions_provider.dart';
import '../dialogs/add_exception_dialog.dart';

/// Widget per visualizzare e gestire le eccezioni alla disponibilit√†
/// in una vista calendario mensile.
class ExceptionCalendarView extends ConsumerStatefulWidget {
  const ExceptionCalendarView({super.key, required this.staffId});

  final int staffId;

  @override
  ConsumerState<ExceptionCalendarView> createState() =>
      _ExceptionCalendarViewState();
}

String? _localizedReasonCode(String? code, BuildContext context) {
  if (code == null || code.isEmpty) return null;
  final l10n = context.l10n;
  switch (code) {
    case 'vacation':
      return l10n.exceptionReasonVacation;
    case 'extra_shift':
      return l10n.exceptionReasonExtraShift;
    case 'medical_visit':
      return l10n.exceptionReasonMedicalVisit;
  }
  return null;
}

class _ExceptionCalendarViewState extends ConsumerState<ExceptionCalendarView> {
  late DateTime _currentMonth;

  @override
  void initState() {
    super.initState();
    _currentMonth = DateTime.now();
    _loadExceptions();
  }

  Future<void> _loadExceptions() async {
    // Carica eccezioni per un range di 3 mesi (mese corrente ¬± 1)
    final from = DateTime(_currentMonth.year, _currentMonth.month - 1, 1);
    final to = DateTime(_currentMonth.year, _currentMonth.month + 2, 0);
    await ref
        .read(availabilityExceptionsProvider.notifier)
        .loadExceptionsForStaff(widget.staffId, fromDate: from, toDate: to);
  }

  void _previousMonth() {
    setState(() {
      _currentMonth = DateTime(_currentMonth.year, _currentMonth.month - 1, 1);
    });
    _loadExceptions();
  }

  void _nextMonth() {
    setState(() {
      _currentMonth = DateTime(_currentMonth.year, _currentMonth.month + 1, 1);
    });
    _loadExceptions();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final exceptions = ref.watch(allExceptionsForStaffProvider(widget.staffId));

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Header con titolo e navigazione mese
        Padding(
          padding: const EdgeInsets.all(16),
          child: Row(
            children: [
              Expanded(
                child: Text(
                  l10n.exceptionsTitle,
                  style: theme.textTheme.titleLarge?.copyWith(
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              FilledButton.icon(
                onPressed: () => showAddExceptionDialog(
                  context,
                  ref,
                  staffId: widget.staffId,
                ),
                icon: const Icon(Icons.add, size: 18),
                label: Text(l10n.exceptionsAdd),
              ),
            ],
          ),
        ),

        // Navigazione mese
        Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              IconButton(
                onPressed: _previousMonth,
                icon: const Icon(Icons.chevron_left),
              ),
              Text(
                _formatMonth(_currentMonth),
                style: theme.textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                ),
              ),
              IconButton(
                onPressed: _nextMonth,
                icon: const Icon(Icons.chevron_right),
              ),
            ],
          ),
        ),

        const SizedBox(height: 8),

        // Griglia calendario
        _CalendarGrid(
          month: _currentMonth,
          exceptions: exceptions,
          staffId: widget.staffId,
          onDayTap: (date) => _onDayTap(date, exceptions),
        ),

        const SizedBox(height: 16),

        // Lista eccezioni del mese
        _ExceptionsList(
          exceptions: _filterExceptionsForMonth(exceptions),
          staffId: widget.staffId,
        ),
      ],
    );
  }

  String _formatMonth(DateTime date) {
    final locale = Localizations.localeOf(context).toLanguageTag();
    return DateFormat('MMMM y', locale).format(date);
  }

  List<AvailabilityException> _filterExceptionsForMonth(
    List<AvailabilityException> exceptions,
  ) {
    return exceptions.where((e) {
      return e.date.year == _currentMonth.year &&
          e.date.month == _currentMonth.month;
    }).toList()..sort((a, b) => a.date.compareTo(b.date));
  }

  void _onDayTap(DateTime date, List<AvailabilityException> exceptions) {
    final dayExceptions = exceptions.where((e) => e.isOnDate(date)).toList();

    if (dayExceptions.isEmpty) {
      // Nessuna eccezione: apri dialog per crearne una nuova
      showAddExceptionDialog(context, ref, staffId: widget.staffId, date: date);
    } else if (dayExceptions.length == 1) {
      // Una sola eccezione: apri dialog per modificarla
      showAddExceptionDialog(
        context,
        ref,
        staffId: widget.staffId,
        initial: dayExceptions.first,
      );
    } else {
      // Pi√π eccezioni: mostra bottom sheet con lista
      _showExceptionsForDay(date, dayExceptions);
    }
  }

  void _showExceptionsForDay(
    DateTime date,
    List<AvailabilityException> exceptions,
  ) {
    showModalBottomSheet(
      context: context,
      builder: (ctx) => SafeArea(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Padding(
              padding: const EdgeInsets.all(16),
              child: Text(
                '${date.day}/${date.month}/${date.year}',
                style: Theme.of(ctx).textTheme.titleMedium,
              ),
            ),
            ...exceptions.map(
              (e) => ListTile(
                leading: Icon(
                  e.type == AvailabilityExceptionType.available
                      ? Icons.check_circle
                      : Icons.block,
                  color: e.type == AvailabilityExceptionType.available
                      ? Colors.green
                      : Theme.of(ctx).colorScheme.error,
                ),
                title: Text(
                  e.reason ??
                      _localizedReasonCode(e.reasonCode, context) ??
                      _getDefaultReason(e.type, context),
                ),
                subtitle: Text(
                  e.isAllDay
                      ? context.l10n.exceptionAllDay
                      : _formatTimeRange(e, context),
                ),
                onTap: () {
                  Navigator.pop(ctx);
                  showAddExceptionDialog(
                    context,
                    ref,
                    staffId: widget.staffId,
                    initial: e,
                  );
                },
              ),
            ),
            const SizedBox(height: 16),
          ],
        ),
      ),
    );
  }

  String _getDefaultReason(
    AvailabilityExceptionType type,
    BuildContext context,
  ) {
    return type == AvailabilityExceptionType.available
        ? context.l10n.exceptionTypeAvailable
        : context.l10n.exceptionTypeUnavailable;
  }

  String _formatTimeRange(AvailabilityException e, BuildContext context) {
    if (e.isAllDay) return context.l10n.exceptionAllDay;
    final start =
        '${e.startTime!.hour.toString().padLeft(2, '0')}:${e.startTime!.minute.toString().padLeft(2, '0')}';
    final end =
        '${e.endTime!.hour.toString().padLeft(2, '0')}:${e.endTime!.minute.toString().padLeft(2, '0')}';
    return '$start - $end';
  }
}

/// Griglia calendario mensile.
class _CalendarGrid extends ConsumerWidget {
  const _CalendarGrid({
    required this.month,
    required this.exceptions,
    required this.staffId,
    required this.onDayTap,
  });

  final DateTime month;
  final List<AvailabilityException> exceptions;
  final int staffId;
  final ValueChanged<DateTime> onDayTap;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    // Calcola primo e ultimo giorno del mese
    final firstDay = DateTime(month.year, month.month, 1);
    final lastDay = DateTime(month.year, month.month + 1, 0);
    final daysInMonth = lastDay.day;

    // Giorno della settimana del primo giorno (1=lun, 7=dom)
    final firstWeekday = firstDay.weekday;

    // Celle vuote iniziali + giorni del mese
    final totalCells = ((firstWeekday - 1) + daysInMonth);
    final rows = (totalCells / 7).ceil();

    final today = DateTime.now();

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      child: Column(
        children: [
          // Header giorni settimana
          Row(
            children: ['L', 'M', 'M', 'G', 'V', 'S', 'D']
                .map(
                  (d) => Expanded(
                    child: Center(
                      child: Text(
                        d,
                        style: theme.textTheme.bodySmall?.copyWith(
                          fontWeight: FontWeight.bold,
                          color: colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ),
                  ),
                )
                .toList(),
          ),
          const SizedBox(height: 8),
          // Griglia giorni
          ...List.generate(rows, (rowIndex) {
            return Row(
              children: List.generate(7, (colIndex) {
                final cellIndex = rowIndex * 7 + colIndex;
                final dayNumber = cellIndex - (firstWeekday - 1) + 1;

                if (dayNumber < 1 || dayNumber > daysInMonth) {
                  return const Expanded(child: SizedBox(height: 44));
                }

                final date = DateTime(month.year, month.month, dayNumber);
                final isToday =
                    date.year == today.year &&
                    date.month == today.month &&
                    date.day == today.day;

                // Trova eccezioni per questo giorno
                final dayExceptions = exceptions
                    .where((e) => e.isOnDate(date))
                    .toList();

                return Expanded(
                  child: GestureDetector(
                    onTap: () => onDayTap(date),
                    child: Container(
                      height: 44,
                      margin: const EdgeInsets.all(2),
                      decoration: BoxDecoration(
                        color: isToday
                            ? colorScheme.primaryContainer.withOpacity(0.5)
                            : null,
                        borderRadius: BorderRadius.circular(8),
                        border: isToday
                            ? Border.all(color: colorScheme.primary, width: 2)
                            : null,
                      ),
                      child: Stack(
                        alignment: Alignment.center,
                        children: [
                          Text(
                            dayNumber.toString(),
                            style: theme.textTheme.bodyMedium?.copyWith(
                              fontWeight: isToday
                                  ? FontWeight.bold
                                  : FontWeight.normal,
                            ),
                          ),
                          // Indicatori eccezioni
                          if (dayExceptions.isNotEmpty)
                            Positioned(
                              bottom: 4,
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: dayExceptions.take(3).map((e) {
                                  return Container(
                                    width: 6,
                                    height: 6,
                                    margin: const EdgeInsets.symmetric(
                                      horizontal: 1,
                                    ),
                                    decoration: BoxDecoration(
                                      shape: BoxShape.circle,
                                      color:
                                          e.type ==
                                              AvailabilityExceptionType
                                                  .available
                                          ? Colors.green
                                          : colorScheme.error,
                                    ),
                                  );
                                }).toList(),
                              ),
                            ),
                        ],
                      ),
                    ),
                  ),
                );
              }),
            );
          }),
        ],
      ),
    );
  }
}

/// Lista delle eccezioni del mese.
class _ExceptionsList extends ConsumerWidget {
  const _ExceptionsList({required this.exceptions, required this.staffId});

  final List<AvailabilityException> exceptions;
  final int staffId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final l10n = context.l10n;
    final colorScheme = theme.colorScheme;

    if (exceptions.isEmpty) {
      return Padding(
        padding: const EdgeInsets.all(16),
        child: Center(
          child: Text(
            l10n.exceptionsEmpty,
            style: theme.textTheme.bodyMedium?.copyWith(
              color: colorScheme.onSurfaceVariant,
            ),
          ),
        ),
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Divider(),
        ...exceptions.map(
          (e) => _ExceptionTile(exception: e, staffId: staffId),
        ),
      ],
    );
  }
}

/// Tile per singola eccezione.
class _ExceptionTile extends ConsumerWidget {
  const _ExceptionTile({required this.exception, required this.staffId});

  final AvailabilityException exception;
  final int staffId;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final colorScheme = theme.colorScheme;

    final isAvailable = exception.type == AvailabilityExceptionType.available;
    final color = isAvailable ? Colors.green : colorScheme.error;

    return ListTile(
      leading: Container(
        width: 40,
        height: 40,
        decoration: BoxDecoration(
          color: color.withOpacity(0.1),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Icon(
          isAvailable ? Icons.check_circle_outline : Icons.block_outlined,
          color: color,
        ),
      ),
      title: Text(
        exception.reason ??
            _localizedReasonCode(exception.reasonCode, context) ??
            (isAvailable
                ? context.l10n.exceptionTypeAvailable
                : context.l10n.exceptionTypeUnavailable),
        style: theme.textTheme.bodyLarge,
      ),
      subtitle: Text(
        '${_formatDate(context, exception.date)} ‚Ä¢ ${_formatTimeRange(exception, context)}',
        style: theme.textTheme.bodySmall?.copyWith(
          color: colorScheme.onSurfaceVariant,
        ),
      ),
      trailing: IconButton(
        icon: const Icon(Icons.edit_outlined),
        onPressed: () => showAddExceptionDialog(
          context,
          ref,
          staffId: staffId,
          initial: exception,
        ),
      ),
      onTap: () => showAddExceptionDialog(
        context,
        ref,
        staffId: staffId,
        initial: exception,
      ),
    );
  }

  String _formatDate(BuildContext context, DateTime date) {
    final locale = Localizations.localeOf(context).toLanguageTag();
    final weekday = DateFormat('EEE', locale).format(date);
    return '$weekday ${date.day}/${date.month}';
  }

  String _formatTimeRange(AvailabilityException e, BuildContext context) {
    if (e.isAllDay) return context.l10n.exceptionAllDay;
    final start =
        '${e.startTime!.hour.toString().padLeft(2, '0')}:${e.startTime!.minute.toString().padLeft(2, '0')}';
    final end =
        '${e.endTime!.hour.toString().padLeft(2, '0')}:${e.endTime!.minute.toString().padLeft(2, '0')}';
    return '$start - $end';
  }
}
--- FILE: lib/features/staff/widgets/staff_top_controls.dart ---
import 'package:agenda_backend/app/widgets/top_controls.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class StaffTopControls extends ConsumerWidget {
  const StaffTopControls({
    super.key,
    this.todayLabel,
    this.labelOverride,
    this.compact = false,
  });

  final String? todayLabel;
  final String? labelOverride;
  final bool compact;
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return TopControls.staff(
      todayLabel: todayLabel,
      labelOverride: labelOverride,
      compact: compact,
    );
  }
}
--- FILE: lib/features/services/services_feature.dart ---
--- FILE: lib/features/services/providers/services_sorted_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import 'service_categories_provider.dart';
import 'services_provider.dart';

/// Liste ordinate con queste priorit√†:
/// 1) Categorie con servizi prima, categorie vuote in coda
/// 2) sortOrder crescente
/// 3) nome come tie-breaker
final sortedCategoriesProvider = Provider<List<ServiceCategory>>((ref) {
  final cats = ref.watch(serviceCategoriesProvider);

  // Pre-calcolo: per ogni categoria verifichiamo se ha servizi.
  final hasServicesMap = <int, bool>{
    for (final c in cats)
      c.id: ref.watch(servicesByCategoryProvider(c.id)).isNotEmpty,
  };

  final copy = [...cats];
  copy.sort((a, b) {
    final aEmpty = !(hasServicesMap[a.id] ?? false);
    final bEmpty = !(hasServicesMap[b.id] ?? false);

    // Vuote in coda: una categoria vuota deve venire dopo una non vuota.
    if (aEmpty != bEmpty) return aEmpty ? 1 : -1;

    final so = a.sortOrder.compareTo(b.sortOrder);
    return so != 0 ? so : a.name.toLowerCase().compareTo(b.name.toLowerCase());
  });
  return copy;
});

final sortedServicesByCategoryProvider = Provider.family<List<Service>, int>((
  ref,
  categoryId,
) {
  final services = ref.watch(servicesByCategoryProvider(categoryId));
  final copy = [...services];
  copy.sort((a, b) {
    final so = a.sortOrder.compareTo(b.sortOrder);
    return so != 0 ? so : a.name.toLowerCase().compareTo(b.name.toLowerCase());
  });
  return copy;
});
--- FILE: lib/features/services/providers/services_provider.dart ---
import 'dart:math';

import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/service.dart';
import '../../../core/models/service_staff_eligibility.dart';
import '../../../core/models/service_variant.dart';
import '../../../core/utils/color_utils.dart';
import 'package:flutter/material.dart';
import '../../agenda/providers/business_providers.dart';
import '../../agenda/providers/location_providers.dart';
import '../utils/service_seed_texts.dart';
import 'service_categories_provider.dart';

// Le categorie sono ora gestite in providers/service_categories_provider.dart

///
/// SERVICES NOTIFIER (CRUD in memoria)
///
class ServicesNotifier extends Notifier<List<Service>> {
  @override
  List<Service> build() {
    final business = ref.watch(currentBusinessProvider);
    final cats = ref.read(serviceCategoriesProvider);
    // Base: tre servizi fissi per compatibilita' con i test esistenti
    final seed = <Service>[
      Service(
        id: 1,
        businessId: business.id,
        categoryId: 10,
        name: ServiceSeedTexts.serviceRelaxName,
        description: ServiceSeedTexts.serviceRelaxDescription,
      ),
      Service(
        id: 2,
        businessId: business.id,
        categoryId: 11,
        name: ServiceSeedTexts.serviceSportName,
        description: ServiceSeedTexts.serviceSportDescription,
      ),
      Service(
        id: 3,
        businessId: business.id,
        categoryId: 12,
        name: ServiceSeedTexts.serviceFaceName,
        description: ServiceSeedTexts.serviceFaceDescription,
      ),
    ];

    // Aggiunge mock extra per ciascuna categoria non vincolata dai test
    // (10 e 11), fino a un totale casuale di 5..10 servizi per categoria.
    int nextId = 4;

    var all = <Service>[...seed];

    if (kIsWeb) {
      for (final cat in cats) {
        // Mantieni la categoria 12 con un solo servizio (id 3) per i test
        if (cat.id == 12) continue;

        final rnd = Random(cat.id);
        final desiredTotal = 5 + rnd.nextInt(6); // 5..10
        final existingInCat = all.where((s) => s.categoryId == cat.id).length;
        final toAdd = (desiredTotal - existingInCat).clamp(0, 10);

        for (int i = 0; i < toAdd; i++) {
          final nameIndex = existingInCat + i + 1;
          final svc = Service(
            id: nextId++,
            businessId: business.id,
            categoryId: cat.id,
            name: '${cat.name} $nameIndex',
            description: null,
          );
          all.add(svc);
        }
      }
    }

    // Hard guard: garantisce che la categoria 12 resti con solo il servizio id 3
    all = [
      for (final s in all)
        if (s.categoryId != 12 || s.id == 3) s,
    ];

    return all;
  }

  void add(Service service) {
    state = [...state, service];
    // Aggiunta di un servizio potrebbe rendere non vuota una categoria
    ref
        .read(serviceCategoriesProvider.notifier)
        .bumpEmptyCategoriesToEnd(servicesOverride: state);
  }

  void update(Service updated) {
    state = [
      for (final s in state)
        if (s.id == updated.id) updated else s,
    ];
    // Aggiorna posizionamento categorie vuote vs piene
    ref
        .read(serviceCategoriesProvider.notifier)
        .bumpEmptyCategoriesToEnd(servicesOverride: state);
  }

  void delete(int id) {
    int? removedCat;
    for (final s in state) {
      if (s.id == id) {
        removedCat = s.categoryId;
        break;
      }
    }
    state = state.where((s) => s.id != id).toList();
    ref.read(serviceVariantsProvider.notifier).removeByServiceId(id);
    // Salvaguardia per i mock dei test: se abbiamo rimosso il servizio
    // della categoria 12, assicurati che la categoria diventi effettivamente vuota.
    if (removedCat == 12) {
      state = state.where((s) => s.categoryId != 12).toList();
    }
    // Ulteriore salvaguardia: se per qualsiasi motivo l'id 3 non √® presente,
    // ma esistono ancora servizi in categoria 12, puliscila per mantenere
    // l'assunto dei test (cat 12 diventa vuota dopo delete(3)).
    final hasId3 = state.any((s) => s.id == 3);
    final hasCat12 = state.any((s) => s.categoryId == 12);
    if (!hasId3 && hasCat12) {
      state = state.where((s) => s.categoryId != 12).toList();
    }
    // Aggiorna posizionamento categorie vuote vs piene
    ref
        .read(serviceCategoriesProvider.notifier)
        .bumpEmptyCategoriesToEnd(servicesOverride: state);
  }

  void duplicate(Service original) {
    final newId = _nextId();
    final existingNames = state.map((s) => s.name).toSet();

    String makeDuplicateName(String originalName) {
      final copyWord = ServiceSeedTexts.duplicateCopyWord;
      final copyWordEscaped = RegExp.escape(copyWord);
      // Supporta varianti precedenti come " (copyWord)" e la nuova " copyWord"/" copyWord N"
      String base = originalName;
      int? startFrom;

      final reNew = RegExp(
        '^(.*?)(?:\\s$copyWordEscaped(?:\\s(\\d+))?)\$',
        caseSensitive: false,
      );
      final reOld = RegExp(
        '^(.*?)(?:\\s\\((?:$copyWordEscaped)(?:\\s(\\d+))?\\))\$',
        caseSensitive: false,
      );

      RegExpMatch? m =
          reNew.firstMatch(originalName) ?? reOld.firstMatch(originalName);
      if (m != null) {
        base = (m.group(1) ?? '').trim();
        final n = m.group(2);
        if (n != null) {
          final parsed = int.tryParse(n);
          if (parsed != null) startFrom = parsed + 1;
        } else {
          startFrom = 1;
        }
      }

      // Primo tentativo: "<base> <copyWord>"
      String candidate = '$base $copyWord';
      if (!existingNames.contains(candidate)) return candidate;

      // Altrimenti prova con numeri incrementali
      int i = startFrom ?? 1;
      while (true) {
        candidate = '$base $copyWord $i';
        if (!existingNames.contains(candidate)) return candidate;
        i++;
        if (i > 9999) break; // guardia
      }
      // Fallback improbabile
      return '$base $copyWord';
    }

    final copy = Service(
      id: newId,
      businessId: original.businessId,
      categoryId: original.categoryId,
      name: makeDuplicateName(original.name),
      description: original.description,
    );
    add(copy);
    final originalVariant = ref.read(
      serviceVariantByServiceIdProvider(original.id),
    );
    if (originalVariant != null) {
      ref.read(serviceVariantsProvider.notifier).upsert(
            originalVariant.copyWith(
              id: 900000 + newId,
              serviceId: newId,
            ),
          );
    }
    // Un duplicato potrebbe rendere non vuota una categoria
    ref
        .read(serviceCategoriesProvider.notifier)
        .bumpEmptyCategoriesToEnd(servicesOverride: state);
  }

  int _nextId() {
    if (state.isEmpty) return 1;
    final maxId = state.map((s) => s.id).reduce((a, b) => a > b ? a : b);
    return maxId + 1;
  }
}

final servicesProvider = NotifierProvider<ServicesNotifier, List<Service>>(
  ServicesNotifier.new,
);

///
/// VARIANTI SERVIZI (mock, filtrate per location)
///
class ServiceVariantsNotifier extends Notifier<List<ServiceVariant>> {
  @override
  List<ServiceVariant> build() {
    final location = ref.read(currentLocationProvider);
    final currency = ref.read(effectiveCurrencyProvider);
    final services = ref.read(servicesProvider);
    final cats = ref.read(serviceCategoriesProvider);

    final palette = <Color>[
      // Same palette used in service_dialog.dart
      Color(0xFFFFCDD2),
      Color(0xFFFFC1C9),
      Color(0xFFFFB4BC),
      Color(0xFFFFD6B3),
      Color(0xFFFFC9A3),
      Color(0xFFFFBD93),
      Color(0xFFFFF0B3),
      Color(0xFFFFE6A3),
      Color(0xFFFFDC93),
      Color(0xFFEAF2B3),
      Color(0xFFDFEAA3),
      Color(0xFFD4E293),
      Color(0xFFCDECCF),
      Color(0xFFC1E4C4),
      Color(0xFFB6DCB9),
      Color(0xFFBFE8E0),
      Color(0xFFB1DFD6),
      Color(0xFFA3D6CB),
      Color(0xFFBDEFF4),
      Color(0xFFB0E6EF),
      Color(0xFFA3DDEA),
      Color(0xFFBFD9FF),
      Color(0xFFB0CEFF),
      Color(0xFFA1C3FF),
      Color(0xFFC7D0FF),
      Color(0xFFBAC4FF),
      Color(0xFFAEB8FF),
      Color(0xFFE0D0FF),
      Color(0xFFD4C4FF),
      Color(0xFFC9B8FF),
    ];
    Color colorForCategory(int categoryId) {
      final index = cats.indexWhere((c) => c.id == categoryId);
      final paletteIndex = index >= 0 ? index % palette.length : 0;
      return palette[paletteIndex];
    }

    final durations = <int>[15, 30, 45, 60, 75, 90];
    const generatedBaseId = 900000;
    final variants = <ServiceVariant>[];

    for (final cat in cats) {
      final inCat = services.where((s) => s.categoryId == cat.id).toList();
      inCat.sort((a, b) => a.id.compareTo(b.id));

      final rnd = Random(cat.id);
      for (final service in inCat) {
        final dur = durations[rnd.nextInt(durations.length)];
        final rawPrice = dur * (1.0 + rnd.nextDouble() * 0.6);
        final price = (rawPrice / 5).round() * 5;
        final isFrom = rnd.nextInt(5) == 0;
        final color = colorForCategory(cat.id);
        final blockedTime = service.id == 1 ? 10 : 0;
        final processingTime = service.name == 'Trattamenti Corpo 2' ? 10 : 0;

        variants.add(
          ServiceVariant(
            id: generatedBaseId + service.id,
            serviceId: service.id,
            locationId: location.id,
            durationMinutes: dur,
            processingTime: processingTime,
            blockedTime: blockedTime,
            price: price.toDouble(),
            colorHex: ColorUtils.toHex(color),
            currency: currency,
            isBookableOnline: true,
            isFree: false,
            isPriceStartingFrom: isFrom,
            resourceRequirements: const [],
          ),
        );
      }
    }

    return variants;
  }

  void upsert(ServiceVariant variant) {
    state = [
      for (final v in state)
        if (v.id == variant.id) variant else v,
      if (!state.any((v) => v.id == variant.id)) variant,
    ];
  }

  void removeByServiceId(int serviceId) {
    state = state.where((v) => v.serviceId != serviceId).toList();
  }
}

final serviceVariantsProvider =
    NotifierProvider<ServiceVariantsNotifier, List<ServiceVariant>>(
  ServiceVariantsNotifier.new,
);

///
/// SERVICE VARIANT BY ID
///
final serviceVariantByIdProvider = Provider.family<ServiceVariant?, int>((
  ref,
  variantId,
) {
  final variants = ref.watch(serviceVariantsProvider);
  for (final variant in variants) {
    if (variant.id == variantId) return variant;
  }
  return null;
});

final serviceVariantByServiceIdProvider =
    Provider.family<ServiceVariant?, int>((ref, serviceId) {
  final location = ref.watch(currentLocationProvider);
  final variants = ref.watch(serviceVariantsProvider);
  for (final variant in variants) {
    if (variant.serviceId == serviceId && variant.locationId == location.id) {
      return variant;
    }
  }
  return null;
});

///
/// ELIGIBILITY STAFF
///
class ServiceStaffEligibilityNotifier
    extends Notifier<List<ServiceStaffEligibility>> {
  @override
  List<ServiceStaffEligibility> build() {
    return const [
      ServiceStaffEligibility(serviceId: 1, staffId: 1, locationId: 101),
      ServiceStaffEligibility(serviceId: 1, staffId: 3, locationId: 101),
      ServiceStaffEligibility(serviceId: 1, staffId: 2, locationId: 102),
      ServiceStaffEligibility(serviceId: 1, staffId: 3, locationId: 102),
      ServiceStaffEligibility(serviceId: 2, staffId: 3),
      ServiceStaffEligibility(serviceId: 2, staffId: 4, locationId: 101),
      ServiceStaffEligibility(serviceId: 2, staffId: 2, locationId: 102),
      ServiceStaffEligibility(serviceId: 3, staffId: 1, locationId: 101),
      ServiceStaffEligibility(serviceId: 3, staffId: 2, locationId: 102),
      ServiceStaffEligibility(serviceId: 3, staffId: 3, locationId: 102),
    ];
  }

  void setEligibleStaffForService({
    required int serviceId,
    required int locationId,
    required Iterable<int> staffIds,
  }) {
    final retained = [
      for (final entry in state)
        if (!(entry.serviceId == serviceId &&
            (entry.locationId == null || entry.locationId == locationId)))
          entry,
    ];
    final updated = [
      for (final staffId in staffIds)
        ServiceStaffEligibility(
          serviceId: serviceId,
          staffId: staffId,
          locationId: locationId,
        ),
    ];
    state = [...retained, ...updated];
  }

  void setEligibleServicesForStaff({
    required int staffId,
    required int locationId,
    required Iterable<int> serviceIds,
  }) {
    final retained = [
      for (final entry in state)
        if (!(entry.staffId == staffId &&
            (entry.locationId == null || entry.locationId == locationId)))
          entry,
    ];
    final updated = [
      for (final serviceId in serviceIds)
        ServiceStaffEligibility(
          serviceId: serviceId,
          staffId: staffId,
          locationId: locationId,
        ),
    ];
    state = [...retained, ...updated];
  }
}

final serviceStaffEligibilityProvider =
    NotifierProvider<ServiceStaffEligibilityNotifier,
        List<ServiceStaffEligibility>>(ServiceStaffEligibilityNotifier.new);

final eligibleStaffForServiceProvider = Provider.family<List<int>, int>((
  ref,
  serviceId,
) {
  final location = ref.watch(currentLocationProvider);
  final elegibility = ref.watch(serviceStaffEligibilityProvider);

  return [
    for (final entry in elegibility)
      if (entry.serviceId == serviceId &&
          (entry.locationId == null || entry.locationId == location.id))
        entry.staffId,
  ];
});

final eligibleServicesForStaffProvider = Provider.family<List<int>, int>((
  ref,
  staffId,
) {
  final location = ref.watch(currentLocationProvider);
  final eligibilities = ref.watch(serviceStaffEligibilityProvider);
  return [
    for (final entry in eligibilities)
      if (entry.staffId == staffId &&
          (entry.locationId == null || entry.locationId == location.id))
        entry.serviceId,
  ];
});

///
/// SERVICES PER CATEGORIA
///
final servicesByCategoryProvider = Provider.family<List<Service>, int>((
  ref,
  categoryId,
) {
  final services = ref.watch(servicesProvider);
  return [
    for (final service in services)
      if (service.categoryId == categoryId) service,
  ];
});
--- FILE: lib/features/services/providers/services_reorder_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/l10n/l10n.dart';
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import 'service_categories_provider.dart';
import 'services_provider.dart';

/// Gestisce la modalit√† riordino e applica gli ordinamenti aggiornando sortOrder
class ServicesReorderNotifier extends Notifier<bool> {
  @override
  bool build() => false; // false = non in riordino

  void toggle() => state = !state;

  void setReordering(bool value) => state = value;

  /// Riordina le categorie a livello top
  void reorderCategories(int oldIndex, int newIndex) {
    final notifier = ref.read(serviceCategoriesProvider.notifier);
    final list = [...ref.read(serviceCategoriesProvider)];

    if (newIndex > oldIndex) newIndex -= 1;

    final item = list.removeAt(oldIndex);
    list.insert(newIndex, item);

    final reordered = <ServiceCategory>[];
    for (int i = 0; i < list.length; i++) {
      reordered.add(list[i].copyWith(sortOrder: i));
    }

    notifier.state = reordered;
  }

  /// Riordina solo le categorie NON vuote, mantenendo le vuote in coda e non spostabili.
  void reorderNonEmptyCategories(int oldIndex, int newIndex) {
    final catsNotifier = ref.read(serviceCategoriesProvider.notifier);
    final allCats = [...ref.read(serviceCategoriesProvider)];
    final services = ref.read(servicesProvider);

    final nonEmpty = <ServiceCategory>[];
    final empty = <ServiceCategory>[];
    for (final c in allCats) {
      final hasServices = services.any((s) => s.categoryId == c.id);
      if (hasServices) {
        nonEmpty.add(c);
      } else {
        empty.add(c);
      }
    }

    final item = nonEmpty.removeAt(oldIndex);
    final insertIndex = newIndex.clamp(0, nonEmpty.length);
    nonEmpty.insert(insertIndex, item);

    final merged = [...nonEmpty, ...empty];
    final reordered = <ServiceCategory>[];
    for (int i = 0; i < merged.length; i++) {
      reordered.add(merged[i].copyWith(sortOrder: i));
    }

    catsNotifier.state = reordered;
  }

  /// Riordina i servizi all'interno della stessa categoria
  void reorderServices(int categoryId, int oldIndex, int newIndex) {
    final servicesNotifier = ref.read(servicesProvider.notifier);
    final all = [...ref.read(servicesProvider)];

    final byCat = all.where((s) => s.categoryId == categoryId).toList();
    final item = byCat.removeAt(oldIndex);
    byCat.insert(newIndex, item);

    final updatedByCat = <Service>[];
    for (int i = 0; i < byCat.length; i++) {
      updatedByCat.add(byCat[i].copyWith(sortOrder: i));
    }

    final updatedAll = [
      for (final s in all)
        if (s.categoryId == categoryId)
          updatedByCat.firstWhere((x) => x.id == s.id)
        else
          s,
    ];

    servicesNotifier.state = updatedAll;
  }

  /// üîÑ Sposta un servizio da una categoria all'altra (drag cross-categoria)
  void moveServiceBetweenCategories(
    int oldCategoryId,
    int newCategoryId,
    int serviceId,
    int newIndex,
  ) {
    final servicesNotifier = ref.read(servicesProvider.notifier);
    final all = [...ref.read(servicesProvider)];

    // servizio selezionato
    final movedService = all.firstWhere(
      (s) => s.id == serviceId,
      orElse: () => throw Exception(L10n.current.errorServiceNotFound),
    );

    // rimuovi da categoria precedente
    final remainingOldCat = all
        .where((s) => s.categoryId == oldCategoryId && s.id != serviceId)
        .toList();

    // aggiungi nella nuova categoria
    final targetCat = all.where((s) => s.categoryId == newCategoryId).toList();
    if (newIndex > targetCat.length) newIndex = targetCat.length;
    targetCat.insert(
      newIndex,
      movedService.copyWith(categoryId: newCategoryId),
    );

    // ricalcola sortOrder in entrambe le categorie
    final updated = [
      ...all.where(
        (s) => s.categoryId != oldCategoryId && s.categoryId != newCategoryId,
      ),
      for (int i = 0; i < remainingOldCat.length; i++)
        remainingOldCat[i].copyWith(sortOrder: i),
      for (int i = 0; i < targetCat.length; i++)
        targetCat[i].copyWith(sortOrder: i),
    ];

    servicesNotifier.state = updated;
    // Aggiorna posizionamento categorie vuote vs piene
    ref.read(serviceCategoriesProvider.notifier).bumpEmptyCategoriesToEnd();
  }
}

final servicesReorderProvider = NotifierProvider<ServicesReorderNotifier, bool>(
  ServicesReorderNotifier.new,
);

class ServicesReorderPanelNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  void toggle() => state = !state;

  void setVisible(bool value) => state = value;
}

final servicesReorderPanelProvider =
    NotifierProvider<ServicesReorderPanelNotifier, bool>(
  ServicesReorderPanelNotifier.new,
);
--- FILE: lib/features/services/providers/service_categories_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../agenda/providers/business_providers.dart';
import '../utils/service_seed_texts.dart';
import 'services_provider.dart';

/// Notifier per la gestione delle categorie di servizi (CRUD in memoria)
class ServiceCategoriesNotifier extends Notifier<List<ServiceCategory>> {
  @override
  List<ServiceCategory> build() {
    final business = ref.watch(currentBusinessProvider);
    // Seed iniziale (spostato qui dal vecchio services_provider)
    final seed = <ServiceCategory>[
      ServiceCategory(
        id: 10,
        businessId: business.id,
        name: ServiceSeedTexts.categoryBodyName,
        description: ServiceSeedTexts.categoryBodyDescription,
        sortOrder: 0,
      ),
      ServiceCategory(
        id: 11,
        businessId: business.id,
        name: ServiceSeedTexts.categorySportsName,
        description: ServiceSeedTexts.categorySportsDescription,
        sortOrder: 1,
      ),
      ServiceCategory(
        id: 12,
        businessId: business.id,
        name: ServiceSeedTexts.categoryFaceName,
        description: ServiceSeedTexts.categoryFaceDescription,
        sortOrder: 2,
      ),
    ];
    return _sorted(seed);
  }

  List<ServiceCategory> _sorted(List<ServiceCategory> list) {
    final copy = [...list];
    copy.sort((a, b) => a.sortOrder.compareTo(b.sortOrder));
    return copy;
  }

  void addCategory(ServiceCategory newCategory) {
    final nextSort = state.isEmpty
        ? 0
        : (state.map((c) => c.sortOrder).reduce((a, b) => a > b ? a : b) + 1);
    final withOrder = newCategory.copyWith(sortOrder: nextSort);
    state = _sorted([...state, withOrder]);
    // Se la nuova categoria √® vuota, deve andare in coda per sortOrder alto
    bumpEmptyCategoriesToEnd();
  }

  void updateCategory(ServiceCategory updatedCategory) {
    state = _sorted([
      for (final c in state)
        if (c.id == updatedCategory.id) updatedCategory else c,
    ]);
  }

  void deleteCategory(int id) {
    state = _sorted(state.where((c) => c.id != id).toList());
  }

  /// Imposta un sortOrder elevato per le categorie senza servizi,
  /// in modo che siano naturalmente in coda all'ordinamento.
  ///
  /// Per evitare dipendenze circolari quando chiamata da ServicesNotifier,
  /// si pu√≤ passare la lista servizi gi√† aggiornata tramite [servicesOverride].
  void bumpEmptyCategoriesToEnd({List<Service>? servicesOverride}) {
    final List<Service> services =
        servicesOverride ?? ref.read(servicesProvider);
    final nonEmptyCatIds = <int>{for (final s in services) s.categoryId};

    int maxNonEmptySort = -1;
    for (final c in state) {
      if (nonEmptyCatIds.contains(c.id)) {
        if (c.sortOrder > maxNonEmptySort) maxNonEmptySort = c.sortOrder;
      }
    }

    // Base alta per evitare collisioni con futuri riordini
    final base = (maxNonEmptySort < 0 ? 0 : maxNonEmptySort + 1) + 1000;
    int offset = 0;

    final updated = [
      for (final c in state)
        if (nonEmptyCatIds.contains(c.id))
          c
        else
          c.copyWith(sortOrder: base + offset++),
    ];

    state = _sorted(updated);
  }
}

final serviceCategoriesProvider =
    NotifierProvider<ServiceCategoriesNotifier, List<ServiceCategory>>(
      ServiceCategoriesNotifier.new,
    );
--- FILE: lib/features/services/utils/service_validators.dart ---
import 'package:agenda_backend/core/models/service.dart';
import 'package:agenda_backend/core/models/service_category.dart';

class ServiceValidators {
  const ServiceValidators._();

  static bool isNonEmpty(String value) => value.trim().isNotEmpty;

  static bool isDuplicateCategoryName(
    List<ServiceCategory> categories,
    String normalizedName, {
    int? excludeId,
  }) {
    final needle = normalizedName.toLowerCase();
    return categories.any(
      (c) => c.id != excludeId && c.name.toLowerCase() == needle,
    );
  }

  static bool isDuplicateServiceName(
    List<Service> services,
    String normalizedName, {
    int? excludeId,
  }) {
    final needle = normalizedName.toLowerCase();
    return services.any(
      (s) => s.id != excludeId && s.name.toLowerCase() == needle,
    );
  }
}
--- FILE: lib/features/services/utils/service_seed_texts.dart ---
import 'package:intl/intl.dart';

/// Localization helpers per le stringhe di seed e duplicazione usate dalla feature Services.
class ServiceSeedTexts {
  const ServiceSeedTexts._();

  static String get categoryBodyName => Intl.message(
        'Trattamenti Corpo',
        name: 'serviceSeedCategoryBodyName',
        desc: 'Nome della categoria di default dedicata ai trattamenti corpo.',
      );

  static String get categoryBodyDescription => Intl.message(
        'Servizi dedicati al benessere del corpo',
        name: 'serviceSeedCategoryBodyDescription',
        desc: 'Descrizione della categoria di default dedicata ai trattamenti corpo.',
      );

  static String get categorySportsName => Intl.message(
        'Trattamenti Sportivi',
        name: 'serviceSeedCategorySportsName',
        desc: 'Nome della categoria di default dedicata ai trattamenti sportivi.',
      );

  static String get categorySportsDescription => Intl.message(
        'Percorsi pensati per atleti e persone attive',
        name: 'serviceSeedCategorySportsDescription',
        desc: 'Descrizione della categoria di default dedicata ai trattamenti sportivi.',
      );

  static String get categoryFaceName => Intl.message(
        'Trattamenti Viso',
        name: 'serviceSeedCategoryFaceName',
        desc: 'Nome della categoria di default dedicata ai trattamenti viso.',
      );

  static String get categoryFaceDescription => Intl.message(
        'Cura estetica e rigenerante per il viso',
        name: 'serviceSeedCategoryFaceDescription',
        desc: 'Descrizione della categoria di default dedicata ai trattamenti viso.',
      );

  static String get serviceRelaxName => Intl.message(
        'Massaggio Relax',
        name: 'serviceSeedServiceRelaxName',
        desc: 'Nome del servizio di massaggio relax iniziale.',
      );

  static String get serviceRelaxDescription => Intl.message(
        'Trattamento rilassante da 30 minuti',
        name: 'serviceSeedServiceRelaxDescription',
        desc: 'Descrizione del servizio di massaggio relax iniziale.',
      );

  static String get serviceSportName => Intl.message(
        'Massaggio Sportivo',
        name: 'serviceSeedServiceSportName',
        desc: 'Nome del servizio di massaggio sportivo iniziale.',
      );

  static String get serviceSportDescription => Intl.message(
        'Trattamento decontratturante intensivo',
        name: 'serviceSeedServiceSportDescription',
        desc: 'Descrizione del servizio di massaggio sportivo iniziale.',
      );

  static String get serviceFaceName => Intl.message(
        'Trattamento Viso',
        name: 'serviceSeedServiceFaceName',
        desc: 'Nome del servizio per il viso iniziale.',
      );

  static String get serviceFaceDescription => Intl.message(
        'Pulizia e trattamento illuminante',
        name: 'serviceSeedServiceFaceDescription',
        desc: 'Descrizione del servizio per il viso iniziale.',
      );

  static String get duplicateCopyWord => Intl.message(
        'Copia',
        name: 'serviceDuplicateCopyWord',
        desc:
            'Parola usata per nominare servizi duplicati (es. "Servizio Copia" o "Servizio Copia 2").',
      );
}
--- FILE: lib/features/services/controllers/services_reorder_controller.dart ---
import 'package:flutter/foundation.dart';

/// Skeleton: controller per reorder servizi ‚Äì API da collegare 1:1
class ServicesReorderController {
  const ServicesReorderController();

  // Esempio di firma che potr√† essere implementata 1:1 durante l'estrazione
  void onReorder({required int oldIndex, required int newIndex}) {
    // Implementazione reale verr√† estratta da services_screen.dart
    if (kDebugMode) {
      // ignore: avoid_print
      print('Services reorder: $oldIndex -> $newIndex (skeleton)');
    }
  }
}
--- FILE: lib/features/services/controllers/categories_reorder_controller.dart ---
import 'package:flutter/foundation.dart';

/// Skeleton: controller per reorder categorie ‚Äì API da collegare 1:1
class CategoriesReorderController {
  const CategoriesReorderController();

  // Esempio di firma che potr√† essere implementata 1:1 durante l'estrazione
  void onReorder({required int oldIndex, required int newIndex}) {
    // Implementazione reale verr√† estratta da services_screen.dart
    if (kDebugMode) {
      // ignore: avoid_print
      print('Categories reorder: $oldIndex -> $newIndex (skeleton)');
    }
  }
}
--- FILE: lib/features/services/data/services_api.dart ---
--- FILE: lib/features/services/data/services_repository.dart ---
--- FILE: lib/features/services/domain/controllers/category_controller.dart ---
/// Placeholder per futura persistenza/sincronizzazione delle categorie
/// con un backend remoto (REST/Firebase, ecc.).
class CategoryController {
  // In futuro: metodi per fetch/save/sync
}
--- FILE: lib/features/services/domain/services.dart ---
--- FILE: lib/features/services/presentation/services_screen.dart ---
import 'dart:async';

import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/l10n/l10_extension.dart';
import '../../../core/models/service.dart';
import '../../../core/models/service_category.dart';
import '../../../core/models/service_variant.dart';
import '../../../core/utils/color_utils.dart';
import '../../../core/widgets/app_dialogs.dart';
import '../../../core/widgets/reorder_toggle_button.dart';
import '../../../core/widgets/reorder_toggle_panel.dart';
import '../providers/service_categories_provider.dart';
import '../providers/services_provider.dart';
import '../providers/services_reorder_provider.dart';
import '../providers/services_sorted_providers.dart';
// utils e validators spostati nei dialog
import 'dialogs/category_dialog.dart';
import 'dialogs/service_dialog.dart';
import 'widgets/categories_list.dart';

class ServicesScreen extends ConsumerStatefulWidget {
  const ServicesScreen({super.key});

  @override
  ConsumerState<ServicesScreen> createState() => _ServicesScreenState();
}

class _ServicesScreenState extends ConsumerState<ServicesScreen> {
  static final ValueNotifier<int?> _hoveredService = ValueNotifier<int?>(null);
  static final ValueNotifier<int?> _selectedService = ValueNotifier<int?>(null);

  final ScrollController _scrollController = ScrollController();
  Timer? _autoScrollTimer;

  /// Modalit√† di riordino (mutuamente esclusive)
  bool isReorderCategories = false;
  bool isReorderServices = false;

  // ---------- Auto-scroll mentre si trascina ----------
  void _startAutoScroll(Offset pointerInGlobal) {
    const threshold = 100.0; // distanza dal bordo
    const speed = 14.0; // px per tick ~60fps

    _autoScrollTimer?.cancel();
    _autoScrollTimer = Timer.periodic(const Duration(milliseconds: 16), (_) {
      if (!_scrollController.hasClients) return;

      final renderBox = context.findRenderObject() as RenderBox?;
      if (renderBox == null) return;

      final local = renderBox.globalToLocal(pointerInGlobal);
      final dy = local.dy;

      final pos = _scrollController.offset;
      final max = _scrollController.position.maxScrollExtent;
      final viewH = _scrollController.position.viewportDimension;

      if (dy < threshold && pos > 0) {
        _scrollController.jumpTo((pos - speed).clamp(0, max));
      } else if (dy > viewH - threshold && pos < max) {
        _scrollController.jumpTo((pos + speed).clamp(0, max));
      }
    });
  }

  void _stopAutoScroll() => _autoScrollTimer?.cancel();

  void _toggleCategoryReorder() {
    setState(() {
      isReorderCategories = !isReorderCategories;
      if (isReorderCategories) isReorderServices = false;
    });
    if (!isReorderCategories) {
      ref.read(servicesReorderPanelProvider.notifier).setVisible(false);
    }
  }

  void _toggleServiceReorder() {
    setState(() {
      isReorderServices = !isReorderServices;
      if (isReorderServices) isReorderCategories = false;
    });
    if (!isReorderServices) {
      ref.read(servicesReorderPanelProvider.notifier).setVisible(false);
    }
  }

  @override
  void dispose() {
    _autoScrollTimer?.cancel();
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final allCategories = ref.watch(sortedCategoriesProvider);

    // Mostriamo sempre tutte le categorie; i provider di sort sposteranno le vuote in coda.
    final categories = allCategories;

    final colorScheme = Theme.of(context).colorScheme;
    final isWide = ref.watch(formFactorProvider) != AppFormFactor.mobile;
    final showReorderPanel = ref.watch(servicesReorderPanelProvider);

    ref.listen<bool>(servicesReorderPanelProvider, (previous, next) {
      if (!next && (isReorderCategories || isReorderServices)) {
        setState(() {
          isReorderCategories = false;
          isReorderServices = false;
        });
      }
    });

    if (categories.isEmpty) {
      return const SizedBox.shrink();
    }

    return GestureDetector(
      behavior: HitTestBehavior.opaque,
      onTap: () => _selectedService.value = null,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (showReorderPanel) ...[
            Padding(
              padding: const EdgeInsets.all(16),
              child: Center(
                child: Column(
                  children: [
                    Text(
                      context.l10n.reorderTitle,
                      style: Theme.of(context).textTheme.titleSmall?.copyWith(
                        fontWeight: FontWeight.w600,
                      ),
                    ),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(0, 4, 0, 8),
                      child: Text(
                        context.l10n.reorderHelpDescription,
                        style: Theme.of(context).textTheme.bodySmall?.copyWith(
                          color: Theme.of(context).colorScheme.onSurfaceVariant,
                        ),
                      ),
                    ),
                    ReorderTogglePanel(
                      isWide: isWide,
                      children: [
                        ReorderToggleButton(
                          isActive: isReorderCategories,
                          onPressed: _toggleCategoryReorder,
                          activeLabel: context.l10n.reorderCategoriesLabel,
                          inactiveLabel: context.l10n.reorderCategoriesLabel,
                          activeIcon: Icons.check,
                          inactiveIcon: Icons.drag_indicator,
                        ),
                        ReorderToggleButton(
                          isActive: isReorderServices,
                          onPressed: _toggleServiceReorder,
                          activeLabel: context.l10n.reorderServicesLabel,
                          inactiveLabel: context.l10n.reorderServicesLabel,
                          activeIcon: Icons.check,
                          inactiveIcon: Icons.drag_indicator,
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ],

          // ---------- Corpo ----------
          Expanded(
            child: isReorderCategories
                ? _buildReorderCategories(context, ref, categories)
                : isReorderServices
                ? _buildReorderServices(context, ref, categories)
                : _buildNormalList(
                    context,
                    ref,
                    categories,
                    isWide,
                    colorScheme,
                  ),
          ),
        ],
      ),
    );
  }

  // ============================
  //  RIORDINO CATEGORIE (solo categorie, servizi nascosti)
  // ============================
  Widget _buildReorderCategories(
    BuildContext context,
    WidgetRef ref,
    List<ServiceCategory> cats,
  ) {
    final colorScheme = Theme.of(context).colorScheme;

    // Partiziona categorie piene e vuote
    final services = ref.watch(servicesProvider);
    final isNonEmpty = <int, bool>{
      for (final c in cats) c.id: services.any((s) => s.categoryId == c.id),
    };
    final fullCats = [
      for (final c in cats)
        if (isNonEmpty[c.id]!) c,
    ];
    final emptyCats = [
      for (final c in cats)
        if (!isNonEmpty[c.id]!) c,
    ];

    // Costruisci righe: piene, separatore, vuote (disabilitate)
    final rows = <({String type, ServiceCategory? cat})>[];
    for (final c in fullCats) {
      rows.add((type: 'full', cat: c));
    }
    if (emptyCats.isNotEmpty) {
      rows.add((type: 'separator', cat: null));
      for (final c in emptyCats) {
        rows.add((type: 'empty', cat: c));
      }
    }

    int fullIndexFromRow(int rowIndex) {
      int count = 0;
      for (int i = 0; i < rowIndex; i++) {
        if (rows[i].type == 'full') count++;
      }
      return count;
    }

    return Listener(
      onPointerMove: (e) => _startAutoScroll(e.position),
      onPointerUp: (_) => _stopAutoScroll(),
      child: ReorderableListView.builder(
        scrollController: _scrollController,
        padding: const EdgeInsets.fromLTRB(16, 12, 16, 100),
        buildDefaultDragHandles: false,
        // Evita l'effetto elevazione/ombra sull'item in drag:
        proxyDecorator: (child, index, animation) => child,
        itemCount: rows.length,
        onReorder: (oldIndex, newIndex) {
          final movingDown = newIndex > oldIndex;
          if (movingDown) newIndex -= 1;

          // Calcola gli indici nella sola lista delle piene
          final oldFullIndex = fullIndexFromRow(oldIndex);
          final newFullIndex = fullIndexFromRow(newIndex);

          ref
              .read(servicesReorderProvider.notifier)
              .reorderNonEmptyCategories(oldFullIndex, newFullIndex);
        },
        itemBuilder: (context, index) {
          final row = rows[index];
          if (row.type == 'separator') {
            return Container(
              key: const ValueKey('sep'),
              padding: const EdgeInsets.only(top: 64, bottom: 24),
              child: Text(
                context.l10n.emptyCategoriesNotReorderableNote,
                textAlign: TextAlign.center,
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
              ),
            );
          }
          final category = row.cat!;
          final isEmpty = row.type == 'empty';
          return Opacity(
            key: ValueKey('cat-${category.id}'),
            opacity: isEmpty ? 0.6 : 1.0,
            child: Container(
              margin: const EdgeInsets.only(bottom: 16),
              decoration: BoxDecoration(
                color: colorScheme.surface,
                borderRadius: BorderRadius.circular(12),
                border: Border.all(
                  color: colorScheme.outlineVariant.withOpacity(0.4),
                ),
              ),
              child: ListTile(
                leading: isEmpty
                    ? Icon(
                        Icons.drag_indicator,
                        color: colorScheme.onSurfaceVariant.withOpacity(0.3),
                      )
                    : ReorderableDragStartListener(
                        index: index,
                        child: const Icon(Icons.drag_indicator),
                      ),
                title: Text(category.name),
                enabled: !isEmpty,
              ),
            ),
          );
        },
      ),
    );
  }

  // ============================
  //  RIORDINO SERVIZI (CROSS-CATEGORIA)
  // ============================
  Widget _buildReorderServices(
    BuildContext context,
    WidgetRef ref,
    List<ServiceCategory> cats,
  ) {
    final colorScheme = Theme.of(context).colorScheme;
    final reorder = ref.read(servicesReorderProvider.notifier);

    // Flatten di tutti i servizi (solo delle categorie visualizzate)
    final allServices = <Service>[];
    final servicesByCategory = <int, List<Service>>{};
    for (final c in cats) {
      final list = ref.watch(sortedServicesByCategoryProvider(c.id));
      servicesByCategory[c.id] = list;
      allServices.addAll(list);
    }

    // Costruisce la lista visuale con header categoria "fissi" e righe servizio.
    // Gli header non hanno drag handle e non sono riordinabili; i servizi s√¨.
    final rows = <({bool isHeader, Service? s, ServiceCategory? c})>[];
    for (final c in cats) {
      final list = servicesByCategory[c.id] ?? const <Service>[];
      // Sempre mostrare header, anche se vuota
      rows.add((isHeader: true, s: null, c: c));
      for (final s in list) {
        rows.add((isHeader: false, s: s, c: null));
      }
    }

    int serviceFlatIndexFromRowsIndex(int rowsIndex) {
      int count = 0;
      for (int i = 0; i < rowsIndex; i++) {
        if (!rows[i].isHeader) count++;
      }
      return count;
    }

    // Funzione di supporto: data la posizione "globale" nella lista piatta,
    // ritorna la coppia (categoryId, indexNellaCategoria) dove verrebbe inserito
    (int catId, int indexInCat) targetForFlatIndex(
      int flatIndex, {
      required bool movingDown,
      int? movingServiceId,
    }) {
      // Clamp e fallback
      if (allServices.isEmpty) return (cats.first.id, 0);
      final idx = flatIndex.clamp(0, allServices.length);

      // Inserimento in coda assoluta
      if (idx == allServices.length) {
        final last = allServices.last;
        final inCat = servicesByCategory[last.categoryId] ?? [];
        return (last.categoryId, inCat.length);
      }

      // Pivot alla posizione globale idx
      final pivot = allServices[idx];
      final pivotCatId = pivot.categoryId;

      // Quanti elementi di quella categoria compaiono prima dell'indice globale,
      // escludendo il servizio in movimento (per evitare off-by-one)
      int countBeforeInPivotCat = 0;
      for (int i = 0; i < idx; i++) {
        final s = allServices[i];
        if (s.categoryId == pivotCatId && s.id != movingServiceId) {
          countBeforeInPivotCat++;
        }
      }

      return (pivotCatId, countBeforeInPivotCat);
    }

    return Listener(
      onPointerMove: (e) => _startAutoScroll(e.position),
      onPointerUp: (_) => _stopAutoScroll(),
      child: ReorderableListView.builder(
        scrollController: _scrollController,
        padding: const EdgeInsets.fromLTRB(16, 12, 16, 100),
        buildDefaultDragHandles: false,
        // Coerenza visiva: nessuna elevazione/ombra anche durante il drag servizi
        proxyDecorator: (child, index, animation) => child,
        itemCount: rows.length,
        onReorder: (oldIndex, newIndex) {
          // Normalizzazione Flutter Reorderable semantics
          final movingDown = newIndex > oldIndex;
          if (movingDown) newIndex -= 1;

          // Indice e servizio originale (riga servizio)
          final sOld = rows[oldIndex].s!;
          final oldCatId = sOld.categoryId;

          // Traduci newIndex della lista visuale in indice sulla lista servizi (saltando header)
          final targetServiceFlatIndex = serviceFlatIndexFromRowsIndex(
            newIndex,
          );

          // Calcola destinazione (categoria e indice relativo nella categoria) sulla base della lista servizi "reale"
          final (targetCatId, indexInTargetCat) = targetForFlatIndex(
            targetServiceFlatIndex,
            movingDown: movingDown,
            movingServiceId: sOld.id,
          );

          if (targetCatId == oldCatId) {
            // stesso gruppo -> semplice riordino interno
            reorder.reorderServices(
              oldCatId,
              // index relativo nella categoria di origine
              (servicesByCategory[oldCatId] ?? []).indexWhere(
                (e) => e.id == sOld.id,
              ),
              indexInTargetCat,
            );
          } else {
            // Cross-categoria -> sposta
            reorder.moveServiceBetweenCategories(
              oldCatId,
              targetCatId,
              sOld.id,
              indexInTargetCat,
            );
          }
        },
        itemBuilder: (context, index) {
          final row = rows[index];
          if (row.isHeader) {
            final category = row.c!;
            return Container(
              key: ValueKey('header-${category.id}'),
              width: double.infinity,
              margin: const EdgeInsets.only(top: 16, bottom: 6),
              decoration: BoxDecoration(
                color: colorScheme.primaryContainer,
                borderRadius: const BorderRadius.vertical(
                  top: Radius.circular(16),
                ),
              ),
              padding: const EdgeInsets.symmetric(horizontal: 18, vertical: 14),
              child: Text(
                category.name,
                style: Theme.of(context).textTheme.titleMedium?.copyWith(
                  fontWeight: FontWeight.w600,
                  color: colorScheme.onPrimaryContainer,
                ),
              ),
            );
          }

          final s = row.s!;
          return Container(
            key: ValueKey('svc-${s.id}'),
            margin: const EdgeInsets.only(bottom: 6),
            decoration: BoxDecoration(
              color: colorScheme.surface,
              borderRadius: BorderRadius.circular(10),
              border: Border.all(
                color: colorScheme.outlineVariant.withOpacity(0.7),
              ),
            ),
            child: ListTile(
              leading: ReorderableDragStartListener(
                index: index,
                child: const Icon(Icons.drag_indicator),
              ),
              title: Text(s.name),
              dense: true,
              contentPadding: const EdgeInsets.symmetric(
                horizontal: 12,
                vertical: 4,
              ),
            ),
          );
        },
      ),
    );
  }

  // ============================
  //  VISTA NORMALE (pulsanti visibili, no drag)
  // ============================
  Widget _buildNormalList(
    BuildContext context,
    WidgetRef ref,
    List<ServiceCategory> cats,
    bool isWide,
    ColorScheme colorScheme,
  ) {
    final servicesNotifier = ref.read(servicesProvider.notifier);
    Color? mostUsedColorForCategory(ServiceCategory category) {
      final services = ref
          .read(servicesProvider)
          .where((s) => s.categoryId == category.id)
          .toList();
      if (services.isEmpty) return null;
      final variants = ref.read(serviceVariantsProvider);
      final counts = <int, int>{};
      Color? topColor;
      int topCount = 0;
      for (final service in services) {
        ServiceVariant? variant;
        for (final v in variants) {
          if (v.serviceId == service.id) {
            variant = v;
            break;
          }
        }
        final colorHex = variant?.colorHex;
        if (colorHex == null) continue;
        final color = ColorUtils.fromHex(colorHex);
        final key = color.value;
        final nextCount = (counts[key] ?? 0) + 1;
        counts[key] = nextCount;
        if (nextCount > topCount) {
          topCount = nextCount;
          topColor = color;
        }
      }
      return topColor;
    }

    return CategoriesList(
      categories: cats,
      isWide: isWide,
      colorScheme: colorScheme,
      hoveredService: _hoveredService,
      selectedService: _selectedService,
      scrollController: _scrollController,
      onAddService: (category) => _openServiceDialog(
        context,
        ref,
        preselectedCategoryId: category.id,
        preselectedColor: mostUsedColorForCategory(category),
      ),
      onEditCategory: (category) =>
          showCategoryDialog(context, ref, category: category),
      onDeleteCategory: (categoryId) =>
          _confirmDeleteCategory(context, ref, categoryId),
      onDeleteCategoryBlocked: () => _showCannotDeleteCategoryDialog(context),
      onServiceOpen: (service) =>
          _openServiceDialog(context, ref, service: service),
      onServiceEdit: (service) =>
          _openServiceDialog(context, ref, service: service),
      onServiceDuplicate: (service) => _openServiceDialog(
        context,
        ref,
        service: service,
        duplicateFrom: true,
      ),
      onServiceDelete: (id) =>
          _confirmDelete(context, onConfirm: () => servicesNotifier.delete(id)),
    );
  }

  void _confirmDeleteCategory(
    BuildContext context,
    WidgetRef ref,
    int categoryId,
  ) {
    showAppConfirmDialog(
      context,
      title: Text(context.l10n.deleteConfirmationTitle),
      confirmLabel: context.l10n.actionDelete,
      cancelLabel: context.l10n.actionCancel,
      danger: true,
      onConfirm: () {
        ref.read(serviceCategoriesProvider.notifier).deleteCategory(categoryId);
      },
    );
  }

  void _showCannotDeleteCategoryDialog(BuildContext context) {
    showAppInfoDialog(
      context,
      title: Text(context.l10n.cannotDeleteTitle),
      content: Text(context.l10n.cannotDeleteCategoryContent),
      closeLabel: context.l10n.actionClose,
    );
  }

  Future<void> _openServiceDialog(
    BuildContext context,
    WidgetRef ref, {
    Service? service,
    int? preselectedCategoryId,
    Color? preselectedColor,
    bool duplicateFrom = false,
  }) {
    return showServiceDialog(
      context,
      ref,
      service: service,
      preselectedCategoryId: preselectedCategoryId,
      preselectedColor: preselectedColor,
      duplicateFrom: duplicateFrom,
    ).then((_) => _selectedService.value = null);
  }

  void _confirmDelete(BuildContext context, {required VoidCallback onConfirm}) {
    showAppConfirmDialog(
      context,
      title: Text(context.l10n.deleteServiceQuestion),
      content: Text(context.l10n.cannotUndoWarning),
      confirmLabel: context.l10n.actionDelete,
      cancelLabel: context.l10n.actionCancel,
      danger: true,
      onConfirm: onConfirm,
    );
  }
}

// Add menu locale rimosso: ora √® gestito dallo ScaffoldWithNavigation
--- FILE: lib/features/services/presentation/dialogs/category_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service_category.dart';
import '../../../../core/utils/string_utils.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/labeled_form_field.dart';
import '../../../agenda/providers/business_providers.dart';
import '../../providers/service_categories_provider.dart';
import '../../utils/service_validators.dart';

Future<void> showCategoryDialog(
  BuildContext context,
  WidgetRef ref, {
  ServiceCategory? category,
}) async {
  final notifier = ref.read(serviceCategoriesProvider.notifier);
  final allCategories = ref.read(serviceCategoriesProvider);
  final isDesktop = ref.read(formFactorProvider) == AppFormFactor.desktop;

  final nameController = TextEditingController(text: category?.name ?? '');
  final descController = TextEditingController(
    text: category?.description ?? '',
  );

  bool nameError = false;
  bool duplicateError = false;

  Widget buildContent(void Function(VoidCallback) setState) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        LabeledFormField(
          label: context.l10n.fieldNameRequiredLabel,
          child: TextField(
            controller: nameController,
            decoration: InputDecoration(
              border: const OutlineInputBorder(),
              isDense: true,
              errorText: nameError
                  ? context.l10n.fieldNameRequiredError
                  : (duplicateError
                        ? context.l10n.categoryDuplicateError
                        : null),
            ),
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        LabeledFormField(
          label: context.l10n.fieldDescriptionLabel,
          child: TextField(
            controller: descController,
            maxLines: 3,
            decoration: const InputDecoration(
              border: OutlineInputBorder(),
              isDense: true,
            ),
          ),
        ),
      ],
    );
  }

  Future<bool> handleSave() async {
    final rawName = nameController.text.trim();
    if (rawName.isEmpty) {
      nameError = true;
      return false;
    }

    final formattedName = StringUtils.toTitleCase(rawName);

    if (ServiceValidators.isDuplicateCategoryName(
      allCategories,
      formattedName,
      excludeId: category?.id,
    )) {
      duplicateError = true;
      return false;
    }

    final newCategory = ServiceCategory(
      id: category?.id ?? DateTime.now().millisecondsSinceEpoch,
      businessId: ref.read(currentBusinessProvider).id,
      name: formattedName,
      description: descController.text.trim().isEmpty
          ? null
          : descController.text.trim(),
      sortOrder: category?.sortOrder ?? allCategories.length,
    );

    if (category == null) {
      notifier.addCategory(newCategory);
    } else {
      notifier.updateCategory(newCategory);
    }

    return true;
  }

  final title = category == null
      ? context.l10n.newCategoryTitle
      : context.l10n.editCategoryTitle;

  final builder = StatefulBuilder(
    builder: (ctx, setState) {
      final content = buildContent(setState);

      final cancelButton = SizedBox(
        width: AppButtonStyles.dialogButtonWidth,
        child: AppOutlinedActionButton(
          onPressed: () => Navigator.pop(ctx),
          padding: AppButtonStyles.dialogButtonPadding,
          child: Text(context.l10n.actionCancel),
        ),
      );

      final saveButton = SizedBox(
        width: AppButtonStyles.dialogButtonWidth,
        child: AppFilledButton(
          onPressed: () async {
            final closed = await handleSave();
            if (!closed) {
              setState(() {});
            } else {
              if (ctx.mounted) {
                Navigator.of(ctx).pop();
              }
            }
          },
          padding: AppButtonStyles.dialogButtonPadding,
          child: Text(context.l10n.actionSave),
        ),
      );

      if (isDesktop) {
        return DismissibleDialog(
          child: Dialog(
            insetPadding: const EdgeInsets.symmetric(
              horizontal: 32,
              vertical: 24,
            ),
            child: ConstrainedBox(
              constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Text(title, style: Theme.of(ctx).textTheme.headlineSmall),
                    const SizedBox(height: 16),
                    content,
                    const SizedBox(height: 24),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        cancelButton,
                        const SizedBox(width: 8),
                        saveButton,
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ),
        );
      }

      return SafeArea(
        top: false,
        child: LayoutBuilder(
          builder: (ctx, constraints) {
            final isKeyboardOpen =
                MediaQuery.of(ctx).viewInsets.bottom > 0;
            return SizedBox(
              height: constraints.maxHeight,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                Expanded(
                  child: SingleChildScrollView(
                    padding: EdgeInsets.only(
                      bottom: 0,
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Padding(
                          padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Padding(
                                padding: const EdgeInsets.only(bottom: 12),
                                child: Text(
                                  title,
                                  style: Theme.of(ctx).textTheme.titleLarge,
                                ),
                              ),
                              content,
                              const SizedBox(height: 24),
                              const SizedBox(height: AppSpacing.formRowSpacing),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                if (!isKeyboardOpen) ...[
                  const AppBottomSheetDivider(),
                  Padding(
                    padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                    child: Align(
                      alignment: 2 == 3
                          ? Alignment.center
                          : Alignment.centerRight,
                      child: Wrap(
                        alignment: 2 == 3
                            ? WrapAlignment.center
                            : WrapAlignment.end,
                        spacing: 8,
                        runSpacing: 8,
                        children: [cancelButton, saveButton],
                      ),
                    ),
                    ),
                  ],
                  SizedBox(height: MediaQuery.of(ctx).viewPadding.bottom),
                ],
              ),
            );
          },
        ),
      );
    },
  );

  if (isDesktop) {
    await showDialog(context: context, builder: (_) => builder);
  } else {
    await AppBottomSheet.show(
      context: context,
      builder: (_) => builder,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
    );
  }
}
--- FILE: lib/features/services/presentation/dialogs/service_dialog.dart ---
import 'package:agenda_backend/app/providers/form_factor_provider.dart';
import 'package:agenda_backend/app/theme/app_spacing.dart';
import 'package:agenda_backend/features/agenda/providers/business_providers.dart';
import 'package:agenda_backend/features/agenda/providers/location_providers.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_variant.dart';
import '../../../../core/utils/color_utils.dart';
import '../../../../core/utils/price_utils.dart';
import '../../../../core/utils/string_utils.dart';
import '../../../../core/widgets/app_bottom_sheet.dart';
import '../../../../core/widgets/app_buttons.dart';
import '../../../../core/widgets/app_dialogs.dart';
import '../../../../core/widgets/app_dividers.dart';
import '../../../../core/widgets/app_switch.dart';
import '../../../../core/widgets/labeled_form_field.dart';
import '../../../staff/providers/staff_providers.dart';
import '../../providers/service_categories_provider.dart';
import '../../providers/services_provider.dart';
import '../../utils/service_seed_texts.dart';
import '../../utils/service_validators.dart';

enum _AdditionalTimeSelection { none, processing, blocked }

const List<Color> _serviceColorPalette = [
  // Reds
  Color(0xFFFFCDD2),
  Color(0xFFFFC1C9),
  Color(0xFFFFB4BC),
  // Oranges
  Color(0xFFFFD6B3),
  Color(0xFFFFC9A3),
  Color(0xFFFFBD93),
  // Yellows
  Color(0xFFFFF0B3),
  Color(0xFFFFE6A3),
  Color(0xFFFFDC93),
  // Yellow-greens
  Color(0xFFEAF2B3),
  Color(0xFFDFEAA3),
  Color(0xFFD4E293),
  // Greens
  Color(0xFFCDECCF),
  Color(0xFFC1E4C4),
  Color(0xFFB6DCB9),
  // Teals
  Color(0xFFBFE8E0),
  Color(0xFFB1DFD6),
  Color(0xFFA3D6CB),
  // Cyans
  Color(0xFFBDEFF4),
  Color(0xFFB0E6EF),
  Color(0xFFA3DDEA),
  // Blues
  Color(0xFFBFD9FF),
  Color(0xFFB0CEFF),
  Color(0xFFA1C3FF),
  // Indigos
  Color(0xFFC7D0FF),
  Color(0xFFBAC4FF),
  Color(0xFFADB8FF),
  // Purples
  Color(0xFFDCC9FF),
  Color(0xFFD0BDFF),
  Color(0xFFC4B1FF),
  // Pinks
  Color(0xFFFFC7E3),
  Color(0xFFFFB7D9),
  Color(0xFFFFA8CF),
];

Color _contrastFor(Color color) {
  return color.computeLuminance() > 0.5 ? Colors.black : Colors.white;
}

class _SwitchTile extends StatelessWidget {
  const _SwitchTile({
    required this.title,
    this.subtitle,
    required this.value,
    required this.onChanged,
    this.enabled = true,
  });

  final String title;
  final String? subtitle;
  final bool value;
  final ValueChanged<bool>? onChanged;
  final bool enabled;

  @override
  Widget build(BuildContext context) {
    final textTheme = Theme.of(context).textTheme;
    final baseColor = textTheme.bodyLarge?.color;
    final titleStyle = enabled
        ? textTheme.bodyLarge
        : textTheme.bodyLarge?.copyWith(color: baseColor?.withOpacity(0.6));
    final subtitleStyle = enabled
        ? textTheme.bodyMedium
        : textTheme.bodyMedium?.copyWith(color: baseColor?.withOpacity(0.6));

    return MergeSemantics(
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: enabled && onChanged != null ? () => onChanged!(!value) : null,
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 8.0),
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(title, style: titleStyle),
                    if (subtitle != null)
                      Padding(
                        padding: const EdgeInsets.only(top: 2.0),
                        child: Text(subtitle!, style: subtitleStyle),
                      ),
                  ],
                ),
              ),
              AppSwitch(
                value: value,
                onChanged: enabled ? onChanged : null,
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _SelectableRow extends StatelessWidget {
  const _SelectableRow({
    required this.label,
    required this.selected,
    required this.onTap,
  });

  final String label;
  final bool selected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          child: Row(
            children: [
              Expanded(child: Text(label)),
              if (selected)
                Icon(
                  Icons.check,
                  color: Theme.of(context).colorScheme.primary,
                  size: 20,
                ),
            ],
          ),
        ),
      ),
    );
  }
}

Future<void> showServiceDialog(
  BuildContext context,
  WidgetRef ref, {
  Service? service,
  int? preselectedCategoryId,
  Color? preselectedColor,
  bool requireCategorySelection = false,
  bool duplicateFrom = false,
}) async {
  final notifier = ref.read(servicesProvider.notifier);
  final allServices = ref.read(servicesProvider);
  final categories = ref.read(serviceCategoriesProvider);
  final isEditing = service != null && !duplicateFrom;
  final existingVariant = service != null
      ? ref.read(serviceVariantByServiceIdProvider(service.id))
      : null;
  final currencyCode = ref.read(effectiveCurrencyProvider);
  final currencySymbol = NumberFormat.currency(
    name: currencyCode,
  ).currencySymbol;
  final isDesktop = ref.read(formFactorProvider) == AppFormFactor.desktop;
  final colorScrollController = ScrollController();
  bool didAutoScroll = false;

  String makeDuplicateName(String originalName) {
    final copyWord = ServiceSeedTexts.duplicateCopyWord;
    final copyWordEscaped = RegExp.escape(copyWord);
    String base = originalName;
    int? startFrom;

    final reNew = RegExp(
      '^(.*?)(?:\\s$copyWordEscaped(?:\\s(\\d+))?)\$',
      caseSensitive: false,
    );
    final reOld = RegExp(
      '^(.*?)(?:\\s\\((?:$copyWordEscaped)(?:\\s(\\d+))?\\))\$',
      caseSensitive: false,
    );

    final match =
        reNew.firstMatch(originalName) ?? reOld.firstMatch(originalName);
    if (match != null) {
      base = (match.group(1) ?? '').trim();
      final n = match.group(2);
      if (n != null) {
        final parsed = int.tryParse(n);
        if (parsed != null) startFrom = parsed + 1;
      } else {
        startFrom = 1;
      }
    }

    final existingNames = allServices.map((s) => s.name).toSet();
    String candidate = '$base $copyWord';
    if (!existingNames.contains(candidate)) return candidate;

    int i = startFrom ?? 1;
    while (true) {
      candidate = '$base $copyWord $i';
      if (!existingNames.contains(candidate)) return candidate;
      i++;
      if (i > 9999) break;
    }
    return '$base $copyWord';
  }

  final nameController = TextEditingController(
    text: (duplicateFrom && service != null)
        ? makeDuplicateName(service.name)
        : (service?.name ?? ''),
  );
  final priceController = TextEditingController(
    text: (existingVariant != null && existingVariant.price > 0)
        ? PriceFormatter.format(
            context: context,
            amount: existingVariant.price,
            currencyCode: existingVariant.currency ?? currencyCode,
          )
        : '',
  );
  final descController = TextEditingController(
    text: service?.description ?? '',
  );
  final staffList = ref.read(staffForCurrentLocationProvider);
  final eligibilityNotifier = ref.read(
    serviceStaffEligibilityProvider.notifier,
  );
  final locationId = ref.read(currentLocationProvider).id;
  Set<int> selectedStaffIds = service != null
      ? ref.read(eligibleStaffForServiceProvider(service.id)).toSet()
      : <int>{};
  bool isSelectingStaff = false;

  int? selectedCategory = requireCategorySelection
      ? (service?.categoryId ?? preselectedCategoryId)
      : (service?.categoryId ?? preselectedCategoryId ?? categories.first.id);
  int? selectedDuration = existingVariant?.durationMinutes;
  int selectedProcessingTime = existingVariant?.processingTime ?? 0;
  int selectedBlockedTime = existingVariant?.blockedTime ?? 0;
  final palette = <Color>[..._serviceColorPalette];
  final seen = <int>{};
  final uniquePalette = <Color>[
    for (final c in palette)
      if (seen.add(c.value)) c,
  ];
  final serviceColor = existingVariant?.colorHex != null
      ? ColorUtils.fromHex(existingVariant!.colorHex!)
      : null;
  final hasPreselectedColor =
      preselectedColor != null &&
      uniquePalette.any((c) => c.value == preselectedColor.value);
  final hasServiceColor =
      serviceColor != null &&
      uniquePalette.any((c) => c.value == serviceColor.value);
  Color selectedColor = hasServiceColor
      ? serviceColor
      : (hasPreselectedColor ? preselectedColor : uniquePalette.first);

  if (selectedProcessingTime > 0 && selectedBlockedTime > 0) {
    selectedBlockedTime = 0;
  }

  _AdditionalTimeSelection additionalSelection = selectedProcessingTime > 0
      ? _AdditionalTimeSelection.processing
      : (selectedBlockedTime > 0
            ? _AdditionalTimeSelection.blocked
            : _AdditionalTimeSelection.none);
  int additionalMinutes = selectedProcessingTime > 0
      ? selectedProcessingTime
      : selectedBlockedTime;

  bool isBookableOnline = existingVariant?.isBookableOnline ?? true;
  bool isFree = existingVariant?.isFree ?? false;
  bool isPriceStartingFrom = existingVariant?.isPriceStartingFrom ?? false;

  bool nameError = false;
  bool durationError = false;
  bool categoryError = false;

  void scrollToSelected({required bool animate}) {
    if (!colorScrollController.hasClients) return;
    final index = uniquePalette.indexWhere(
      (c) => c.value == selectedColor.value,
    );
    if (index < 0) return;
    const double colorItemSize = 36;
    const double colorItemSpacing = 10;
    const double colorListPadding = 4;
    final viewport = colorScrollController.position.viewportDimension;
    final target =
        index * (colorItemSize + colorItemSpacing) -
        (viewport - colorItemSize) / 2 -
        colorListPadding;
    final maxExtent = colorScrollController.position.maxScrollExtent;
    final clamped = target.clamp(0.0, maxExtent);
    if (animate) {
      colorScrollController.animateTo(
        clamped,
        duration: const Duration(milliseconds: 220),
        curve: Curves.easeOutCubic,
      );
    } else {
      colorScrollController.jumpTo(clamped);
    }
  }

  Future<void> handleSave() async {
    final name = nameController.text.trim();
    if (name.isEmpty) {
      nameError = true;
      return;
    }
    final normalizedName = StringUtils.toTitleCase(name);
    final isDuplicate = ServiceValidators.isDuplicateServiceName(
      allServices,
      normalizedName,
      excludeId: isEditing ? service.id : null,
    );
    if (selectedDuration == null) {
      durationError = true;
      return;
    }
    if (selectedCategory == null) {
      categoryError = true;
      return;
    }

    final parsedPrice = PriceFormatter.parse(priceController.text);
    final effectiveIsFree = isFree;
    final double? finalPrice = effectiveIsFree ? null : parsedPrice;
    final bool finalIsPriceStartingFrom =
        (effectiveIsFree || finalPrice == null) ? false : isPriceStartingFrom;

    Future<void> doSave() async {
      int processingToSave = 0;
      int blockedToSave = 0;
      if (additionalSelection == _AdditionalTimeSelection.processing &&
          additionalMinutes > 0) {
        processingToSave = additionalMinutes;
      } else if (additionalSelection == _AdditionalTimeSelection.blocked &&
          additionalMinutes > 0) {
        blockedToSave = additionalMinutes;
      }
      final newService = Service(
        id: isEditing ? service.id : DateTime.now().millisecondsSinceEpoch,
        businessId: ref.read(currentBusinessProvider).id,
        categoryId: selectedCategory!,
        name: normalizedName,
        description: descController.text.trim().isEmpty
            ? null
            : descController.text.trim(),
        sortOrder: service?.sortOrder ?? 0,
      );

      final newVariant = ServiceVariant(
        id: isEditing
            ? (existingVariant?.id ?? (900000 + newService.id))
            : (900000 + newService.id),
        serviceId: newService.id,
        locationId: ref.read(currentLocationProvider).id,
        durationMinutes: selectedDuration!,
        processingTime: processingToSave,
        blockedTime: blockedToSave,
        price: finalPrice ?? 0,
        colorHex: ColorUtils.toHex(selectedColor),
        currency: currencyCode,
        isBookableOnline: isBookableOnline,
        isFree: effectiveIsFree,
        isPriceStartingFrom: finalIsPriceStartingFrom,
        resourceRequirements: existingVariant?.resourceRequirements ?? const [],
      );

      if (!isEditing) {
        notifier.add(newService);
      } else {
        notifier.update(newService);
      }
      ref.read(serviceVariantsProvider.notifier).upsert(newVariant);
      eligibilityNotifier.setEligibleStaffForService(
        serviceId: newService.id,
        locationId: locationId,
        staffIds: selectedStaffIds,
      );

      Navigator.of(context, rootNavigator: true).pop();
    }

    if (isDuplicate) {
      await showAppConfirmDialog(
        context,
        title: Text(context.l10n.serviceDuplicateError),
        confirmLabel: context.l10n.actionConfirm,
        cancelLabel: context.l10n.actionCancel,
        danger: false,
        onConfirm: doSave,
      );
    } else {
      await doSave();
    }
  }

  Widget buildBody(BuildContext context, void Function(VoidCallback) setState) {
    Future<void> openStaffSelector() async {
      if (isSelectingStaff) return;
      setState(() => isSelectingStaff = true);
      final l10n = context.l10n;
      final formFactor = ref.read(formFactorProvider);
      Set<int> current = {...selectedStaffIds};

      Widget buildStaffRows(void Function(VoidCallback) setStateLocal) {
        final allIds = [for (final s in staffList) s.id];
        final allSelected = allIds.isNotEmpty && allIds.every(current.contains);
        return Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            _SelectableRow(
              label: l10n.teamSelectAllServices,
              selected: allSelected,
              onTap: () {
                if (allSelected) {
                  current.clear();
                } else {
                  current
                    ..clear()
                    ..addAll(allIds);
                }
                setStateLocal(() {});
              },
            ),
            const Divider(height: 1),
            for (final member in staffList)
              _SelectableRow(
                label: member.displayName,
                selected: current.contains(member.id),
                onTap: () {
                  if (current.contains(member.id)) {
                    current.remove(member.id);
                  } else {
                    current.add(member.id);
                  }
                  setStateLocal(() {});
                },
              ),
          ],
        );
      }

      Future<void> openDialog(BuildContext ctx) async {
        await showDialog<void>(
          context: ctx,
          builder: (dialogCtx) => StatefulBuilder(
            builder: (context, setStateLocal) {
              return Dialog(
                insetPadding: const EdgeInsets.symmetric(
                  horizontal: 32,
                  vertical: 24,
                ),
                child: ConstrainedBox(
                  constraints: const BoxConstraints(
                    minWidth: 520,
                    maxWidth: 680,
                    maxHeight: 520,
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.stretch,
                    children: [
                      Padding(
                        padding: const EdgeInsets.fromLTRB(20, 16, 20, 8),
                        child: Text(
                          l10n.teamEligibleStaffLabel,
                          style: Theme.of(context).textTheme.titleLarge,
                        ),
                      ),
                      const Divider(height: 1),
                      Expanded(
                        child: SingleChildScrollView(
                          child: buildStaffRows(setStateLocal),
                        ),
                      ),
                      const Divider(height: 1),
                      Padding(
                        padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                        child: Align(
                          alignment: Alignment.centerRight,
                          child: AppFilledButton(
                            onPressed: () => Navigator.of(dialogCtx).pop(),
                            padding: AppButtonStyles.dialogButtonPadding,
                            child: Text(l10n.actionConfirm),
                          ),
                        ),
                      ),
                    ],
                  ),
                ),
              );
            },
          ),
        );
      }

      Future<void> openSheet(BuildContext ctx) async {
        await AppBottomSheet.show<void>(
          context: ctx,
          heightFactor: AppBottomSheet.defaultHeightFactor,
          padding: EdgeInsets.zero,
          builder: (sheetCtx) => StatefulBuilder(
            builder: (context, setStateLocal) {
              return SafeArea(
                top: false,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 8),
                      child: Text(
                        l10n.teamEligibleStaffLabel,
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                    ),
                    const Divider(height: 1),
                    Expanded(
                      child: SingleChildScrollView(
                        child: buildStaffRows(setStateLocal),
                      ),
                    ),
                    const Divider(height: 1),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 16),
                      child: Align(
                        alignment: Alignment.centerRight,
                        child: AppFilledButton(
                          onPressed: () => Navigator.of(sheetCtx).pop(),
                          padding: AppButtonStyles.dialogButtonPadding,
                          child: Text(l10n.actionConfirm),
                        ),
                      ),
                    ),
                    SizedBox(height: MediaQuery.of(ctx).viewPadding.bottom),
                  ],
                ),
              );
            },
          ),
        );
      }

      if (formFactor == AppFormFactor.desktop) {
        await openDialog(context);
      } else {
        await openSheet(context);
      }

      setState(() {
        selectedStaffIds = {...current};
        isSelectingStaff = false;
      });
    }

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        LabeledFormField(
          label: context.l10n.fieldCategoryRequiredLabel,
          child: DropdownButtonFormField<int>(
            value: selectedCategory,
            decoration: InputDecoration(
              border: const OutlineInputBorder(),
              isDense: true,
              errorText: categoryError ? context.l10n.validationRequired : null,
            ),
            items: [
              for (final c in categories)
                DropdownMenuItem(value: c.id, child: Text(c.name)),
            ],
            onChanged: (v) => setState(() {
              selectedCategory = v;
              categoryError = false;
            }),
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        LabeledFormField(
          label: context.l10n.fieldNameRequiredLabel,
          child: TextField(
            controller: nameController,
            decoration: InputDecoration(
              border: const OutlineInputBorder(),
              isDense: true,
              errorText: nameError ? context.l10n.fieldNameRequiredError : null,
            ),
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        LabeledFormField(
          label: context.l10n.fieldDescriptionLabel,
          child: TextField(
            controller: descController,
            maxLines: 3,
            decoration: const InputDecoration(
              border: OutlineInputBorder(),
              isDense: true,
            ),
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        AppOutlinedActionButton(
          onPressed: openStaffSelector,
          expand: true,
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
          child: Row(
            children: [
              Expanded(
                child: Align(
                  alignment: Alignment.centerLeft,
                  child: Text(context.l10n.teamEligibleStaffLabel),
                ),
              ),
              Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 10,
                  vertical: 4,
                ),
                decoration: BoxDecoration(
                  color: Theme.of(
                    context,
                  ).colorScheme.primary.withOpacity(0.12),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Text(
                  '${selectedStaffIds.length}/${staffList.length}',
                  style: Theme.of(context).textTheme.labelSmall?.copyWith(
                    color: Theme.of(context).colorScheme.primary,
                    fontWeight: FontWeight.w600,
                  ),
                ),
              ),
            ],
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        LabeledFormField(
          label: context.l10n.serviceColorLabel,
          child: SizedBox(
            height: 44,
            child: Row(
              children: [
                Expanded(
                  child: ShaderMask(
                    shaderCallback: (rect) {
                      return const LinearGradient(
                        begin: Alignment.centerLeft,
                        end: Alignment.centerRight,
                        colors: [
                          Colors.transparent,
                          Colors.black,
                          Colors.black,
                          Colors.transparent,
                        ],
                        stops: [0.0, 0.01, 0.99, 1.0],
                      ).createShader(rect);
                    },
                    blendMode: BlendMode.dstIn,
                    child: ScrollConfiguration(
                      behavior: const ScrollBehavior().copyWith(
                        dragDevices: {
                          PointerDeviceKind.touch,
                          PointerDeviceKind.mouse,
                          PointerDeviceKind.trackpad,
                        },
                      ),
                      child: ListView.separated(
                        controller: colorScrollController,
                        padding: const EdgeInsets.symmetric(horizontal: 4),
                        scrollDirection: Axis.horizontal,
                        physics: const BouncingScrollPhysics(),
                        itemCount: uniquePalette.length,
                        separatorBuilder: (_, __) => const SizedBox(width: 10),
                        itemBuilder: (context, index) {
                          final color = uniquePalette[index];
                          return GestureDetector(
                            onTap: () => setState(() {
                              selectedColor = color;
                            }),
                            child: AnimatedContainer(
                              duration: const Duration(milliseconds: 150),
                              width: 36,
                              height: 36,
                              decoration: BoxDecoration(
                                color: color,
                                shape: BoxShape.circle,
                                border: Border.all(
                                  color: selectedColor.value == color.value
                                      ? Theme.of(context).colorScheme.onSurface
                                      : Colors.black.withOpacity(0.08),
                                  width: selectedColor.value == color.value
                                      ? 2
                                      : 1,
                                ),
                                boxShadow: [
                                  BoxShadow(
                                    color: Colors.black.withOpacity(0.08),
                                    blurRadius: 4,
                                    offset: const Offset(0, 2),
                                  ),
                                ],
                              ),
                              child: selectedColor.value == color.value
                                  ? Icon(
                                      Icons.check,
                                      color: _contrastFor(color),
                                      size: 18,
                                    )
                                  : null,
                            ),
                          );
                        },
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: AppSpacing.medium),
        Align(
          alignment: Alignment.center,
          child: ConstrainedBox(
            constraints: const BoxConstraints(maxWidth: 300),
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6),
              decoration: BoxDecoration(
                color: selectedColor,
                borderRadius: BorderRadius.circular(10),
              ),
              child: DefaultTextStyle(
                style: const TextStyle(
                  color: Colors.black87,
                  fontWeight: FontWeight.w600,
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      '09:00 - 10:00  ${context.l10n.formClient}',
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                    const SizedBox(height: 2),
                    Text(
                      nameController.text.trim().isEmpty
                          ? context.l10n.formService
                          : nameController.text.trim(),
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                      style: const TextStyle(
                        color: Colors.black54,
                        fontWeight: FontWeight.w500,
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        LabeledFormField(
          label: context.l10n.fieldDurationRequiredLabel,
          child: DropdownButtonFormField<int>(
            value: selectedDuration,
            decoration: InputDecoration(
              border: const OutlineInputBorder(),
              isDense: true,
              errorText: durationError
                  ? context.l10n.fieldDurationRequiredError
                  : null,
            ),
            items: [
              for (final (minutes, label) in _durationOptions(context))
                DropdownMenuItem(value: minutes, child: Text(label)),
            ],
            onChanged: (v) => setState(() {
              selectedDuration = v;
              durationError = false;
              if ((selectedDuration ?? 0) <= 0) {
                additionalSelection = _AdditionalTimeSelection.none;
                additionalMinutes = 0;
              }
            }),
          ),
        ),
        if ((selectedDuration ?? 0) > 0) ...[
          const SizedBox(height: AppSpacing.formRowSpacing),
          LabeledFormField(
            label: context.l10n.additionalTimeSwitch,
            child: DropdownButtonFormField<_AdditionalTimeSelection>(
              value: additionalSelection == _AdditionalTimeSelection.none
                  ? null
                  : additionalSelection,
              decoration: const InputDecoration(
                border: OutlineInputBorder(),
                isDense: true,
              ),
              hint: const Text(''),
              items: [
                DropdownMenuItem(
                  value: _AdditionalTimeSelection.none,
                  child: const Text(''),
                ),
                DropdownMenuItem(
                  value: _AdditionalTimeSelection.processing,
                  child: Text(context.l10n.additionalTimeOptionProcessing),
                ),
                DropdownMenuItem(
                  value: _AdditionalTimeSelection.blocked,
                  child: Text(context.l10n.additionalTimeOptionBlocked),
                ),
              ],
              onChanged: (sel) => setState(() {
                additionalSelection = sel ?? _AdditionalTimeSelection.none;
                if (additionalSelection == _AdditionalTimeSelection.none) {
                  additionalMinutes = 0;
                }
              }),
            ),
          ),
          if (additionalSelection != _AdditionalTimeSelection.none) ...[
            const SizedBox(height: AppSpacing.formRowSpacing),
            LabeledFormField(
              label:
                  (additionalSelection == _AdditionalTimeSelection.processing)
                  ? context.l10n.fieldProcessingTimeLabel
                  : context.l10n.fieldBlockedTimeLabel,
              child: DropdownButtonFormField<int>(
                value: additionalMinutes,
                decoration: const InputDecoration(
                  border: OutlineInputBorder(),
                  isDense: true,
                ),
                items: [
                  for (final (minutes, label) in _bufferOptions(context))
                    DropdownMenuItem(value: minutes, child: Text(label)),
                ],
                onChanged: (v) => setState(() {
                  additionalMinutes = v ?? 0;
                }),
              ),
            ),
          ],
        ],
        const SizedBox(height: AppSpacing.formRowSpacing),
        LabeledFormField(
          label: context.l10n.fieldPriceLabel,
          child: TextField(
            controller: priceController,
            keyboardType: const TextInputType.numberWithOptions(decimal: true),
            inputFormatters: [
              FilteringTextInputFormatter.allow(RegExp(r'[0-9.,\-]')),
            ],
            decoration: InputDecoration(
              border: const OutlineInputBorder(),
              isDense: true,
              prefixText: '$currencySymbol ',
            ),
            enabled: !isFree,
            onChanged: (_) {
              if (priceController.text.trim().isEmpty && isPriceStartingFrom) {
                setState(() => isPriceStartingFrom = false);
              }
            },
          ),
        ),
        const SizedBox(height: AppSpacing.formRowSpacing),
        _SwitchTile(
          title: context.l10n.freeServiceSwitch,
          value: isFree,
          onChanged: (v) {
            setState(() {
              isFree = v;
              if (isFree) {
                priceController.clear();
                isPriceStartingFrom = false;
              }
            });
          },
        ),
        _SwitchTile(
          title: context.l10n.priceStartingFromSwitch,
          subtitle: (isFree || priceController.text.trim().isEmpty)
              ? context.l10n.setPriceToEnable
              : null,
          value: isPriceStartingFrom,
          onChanged: (!isFree && priceController.text.trim().isNotEmpty)
              ? (v) => setState(() => isPriceStartingFrom = v)
              : null,
          enabled: (!isFree && priceController.text.trim().isNotEmpty),
        ),
        const SizedBox(height: 40),
        _SwitchTile(
          title: context.l10n.bookableOnlineSwitch,
          value: isBookableOnline,
          onChanged: (v) => setState(() => isBookableOnline = v),
        ),
      ],
    );
  }

  final dialogTitle = !isEditing
      ? context.l10n.newServiceTitle
      : context.l10n.editServiceTitle;

  final builder = StatefulBuilder(
    builder: (context, setState) {
      if (!didAutoScroll) {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          scrollToSelected(animate: false);
        });
        didAutoScroll = true;
      }
      final body = buildBody(context, setState);

      final cancelButton = SizedBox(
        width: AppButtonStyles.dialogButtonWidth,
        child: AppOutlinedActionButton(
          onPressed: () => Navigator.of(context, rootNavigator: true).pop(),
          padding: AppButtonStyles.dialogButtonPadding,
          child: Text(context.l10n.actionCancel),
        ),
      );

      final saveButton = SizedBox(
        width: AppButtonStyles.dialogButtonWidth,
        child: AppFilledButton(
          onPressed: () async {
            await handleSave();
            setState(() {});
          },
          padding: AppButtonStyles.dialogButtonPadding,
          child: Text(context.l10n.actionSave),
        ),
      );
      final bottomActions = [cancelButton, saveButton];

      if (isDesktop) {
        return DismissibleDialog(
          child: Dialog(
            insetPadding: const EdgeInsets.symmetric(
              horizontal: 32,
              vertical: 24,
            ),
            child: ConstrainedBox(
              constraints: const BoxConstraints(minWidth: 600, maxWidth: 720),
              child: Padding(
                padding: const EdgeInsets.all(20),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    Text(
                      dialogTitle,
                      style: Theme.of(context).textTheme.headlineSmall,
                    ),
                    const SizedBox(height: 16),
                    Flexible(child: SingleChildScrollView(child: body)),
                    const SizedBox(height: 24),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        cancelButton,
                        const SizedBox(width: 8),
                        saveButton,
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ),
        );
      }

      return SafeArea(
        top: false,
        child: LayoutBuilder(
        builder: (context, constraints) {
          final isKeyboardOpen =
              MediaQuery.of(context).viewInsets.bottom > 0;
          return SizedBox(
            height: constraints.maxHeight,
            child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                Expanded(
                  child: SingleChildScrollView(
                    padding: EdgeInsets.zero,
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Padding(
                          padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Padding(
                                padding: const EdgeInsets.only(bottom: 12),
                                child: Text(
                                  dialogTitle,
                                  style: Theme.of(context).textTheme.titleLarge,
                                ),
                              ),
                              body,
                              const SizedBox(height: 24),
                              const SizedBox(height: AppSpacing.formRowSpacing),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
                  if (!isKeyboardOpen) ...[
                    const AppBottomSheetDivider(),
                    Padding(
                      padding: const EdgeInsets.fromLTRB(16, 12, 16, 0),
                      child: Align(
                        alignment: bottomActions.length == 3
                            ? Alignment.center
                            : Alignment.centerRight,
                        child: Wrap(
                          alignment: bottomActions.length == 3
                              ? WrapAlignment.center
                              : WrapAlignment.end,
                          spacing: 8,
                          runSpacing: 8,
                          children: bottomActions,
                        ),
                      ),
                    ),
                  ],
                  SizedBox(height: MediaQuery.of(context).viewPadding.bottom),
                ],
              ),
            );
          },
        ),
      );
    },
  );

  if (isDesktop) {
    await showDialog(
      context: context,
      barrierDismissible: true,
      builder: (_) => builder,
    );
  } else {
    await AppBottomSheet.show(
      context: context,
      builder: (_) => builder,
      useRootNavigator: true,
      padding: EdgeInsets.zero,
    );
  }
}

List<(int, String)> _durationOptions(BuildContext context) {
  final List<(int, String)> options = [];
  for (int i = 5; i <= 240; i += 5) {
    options.add((i, context.localizedDurationLabel(i)));
  }
  return options;
}

List<(int, String)> _bufferOptions(BuildContext context) {
  final List<(int, String)> options = [];
  final steps = <int>[0, 5, 10, 15, 20, 30, 45, 60];
  for (final m in steps) {
    options.add((m, context.localizedDurationLabel(m)));
  }
  return options;
}
--- FILE: lib/features/services/presentation/widgets/category_item.dart ---
import 'package:flutter/material.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';
import 'empty_state.dart';
import 'services_list.dart';

/// Item che rappresenta la card di una singola categoria (header + servizi).
class CategoryItem extends StatelessWidget {
  final ServiceCategory category;
  final List<Service> services;
  final bool isWide;
  final ColorScheme colorScheme;
  final ValueNotifier<int?> hoveredService;
  final ValueNotifier<int?> selectedService;
  final VoidCallback onAddService;
  final VoidCallback onEditCategory;
  final VoidCallback onDeleteCategory;
  final VoidCallback onDeleteBlocked;
  final ValueChanged<Service> onServiceOpen;
  final ValueChanged<Service> onServiceEdit;
  final ValueChanged<Service> onServiceDuplicate;
  final ValueChanged<int> onServiceDelete;
  final bool addTopSpacing;

  const CategoryItem({
    super.key,
    required this.category,
    required this.services,
    required this.isWide,
    required this.colorScheme,
    required this.hoveredService,
    required this.selectedService,
    required this.onAddService,
    required this.onEditCategory,
    required this.onDeleteCategory,
    required this.onDeleteBlocked,
    required this.onServiceOpen,
    required this.onServiceEdit,
    required this.onServiceDuplicate,
    required this.onServiceDelete,
    required this.addTopSpacing,
  });

  @override
  Widget build(BuildContext context) {
    final isEmptyCategory = services.isEmpty;
    return Container(
      margin: EdgeInsets.only(
        top: addTopSpacing ? 32 : 0,
        bottom: 24,
      ),
      decoration: BoxDecoration(
        color: colorScheme.surface,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.05),
            blurRadius: 6,
            offset: const Offset(0, 3),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header categoria
          Container(
            width: double.infinity,
            decoration: BoxDecoration(
              color: colorScheme.primaryContainer,
              borderRadius: const BorderRadius.vertical(
                top: Radius.circular(16),
              ),
            ),
            padding: const EdgeInsets.symmetric(
              horizontal: 18,
              vertical: 14,
            ),
            child: Row(
              children: [
                // Titolo + descrizione
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        category.name,
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                        style: Theme.of(context).textTheme.titleMedium?.copyWith(
                              fontWeight: FontWeight.w600,
                              color: colorScheme.onPrimaryContainer,
                            ),
                      ),
                      if (category.description != null)
                        Padding(
                          padding: const EdgeInsets.only(top: 4),
                          child: Text(
                            category.description!,
                            maxLines: 2,
                            overflow: TextOverflow.ellipsis,
                            style: Theme.of(context)
                                .textTheme
                                .bodySmall
                                ?.copyWith(
                                  color: colorScheme.onPrimaryContainer
                                      .withOpacity(0.8),
                                ),
                          ),
                        ),
                    ],
                  ),
                ),
                const SizedBox(width: 12),

                // Pulsanti azione (solo in vista normale)
                Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    IconButton(
                      tooltip: context.l10n.addServiceTooltip,
                      icon: Icon(
                        Icons.add,
                        color: colorScheme.onPrimaryContainer,
                      ),
                      onPressed: onAddService,
                    ),
                    IconButton(
                      tooltip: context.l10n.actionEdit,
                      icon: Icon(
                        Icons.edit_outlined,
                        color: colorScheme.onPrimaryContainer,
                      ),
                      onPressed: onEditCategory,
                    ),
                    if (isEmptyCategory)
                      IconButton(
                        tooltip: context.l10n.actionDelete,
                        icon: const Icon(Icons.delete_outline),
                        color: colorScheme.onPrimaryContainer,
                        onPressed: onDeleteCategory,
                      ),
                  ],
                ),
              ],
            ),
          ),

          // Body: lista servizi o stato vuoto
          ClipRRect(
            borderRadius: const BorderRadius.vertical(
              bottom: Radius.circular(16),
            ),
            child: isEmptyCategory
                ? ServicesEmptyState(message: context.l10n.noServicesInCategory)
                : ServicesList(
                    services: services,
                    isWide: isWide,
                    colorScheme: colorScheme,
                    hoveredService: hoveredService,
                    selectedService: selectedService,
                    onOpen: onServiceOpen,
                    onEdit: onServiceEdit,
                    onDuplicate: onServiceDuplicate,
                    onDelete: onServiceDelete,
                  ),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/service_item.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../app/theme/extensions.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/utils/color_utils.dart';
import '../../../../core/utils/price_utils.dart';
import '../../providers/services_provider.dart';

class ServiceItem extends ConsumerWidget {
  final Service service;
  final bool isLast;
  final bool isEvenRow;
  final bool isHovered;
  final bool isSelected;
  final bool isWide;
  final ColorScheme colorScheme;
  final VoidCallback onTap;
  final VoidCallback onEnter;
  final VoidCallback onExit;
  final VoidCallback onEdit;
  final VoidCallback onDuplicate;
  final VoidCallback onDelete;

  const ServiceItem({
    super.key,
    required this.service,
    required this.isLast,
    required this.isEvenRow,
    required this.isHovered,
    required this.isSelected,
    required this.isWide,
    required this.colorScheme,
    required this.onTap,
    required this.onEnter,
    required this.onExit,
    required this.onEdit,
    required this.onDuplicate,
    required this.onDelete,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final interactionColors = Theme.of(
      context,
    ).extension<AppInteractionColors>();
    final variant = ref.watch(serviceVariantByServiceIdProvider(service.id));
    final eligibleStaffIds =
        ref.watch(eligibleStaffForServiceProvider(service.id));
    final eligibleStaffCount = eligibleStaffIds.length;
    final baseColor = isEvenRow
        ? (interactionColors?.alternatingRowFill ??
              colorScheme.onSurface.withOpacity(0.04))
        : Colors.transparent;

    final hoverFill = interactionColors?.hoverFill ??
        colorScheme.primaryContainer.withOpacity(0.1);
    final bgColor = (isHovered || isSelected) ? hoverFill : baseColor;

    final durationMinutes = variant?.durationMinutes;
    final extraMinutes =
        (variant?.processingTime ?? 0) + (variant?.blockedTime ?? 0);
    final totalMinutes = (durationMinutes ?? 0) + extraMinutes;
    final durationLabel = durationMinutes != null
        ? context.localizedDurationLabel(
            extraMinutes > 0 ? totalMinutes : durationMinutes,
          )
        : null;

    return MouseRegion(
      cursor: SystemMouseCursors.click,
      onEnter: (_) => onEnter(),
      onExit: (_) => onExit(),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: onTap,
          borderRadius: BorderRadius.only(
            bottomLeft: isLast ? const Radius.circular(16) : Radius.zero,
            bottomRight: isLast ? const Radius.circular(16) : Radius.zero,
          ),
          child: Container(
            decoration: BoxDecoration(
              color: bgColor,
              borderRadius: BorderRadius.only(
                bottomLeft: isLast ? const Radius.circular(16) : Radius.zero,
                bottomRight: isLast ? const Radius.circular(16) : Radius.zero,
              ),
            ),
            child: IntrinsicHeight(
              child: Row(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Container(
                    width: 4,
                    decoration: BoxDecoration(
                      color: variant?.colorHex != null
                          ? ColorUtils.fromHex(variant!.colorHex!)
                          : colorScheme.primary,
                      borderRadius: BorderRadius.only(
                        bottomLeft: isLast
                            ? const Radius.circular(16)
                            : Radius.zero,
                      ),
                    ),
                  ),
                  Expanded(
                    child: ListTile(
                      contentPadding: const EdgeInsets.fromLTRB(16, 2, 16, 16),
                      mouseCursor: SystemMouseCursors.click,
                      title: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            service.name,
                            style: Theme.of(context).textTheme.titleMedium
                                ?.copyWith(fontWeight: FontWeight.w500),
                          ),
                          if (eligibleStaffCount == 0) ...[
                            const SizedBox(height: 2),
                            Text(
                              context.l10n.serviceEligibleStaffNone,
                              style: Theme.of(context)
                                  .textTheme
                                  .bodySmall
                                  ?.copyWith(
                                    color: Theme.of(context).colorScheme.error,
                                    fontStyle: FontStyle.italic,
                                  ),
                            ),
                          ],
                          if (durationLabel != null ||
                              variant?.price != null ||
                              (variant?.isFree ?? false))
                            Padding(
                              padding: const EdgeInsets.only(top: 4),
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  if (durationLabel != null)
                                    Text(
                                      durationLabel,
                                      style: const TextStyle(
                                        fontSize: 11,
                                        color: Colors.black54,
                                        height: 1.1,
                                      ),
                                    ),
                                  if (durationLabel != null &&
                                      (variant?.price != null ||
                                          (variant?.isFree ?? false)))
                                    const SizedBox(width: 8),
                                  if (variant?.isFree ?? false)
                                    Text(
                                      context.l10n.freeLabel,
                                      style: const TextStyle(
                                        fontSize: 11,
                                        color: Colors.black54,
                                        height: 1.1,
                                      ),
                                    )
                                  else if (variant?.price != null)
                                    Text(
                                      PriceFormatter.formatVariant(
                                        context: context,
                                        ref: ref,
                                        variant: variant!,
                                      ),
                                      style: const TextStyle(
                                        fontSize: 11,
                                        color: Colors.black54,
                                        height: 1.1,
                                      ),
                                    ),
                                ],
                              ),
                            ),
                          if (!(variant?.isBookableOnline ?? true))
                            Padding(
                              padding: const EdgeInsets.only(top: 2),
                              child: Text(
                                context.l10n.notBookableOnline,
                                style: Theme.of(context).textTheme.bodySmall
                                    ?.copyWith(
                                      color: Colors.red[600],
                                      fontStyle: FontStyle.italic,
                                    ),
                              ),
                            ),
                        ],
                      ),
                      trailing: UnconstrainedBox(
                        alignment: Alignment.centerRight,
                        child: isWide
                            ? _buildActionIcons(context)
                            : _buildPopupMenu(),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildActionIcons(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        IconButton(
          tooltip: context.l10n.actionEdit,
          icon: const Icon(Icons.edit_outlined),
          onPressed: onEdit,
        ),
        IconButton(
          tooltip: context.l10n.duplicateAction,
          icon: const Icon(Icons.copy_outlined),
          onPressed: onDuplicate,
        ),
        IconButton(
          tooltip: context.l10n.actionDelete,
          icon: const Icon(Icons.delete_outline, color: Colors.red),
          onPressed: onDelete,
        ),
      ],
    );
  }

  Widget _buildPopupMenu() {
    return PopupMenuButton<String>(
      onSelected: (value) {
        switch (value) {
          case 'edit':
            onEdit();
            break;
          case 'duplicate':
            onDuplicate();
            break;
          case 'delete':
            onDelete();
            break;
        }
      },
      itemBuilder: (context) => [
        PopupMenuItem(value: 'edit', child: Text(context.l10n.actionEdit)),
        PopupMenuItem(
          value: 'duplicate',
          child: Text(context.l10n.duplicateAction),
        ),
        PopupMenuItem(value: 'delete', child: Text(context.l10n.actionDelete)),
      ],
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/service_eligibility_selector.dart ---
import 'package:flutter/material.dart';

import '../../../../app/theme/extensions.dart';
import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';

class ServiceEligibilitySelector extends StatelessWidget {
  const ServiceEligibilitySelector({
    super.key,
    required this.services,
    required this.categories,
    required this.selectedServiceIds,
    required this.onChanged,
    this.showSelectAll = true,
  });

  final List<Service> services;
  final List<ServiceCategory> categories;
  final Set<int> selectedServiceIds;
  final ValueChanged<Set<int>> onChanged;
  final bool showSelectAll;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final l10n = context.l10n;

    final servicesByCategory = <int, List<Service>>{};
    for (final service in services) {
      (servicesByCategory[service.categoryId] ??= []).add(service);
    }

    final hasServicesMap = <int, bool>{
      for (final category in categories)
        category.id: (servicesByCategory[category.id]?.isNotEmpty ?? false),
    };

    final sortedCategories = [...categories]
      ..sort((a, b) {
        final aEmpty = !(hasServicesMap[a.id] ?? false);
        final bEmpty = !(hasServicesMap[b.id] ?? false);
        if (aEmpty != bEmpty) return aEmpty ? 1 : -1;
        final so = a.sortOrder.compareTo(b.sortOrder);
        return so != 0
            ? so
            : a.name.toLowerCase().compareTo(b.name.toLowerCase());
      });

    final allServiceIds = [
      for (final service in services) service.id,
    ];
    final isAllSelected =
        allServiceIds.isNotEmpty &&
        allServiceIds.every(selectedServiceIds.contains);

    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        if (showSelectAll)
          _SelectableRow(
            label: l10n.teamSelectAllServices,
            selected: isAllSelected,
            onTap: () {
              if (isAllSelected) {
                onChanged(<int>{});
              } else {
                onChanged(allServiceIds.toSet());
              }
            },
          ),
        if (showSelectAll) const Divider(height: 1),
        for (final category in sortedCategories)
          if ((servicesByCategory[category.id] ?? const <Service>[]).isNotEmpty)
            ...[
              _CategoryHeader(
                category: category,
                selectedIds: selectedServiceIds,
                services: servicesByCategory[category.id]!,
                onChanged: onChanged,
              ),
              for (int i = 0; i < servicesByCategory[category.id]!.length; i++)
                _ServiceRow(
                  service: servicesByCategory[category.id]![i],
                  isEven: i.isEven,
                  selectedIds: selectedServiceIds,
                  onChanged: onChanged,
                  evenBackgroundColor: theme
                          .extension<AppInteractionColors>()
                          ?.alternatingRowFill ??
                      theme.colorScheme.onSurface.withOpacity(0.04),
                ),
            ],
      ],
    );
  }
}

class _SelectableRow extends StatelessWidget {
  const _SelectableRow({
    required this.label,
    required this.selected,
    required this.onTap,
  });

  final String label;
  final bool selected;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          child: Row(
            children: [
              Expanded(child: Text(label)),
              if (selected)
                Icon(
                  Icons.check,
                  color: Theme.of(context).colorScheme.primary,
                  size: 20,
                ),
            ],
          ),
        ),
      ),
    );
  }
}

class _CategoryHeader extends StatelessWidget {
  const _CategoryHeader({
    required this.category,
    required this.services,
    required this.selectedIds,
    required this.onChanged,
  });

  final ServiceCategory category;
  final List<Service> services;
  final Set<int> selectedIds;
  final ValueChanged<Set<int>> onChanged;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final serviceIds = services.map((s) => s.id).toList();
    final isSelected =
        serviceIds.isNotEmpty && serviceIds.every(selectedIds.contains);

    return Material(
      color: theme.colorScheme.primary,
      child: InkWell(
        onTap: () {
          if (serviceIds.isEmpty) return;
          final updated = {...selectedIds};
          if (isSelected) {
            updated.removeWhere(serviceIds.contains);
          } else {
            updated.addAll(serviceIds);
          }
          onChanged(updated);
        },
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 20),
          child: Row(
            children: [
              Expanded(
                child: Text(
                  category.name.toUpperCase(),
                  style: theme.textTheme.labelMedium?.copyWith(
                    color: theme.colorScheme.onPrimary,
                    fontWeight: FontWeight.bold,
                    letterSpacing: 0.5,
                  ),
                ),
              ),
              if (serviceIds.isNotEmpty)
                Icon(
                  isSelected ? Icons.check_box : Icons.check_box_outline_blank,
                  color: theme.colorScheme.onPrimary,
                  size: 18,
                ),
            ],
          ),
        ),
      ),
    );
  }
}

class _ServiceRow extends StatelessWidget {
  const _ServiceRow({
    required this.service,
    required this.isEven,
    required this.selectedIds,
    required this.onChanged,
    required this.evenBackgroundColor,
  });

  final Service service;
  final bool isEven;
  final Set<int> selectedIds;
  final ValueChanged<Set<int>> onChanged;
  final Color evenBackgroundColor;

  @override
  Widget build(BuildContext context) {
    final isSelected = selectedIds.contains(service.id);
    return Material(
      color: isEven ? evenBackgroundColor : Colors.transparent,
      child: InkWell(
        onTap: () {
          final updated = {...selectedIds};
          if (isSelected) {
            updated.remove(service.id);
          } else {
            updated.add(service.id);
          }
          onChanged(updated);
        },
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          child: Row(
            children: [
              Expanded(child: Text(service.name)),
              if (isSelected)
                Icon(
                  Icons.check,
                  color: Theme.of(context).colorScheme.primary,
                  size: 20,
                ),
            ],
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/services_list.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/models/service.dart';
import 'service_item.dart';

class ServicesList extends ConsumerWidget {
  final List<Service> services;
  final bool isWide;
  final ColorScheme colorScheme;
  final ValueNotifier<int?> hoveredService;
  final ValueNotifier<int?> selectedService;
  final void Function(Service) onOpen;
  final void Function(Service) onEdit;
  final void Function(Service) onDuplicate;
  final void Function(int id) onDelete;

  const ServicesList({
    super.key,
    required this.services,
    required this.isWide,
    required this.colorScheme,
    required this.hoveredService,
    required this.selectedService,
    required this.onOpen,
    required this.onEdit,
    required this.onDuplicate,
    required this.onDelete,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ValueListenableBuilder<int?>(
      valueListenable: hoveredService,
      builder: (context, hoveredId, _) {
        return ValueListenableBuilder<int?>(
          valueListenable: selectedService,
          builder: (context, selectedId, __) {
            return Column(
              children: [
                for (int i = 0; i < services.length; i++)
                  ServiceItem(
                    service: services[i],
                    isLast: i == services.length - 1,
                    isEvenRow: i.isEven,
                    isHovered: hoveredId == services[i].id,
                    isSelected: selectedId == services[i].id,
                    isWide: isWide,
                    colorScheme: colorScheme,
                    onTap: () {
                      selectedService.value = services[i].id;
                      onOpen(services[i]);
                    },
                    onEnter: () => hoveredService.value = services[i].id,
                    onExit: () => hoveredService.value = null,
                    onEdit: () => onEdit(services[i]),
                    onDuplicate: () => onDuplicate(services[i]),
                    onDelete: () => onDelete(services[i].id),
                  ),
                if (services.isNotEmpty)
                  Divider(
                    color: Colors.grey.withOpacity(0.2),
                    height: 1,
                    thickness: 1,
                  ),
              ],
            );
          },
        );
      },
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/empty_state.dart ---
import 'package:flutter/material.dart';

/// Widget riutilizzabile per i casi in cui una categoria non contiene servizi.
class ServicesEmptyState extends StatelessWidget {
  final String message;

  const ServicesEmptyState({
    super.key,
    required this.message,
  });

  @override
  Widget build(BuildContext context) {
    final textStyle = Theme.of(context).textTheme.bodyMedium;

    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            Icons.inbox_outlined,
            color: Theme.of(context).colorScheme.onSurface.withOpacity(0.6),
          ),
          const SizedBox(width: 8),
          Flexible(
            child: Text(
              message,
              textAlign: TextAlign.center,
              style: textStyle?.copyWith(
                color: textStyle.color?.withOpacity(0.7),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/categories_list.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/models/service.dart';
import '../../../../core/models/service_category.dart';
import '../../providers/services_sorted_providers.dart';
import 'category_item.dart';

/// Lista dei pannelli categoria aggiornata per la vista normale.
class CategoriesList extends ConsumerWidget {
  final List<ServiceCategory> categories;
  final bool isWide;
  final ColorScheme colorScheme;
  final ValueNotifier<int?> hoveredService;
  final ValueNotifier<int?> selectedService;
  final ValueChanged<ServiceCategory> onAddService;
  final ValueChanged<ServiceCategory> onEditCategory;
  final ValueChanged<int> onDeleteCategory;
  final VoidCallback onDeleteCategoryBlocked;
  final ValueChanged<Service> onServiceOpen;
  final ValueChanged<Service> onServiceEdit;
  final ValueChanged<Service> onServiceDuplicate;
  final ValueChanged<int> onServiceDelete;
  final ScrollController scrollController;

  const CategoriesList({
    super.key,
    required this.categories,
    required this.isWide,
    required this.colorScheme,
    required this.hoveredService,
    required this.selectedService,
    required this.onAddService,
    required this.onEditCategory,
    required this.onDeleteCategory,
    required this.onDeleteCategoryBlocked,
    required this.onServiceOpen,
    required this.onServiceEdit,
    required this.onServiceDuplicate,
    required this.onServiceDelete,
    required this.scrollController,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return ListView.builder(
      controller: scrollController,
      padding: const EdgeInsets.fromLTRB(16, 0, 16, 100),
      itemCount: categories.length,
      itemBuilder: (context, index) {
        final category = categories[index];
        final services = ref.watch(
          sortedServicesByCategoryProvider(category.id),
        );
        final hasPrev = index > 0;
        final prevIsNonEmpty = hasPrev
            ? ref
                  .watch(
                    sortedServicesByCategoryProvider(categories[index - 1].id),
                  )
                  .isNotEmpty
            : false;
        final isFirstEmptyAfterNonEmpty =
            services.isEmpty && (!hasPrev || prevIsNonEmpty);

        return AnimatedSwitcher(
          duration: const Duration(milliseconds: 300),
          switchInCurve: Curves.easeInOut,
          switchOutCurve: Curves.easeInOut,
          layoutBuilder: (currentChild, previousChildren) => Stack(
            alignment: Alignment.topCenter,
            children: [
              ...previousChildren,
              if (currentChild != null) currentChild,
            ],
          ),
          transitionBuilder: (child, animation) => FadeTransition(
            opacity: animation,
            child: SizeTransition(
              sizeFactor: animation,
              axisAlignment: -1.0,
              child: child,
            ),
          ),
          child: KeyedSubtree(
            key: ValueKey(
              'cat-${category.id}-${services.isEmpty ? 'empty' : 'full'}',
            ),
            child: CategoryItem(
              category: category,
              services: services,
              isWide: isWide,
              colorScheme: colorScheme,
              hoveredService: hoveredService,
              selectedService: selectedService,
              onAddService: () => onAddService(category),
              onEditCategory: () => onEditCategory(category),
              onDeleteCategory: () => onDeleteCategory(category.id),
              onDeleteBlocked: onDeleteCategoryBlocked,
              onServiceOpen: onServiceOpen,
              onServiceEdit: onServiceEdit,
              onServiceDuplicate: onServiceDuplicate,
              onServiceDelete: onServiceDelete,
              addTopSpacing: isFirstEmptyAfterNonEmpty,
            ),
          ),
        );
      },
    );
  }
}
--- FILE: lib/features/services/presentation/widgets/category_tile.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../core/l10n/l10_extension.dart';
import '../../../../core/models/service_category.dart';
import '../../providers/service_categories_provider.dart';

class CategoryTile extends ConsumerWidget {
  const CategoryTile({super.key, required this.category, this.onEdit});

  final ServiceCategory category;
  final VoidCallback? onEdit;

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    return InkWell(
      onTap: onEdit,
      borderRadius: BorderRadius.circular(12),
      child: Container(
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: theme.cardColor,
          borderRadius: BorderRadius.circular(12),
          border: Border.all(color: theme.dividerColor.withOpacity(0.4)),
        ),
        child: Row(
          children: [
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(category.name, style: theme.textTheme.titleMedium),
                  if (category.description != null && category.description!.isNotEmpty)
                    Padding(
                      padding: const EdgeInsets.only(top: 4),
                      child: Text(
                        category.description!,
                        style: theme.textTheme.bodySmall,
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                ],
              ),
            ),
            IconButton(
              tooltip: context.l10n.actionEdit,
              icon: const Icon(Icons.edit_outlined),
              onPressed: onEdit,
            ),
            IconButton(
              tooltip: context.l10n.actionDelete,
              icon: const Icon(Icons.delete_outline, color: Colors.redAccent),
              onPressed: () => _confirmDelete(context, ref),
            ),
          ],
        ),
      ),
    );
  }

  void _confirmDelete(BuildContext context, WidgetRef ref) {
    showDialog(
      context: context,
      builder: (_) => AlertDialog(
        title: Text(context.l10n.deleteConfirmationTitle),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: Text(context.l10n.actionCancel),
          ),
          FilledButton(
            onPressed: () {
              ref.read(serviceCategoriesProvider.notifier).deleteCategory(category.id);
              Navigator.of(context).pop();
            },
            child: Text(context.l10n.actionDelete),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/main.dart ---
import 'package:agenda_backend/app/app.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  runApp(const ProviderScope(child: MyApp()));
}
--- FILE: pubspec.yaml ---
name: agenda_backend
description: "A new Flutter project."
publish_to: 'none'
version: 1.0.0+1

environment:
  sdk: ^3.10.4

dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter
  
  intl: ^0.20.2    
  flutter_riverpod: ^3.0.3
  riverpod_annotation: ^3.0.3
  go_router: ^16.2.4
  url_launcher: ^6.3.1
dev_dependencies:
  build_runner: ^2.7.1
  riverpod_generator: ^3.0.3
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0
  intl_utils: ^2.8.11

flutter:
  uses-material-design: true


flutter_intl:
  enabled: true
  class_name: L10n
  main_locale: it
  arb_dir: lib/core/l10n
  output_dir: lib/core/l10n

--------------------------

>>> CONTENUTO: Core
‚ö† File non trovato: ../agenda_core/agenda_core_snapshot.txt

=== FINE DEL BUNDLE ===
