--- FILE: lib/core/l10n/l10_extension.dart ---
import 'package:flutter/widgets.dart';

import 'l10n.dart';

/// 🔤 Estensione per accedere facilmente alle stringhe localizzate.
///
/// Permette di scrivere:
/// ```dart
/// Text(context.l10n.welcomeMessage)
/// ```
/// invece di:
/// ```dart
/// Text(L10n.of(context).welcomeMessage)
/// ```
///
/// ✅ Compatibile con aggiornamenti runtime della lingua.
/// ✅ Evita dipendenze da `L10n.current` statico.
/// ✅ Standard consigliato per progetti Flutter internazionalizzati.
extension L10nX on BuildContext {
  /// Restituisce l'istanza corrente di [L10n] per questo [BuildContext].
  L10n get l10n => L10n.of(this);
}
--- FILE: lib/core/l10n/intl/messages_all.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that looks up messages for specific locales by
// delegating to the appropriate library.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:implementation_imports, file_names, unnecessary_new
// ignore_for_file:unnecessary_brace_in_string_interps, directives_ordering
// ignore_for_file:argument_type_not_assignable, invalid_assignment
// ignore_for_file:prefer_single_quotes, prefer_generic_function_type_aliases
// ignore_for_file:comment_references

import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';
import 'package:intl/src/intl_helpers.dart';

import 'messages_en.dart' as messages_en;
import 'messages_it.dart' as messages_it;

typedef Future<dynamic> LibraryLoader();
Map<String, LibraryLoader> _deferredLibraries = {
  'en': () => new SynchronousFuture(null),
  'it': () => new SynchronousFuture(null),
};

MessageLookupByLibrary? _findExact(String localeName) {
  switch (localeName) {
    case 'en':
      return messages_en.messages;
    case 'it':
      return messages_it.messages;
    default:
      return null;
  }
}

/// User programs should call this before using [localeName] for messages.
Future<bool> initializeMessages(String localeName) {
  var availableLocale = Intl.verifiedLocale(
      localeName, (locale) => _deferredLibraries[locale] != null,
      onFailure: (_) => null);
  if (availableLocale == null) {
    return new SynchronousFuture(false);
  }
  var lib = _deferredLibraries[availableLocale];
  lib == null ? new SynchronousFuture(false) : lib();
  initializeInternalMessageLookup(() => new CompositeMessageLookup());
  messageLookup.addLocale(availableLocale, _findGeneratedMessagesFor);
  return new SynchronousFuture(true);
}

bool _messagesExistFor(String locale) {
  try {
    return _findExact(locale) != null;
  } catch (e) {
    return false;
  }
}

MessageLookupByLibrary? _findGeneratedMessagesFor(String locale) {
  var actualLocale =
      Intl.verifiedLocale(locale, _messagesExistFor, onFailure: (_) => null);
  if (actualLocale == null) return null;
  return _findExact(actualLocale);
}
--- FILE: lib/core/l10n/intl/messages_it.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that provides messages for a it locale. All the
// messages from the main program should be duplicated here with the same
// function name.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:unnecessary_brace_in_string_interps, unnecessary_new
// ignore_for_file:prefer_single_quotes,comment_references, directives_ordering
// ignore_for_file:annotate_overrides,prefer_generic_function_type_aliases
// ignore_for_file:unused_import, file_names, avoid_escaping_inner_quotes
// ignore_for_file:unnecessary_string_interpolations, unnecessary_string_escapes

import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = new MessageLookup();

typedef String MessageIfAbsent(String messageStr, List<dynamic> args);

class MessageLookup extends MessageLookupByLibrary {
  String get localeName => 'it';

  final messages = _notInlinedMessages(_notInlinedMessages);
  static Map<String, Function> _notInlinedMessages(_) => <String, Function>{
        "appTitle": MessageLookupByLibrary.simpleMessage("Agenda"),
        "clientsTitle": MessageLookupByLibrary.simpleMessage("Elenco Clienti"),
        "navAgenda": MessageLookupByLibrary.simpleMessage("Agenda"),
        "navClients": MessageLookupByLibrary.simpleMessage("Clienti"),
        "navServices": MessageLookupByLibrary.simpleMessage("Servizi"),
        "navStaff": MessageLookupByLibrary.simpleMessage("Staff"),
        "servicesTitle": MessageLookupByLibrary.simpleMessage("Elenco Servizi"),
        "staffTitle": MessageLookupByLibrary.simpleMessage("Elenco Staff")
      };
}
--- FILE: lib/core/l10n/intl/messages_en.dart ---
// DO NOT EDIT. This is code generated via package:intl/generate_localized.dart
// This is a library that provides messages for a en locale. All the
// messages from the main program should be duplicated here with the same
// function name.

// Ignore issues from commonly used lints in this file.
// ignore_for_file:unnecessary_brace_in_string_interps, unnecessary_new
// ignore_for_file:prefer_single_quotes,comment_references, directives_ordering
// ignore_for_file:annotate_overrides,prefer_generic_function_type_aliases
// ignore_for_file:unused_import, file_names, avoid_escaping_inner_quotes
// ignore_for_file:unnecessary_string_interpolations, unnecessary_string_escapes

import 'package:intl/intl.dart';
import 'package:intl/message_lookup_by_library.dart';

final messages = new MessageLookup();

typedef String MessageIfAbsent(String messageStr, List<dynamic> args);

class MessageLookup extends MessageLookupByLibrary {
  String get localeName => 'en';

  final messages = _notInlinedMessages(_notInlinedMessages);
  static Map<String, Function> _notInlinedMessages(_) => <String, Function>{
        "appTitle": MessageLookupByLibrary.simpleMessage("Agenda Platform"),
        "clientsTitle": MessageLookupByLibrary.simpleMessage("Clients List"),
        "navAgenda": MessageLookupByLibrary.simpleMessage("Agenda"),
        "navClients": MessageLookupByLibrary.simpleMessage("Clients"),
        "navServices": MessageLookupByLibrary.simpleMessage("Services"),
        "navStaff": MessageLookupByLibrary.simpleMessage("Staff"),
        "servicesTitle": MessageLookupByLibrary.simpleMessage("Services List"),
        "staffTitle": MessageLookupByLibrary.simpleMessage("Staff List")
      };
}
--- FILE: lib/core/l10n/l10n.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'intl/messages_all.dart';

// **************************************************************************
// Generator: Flutter Intl IDE plugin
// Made by Localizely
// **************************************************************************

// ignore_for_file: non_constant_identifier_names, lines_longer_than_80_chars
// ignore_for_file: join_return_with_assignment, prefer_final_in_for_each
// ignore_for_file: avoid_redundant_argument_values, avoid_escaping_inner_quotes

class L10n {
  L10n();

  static L10n? _current;

  static L10n get current {
    assert(_current != null,
        'No instance of L10n was loaded. Try to initialize the L10n delegate before accessing L10n.current.');
    return _current!;
  }

  static const AppLocalizationDelegate delegate = AppLocalizationDelegate();

  static Future<L10n> load(Locale locale) {
    final name = (locale.countryCode?.isEmpty ?? false)
        ? locale.languageCode
        : locale.toString();
    final localeName = Intl.canonicalizedLocale(name);
    return initializeMessages(localeName).then((_) {
      Intl.defaultLocale = localeName;
      final instance = L10n();
      L10n._current = instance;

      return instance;
    });
  }

  static L10n of(BuildContext context) {
    final instance = L10n.maybeOf(context);
    assert(instance != null,
        'No instance of L10n present in the widget tree. Did you add L10n.delegate in localizationsDelegates?');
    return instance!;
  }

  static L10n? maybeOf(BuildContext context) {
    return Localizations.of<L10n>(context, L10n);
  }

  /// `Agenda`
  String get appTitle {
    return Intl.message(
      'Agenda',
      name: 'appTitle',
      desc: '',
      args: [],
    );
  }

  /// `Agenda`
  String get navAgenda {
    return Intl.message(
      'Agenda',
      name: 'navAgenda',
      desc: '',
      args: [],
    );
  }

  /// `Clienti`
  String get navClients {
    return Intl.message(
      'Clienti',
      name: 'navClients',
      desc: '',
      args: [],
    );
  }

  /// `Servizi`
  String get navServices {
    return Intl.message(
      'Servizi',
      name: 'navServices',
      desc: '',
      args: [],
    );
  }

  /// `Staff`
  String get navStaff {
    return Intl.message(
      'Staff',
      name: 'navStaff',
      desc: '',
      args: [],
    );
  }

  /// `Elenco Clienti`
  String get clientsTitle {
    return Intl.message(
      'Elenco Clienti',
      name: 'clientsTitle',
      desc: '',
      args: [],
    );
  }

  /// `Elenco Servizi`
  String get servicesTitle {
    return Intl.message(
      'Elenco Servizi',
      name: 'servicesTitle',
      desc: '',
      args: [],
    );
  }

  /// `Elenco Staff`
  String get staffTitle {
    return Intl.message(
      'Elenco Staff',
      name: 'staffTitle',
      desc: '',
      args: [],
    );
  }
}

class AppLocalizationDelegate extends LocalizationsDelegate<L10n> {
  const AppLocalizationDelegate();

  List<Locale> get supportedLocales {
    return const <Locale>[
      Locale.fromSubtags(languageCode: 'it'),
      Locale.fromSubtags(languageCode: 'en'),
    ];
  }

  @override
  bool isSupported(Locale locale) => _isSupported(locale);
  @override
  Future<L10n> load(Locale locale) => L10n.load(locale);
  @override
  bool shouldReload(AppLocalizationDelegate old) => false;

  bool _isSupported(Locale locale) {
    for (var supportedLocale in supportedLocales) {
      if (supportedLocale.languageCode == locale.languageCode) {
        return true;
      }
    }
    return false;
  }
}
--- FILE: lib/core/network/api_client.dart ---
--- FILE: lib/core/utils/color_utils.dart ---
import 'package:flutter/material.dart';

class ColorUtils {
  /// Restituisce il colore in formato esadecimale '#AARRGGBB'
  static String toHex(Color color) {
    final int argb = color.toARGB32();
    return '#${argb.toRadixString(16).padLeft(8, '0').toUpperCase()}';
  }

  /// Converte una stringa esadecimale '#AARRGGBB' o '#RRGGBB' in un Color
  static Color fromHex(String hexString) {
    final buffer = StringBuffer();
    if (hexString.length == 6 || hexString.length == 7) buffer.write('FF');
    buffer.write(hexString.replaceFirst('#', ''));
    return Color(int.parse(buffer.toString(), radix: 16));
  }
}
--- FILE: lib/core/utils/date_utils.dart ---
--- FILE: lib/core/models/appointment.dart ---
class Appointment {
  final int id;
  final int staffId;
  final String clientName;
  final String serviceName;
  final DateTime startTime;
  final DateTime endTime;
  final double? price; // costo singolo in euro

  const Appointment({
    required this.id,
    required this.staffId,
    required this.clientName,
    required this.serviceName,
    required this.startTime,
    required this.endTime,
    this.price,
  });

  /// 🔸 Costruttore da JSON
  factory Appointment.fromJson(Map<String, dynamic> json) => Appointment(
    id: json['id'],
    staffId: json['staff_id'],
    clientName: json['client_name'],
    serviceName: json['service_name'],
    startTime: DateTime.parse(json['start_time']),
    endTime: DateTime.parse(json['end_time']),
    price: json['price'] != null ? (json['price'] as num).toDouble() : null,
  );

  Appointment copyWith({
    int? id,
    int? staffId,
    String? clientName,
    String? serviceName,
    DateTime? startTime,
    DateTime? endTime,
    double? price,
  }) {
    return Appointment(
      id: id ?? this.id,
      staffId: staffId ?? this.staffId,
      clientName: clientName ?? this.clientName,
      serviceName: serviceName ?? this.serviceName,
      startTime: startTime ?? this.startTime,
      endTime: endTime ?? this.endTime,
      price: price ?? this.price,
    );
  }

  /// 🔸 Serializzazione in JSON
  Map<String, dynamic> toJson({bool includeServices = true}) {
    return {
      'id': id,
      'staff_id': staffId,
      'client_name': clientName,
      'service_name': serviceName,
      'start_time': startTime.toIso8601String(),
      'end_time': endTime.toIso8601String(),
      if (price != null) 'price': price,
    };
  }

  /// 🔹 Durata totale in minuti
  int get totalDuration => endTime.difference(startTime).inMinutes;

  /// 🔹 Stringa formattata per prezzo totale
  String get formattedPrice {
    if (price == null || price == 0) return '';
    return '${price!.toStringAsFixed(2)}€';
  }
}
--- FILE: lib/core/models/service.dart ---
class Service {
  final int id;
  final String name;
  final int? duration; // minuti
  final double? price; // costo singolo in euro

  const Service({
    required this.id,
    required this.name,
    this.duration,
    this.price,
  });

  factory Service.fromJson(Map<String, dynamic> json) => Service(
    id: json['id'],
    name: json['name'],
    duration: json['duration'],
    price: json['price'] != null ? (json['price'] as num).toDouble() : null,
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    if (duration != null) 'duration': duration,
    if (price != null) 'price': price,
  };
}
--- FILE: lib/core/models/staff.dart ---
import 'package:flutter/material.dart';

import '../utils/color_utils.dart';

class Staff {
  final int id;
  final String name;
  final Color color;

  const Staff({required this.id, required this.name, required this.color});

  factory Staff.fromJson(Map<String, dynamic> json) => Staff(
    id: json['id'],
    name: json['name'],
    color: json['color_hex'] != null
        ? ColorUtils.fromHex(json['color_hex'])
        : ColorUtils.fromHex('#FFD700'),
  );

  Map<String, dynamic> toJson() => {
    'id': id,
    'name': name,
    'color_hex': ColorUtils.toHex(color),
  };
}
--- FILE: lib/core/widgets/no_scrollbar_behavior.dart ---
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';

/// Comportamento di scroll che disattiva scrollbar, effetto glow e spazio riservato
class NoScrollbarBehavior extends ScrollBehavior {
  const NoScrollbarBehavior();

  @override
  Widget buildScrollbar(
    BuildContext context,
    Widget child,
    ScrollableDetails details,
  ) {
    return child; // 🔕 nessuna scrollbar
  }

  @override
  Set<PointerDeviceKind> get dragDevices => {
    PointerDeviceKind.touch,
    PointerDeviceKind.mouse,
    PointerDeviceKind.trackpad,
  }; // abilita lo scroll anche col mouse

  @override
  ScrollPhysics getScrollPhysics(BuildContext context) =>
      const ClampingScrollPhysics(); // nessun overscroll o padding aggiuntivo
}
--- FILE: lib/core/widgets/layout_config_auto_listener.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// 1. Importa il nuovo provider globale
import '../../app/providers/form_factor_provider.dart';
import '../../features/agenda/providers/layout_config_provider.dart';

class LayoutConfigAutoListener extends ConsumerStatefulWidget {
  final Widget child;

  const LayoutConfigAutoListener({super.key, required this.child});
  @override
  ConsumerState<LayoutConfigAutoListener> createState() =>
      _LayoutConfigAutoListenerState();
}

class _LayoutConfigAutoListenerState
    extends ConsumerState<LayoutConfigAutoListener>
    with WidgetsBindingObserver {
  Size? _lastSize;
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _updateLayoutConfig();
    });
  }

  @override
  void didChangeMetrics() {
    super.didChangeMetrics();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final newSize = MediaQuery.of(context).size;
      if (_lastSize == null || newSize != _lastSize) {
        _lastSize = newSize;
        _updateLayoutConfig();
      }
    });
  }

  void _updateLayoutConfig() {
    // 2. Aggiorna il provider originale (per l'agenda)
    ref.read(layoutConfigProvider.notifier).updateFromContext(context);

    // 3. Aggiorna il NUOVO provider globale (per la Shell)
    final screenWidth = MediaQuery.of(context).size.width;
    ref.read(formFactorProvider.notifier).update(screenWidth);
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return widget.child;
  }
}
--- FILE: lib/app/router.dart ---
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:go_router/go_router.dart';

// Importa le nuove schermate
import '../features/agenda/presentation/agenda_screen.dart';
import '../features/clients/presentation/clients_screen.dart';
import '../features/services/presentation/services_screen.dart';
import '../features/staff/presentation/staff_screen.dart';
// Importa la nostra "Shell"
import 'scaffold_with_navigation.dart';

// 1. Definiamo una chiave globale per la nostra Shell (necessaria)
final _rootNavigatorKey = GlobalKey<NavigatorState>();

/// 🔹 Router globale dell’app
final GoRouter appRouter = GoRouter(
  initialLocation: '/agenda',
  navigatorKey: _rootNavigatorKey,

  debugLogDiagnostics: kDebugMode,

  errorBuilder: (context, state) => Scaffold(
    appBar: AppBar(title: const Text('Errore')),
    body: Center(
      child: Text(
        'Pagina non trovata: ${state.uri.path}',
        style: const TextStyle(color: Colors.redAccent),
      ),
    ),
  ),

  // 2. Definiamo la nostra navigazione con `StatefulShellRoute`
  routes: [
    StatefulShellRoute.indexedStack(
      builder: (context, state, navigationShell) {
        return ScaffoldWithNavigation(navigationShell: navigationShell);
      },

      branches: [
        // --- Ramo 0: Agenda ---
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/agenda',
              name: 'agenda',
              builder: (BuildContext context, GoRouterState state) =>
                  const AgendaScreen(),
            ),
          ],
        ),

        // --- Ramo 1: Clienti ---
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/clienti',
              name: 'clienti',
              builder: (BuildContext context, GoRouterState state) =>
                  const ClientsScreen(),
            ),
          ],
        ),

        // --- Ramo 2: Servizi ---
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/servizi',
              name: 'servizi',
              builder: (BuildContext context, GoRouterState state) =>
                  const ServicesScreen(),
            ),
          ],
        ),

        // --- Ramo 3: Staff ---
        StatefulShellBranch(
          routes: [
            GoRoute(
              path: '/staff',
              name: 'staff',
              builder: (BuildContext context, GoRouterState state) =>
                  const StaffScreen(),
            ),
          ],
        ),
      ],
    ),
  ],
);
--- FILE: lib/app/scaffold_with_navigation.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart'; // 1. Importa Riverpod
import 'package:go_router/go_router.dart';

import '../core/l10n/l10_extension.dart';
// 2. Importa il nuovo provider globale
import 'providers/form_factor_provider.dart';

// 3. Trasforma in ConsumerWidget
class ScaffoldWithNavigation extends ConsumerWidget {
  const ScaffoldWithNavigation({super.key, required this.navigationShell});

  final StatefulNavigationShell navigationShell;

  // ... (le funzioni helper _getLocalizedTitle e _getDestinations non cambiano) ...
  // [CODICE HELPER OMESSO PER BREVITÀ]

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 4. Aggiungi WidgetRef
    final destinations = _getDestinations(context);

    // 5. LEGGI IL PROVIDER GLOBALE!
    final formFactor = ref.watch(formFactorProvider);

    // 6. Usa il formFactor per decidere il layout
    if (formFactor == AppFormFactor.tabletOrDesktop) {
      // 🎯 TARGET WEB/DESKTOP/TABLET: NavigationRail
      return Scaffold(
        appBar: AppBar(
          title: Text(
            _getLocalizedTitle(context, navigationShell.currentIndex),
          ),
          centerTitle: false,
        ),
        body: Row(
          children: [
            NavigationRail(
              selectedIndex: navigationShell.currentIndex,
              onDestinationSelected: (index) => _goBranch(index),
              labelType: NavigationRailLabelType.all,
              destinations: destinations
                  .map(
                    (d) => NavigationRailDestination(
                      icon: d.icon,
                      selectedIcon: d.selectedIcon,
                      label: Text(d.label),
                    ),
                  )
                  .toList(),
            ),
            const VerticalDivider(thickness: 1, width: 1),
            Expanded(child: navigationShell),
          ],
        ),
      );
    }

    // 🎯 TARGET MOBILE: BottomNavigationBar
    return Scaffold(
      appBar: AppBar(
        title: Text(_getLocalizedTitle(context, navigationShell.currentIndex)),
      ),
      body: navigationShell,
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: navigationShell.currentIndex,
        onTap: (index) => _goBranch(index),
        type: BottomNavigationBarType.fixed,
        items: destinations
            .map(
              (d) => BottomNavigationBarItem(
                icon: d.icon,
                activeIcon: d.selectedIcon,
                label: d.label,
              ),
            )
            .toList(),
      ),
    );
  }

  // ... (la funzione _goBranch non cambia) ...
  void _goBranch(int index) {
    navigationShell.goBranch(
      index,
      initialLocation: index == navigationShell.currentIndex,
    );
  }

  // ... (le funzioni helper omesse prima) ...
  String _getLocalizedTitle(BuildContext context, int index) {
    final l10n = context.l10n;
    switch (index) {
      case 0:
        return l10n.navAgenda;
      case 1:
        return l10n.navClients;
      case 2:
        return l10n.navServices;
      case 3:
        return l10n.navStaff;
      default:
        return l10n.appTitle;
    }
  }

  List<NavigationDestination> _getDestinations(BuildContext context) {
    final l10n = context.l10n;
    return [
      NavigationDestination(
        icon: const Icon(Icons.calendar_month_outlined),
        selectedIcon: const Icon(Icons.calendar_month),
        label: l10n.navAgenda,
      ),
      NavigationDestination(
        icon: const Icon(Icons.people_outline),
        selectedIcon: const Icon(Icons.people),
        label: l10n.navClients,
      ),
      NavigationDestination(
        icon: const Icon(Icons.cut_outlined),
        selectedIcon: const Icon(Icons.cut),
        label: l10n.navServices,
      ),
      NavigationDestination(
        icon: const Icon(Icons.badge_outlined),
        selectedIcon: const Icon(Icons.badge),
        label: l10n.navStaff,
      ),
    ];
  }
}

// Classe helper (invariata)
class NavigationDestination {
  const NavigationDestination({
    required this.icon,
    required this.selectedIcon,
    required this.label,
  });
  final Widget icon;
  final Widget selectedIcon;
  final String label;
}
--- FILE: lib/app/providers/form_factor_provider.dart ---
import 'package:riverpod_annotation/riverpod_annotation.dart';

part 'form_factor_provider.g.dart';

// Definiamo i due layout che ci interessano
enum AppFormFactor { mobile, tabletOrDesktop }

@riverpod
class FormFactorNotifier extends _$FormFactorNotifier {
  @override
  AppFormFactor build() {
    // Il default è mobile, ma verrà aggiornato immediatamente
    return AppFormFactor.mobile;
  }

  /// Aggiorna il form factor in base alla larghezza dello schermo.
  /// Usa lo stesso breakpoint di 600px che usi nel resto dell'app.
  void update(double screenWidth) {
    final newFactor = screenWidth >= 600
        ? AppFormFactor.tabletOrDesktop
        : AppFormFactor.mobile;

    // Aggiorna lo stato solo se il form factor cambia
    if (state != newFactor) {
      state = newFactor;
    }
  }
}
--- FILE: lib/app/providers/form_factor_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'form_factor_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(FormFactorNotifier)
const formFactorProvider = FormFactorNotifierProvider._();

final class FormFactorNotifierProvider
    extends $NotifierProvider<FormFactorNotifier, AppFormFactor> {
  const FormFactorNotifierProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'formFactorProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$formFactorNotifierHash();

  @$internal
  @override
  FormFactorNotifier create() => FormFactorNotifier();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AppFormFactor value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AppFormFactor>(value),
    );
  }
}

String _$formFactorNotifierHash() =>
    r'b424a354337075ba3ba718aa01c971cbf4353de7';

abstract class _$FormFactorNotifier extends $Notifier<AppFormFactor> {
  AppFormFactor build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<AppFormFactor, AppFormFactor>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AppFormFactor, AppFormFactor>,
              AppFormFactor,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/app/theme/theme_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'theme_config.dart';

/// 🔹 Notifier moderno per gestire il tema dinamico
class ThemeNotifier extends Notifier<AppThemeConfig> {
  @override
  AppThemeConfig build() {
    // Stato iniziale del tema
    return const AppThemeConfig(
      seedColor: Color(0xFFFFD700), // Oro
      brightness: Brightness.dark,
    );
  }

  /// Cambia il colore principale (seed color)
  void updateSeed(Color color) {
    state = state.copyWith(seedColor: color);
  }

  /// Inverte la modalità chiara/scura
  void toggleBrightness() {
    state = state.copyWith(
      brightness: state.brightness == Brightness.dark
          ? Brightness.light
          : Brightness.dark,
    );
  }
}

/// 🔹 Provider globale per il tema (versione Notifier)
final themeNotifierProvider = NotifierProvider<ThemeNotifier, AppThemeConfig>(
  ThemeNotifier.new,
);
--- FILE: lib/app/theme/theme_config.dart ---
import 'package:flutter/material.dart';

class AppThemeConfig {
  final Color seedColor;
  final Brightness brightness;

  const AppThemeConfig({
    required this.seedColor,
    this.brightness = Brightness.dark,
  });

  AppThemeConfig copyWith({Color? seedColor, Brightness? brightness}) {
    return AppThemeConfig(
      seedColor: seedColor ?? this.seedColor,
      brightness: brightness ?? this.brightness,
    );
  }
}
--- FILE: lib/app/theme/theme.dart ---
import 'package:flutter/material.dart';

import 'theme_config.dart';

/// 🔹 Tema chiaro con sfondo bianco e testi neri
ThemeData buildTheme(AppThemeConfig config, Brightness brightness) {
  // Palette chiara, fissa (non dipende dal seed)
  const colorScheme = ColorScheme.light(
    primary: Colors.black,
    onPrimary: Colors.white,
    secondary: Colors.grey,
    onSecondary: Colors.white,
    background: Colors.white,
    onBackground: Colors.black,
    surface: Colors.white,
    onSurface: Colors.black,
  );

  return ThemeData(
    useMaterial3: true,
    brightness: Brightness.light,
    colorScheme: colorScheme,

    // ✅ Sfondo bianco
    scaffoldBackgroundColor: Colors.white,
    canvasColor: Colors.white,

    // ✅ AppBar bianca, testo nero
    appBarTheme: const AppBarTheme(
      backgroundColor: Colors.white,
      foregroundColor: Colors.black,
      centerTitle: true,
      surfaceTintColor: Colors.transparent,
      elevation: 0,
      iconTheme: IconThemeData(color: Colors.black),
      titleTextStyle: TextStyle(
        color: Colors.black,
        fontSize: 18,
        fontWeight: FontWeight.w600,
      ),
    ),

    // ✅ Card bianche con bordo grigio leggero (usa CardThemeData!)
    cardTheme: CardThemeData(
      color: Colors.white,
      surfaceTintColor: Colors.transparent,
      elevation: 0,
      margin: const EdgeInsets.all(8),
      shape: RoundedRectangleBorder(
        side: BorderSide(color: Colors.grey.shade300, width: 0.5),
        borderRadius: const BorderRadius.all(Radius.circular(12)),
      ),
    ),

    // ✅ Testi neri
    textTheme: const TextTheme(
      bodyLarge: TextStyle(color: Colors.black),
      bodyMedium: TextStyle(color: Colors.black, fontSize: 14),
      bodySmall: TextStyle(color: Colors.black87, fontSize: 12),
      titleMedium: TextStyle(
        color: Colors.black,
        fontWeight: FontWeight.w600,
        fontSize: 16,
      ),
      labelLarge: TextStyle(color: Colors.black),
    ),

    // ✅ Icone e divider coerenti
    iconTheme: const IconThemeData(color: Colors.black),
    dividerColor: Colors.grey,

    // ✅ Pulsanti coerenti
    floatingActionButtonTheme: const FloatingActionButtonThemeData(
      backgroundColor: Colors.black,
      foregroundColor: Colors.white,
    ),
    elevatedButtonTheme: ElevatedButtonThemeData(
      style: ElevatedButton.styleFrom(
        backgroundColor: Colors.black,
        foregroundColor: Colors.white,
        textStyle: const TextStyle(fontWeight: FontWeight.w600),
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(8), // BorderRadiusGeometry ok
        ),
      ),
    ),
  );
}
--- FILE: lib/app/app.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/l10n/l10_extension.dart';
import '/core/l10n/l10n.dart';
// 1. Importa il listener dalla sua nuova posizione (se non l'hai già spostato)
// Assicurati che il percorso sia corretto.
import '../core/widgets/layout_config_auto_listener.dart';
import 'router.dart';
import 'theme/theme.dart';
import 'theme/theme_provider.dart';

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeConfig = ref.watch(themeNotifierProvider);
    return MaterialApp.router(
      debugShowCheckedModeBanner: false,
      title: 'Agenda Platform',
      routerConfig: appRouter,
      themeMode: ThemeMode.system,
      theme: buildTheme(themeConfig, Brightness.light),
      darkTheme: buildTheme(themeConfig, Brightness.dark),
      localizationsDelegates: const [
        L10n.delegate,
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: L10n.delegate.supportedLocales,
      locale: const Locale('it'),

      // 2. SPOSTA IL LISTENER QUI
      builder: (context, child) {
        final localizedTitle = context.l10n.appTitle;
        return Title(
          title: localizedTitle,
          color: Theme.of(context).scaffoldBackgroundColor,
          // Questo widget ora aggiornerà i provider globali
          // prima che qualsiasi schermata venga costruita.
          child: LayoutConfigAutoListener(
            child: child ?? const SizedBox.shrink(),
          ),
        );
      },
    );
  }
}
--- FILE: lib/features/clients/providers/clients_providers.dart ---
--- FILE: lib/features/clients/data/clients_api.dart ---
--- FILE: lib/features/clients/data/clients_repository.dart ---
--- FILE: lib/features/clients/domain/clients.dart ---
--- FILE: lib/features/clients/presentation/clients_screen.dart ---
import 'package:flutter/material.dart';

import '../../../core/l10n/l10_extension.dart'; // 🌍

class ClientsScreen extends StatelessWidget {
  const ClientsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    // ❗️ Niente Scaffold o AppBar
    return Center(
      child: Text(
        context.l10n.clientsTitle, // 🌍
        style: const TextStyle(fontSize: 24),
      ),
    );
  }
}
--- FILE: lib/features/agenda/providers/staff_providers.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/staff.dart';

final staffProvider = Provider<List<Staff>>((ref) {
  return [
    Staff(id: 1, name: 'Mario', color: Colors.green),
    Staff(id: 2, name: 'Luca', color: Colors.cyan),
    Staff(id: 3, name: 'Sara', color: Colors.orange),
    Staff(id: 4, name: 'Alessia', color: Colors.pinkAccent),
    Staff(id: 5, name: 'Luisa', color: Colors.purpleAccent),
  ];
});
--- FILE: lib/features/agenda/providers/dragged_appointment_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// 🔹 Tiene traccia dell’appuntamento attualmente trascinato.
/// Nessun delay: il fantasma scompare subito al rilascio.
class DraggedAppointmentIdNotifier extends Notifier<int?> {
  @override
  int? build() => null;

  /// Imposta l'ID dell'appuntamento trascinato
  void set(int id) => state = id;

  /// Cancella immediatamente il fantasma
  void clear() => state = null;
}

final draggedAppointmentIdProvider =
    NotifierProvider<DraggedAppointmentIdNotifier, int?>(
      DraggedAppointmentIdNotifier.new,
    );
--- FILE: lib/features/agenda/providers/layout_config_provider.dart ---
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../domain/config/layout_config.dart';

part 'layout_config_provider.g.dart';

/// Provider responsabile di mantenere aggiornata la configurazione del layout
/// (in particolare l’altezza degli slot e dell’header)
@riverpod
class LayoutConfigNotifier extends _$LayoutConfigNotifier {
  Timer? _resizeDebounce;

  @override
  double build() {
    ref.onDispose(() {
      _resizeDebounce?.cancel();
    });
    return LayoutConfig.slotHeight;
  }

  /// Aggiorna dinamicamente l’altezza degli slot e dell’header
  /// in base alle dimensioni della finestra
  void updateFromContext(BuildContext context) {
    _resizeDebounce?.cancel();
    _resizeDebounce = Timer(const Duration(milliseconds: 100), () {
      final size = MediaQuery.of(context).size;
      final screenHeight = size.height;
      final screenWidth = size.width;

      // 🔹 Calcolo dinamico dell’altezza degli slot
      double newSlotHeight = LayoutConfig.slotHeight;
      if (screenHeight < 700) {
        newSlotHeight = 30 * 0.8;
      } else if (screenHeight > 1200) {
        newSlotHeight = 30 * 1.2;
      } else {
        newSlotHeight = 30;
      }

      // 🔹 Calcolo dinamico dell’altezza dell’header
      double newHeaderHeight;
      if (screenWidth >= 1024) {
        newHeaderHeight = 56; // Desktop
      } else if (screenWidth >= 600) {
        newHeaderHeight = 52; // Tablet
      } else {
        newHeaderHeight = 48; // Mobile
      }

      // 🔹 Aggiorna LayoutConfig globale
      LayoutConfig.updateSlotHeight(newSlotHeight);
      LayoutConfig.updateHeaderHeight(newHeaderHeight);

      // 🔹 Aggiorna stato provider se necessario
      if (newSlotHeight != state) {
        state = newSlotHeight;
      }
    });
  }
}
--- FILE: lib/features/agenda/providers/agenda_scroll_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'agenda_scroll_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning

@ProviderFor(AgendaScroll)
const agendaScrollProvider = AgendaScrollFamily._();

final class AgendaScrollProvider
    extends $NotifierProvider<AgendaScroll, AgendaScrollState> {
  const AgendaScrollProvider._({
    required AgendaScrollFamily super.from,
    required List<Staff> super.argument,
  }) : super(
         retry: null,
         name: r'agendaScrollProvider',
         isAutoDispose: true,
         dependencies: null,
         $allTransitiveDependencies: null,
       );

  @override
  String debugGetCreateSourceHash() => _$agendaScrollHash();

  @override
  String toString() {
    return r'agendaScrollProvider'
        ''
        '($argument)';
  }

  @$internal
  @override
  AgendaScroll create() => AgendaScroll();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(AgendaScrollState value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<AgendaScrollState>(value),
    );
  }

  @override
  bool operator ==(Object other) {
    return other is AgendaScrollProvider && other.argument == argument;
  }

  @override
  int get hashCode {
    return argument.hashCode;
  }
}

String _$agendaScrollHash() => r'68ed618f8b12029a0d3177f2c9e8f146840ca836';

final class AgendaScrollFamily extends $Family
    with
        $ClassFamilyOverride<
          AgendaScroll,
          AgendaScrollState,
          AgendaScrollState,
          AgendaScrollState,
          List<Staff>
        > {
  const AgendaScrollFamily._()
    : super(
        retry: null,
        name: r'agendaScrollProvider',
        dependencies: null,
        $allTransitiveDependencies: null,
        isAutoDispose: true,
      );

  AgendaScrollProvider call(List<Staff> staffList) =>
      AgendaScrollProvider._(argument: staffList, from: this);

  @override
  String toString() => r'agendaScrollProvider';
}

abstract class _$AgendaScroll extends $Notifier<AgendaScrollState> {
  late final _$args = ref.$arg as List<Staff>;
  List<Staff> get staffList => _$args;

  AgendaScrollState build(List<Staff> staffList);
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build(_$args);
    final ref = this.ref as $Ref<AgendaScrollState, AgendaScrollState>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<AgendaScrollState, AgendaScrollState>,
              AgendaScrollState,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/features/agenda/providers/highlighted_staff_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// 🔹 Tiene traccia dello staff evidenziato durante il drag
class HighlightedStaffIdNotifier extends Notifier<int?> {
  @override
  int? build() => null;

  void set(int? id) => state = id;
  void clear() => state = null;
}

final highlightedStaffIdProvider =
    NotifierProvider<HighlightedStaffIdNotifier, int?>(
      HighlightedStaffIdNotifier.new,
    );
--- FILE: lib/features/agenda/providers/drag_offset_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// 🔹 Distanza verticale (in px) tra il punto di presa e il bordo superiore della card
class DragOffsetNotifier extends Notifier<double?> {
  @override
  double? build() => null;

  void set(double value) => state = value;
  void clear() => state = null;
}

final dragOffsetProvider = NotifierProvider<DragOffsetNotifier, double?>(
  DragOffsetNotifier.new,
);

/// 🔹 Distanza orizzontale (in px) tra il punto di presa e il bordo sinistro della card
class DragOffsetXNotifier extends Notifier<double?> {
  @override
  double? build() => null;

  void set(double value) => state = value;
  void clear() => state = null;
}

final dragOffsetXProvider = NotifierProvider<DragOffsetXNotifier, double?>(
  DragOffsetXNotifier.new,
);
--- FILE: lib/features/agenda/providers/layout_config_provider.g.dart ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'layout_config_provider.dart';

// **************************************************************************
// RiverpodGenerator
// **************************************************************************

// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint, type=warning
/// Provider responsabile di mantenere aggiornata la configurazione del layout
/// (in particolare l’altezza degli slot e dell’header)

@ProviderFor(LayoutConfigNotifier)
const layoutConfigProvider = LayoutConfigNotifierProvider._();

/// Provider responsabile di mantenere aggiornata la configurazione del layout
/// (in particolare l’altezza degli slot e dell’header)
final class LayoutConfigNotifierProvider
    extends $NotifierProvider<LayoutConfigNotifier, double> {
  /// Provider responsabile di mantenere aggiornata la configurazione del layout
  /// (in particolare l’altezza degli slot e dell’header)
  const LayoutConfigNotifierProvider._()
    : super(
        from: null,
        argument: null,
        retry: null,
        name: r'layoutConfigProvider',
        isAutoDispose: true,
        dependencies: null,
        $allTransitiveDependencies: null,
      );

  @override
  String debugGetCreateSourceHash() => _$layoutConfigNotifierHash();

  @$internal
  @override
  LayoutConfigNotifier create() => LayoutConfigNotifier();

  /// {@macro riverpod.override_with_value}
  Override overrideWithValue(double value) {
    return $ProviderOverride(
      origin: this,
      providerOverride: $SyncValueProvider<double>(value),
    );
  }
}

String _$layoutConfigNotifierHash() =>
    r'850083366aea0ce85343fe700d326c9e075842cf';

/// Provider responsabile di mantenere aggiornata la configurazione del layout
/// (in particolare l’altezza degli slot e dell’header)

abstract class _$LayoutConfigNotifier extends $Notifier<double> {
  double build();
  @$mustCallSuper
  @override
  void runBuild() {
    final created = build();
    final ref = this.ref as $Ref<double, double>;
    final element =
        ref.element
            as $ClassProviderElement<
              AnyNotifier<double, double>,
              double,
              Object?,
              Object?
            >;
    element.handleValue(ref, created);
  }
}
--- FILE: lib/features/agenda/providers/dragged_card_size_provider.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// 🔹 Tiene la dimensione (Size) della card attualmente trascinata.
/// Serve per calcolare correttamente la percentuale di overlap orizzontale.
class DraggedCardSizeNotifier extends Notifier<Size?> {
  @override
  Size? build() => null;

  void set(Size size) => state = size;
  void clear() => state = null;
}

final draggedCardSizeProvider =
    NotifierProvider<DraggedCardSizeNotifier, Size?>(
      DraggedCardSizeNotifier.new,
    );
--- FILE: lib/features/agenda/providers/appointment_providers.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../core/models/appointment.dart';

/// ✅ Gestione degli appuntamenti (mock persistente in memoria)
class AppointmentsNotifier extends Notifier<List<Appointment>> {
  bool _initialized = false;

  @override
  List<Appointment> build() {
    if (!_initialized) {
      _initialized = true;
      state = _mockAppointments();
    }
    return state;
  }

  List<Appointment> _mockAppointments() {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);

    return [
      // Staff 1
      Appointment(
        id: 1,
        staffId: 1,
        clientName: 'Anna Rossi',
        serviceName: 'service name',
        startTime: today.add(const Duration(hours: 9, minutes: 10)),
        endTime: today.add(const Duration(hours: 9, minutes: 35)),
      ),
      Appointment(
        id: 2,
        staffId: 1,
        clientName: 'Luca Bianchi',
        serviceName: 'service name',
        startTime: today.add(const Duration(hours: 9, minutes: 30)),
        endTime: today.add(const Duration(hours: 10, minutes: 30)),
      ),
      Appointment(
        id: 3,
        staffId: 1,
        clientName: 'Paolo Verdi',
        serviceName: 'service name',
        startTime: today.add(const Duration(hours: 11)),
        endTime: today.add(const Duration(hours: 12)),
      ),

      // Staff 2
      Appointment(
        id: 4,
        staffId: 2,
        clientName: 'Giulia Neri',
        serviceName: 'service name',
        startTime: today.add(const Duration(hours: 10)),
        endTime: today.add(const Duration(hours: 11)),
      ),
      Appointment(
        id: 5,
        staffId: 2,
        clientName: 'Marco Gialli',
        serviceName: 'service name',
        startTime: today.add(const Duration(hours: 10, minutes: 15)),
        endTime: today.add(const Duration(hours: 10, minutes: 45)),
      ),
      Appointment(
        id: 6,
        staffId: 2,
        clientName: 'Chiara Blu',
        serviceName: 'service name',
        startTime: today.add(const Duration(hours: 14)),
        endTime: today.add(const Duration(hours: 15)),
      ),

      // Staff 3
      Appointment(
        id: 7,
        staffId: 3,
        clientName: 'Valentina',
        serviceName: 'service name',
        startTime: today.add(const Duration(hours: 9)),
        endTime: today.add(const Duration(hours: 9, minutes: 45)),
      ),
      Appointment(
        id: 8,
        staffId: 3,
        clientName: 'Francesco',
        serviceName: 'service name',
        startTime: today.add(const Duration(hours: 9, minutes: 30)),
        endTime: today.add(const Duration(hours: 10, minutes: 15)),
      ),
      Appointment(
        id: 9,
        staffId: 3,
        clientName: 'Elisa',
        serviceName: 'service name',
        startTime: today.add(const Duration(hours: 10, minutes: 30)),
        endTime: today.add(const Duration(hours: 11)),
      ),
    ];
  }

  void moveAppointment({
    required int appointmentId,
    required int newStaffId,
    required DateTime newStart,
    required DateTime newEnd,
  }) {
    state = [
      for (final a in state)
        if (a.id == appointmentId)
          a.copyWith(staffId: newStaffId, startTime: newStart, endTime: newEnd)
        else
          a,
    ];
  }
}

final appointmentsProvider =
    NotifierProvider<AppointmentsNotifier, List<Appointment>>(
      AppointmentsNotifier.new,
    );
--- FILE: lib/features/agenda/providers/is_resizing_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Provider che tiene traccia se si sta ridimensionando una AppointmentCard.
/// Utilizzato per bloccare lo scroll verticale delle colonne durante il resize.
class IsResizingNotifier extends Notifier<bool> {
  @override
  bool build() => false;

  void start() => state = true;
  void stop() => state = false;
}

final isResizingProvider = NotifierProvider<IsResizingNotifier, bool>(
  IsResizingNotifier.new,
);
--- FILE: lib/features/agenda/providers/resizing_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

class _ResizingEntry {
  final double? tempHeight;
  final DateTime? provisionalEndTime;

  const _ResizingEntry({this.tempHeight, this.provisionalEndTime});

  _ResizingEntry copyWith({double? tempHeight, DateTime? provisionalEndTime}) {
    return _ResizingEntry(
      tempHeight: tempHeight ?? this.tempHeight,
      provisionalEndTime: provisionalEndTime ?? this.provisionalEndTime,
    );
  }
}

class ResizingState {
  final Map<int, _ResizingEntry> entries;
  const ResizingState({this.entries = const {}});

  ResizingState copyWith({Map<int, _ResizingEntry>? entries}) =>
      ResizingState(entries: entries ?? this.entries);
}

class ResizingNotifier extends Notifier<ResizingState> {
  @override
  ResizingState build() => const ResizingState();

  void start(int id, double startHeight) {
    final newMap = Map<int, _ResizingEntry>.from(state.entries);
    newMap[id] = _ResizingEntry(tempHeight: startHeight);
    state = state.copyWith(entries: newMap);
  }

  void updateHeight(int id, double h) {
    final entry = state.entries[id];
    if (entry != null) {
      final newMap = Map<int, _ResizingEntry>.from(state.entries);
      newMap[id] = entry.copyWith(tempHeight: h);
      state = state.copyWith(entries: newMap);
    }
  }

  void updateProvisionalEndTime(int id, DateTime newEnd) {
    final entry = state.entries[id];
    if (entry != null) {
      final newMap = Map<int, _ResizingEntry>.from(state.entries);
      newMap[id] = entry.copyWith(provisionalEndTime: newEnd);
      state = state.copyWith(entries: newMap);
    }
  }

  void stop(int id) {
    final newMap = Map<int, _ResizingEntry>.from(state.entries);
    newMap.remove(id);
    state = state.copyWith(entries: newMap);
  }

  void clearAll() => state = const ResizingState();
}

final resizingProvider = NotifierProvider<ResizingNotifier, ResizingState>(
  ResizingNotifier.new,
);

/// 🟢 Provider selettivo: restituisce solo l’entry del singolo appointment
final resizingEntryProvider = Provider.family<_ResizingEntry?, int>((
  ref,
  appointmentId,
) {
  final state = ref.watch(resizingProvider);
  return state.entries[appointmentId];
});
--- FILE: lib/features/agenda/providers/agenda_scroll_provider.dart ---
import 'package:flutter/material.dart';
import 'package:riverpod_annotation/riverpod_annotation.dart';

import '../../../core/models/staff.dart';

part 'agenda_scroll_provider.g.dart';

/// Stato con tutti i controller di scroll sincronizzati
class AgendaScrollState {
  final ScrollController verticalScrollCtrl;
  final ScrollController horizontalScrollCtrl;
  final Map<int, ScrollController> staffScrollCtrls;

  const AgendaScrollState({
    required this.verticalScrollCtrl,
    required this.horizontalScrollCtrl,
    required this.staffScrollCtrls,
  });
}

@riverpod
class AgendaScroll extends _$AgendaScroll {
  @override
  AgendaScrollState build(List<Staff> staffList) {
    final verticalCtrl = ScrollController();
    final horizontalCtrl = ScrollController();
    final staffCtrls = {for (final s in staffList) s.id: ScrollController()};

    ref.onDispose(() {
      verticalCtrl.dispose();
      horizontalCtrl.dispose();
      for (final c in staffCtrls.values) {
        c.dispose();
      }
    });

    return AgendaScrollState(
      verticalScrollCtrl: verticalCtrl,
      horizontalScrollCtrl: horizontalCtrl,
      staffScrollCtrls: staffCtrls,
    );
  }

  /// Sincronizza orizzontalmente lo scroll (se serve)
  void syncHorizontal(double offset) {
    final st = state;
    if (st.horizontalScrollCtrl.hasClients) {
      st.horizontalScrollCtrl.jumpTo(offset);
    }
  }
}
--- FILE: lib/features/agenda/providers/staff_columns_geometry_provider.dart ---
import 'dart:ui';

import 'package:flutter_riverpod/flutter_riverpod.dart';

/// Mappa: staffId -> Rect della colonna in coordinate BODY-LOCAL
class StaffColumnsGeometryNotifier extends Notifier<Map<int, Rect>> {
  @override
  Map<int, Rect> build() => <int, Rect>{};

  void setRect(int staffId, Rect rect) {
    final next = Map<int, Rect>.from(state)..[staffId] = rect;
    state = next;
  }

  void clearFor(int staffId) {
    if (!state.containsKey(staffId)) return;
    final next = Map<int, Rect>.from(state)..remove(staffId);
    state = next;
  }

  void clearAll() => state = <int, Rect>{};
}

final staffColumnsGeometryProvider =
    NotifierProvider<StaffColumnsGeometryNotifier, Map<int, Rect>>(
      StaffColumnsGeometryNotifier.new,
    );
--- FILE: lib/features/agenda/providers/agenda_providers.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// 🔹 Notifier che tiene traccia della posizione globale del drag
class DragPositionNotifier extends Notifier<Offset?> {
  @override
  Offset? build() => null;

  void update(Offset position) => state = position;

  /// ✅ Nuovo metodo pubblico per aggiornare lo stato interpolato
  void set(Offset newValue) => state = newValue;

  void clear() => state = null;
}

final dragPositionProvider = NotifierProvider<DragPositionNotifier, Offset?>(
  DragPositionNotifier.new,
);
--- FILE: lib/features/agenda/providers/selected_appointment_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// 🔹 Tiene traccia dell'ID dell'appuntamento selezionato (clic singolo)
class SelectedAppointmentNotifier extends Notifier<int?> {
  @override
  int? build() => null;

  /// Seleziona un appuntamento; se è già selezionato, lo deseleziona
  void toggle(int id) {
    if (state == id) {
      state = null;
    } else {
      state = id;
    }
  }

  /// Deseleziona tutto
  void clear() => state = null;
}

final selectedAppointmentProvider =
    NotifierProvider<SelectedAppointmentNotifier, int?>(
      SelectedAppointmentNotifier.new,
    );
--- FILE: lib/features/agenda/providers/temp_drag_time_provider.dart ---
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// 🔹 Mantiene in memoria temporanea l'intervallo orario stimato
/// (start, end) dell'appuntamento durante il drag.
/// Viene aggiornato in tempo reale dalla StaffColumn mentre l'utente trascina
/// e letto da AppointmentCard per mostrare orari live.
class TempDragTimeNotifier extends Notifier<(DateTime, DateTime)?> {
  @override
  (DateTime, DateTime)? build() => null;

  /// Imposta un nuovo intervallo orario (start, end)
  void setTimes(DateTime start, DateTime end) {
    // aggiorna solo se cambia effettivamente lo slot di riferimento
    if (state == null ||
        state!.$1.minute != start.minute ||
        state!.$1.hour != start.hour) {
      state = (start, end);
    }
  }

  /// Resetta lo stato (nessun drag in corso)
  void clear() => state = null;
}

final tempDragTimeProvider =
    NotifierProvider<TempDragTimeNotifier, (DateTime, DateTime)?>(
      TempDragTimeNotifier.new,
    );
--- FILE: lib/features/agenda/providers/drag_layer_link_provider.dart ---
import 'package:flutter/widgets.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// 🔹 Gestisce il LayerLink del body (ancora per i feedback)
class DragLayerLinkNotifier extends Notifier<LayerLink> {
  @override
  LayerLink build() => LayerLink();

  void reset() => state = LayerLink();
}

final dragLayerLinkProvider =
    NotifierProvider<DragLayerLinkNotifier, LayerLink>(
      DragLayerLinkNotifier.new,
    );

/// 🔹 Gestisce il RenderBox del body (area scrollabile dell’agenda)
class DragBodyBoxNotifier extends Notifier<RenderBox?> {
  @override
  RenderBox? build() => null;

  void set(RenderBox box) => state = box;
  void clear() => state = null;
}

final dragBodyBoxProvider = NotifierProvider<DragBodyBoxNotifier, RenderBox?>(
  DragBodyBoxNotifier.new,
);
--- FILE: lib/features/agenda/domain/config/agenda_theme.dart ---
import 'package:flutter/material.dart';

/// Tema visivo centralizzato per l'agenda.
/// Definisce colori, spessori, altezze e stili coerenti
/// per tutti i componenti della vista agenda.
///
/// In futuro potrai adattarlo dinamicamente (dark mode, branding, ecc.)
class AgendaTheme {
  // ──────────────────────────────────────────────
  // 🎨 COLORI BASE
  // ──────────────────────────────────────────────

  /// Colore principale per i separatori verticali/orizzontali
  static Color get dividerColor => Colors.grey.shade300;

  /// Colore per ombre leggere o bordi di separazione
  static Color get shadowColor => Colors.black.withOpacity(0.5);

  /// Colore di sfondo per lo slot orario
  static const Color backgroundHourSlot = Colors.white;

  /// Colore di sfondo per le intestazioni staff
  static Color staffHeaderBackground(Color base) =>
      base.withValues(alpha: 0.15);

  /// Colore del testo nelle intestazioni staff
  static const Color staffHeaderTextColor = Colors.black87;

  /// Colore del bordo di un appuntamento (card)
  static Color get appointmentBorder => Colors.grey.shade400;

  // ──────────────────────────────────────────────
  // 💧 OMBRE & BORDI
  // ──────────────────────────────────────────────

  /// Ombra leggera usata nei divider verticali
  static BoxShadow get subtleShadow =>
      BoxShadow(color: shadowColor, offset: const Offset(1, 0), blurRadius: 2);

  /// Stile base per i separatori verticali
  static BoxDecoration get verticalDividerDecoration =>
      BoxDecoration(color: dividerColor, boxShadow: [subtleShadow]);

  /// Stile base per i separatori orizzontali
  static BoxDecoration get horizontalDividerDecoration =>
      const BoxDecoration(color: Colors.grey);

  // ──────────────────────────────────────────────
  // 🧱 STILI TESTO
  // ──────────────────────────────────────────────

  static const TextStyle staffHeaderTextStyle = TextStyle(
    fontWeight: FontWeight.bold,
    color: staffHeaderTextColor,
  );

  static const TextStyle hourTextStyle = TextStyle(
    fontSize: 13,
    fontWeight: FontWeight.w500,
    color: Colors.black87,
  );

  static const TextStyle appointmentTextStyle = TextStyle(
    fontSize: 14,
    color: Colors.black87,
  );

  // ──────────────────────────────────────────────
  // 👻 EFFETTO DRAG / FANTASMA
  // ──────────────────────────────────────────────

  /// Opacità del "fantasma" lasciato dalla card originale durante il drag.
  /// Regola questo valore per rendere il ghost più o meno visibile.
  static const double ghostOpacity = 0.50;

  /// Durata dell’effetto fade-out del fantasma dopo il rilascio.
  /// Aumentala per una dissolvenza più lenta e visibile.
  static const Duration ghostFadeDuration = Duration(milliseconds: 500);
}
--- FILE: lib/features/agenda/domain/config/layout_config.dart ---
import 'package:flutter/material.dart';

class LayoutConfig {
  // ──────────────────────────────────────────────
  // 📐 DIMENSIONI STRUTTURALI
  // ──────────────────────────────────────────────

  static const double hourColumnWidth = 70;

  /// Altezza iniziale di default della barra header
  static double _headerHeight = 50;

  /// Getter per l’altezza corrente dell’header
  static double get headerHeight => _headerHeight;

  /// Aggiorna dinamicamente l’altezza dell’header
  static void updateHeaderHeight(double newHeight) {
    _headerHeight = newHeight;
  }

  static const int hoursInDay = 24;

  static const double horizontalPadding = 8;
  static const double verticalPadding = 4;

  /// 🔹 Larghezza minima garantita per ogni colonna staff
  static const double minColumnWidth = 180;

  /// 🔹 [maxColumnWidth] rimosso: le colonne si espandono liberamente

  static const double borderRadius = 8;

  // ──────────────────────────────────────────────
  // ⏱️ CONFIGURAZIONE SLOT TEMPORALI
  // ──────────────────────────────────────────────

  static const int minutesPerSlot = 15;

  static double _slotHeight = 30;

  static double get slotHeight => _slotHeight;

  static int get totalSlots => (hoursInDay * 60 ~/ minutesPerSlot);

  static double get totalHeight => totalSlots * _slotHeight;

  static void updateSlotHeight(double newHeight) {
    _slotHeight = newHeight;
  }

  // ──────────────────────────────────────────────
  // ⚙️ CALCOLI DINAMICI
  // ──────────────────────────────────────────────

  /// Calcola quanti staff possono essere mostrati in base alla larghezza schermo
  static int computeMaxVisibleStaff(double screenWidth) {
    final availableWidth = screenWidth - hourColumnWidth;
    final maxStaff = (availableWidth / minColumnWidth).floor();
    return maxStaff.clamp(1, 6);
  }

  /// 🔸 Calcola dinamicamente la larghezza di ogni colonna staff
  /// per riempire tutto lo spazio disponibile senza superare un minimo.
  static double computeAdaptiveColumnWidth({
    required double screenWidth,
    required int visibleStaffCount,
  }) {
    if (visibleStaffCount <= 0) return minColumnWidth;

    final availableWidth = screenWidth - hourColumnWidth;
    final idealWidth = availableWidth / visibleStaffCount;

    // 👇 Solo limite minimo
    return idealWidth < minColumnWidth ? minColumnWidth : idealWidth;
  }

  /// Altezza header “responsive” basata sulla larghezza finestra.
  static double headerHeightFor(BuildContext context) {
    final width = MediaQuery.of(context).size.width;
    if (width >= 1024) return 56; // Desktop
    if (width >= 600) return 52; // Tablet
    return 48; // Mobile
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/current_time_line.dart ---
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/config/layout_config.dart';
import '../../../providers/layout_config_provider.dart';

/// 🔹 Widget autonomo che disegna e aggiorna la riga rossa dell’orario corrente
class CurrentTimeLine extends ConsumerStatefulWidget {
  final double hourColumnWidth;

  const CurrentTimeLine({super.key, required this.hourColumnWidth});

  @override
  ConsumerState<CurrentTimeLine> createState() => _CurrentTimeLineState();
}

class _CurrentTimeLineState extends ConsumerState<CurrentTimeLine> {
  Timer? _minuteTimer;
  double _offset = 0;
  String _label = '';
  late final ProviderSubscription<double> _slotHeightSub;

  @override
  void initState() {
    super.initState();
    _slotHeightSub = ref.listenManual<double>(
      layoutConfigProvider,
      (previous, next) => _updateLine(slotHeightOverride: next),
      fireImmediately: true,
    );
    _scheduleMinuteSync();
  }

  void _scheduleMinuteSync() {
    final now = DateTime.now();
    final msToNextMinute = 60000 - (now.second * 1000 + now.millisecond);

    _minuteTimer = Timer(Duration(milliseconds: msToNextMinute), () {
      _updateLine();
      _minuteTimer?.cancel();
      _minuteTimer = Timer.periodic(const Duration(minutes: 1), (_) {
        _updateLine();
      });
    });
  }

  void _updateLine({double? slotHeightOverride}) {
    final now = DateTime.now();
    final minutesSinceMidnight = now.hour * 60 + now.minute;
    final double slotHeight =
        slotHeightOverride ?? ref.read(layoutConfigProvider);
    final offset =
        (minutesSinceMidnight / LayoutConfig.minutesPerSlot) * slotHeight;
    final label =
        "${now.hour.toString().padLeft(2, '0')}:${now.minute.toString().padLeft(2, '0')}";

    if (mounted) {
      setState(() {
        _offset = offset;
        _label = label;
      });
    }
  }

  @override
  void dispose() {
    _minuteTimer?.cancel();
    _slotHeightSub.close();
    super.dispose();
  }

  // In lib/features/agenda/presentation/screens/widgets/current_time_line.dart

  @override
  Widget build(BuildContext context) {
    // 1. La linea viene posizionata esattamente a _offset
    return Positioned(
      top: _offset,
      left: 0,
      right: 0,
      // Usiamo uno Stack per sovrapporre la linea e il testo
      child: Stack(
        clipBehavior: Clip.none, // Permette al testo di "uscire"
        children: [
          // 2. Questa è la linea rossa
          Container(
            height: 0.5, // Manteniamo un'altezza minima per la visibilità
            color: Colors.redAccent,
            // Lasciamo lo spazio per la colonna degli orari
            margin: EdgeInsets.only(left: widget.hourColumnWidth),
          ),

          // 3. Posizioniamo il testo e il pallino RELATIVAMENTE alla linea
          Positioned(
            left: 0,
            // Centriamo il testo verticalmente sulla linea.
            // (L'altezza del testo è 11 , quindi -5.5 è circa il centro)
            top: -6,
            child: SizedBox(
              width: widget.hourColumnWidth,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.end,
                crossAxisAlignment:
                    CrossAxisAlignment.center, // Centra pallino e testo
                children: [
                  Container(
                    width: 8,
                    height: 8,
                    decoration: const BoxDecoration(
                      color: Colors.redAccent,
                      shape: BoxShape.circle,
                    ),
                  ),
                  const SizedBox(width: 4),
                  Text(
                    _label,
                    style: const TextStyle(
                      color: Colors.redAccent,
                      fontSize: 11,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                  const SizedBox(width: 4),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/agenda_dividers.dart ---
import 'package:flutter/material.dart';

/// Divider verticale sottile tra la colonna oraria e le colonne staff
class AgendaVerticalDivider extends StatelessWidget {
  final double height;
  final Color color;
  final double thickness;

  const AgendaVerticalDivider({
    super.key,
    required this.height,
    this.color = const Color(0xFFBDBDBD),
    this.thickness = 0.5,
  });

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: height,
      width: thickness,
      child: DecoratedBox(decoration: BoxDecoration(color: color)),
    );
  }
}

/// Divider orizzontale usato per le righe orarie
class AgendaHorizontalDivider extends StatelessWidget {
  final double thickness;
  final Color color;

  const AgendaHorizontalDivider({
    super.key,
    this.thickness = 0.5,
    this.color = const Color(0xFFBDBDBD),
  });

  @override
  Widget build(BuildContext context) {
    return Divider(height: thickness, thickness: thickness, color: color);
  }
}
--- FILE: lib/features/agenda/presentation/screens/widgets/appointment_card.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/models/appointment.dart';
import '../../../domain/config/agenda_theme.dart';
import '../../../domain/config/layout_config.dart';
import '../../../providers/agenda_providers.dart';
import '../../../providers/appointment_providers.dart';
import '../../../providers/drag_layer_link_provider.dart';
import '../../../providers/drag_offset_provider.dart';
import '../../../providers/dragged_appointment_provider.dart';
import '../../../providers/highlighted_staff_provider.dart';
import '../../../providers/is_resizing_provider.dart';
import '../../../providers/resizing_provider.dart';
import '../../../providers/selected_appointment_provider.dart';
import '../../../providers/staff_columns_geometry_provider.dart';
import '../../../providers/temp_drag_time_provider.dart';

class AppointmentCard extends ConsumerStatefulWidget {
  final Appointment appointment;
  final Color color;
  final double? columnWidth;
  final bool expandToLeft;

  const AppointmentCard({
    super.key,
    required this.appointment,
    required this.color,
    this.columnWidth,
    this.expandToLeft = false,
  });

  @override
  ConsumerState<AppointmentCard> createState() => _AppointmentCardState();
}

class _AppointmentCardState extends ConsumerState<AppointmentCard> {
  Size? _lastSize;
  Offset? _lastPointerGlobalPosition;
  double? _tempHeight;
  double? _initialHeight;
  bool _isDraggingResize = false;

  @override
  Widget build(BuildContext context) {
    final selectedId = ref.watch(selectedAppointmentProvider);
    final draggedId = ref.watch(draggedAppointmentIdProvider);
    final isSelected = selectedId == widget.appointment.id;
    final isDragging = draggedId == widget.appointment.id;
    final showThickBorder = isSelected || isDragging;

    return LayoutBuilder(
      builder: (context, constraints) {
        WidgetsBinding.instance.addPostFrameCallback((_) {
          final size = Size(constraints.maxWidth, constraints.maxHeight);
          if (mounted && (_lastSize == null || _lastSize != size)) {
            setState(() => _lastSize = size);
          }
        });

        return Listener(
          onPointerDown: (e) {
            final cardBox = context.findRenderObject() as RenderBox?;
            if (cardBox != null) {
              _lastPointerGlobalPosition = e.position;

              final bodyBox = ref.read(dragBodyBoxProvider);
              if (bodyBox != null) {
                final cardTopLeftGlobal = cardBox.localToGlobal(Offset.zero);
                ref
                    .read(dragOffsetProvider.notifier)
                    .set(e.position.dy - cardTopLeftGlobal.dy);
                ref
                    .read(dragOffsetXProvider.notifier)
                    .set(e.position.dx - cardTopLeftGlobal.dx);
                final localStart = bodyBox.globalToLocal(e.position);
                ref.read(dragPositionProvider.notifier).set(localStart);
              }
            }
          },

          child: GestureDetector(
            onTap: () {
              final resizing = ref.read(isResizingProvider);
              if (!resizing) {
                final notifier = ref.read(selectedAppointmentProvider.notifier);
                notifier.clear();
                notifier.toggle(widget.appointment.id);

                ref.read(dragOffsetProvider.notifier).clear();
                ref.read(dragOffsetXProvider.notifier).clear();
                ref.read(dragPositionProvider.notifier).clear();
                ref.read(highlightedStaffIdProvider.notifier).clear();
              }
            },

            child: LongPressDraggable<Appointment>(
              data: widget.appointment,
              feedback: Consumer(
                builder: (c, r, _) => _buildFollowerFeedback(c, r),
              ),
              feedbackOffset: Offset.zero,
              dragAnchorStrategy: childDragAnchorStrategy,
              hapticFeedbackOnStart: false,
              childWhenDragging: _buildCard(
                isGhost: true,
                showThickBorder: showThickBorder,
              ),
              onDragStarted: () {
                final selected = ref.read(selectedAppointmentProvider.notifier);
                selected.clear();
                selected.toggle(widget.appointment.id);
                ref
                    .read(draggedAppointmentIdProvider.notifier)
                    .set(widget.appointment.id);

                final bodyBox = ref.read(dragBodyBoxProvider);
                if (bodyBox != null && _lastPointerGlobalPosition != null) {
                  final local = bodyBox.globalToLocal(
                    _lastPointerGlobalPosition!,
                  );
                  ref.read(dragPositionProvider.notifier).set(local);
                }
              },
              onDragUpdate: (details) {
                final prev = ref.read(dragPositionProvider);
                final bodyBox = ref.read(dragBodyBoxProvider);
                if (bodyBox != null) {
                  final local = bodyBox.globalToLocal(details.globalPosition);
                  ref
                      .read(dragPositionProvider.notifier)
                      .set(Offset.lerp(prev, local, 0.85)!);
                }
              },
              onDragEnd: (_) => _handleEnd(ref),
              onDragCompleted: () => _handleEnd(ref),
              onDraggableCanceled: (_, __) => _handleEnd(ref),
              child: _buildCard(
                showThickBorder: showThickBorder,
                isResizingDisabled: isDragging,
              ),
            ),
          ),
        );
      },
    );
  }

  void _handleEnd(WidgetRef ref) {
    ref.read(draggedAppointmentIdProvider.notifier).clear();
    ref.read(dragOffsetProvider.notifier).clear();
    ref.read(dragOffsetXProvider.notifier).clear();
    ref.read(dragPositionProvider.notifier).clear();
    ref.read(tempDragTimeProvider.notifier).clear();
    ref.read(selectedAppointmentProvider.notifier).clear();
  }

  Widget _buildCard({
    bool isGhost = false,
    bool forFeedback = false,
    bool showThickBorder = false,
    bool isResizingDisabled = false,
    DateTime? overrideStart,
    DateTime? overrideEnd,
  }) {
    final entry = ref.watch(resizingEntryProvider(widget.appointment.id));

    final baseColor = widget.color.withOpacity(0.15);
    const r = BorderRadius.all(Radius.circular(6));
    final startTime = overrideStart ?? widget.appointment.startTime;
    final endTime =
        entry?.provisionalEndTime ?? overrideEnd ?? widget.appointment.endTime;

    final start = _formatTime(startTime);
    final end = _formatTime(endTime);

    final client = widget.appointment.clientName;

    final pieces = <String>[];
    if (widget.appointment.serviceName.isNotEmpty) {
      pieces.add(widget.appointment.serviceName);
    }
    if (widget.appointment.formattedPrice.isNotEmpty) {
      pieces.add(widget.appointment.formattedPrice);
    }
    final info = pieces.join(' – ');
    final borderWidth = showThickBorder ? 2.5 : 1.0;

    final animationDuration = _isDraggingResize || forFeedback
        ? Duration.zero
        : const Duration(milliseconds: 80);
    final animationCurve = _isDraggingResize || forFeedback
        ? Curves.linear
        : Curves.easeOutQuad;

    return Opacity(
      opacity: isGhost ? AgendaTheme.ghostOpacity : 1,
      child: Material(
        borderRadius: r,
        color: Colors.transparent,
        child: AnimatedContainer(
          duration: animationDuration,
          curve: animationCurve,
          decoration: BoxDecoration(
            color: Color.alphaBlend(baseColor, Colors.white),
            borderRadius: r,
            border: Border.all(color: widget.color, width: borderWidth),
            boxShadow: [
              BoxShadow(
                color: widget.color.withOpacity(showThickBorder ? 0.25 : 0.1),
                blurRadius: showThickBorder ? 8 : 4,
                offset: showThickBorder
                    ? const Offset(2, 3)
                    : const Offset(1, 1),
              ),
            ],
          ),
          child: Stack(
            children: [
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 4),
                child: Align(
                  alignment: Alignment.topLeft,
                  child: _buildContent(start, end, client, info),
                ),
              ),
              if (!forFeedback && !isResizingDisabled) _buildResizeHandle(),
            ],
          ),
        ),
      ),
    );
  }

  String _formatTime(DateTime time) {
    // Se è 23:59 o 23:59:59 → mostra come 24:00
    if (time.hour == 23 && time.minute >= 59) return '24:00';
    return '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';
  }

  Widget _buildContent(String start, String end, String client, String info) {
    return ClipRect(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          Flexible(
            child: RichText(
              maxLines: 1,
              softWrap: false,
              overflow: TextOverflow.ellipsis,
              text: TextSpan(
                children: [
                  TextSpan(
                    text: '$start - $end  ',
                    style: const TextStyle(
                      color: Colors.black87,
                      fontWeight: FontWeight.w700,
                    ),
                  ),
                  TextSpan(
                    text: client,
                    style: const TextStyle(
                      color: Colors.grey,
                      fontWeight: FontWeight.w600,
                    ),
                  ),
                ],
              ),
            ),
          ),
          if (info.isNotEmpty)
            Flexible(
              child: Text(
                info,
                maxLines: 1,
                softWrap: false,
                overflow: TextOverflow.ellipsis,
                style: const TextStyle(
                  fontSize: 11,
                  color: Colors.black54,
                  height: 1.1,
                ),
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildResizeHandle() {
    return Align(
      alignment: Alignment.bottomCenter,
      child: MouseRegion(
        cursor: SystemMouseCursors.resizeUpDown,
        child: GestureDetector(
          behavior: HitTestBehavior.opaque,
          onVerticalDragStart: (_) {
            final h = _lastSize?.height ?? 0;
            _initialHeight = h;
            ref.read(isResizingProvider.notifier).start();
            ref.read(resizingProvider.notifier).start(widget.appointment.id, h);
            setState(() {
              _isDraggingResize = true;
              _tempHeight = h;
            });
          },
          onVerticalDragUpdate: (details) {
            final previous = _tempHeight ?? _lastSize?.height ?? 0;
            final next = (previous + details.delta.dy)
                .clamp(20, double.infinity)
                .toDouble();

            setState(() => _tempHeight = next);
            ref
                .read(resizingProvider.notifier)
                .updateHeight(widget.appointment.id, next);

            final appt = widget.appointment;
            final minutesPerPixel =
                LayoutConfig.minutesPerSlot / LayoutConfig.slotHeight;
            final baseHeight = _initialHeight ?? _lastSize?.height ?? 0;
            final deltaPixels = next - baseHeight;

            final deltaMinutesRaw = (deltaPixels * minutesPerPixel);
            final deltaMinutes = ((deltaMinutesRaw / 5).round() * 5).toInt();

            final previewEnd = appt.endTime.add(
              Duration(minutes: deltaMinutes),
            );
            ref
                .read(resizingProvider.notifier)
                .updateProvisionalEndTime(widget.appointment.id, previewEnd);
          },
          onVerticalDragEnd: (_) {
            final appt = widget.appointment;
            final notifier = ref.read(appointmentsProvider.notifier);
            final minutesPerPixel =
                LayoutConfig.minutesPerSlot / LayoutConfig.slotHeight;
            final baseHeight = _initialHeight ?? _lastSize?.height ?? 0;
            final deltaPixels = (_tempHeight ?? baseHeight) - baseHeight;
            final deltaMinutes = (deltaPixels * minutesPerPixel).round();

            if (deltaMinutes.abs() >= 5) {
              final steps = (deltaMinutes ~/ 5);
              final newEnd = appt.endTime.add(Duration(minutes: steps * 5));
              final minEnd = appt.startTime.add(const Duration(minutes: 5));

              ref
                  .read(resizingProvider.notifier)
                  .updateProvisionalEndTime(widget.appointment.id, newEnd);

              notifier.moveAppointment(
                appointmentId: appt.id,
                newStaffId: appt.staffId,
                newStart: appt.startTime,
                newEnd: newEnd.isAfter(minEnd) ? newEnd : minEnd,
              );

              WidgetsBinding.instance.addPostFrameCallback((_) {
                if (mounted) setState(() {});
              });
            }

            setState(() {
              _isDraggingResize = false;
              _tempHeight = null;
            });

            ref.read(isResizingProvider.notifier).stop();
          },
          child: Container(
            height: 20,
            width: double.infinity,
            alignment: Alignment.bottomCenter,
            child: const Padding(
              padding: EdgeInsets.only(bottom: 1),
              child: Icon(Icons.drag_indicator, size: 14, color: Colors.grey),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildFollowerFeedback(BuildContext context, WidgetRef ref) {
    final times = ref.watch(tempDragTimeProvider);
    final start = times?.$1;
    final end = times?.$2;
    final dragPos = ref.watch(dragPositionProvider);
    final offY = ref.watch(dragOffsetProvider) ?? 0;
    final offX = ref.watch(dragOffsetXProvider) ?? 0;
    final link = ref.watch(dragLayerLinkProvider);
    final highlightedId = ref.watch(highlightedStaffIdProvider);
    final columnsRects = ref.watch(staffColumnsGeometryProvider);

    final w = widget.columnWidth ?? _lastSize?.width ?? 180.0;
    final h = _lastSize?.height ?? 50.0;
    final hourW = LayoutConfig.hourColumnWidth;
    if (dragPos == null) return const SizedBox.shrink();

    double top = dragPos.dy - offY;
    if (top < 0) top = 0;

    // 🔹 Calcola l’altezza totale effettiva del body scrollabile
    final bodyBox = ref.read(dragBodyBoxProvider);
    final totalHeight = bodyBox?.size.height ?? LayoutConfig.totalHeight;
    final cardHeight = h;

    // 🔹 Impedisce di superare la fine dell’area visibile (ancora inferiore)
    if (top + cardHeight > totalHeight) {
      top = totalHeight - cardHeight;
    }

    // 🔹 Sicurezza extra nel caso di overflow negativo
    if (top < 0) top = 0;

    double left;
    final rect = highlightedId != null ? columnsRects[highlightedId] : null;
    if (rect != null) {
      left = rect.left + (rect.width - w) / 2;
      if (left < hourW) left = hourW;
    } else {
      left = dragPos.dx - offX;
      if (widget.expandToLeft) left -= (w / 2);
      if (left < hourW) left = hourW;
    }

    final dpr = MediaQuery.of(context).devicePixelRatio;
    left = (left * dpr).round() / dpr;
    top = (top * dpr).round() / dpr;

    return RepaintBoundary(
      child: CompositedTransformFollower(
        link: link,
        showWhenUnlinked: false,
        offset: Offset(left, top),
        child: Material(
          color: Colors.transparent,
          borderRadius: const BorderRadius.all(Radius.circular(6)),
          clipBehavior: Clip.antiAlias,
          child: ConstrainedBox(
            constraints: BoxConstraints(
              minWidth: w - 4,
              maxWidth: w - 4,
              minHeight: h,
              maxHeight: h,
            ),
            child: _buildCard(
              forFeedback: true,
              showThickBorder: true,
              overrideStart: start,
              overrideEnd: end,
            ),
          ),
        ),
      ),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/hour_column.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/config/agenda_theme.dart';
import '../../../domain/config/layout_config.dart';
import '../../../providers/layout_config_provider.dart';
import '../widgets/agenda_dividers.dart';

class HourColumn extends ConsumerWidget {
  const HourColumn({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final slotHeight = ref.watch(layoutConfigProvider);
    final totalSlots = LayoutConfig.totalSlots;
    final slotsPerHour = (60 ~/ LayoutConfig.minutesPerSlot);

    return Column(
      children: List.generate(totalSlots, (index) {
        final isHourStart = index % slotsPerHour == 0;
        final isMainLine = (index + 1) % slotsPerHour == 0;
        final hour = (index ~/ slotsPerHour);
        final minutes = (index % slotsPerHour) * LayoutConfig.minutesPerSlot;

        return SizedBox(
          height: slotHeight,
          child: Stack(
            children: [
              if (isHourStart)
                Positioned(
                  left: 8,
                  top: 0,
                  child: Text(
                    "${hour.toString().padLeft(2, '0')}:${minutes.toString().padLeft(2, '0')}",
                    style: AgendaTheme.hourTextStyle,
                  ),
                ),
              Align(
                alignment: Alignment.bottomLeft,
                child: AgendaHorizontalDivider(
                  color: Colors.grey.withOpacity(isMainLine ? 0.5 : 0.2),
                  thickness: isMainLine ? 1 : 0.5,
                ),
              ),
            ],
          ),
        );
      }),
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/staff_column.dart ---
import 'package:agenda_frontend/features/agenda/providers/dragged_card_size_provider.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '/core/models/appointment.dart';
import '/core/models/staff.dart';
import '../../../domain/config/agenda_theme.dart';
import '../../../domain/config/layout_config.dart';
import '../../../providers/agenda_providers.dart';
import '../../../providers/appointment_providers.dart';
import '../../../providers/drag_layer_link_provider.dart';
import '../../../providers/drag_offset_provider.dart';
import '../../../providers/dragged_appointment_provider.dart';
import '../../../providers/highlighted_staff_provider.dart';
import '../../../providers/layout_config_provider.dart';
import '../../../providers/resizing_provider.dart';
import '../../../providers/staff_columns_geometry_provider.dart';
import '../../../providers/temp_drag_time_provider.dart';
import '../widgets/agenda_dividers.dart';
import '../widgets/appointment_card.dart';

class StaffColumn extends ConsumerStatefulWidget {
  final Staff staff;
  final List<Appointment> appointments;
  final double columnWidth;
  final bool showRightBorder;

  const StaffColumn({
    super.key,
    required this.staff,
    required this.appointments,
    required this.columnWidth,
    this.showRightBorder = true,
  });

  @override
  ConsumerState<StaffColumn> createState() => _StaffColumnState();
}

class _StaffColumnState extends ConsumerState<StaffColumn> {
  bool _isHighlighted = false;
  double? _hoverY;
  late final ProviderSubscription<Offset?> _dragListener;

  @override
  void initState() {
    super.initState();

    _dragListener = ref.listenManual<Offset?>(dragPositionProvider, (
      previous,
      next,
    ) {
      if (!mounted) return;

      final highlightNotifier = ref.read(highlightedStaffIdProvider.notifier);
      final tempTimeNotifier = ref.read(tempDragTimeProvider.notifier);

      if (next == null) {
        if (_isHighlighted || _hoverY != null) {
          setState(() {
            _isHighlighted = false;
            _hoverY = null;
          });
        }
        highlightNotifier.clear();
        tempTimeNotifier.clear();
        return;
      }

      final box = context.findRenderObject() as RenderBox?;
      final bodyBox = ref.read(dragBodyBoxProvider);
      if (box == null || bodyBox == null) return;

      final columnTopLeftInBody = bodyBox.globalToLocal(
        box.localToGlobal(Offset.zero),
      );
      ref
          .read(staffColumnsGeometryProvider.notifier)
          .setRect(
            widget.staff.id,
            Rect.fromLTWH(
              columnTopLeftInBody.dx,
              columnTopLeftInBody.dy,
              box.size.width,
              box.size.height,
            ),
          );

      final localInColumn = Offset(
        next.dx - columnTopLeftInBody.dx,
        next.dy - columnTopLeftInBody.dy,
      );

      final inside =
          localInColumn.dx >= 0 &&
          localInColumn.dy >= 0 &&
          localInColumn.dx <= box.size.width &&
          localInColumn.dy <= box.size.height;

      if (inside) {
        final dragOffset = ref.read(dragOffsetProvider);

        // 🔹 Altezza effettiva della card trascinata (fallback 50px se non nota)
        final draggedCardHeightPx =
            ref.read(draggedCardSizeProvider)?.height ?? 50.0;

        // 🔹 Punto massimo CONSENTITO per l'inizio della card in pixel
        final maxYStartPx = (box.size.height - draggedCardHeightPx)
            .clamp(0, box.size.height)
            .toDouble();

        // 🔹 Y effettiva del "top" della card, clampata ai limiti verticali
        final double effectiveY = (localInColumn.dy - (dragOffset ?? 0))
            .clamp(0, maxYStartPx)
            .toDouble();

        setState(() {
          _hoverY = effectiveY;
          _isHighlighted = true;
        });
        highlightNotifier.set(widget.staff.id);

        // ─────────────────────────────────────────
        // ⏱ Calcolo orario proposto
        // ─────────────────────────────────────────
        final slotHeight = LayoutConfig.slotHeight;

        // minuti dall'inizio giornata (00:00)
        final minutesFromTop =
            (effectiveY / slotHeight) * LayoutConfig.minutesPerSlot;

        // arrotondiamo a step di 5 minuti
        double roundedMinutes = (minutesFromTop / 5).round() * 5;

        // durata dell'appuntamento trascinato
        final draggedId = ref.read(draggedAppointmentIdProvider);
        Duration duration;
        if (draggedId != null) {
          final appt = ref
              .read(appointmentsProvider)
              .firstWhere((a) => a.id == draggedId);
          duration = appt.endTime.difference(appt.startTime);
        } else {
          duration = const Duration(minutes: 30);
        }

        final durationMinutes = duration.inMinutes;

        // 🔒 Limite massimo per l'inizio in minuti:
        final dayMinutes = LayoutConfig.hoursInDay * 60; // 24 * 60 = 1440
        final maxStartMinutes = (dayMinutes - durationMinutes).clamp(
          0,
          dayMinutes,
        );

        // --- ✅ FIX #1: blocco fine oltre 24:00 ---
        final endMinutes = roundedMinutes + durationMinutes;
        if (endMinutes > dayMinutes) {
          roundedMinutes = (dayMinutes - durationMinutes).toDouble();

          // ✅ correzione extra: forza minuto a 0 all'ultimo slot visivo
          final lastHourStart = dayMinutes - 60; // 1380 = 23:00
          if (roundedMinutes >= lastHourStart) {
            roundedMinutes = lastHourStart.toDouble(); // fissa a 23:00
          }
        }

        // clamp finale dell'orario di inizio
        if (roundedMinutes > maxStartMinutes) {
          roundedMinutes = maxStartMinutes.toDouble();
        } else if (roundedMinutes < 0) {
          roundedMinutes = 0;
        }

        // costruiamo gli orari da mostrare nella card fantasma
        final today = DateTime.now();
        final start = DateTime(
          today.year,
          today.month,
          today.day,
        ).add(Duration(minutes: roundedMinutes.toInt()));

        final end = start.add(duration);

        // aggiorna l'anteprima oraria mostrata nella card fantasma
        tempTimeNotifier.setTimes(start, end);
      } else if (_isHighlighted) {
        final headerHeight = LayoutConfig.headerHeight;
        final globalY = next.dy;
        if (globalY > headerHeight - 5) return;

        setState(() {
          _isHighlighted = false;
          _hoverY = null;
        });
        highlightNotifier.clear();
        tempTimeNotifier.clear();
      }
    }, fireImmediately: false);
  }

  @override
  void dispose() {
    _dragListener.close();
    final highlightedId = ref.read(highlightedStaffIdProvider);
    if (highlightedId == widget.staff.id) {
      ref.read(highlightedStaffIdProvider.notifier).clear();
    }
    ref.read(staffColumnsGeometryProvider.notifier).clearFor(widget.staff.id);
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final allAppointments = ref.watch(appointmentsProvider);
    final staffAppointments = allAppointments
        .where((a) => a.staffId == widget.staff.id)
        .toList();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      final box = context.findRenderObject() as RenderBox?;
      final bodyBox = ref.read(dragBodyBoxProvider);
      if (box != null && bodyBox != null) {
        final topLeft = bodyBox.globalToLocal(box.localToGlobal(Offset.zero));
        ref
            .read(staffColumnsGeometryProvider.notifier)
            .setRect(
              widget.staff.id,
              Rect.fromLTWH(
                topLeft.dx,
                topLeft.dy,
                box.size.width,
                box.size.height,
              ),
            );
      }
    });

    final slotHeight = ref.watch(layoutConfigProvider);
    final totalSlots = LayoutConfig.totalSlots;
    final appointmentsNotifier = ref.read(appointmentsProvider.notifier);

    final stackChildren = <Widget>[];

    // 🔹 Griglia oraria
    stackChildren.add(
      Column(
        children: List.generate(totalSlots, (index) {
          final slotsPerHour = 60 ~/ LayoutConfig.minutesPerSlot;
          final isHourStart = (index + 1) % slotsPerHour == 0;
          return SizedBox(
            height: slotHeight,
            child: Align(
              alignment: Alignment.bottomLeft,
              child: AgendaHorizontalDivider(
                color: Colors.grey.withOpacity(isHourStart ? 0.5 : 0.2),
                thickness: isHourStart ? 1 : 0.5,
              ),
            ),
          );
        }),
      ),
    );

    // 🔹 Appuntamenti
    stackChildren.addAll(_buildAppointments(slotHeight, staffAppointments));

    return DragTarget<Appointment>(
      onWillAcceptWithDetails: (_) {
        setState(() => _isHighlighted = true);
        ref.read(highlightedStaffIdProvider.notifier).set(widget.staff.id);
        return true;
      },
      onLeave: (_) {
        setState(() => _isHighlighted = false);
        ref.read(highlightedStaffIdProvider.notifier).clear();
      },
      onAcceptWithDetails: (details) {
        setState(() {
          _isHighlighted = false;
          _hoverY = null;
        });
        ref.read(highlightedStaffIdProvider.notifier).clear();
        ref.read(tempDragTimeProvider.notifier).clear();

        final box = context.findRenderObject() as RenderBox?;
        if (box == null) return;

        final localPosition = box.globalToLocal(details.offset);
        double effectiveDy = localPosition.dy;
        if (effectiveDy <= 0.0) effectiveDy = 0.1;

        final minutesFromTop =
            (effectiveDy / slotHeight) * LayoutConfig.minutesPerSlot;
        double roundedMinutes = (minutesFromTop / 5).round() * 5;

        final duration = details.data.endTime.difference(
          details.data.startTime,
        );
        final durationMinutes = duration.inMinutes;

        // ✅ Data base dell'app originale
        final baseDate = DateTime(
          details.data.startTime.year,
          details.data.startTime.month,
          details.data.startTime.day,
        );

        // Calcolo nuovo start in minuti
        DateTime newStart = baseDate.add(
          Duration(minutes: roundedMinutes.toInt()),
        );

        DateTime newEnd = newStart.add(duration);

        // --- ✅ FIX: non andare oltre la giornata corrente ---
        final endOfDay = DateTime(
          baseDate.year,
          baseDate.month,
          baseDate.day,
          23,
          59,
          59,
        );

        if (newEnd.isAfter(endOfDay)) {
          newEnd = endOfDay;
          newStart = newEnd.subtract(Duration(minutes: durationMinutes));

          // ✅ correzione visiva: se finisce a 23:59, aggancia inizio all'ora piena
          if (newStart.minute == 59) {
            newStart = DateTime(
              newStart.year,
              newStart.month,
              newStart.day,
              newStart.hour + 1,
              0,
            );
          }
        }

        appointmentsNotifier.moveAppointment(
          appointmentId: details.data.id,
          newStaffId: widget.staff.id,
          newStart: newStart,
          newEnd: newEnd,
        );
      },
      builder: (context, candidateData, rejectedData) {
        return SizedBox(
          width: widget.columnWidth,
          child: Container(
            decoration: BoxDecoration(
              color: _isHighlighted
                  ? widget.staff.color.withOpacity(0.01)
                  : Colors.transparent,
              border: widget.showRightBorder
                  ? Border(
                      right: BorderSide(
                        color: Colors.grey.withOpacity(0.5),
                        width: 0.5,
                      ),
                    )
                  : null,
            ),
            child: Stack(children: stackChildren),
          ),
        );
      },
    );
  }

  List<Widget> _buildAppointments(
    double slotHeight,
    List<Appointment> appointments,
  ) {
    final draggedId = ref.watch(draggedAppointmentIdProvider);

    final List<List<Appointment>> overlapGroups = [];

    for (final appt in appointments) {
      bool added = false;
      for (final group in overlapGroups) {
        if (group.any(
          (g) =>
              appt.startTime.isBefore(g.endTime) &&
              appt.endTime.isAfter(g.startTime),
        )) {
          group.add(appt);
          added = true;
          break;
        }
      }
      if (!added) overlapGroups.add([appt]);
    }

    final positionedAppointments = <Widget>[];

    for (final group in overlapGroups) {
      final groupSize = group.length;
      for (int i = 0; i < groupSize; i++) {
        final a = group[i];
        final isDragged = a.id == draggedId;

        final startMinutes = a.startTime.hour * 60 + a.startTime.minute;
        final endMinutes = a.endTime.hour * 60 + a.endTime.minute;

        final double top =
            (startMinutes / LayoutConfig.minutesPerSlot) * slotHeight;
        double height =
            ((endMinutes - startMinutes) / LayoutConfig.minutesPerSlot) *
            slotHeight;

        final entry = ref.watch(resizingEntryProvider(a.id));
        if (entry != null) {
          if (a.endTime != entry.provisionalEndTime) {
            if (entry.tempHeight != null) height = entry.tempHeight!;
          } else {
            WidgetsBinding.instance.addPostFrameCallback((_) {
              ref.read(resizingProvider.notifier).stop(a.id);
            });
          }
        }

        double widthFraction = 1 / groupSize;
        double leftFraction = i * widthFraction;
        double opacity = isDragged ? AgendaTheme.ghostOpacity : 1.0;

        positionedAppointments.add(
          Positioned(
            top: top,
            left: leftFraction * widget.columnWidth + 2,
            width: widget.columnWidth * widthFraction - 4,
            height: height,
            child: Opacity(
              opacity: opacity,
              child: AppointmentCard(
                appointment: a,
                color: widget.staff.color,
                columnWidth: widget.columnWidth,
                expandToLeft: i > 0,
              ),
            ),
          ),
        );
      }
    }

    return positionedAppointments;
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/responsive_layout.dart ---
import 'package:flutter/material.dart';

import '../../../domain/config/layout_config.dart';

class ResponsiveLayout {
  final double columnWidth;
  final double slotHeight;
  final int maxVisibleStaff;

  const ResponsiveLayout({
    required this.columnWidth,
    required this.slotHeight,
    required this.maxVisibleStaff,
  });

  static ResponsiveLayout of(BuildContext context, {required int staffCount}) {
    final screenWidth = MediaQuery.of(context).size.width;
    final screenHeight = MediaQuery.of(context).size.height;

    // ──────────────────────────────────────────────
    // 📐 Calcolo larghezza colonne staff
    // ──────────────────────────────────────────────
    final dynamicMaxVisible = LayoutConfig.computeMaxVisibleStaff(screenWidth);

    final availableWidth = screenWidth - LayoutConfig.hourColumnWidth;
    final rawWidth = availableWidth / staffCount.clamp(1, dynamicMaxVisible);

    // 🔸 Solo limite minimo: niente limite massimo
    final columnWidth = rawWidth < LayoutConfig.minColumnWidth
        ? LayoutConfig.minColumnWidth
        : rawWidth;

    // ──────────────────────────────────────────────
    // ⏱️ Calcolo altezza slot dinamica
    // ──────────────────────────────────────────────
    double slotHeight = LayoutConfig.slotHeight;

    if (screenHeight < 700) {
      slotHeight = LayoutConfig.slotHeight * 0.8;
    } else if (screenHeight > 1200) {
      slotHeight = LayoutConfig.slotHeight * 1.2;
    }

    slotHeight = slotHeight.roundToDouble();

    // 🔁 Aggiorna LayoutConfig globale
    LayoutConfig.updateSlotHeight(slotHeight);

    return ResponsiveLayout(
      columnWidth: columnWidth,
      slotHeight: slotHeight,
      maxVisibleStaff: dynamicMaxVisible,
    );
  }

  double get totalHeight => LayoutConfig.totalSlots * slotHeight;
}
--- FILE: lib/features/agenda/presentation/screens/day_view/multi_staff_day_view.dart ---
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../core/models/staff.dart';
import '../../../../../core/widgets/no_scrollbar_behavior.dart';
import '../../../domain/config/layout_config.dart';
import '../../../providers/agenda_providers.dart';
import '../../../providers/agenda_scroll_provider.dart';
import '../../../providers/appointment_providers.dart';
import '../../../providers/drag_layer_link_provider.dart';
import '../../../providers/is_resizing_provider.dart'; // 👈 nuovo import
import '../../../providers/layout_config_provider.dart';
import '../widgets/agenda_dividers.dart';
import '../widgets/current_time_line.dart';
import 'hour_column.dart';
import 'responsive_layout.dart';
import 'staff_column.dart';
import 'staff_header_row.dart';

class MultiStaffDayView extends ConsumerStatefulWidget {
  final List<Staff> staffList;
  const MultiStaffDayView({super.key, required this.staffList});

  @override
  ConsumerState<MultiStaffDayView> createState() => _MultiStaffDayViewState();
}

class _MultiStaffDayViewState extends ConsumerState<MultiStaffDayView> {
  Timer? _autoScrollTimer;
  late final ProviderSubscription<Offset?> _dragSub;
  final ScrollController _headerHCtrl = ScrollController();
  bool _isSyncing = false;

  static const double _scrollEdgeMargin = 100;
  static const double _scrollSpeed = 20;
  static const Duration _scrollInterval = Duration(milliseconds: 50);

  final GlobalKey _bodyKey = GlobalKey(); // registrazione RenderBox body

  @override
  void initState() {
    super.initState();

    _dragSub = ref.listenManual<Offset?>(dragPositionProvider, (prev, next) {
      if (next != null) {
        _startAutoScroll();
      } else {
        _stopAutoScroll();
      }
    });

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _registerBodyBox();
      _centerCurrentTimeLine();
      _setupHorizontalSync();
    });
  }

  void _registerBodyBox() {
    final box = _bodyKey.currentContext?.findRenderObject() as RenderBox?;
    if (box != null) {
      ref.read(dragBodyBoxProvider.notifier).set(box);
    }
  }

  void _setupHorizontalSync() {
    final bodyCtrl = ref
        .read(agendaScrollProvider(widget.staffList))
        .horizontalScrollCtrl;

    if (_headerHCtrl.hasClients && bodyCtrl.hasClients) {
      _headerHCtrl.jumpTo(bodyCtrl.offset);
    }

    bodyCtrl.addListener(() {
      if (_isSyncing || !_headerHCtrl.hasClients) return;
      _isSyncing = true;
      _headerHCtrl.jumpTo(bodyCtrl.offset);
      _isSyncing = false;
    });

    _headerHCtrl.addListener(() {
      if (_isSyncing || !bodyCtrl.hasClients) return;
      _isSyncing = true;
      bodyCtrl.jumpTo(_headerHCtrl.offset);
      _isSyncing = false;
    });
  }

  void _centerCurrentTimeLine() {
    final scrollState = ref.read(agendaScrollProvider(widget.staffList));
    final verticalCtrl = scrollState.verticalScrollCtrl;
    if (!verticalCtrl.hasClients) return;

    final now = DateTime.now();
    final minutes = now.hour * 60 + now.minute;
    final offset =
        (minutes / LayoutConfig.minutesPerSlot) * LayoutConfig.slotHeight;

    final renderBox = context.findRenderObject() as RenderBox?;
    if (renderBox == null) return;
    final viewHeight = renderBox.size.height;
    final availableHeight = viewHeight - LayoutConfig.headerHeight;

    const bias = 0.4;
    final target = (offset - availableHeight * bias).clamp(
      0.0,
      verticalCtrl.position.maxScrollExtent,
    );
    verticalCtrl.jumpTo(target);
  }

  void _startAutoScroll() {
    if (_autoScrollTimer != null) return;
    _autoScrollTimer = Timer.periodic(_scrollInterval, (_) {
      if (!mounted) return;

      final dragPos = ref.read(dragPositionProvider);
      if (dragPos == null) {
        _stopAutoScroll();
        return;
      }

      final scrollState = ref.read(agendaScrollProvider(widget.staffList));
      final verticalCtrl = scrollState.verticalScrollCtrl;
      if (!verticalCtrl.hasClients) return;

      final renderBox = context.findRenderObject() as RenderBox?;
      if (renderBox == null) return;

      final localPos = renderBox.globalToLocal(dragPos);
      final viewHeight = renderBox.size.height;
      final maxExtent = verticalCtrl.position.maxScrollExtent;
      final current = verticalCtrl.offset;

      double? newOffset;
      if (localPos.dy < _scrollEdgeMargin && current > 0) {
        newOffset = (current - _scrollSpeed).clamp(0, maxExtent);
      } else if (localPos.dy > viewHeight - _scrollEdgeMargin &&
          current < maxExtent) {
        newOffset = (current + _scrollSpeed).clamp(0, maxExtent);
      }

      if (newOffset != null && newOffset != current) {
        verticalCtrl.jumpTo(newOffset);
      }
    });
  }

  void _stopAutoScroll() {
    _autoScrollTimer?.cancel();
    _autoScrollTimer = null;
  }

  @override
  void dispose() {
    _dragSub.close();
    _stopAutoScroll();
    _headerHCtrl.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final appointments = ref.watch(appointmentsProvider);
    final scrollState = ref.watch(agendaScrollProvider(widget.staffList));
    final layout = ResponsiveLayout.of(
      context,
      staffCount: widget.staffList.length,
    );
    final slotHeight = ref.watch(layoutConfigProvider);
    final totalHeight = LayoutConfig.totalSlots * slotHeight;
    final hourW = LayoutConfig.hourColumnWidth;
    final link = ref.watch(dragLayerLinkProvider);

    // 🔹 blocca scroll se stiamo ridimensionando
    final isResizing = ref.watch(isResizingProvider);

    // Aggiorna periodicamente il bodyBox (in caso di resize)
    WidgetsBinding.instance.addPostFrameCallback((_) => _registerBodyBox());

    return Stack(
      children: [
        // BODY scrollabile con leader
        Positioned.fill(
          top: LayoutConfig.headerHeight,
          child: CompositedTransformTarget(
            key: _bodyKey,
            link: link,
            child: ScrollConfiguration(
              behavior: const NoScrollbarBehavior(),
              child: SingleChildScrollView(
                controller: scrollState.verticalScrollCtrl,
                // 👇 blocco dinamico scroll verticale
                physics: isResizing
                    ? const NeverScrollableScrollPhysics()
                    : const ClampingScrollPhysics(),
                child: Stack(
                  children: [
                    Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        SizedBox(width: hourW, child: const HourColumn()),
                        AgendaVerticalDivider(
                          height: totalHeight,
                          thickness: 1,
                        ),
                        Expanded(
                          child: ScrollConfiguration(
                            behavior: const NoScrollbarBehavior(),
                            child: SingleChildScrollView(
                              controller: scrollState.horizontalScrollCtrl,
                              scrollDirection: Axis.horizontal,
                              physics: const ClampingScrollPhysics(),
                              child: Row(
                                crossAxisAlignment: CrossAxisAlignment.start,
                                children: widget.staffList.asMap().entries.map((
                                  e,
                                ) {
                                  final i = e.key;
                                  final s = e.value;
                                  final last = i == widget.staffList.length - 1;
                                  final staffAppts = appointments
                                      .where((a) => a.staffId == s.id)
                                      .toList();

                                  return StaffColumn(
                                    staff: s,
                                    appointments: staffAppts,
                                    columnWidth: layout.columnWidth,
                                    showRightBorder:
                                        widget.staffList.length > 1 && !last,
                                  );
                                }).toList(),
                              ),
                            ),
                          ),
                        ),
                      ],
                    ),
                    CurrentTimeLine(hourColumnWidth: hourW),
                  ],
                ),
              ),
            ),
          ),
        ),

        // HEADER staff
        Positioned(
          top: 0,
          left: 0,
          right: 0,
          height: LayoutConfig.headerHeight,
          child: Material(
            elevation: 8,
            shadowColor: Colors.black.withOpacity(0.3),
            surfaceTintColor: Colors.transparent,
            child: DecoratedBox(
              decoration: const BoxDecoration(
                border: Border(
                  bottom: BorderSide(color: Color(0x1F000000), width: 0.5),
                ),
              ),
              child: Row(
                children: [
                  SizedBox(width: hourW),
                  Expanded(
                    child: ScrollConfiguration(
                      behavior: const NoScrollbarBehavior(),
                      child: SingleChildScrollView(
                        controller: _headerHCtrl,
                        scrollDirection: Axis.horizontal,
                        physics: const ClampingScrollPhysics(),
                        child: StaffHeaderRow(
                          staffList: widget.staffList,
                          scrollController: _headerHCtrl,
                          columnWidth: layout.columnWidth,
                          hourColumnWidth: hourW,
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        ),
      ],
    );
  }
}
--- FILE: lib/features/agenda/presentation/screens/day_view/staff_header_row.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../core/models/staff.dart';
import '../../../domain/config/layout_config.dart';
import '../../../providers/highlighted_staff_provider.dart';

class StaffHeaderRow extends ConsumerWidget {
  final List<Staff> staffList;
  final ScrollController
  scrollController; // non usato per scrollare qui, ma utile per offset/read
  final double columnWidth;
  final double hourColumnWidth; // NON usato per lasciare spazio iniziale

  const StaffHeaderRow({
    super.key,
    required this.staffList,
    required this.scrollController,
    required this.columnWidth,
    required this.hourColumnWidth,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final headerHeight = LayoutConfig.headerHeight;
    final highlightedId = ref.watch(highlightedStaffIdProvider);

    // ⚠️ Nessuna SizedBox iniziale qui! Lo spazio per l'ora è già messo nel parent.
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: staffList.asMap().entries.map((entry) {
        final index = entry.key;
        final staff = entry.value;
        final isLast = index == staffList.length - 1;
        final isHighlighted = highlightedId == staff.id;

        return Container(
          width:
              columnWidth, // larghezza minima/variabile decisa dal ResponsiveLayout
          height: headerHeight,
          decoration: BoxDecoration(
            color: isHighlighted
                ? staff.color.withOpacity(0.18)
                : staff.color.withOpacity(0.10),
            border: Border(
              right: BorderSide(
                color: isLast
                    ? Colors.transparent
                    : Colors.grey.withOpacity(0.25),
                width: 1,
              ),
            ),
          ),
          alignment: Alignment.center,
          padding: const EdgeInsets.symmetric(vertical: 8, horizontal: 6),
          child: Text(
            staff.name,
            maxLines: 1,
            overflow: TextOverflow.ellipsis,
            style: const TextStyle(
              fontWeight: FontWeight.w600,
              fontSize: 13,
              color: Colors.black87,
            ),
          ),
        );
      }).toList(),
    );
  }
}
--- FILE: lib/features/agenda/presentation/agenda_screen.dart ---
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../providers/staff_providers.dart';
import 'screens/day_view/multi_staff_day_view.dart';

class AgendaScreen extends ConsumerWidget {
  const AgendaScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // ✅ Recupera la lista dello staff dal provider
    final staffList = ref.watch(staffProvider);

    return SafeArea(
      // Passa la lista dello staff alla view
      child: MultiStaffDayView(staffList: staffList),
    );
  }
}
--- FILE: lib/features/agenda/agenda_feature.dart ---
/// Entry point modulare per la feature "Agenda"
/// Importa qui tutti i componenti pubblici dell'agenda.
/// Così altrove potrai scrivere semplicemente:
///   import 'package:agenda/features/agenda/agenda_feature.dart';

library;

export 'domain/config/agenda_theme.dart'; // se aggiungi un tema centralizzato
// ──────────────────────────────────────────────
// � Domain & Config
// ──────────────────────────────────────────────
export 'domain/config/layout_config.dart';
// Schermata di agenda (entry screen)
export 'presentation/agenda_screen.dart';
export 'presentation/screens/day_view/hour_column.dart';
// Vista principale (giornaliera multi-staff)
export 'presentation/screens/day_view/multi_staff_day_view.dart';
// ──────────────────────────────────────────────
// 🎨 Presentation layer
// ──────────────────────────────────────────────

// Layout e componenti core
export 'presentation/screens/day_view/responsive_layout.dart';
export 'presentation/screens/day_view/staff_column.dart';
export 'presentation/screens/day_view/staff_header_row.dart';
export 'presentation/screens/widgets/agenda_dividers.dart';
// ──────────────────────────────────────────────
// � Application (providers, notifiers, stato)
// ──────────────────────────────────────────────
export 'providers/agenda_scroll_provider.dart';
--- FILE: lib/features/staff/providers/staff_providers.dart ---
--- FILE: lib/features/staff/data/staff_api.dart ---
--- FILE: lib/features/staff/data/staff_repository.dart ---
--- FILE: lib/features/staff/presentation/staff_screen.dart ---
import 'package:flutter/material.dart';

class StaffScreen extends StatelessWidget {
  const StaffScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return const Center(
      child: Text('Schermata Staff', style: TextStyle(fontSize: 24)),
    );
  }
}
--- FILE: lib/features/services/services_feature.dart ---
--- FILE: lib/features/services/providers/services_providers.dart ---
--- FILE: lib/features/services/data/services_api.dart ---
--- FILE: lib/features/services/data/services_repository.dart ---
--- FILE: lib/features/services/domain/services.dart ---
--- FILE: lib/features/services/presentation/services_screen.dart ---
import 'package:flutter/material.dart';

import '../../../core/l10n/l10_extension.dart'; // 🌍

class ServicesScreen extends StatelessWidget {
  const ServicesScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Text(
        context.l10n.servicesTitle, // 🌍
        style: const TextStyle(fontSize: 24),
      ),
    );
  }
}
--- FILE: lib/main.dart ---
import 'package:agenda_frontend/app/app.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  runApp(const ProviderScope(child: MyApp()));
}
--- FILE: pubspec.yaml ---
name: agenda_frontend
description: "A new Flutter project."
publish_to: 'none'
version: 1.0.0+1

environment:
  sdk: ^3.9.2

dependencies:
  flutter:
    sdk: flutter
  flutter_localizations:
    sdk: flutter
  
  intl: ^0.20.2    
  flutter_riverpod: ^3.0.3
  riverpod_annotation: ^3.0.3
  go_router: ^16.2.4

dev_dependencies:
  build_runner: ^2.7.1
  riverpod_generator: ^3.0.3
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0

flutter:
  uses-material-design: true


flutter_intl:
  enabled: true
  class_name: L10n
  main_locale: it
  arb_dir: lib/core/l10n
  output_dir: lib/core/l10n